<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>预编译sql防御 | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>预编译sql防御</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-08-07T02:04:58.755Z" id="date"> 2023-08-07</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-08-07T02:07:07.554Z" id="updated"> 2023-08-07</time></div></span><br><span>Word Count: <div class="control">3k</div></span><br><span>Read Time: <div class="control">11 min</div></span></div></div><hr><div id="post-content"><h1>前言</h1>
<p>为啥用 <code>PreparedStatement</code> 预编译的 SQL 就不会有被 SQL 注入的风险？</p>
<p>第一时间我联想到的是八股文中关于 <code>Mybatis</code> 的脚本 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code> 的问题，不过再想想，为啥 <code>$&#123;&#125;</code> 会有 SQL 注入的风险，而 <code>#&#123;&#125;</code> 就没有？是因为到 <code>PreparedStatement</code> 做了什么处理吗？不知道。</p>
<p>然后我又想了想，预编译到底是个什么概念？预编译或者不预编译的 SQL 对数据库来说有什么区别吗？<code>PreparedStatement</code> 又在这个过程中扮演了怎样的角色？不知道。</p>
<p>好吧，我发现我确实对这个问题一无所知，看来需要亲自研究一下了。(这是真的)</p>
<h2 id="一、数据库预编译"><a href="#一、数据库预编译" class="headerlink" title="一、数据库预编译"></a>一、数据库预编译</h2>
<p>当我们说到关于持久层框架的功能，必然需要先想想这个功能的源头到底是不是直接通过数据库提供的。实际上和事务一样，SQL 预编译的功能也是需要数据库提供底层支持的。</p>
<h3 id="1、预编译SQL的用法"><a href="#1、预编译SQL的用法" class="headerlink" title="1、预编译SQL的用法"></a>1、预编译SQL的用法</h3>
<p>以 MySQL 为例，在 MySQL 中，所谓预编译其实是指先提交带占位符的 SQL 模板，然后为其指定一个 key，MySQL 先将其编译好，然后用户再拿着 key 和占位符对应的参数让 MySQL 去执行，用法有点像 python 中的 format 函数。</p>
<p>一个标准的预编译 SQL 的用法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> prepare_query <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from s_user where username = ?&#x27;</span> # 提交带有占位符的参数化 <span class="hljs-keyword">SQL</span>，也可以理解为 <span class="hljs-keyword">SQL</span> 模板<br><span class="hljs-keyword">set</span> <span class="hljs-variable">@name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;%王五&#x27;</span>; # 指定一个参数<br><span class="hljs-keyword">execute</span> prepare_query <span class="hljs-keyword">using</span> <span class="hljs-variable">@name</span>; # 指定参数化 <span class="hljs-keyword">SQL</span> 的 key 和参数，让 MySQL 自己去拼接执行<br></code></pre></td></tr></table></figure>
<p>先通过 <code>prepare</code> 设置一个 SQL 模板，然后通过 <code>execute</code> 提交参数，MySQL 会自行根据参数替换占位符，到最后执行的 SQL 就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;%王五&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="2、预编译的原理"><a href="#2、预编译的原理" class="headerlink" title="2、预编译的原理"></a>2、预编译的原理</h3>
<p>这里有个有意思问题，按网上的说法，<code>prepare</code> 执行的时候实际上 SQL 已经编译完了，所以可以防止注入，因为后续不管塞什么参数都不可能在调整语法树了，换个角度想，这是不是说明，如果我们一开始就让 <code>prepare</code> 执行的 SQL 模板的关键字变成占位符，是不是应该在这个时候就编译不通过？</p>
<p>比如，可以把查询的表名改成占位符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> prepare_query <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select * from ? where username = ?&#x27;</span><br><br># <span class="hljs-operator">&gt;</span> <span class="hljs-number">1064</span> <span class="hljs-operator">-</span> You have an error <span class="hljs-keyword">in</span> your <span class="hljs-keyword">SQL</span> syntax; <span class="hljs-keyword">check</span> the manual that corresponds <span class="hljs-keyword">to</span> your MySQL server version <span class="hljs-keyword">for</span> the <span class="hljs-keyword">right</span> syntax <span class="hljs-keyword">to</span> <br># use near <span class="hljs-string">&#x27;? where username = ?&#x27;</span> <span class="hljs-keyword">at</span> line <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>实际上也确实不行，因为编译时必须确定主表，因此在 <code>from</code> 后面加占位符会导致预编译不通过。</p>
<p>那么只在查询字段里面套一个嵌套查询呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">prepare</span> prepare_query <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;select ? from s_user&#x27;</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(select * from s_user) as q&#x27;</span>;<br><span class="hljs-keyword">EXECUTE</span> prepare_query <span class="hljs-keyword">using</span> <span class="hljs-variable">@c</span>;<br><br># 查询结果<br># (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user) <span class="hljs-keyword">as</span> q<br># (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user) <span class="hljs-keyword">as</span> q<br># (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user) <span class="hljs-keyword">as</span> q<br># ......<br></code></pre></td></tr></table></figure>
<p>查询成功了，不过得到的结果的固定的 <code>(select * from s_user)</code> 这个字符串，我们检查一下 MySQL 的执行日志，看看最终执行的 SQL 变成什么样了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Prepare</span>	<span class="hljs-keyword">select</span> ? <span class="hljs-keyword">from</span> s_user<br>Query	<span class="hljs-keyword">SET</span> <span class="hljs-variable">@c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;(select * from s_user) as q&#x27;</span><br>Query	<span class="hljs-keyword">EXECUTE</span> prepare_query <span class="hljs-keyword">using</span> <span class="hljs-variable">@c</span><br><span class="hljs-keyword">Execute</span>	<span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;(select * from s_user) as q&#x27;</span> <span class="hljs-keyword">from</span> s_user # 最终执行的<span class="hljs-keyword">SQL</span><br></code></pre></td></tr></table></figure>
<p>显然，<code>(select * from s_user)</code> <strong>参数本身被直接转义为了一串普通的字符串，我们试图“注入”的 SQL 片段完全不会生效</strong>。</p>
<p>换而言之，对于预编译 SQL 来说，我们作为模板的参数化 SQL 已经完成的编译过程，这段 SQL 包含几条有效语句？查哪张表？查哪些字段？作为条件的字段有哪些？…这些在 <code>prepare</code> 语句执行完后都是固定的，此后我们再通过 <code>execute</code> 语句塞进去的任何参数，都会进行转义，不会再作为 SQL 的一部分。这就是为什么说预编译 SQL 可以防止注入的原因。</p>
<h2 id="二、JDBC的预编译"><a href="#二、JDBC的预编译" class="headerlink" title="二、JDBC的预编译"></a>二、JDBC的预编译</h2>
<p>现在我们知道了预编译在数据库中是个怎样的功能，那么 JDBC 又是如何把这个功能提供给开发者使用的呢？</p>
<h3 id="1、PreparedStatement"><a href="#1、PreparedStatement" class="headerlink" title="1、PreparedStatement"></a>1、PreparedStatement</h3>
<p>从最开始学 JDBC 时，我们就知道通过 JDBC 连接数据库一般是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(JDBC_DRIVER); <span class="hljs-comment">// 加载驱动</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(URL, USERNAME, PASSWORD); <span class="hljs-comment">// 获取连接</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql); <span class="hljs-comment">// 获取sqlStatement</span><br>preparedStatement.setString(<span class="hljs-number">1</span>, foo); <span class="hljs-comment">// 设置参数</span><br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery(); <span class="hljs-comment">// 执行SQL</span><br></code></pre></td></tr></table></figure>
<p>这里有一个关键角色 <code>PreparedStatement</code>，相比起它的父接口 <code>Statement</code>，它最大的变化是多了各种格式为 <code>setXXX</code> 的、用于设置与占位符对应的参数的方法，显然它正对应着上文我们提到的预编译 SQL。</p>
<h3 id="2、虚假的“预编译”"><a href="#2、虚假的“预编译”" class="headerlink" title="2、虚假的“预编译”"></a>2、虚假的“预编译”</h3>
<p>不过事情显然没有这么简单，我们依然以 MySQL 为例，默认情况下 MySQL 驱动包提供的 <code>PreparedStatement</code> 实现类 <code>ClientPreparedStatement</code> 也能起到防止 SQL 注入的功能，但是方式跟我们想的不太一样。</p>
<p>假设现有如下代码，我们尝试模拟进行一次 SQL 注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from s_user where username = ?&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;王五&#x27; union select * from s_user&quot;</span>);<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br></code></pre></td></tr></table></figure>
<p>运行上述代码并正常的请求数据库，然后我们去数据库执行日志中查看对应的执行的 SQL 如下，会发现只有这么一行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Query <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;王五&#x27;&#x27; union select * from s_user&#x27;</span><br></code></pre></td></tr></table></figure>
<p>显然跟我们上文说到的先 <code>prepare</code> 再 <code>execute</code> 流程不同，带有占位符的原始 SQL 模板并没有在日志中出现，但是代码中的 <code>王五'</code> 确实也被转义为了 <code>'王五''</code>。</p>
<p><strong>数据库到底收到了哪些数据？</strong></p>
<p>那么数据库到底拿到的就是这条 SQL，还是原始的 SQL 模板 + 参数呢？</p>
<p>为了了解这一点，我们打断点跟踪 <code>ClientPreparedStatement.executeQuery</code> 方法，一路找到它组装请求数据库的参数的那一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Message</span> <span class="hljs-variable">sendPacket</span> <span class="hljs-operator">=</span> ((PreparedQuery&lt;?&gt;) <span class="hljs-built_in">this</span>.query).fillSendPacket();<br></code></pre></td></tr></table></figure>
<p>最后我们会进入 <code>AbstractPreparedQuery.fillSendPacket</code> 这个方法，这里主要干的事是把我们带占位符的原始 SQL 模板和参数合并为最终要执行的 SQL ，并封装到 <code>NativePacketPayload</code> 对象，用于在后续发起 TCP 请求时把 SQL 参数转为二进制数据包。</p>
<p>为了验证这一点，我们先拿到 <code>sendPacket</code> 对象，再获取里面的字节数组，最后转为字符串：</p>
<p class='item-img' data-src='image-20230807100659050.png'><img src="image-20230807100659050.png" alt="image-20230807100659050"></p>
<p>可以看到内容就是已经格式化完的 SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;王五&#x27;&#x27; union select * from s_user&#x27;</span><br></code></pre></td></tr></table></figure>
<p>现在答案就很明显了，转义在 <code>preparedStatement.setString</code> 方法调用的时候完成，而 <code>PreparedStatement</code> 在<strong>发起请求前就把转义后的参数和 SQL 模板进行了格式化，最后发送到 MySQL 的时候就是一条普通的 SQL</strong>。</p>
<p>鉴于此，我们可以说 MySQL 提供的 <code>PreparedStatement</code> 在默认情况下是假的“预编译”，它只不过在设置参数的时候帮我们对参数做了一下转义，但是最后发送到数据库的依然是普通的 SQL，而不是按预编译 SQL 的方式去执行。</p>
<h3 id="3、真正的预编译"><a href="#3、真正的预编译" class="headerlink" title="3、真正的预编译"></a>3、真正的预编译</h3>
<p>好吧，那既然 MySQL 提供了这个预编译的功能，那通过 JDBC 肯定也还是有办法用上真正的预编译功能的，实际上要做到这点也很简单，就是直接在驱动的 url 上配上 <code>useServerPrepStmts=true</code> ，这样就会真正的启用 MySQL 的预编译功能。</p>
<p>依然以上文的代码为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from s_user where username = ?&quot;</span>;<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>preparedStatement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;王五&#x27; union select * from s_user&quot;</span>);<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br></code></pre></td></tr></table></figure>
<p>设置了 <code>useServerPrepStmts=true</code> 后再执行代码，去数据库查看执行日志有：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Execute</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;王五\&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_user<span class="hljs-string">&#x27;</span><br><span class="hljs-string">Prepare select * from s_user where username = ?</span><br></code></pre></td></tr></table></figure>
<p>此时 MySQL 的预编译功能就真正的生效了。</p>
<p>我们回到 <code>ClientPreparedStatement.executeQuery</code> 创建 <code>sendPacket</code> 地方看，此时通过 <code>((PreparedQuery&lt;?&gt;) this.query).fillSendPacket();</code> 拿到的 <code>Message</code> 对象是 <code>null</code>，然后进一步追踪到最后向 MySQL 发送请求的地方 <code>NativeSession.execSQL</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Resultset</span>&gt; T <span class="hljs-title function_">execSQL</span><span class="hljs-params">(Query callingQuery, String query, <span class="hljs-type">int</span> maxRows, NativePacketPayload packet, <span class="hljs-type">boolean</span> streamResults,</span><br><span class="hljs-params">                                       ProtocolEntityFactory&lt;T, NativePacketPayload&gt; resultSetFactory, ColumnDefinition cachedMetadata, <span class="hljs-type">boolean</span> isBatch)</span> &#123;<br><br>    <span class="hljs-comment">// ... ...</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果 sendPacket 为 null，则调用 sendQueryString 方法，把原始 sql 和参数序列化为二进制数据包</span><br>        <span class="hljs-keyword">return</span> packet == <span class="hljs-literal">null</span><br>            ? ((NativeProtocol) <span class="hljs-built_in">this</span>.protocol).sendQueryString(callingQuery, query, <span class="hljs-built_in">this</span>.characterEncoding.getValue(), maxRows, streamResults, cachedMetadata, resultSetFactory)<br>            <span class="hljs-comment">// 否则调用 sendQueryPacket 方法，直接发送数据包</span><br>            : ((NativeProtocol) <span class="hljs-built_in">this</span>.protocol).sendQueryPacket(callingQuery, packet, maxRows, streamResults, cachedMetadata, resultSetFactory);<br><br>    &#125;<br><br>    <span class="hljs-comment">// ... ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>更具体的实现就不看了，基本都是关于序列化请求参数的逻辑。</p>
<h2 id="三、Myabtis占位符与预编译"><a href="#三、Myabtis占位符与预编译" class="headerlink" title="三、Myabtis占位符与预编译"></a>三、Myabtis占位符与预编译</h2>
<p>至此问题真相大白了，不过还是顺带扯一下八股文常提到的 Mybatis 占位符 <code>#&#123;&#125;</code> 与 <code>$&#123;&#125;</code> 是如何影响 SQL 注入问题的。</p>
<p>当然，看完上面的内容其实就已经很好猜到原因了：</p>
<ul>
<li><code>#&#123;&#125;</code> 对应的内容会作为 SQL 参数的一部分通过 <code>PreparedStatement.setXXX</code> 装入请求；</li>
<li><code>$&#123;&#125;</code> 对应的内容会直接作为 SQL 模板的一部分，而不会视为独立的请求参数；</li>
</ul>
<p>在 Mybatis 中，用于解析占位符的类为 <code>GenericTokenParser</code> ，根据它我们很容易在源码中找到占位符的处理方法，从而验证我们的猜想：</p>
<p>其中，<code>#&#123;&#125;</code> 占位符在 <code>SqlSourceBuilder.ParameterMappingTokenHandler.handleToken</code> 方法中处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleToken</span><span class="hljs-params">(String content)</span> &#123;<br>    parameterMappings.add(buildParameterMapping(content));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;?&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见 <code>#&#123;&#125;</code> 占位符会被解析为 <code>?</code> 占位符，而对于的数据会被添加到 <code>parameterMappings</code> 用于后续塞到 <code>PreparedStatement</code>。</p>
<p>而 <code>$&#123;&#125;</code> 占位符在 <code>PropertyParser.VariableTokenHandler.handleToken</code> 方法中被处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleToken</span><span class="hljs-params">(String content)</span> &#123;<br>    <span class="hljs-keyword">if</span> (variables != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> content;<br>        <span class="hljs-keyword">if</span> (enableDefaultValue) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">separatorIndex</span> <span class="hljs-operator">=</span> content.indexOf(defaultValueSeparator);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">defaultValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (separatorIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>                key = content.substring(<span class="hljs-number">0</span>, separatorIndex);<br>                defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (defaultValue != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> variables.getProperty(key, defaultValue);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (variables.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> variables.getProperty(key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;$&#123;&quot;</span> + content + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>若占位符符合规范，则占会根据占位符中的内容去用户给定的参数中取值，并且让值直接替换掉原本 SQL 脚本中的 <code>$&#123;&#125;</code> 占位符。</p>
<p><strong>这就是“ <code>Mybatis</code> 用 <code>#&#123;&#125;</code> 而不是 <code>$&#123;&#125;</code> 可以防止 SQL 注入的真相</strong>。</p>
<h1>总结</h1>
<p>回顾一下全文，当我们说“预编译”的时候，其实这个功能来自于数据库的支持，它的原理是先编译带有占位符的 SQL 模板，然后在传入参数让数据库自动替换 SQL 中占位符并执行，在这个过程中，由于预编译好的 SQL 模板本身语法已经定死，因此后续所有参数都会被视为不可执行的非 SQL 片段被转义，因此能够防止 SQL 注入。</p>
<p>当我们通过 JDBC 使用 <code>PreparedStatement</code> 执行预编译 SQL 的时候，此处的预编译实际上是假的预编译（至少 MySQL 是如此，不过其他数据库仍待确认），<code>PreparedStatement</code> 只是在设置参数的时候自动做了一层转义，最终提交给数据库执行的 SQL 仍然是单条的非预编译 SQL。</p>
<p>而当我们通过在驱动 url 上开启 <code>useServerPrepStmts</code> 配置后，预编译就会真正的生效，驱动包发往数据库的请求就会分成带占位符的 SQL 模板和参数，到了数据库再由数据库完成格式化并执行。</p>
<p>此外，八股文常提到的“<code>Mybatis</code> 的 <code>#&#123;&#125;</code> 相比 <code>$&#123;&#125;</code> 可以防止 SQL 注入”这一点，本质上是因为 <code>#&#123;&#125;</code> 占位符会被解析为 SQL 模板中的 <code>?</code> 占位符，而 <code>$&#123;&#125;</code> 占位符会被直接解析为 SQL 模板的一部分导致的。</p>
<p>最后脑补一下，由于 <code>useServerPrepStmts</code> 不开启时 <code>PreparedStatement</code> 的预编译实际上是假的预编译，所以理论上使用 <code>#&#123;&#125;</code> 也并非绝对安全，如果有办法绕过 <code>PreparedStatement</code> 的检查，那么数据库拿到被注入过的 SQL 直接执行，依然有暴毙的风险。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/08/07/%E6%B5%85%E6%9E%90%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/">← Next 浅析目录穿越</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/08/07/%E6%B5%85%E6%9E%90%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/">浅析文件操作漏洞 Prev →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.</span> <span class="toc-text">一、数据库预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%A2%84%E7%BC%96%E8%AF%91SQL%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、预编译SQL的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、预编译的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDBC%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.2.</span> <span class="toc-text">二、JDBC的预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81PreparedStatement"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、PreparedStatement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%99%9A%E5%81%87%E7%9A%84%E2%80%9C%E9%A2%84%E7%BC%96%E8%AF%91%E2%80%9D"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、虚假的“预编译”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、真正的预编译</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Myabtis%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%B8%8E%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.</span> <span class="toc-text">三、Myabtis占位符与预编译</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>