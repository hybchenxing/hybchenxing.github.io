<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>汇编基础指令 | hybcx</title><meta name="keywords" content="reverse系列"><meta name="author" content="hybcx,19815455497@163.com"><meta name="copyright" content="hybcx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="汇编基础指令"><meta name="application-name" content="汇编基础指令"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="汇编基础指令"><meta property="og:url" content="http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/index.html"><meta property="og:site_name" content="hybcx"><meta property="og:description" content="0x01 什么是汇编语言 汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：  汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg"><meta property="article:author" content="hybcx"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg"><meta name="description" content="0x01 什么是汇编语言 汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：  汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d98ea8480e5ec98a243adfc7bd46b93a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"向✌们无限学习","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3JLPGIZJOJw6Nvu2","LingQueMonitorID":"3JLPOLHV5W6IAty5"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: hybcx","link":"链接: ","source":"来源: hybcx","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'hybcx',
  title: '汇编基础指令',
  postAI: '',
  pageFillDescription: '0x01 什么是汇编语言, 1.1 汇编语言产生的原因, 1.2 汇编与二进制的关系, 0x02 寄存器, 2.1 寄存器作用, 2.2 存取速度比较, 2.3 寄存器分类, 2.4 常用寄存器用途, 2.5 寄存器EAX、AX、AH、AL的关系, 2.6 物理地址, 2.7 段寄存器, 0x03 内存模型：Heap, 0x04 内存模型：Stack, 0x05 CPU 指令, 5.1 实例, 5.2 push 指令, 5.3 call 指令, 5.4 mov 指令, 5.5 add 指令, 5.6 pop 指令, 5.7 ret 指令, 0x06 汇编语言指令, 6.1 数据传送指令, 6.2 算术运算指令, 6.3 逻辑运算指令, 6.4 循环控制指令, 6.5 转移指令, 6.6 JCC指令组, 6.7 堆栈指令, 6.8 跳转指令, 0x07 linux 和 windows 下汇编的区别, 0x08 什么是字长, 0x09 大端与小端的比较, 9.1 概念, 9.2 可读性, 9.3 检查奇偶性, 9.4 检查正负号, 9.5 比较大小, 9.6 乘法, 9.7 任意精度整数, 9.8 更改类型, 9.9 总结, 0x10 总结, 0x11 冯诺依曼结构体系, 11.1 计算机的基本硬件组成, 11.2 冯·诺依曼体系结构, 12.2  冯·诺依曼瓶颈, 12.3 总结, 0x12 参考文章什么是汇编语言汇编语言是最接近机器语言的编程语言引用百科中的一段话解释为汇编语言是一种用于电子计算机微处理器微控制器或其他可编程器件的低级语言亦称为符号语言在汇编语言中用助记符代替机器指令的操作码用地址符号或标号代替指令或操作数的地址汇编语言又被称为第二代计算机语言汇编语言产生的原因对于绝大多数人来说二进制程序是不可读的当然有能人可以读比如第一代程序员但这类人快灭绝了直接看二进制不容易看出来究竟做了什么事情比如最简单的加法指令二进制表示为如果它混在一大串字符串中就很难把它找出来所以汇编语言主要就是为了解决二进制编码的可读性问题汇编与二进制的关系换句话来说汇编语言就是把给机器看的二进制编码翻译成人话汇编指令是机器指令的助记符与机器指令是一一对应的关系是一种便于阅读和记忆的书写格式有效地解决了机器指令编写程序难度大的问题并且使用编译器可以很方便的把汇编程序转译成机器指令程序比如之前提到的加法指令对应的汇编指令是在调用汇编器时就会把翻译成寄存器说到汇编指令不得不提到寄存器寄存器本身是用来存数据的因为本身只负责逻辑运算数据需要单独储存在其他的地方但是对于不熟悉寄存器的人来说会有疑惑数据不是存在硬盘上吗或者说数据不是存在内存中吗这些想法都没错那么寄存器是用来做什么的呢寄存器作用其实硬盘内存都是用来存储数据的但是的运算速度远高于内存的读写速度更不用说从硬盘上取数据了所以为了避免被拖慢速度影响效率都自带一级缓存和二级缓存一些甚至增加了三级缓存从这些缓存中读写数据要比内存快很多但是还是无法使用飞速运转的所以才会有寄存器的存在寄存器不是后来增加的在最初的计算中就已经设计出来相比而言多级缓存出现的更晚一些通常那些最频繁读写的数据都会被放在寄存器里面优先读写寄存器再通过寄存器缓存跟内存来交换数据达到缓冲的目的因为可以通过名称访问寄存器这样访问速度是最快的因此也被称为零级缓存存取速度比较通过上面的叙述我们可以知道存取速度从高到低分别是寄存器级缓存级缓存级缓存内存硬盘关于它们的存取速度举个例子很容易就能明白了比如我们做菜工作时取手中寄存器正拿着的肉和蔬菜肯定是最快的如果没有就需要把案板上级缓存处理好的菜拿过来如果案板上没有就在更远一点的洗菜池级缓存中找一找还没找到的话就要到冰箱级缓存中看一看了这时发现家里真没有那去楼下的菜店内存去买点吧转了一圈发现没有想要的最后还是开车去农贸市场硬盘买吧通过上面这个例子应该能明白它们的速度关系了既然缓存这么快为什么不用缓存代替内存或者将级缓存都换成级缓存呢这里边有一个成本问题速度越快对应着价格越高如果你买过机械硬盘和固态硬盘应该很容易就理解了寄存器分类常用的寄存器有个据说现在寄存器总数已经超过个了等我找到相关资料再来补充上面这几个寄存器是最常用的这些名字也常常出现在汇编的代码中其中是通用寄存器存放一般性数据个位寄存器可以存储位的数据为了向上一代兼容这个寄存器可以分为我们常说的位位是指数据总线的宽度或根数而寄存器是暂存数据和中间结果的单元因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的所以位对应的寄存器也应该是位的常用寄存器用途上面提到大个寄存器都有其特定的用途我们以位为例简单说明下这些寄存器的作用整理如下表寄存器含义用途包含寄存器累加寄存器常用于乘除法和函数返回值基址寄存器常做内存数据的指针或者说常以它为基址来访问内存计数器寄存器常做字符串和循环操作中的计数器数据寄存器常用于乘除法和指针来源索引寄存器常做内存数据指针和源字符串指针目的索引寄存器常做内存数据指针和目的字符串指针堆栈指针寄存器只做堆栈的栈顶指针不能用于算术运算与数据传送基址指针寄存器只做堆栈指针可以访问堆栈内任意地址经常用于中转中的数据也常以它为基址来访问堆栈不能用于算术运算与数据传送寄存器的关系在上面的图标中每个常用寄存器后面还有其他的名字它们是同一个寄存器不同用法下的不同名字比如在位上是位的寄存器而是的低位是的高位而是的低位它们的对照关系如下个字节个字节个字节个字节物理地址要想访问内存单元就要给出内存单元的物理地址内存是一个一维的线性空间每一个内存单元都有唯一的地址这个地址就是物理地址是位结构的其数据总线是位宽但地址总线是位寻址能力但内部是位结构内部一次性处理传输地址为位所以在内部采用个位地址合成方式形成一个位的物理地址进行内存寻址物理地址段地址偏移地址段地址即左移位其本质含义是在访问内存时用一个基础地址段地址和相对于基础地址的偏移地址相加得到物理地址由于偏移地址为位位地址的寻址能力是所以一个段的长度最大为可以用不同的段地址和偏移地址形成同一个物理地址段寄存器有个段寄存器为代码段寄存器为指令指针寄存器任意时刻将指向的内容当做当前指令执行工作过程从指向的内存单元读指令指令进指令缓冲器指向下一条指令执行指令跳到步骤重复这个过程根据什么将内存中的信息看做指令答案是将指向的内存单元的内容看做指令使用段地址偏移地址或寄存器修改或的地址在编程时根据需要可以将长度为的一组代码存在一组连续的内存单元中这段内存单元叫做代码段同样的可以根据需要将长度为的一组内存单元专门存储数据这段内存单元叫做数据段自动取寄存器中的数据为内存单元的段地址例如表示将寄存器的值复制到段地址为偏移地址为的内存单元中字在内存中存储时用个地址连续的内存单元存放字的低字节放在低地址单元高字节放在高地址单元标志寄存器标志寄存器作用存储相关指令某些执行结果为执行相关指令提供行为依据控制相关工作方式中有个叫寄存器共位每一位代表专门的含义第位零标志位相关指令执行后结果为则不为则第位奇偶标志位相关指令执行后结果所有位中的个数为偶数否则第位符号标志位相关指令执行后结果是否为负结果为负否则第位进位标志位对于无符号数运算记录运算结果最高有效位向更高位的进位值借位值第位溢出标志位对于有符号数运算是否发生溢出溢出则否则第位方向标志位在串处理指令中控制操作后增减每次操作后递增否则递减内存模型寄存器只能存放很少量的数据大多数时候要指挥寄存器直接跟内存交换数据所以除了寄存器还必须了解内存怎么储存数据程序运行的时候操作系统会给它分配一段内存用来储存程序和运行产生的数据这段内存有起始地址和结束地址比如从到起始地址是较小的那个地址结束地址是较大的那个地址程序运行过程中对于动态的内存占用请求比如新建对象或者使用命令系统就会从预先分配好的那段内存之中划出一部分给用户具体规则是从起始地址开始划分实际上起始地址会有一段静态数据这里忽略举例来说用户要求得到个字节内存那么从起始地址开始给他分配一直分配到地址如果再要求得到个字节那么就分配到这种因为用户主动请求而划分出来的内存区域叫做堆它由起始地址开始从低位地址向高位地址增长的一个重要特点就是不会自动消失必须手动释放或者由垃圾回收机制来回收内存模型除了以外其他的内存占用叫做栈简单说是由于函数运行而临时占用的内存区域请看下面的例子上面代码中系统开始执行函数时会为它在内存里面建立一个帧所有的内部变量比如和都保存在这个帧里面函数执行结束后该帧就会被回收释放所有的内部变量不再占用空间如果函数内部调用了其他函数会发生什么情况上面代码中函数内部调用了函数执行到这一行的时候系统也会为新建一个帧用来储存它的内部变量也就是说此时同时存在两个帧和一般来说调用栈有多少层就有多少帧等到运行结束它的帧就会被回收系统会回到函数刚才中断执行的地方继续往下执行通过这种机制就实现了函数的层层调用并且每一层都能使用自己的本地变量所有的帧都存放在由于帧是一层层叠加的所以叫做栈生成新的帧叫做入栈英文是栈的回收叫做出栈英文是的特点就是最晚入栈的帧最早出栈因为最内层的函数调用最先结束运行这就叫做后进先出的数据结构每一次函数执行结束就自动释放一个帧所有函数执行结束整个就都释放了是由内存区域的结束地址开始从高位地址向低位地址分配比如内存区域的结束地址是第一帧假定是字节那么下一次分配的地址就会从开始第二帧假定需要字节那么地址就会移动到提供入栈和出栈的指令和任意时刻寄存器指向栈顶元素指令执行向指向的字单元送入数据指令执行从指向的字单元读数据在编程时要时刻注意栈顶越界的问题用栈来可以暂存以后需要恢复的寄存器中的内容和实质上是一种内存传送指令同样的编程时我们可以将长度为的一组连续内存单元当做栈空间使用叫做栈段一个栈段的容量最大为指令实例了解寄存器和内存模型以后就可以来看汇编语言到底是什么了下面是一个简单的程序将这个程序转成汇编语言上面的命令执行以后会生成一个文本文件里面就是汇编语言包含了几十行指令这么说吧一个高级语言的简单操作底层可能由几个甚至几十个指令构成依次执行这些指令完成这一步操作经过简化以后大概是下面的样子可以看到原程序的两个函数和对应两个标签和每个标签里面是该函数所转成的运行流程每一行就是执行的一次操作它又分成两部分就以其中一行为例这一行里面是指令是该指令要用到的运算子一个指令可以有零个到多个运算子下面我就一行一行讲解这个汇编程序建议读者最好把这个程序在另一个窗口拷贝一份省得阅读的时候再把页面滚动上来指令根据约定程序从标签开始执行这时会在上为建立一个帧并将所指向的地址写入寄存器后面如果有数据要写入这个帧就会写在寄存器所保存的地址然后开始执行第一行代码指令用于将运算子放入这里就是将写入这个帧虽然看上去很简单指令其实有一个前置操作它会先取出寄存器里面的地址将其减去个字节然后将新地址写入寄存器使用减法是因为从高位向低位发展个字节则是因为的类型是占用个字节得到新地址以后就会写入这个地址开始的四个字节第二行也是一样指令将写入这个帧位置紧贴着前面写入的这时寄存器会再减去个字节累计减去指令第三行的指令用来调用函数上面的代码表示调用函数这时程序就会去找标签并为该函数建立一个新的帧下面就开始执行的代码这一行表示将寄存器里面的值写入这个帧这是因为后面要用到这个寄存器就先把里面的值取出来用完后再写回去这时指令会再将寄存器里面的地址减去个字节累计减去指令指令用于将一个值写入某个寄存器这一行代码表示先将寄存器里面的地址加上个字节得到一个新的地址然后按照这个地址在取出数据根据前面的步骤可以推算出这里取出的是再将写入寄存器下一行代码也是干同样的事情上面的代码将寄存器的值加个字节再按照这个地址在取出数据这次取出的是将其写入寄存器指令指令用于将两个运算子相加并将结果写入第一个运算子上面的代码将寄存器的值即加上寄存器的值即得到结果再将这个结果写入第一个运算子寄存器指令指令用于取出最近一个写入的值即最低位地址的值并将这个值写入运算子指定的位置上面的代码表示取出最近写入的值即寄存器的原始值再将这个值写回寄存器因为加法已经做完了寄存器用不到了注意指令还会将寄存器里面的地址加即回收个字节指令指令用于终止当前函数的执行将运行权交还给上层函数也就是当前函数的帧将被回收可以看到该指令没有运算子随着函数终止执行系统就回到刚才函数中断的地方继续往下执行上面的代码表示将寄存器里面的地址手动加上个字节再写回寄存器这是因为寄存器的是的写入开始地址前面的操作已经回收了个字节这里再回收个字节等于全部回收最后函数运行结束指令退出程序执行汇编语言指令终于说到汇编常用指令了因为和下的汇编语法是有些不同的所以下面我们先通过下的汇编指令来简单学习一下后续再来比较两者的不同数据传送指令指令名称示例备注传送指令将数据从移动到进栈指令把源操作数压入堆栈出栈指令从栈顶弹出字数据到算术运算指令指令名称示例备注加法指令在基础上加减法指令在基础上减加指令在基础上加减指令在基础上减逻辑运算指令指令名称示例备注取反运算指令把操作数按位取反与运算指令把和进行与运算之后送回或运算指令把和进行或运算之后送回异或运算把和进行异或运算之后送回循环控制指令指令名称示例备注计数循环指令使的值减当的值不为的时候跳转至否则执行之后的语句转移指令指令名称示例备注无条件转移指令无条件地转移到标号为的位置过程调用指令直接调用条件转移指令时跳转到标号为的位置条件转移指令时跳转到标号为的位置指令组是指是条件该条件与标志寄存器中的标志位息息相关通过获取标志位的值判断是否满足条件而是否执行操作对应了高级语言中的比较运算指令中文含义检查符号位典型应用若为则跳转若相等则跳转若不为则跳转若不相等则跳转若为负则跳转若为非负数则跳转若出现次数为偶数则跳转若出现次数为奇数则跳转若溢出则跳转若无溢出则跳转若进位则跳转若低于则跳转若不高于等于则跳转若无进位则跳转若不低于则跳转若高于等于则跳转若低于等于则跳转若不高于则跳转或若不低于等于则跳转若高于则跳转或若小于则跳转若不大于等于则跳转若不小于则跳转若大于等于则跳转若小于等于则跳转若不大于则跳转或若不小于等于则跳转若大于则跳转且堆栈指令栈顶指针寄存器记录当前使用的地址栈的内存空间是存大地址开始使用的栈底指针寄存器记录栈开始的位置我们可以使用指令将数据到寄存器指定的位置然后使用或者指令将寄存器的值偏移对应的数据宽度值实现数据的入栈和出栈操作基于这样的原理汇编中提供了和命令向栈中写入一个字节栈顶指针偏移一字节以上两个操作等同于一个操作将写入到保存的地址处同时偏移一个数据宽度中的值入栈地址该地址处的值入栈出栈同理将栈顶的元素取出放入寄存器中保存同时偏移一个数据宽度跳转指令将程序跳转到指定的地址执行通过改变中的值实现将程序跳转到指定的地址跳转前将下一次执行的地址保存到栈中用来记录跳转前的位置然后改变中的值使得去执行其他地址的指令当执行结束需要返回原来的地址时从栈中取出跳转签到的地址赋值到寄存器中即可回到跳转前的状态从栈中取出保存的地址赋值给用作下次执行使用这两个指令需要理解寄存器的作用当一个程序被编译完成之后程序的执行方法即已经确定即的顺序进行执行且他们使用的内存空间说连续的计算机执行一行指令后下一次要执行的内容都保存在寄存器保存的地址处所以寄存器指向的内容就是程序下一次执行的指令也就是说执行时寄存器中保存的是的地址这样执行后将会获取的信息并执行如果是一个或者指令执行依次这条指令表示将中的值改为的地址所以下一次执行的即为指令由此实现了跳转这样的方式当程序跳转到指令后程序无法返回指令了因为我们找不到的地址想要重新回到指令需要将的地址保存使用时取回即可通常是将其入栈这样就和指令的使用方式相同了地址修改寄存器中的值地址跳转到指定地址执行该地址的指令跳转前将下一行地址入栈和下汇编的区别前面说到和下的汇编语法是不同的其实两种语法的不同和系统不同没有绝对的关系一般在上会使用编译器而在上会使用微软的也就是所以产生不同的代码是因为编译器不同下采用的是的汇编语法格式采用的是汇编语法格式差异引用寄存器名字赋值操作数顺序寄存器立即数指令前缀寄存器间接寻址数据类型大小操作码后加后缀字母位位位操作数前面加的格式什么是字长内存以字节为单位一个字节是个比特位可以表示个数大小为位的二进制数是从开始到这个值中的一个两个字节被称为一个字两个字被称为四个字节位也即双字四字是八个字节位这些连续的字节要按什么样的顺序排列和解释这就涉及到端序的范畴了字节的排列方式有两个通用规则大端序与小端序大端序将数据的低位字节存放在内存的高位地址高位字节存放在低位地址这种排列方式与数据用字节表示时的书写顺序一致符合人类的阅读习惯小端序将数据的低位字节放在较小的地址处高位放在较大的地址处小端序与人类的阅读习惯相反但更符合计算机读取内存的方式因为读取内存中的数据时是从低地址向高地址方向进行读取的大端与小端的比较概念字节序指的是多字节数据的内存排列顺序这样说比较抽象使用图形解释就很好懂内存好比一排房间每个字节是一间房每间房都有门牌号内存地址从号开始然后是号号号字节的地址小称为低位内存号字节的地址大称为高位内存现在有一个数值要放进这些房间每个房间放一个数字那么有两种放法第一种放法是第一位放在低位地址号最后一位放在高位地址号这种排列称为大端序简称即大头在前因为是的大头最重要的数字第二种放法是第一位放在高位地址号地址最后一位放在低位地址号地址这种排列称为小端序简称即小头在前大端序和小端序合称字节序这两个名字来自世纪的英国小说格列佛游记某国分成两派一派认为鸡蛋应该从大头吃起称为大端派另一派认为鸡蛋应该从小头吃起称为小端派两派相执不下谁也无法说服谁最后甚至为此交战可读性对于人类来说不同字节序的可读性是不一样的大部分国家的阅读习惯是从左到右阅读大端序的最高位在左边最低位在右边符合阅读习惯所以对于这些国家的人来说从左到右的大端序的可读性更好但是现实中从右到左的小端序虽然可读性差但应用更广泛和这两种架构都采用小端序这是为什么或者换一种问法两种不同的字节序为什么会并存统一规定只使用一种难道不是更方便吗原因是它们有各自的适用场景某些场景大端序有优势另一些场景小端序有优势下面就逐一分析检查奇偶性小端序优势最明显的大概就是检查奇偶性即通过查看个位数确定某个数字是奇数还是偶数以为例大端序从左到右排列计算机必须一直读到最后一位的个位数才能确定这是偶数小端序是从右到左排列个位数在第一位所以只要读取第一位就能确定它是偶数检查正负号一个类似的场景是检查正负号确定一个数是正数还是负数大端序的符号位在左边第一位小端序的符号位在右边最后一位所以大端序有优势只看第一位就能知道是不是负数比较大小下一个操作是比较大小现在有三个数字需要比较大小上图是大端序排列因为是从左到右排列所以三个数字在右边个位数对齐比较大小时计算机就不得不读取每一个数的所有位直到个位数再进行比较如果改成小端序就是下面的排列方式小端序是从右到左所以三个数字在第一位对齐计算机就不需要读取所有位哪个数字先读不到下一位就是最小的比如这个数字就没有第二位所以读到第二位时就知道它是最小的所以比较大小时小端序有优势乘法接下来再看乘法操作乘法是逐位相乘每一轮乘法都要向前进位上图是大端序的乘以大端序的乘法是向左进位也就是向左边扩展必须等到每一轮的结果都出来上例是四轮再相加统一写入内存如果改成小端序的乘法就不需要等待下一轮的结果每一轮都可以直接写入内存上图是小端序的乘以小端序的乘法是向右进位也就是向右边扩展左边的边界不变每一轮结果写入内存后就不需要移动后面有变化只需要改动对应的位就行了因此小端序的乘法有明显优势任意精度整数上一个例子的从低位开始计算的特性对于任意精度整数特别有用任意精度整数又称大整数可以存放任意大小的整数它的内部实现是把整数分成一个个较小的单位通常是无符号位整数或无符号位整数按顺序组合在一起如果是大端序第一个就是这个整数最大的部分运算时一旦这个数发生变化需要进位后面的所有位都必须移动和改写小端序发生进位时往往就不需要所有位移动小端序的另一个好处是如果逐字节的运算从个位数开始比如乘法和加法可以从左到右依次运算一个个算完上一个再读取下一个大端序就不行必须读取整个数以后再进行运算更改类型最后一个例子是语言有一种操作可以强制改变变量的数据类型比如把位整数强行改变为位整数上图中位整数更改为位整数大端序是截去前面两个字节这时指向这个地址的指针必须向后移动两个字节小端序就没有这个问题截去的是后面两个字节第一位的地址是不变的所以指针不需要移动总结综上所述大端序和小端序各自的优势如下如果需要逐位运算或者需要到从个位数开始运算都是小端序占优势反之如果运算只涉及到高位或者数据的可读性比较重要则是大端序占优势总结汇编指令是机器指令的助记符与机器指令是一一对应的的汇编语法格式和汇编语法格式的是不同的常用寄存器存取速度从高到低分别是寄存器级缓存级缓存级缓存内存硬盘常用的汇编指令冯诺依曼结构体系计算机的基本硬件组成早年要自己组装一台计算机要先有三大件内存和主板在这三大件中我们首先要说的是它是计算机最重要的核心配件全名你肯定知道叫中央处理器为什么说是最重要的呢因为计算机的所有计算都是由来进行的自然也是整台计算机中造价最昂贵的部分之一是一个超级精细的印刷电路版图片来源第二个重要的配件就是内存你撰写的程序打开的浏览器运行的游戏都要加载到内存里才能运行程序读取的数据计算得到的结果也都要放在内存里内存越大能加载的东西自然也就越多内存通常直接可以插在主板上图片来源存放在内存里的程序和数据需要被读取计算完之后还要把数据写回到内存然而不能直接插到内存上反之亦然于是就带来了最后一个大件主板主板是一个有着各种各样有时候多达数十乃至上百个插槽的配件我们的要插在主板上内存也要插在主板上主板的芯片组和总线解决了和内存之间如何通信的问题芯片组控制了数据传输的流转也就是数据从哪里到哪里的问题总线则是实际数据传输的高速公路因此总线速度决定了数据能传输得多快计算机主板上通常有着各种各样的插槽图片来源有了三大件只要配上电源供电计算机差不多就可以跑起来了但是现在还缺少各类输入输出设备也就是我们常说的设备如果你用的是自己的个人电脑那显示器肯定必不可少只有有了显示器我们才能看到计算机输出的各种图像文字这也就是所谓的输出设备同样的鼠标和键盘也都是必不可少的配件这样我才能输入文本写下这篇文章它们也就是所谓的输入设备最后你自己配的个人计算机还要配上一个硬盘这样各种数据才能持久地保存下来绝大部分人都会给自己的机器装上一个机箱配上风扇解决灰尘和散热的问题不过机箱和风扇算不上是计算机的必备硬件我们拿个纸板或者外面放个电风扇也一样能用说了这么多其实你应该有感觉了显示器鼠标键盘和硬盘这些东西并不是一台计算机必须的部分你想一想我们其实只需要有设备能让我们从计算机里输入和输出信息是不是就可以了答案当然是肯定的你肯定去过网吧吧不知道你注意到没有很多网吧的计算机就没有硬盘而是直接通过局域网读写远程网络硬盘里面的数据我们日常用的各类云服务器只要让计算机能通过网络远程登陆访问就好了因此也没必要配显示器鼠标键盘这些东西这样不仅能够节约成本还更方便维护还有一个很特殊的设备就是显卡现在使用图形界面操作系统的计算机无论是还是显卡都是必不可少的有人可能要说了我装机的时候没有买显卡计算机一样可以正常跑起来啊那是因为现在的主板都带了内置的显卡如果你用计算机玩游戏做图形渲染或者跑深度学习应用你多半就需要买一张单独的显卡插在主板上显卡之所以特殊是因为显卡里有除了之外的另一个处理器也就是图形处理器一样可以做各种计算的工作鼠标键盘以及硬盘这些都是插在主板上的作为外部设备它们是通过主板上的南桥芯片组来控制和之间的通信的南桥芯片的名字很直观一方面它在主板上的位置通常在主板的南面另一方面它的作用就是作为桥来连接鼠标键盘以及硬盘这些外部设备和之间的通信有了南桥自然对应着也有北桥是的以前的主板上通常也有北桥芯片用来作为桥连接和内存显卡之间的通信不过随着时间的变迁现在的主板上的北桥芯片的工作已经被移到了的内部所以你在主板上已经看不到北桥芯片了冯诺依曼体系结构刚才我们讲了一台计算机的硬件组成这说的是我们平时用的个人电脑或者服务器那我们平时最常用的智能手机的组成也是这样吗我们手机里只有卡这样类似硬盘功能的存储卡插槽并没有内存插槽插槽这些东西没错因为手机尺寸的原因手机制造商们选择把内存网络通信乃至摄像头芯片都封装到一个芯片然后再嵌入到手机主板上这种方式叫也就是系统芯片这样看起来个人电脑和智能手机的硬件组成方式不太一样可是我们写智能手机上的和写个人电脑的客户端应用似乎没有什么差别都是通过高级语言这样的编程语言撰写编译之后一样是把代码和数据加载到内存里来执行这是为什么呢因为无论是个人电脑服务器智能手机还是这样的微型卡片机都遵循着同一个计算机的抽象概念这是怎么样一个计算机呢这其实就是计算机祖师爷之一冯诺依曼提出的冯诺依曼体系结构也叫存储程序计算机什么是存储程序计算机呢这里面其实暗含了两个概念一个是可编程计算机一个是存储计算机说到可编程估计你会有点懵你可以先想想什么是不可编程计算机是由各种门电路组合而成的然后通过组装出一个固定的电路版来完成一个特定的计算程序一旦需要修改功能就要重新组装电路这样的话计算机就是不可编程的因为程序在计算机硬件层面是写死的最常见的就是老式计算器电路板设好了加减乘除做不了任何计算逻辑固定之外的事情计算器的本质是一个不可编程的计算机图片来源我们再来看存储计算机这其实是说程序本身是存储在计算机的内存里可以通过加载不同的程序来解决不同的问题有存储程序计算机自然也有不能存储程序的计算机典型的就是早年的这样的插线板式的计算机整个计算机就是一个巨大的插线板通过在板子上不同的插头或者接口的位置插入线路来实现不同的功能这样的计算机自然是可编程的但是编写好的程序不能存储下来供下一次加载使用不得不每次要用到和当前不同的程序的时候重新插板子重新编程著名的就用到了来进行编程图片来源可以看到无论是不可编程还是不可存储都会让使用计算机的效率大大下降而这个对于效率的追求也就是存储程序计算机的由来于是我们的冯祖师爷基于当时在秘密开发的写了一篇报告描述了他心目中的一台计算机应该长什么样这篇报告在历史上有个很特殊的简称叫翻译成中文其实就是第一份草案这样现代计算机的发展就从祖师爷写的一份草案开始了里面说了一台计算机应该有哪些部分组成我们一起来看看首先是一个包含算术逻辑单元和处理器寄存器的处理器单元用来完成各种算术和逻辑运算因为它能够完成各种数据的处理或者计算工作因此也有人把这个叫作数据通路或者运算器然后是一个包含指令寄存器和程序计数器的控制器单元用来控制程序的流程通常就是不同条件下的分支和跳转在现在的计算机里上面的算术逻辑单元和这里的控制器单元共同组成了我们说的接着是用来存储数据和指令的内存以及更大容量的外部存储在过去可能是磁带磁鼓这样的设备现在通常就是硬盘最后就是各种输入和输出设备以及对应的输入和输出机制我们现在无论是使用什么样的计算机其实都是和输入输出设备在打交道个人电脑的鼠标键盘是输入设备显示器是输出设备我们用的智能手机触摸屏既是输入设备又是输出设备而跑在各种云上的服务器则是通过网络来进行输入和输出这个时候网卡既是输入设备又是输出设备任何一台计算机的任何一个部件都可以归到运算器控制器存储器输入设备和输出设备中而所有的现代计算机也都是基于这个基础架构来设计开发的而所有的计算机程序也都可以抽象为从输入设备读取输入信息通过运算器和控制器来执行存储在存储器里的程序最终把结果输出到输出设备中而我们所有撰写的无论高级还是低级语言的程序也都是基于这样一个抽象框架来进行运作的冯诺依曼体系结构示意图图片来源冯诺依曼架构是冯诺依曼和其他人提出的电子计算机通用架构冯诺依曼架构将通用计算机定义为以下个基本原则采用二进制指令和数据均采用二进制格式存储程序一个计算机程序不可能只有一条指令而是由成千上万条指令组成的指令和数据均存储在存储器中而不是早期的插线板中计算机按需从存储器中取指令和取数据计算机由个硬件组成运算器控制器存储器输入设备和输出设备在最开始的计算机中五个部件是围绕着运算器运转的这使得存储器和设备之间的数据传送也需要经过运算器而现代计算机中五个部件是围绕着存储器运转的这使得存储器和设备可以直接完成数据传送而不需要经过在冯诺依曼架构之前还有一个哈佛架构现在说的比较少两者的区别在于冯诺依曼是将指令和数据存储在同一个存储器的不同位置存在争用问题而哈弗架构将指令和数据存储在不同存储器中规避了争用问题与缓存将指令和数据分离的思想类似冯诺依曼瓶颈冯诺依曼瓶颈的概念最早由在年的图灵奖领奖演讲中提出由于和存储器之间共享同一个系统总线并且和存储器之间存在巨大的速度差导致需要不断地被迫等待数据读取或写入到存储器因此遏制了的吞吐量要从根本上解决冯诺依曼瓶颈还是只能重新构建一套新的计算机体系例如生物计算机量子计算机不过目前它们都还处在非常原始的阶段现代计算机体系只能采用优化策略来减弱冯诺依曼瓶颈的影响总结如果说图灵机描述的是计算机的抽象模型那么冯诺依曼架构则是对图灵机这个抽象模型的实现架构冯诺依曼架构确立了现代电子计算机的基础和结构学习计算机组成原理其实就是学习和拆解冯诺依曼架构参考文章字长与端序字节序探析大端与小端的比较汇编指令入门级整理汇编语言入门教程汇编基础之三汇编指令冯诺依曼体系结构计算机组成的金字塔一套用了年的计算机架构冯诺依曼架构',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-11-25 15:42:32',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">hybcx</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 1.05rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 1.05rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 1.05rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 1.05rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 1.05rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 1.05rem;">TryHackMe<sup>42</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 1.05rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 1.05rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 1.05rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/reverse/" itemprop="url">reverse</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/reverse%E7%B3%BB%E5%88%97/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>reverse系列</span></a></span></div></div><h1 class="post-title" itemprop="name headline">汇编基础指令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-19T01:49:29.501Z" title="发表于 2023-11-19 09:49:29">2023-11-19</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-11-25T07:42:32.103Z" title="更新于 2023-11-25 15:42:32">2023-11-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.6k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="汇编基础指令"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为太原"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>太原</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/11/19/hui-bian-ji-chu-zhi-ling/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/11/19/hui-bian-ji-chu-zhi-ling/" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/"><header><a class="post-meta-categories" href="/categories/reverse/" itemprop="url">reverse</a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" tabindex="-1" itemprop="url">reverse系列</a><h1 id="CrawlerTitle" itemprop="name headline">汇编基础指令</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">hybcx</span><time itemprop="dateCreated datePublished" datetime="2023-11-19T01:49:29.501Z" title="发表于 2023-11-19 09:49:29">2023-11-19</time><time itemprop="dateCreated datePublished" datetime="2023-11-25T07:42:32.103Z" title="更新于 2023-11-25 15:42:32">2023-11-25</time></header><h1 id="0x01-什么是汇编语言">0x01 什么是汇编语言</h1>
<p>汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：</p>
<blockquote>
<p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p>
</blockquote>
<h2 id="11-汇编语言产生的原因">1.1 汇编语言产生的原因</h2>
<p>对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 <code>00000011</code>，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。</p>
<h2 id="12-汇编与二进制的关系">1.2 汇编与二进制的关系</h2>
<p>换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便的把汇编程序转译成机器指令程序，比如之前提到的 <code>00000011</code> 加法指令，对应的汇编指令是 <code>ADD</code>，在调用汇编器时就会把 <code>ADD</code> 翻译成 <code>00000011</code>。</p>
<h1 id="0x02-寄存器">0x02 寄存器</h1>
<p>说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 <code>CPU</code> 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？</p>
<h2 id="21-寄存器作用">2.1 寄存器作用</h2>
<p>其实硬盘、内存都是用来存储数据的，但是 <code>CPU</code> 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，<code>CPU</code> 都自带一级缓存和二级缓存，一些 <code>CPU</code> 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 <code>CPU</code>，所以才会有寄存器的存在。</p>
<p>寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现的更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，<code>CPU</code> 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。</p>
<h2 id="22-存取速度比较">2.2 存取速度比较</h2>
<p>通过上面的叙述我们可以知道存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code>，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。</p>
<p>通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。</p>
<h2 id="23-寄存器分类">2.3 寄存器分类</h2>
<p>常用的 <code>x86 CPU</code> 寄存器有8个：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。</p>
<p>其中<code>AX、BX、CX、DX</code>是通用寄存器，存放一般性数据。1个16位寄存器可以存储16位的数据。</p>
<p>为了向上一代CPU兼容，这4个寄存器可以分为<code>AH、AL，BH、BL，CH、CL，DH、DL</code>。</p>
<p>我们常说的32位、64位 <code>CPU</code> 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 <code>CPU</code> 对应的寄存器也应该是32位的。</p>
<h2 id="24-常用寄存器用途">2.4 常用寄存器用途</h2>
<p>上面提到大8个寄存器都有其特定的用途，我们以32位 <code>CPU</code> 为例简单说明下这些寄存器的作用，整理如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">用途</th>
<th style="text-align:center">包含寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EAX</td>
<td style="text-align:center">累加(Accumulator)寄存器</td>
<td style="text-align:center">常用于乘、除法和函数返回值</td>
<td style="text-align:center">AX(AH、AL)</td>
</tr>
<tr>
<td style="text-align:center">EBX</td>
<td style="text-align:center">基址(Base)寄存器</td>
<td style="text-align:center">常做内存数据的指针, 或者说常以它为基址来访问内存.</td>
<td style="text-align:center">BX(BH、BL)</td>
</tr>
<tr>
<td style="text-align:center">ECX</td>
<td style="text-align:center">计数器(Counter)寄存器</td>
<td style="text-align:center">常做字符串和循环操作中的计数器</td>
<td style="text-align:center">CX(CH、CL)</td>
</tr>
<tr>
<td style="text-align:center">EDX</td>
<td style="text-align:center">数据(Data)寄存器</td>
<td style="text-align:center">常用于乘、除法和 I/O 指针</td>
<td style="text-align:center">DX(DH、DL)</td>
</tr>
<tr>
<td style="text-align:center">ESI</td>
<td style="text-align:center">来源索引(Source Index)寄存器</td>
<td style="text-align:center">常做内存数据指针和源字符串指针</td>
<td style="text-align:center">SI</td>
</tr>
<tr>
<td style="text-align:center">EDI</td>
<td style="text-align:center">目的索引(Destination Index)寄存器</td>
<td style="text-align:center">常做内存数据指针和目的字符串指针</td>
<td style="text-align:center">DI</td>
</tr>
<tr>
<td style="text-align:center">ESP</td>
<td style="text-align:center">堆栈指针(Stack Point)寄存器</td>
<td style="text-align:center">只做堆栈的栈顶指针; 不能用于算术运算与数据传送</td>
<td style="text-align:center">SP</td>
</tr>
<tr>
<td style="text-align:center">EBP</td>
<td style="text-align:center">基址指针(Base Point)寄存器</td>
<td style="text-align:center">只做堆栈指针, 可以访问堆栈内任意地址, 经常用于中转 ESP 中的数据, 也常以它为基址来访问堆栈; 不能用于算术运算与数据传送</td>
<td style="text-align:center">BP</td>
</tr>
</tbody>
</table>
<h2 id="25-寄存器eax-ax-ah-al的关系">2.5 寄存器EAX、AX、AH、AL的关系</h2>
<p>在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 <code>CPU</code> 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下:</p>
<pre><code class="hljs plaintext">00000000 00000000 00000000 00000000
|===============EAX===============|---4个字节
                  |======AX=======|---2个字节
                  |==AH===|-----------1个字节
                          |===AL==|---1个字节</code></pre>
<h2 id="26-物理地址">2.6 物理地址</h2>
<p>CPU要想访问内存单元，就要给出内存单元的物理地址，内存是一个一维的线性空间，每一个内存单元都有唯一的地址，这个地址就是<strong>物理地址</strong>。</p>
<p>8086CPU是16位结构的，其数据总线是16位宽，但地址总线是20位，1MB寻址能力。</p>
<p>但内部是16位结构，内部一次性处理、传输地址为16位，所以在内部采用2个16位地址合成方式形成一个20位的物理地址进行内存寻址。</p>
<p><strong>物理地址 = 段地址 * 16 + 偏移地址(段地址*16即左移4位)</strong></p>
<p><strong>其本质含义是：CPU在访问内存时，用一个基础地址(段地址*16)和相对于基础地址的偏移地址相加，得到物理地址。</strong></p>
<p>由于偏移地址为16位，16位地址的寻址能力是64KB，所以一个段的长度最大为64K。</p>
<p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p>
<h2 id="27-段寄存器">2.7 段寄存器</h2>
<p>8086CPU有4个段寄存器：<code>CS、DS、SS、ES</code>。</p>
<p><code>CS</code>为代码段寄存器，<code>IP</code>为指令指针寄存器。</p>
<p><strong>任意时刻，CPU将CS:IP指向的内容当做当前指令执行。</strong></p>
<p>8086CPU工作过程：</p>
<ul>
<li>从CS:IP指向的内存单元读指令，指令进指令缓冲器</li>
<li>IP指向下一条指令</li>
<li>执行指令，跳到步骤1，重复这个过程</li>
</ul>
<p><strong>CPU根据什么将内存中的信息看做指令？答案是CPU将CS:IP指向的内存单元的内容看做指令。</strong></p>
<p>使用<code>jmp 段地址:偏移地址</code>或<code>jmp 寄存器</code>修改CS:IP或IP的地址。</p>
<p>在编程时，根据需要可以将长度为N的一组代码，存在一组连续的内存单元中，这段内存单元叫做<strong>代码段</strong>。</p>
<p>同样的，可以根据需要将长度为N的一组内存单元，专门存储数据，这段内存单元叫做<strong>数据段</strong>。</p>
<p><strong>8086CPU自动取<code>DS</code>寄存器中的数据为内存单元的段地址。</strong></p>
<p>例如<code>mov [0] cs</code>表示将寄存器<code>cs</code>的值复制到段地址为DS偏移地址为0的内存单元中。</p>
<p>字在内存中存储时，用2个地址连续的内存单元存放，字的低字节放在低地址单元，高字节放在高地址单元。</p>
<p>2.8 标志寄存器</p>
<p>标志寄存器作用：</p>
<ul>
<li>存储相关指令某些执行结果</li>
<li>为CPU执行相关指令提供行为依据</li>
<li>控制CPU相关工作方式</li>
</ul>
<p>8086CPU中有个叫flag寄存器，共16位，每一位代表专门的含义：</p>
<ul>
<li>第6位<code>ZF</code>，<strong>零标志位</strong>：相关指令执行后，结果为0则zf=1，不为0则zf=0</li>
<li>第2位<code>PF</code>，<strong>奇偶标志位</strong>：相关指令执行后，结果所有bit位中1的个数为偶数，pf=1，否则pf=0</li>
<li>第7位<code>SF</code>，<strong>符号标志位</strong>：相关指令执行后，结果是否为负，结果为负sf=1，否则sf=0</li>
<li>第0位<code>CF</code>，<strong>进位标志位</strong>：对于无符号数运算，CF记录运算结果最高有效位向更高位的进位值/借位值</li>
<li>第11位<code>OF</code>，<strong>溢出标志位</strong>：对于有符号数运算，是否发生溢出，溢出则of=1，否则of=0</li>
<li>第10位<code>DF</code>，<strong>方向标志位</strong>：在串处理指令中，控制操作后si、di增减，df=0每次操作后si、di递增，否则递减</li>
</ul>
<h1 id="0x03-内存模型heap">0x03 内存模型：Heap</h1>
<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119101942817.png" alt="image-20231119101942817"></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119101952917.png" alt="image-20231119101952917"></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h1 id="0x04-内存模型stack">0x04 内存模型：Stack</h1>
<p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119102033874.png" alt="image-20231119102033874"></p>
<p>请看下面的例子。</p>
<pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
   <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;
   <span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;
}</code></pre>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119102055485.png" alt="image-20231119102055485"></p>
<p>如果函数内部调用了其他函数，会发生什么情况？</p>
<pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
   <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;
   <span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;
   <span class="hljs-keyword">return</span> add_a_and_b(a, b);
}</code></pre>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119102118853.png" alt="image-20231119102118853"></p>
<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"后进先出"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119102130802.png" alt="image-20231119102130802"></p>
<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119102138709.png" alt="image-20231119102138709"></p>
<p>8086CPU提供入栈和出栈的指令：<code>PUSH</code>和<code>POP</code>，任意时刻，寄存器<code>SS:SP</code>指向栈顶元素。</p>
<p>push指令执行：</p>
<ul>
<li>SP=SP-2</li>
<li>向SS:SP指向的字单元送入数据</li>
</ul>
<p>pop指令执行：</p>
<ul>
<li>从SS:SP指向的字单元读数据</li>
<li>SP=SP+2</li>
</ul>
<p>在编程时，要时刻注意栈顶越界的问题，<strong>用栈来可以暂存以后需要恢复的寄存器中的内容。</strong></p>
<p><code>push和pop</code>实质上是一种内存传送指令，同样的，编程时我们可以将长度为N的一组连续内存单元当做栈空间使用，叫做<strong>栈段</strong>。</p>
<p>一个栈段的容量最大为64KB。</p>
<h1 id="0x05-cpu-指令">0x05 CPU 指令</h1>
<h2 id="51-实例">5.1 实例</h2>
<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>
<pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
   <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {
   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
}</code></pre>
<p>gcc 将这个程序转成汇编语言。</p>
<pre><code class="hljs bash">$ gcc -S example.c</code></pre>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>
<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>
<pre><code class="hljs assembly">_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret</code></pre>
<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<pre><code class="hljs assembly">push   %ebx</code></pre>
<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>
<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>
<h2 id="52-push-指令">5.2 push 指令</h2>
<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<pre><code class="hljs assembly">push   3</code></pre>
<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>
<pre><code class="hljs assembly">push   2</code></pre>
<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119104334762.png" alt="image-20231119104334762"></p>
<h2 id="53-call-指令">5.3 call 指令</h2>
<p>第三行的<code>call</code>指令用来调用函数。</p>
<pre><code class="hljs assembly">call   _add_a_and_b</code></pre>
<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>
<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>
<pre><code class="hljs assembly">push   %ebx</code></pre>
<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>
<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>
<h2 id="54-mov-指令">5.4 mov 指令</h2>
<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<pre><code class="hljs assembly">mov    %eax, [%esp+8]</code></pre>
<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>
<p>下一行代码也是干同样的事情。</p>
<pre><code class="hljs assembly">mov    %ebx, [%esp+12]</code></pre>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>
<h2 id="55-add-指令">5.5 add 指令</h2>
<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<pre><code class="hljs assembly">add    %eax, %ebx</code></pre>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>
<h2 id="56-pop-指令">5.6 pop 指令</h2>
<p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>
<pre><code class="hljs assembly">pop    %ebx</code></pre>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>
<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>
<h2 id="57-ret-指令">5.7 ret 指令</h2>
<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>
<pre><code class="hljs assembly">ret</code></pre>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<pre><code class="hljs assembly">add    %esp, 8</code></pre>
<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<pre><code class="hljs assembly">ret</code></pre>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>
<h1 id="0x06-汇编语言指令">0x06 汇编语言指令</h1>
<p>终于说到汇编常用指令了，因为 <code>linux</code> 和 <code>windows</code> 下的汇编语法是有些不同的，所以下面我们先通过 <code>windows</code> 下的汇编指令来简单学习一下，后续再来比较两者的不同。</p>
<h2 id="61-数据传送指令">6.1 数据传送指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MOV</td>
<td style="text-align:center">传送指令</td>
<td style="text-align:center">MOV dest, src</td>
<td style="text-align:center">将数据从src移动到dest</td>
</tr>
<tr>
<td style="text-align:center">PUSH</td>
<td style="text-align:center">进栈指令</td>
<td style="text-align:center">PUSH src</td>
<td style="text-align:center">把源操作数src压入堆栈</td>
</tr>
<tr>
<td style="text-align:center">POP</td>
<td style="text-align:center">出栈指令</td>
<td style="text-align:center">POP dest</td>
<td style="text-align:center">从栈顶弹出字数据到dest</td>
</tr>
</tbody>
</table>
<h2 id="62-算术运算指令">6.2 算术运算指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ADD</td>
<td style="text-align:center">加法指令</td>
<td style="text-align:center">ADD dest, src</td>
<td style="text-align:center">在dest基础上加src</td>
</tr>
<tr>
<td style="text-align:center">SUB</td>
<td style="text-align:center">减法指令</td>
<td style="text-align:center">SUB dest, src</td>
<td style="text-align:center">在dest基础上减src</td>
</tr>
<tr>
<td style="text-align:center">INC</td>
<td style="text-align:center">加1指令</td>
<td style="text-align:center">INC dest</td>
<td style="text-align:center">在dest基础上加1</td>
</tr>
<tr>
<td style="text-align:center">DEC</td>
<td style="text-align:center">减1指令</td>
<td style="text-align:center">DEC dest</td>
<td style="text-align:center">在dest基础上减1</td>
</tr>
</tbody>
</table>
<h2 id="63-逻辑运算指令">6.3 逻辑运算指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NOT</td>
<td style="text-align:center">取反运算指令</td>
<td style="text-align:center">NOT dest</td>
<td style="text-align:center">把操作数dest按位取反</td>
</tr>
<tr>
<td style="text-align:center">AND</td>
<td style="text-align:center">与运算指令</td>
<td style="text-align:center">AND dest, src</td>
<td style="text-align:center">把dest和src进行与运算之后送回dest</td>
</tr>
<tr>
<td style="text-align:center">OR</td>
<td style="text-align:center">或运算指令</td>
<td style="text-align:center">OR dest, src</td>
<td style="text-align:center">把dest和src进行或运算之后送回dest</td>
</tr>
<tr>
<td style="text-align:center">XOR</td>
<td style="text-align:center">异或运算</td>
<td style="text-align:center">XOR dest, src</td>
<td style="text-align:center">把dest和src进行异或运算之后送回dest</td>
</tr>
</tbody>
</table>
<h2 id="64-循环控制指令">6.4 循环控制指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOOP</td>
<td style="text-align:center">计数循环指令</td>
<td style="text-align:center">LOOP label</td>
<td style="text-align:center">使ECX的值减1，当ECX的值不为0的时候跳转至label，否则执行LOOP之后的语句</td>
</tr>
</tbody>
</table>
<h2 id="65-转移指令">6.5 转移指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JMP</td>
<td style="text-align:center">无条件转移指令</td>
<td style="text-align:center">JMP lable</td>
<td style="text-align:center">无条件地转移到标号为label的位置</td>
</tr>
<tr>
<td style="text-align:center">CALL</td>
<td style="text-align:center">过程调用指令</td>
<td style="text-align:center">CALL labal</td>
<td style="text-align:center">直接调用label</td>
</tr>
<tr>
<td style="text-align:center">JE</td>
<td style="text-align:center">条件转移指令</td>
<td style="text-align:center">JE lable</td>
<td style="text-align:center">zf =1 时跳转到标号为label的位置</td>
</tr>
<tr>
<td style="text-align:center">JNE</td>
<td style="text-align:center">条件转移指令</td>
<td style="text-align:center">JNE lable</td>
<td style="text-align:center">zf=0 时跳转到标号为label的位置</td>
</tr>
</tbody>
</table>
<h2 id="66-jcc指令组">6.6 JCC指令组</h2>
<p>J是指jump。CC是条件，该条件与EFL标志寄存器中的标志位息息相关。通过获取EFL标志位的值，判断是否满足条件而是否执行JUMP操作。对应了高级语言中的比较运算。</p>
<table>
<thead>
<tr>
<th style="text-align:left">JCC指令</th>
<th style="text-align:left">中文含义</th>
<th style="text-align:left">检查符号位</th>
<th style="text-align:left">典型C应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JZ/JE</td>
<td style="text-align:left">若为0则跳转；若相等则跳转</td>
<td style="text-align:left">ZF=1</td>
<td style="text-align:left">if (i == j);if (i == 0);</td>
</tr>
<tr>
<td style="text-align:left">JNZ/JNE</td>
<td style="text-align:left">若不为0则跳转；若不相等则跳转</td>
<td style="text-align:left">ZF=0</td>
<td style="text-align:left">if (i != j);if (i != 0);</td>
</tr>
<tr>
<td style="text-align:left">JS</td>
<td style="text-align:left">若为负则跳转</td>
<td style="text-align:left">SF=1</td>
<td style="text-align:left">if (i &lt; 0);</td>
</tr>
<tr>
<td style="text-align:left">JNS</td>
<td style="text-align:left">若为非负数则跳转</td>
<td style="text-align:left">SF=0</td>
<td style="text-align:left">if (i &gt;= 0);</td>
</tr>
<tr>
<td style="text-align:left">JP/JPE</td>
<td style="text-align:left">若1出现次数为偶数则跳转</td>
<td style="text-align:left">PF=1</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JNP/JPO</td>
<td style="text-align:left">若1出现次数为奇数则跳转</td>
<td style="text-align:left">PF=0</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JO</td>
<td style="text-align:left">若溢出则跳转</td>
<td style="text-align:left">OF=1</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JNO</td>
<td style="text-align:left">若无溢出则跳转</td>
<td style="text-align:left">OF=0</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JC/JB/JNAE</td>
<td style="text-align:left">若进位则跳转；若低于则跳转；若不高于等于则跳转</td>
<td style="text-align:left">CF=1</td>
<td style="text-align:left">if (i &lt; j);</td>
</tr>
<tr>
<td style="text-align:left">JNC/JNB/JAE</td>
<td style="text-align:left">若无进位则跳转；若不低于则跳转；若高于等于则跳转；</td>
<td style="text-align:left">CF=0</td>
<td style="text-align:left">if (i &gt;= j);</td>
</tr>
<tr>
<td style="text-align:left">JBE/JNA</td>
<td style="text-align:left">若低于等于则跳转；若不高于则跳转</td>
<td style="text-align:left">ZF=1或CF=1</td>
<td style="text-align:left">if (i &lt;= j);</td>
</tr>
<tr>
<td style="text-align:left">JNBE/JA</td>
<td style="text-align:left">若不低于等于则跳转；若高于则跳转</td>
<td style="text-align:left">ZF=0或CF=0</td>
<td style="text-align:left">if (i &gt; j);</td>
</tr>
<tr>
<td style="text-align:left">JL/JNGE</td>
<td style="text-align:left">若小于则跳转；若不大于等于则跳转</td>
<td style="text-align:left">SF != OF</td>
<td style="text-align:left">if (si &lt; sj);</td>
</tr>
<tr>
<td style="text-align:left">JNL/JGE</td>
<td style="text-align:left">若不小于则跳转；若大于等于则跳转；</td>
<td style="text-align:left">SF = OF</td>
<td style="text-align:left">if (si &gt;= sj);</td>
</tr>
<tr>
<td style="text-align:left">JLE/JNG</td>
<td style="text-align:left">若小于等于则跳转；若不大于则跳转</td>
<td style="text-align:left">ZF != OF 或 ZF=1</td>
<td style="text-align:left">if (si &lt;= sj);</td>
</tr>
<tr>
<td style="text-align:left">JNLE/JG</td>
<td style="text-align:left">若不小于等于则跳转；若大于则跳转</td>
<td style="text-align:left">SF=0F 且 ZF=0</td>
<td style="text-align:left">if(si&gt;sj)ag</td>
</tr>
</tbody>
</table>
<h2 id="67-堆栈指令">6.7 堆栈指令</h2>
<p>ESP：栈顶指针寄存器，记录当前使用的地址，栈的内存空间是存大地址开始使用的。EBP：栈底指针寄存器，记录栈开始的位置。</p>
<p>我们可以使用MOV指令，将数据MOV到ESP寄存器指定的位置，然后使用SUB或者ADD指令，将ESP寄存器的值偏移对应的数据宽度值，实现数据的入栈和出栈操作。基于这样的原理，汇编中提供了PUSH和POP命令</p>
<pre><code class="hljs assembly">MOV BYTE PTR DS:[ESP], 0xFF          // 向栈中写入一个字节
SUB ESP, 1                           // 栈顶指针偏移一字节

以上两个操作等同于一个push操作
PUSH 0xFF                           // 将0xFF写入到ESP保存的地址处，同时ESP偏移一个数据宽度
PUSH EAX   　　　　　　　　　　　　　// EAX中的值入栈
PUSH DWORD PTR DS:[地址]             // 该地址处的值入栈

出栈同理 
POP DWORD　EAX                     // 将栈顶的元素取出放入EAX寄存器中保存，同时ESP偏移一个DWORD数据宽度</code></pre>
<h2 id="68-跳转指令">6.8 跳转指令</h2>
<ul>
<li>JMP：将程序跳转到指定的地址执行，通过改变EIP中的值实现</li>
<li>CALL：将程序跳转到指定的地址，跳转前将下一次执行的地址保存到栈中，用来记录跳转前的位置。然后改变EIP中的值使得cpu去执行其他地址的指令。当执行结束需要返回原来的地址时，从栈中取出跳转签到的地址，赋值到EIP寄存器中即可回到跳转前的状态。</li>
<li>RETN：从栈中取出保存的地址，赋值给EIP，用作下次执行</li>
</ul>
<p>使用这两个指令需要理解EIP寄存器的作用。当一个程序被编译完成之后，程序的执行方法即已经确定，即A=&gt;B=&gt;C的顺序进行执行，且他们使用的内存空间说连续的，计算机执行一行指令后，下一次要执行的内容都保存在EIP寄存器保存的地址处。所以EIP寄存器指向的内容，就是程序下一次执行的指令。也就是说，A执行时，EIP寄存器中保存的是B的地址，这样执行A后将会获取B的信息并执行。如果A是一个JMP或者CALL指令，执行依次<code>JMP EIP D</code>，这条指令表示将EIP中的值改为D的地址，所以下一次执行的即为D指令。由此实现了跳转。这样的方式当程序跳转到D指令后，程序无法返回B指令了，因为我们找不到B的地址，想要重新回到B指令，需要将B的地址保存，使用时取回即可，通常是将其入栈。这样就和CALL指令的使用方式相同了。</p>
<pre><code class="hljs assembly">JMP EIP, 地址   // 修改EIP寄存器中的值。
CALL　地址　   // 跳转到指定地址，执行该地址的指令，跳转前，将下一行地址入栈，</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231120193326379.png" alt="image-20231120193326379"></p>
<h1 id="0x07-linux-和-windows-下汇编的区别">0x07 linux 和 windows 下汇编的区别</h1>
<p>前面说到 <code>linux</code> 和 <code>windows</code> 下的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 <code>linux</code> 上会使用 <code>gcc/g++</code> 编译器，而在 <code>windows</code> 上会使用微软的 <code>cl</code> 也就是 <code>MSBUILD</code>，所以产生不同的代码是因为编译器不同，<code>gcc</code> 下采用的是AT&amp;T的汇编语法格式，<code>MSBUILD</code> 采用的是Intel汇编语法格式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:center">Intel</th>
<th style="text-align:center">AT&amp;T</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">引用寄存器名字</td>
<td style="text-align:center">eax</td>
<td style="text-align:center">%eax</td>
</tr>
<tr>
<td style="text-align:center">赋值操作数顺序</td>
<td style="text-align:center">mov dest, src</td>
<td style="text-align:center">movl src, dest</td>
</tr>
<tr>
<td style="text-align:center">寄存器、立即数指令前缀</td>
<td style="text-align:center">mov ebx, 0xd00d</td>
<td style="text-align:center">movl $0xd00d, %ebx</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:center">[eax]</td>
<td style="text-align:center">(%eax)</td>
</tr>
<tr>
<td style="text-align:center">数据类型大小</td>
<td style="text-align:center">操作码后加后缀字母，“l” 32位，“w” 16位，“b” 8位（mov dx, word ptr [eax]）</td>
<td style="text-align:center">操作数前面加dword ptr， word ptr，byte ptr的格式 （movb %bl %al）</td>
</tr>
</tbody>
</table>
<h1 id="0x08-什么是字长">0x08 什么是字长</h1>
<p>​		内存以字节为单位。 一个字节是 8 个比特位，可以表示 2^8 = 256 个数。大小为 8 位的二进制数是从 0 开始到 255 这 256 个值中的一个。 两个字节被称为一个字（WORD），两个字被称为四个字节（32位）也即双字（DWORD），四字 （QWORD）是八个字节（64 位）。 这些连续的字节要按什么样的顺序排列和解释，这就涉及到端序的范畴了。 字节的排列方式有两个通用规则: 大端序（Big-Endian）与小端序（Little-Endian）</p>
<pre><code class="hljs plaintext">大端序（Big-Endian）将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种 排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。

小端序（Little-Endian）将数据的低位字节放在较小的地址处，高位放在较大的地址处。小端序与 人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地 址向高地址方向进行读取的。</code></pre>
<h1 id="0x09-大端与小端的比较">0x09 大端与小端的比较</h1>
<h2 id="91-概念">9.1 概念</h2>
<p>字节序指的是，<strong>多字节数据的内存排列顺序</strong>。这样说比较抽象，使用图形解释就很好懂。</p>
<p>内存好比一排房间，每个字节是一间房。每间房都有门牌号（内存地址），从0号开始，然后是1号、2号…</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100702283.png" alt="image-20231119100702283"></p>
<p>0号字节的地址小，称为低位内存；3号字节的地址大，称为高位内存。</p>
<p>现在有一个数值<code>abcd</code>要放进这些房间，每个房间放一个数字，那么有两种放法。</p>
<p>第一种放法是，第一位<code>a</code>放在低位地址（0号），最后一位<code>d</code>放在高位地址（3号）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100710379.png" alt="image-20231119100710379"></p>
<p>这种排列称为"<strong>大端序</strong>"（big-endian，简称 BE），即大头在前，因为<code>a</code>是<code>abcd</code>的大头（最重要的数字）。</p>
<p>第二种放法是，第一位<code>a</code>放在高位地址（3号地址），最后一位<code>d</code>放在低位地址（0号地址）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100719213.png" alt="image-20231119100719213"></p>
<p>这种排列称为"<strong>小端序</strong>"（little-endian，简称 LE），即小头<code>d</code>在前。</p>
<p>大端序和小端序合称字节序，这两个名字来自18世纪的英国小说《格列佛游记》。某国分成两派，一派认为鸡蛋应该从大头吃起，称为"大端派"；另一派认为，鸡蛋应该从小头吃起，称为"小端派"。两派相执不下，谁也无法说服谁，最后甚至为此交战。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100732966.png" alt="image-20231119100732966"></p>
<h2 id="92-可读性">9.2 可读性</h2>
<p>对于人类来说，不同字节序的可读性是不一样的。大部分国家的阅读习惯是从左到右阅读。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100747791.png" alt="image-20231119100747791"></p>
<p>大端序的最高位在左边，最低位在右边，符合阅读习惯。所以，对于这些国家的人来说，<strong>从左到右的大端序的可读性更好。</strong></p>
<p>但是现实中，从右到左的小端序虽然可读性差，但应用更广泛，x86 和 ARM 这两种 CPU 架构都采用小端序，这是为什么？</p>
<p>或者换一种问法，两种不同的字节序为什么会并存，统一规定只使用一种，难道不是更方便吗？</p>
<p>原因是它们有各自的适用场景，某些场景大端序有优势，另一些场景小端序有优势，下面就逐一分析。</p>
<h2 id="93-检查奇偶性">9.3 检查奇偶性</h2>
<p>小端序优势最明显的，大概就是检查奇偶性，即通过查看个位数，确定某个数字是奇数还是偶数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100802290.png" alt="image-20231119100802290"></p>
<p>以<code>123456</code>为例，大端序从左到右排列，计算机必须一直读到最后一位的个位数<code>6</code>，才能确定这是偶数。</p>
<p>小端序是从右到左排列，个位数在第一位。所以，只要读取第一位，就能确定它是偶数。</p>
<h2 id="94-检查正负号">9.4 检查正负号</h2>
<p>一个类似的场景是检查正负号，确定一个数是正数还是负数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100810206.png" alt="image-20231119100810206"></p>
<p>大端序的符号位在左边第一位，小端序的符号位在右边最后一位。所以，大端序有优势，只看第一位就能知道是不是负数。</p>
<h2 id="95-比较大小">9.5 比较大小</h2>
<p>下一个操作是比较大小。现在有三个数字，需要比较大小：43662576，594，2。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100817614.png" alt="image-20231119100817614"></p>
<p>上图是大端序排列，因为是从左到右排列，所以三个数字在右边个位数对齐。比较大小时，计算机就不得不读取每一个数的所有位，直到个位数，再进行比较。</p>
<p>如果改成小端序，就是下面的排列方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100834253.png" alt="image-20231119100834253"></p>
<p>小端序是从右到左，所以三个数字在第一位对齐。计算机就不需要读取所有位，哪个数字先读不到下一位，就是最小的。比如，<code>2</code>这个数字就没有第二位，所以读到第二位时，就知道它是最小的。</p>
<p>所以，比较大小时，小端序有优势。</p>
<h2 id="96-乘法">9.6 乘法</h2>
<p>接下来，再看乘法操作。</p>
<p>乘法是逐位相乘，每一轮乘法都要向前进位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100846922.png" alt="image-20231119100846922"></p>
<p>上图是大端序的24165乘以3841。大端序的乘法是向左进位，也就是向左边扩展，必须等到每一轮的结果都出来（上例是四轮），再相加统一写入内存。</p>
<p>如果改成小端序的乘法，就不需要等待下一轮的结果，每一轮都可以直接写入内存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100858692.png" alt="image-20231119100858692"></p>
<p>上图是小端序的24165乘以3841。小端序的乘法是向右进位，也就是向右边扩展，左边的边界不变。每一轮结果写入内存后，就不需要移动，后面有变化只需要改动对应的位就行了。</p>
<p>因此，小端序的乘法有明显优势。</p>
<h2 id="97-任意精度整数">9.7 任意精度整数</h2>
<p>上一个例子的从低位开始计算的特性，对于任意精度整数特别有用。任意精度整数又称大整数，可以存放任意大小的整数。</p>
<p>它的内部实现是把整数分成一个个较小的单位，通常是 uint32（无符号32位整数）或 uint64（无符号64位整数），按顺序组合在一起。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100906634.png" alt="image-20231119100906634"></p>
<p>如果是大端序，第一个 u64 就是这个整数最大的部分。运算时，一旦这个数发生变化，需要进位，后面的所有位都必须移动和改写。小端序发生进位时，往往就不需要所有位移动。</p>
<p>小端序的另一个好处是，如果逐字节的运算从个位数开始（比如乘法和加法），可以从左到右依次运算一个个 u64，算完上一个再读取下一个。大端序就不行，必须读取整个数以后再进行运算。</p>
<h2 id="98-更改类型">9.8 更改类型</h2>
<p>最后一个例子是，C 语言有一种 cast 操作，可以强制改变变量的数据类型，比如把32位整数强行改变为16位整数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119100914441.png" alt="image-20231119100914441"></p>
<p>上图中，32位整数<code>0x00000001</code>更改为16位整数<code>0x0001</code>，大端序是截去前面两个字节，这时指向这个地址的指针必须向后移动两个字节。</p>
<p>小端序就没有这个问题，截去的是后面两个字节，第一位的地址是不变的，所以指针不需要移动。</p>
<h2 id="99-总结">9.9 总结</h2>
<p>综上所述，大端序和小端序各自的优势如下。</p>
<p>如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势。反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势。</p>
<h1 id="0x10-总结">0x10 总结</h1>
<ul>
<li>汇编指令是机器指令的助记符，与机器指令是一一对应的</li>
<li>AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的</li>
<li>常用寄存器：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code></li>
<li>存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code></li>
<li>常用的汇编指令：<code>mov</code>、<code>je</code>、<code>jmp</code>、<code>call</code>、<code>add</code>、<code>sub</code>、<code>inc</code>、<code>dec</code>、<code>and</code>、<code>or</code></li>
</ul>
<h1 id="0x11-冯诺依曼结构体系">0x11 冯诺依曼结构体系</h1>
<h2 id="111-计算机的基本硬件组成">11.1 计算机的基本硬件组成</h2>
<p>早年，要自己组装一台计算机，要先有三大件，CPU、内存和主板。</p>
<p>在这三大件中，我们首先要说的是<strong>CPU</strong>，它是计算机最重要的核心配件，全名你肯定知道，叫中央处理器（Central Processing Unit）。为什么说 CPU 是“最重要”的呢？因为计算机的所有“计算”都是由 CPU 来进行的。自然，CPU 也是整台计算机中造价最昂贵的部分之一。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119110740067.png" alt="image-20231119110740067"></p>
<p>CPU 是一个超级精细的印刷电路版，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/130561288@N04/39836037882/in/photolist-23Gb7cm-25V6DAn-q421FW-qMvhAJ-7yVugk-qMvgHb-o3NoQV-qMwDkj-qMvgT1-7yVu7T-qMvgMj-7yVu5c-py3Fpg-8pZhf1-7yZhR5-7yVuax-ewr4C-7TQAKk-7SbTox-8pZh3b-fkLugb-HCGERb-231L6Mo-5SSUsD-28WhLvN-K2Tvk-98Cc4e-6ag8YH-7Sf6KS-aDGEYV-7yY2XT-b66LSc-r2oZqk-rPcasz-7TQ1dB-754sSu-qMwEzy-npvMDK-4BDkou-zrid4-a8X3jn-5uTaCd-7SbRFV-7TTeJh-6ag8zX-6akhEm-7ihCSj-8Whgmi-6j5iUJ-6ag8m8">图片来源</a></p>
<p>第二个重要的配件，就是<strong>内存</strong>（Memory）。你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。程序读取的数据、计算得到的结果，也都要放在内存里。内存越大，能加载的东西自然也就越多。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119110753185.png" alt="image-20231119110753185"></p>
<p>内存通常直接可以插在主板上，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/dennissylvesterhurd/7633424314/in/photolist-cCxi73-4DT7ov-5SFN7f-22ptD6Q-5SEAjJ-5SMkhQ-qvfnJh-7TQ7bM-5SAgnX-jwzhXx-5SFTJY-7TQe2k-atvnG7-YGowK7-4w9tXh-5SEDih-dPcqJ1-5SAgFV-8EboSi-5SGJ9r-62Yv2h-5Tft1r-5Xz9Na-89gSAF-5SFFVy-5SMcvH-5KtAAz-eaehyJ-8kYkea-rEdcLj-b39Kug-EST98f-8tR3Vk-7ihCSj-dTYG6-YL543f-4dEEe-BJ8QZ-88ZMZg-6ZzkhW-8Z6NkM-5SBoXn-6JKJfA-7Zx3Su-5SFT2q-7TQkLk-75VyrS-5SGnr4-5SJnWV-5SBpq8">图片来源</a></p>
<p>存放在内存里的程序和数据，需要被 CPU 读取，CPU 计算完之后，还要把数据写回到内存。然而 CPU 不能直接插到内存上，反之亦然。于是，就带来了最后一个大件——<strong>主板</strong>（Motherboard）。</p>
<p>主板是一个有着各种各样，有时候多达数十乃至上百个插槽的配件。我们的 CPU 要插在主板上，内存也要插在主板上。主板的<strong>芯片组</strong>（Chipset）和<strong>总线</strong>（Bus）解决了 CPU 和内存之间如何通信的问题。芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，<strong>总线速度</strong>（Bus Speed）决定了数据能传输得多快。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119110802154.png" alt="image-20231119110802154"></p>
<p>计算机主板上通常有着各种各样的插槽，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/117150261@N02/12448712795/in/photolist-jY3UBe-7JggqE-DUWwNz-9GWzCa-bvGsRS-8m9cYn-e1BaEo-5SEAjJ-5SMkhQ-2eXVzdk-5SEDoU-dmvKB-5SAgnX-5SFTJY-e1vtir-5Pnxus-5SFFVy-63duyC-5SMcvH-jrTkcC-25V6DAn-imfxix-7VRFgR-inZF2N-io1oLM-zHB1BQ-C7aA66-dmE49-K6oVVQ-7VUTom-4pd9Jb-5SEDih-6LK87S-5SAgFV-5SGJ9r-22u9CTJ-7ihCSj-75VyrS-5PigdF-5SGnr4-5SJnWV-5SBpq8-5SNggT-jrTfcY-5SAjgT-5SSUsD-5SAgMi-4eqcQq-22cvYDk-5SAgSn">图片来源</a></p>
<p>有了三大件，只要配上<strong>电源</strong>供电，计算机差不多就可以跑起来了。但是现在还缺少各类输入（Input）/ 输出（Output）设备，也就是我们常说的<strong>I/O 设备</strong>。如果你用的是自己的个人电脑，那显示器肯定必不可少，只有有了显示器我们才能看到计算机输出的各种图像、文字，这也就是所谓的<strong>输出设备</strong>。</p>
<p>同样的，鼠标和键盘也都是必不可少的配件。这样我才能输入文本，写下这篇文章。它们也就是所谓的<strong>输入设备</strong>。</p>
<p>最后，你自己配的个人计算机，还要配上一个硬盘。这样各种数据才能持久地保存下来。绝大部分人都会给自己的机器装上一个机箱，配上风扇，解决灰尘和散热的问题。不过机箱和风扇，算不上是计算机的必备硬件，我们拿个纸板或者外面放个电风扇，也一样能用。</p>
<p>说了这么多，其实你应该有感觉了，显示器、鼠标、键盘和硬盘这些东西并不是一台计算机必须的部分。你想一想，我们其实只需要有 I/O 设备，能让我们从计算机里输入和输出信息，是不是就可以了？答案当然是肯定的。</p>
<p>你肯定去过网吧吧？不知道你注意到没有，很多网吧的计算机就没有硬盘，而是直接通过局域网，读写远程网络硬盘里面的数据。我们日常用的各类云服务器，只要让计算机能通过网络，SSH 远程登陆访问就好了，因此也没必要配显示器、鼠标、键盘这些东西。这样不仅能够节约成本，还更方便维护。</p>
<p>还有一个很特殊的设备，就是<strong>显卡</strong>（Graphics Card）。现在，使用图形界面操作系统的计算机，无论是 Windows、Mac OS 还是 Linux，显卡都是必不可少的。有人可能要说了，我装机的时候没有买显卡，计算机一样可以正常跑起来啊！那是因为，现在的主板都带了内置的显卡。如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。显卡之所以特殊，是因为显卡里有除了 CPU 之外的另一个“处理器”，也就是<strong>GPU</strong>（Graphics Processing Unit，图形处理器），GPU 一样可以做各种“计算”的工作。</p>
<p>鼠标、键盘以及硬盘，这些都是插在主板上的。作为外部 I/O 设备，它们是通过主板上的<strong>南桥</strong>（SouthBridge）芯片组，来控制和 CPU 之间的通信的。“南桥”芯片的名字很直观，一方面，它在主板上的位置，通常在主板的“南面”。另一方面，它的作用就是作为“桥”，来连接鼠标、键盘以及硬盘这些外部设备和 CPU 之间的通信。</p>
<p>有了南桥，自然对应着也有“北桥”。是的，以前的主板上通常也有“北桥”芯片，用来作为“桥”，连接 CPU 和内存、显卡之间的通信。不过，随着时间的变迁，现在的主板上的“北桥”芯片的工作，已经被移到了 CPU 的内部，所以你在主板上，已经看不到北桥芯片了。</p>
<h2 id="112-冯诺依曼体系结构">11.2 冯·诺依曼体系结构</h2>
<p>刚才我们讲了一台计算机的硬件组成，这说的是我们平时用的个人电脑或者服务器。那我们平时最常用的智能手机的组成，也是这样吗？</p>
<p>我们手机里只有 SD 卡（Secure Digital Memory Card）这样类似硬盘功能的存储卡插槽，并没有内存插槽、CPU 插槽这些东西。没错，因为手机尺寸的原因，手机制造商们选择把 CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。这种方式叫<strong>SoC</strong>，也就是 System on a Chip（系统芯片）。</p>
<p>这样看起来，个人电脑和智能手机的硬件组成方式不太一样。可是，我们写智能手机上的 App，和写个人电脑的客户端应用似乎没有什么差别，都是通过“高级语言”这样的编程语言撰写、编译之后，一样是把代码和数据加载到内存里来执行。这是为什么呢？因为，无论是个人电脑、服务器、智能手机，还是 Raspberry Pi 这样的微型卡片机，都遵循着同一个“计算机”的抽象概念。这是怎么样一个“计算机”呢？这其实就是，计算机祖师爷之一冯·诺依曼（John von Neumann）提出的<strong>冯·诺依曼体系结构</strong>（Von Neumann architecture），也叫<strong>存储程序计算机</strong>。</p>
<p>什么是存储程序计算机呢？这里面其实暗含了两个概念，一个是“<strong>可编程</strong>”计算机，一个是“<strong>存储</strong>”计算机。</p>
<p>说到“可编程”，估计你会有点懵，你可以先想想，什么是“不可编程”。计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路版，来完成一个特定的计算程序。一旦需要修改功能，就要重新组装电路。这样的话，计算机就是“不可编程”的，因为程序在计算机硬件层面是“写死”的。最常见的就是老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119110821403.png" alt="image-20231119110821403"></p>
<p>计算器的本质是一个不可编程的计算机，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/horiavarlan/4273218725/in/photolist-7vBn3V-3j7qrv-8iUqcs-biaK7a-qdmGPv-3jbGUN-6pFNS-3jbBa1-4MZAxs-292yK5p-2akim1j-26Bw8bE-qgskU-4EeDGe-NhdPhL-28gSRkC-292yLd6-4wVKuz-29iaje9-81BJ2h-27DSFgw-292yQkV-2akis1L-292yWRa-292yTqn-9sATYG-2akirG9-29ian6G-27DSDV5-9sAUCq-8EGHW5-29iaj49-2akigzf-29iarj1-MexNtE-292yUkt-LDNqXB-29jdR8d-4pyKYY-29nivE4-29iavZy-29iamfy-292yUMa-2akig6u-2akifN5-29jdQs5-29jdQhW-2akifUN-29jdRah-29jdQtN">图片来源</a></p>
<p>我们再来看“存储”计算机。这其实是说，程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。有“存储程序计算机”，自然也有不能存储程序的计算机。典型的就是早年的“Plugboard”这样的插线板式的计算机。整个计算机就是一个巨大的插线板，通过在板子上不同的插头或者接口的位置插入线路，来实现不同的功能。这样的计算机自然是“可编程”的，但是编写好的程序不能存储下来供下一次加载使用，不得不每次要用到和当前不同的“程序”的时候，重新插板子，重新“编程”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119110829370.png" alt="image-20231119110829370"></p>
<p>著名的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Enigma_machine">Engima Machine</a>就用到了 Plugboard 来进行“编程”，<a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Enigma-plugboard.jpg">图片来源</a></p>
<p>可以看到，无论是“不可编程”还是“不可存储”，都会让使用计算机的效率大大下降。而这个对于效率的追求，也就是“存储程序计算机”的由来。</p>
<p>于是我们的冯祖师爷，基于当时在秘密开发的 EDVAC 写了一篇报告<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC"><em>First Draft of a Report on the EDVAC</em></a>，描述了他心目中的一台计算机应该长什么样。这篇报告在历史上有个很特殊的简称，叫<strong>First Draft</strong>，翻译成中文，其实就是《第一份草案》。这样，现代计算机的发展就从祖师爷写的一份草案开始了。</p>
<p><strong>First Draft</strong>里面说了一台计算机应该有哪些部分组成，我们一起来看看。</p>
<p>首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p>
<p>然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU。</p>
<p>接着是用来存储数据（Data）和指令（Instruction）的<strong>内存</strong>。以及更大容量的<strong>外部存储</strong>，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p>
<p>最后就是各种<strong>输入和输出设备</strong>，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。</p>
<p>任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。</p>
<p>而所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119110837770.png" alt="image-20231119110837770"></p>
<p>冯·诺依曼体系结构示意图，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Von_Neumann_architecture#/media/File:Von_Neumann_Architecture.svg">图片来源</a></p>
<p><strong>冯·诺依曼架构（Von Neumann Architecture）</strong> 是冯·诺依曼和其他人提出的电子计算机通用架构。冯·诺依曼架构将通用计算机定义为以下 3 个基本原则：</p>
<ul>
<li><strong>1、采用二进制：</strong> 指令和数据均采用二进制格式；</li>
<li><strong>2、存储程序：</strong> 一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。指令和数据均存储在存储器中，而不是早期的插线板中，计算机按需从存储器中取指令和取数据；</li>
<li><strong>3、计算机由 5 个硬件组成：</strong> 运算器、控制器、存储器、输入设备和输出设备。在最开始的计算机中，五个部件是围绕着运算器运转的，这使得存储器和 I/O 设备之间的数据传送也需要经过运算器。 <strong>而现代计算机中，五个部件是围绕着存储器运转的，这使得存储器和 I/O 设备可以直接完成数据传送，而不需要经过 CPU。</strong></li>
</ul>
<p>在冯·诺依曼架构之前还有一个哈佛架构，现在说的比较少。两者的区别在于冯·诺依曼是将指令和数据存储在同一个存储器的不同位置，存在争用问题；而哈弗架构将指令和数据存储在不同存储器中，规避了争用问题，与 CPU L1 缓存将指令和数据分离的思想类似。</p>
<h2 id="122-冯诺依曼瓶颈">12.2  冯·诺依曼瓶颈</h2>
<p>冯·诺依曼瓶颈的概念最早由 John Backus 在 1977 年的图灵奖领奖演讲中提出： <strong>由于 CPU 和存储器之间共享同一个系统总线，并且 CPU 和存储器之间存在巨大的速度差，导致 CPU 需要不断地被迫等待数据读取或写入到存储器，因此遏制了 CPU 的吞吐量</strong></p>
<p>要从根本上解决冯·诺依曼瓶颈，还是只能重新构建一套新的计算机体系，例如生物计算机、量子计算机。不过，目前它们都还处在非常原始的阶段。现代计算机体系只能采用优化策略来减弱冯·诺依曼瓶颈的影响。</p>
<h2 id="123-总结">12.3 总结</h2>
<p><strong>如果说图灵机描述的是计算机的抽象模型，那么冯·诺依曼架构则是对图灵机这个抽象模型的实现架构。</strong> 冯诺依曼架构确立了现代电子计算机的基础和结构，学习计算机组成原理，其实就是学习和拆解冯诺依曼架构。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231119111138054.png" alt="image-20231119111138054"></p>
<h1 id="0x12-参考文章">0x12 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a20020107020/article/details/130255261">字长与端序</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">字节序探析：大端与小端的比较</a></p>
<p><a target="_blank" rel="noopener" href="http://www.008ct.top/blog/2020/05/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%B4%E7%90%86/">汇编指令入门级整理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/k5210202/p/13365499.html">汇编基础之三 – 汇编指令</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/01%20%20%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%9A%84%E9%87%91%E5%AD%97%E5%A1%94.md"><strong>01 冯·诺依曼体系结构：计算机组成的金字塔</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://mdnice.com/writing/ba4b3af843a84652adef7fae7380da07">一套用了 70 年的计算机架构 —— 冯·诺依曼架构</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">hybcx</div><div class="post-copyright__author_desc">只需热爱, 未来可期！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/')">汇编基础指令</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=汇编基础指令&amp;url=http://hybcx.xyz/2023/11/19/hui-bian-ji-chu-zhi-ling/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hybcx.xyz" target="_blank">hybcx</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/reverse%E7%B3%BB%E5%88%97/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>reverse系列<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Pickle反序列化</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/22/qian-xi-dui-zhan-ping-heng/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">堆栈平衡的学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/11/22/qian-xi-dui-zhan-ping-heng/" title="堆栈平衡的学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-22</div><div class="title">堆栈平衡的学习</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">hybcx</h1><div class="author-info__desc">只需热爱, 未来可期！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hybchenxing" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1761635300" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x01 什么是汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 汇编语言产生的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%B1%87%E7%BC%96%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 汇编与二进制的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">0x02 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 寄存器作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%AD%98%E5%8F%96%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 存取速度比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 寄存器分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E9%80%94"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 常用寄存器用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%AF%84%E5%AD%98%E5%99%A8eax-ax-ah-al%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 寄存器EAX、AX、AH、AL的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 段寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bheap"><span class="toc-number">3.</span> <span class="toc-text">0x03 内存模型：Heap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bstack"><span class="toc-number">4.</span> <span class="toc-text">0x04 内存模型：Stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-cpu-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.</span> <span class="toc-text">0x05 CPU 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-push-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 push 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-call-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-mov-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 mov 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-add-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 add 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-pop-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 pop 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-ret-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 ret 指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8C%87%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">0x06 汇编语言指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 数据传送指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 算术运算指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 逻辑运算指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 循环控制指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-jcc%E6%8C%87%E4%BB%A4%E7%BB%84"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 JCC指令组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-%E5%A0%86%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 堆栈指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">6.8.</span> <span class="toc-text">6.8 跳转指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-linux-%E5%92%8C-windows-%E4%B8%8B%E6%B1%87%E7%BC%96%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">0x07 linux 和 windows 下汇编的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E9%95%BF"><span class="toc-number">8.</span> <span class="toc-text">0x08 什么是字长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x09-%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">9.</span> <span class="toc-text">0x09 大端与小端的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91-%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 可读性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93-%E6%A3%80%E6%9F%A5%E5%A5%87%E5%81%B6%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 检查奇偶性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E6%A3%80%E6%9F%A5%E6%AD%A3%E8%B4%9F%E5%8F%B7"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 检查正负号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#95-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 比较大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#96-%E4%B9%98%E6%B3%95"><span class="toc-number">9.6.</span> <span class="toc-text">9.6 乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#97-%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0"><span class="toc-number">9.7.</span> <span class="toc-text">9.7 任意精度整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E6%9B%B4%E6%94%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.8.</span> <span class="toc-text">9.8 更改类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#99-%E6%80%BB%E7%BB%93"><span class="toc-number">9.9.</span> <span class="toc-text">9.9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x10-%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">0x10 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x11-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB"><span class="toc-number">11.</span> <span class="toc-text">0x11 冯诺依曼结构体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 计算机的基本硬件组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#112-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 冯·诺依曼体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%93%B6%E9%A2%88"><span class="toc-number">11.3.</span> <span class="toc-text">12.2  冯·诺依曼瓶颈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E6%80%BB%E7%BB%93"><span class="toc-number">11.4.</span> <span class="toc-text">12.3 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x12-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">12.</span> <span class="toc-text">0x12 参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-sha-he-gui-bi/" title="THM-沙盒规避">THM-沙盒规避</a><time datetime="2024-08-21T09:41:49.000Z" title="发表于 2024-08-21 17:41:49">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-fang-huo-qiang/" title="THM-防火墙">THM-防火墙</a><time datetime="2024-08-21T07:07:33.000Z" title="发表于 2024-08-21 15:07:33">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-wang-luo-an-quan-jie-jue-fang-an/" title="THM-网络安全解决方案">THM-网络安全解决方案</a><time datetime="2024-08-21T01:37:19.000Z" title="发表于 2024-08-21 09:37:19">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/20/thm-kao-tu-di-wei-sheng/" title="THM-靠土地为生">THM-靠土地为生</a><time datetime="2024-08-20T10:08:09.000Z" title="发表于 2024-08-20 18:08:09">2024-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/20/thm-tao-bi-ri-zhi-ji-lu-he-jian-kong/" title="THM-逃避日志记录和监控">THM-逃避日志记录和监控</a><time datetime="2024-08-20T06:51:56.000Z" title="发表于 2024-08-20 14:51:56">2024-08-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="hybcx" target="_blank">hybcx</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 0.88rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 0.88rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 0.88rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 0.88rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 0.88rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 0.88rem;">TryHackMe<sup>42</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 0.88rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 0.88rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 0.88rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 hybcx 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
      appKey: 'iEFJUGMm2FY91n9ZG1gdKBSy',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://7Sc5uZwc.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
        "X-LC-Key": 'iEFJUGMm2FY91n9ZG1gdKBSy',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>