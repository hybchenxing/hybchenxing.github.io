<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>汇编基础指令 | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>汇编基础指令</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-11-19T01:49:29.501Z" id="date"> 2023-11-19</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-11-25T07:42:32.103Z" id="updated"> 2023-11-25</time></div></span><br><span>文章总字数: <div class="control">12.6k</div></span><br><span>预计阅读时间: <div class="control">45 分钟</div></span></div></div><hr><div id="post-content"><h1>0x01 什么是汇编语言</h1>
<p>汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：</p>
<blockquote>
<p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p>
</blockquote>
<h2 id="1-1-汇编语言产生的原因"><a href="#1-1-汇编语言产生的原因" class="headerlink" title="1-1-汇编语言产生的原因"></a>1.1 汇编语言产生的原因</h2>
<p>对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 <code>00000011</code>，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。</p>
<h2 id="1-2-汇编与二进制的关系"><a href="#1-2-汇编与二进制的关系" class="headerlink" title="1-2-汇编与二进制的关系"></a>1.2 汇编与二进制的关系</h2>
<p>换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便的把汇编程序转译成机器指令程序，比如之前提到的 <code>00000011</code> 加法指令，对应的汇编指令是 <code>ADD</code>，在调用汇编器时就会把 <code>ADD</code> 翻译成 <code>00000011</code>。</p>
<h1>0x02 寄存器</h1>
<p>说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 <code>CPU</code> 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？</p>
<h2 id="2-1-寄存器作用"><a href="#2-1-寄存器作用" class="headerlink" title="2-1-寄存器作用"></a>2.1 寄存器作用</h2>
<p>其实硬盘、内存都是用来存储数据的，但是 <code>CPU</code> 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，<code>CPU</code> 都自带一级缓存和二级缓存，一些 <code>CPU</code> 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 <code>CPU</code>，所以才会有寄存器的存在。</p>
<p>寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现的更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，<code>CPU</code> 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。</p>
<h2 id="2-2-存取速度比较"><a href="#2-2-存取速度比较" class="headerlink" title="2-2-存取速度比较"></a>2.2 存取速度比较</h2>
<p>通过上面的叙述我们可以知道存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code>，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。</p>
<p>通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。</p>
<h2 id="2-3-寄存器分类"><a href="#2-3-寄存器分类" class="headerlink" title="2-3-寄存器分类"></a>2.3 寄存器分类</h2>
<p>常用的 <code>x86 CPU</code> 寄存器有8个：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。</p>
<p>其中<code>AX、BX、CX、DX</code>是通用寄存器，存放一般性数据。1个16位寄存器可以存储16位的数据。</p>
<p>为了向上一代CPU兼容，这4个寄存器可以分为<code>AH、AL，BH、BL，CH、CL，DH、DL</code>。</p>
<p>我们常说的32位、64位 <code>CPU</code> 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 <code>CPU</code> 对应的寄存器也应该是32位的。</p>
<h2 id="2-4-常用寄存器用途"><a href="#2-4-常用寄存器用途" class="headerlink" title="2-4-常用寄存器用途"></a>2.4 常用寄存器用途</h2>
<p>上面提到大8个寄存器都有其特定的用途，我们以32位 <code>CPU</code> 为例简单说明下这些寄存器的作用，整理如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">寄存器</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">用途</th>
<th style="text-align:center">包含寄存器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EAX</td>
<td style="text-align:center">累加(Accumulator)寄存器</td>
<td style="text-align:center">常用于乘、除法和函数返回值</td>
<td style="text-align:center">AX(AH、AL)</td>
</tr>
<tr>
<td style="text-align:center">EBX</td>
<td style="text-align:center">基址(Base)寄存器</td>
<td style="text-align:center">常做内存数据的指针, 或者说常以它为基址来访问内存.</td>
<td style="text-align:center">BX(BH、BL)</td>
</tr>
<tr>
<td style="text-align:center">ECX</td>
<td style="text-align:center">计数器(Counter)寄存器</td>
<td style="text-align:center">常做字符串和循环操作中的计数器</td>
<td style="text-align:center">CX(CH、CL)</td>
</tr>
<tr>
<td style="text-align:center">EDX</td>
<td style="text-align:center">数据(Data)寄存器</td>
<td style="text-align:center">常用于乘、除法和 I/O 指针</td>
<td style="text-align:center">DX(DH、DL)</td>
</tr>
<tr>
<td style="text-align:center">ESI</td>
<td style="text-align:center">来源索引(Source Index)寄存器</td>
<td style="text-align:center">常做内存数据指针和源字符串指针</td>
<td style="text-align:center">SI</td>
</tr>
<tr>
<td style="text-align:center">EDI</td>
<td style="text-align:center">目的索引(Destination Index)寄存器</td>
<td style="text-align:center">常做内存数据指针和目的字符串指针</td>
<td style="text-align:center">DI</td>
</tr>
<tr>
<td style="text-align:center">ESP</td>
<td style="text-align:center">堆栈指针(Stack Point)寄存器</td>
<td style="text-align:center">只做堆栈的栈顶指针; 不能用于算术运算与数据传送</td>
<td style="text-align:center">SP</td>
</tr>
<tr>
<td style="text-align:center">EBP</td>
<td style="text-align:center">基址指针(Base Point)寄存器</td>
<td style="text-align:center">只做堆栈指针, 可以访问堆栈内任意地址, 经常用于中转 ESP 中的数据, 也常以它为基址来访问堆栈; 不能用于算术运算与数据传送</td>
<td style="text-align:center">BP</td>
</tr>
</tbody>
</table>
<h2 id="2-5-寄存器EAX、AX、AH、AL的关系"><a href="#2-5-寄存器EAX、AX、AH、AL的关系" class="headerlink" title="2-5-寄存器EAX、AX、AH、AL的关系"></a>2.5 寄存器EAX、AX、AH、AL的关系</h2>
<p>在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 <code>CPU</code> 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">00000000 00000000 00000000 00000000<br>|===============EAX===============|---4个字节<br>                  |======AX=======|---2个字节<br>                  |==AH===|-----------1个字节<br>                          |===AL==|---1个字节<br></code></pre></td></tr></table></figure>
<h2 id="2-6-物理地址"><a href="#2-6-物理地址" class="headerlink" title="2-6-物理地址"></a>2.6 物理地址</h2>
<p>CPU要想访问内存单元，就要给出内存单元的物理地址，内存是一个一维的线性空间，每一个内存单元都有唯一的地址，这个地址就是<strong>物理地址</strong>。</p>
<p>8086CPU是16位结构的，其数据总线是16位宽，但地址总线是20位，1MB寻址能力。</p>
<p>但内部是16位结构，内部一次性处理、传输地址为16位，所以在内部采用2个16位地址合成方式形成一个20位的物理地址进行内存寻址。</p>
<p><strong>物理地址 = 段地址 * 16 + 偏移地址(段地址*16即左移4位)</strong></p>
<p><strong>其本质含义是：CPU在访问内存时，用一个基础地址(段地址*16)和相对于基础地址的偏移地址相加，得到物理地址。</strong></p>
<p>由于偏移地址为16位，16位地址的寻址能力是64KB，所以一个段的长度最大为64K。</p>
<p>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p>
<h2 id="2-7-段寄存器"><a href="#2-7-段寄存器" class="headerlink" title="2-7-段寄存器"></a>2.7 段寄存器</h2>
<p>8086CPU有4个段寄存器：<code>CS、DS、SS、ES</code>。</p>
<p><code>CS</code>为代码段寄存器，<code>IP</code>为指令指针寄存器。</p>
<p><strong>任意时刻，CPU将CS:IP指向的内容当做当前指令执行。</strong></p>
<p>8086CPU工作过程：</p>
<ul>
<li>从CS:IP指向的内存单元读指令，指令进指令缓冲器</li>
<li>IP指向下一条指令</li>
<li>执行指令，跳到步骤1，重复这个过程</li>
</ul>
<p><strong>CPU根据什么将内存中的信息看做指令？答案是CPU将CS:IP指向的内存单元的内容看做指令。</strong></p>
<p>使用<code>jmp 段地址:偏移地址</code>或<code>jmp 寄存器</code>修改CS:IP或IP的地址。</p>
<p>在编程时，根据需要可以将长度为N的一组代码，存在一组连续的内存单元中，这段内存单元叫做<strong>代码段</strong>。</p>
<p>同样的，可以根据需要将长度为N的一组内存单元，专门存储数据，这段内存单元叫做<strong>数据段</strong>。</p>
<p><strong>8086CPU自动取<code>DS</code>寄存器中的数据为内存单元的段地址。</strong></p>
<p>例如<code>mov [0] cs</code>表示将寄存器<code>cs</code>的值复制到段地址为DS偏移地址为0的内存单元中。</p>
<p>字在内存中存储时，用2个地址连续的内存单元存放，字的低字节放在低地址单元，高字节放在高地址单元。</p>
<p>2.8 标志寄存器</p>
<p>标志寄存器作用：</p>
<ul>
<li>存储相关指令某些执行结果</li>
<li>为CPU执行相关指令提供行为依据</li>
<li>控制CPU相关工作方式</li>
</ul>
<p>8086CPU中有个叫flag寄存器，共16位，每一位代表专门的含义：</p>
<ul>
<li>第6位<code>ZF</code>，<strong>零标志位</strong>：相关指令执行后，结果为0则zf=1，不为0则zf=0</li>
<li>第2位<code>PF</code>，<strong>奇偶标志位</strong>：相关指令执行后，结果所有bit位中1的个数为偶数，pf=1，否则pf=0</li>
<li>第7位<code>SF</code>，<strong>符号标志位</strong>：相关指令执行后，结果是否为负，结果为负sf=1，否则sf=0</li>
<li>第0位<code>CF</code>，<strong>进位标志位</strong>：对于无符号数运算，CF记录运算结果最高有效位向更高位的进位值/借位值</li>
<li>第11位<code>OF</code>，<strong>溢出标志位</strong>：对于有符号数运算，是否发生溢出，溢出则of=1，否则of=0</li>
<li>第10位<code>DF</code>，<strong>方向标志位</strong>：在串处理指令中，控制操作后si、di增减，df=0每次操作后si、di递增，否则递减</li>
</ul>
<h1>0x03 内存模型：Heap</h1>
<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>
<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>
<p class='item-img' data-src='image-20231119101942817.png'><img src="image-20231119101942817.png" alt="image-20231119101942817"></p>
<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>
<p class='item-img' data-src='image-20231119101952917.png'><img src="image-20231119101952917.png" alt="image-20231119101952917"></p>
<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h1>0x04 内存模型：Stack</h1>
<p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>
<p class='item-img' data-src='image-20231119102033874.png'><img src="image-20231119102033874.png" alt="image-20231119102033874"></p>
<p>请看下面的例子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>   <span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>
<p class='item-img' data-src='image-20231119102055485.png'><img src="image-20231119102055485.png" alt="image-20231119102055485"></p>
<p>如果函数内部调用了其他函数，会发生什么情况？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>;<br>   <span class="hljs-type">int</span> b = <span class="hljs-number">3</span>;<br>   <span class="hljs-keyword">return</span> add_a_and_b(a, b);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>
<p class='item-img' data-src='image-20231119102118853.png'><img src="image-20231119102118853.png" alt="image-20231119102118853"></p>
<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做&quot;入栈&quot;，英文是 push；栈的回收叫做&quot;出栈&quot;，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做&quot;后进先出&quot;的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>
<p class='item-img' data-src='image-20231119102130802.png'><img src="image-20231119102130802.png" alt="image-20231119102130802"></p>
<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>
<p class='item-img' data-src='image-20231119102138709.png'><img src="image-20231119102138709.png" alt="image-20231119102138709"></p>
<p>8086CPU提供入栈和出栈的指令：<code>PUSH</code>和<code>POP</code>，任意时刻，寄存器<code>SS:SP</code>指向栈顶元素。</p>
<p>push指令执行：</p>
<ul>
<li>SP=SP-2</li>
<li>向SS:SP指向的字单元送入数据</li>
</ul>
<p>pop指令执行：</p>
<ul>
<li>从SS:SP指向的字单元读数据</li>
<li>SP=SP+2</li>
</ul>
<p>在编程时，要时刻注意栈顶越界的问题，<strong>用栈来可以暂存以后需要恢复的寄存器中的内容。</strong></p>
<p><code>push和pop</code>实质上是一种内存传送指令，同样的，编程时我们可以将长度为N的一组连续内存单元当做栈空间使用，叫做<strong>栈段</strong>。</p>
<p>一个栈段的容量最大为64KB。</p>
<h1>0x05 CPU 指令</h1>
<h2 id="5-1-实例"><a href="#5-1-实例" class="headerlink" title="5-1-实例"></a>5.1 实例</h2>
<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>gcc 将这个程序转成汇编语言。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -S example.c<br></code></pre></td></tr></table></figure>
<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>
<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">_add_a_and_b:<br>   push   %ebx<br>   mov    %eax, [%esp+8] <br>   mov    %ebx, [%esp+12]<br>   add    %eax, %ebx <br>   pop    %ebx <br>   ret  <br><br>_main:<br>   push   3<br>   push   2<br>   call   _add_a_and_b <br>   add    %esp, 8<br>   ret<br></code></pre></td></tr></table></figure>
<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>
<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push   %ebx<br></code></pre></td></tr></table></figure>
<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>
<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>
<h2 id="5-2-push-指令"><a href="#5-2-push-指令" class="headerlink" title="5-2-push-指令"></a>5.2 push 指令</h2>
<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>
<p>然后，开始执行第一行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push   3<br></code></pre></td></tr></table></figure>
<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>
<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push   2<br></code></pre></td></tr></table></figure>
<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>
<p class='item-img' data-src='image-20231119104334762.png'><img src="image-20231119104334762.png" alt="image-20231119104334762"></p>
<h2 id="5-3-call-指令"><a href="#5-3-call-指令" class="headerlink" title="5-3-call-指令"></a>5.3 call 指令</h2>
<p>第三行的<code>call</code>指令用来调用函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call   _add_a_and_b<br></code></pre></td></tr></table></figure>
<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>
<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push   %ebx<br></code></pre></td></tr></table></figure>
<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>
<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>
<h2 id="5-4-mov-指令"><a href="#5-4-mov-指令" class="headerlink" title="5-4-mov-指令"></a>5.4 mov 指令</h2>
<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    %eax, [%esp+8] <br></code></pre></td></tr></table></figure>
<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>
<p>下一行代码也是干同样的事情。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov    %ebx, [%esp+12] <br></code></pre></td></tr></table></figure>
<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>
<h2 id="5-5-add-指令"><a href="#5-5-add-指令" class="headerlink" title="5-5-add-指令"></a>5.5 add 指令</h2>
<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add    %eax, %ebx<br></code></pre></td></tr></table></figure>
<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>
<h2 id="5-6-pop-指令"><a href="#5-6-pop-指令" class="headerlink" title="5-6-pop-指令"></a>5.6 pop 指令</h2>
<p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop    %ebx<br></code></pre></td></tr></table></figure>
<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>
<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>
<h2 id="5-7-ret-指令"><a href="#5-7-ret-指令" class="headerlink" title="5-7-ret-指令"></a>5.7 ret 指令</h2>
<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ret<br></code></pre></td></tr></table></figure>
<p>可以看到，该指令没有运算子。</p>
<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add    %esp, 8 <br></code></pre></td></tr></table></figure>
<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ret<br></code></pre></td></tr></table></figure>
<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>
<h1>0x06 汇编语言指令</h1>
<p>终于说到汇编常用指令了，因为 <code>linux</code> 和 <code>windows</code> 下的汇编语法是有些不同的，所以下面我们先通过 <code>windows</code> 下的汇编指令来简单学习一下，后续再来比较两者的不同。</p>
<h2 id="6-1-数据传送指令"><a href="#6-1-数据传送指令" class="headerlink" title="6-1-数据传送指令"></a>6.1 数据传送指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MOV</td>
<td style="text-align:center">传送指令</td>
<td style="text-align:center">MOV dest, src</td>
<td style="text-align:center">将数据从src移动到dest</td>
</tr>
<tr>
<td style="text-align:center">PUSH</td>
<td style="text-align:center">进栈指令</td>
<td style="text-align:center">PUSH src</td>
<td style="text-align:center">把源操作数src压入堆栈</td>
</tr>
<tr>
<td style="text-align:center">POP</td>
<td style="text-align:center">出栈指令</td>
<td style="text-align:center">POP dest</td>
<td style="text-align:center">从栈顶弹出字数据到dest</td>
</tr>
</tbody>
</table>
<h2 id="6-2-算术运算指令"><a href="#6-2-算术运算指令" class="headerlink" title="6-2-算术运算指令"></a>6.2 算术运算指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ADD</td>
<td style="text-align:center">加法指令</td>
<td style="text-align:center">ADD dest, src</td>
<td style="text-align:center">在dest基础上加src</td>
</tr>
<tr>
<td style="text-align:center">SUB</td>
<td style="text-align:center">减法指令</td>
<td style="text-align:center">SUB dest, src</td>
<td style="text-align:center">在dest基础上减src</td>
</tr>
<tr>
<td style="text-align:center">INC</td>
<td style="text-align:center">加1指令</td>
<td style="text-align:center">INC dest</td>
<td style="text-align:center">在dest基础上加1</td>
</tr>
<tr>
<td style="text-align:center">DEC</td>
<td style="text-align:center">减1指令</td>
<td style="text-align:center">DEC dest</td>
<td style="text-align:center">在dest基础上减1</td>
</tr>
</tbody>
</table>
<h2 id="6-3-逻辑运算指令"><a href="#6-3-逻辑运算指令" class="headerlink" title="6-3-逻辑运算指令"></a>6.3 逻辑运算指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NOT</td>
<td style="text-align:center">取反运算指令</td>
<td style="text-align:center">NOT dest</td>
<td style="text-align:center">把操作数dest按位取反</td>
</tr>
<tr>
<td style="text-align:center">AND</td>
<td style="text-align:center">与运算指令</td>
<td style="text-align:center">AND dest, src</td>
<td style="text-align:center">把dest和src进行与运算之后送回dest</td>
</tr>
<tr>
<td style="text-align:center">OR</td>
<td style="text-align:center">或运算指令</td>
<td style="text-align:center">OR dest, src</td>
<td style="text-align:center">把dest和src进行或运算之后送回dest</td>
</tr>
<tr>
<td style="text-align:center">XOR</td>
<td style="text-align:center">异或运算</td>
<td style="text-align:center">XOR dest, src</td>
<td style="text-align:center">把dest和src进行异或运算之后送回dest</td>
</tr>
</tbody>
</table>
<h2 id="6-4-循环控制指令"><a href="#6-4-循环控制指令" class="headerlink" title="6-4-循环控制指令"></a>6.4 循环控制指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOOP</td>
<td style="text-align:center">计数循环指令</td>
<td style="text-align:center">LOOP label</td>
<td style="text-align:center">使ECX的值减1，当ECX的值不为0的时候跳转至label，否则执行LOOP之后的语句</td>
</tr>
</tbody>
</table>
<h2 id="6-5-转移指令"><a href="#6-5-转移指令" class="headerlink" title="6-5-转移指令"></a>6.5 转移指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JMP</td>
<td style="text-align:center">无条件转移指令</td>
<td style="text-align:center">JMP lable</td>
<td style="text-align:center">无条件地转移到标号为label的位置</td>
</tr>
<tr>
<td style="text-align:center">CALL</td>
<td style="text-align:center">过程调用指令</td>
<td style="text-align:center">CALL labal</td>
<td style="text-align:center">直接调用label</td>
</tr>
<tr>
<td style="text-align:center">JE</td>
<td style="text-align:center">条件转移指令</td>
<td style="text-align:center">JE lable</td>
<td style="text-align:center">zf =1 时跳转到标号为label的位置</td>
</tr>
<tr>
<td style="text-align:center">JNE</td>
<td style="text-align:center">条件转移指令</td>
<td style="text-align:center">JNE lable</td>
<td style="text-align:center">zf=0 时跳转到标号为label的位置</td>
</tr>
</tbody>
</table>
<h2 id="6-6-JCC指令组"><a href="#6-6-JCC指令组" class="headerlink" title="6-6-JCC指令组"></a>6.6 JCC指令组</h2>
<p>J是指jump。CC是条件，该条件与EFL标志寄存器中的标志位息息相关。通过获取EFL标志位的值，判断是否满足条件而是否执行JUMP操作。对应了高级语言中的比较运算。</p>
<table>
<thead>
<tr>
<th style="text-align:left">JCC指令</th>
<th style="text-align:left">中文含义</th>
<th style="text-align:left">检查符号位</th>
<th style="text-align:left">典型C应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JZ/JE</td>
<td style="text-align:left">若为0则跳转；若相等则跳转</td>
<td style="text-align:left">ZF=1</td>
<td style="text-align:left">if (i == j);if (i == 0);</td>
</tr>
<tr>
<td style="text-align:left">JNZ/JNE</td>
<td style="text-align:left">若不为0则跳转；若不相等则跳转</td>
<td style="text-align:left">ZF=0</td>
<td style="text-align:left">if (i != j);if (i != 0);</td>
</tr>
<tr>
<td style="text-align:left">JS</td>
<td style="text-align:left">若为负则跳转</td>
<td style="text-align:left">SF=1</td>
<td style="text-align:left">if (i &lt; 0);</td>
</tr>
<tr>
<td style="text-align:left">JNS</td>
<td style="text-align:left">若为非负数则跳转</td>
<td style="text-align:left">SF=0</td>
<td style="text-align:left">if (i &gt;= 0);</td>
</tr>
<tr>
<td style="text-align:left">JP/JPE</td>
<td style="text-align:left">若1出现次数为偶数则跳转</td>
<td style="text-align:left">PF=1</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JNP/JPO</td>
<td style="text-align:left">若1出现次数为奇数则跳转</td>
<td style="text-align:left">PF=0</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JO</td>
<td style="text-align:left">若溢出则跳转</td>
<td style="text-align:left">OF=1</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JNO</td>
<td style="text-align:left">若无溢出则跳转</td>
<td style="text-align:left">OF=0</td>
<td style="text-align:left">(null)</td>
</tr>
<tr>
<td style="text-align:left">JC/JB/JNAE</td>
<td style="text-align:left">若进位则跳转；若低于则跳转；若不高于等于则跳转</td>
<td style="text-align:left">CF=1</td>
<td style="text-align:left">if (i &lt; j);</td>
</tr>
<tr>
<td style="text-align:left">JNC/JNB/JAE</td>
<td style="text-align:left">若无进位则跳转；若不低于则跳转；若高于等于则跳转；</td>
<td style="text-align:left">CF=0</td>
<td style="text-align:left">if (i &gt;= j);</td>
</tr>
<tr>
<td style="text-align:left">JBE/JNA</td>
<td style="text-align:left">若低于等于则跳转；若不高于则跳转</td>
<td style="text-align:left">ZF=1或CF=1</td>
<td style="text-align:left">if (i &lt;= j);</td>
</tr>
<tr>
<td style="text-align:left">JNBE/JA</td>
<td style="text-align:left">若不低于等于则跳转；若高于则跳转</td>
<td style="text-align:left">ZF=0或CF=0</td>
<td style="text-align:left">if (i &gt; j);</td>
</tr>
<tr>
<td style="text-align:left">JL/JNGE</td>
<td style="text-align:left">若小于则跳转；若不大于等于则跳转</td>
<td style="text-align:left">SF != OF</td>
<td style="text-align:left">if (si &lt; sj);</td>
</tr>
<tr>
<td style="text-align:left">JNL/JGE</td>
<td style="text-align:left">若不小于则跳转；若大于等于则跳转；</td>
<td style="text-align:left">SF = OF</td>
<td style="text-align:left">if (si &gt;= sj);</td>
</tr>
<tr>
<td style="text-align:left">JLE/JNG</td>
<td style="text-align:left">若小于等于则跳转；若不大于则跳转</td>
<td style="text-align:left">ZF != OF 或 ZF=1</td>
<td style="text-align:left">if (si &lt;= sj);</td>
</tr>
<tr>
<td style="text-align:left">JNLE/JG</td>
<td style="text-align:left">若不小于等于则跳转；若大于则跳转</td>
<td style="text-align:left">SF=0F 且 ZF=0</td>
<td style="text-align:left">if(si&gt;sj)ag</td>
</tr>
</tbody>
</table>
<h2 id="6-7-堆栈指令"><a href="#6-7-堆栈指令" class="headerlink" title="6-7-堆栈指令"></a>6.7 堆栈指令</h2>
<p>ESP：栈顶指针寄存器，记录当前使用的地址，栈的内存空间是存大地址开始使用的。EBP：栈底指针寄存器，记录栈开始的位置。</p>
<p>我们可以使用MOV指令，将数据MOV到ESP寄存器指定的位置，然后使用SUB或者ADD指令，将ESP寄存器的值偏移对应的数据宽度值，实现数据的入栈和出栈操作。基于这样的原理，汇编中提供了PUSH和POP命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV BYTE PTR DS:[ESP], 0xFF          // 向栈中写入一个字节<br>SUB ESP, 1                           // 栈顶指针偏移一字节<br><br>以上两个操作等同于一个push操作<br>PUSH 0xFF                           // 将0xFF写入到ESP保存的地址处，同时ESP偏移一个数据宽度<br>PUSH EAX   　　　　　　　　　　　　　// EAX中的值入栈<br>PUSH DWORD PTR DS:[地址]             // 该地址处的值入栈<br><br>出栈同理 <br>POP DWORD　EAX                     // 将栈顶的元素取出放入EAX寄存器中保存，同时ESP偏移一个DWORD数据宽度<br></code></pre></td></tr></table></figure>
<h2 id="6-8-跳转指令"><a href="#6-8-跳转指令" class="headerlink" title="6-8-跳转指令"></a>6.8 跳转指令</h2>
<ul>
<li>JMP：将程序跳转到指定的地址执行，通过改变EIP中的值实现</li>
<li>CALL：将程序跳转到指定的地址，跳转前将下一次执行的地址保存到栈中，用来记录跳转前的位置。然后改变EIP中的值使得cpu去执行其他地址的指令。当执行结束需要返回原来的地址时，从栈中取出跳转签到的地址，赋值到EIP寄存器中即可回到跳转前的状态。</li>
<li>RETN：从栈中取出保存的地址，赋值给EIP，用作下次执行</li>
</ul>
<p>使用这两个指令需要理解EIP寄存器的作用。当一个程序被编译完成之后，程序的执行方法即已经确定，即A=&gt;B=&gt;C的顺序进行执行，且他们使用的内存空间说连续的，计算机执行一行指令后，下一次要执行的内容都保存在EIP寄存器保存的地址处。所以EIP寄存器指向的内容，就是程序下一次执行的指令。也就是说，A执行时，EIP寄存器中保存的是B的地址，这样执行A后将会获取B的信息并执行。如果A是一个JMP或者CALL指令，执行依次<code>JMP EIP D</code>，这条指令表示将EIP中的值改为D的地址，所以下一次执行的即为D指令。由此实现了跳转。这样的方式当程序跳转到D指令后，程序无法返回B指令了，因为我们找不到B的地址，想要重新回到B指令，需要将B的地址保存，使用时取回即可，通常是将其入栈。这样就和CALL指令的使用方式相同了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">JMP EIP, 地址   // 修改EIP寄存器中的值。<br>CALL　地址　   // 跳转到指定地址，执行该地址的指令，跳转前，将下一行地址入栈，<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231120193326379.png'><img src="image-20231120193326379.png" alt="image-20231120193326379"></p>
<h1>0x07 linux 和 windows 下汇编的区别</h1>
<p>前面说到 <code>linux</code> 和 <code>windows</code> 下的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 <code>linux</code> 上会使用 <code>gcc/g++</code> 编译器，而在 <code>windows</code> 上会使用微软的 <code>cl</code> 也就是 <code>MSBUILD</code>，所以产生不同的代码是因为编译器不同，<code>gcc</code> 下采用的是AT&amp;T的汇编语法格式，<code>MSBUILD</code> 采用的是Intel汇编语法格式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">差异</th>
<th style="text-align:center">Intel</th>
<th style="text-align:center">AT&amp;T</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">引用寄存器名字</td>
<td style="text-align:center">eax</td>
<td style="text-align:center">%eax</td>
</tr>
<tr>
<td style="text-align:center">赋值操作数顺序</td>
<td style="text-align:center">mov dest, src</td>
<td style="text-align:center">movl src, dest</td>
</tr>
<tr>
<td style="text-align:center">寄存器、立即数指令前缀</td>
<td style="text-align:center">mov ebx, 0xd00d</td>
<td style="text-align:center">movl $0xd00d, %ebx</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接寻址</td>
<td style="text-align:center">[eax]</td>
<td style="text-align:center">(%eax)</td>
</tr>
<tr>
<td style="text-align:center">数据类型大小</td>
<td style="text-align:center">操作码后加后缀字母，“l” 32位，“w” 16位，“b” 8位（mov dx, word ptr [eax]）</td>
<td style="text-align:center">操作数前面加dword ptr， word ptr，byte ptr的格式 （movb %bl %al）</td>
</tr>
</tbody>
</table>
<h1>0x08 什么是字长</h1>
<p>​		内存以字节为单位。 一个字节是 8 个比特位，可以表示 2^8 = 256 个数。大小为 8 位的二进制数是从 0 开始到 255 这 256 个值中的一个。 两个字节被称为一个字（WORD），两个字被称为四个字节（32位）也即双字（DWORD），四字 （QWORD）是八个字节（64 位）。 这些连续的字节要按什么样的顺序排列和解释，这就涉及到端序的范畴了。 字节的排列方式有两个通用规则: 大端序（Big-Endian）与小端序（Little-Endian）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">大端序（Big-Endian）将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种 排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。<br><br>小端序（Little-Endian）将数据的低位字节放在较小的地址处，高位放在较大的地址处。小端序与 人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地 址向高地址方向进行读取的。<br></code></pre></td></tr></table></figure>
<h1>0x09 大端与小端的比较</h1>
<h2 id="9-1-概念"><a href="#9-1-概念" class="headerlink" title="9-1-概念"></a>9.1 概念</h2>
<p>字节序指的是，<strong>多字节数据的内存排列顺序</strong>。这样说比较抽象，使用图形解释就很好懂。</p>
<p>内存好比一排房间，每个字节是一间房。每间房都有门牌号（内存地址），从0号开始，然后是1号、2号…</p>
<p class='item-img' data-src='image-20231119100702283.png'><img src="image-20231119100702283.png" alt="image-20231119100702283"></p>
<p>0号字节的地址小，称为低位内存；3号字节的地址大，称为高位内存。</p>
<p>现在有一个数值<code>abcd</code>要放进这些房间，每个房间放一个数字，那么有两种放法。</p>
<p>第一种放法是，第一位<code>a</code>放在低位地址（0号），最后一位<code>d</code>放在高位地址（3号）。</p>
<p class='item-img' data-src='image-20231119100710379.png'><img src="image-20231119100710379.png" alt="image-20231119100710379"></p>
<p>这种排列称为&quot;<strong>大端序</strong>&quot;（big-endian，简称 BE），即大头在前，因为<code>a</code>是<code>abcd</code>的大头（最重要的数字）。</p>
<p>第二种放法是，第一位<code>a</code>放在高位地址（3号地址），最后一位<code>d</code>放在低位地址（0号地址）。</p>
<p class='item-img' data-src='image-20231119100719213.png'><img src="image-20231119100719213.png" alt="image-20231119100719213"></p>
<p>这种排列称为&quot;<strong>小端序</strong>&quot;（little-endian，简称 LE），即小头<code>d</code>在前。</p>
<p>大端序和小端序合称字节序，这两个名字来自18世纪的英国小说《格列佛游记》。某国分成两派，一派认为鸡蛋应该从大头吃起，称为&quot;大端派&quot;；另一派认为，鸡蛋应该从小头吃起，称为&quot;小端派&quot;。两派相执不下，谁也无法说服谁，最后甚至为此交战。</p>
<p class='item-img' data-src='image-20231119100732966.png'><img src="image-20231119100732966.png" alt="image-20231119100732966"></p>
<h2 id="9-2-可读性"><a href="#9-2-可读性" class="headerlink" title="9-2-可读性"></a>9.2 可读性</h2>
<p>对于人类来说，不同字节序的可读性是不一样的。大部分国家的阅读习惯是从左到右阅读。</p>
<p class='item-img' data-src='image-20231119100747791.png'><img src="image-20231119100747791.png" alt="image-20231119100747791"></p>
<p>大端序的最高位在左边，最低位在右边，符合阅读习惯。所以，对于这些国家的人来说，<strong>从左到右的大端序的可读性更好。</strong></p>
<p>但是现实中，从右到左的小端序虽然可读性差，但应用更广泛，x86 和 ARM 这两种 CPU 架构都采用小端序，这是为什么？</p>
<p>或者换一种问法，两种不同的字节序为什么会并存，统一规定只使用一种，难道不是更方便吗？</p>
<p>原因是它们有各自的适用场景，某些场景大端序有优势，另一些场景小端序有优势，下面就逐一分析。</p>
<h2 id="9-3-检查奇偶性"><a href="#9-3-检查奇偶性" class="headerlink" title="9-3-检查奇偶性"></a>9.3 检查奇偶性</h2>
<p>小端序优势最明显的，大概就是检查奇偶性，即通过查看个位数，确定某个数字是奇数还是偶数。</p>
<p class='item-img' data-src='image-20231119100802290.png'><img src="image-20231119100802290.png" alt="image-20231119100802290"></p>
<p>以<code>123456</code>为例，大端序从左到右排列，计算机必须一直读到最后一位的个位数<code>6</code>，才能确定这是偶数。</p>
<p>小端序是从右到左排列，个位数在第一位。所以，只要读取第一位，就能确定它是偶数。</p>
<h2 id="9-4-检查正负号"><a href="#9-4-检查正负号" class="headerlink" title="9-4-检查正负号"></a>9.4 检查正负号</h2>
<p>一个类似的场景是检查正负号，确定一个数是正数还是负数。</p>
<p class='item-img' data-src='image-20231119100810206.png'><img src="image-20231119100810206.png" alt="image-20231119100810206"></p>
<p>大端序的符号位在左边第一位，小端序的符号位在右边最后一位。所以，大端序有优势，只看第一位就能知道是不是负数。</p>
<h2 id="9-5-比较大小"><a href="#9-5-比较大小" class="headerlink" title="9-5-比较大小"></a>9.5 比较大小</h2>
<p>下一个操作是比较大小。现在有三个数字，需要比较大小：43662576，594，2。</p>
<p class='item-img' data-src='image-20231119100817614.png'><img src="image-20231119100817614.png" alt="image-20231119100817614"></p>
<p>上图是大端序排列，因为是从左到右排列，所以三个数字在右边个位数对齐。比较大小时，计算机就不得不读取每一个数的所有位，直到个位数，再进行比较。</p>
<p>如果改成小端序，就是下面的排列方式。</p>
<p class='item-img' data-src='image-20231119100834253.png'><img src="image-20231119100834253.png" alt="image-20231119100834253"></p>
<p>小端序是从右到左，所以三个数字在第一位对齐。计算机就不需要读取所有位，哪个数字先读不到下一位，就是最小的。比如，<code>2</code>这个数字就没有第二位，所以读到第二位时，就知道它是最小的。</p>
<p>所以，比较大小时，小端序有优势。</p>
<h2 id="9-6-乘法"><a href="#9-6-乘法" class="headerlink" title="9-6-乘法"></a>9.6 乘法</h2>
<p>接下来，再看乘法操作。</p>
<p>乘法是逐位相乘，每一轮乘法都要向前进位。</p>
<p class='item-img' data-src='image-20231119100846922.png'><img src="image-20231119100846922.png" alt="image-20231119100846922"></p>
<p>上图是大端序的24165乘以3841。大端序的乘法是向左进位，也就是向左边扩展，必须等到每一轮的结果都出来（上例是四轮），再相加统一写入内存。</p>
<p>如果改成小端序的乘法，就不需要等待下一轮的结果，每一轮都可以直接写入内存。</p>
<p class='item-img' data-src='image-20231119100858692.png'><img src="image-20231119100858692.png" alt="image-20231119100858692"></p>
<p>上图是小端序的24165乘以3841。小端序的乘法是向右进位，也就是向右边扩展，左边的边界不变。每一轮结果写入内存后，就不需要移动，后面有变化只需要改动对应的位就行了。</p>
<p>因此，小端序的乘法有明显优势。</p>
<h2 id="9-7-任意精度整数"><a href="#9-7-任意精度整数" class="headerlink" title="9-7-任意精度整数"></a>9.7 任意精度整数</h2>
<p>上一个例子的从低位开始计算的特性，对于任意精度整数特别有用。任意精度整数又称大整数，可以存放任意大小的整数。</p>
<p>它的内部实现是把整数分成一个个较小的单位，通常是 uint32（无符号32位整数）或 uint64（无符号64位整数），按顺序组合在一起。</p>
<p class='item-img' data-src='image-20231119100906634.png'><img src="image-20231119100906634.png" alt="image-20231119100906634"></p>
<p>如果是大端序，第一个 u64 就是这个整数最大的部分。运算时，一旦这个数发生变化，需要进位，后面的所有位都必须移动和改写。小端序发生进位时，往往就不需要所有位移动。</p>
<p>小端序的另一个好处是，如果逐字节的运算从个位数开始（比如乘法和加法），可以从左到右依次运算一个个 u64，算完上一个再读取下一个。大端序就不行，必须读取整个数以后再进行运算。</p>
<h2 id="9-8-更改类型"><a href="#9-8-更改类型" class="headerlink" title="9-8-更改类型"></a>9.8 更改类型</h2>
<p>最后一个例子是，C 语言有一种 cast 操作，可以强制改变变量的数据类型，比如把32位整数强行改变为16位整数。</p>
<p class='item-img' data-src='image-20231119100914441.png'><img src="image-20231119100914441.png" alt="image-20231119100914441"></p>
<p>上图中，32位整数<code>0x00000001</code>更改为16位整数<code>0x0001</code>，大端序是截去前面两个字节，这时指向这个地址的指针必须向后移动两个字节。</p>
<p>小端序就没有这个问题，截去的是后面两个字节，第一位的地址是不变的，所以指针不需要移动。</p>
<h2 id="9-9-总结"><a href="#9-9-总结" class="headerlink" title="9-9-总结"></a>9.9 总结</h2>
<p>综上所述，大端序和小端序各自的优势如下。</p>
<p>如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势。反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势。</p>
<h1>0x10 总结</h1>
<ul>
<li>汇编指令是机器指令的助记符，与机器指令是一一对应的</li>
<li>AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的</li>
<li>常用寄存器：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code></li>
<li>存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code></li>
<li>常用的汇编指令：<code>mov</code>、<code>je</code>、<code>jmp</code>、<code>call</code>、<code>add</code>、<code>sub</code>、<code>inc</code>、<code>dec</code>、<code>and</code>、<code>or</code></li>
</ul>
<h1>0x11 冯诺依曼结构体系</h1>
<h2 id="11-1-计算机的基本硬件组成"><a href="#11-1-计算机的基本硬件组成" class="headerlink" title="11-1-计算机的基本硬件组成"></a>11.1 计算机的基本硬件组成</h2>
<p>早年，要自己组装一台计算机，要先有三大件，CPU、内存和主板。</p>
<p>在这三大件中，我们首先要说的是<strong>CPU</strong>，它是计算机最重要的核心配件，全名你肯定知道，叫中央处理器（Central Processing Unit）。为什么说 CPU 是“最重要”的呢？因为计算机的所有“计算”都是由 CPU 来进行的。自然，CPU 也是整台计算机中造价最昂贵的部分之一。</p>
<p class='item-img' data-src='image-20231119110740067.png'><img src="image-20231119110740067.png" alt="image-20231119110740067"></p>
<p>CPU 是一个超级精细的印刷电路版，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/130561288@N04/39836037882/in/photolist-23Gb7cm-25V6DAn-q421FW-qMvhAJ-7yVugk-qMvgHb-o3NoQV-qMwDkj-qMvgT1-7yVu7T-qMvgMj-7yVu5c-py3Fpg-8pZhf1-7yZhR5-7yVuax-ewr4C-7TQAKk-7SbTox-8pZh3b-fkLugb-HCGERb-231L6Mo-5SSUsD-28WhLvN-K2Tvk-98Cc4e-6ag8YH-7Sf6KS-aDGEYV-7yY2XT-b66LSc-r2oZqk-rPcasz-7TQ1dB-754sSu-qMwEzy-npvMDK-4BDkou-zrid4-a8X3jn-5uTaCd-7SbRFV-7TTeJh-6ag8zX-6akhEm-7ihCSj-8Whgmi-6j5iUJ-6ag8m8">图片来源</a></p>
<p>第二个重要的配件，就是<strong>内存</strong>（Memory）。你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。程序读取的数据、计算得到的结果，也都要放在内存里。内存越大，能加载的东西自然也就越多。</p>
<p class='item-img' data-src='image-20231119110753185.png'><img src="image-20231119110753185.png" alt="image-20231119110753185"></p>
<p>内存通常直接可以插在主板上，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/dennissylvesterhurd/7633424314/in/photolist-cCxi73-4DT7ov-5SFN7f-22ptD6Q-5SEAjJ-5SMkhQ-qvfnJh-7TQ7bM-5SAgnX-jwzhXx-5SFTJY-7TQe2k-atvnG7-YGowK7-4w9tXh-5SEDih-dPcqJ1-5SAgFV-8EboSi-5SGJ9r-62Yv2h-5Tft1r-5Xz9Na-89gSAF-5SFFVy-5SMcvH-5KtAAz-eaehyJ-8kYkea-rEdcLj-b39Kug-EST98f-8tR3Vk-7ihCSj-dTYG6-YL543f-4dEEe-BJ8QZ-88ZMZg-6ZzkhW-8Z6NkM-5SBoXn-6JKJfA-7Zx3Su-5SFT2q-7TQkLk-75VyrS-5SGnr4-5SJnWV-5SBpq8">图片来源</a></p>
<p>存放在内存里的程序和数据，需要被 CPU 读取，CPU 计算完之后，还要把数据写回到内存。然而 CPU 不能直接插到内存上，反之亦然。于是，就带来了最后一个大件——<strong>主板</strong>（Motherboard）。</p>
<p>主板是一个有着各种各样，有时候多达数十乃至上百个插槽的配件。我们的 CPU 要插在主板上，内存也要插在主板上。主板的<strong>芯片组</strong>（Chipset）和<strong>总线</strong>（Bus）解决了 CPU 和内存之间如何通信的问题。芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，<strong>总线速度</strong>（Bus Speed）决定了数据能传输得多快。</p>
<p class='item-img' data-src='image-20231119110802154.png'><img src="image-20231119110802154.png" alt="image-20231119110802154"></p>
<p>计算机主板上通常有着各种各样的插槽，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/117150261@N02/12448712795/in/photolist-jY3UBe-7JggqE-DUWwNz-9GWzCa-bvGsRS-8m9cYn-e1BaEo-5SEAjJ-5SMkhQ-2eXVzdk-5SEDoU-dmvKB-5SAgnX-5SFTJY-e1vtir-5Pnxus-5SFFVy-63duyC-5SMcvH-jrTkcC-25V6DAn-imfxix-7VRFgR-inZF2N-io1oLM-zHB1BQ-C7aA66-dmE49-K6oVVQ-7VUTom-4pd9Jb-5SEDih-6LK87S-5SAgFV-5SGJ9r-22u9CTJ-7ihCSj-75VyrS-5PigdF-5SGnr4-5SJnWV-5SBpq8-5SNggT-jrTfcY-5SAjgT-5SSUsD-5SAgMi-4eqcQq-22cvYDk-5SAgSn">图片来源</a></p>
<p>有了三大件，只要配上<strong>电源</strong>供电，计算机差不多就可以跑起来了。但是现在还缺少各类输入（Input）/ 输出（Output）设备，也就是我们常说的<strong>I/O 设备</strong>。如果你用的是自己的个人电脑，那显示器肯定必不可少，只有有了显示器我们才能看到计算机输出的各种图像、文字，这也就是所谓的<strong>输出设备</strong>。</p>
<p>同样的，鼠标和键盘也都是必不可少的配件。这样我才能输入文本，写下这篇文章。它们也就是所谓的<strong>输入设备</strong>。</p>
<p>最后，你自己配的个人计算机，还要配上一个硬盘。这样各种数据才能持久地保存下来。绝大部分人都会给自己的机器装上一个机箱，配上风扇，解决灰尘和散热的问题。不过机箱和风扇，算不上是计算机的必备硬件，我们拿个纸板或者外面放个电风扇，也一样能用。</p>
<p>说了这么多，其实你应该有感觉了，显示器、鼠标、键盘和硬盘这些东西并不是一台计算机必须的部分。你想一想，我们其实只需要有 I/O 设备，能让我们从计算机里输入和输出信息，是不是就可以了？答案当然是肯定的。</p>
<p>你肯定去过网吧吧？不知道你注意到没有，很多网吧的计算机就没有硬盘，而是直接通过局域网，读写远程网络硬盘里面的数据。我们日常用的各类云服务器，只要让计算机能通过网络，SSH 远程登陆访问就好了，因此也没必要配显示器、鼠标、键盘这些东西。这样不仅能够节约成本，还更方便维护。</p>
<p>还有一个很特殊的设备，就是<strong>显卡</strong>（Graphics Card）。现在，使用图形界面操作系统的计算机，无论是 Windows、Mac OS 还是 Linux，显卡都是必不可少的。有人可能要说了，我装机的时候没有买显卡，计算机一样可以正常跑起来啊！那是因为，现在的主板都带了内置的显卡。如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。显卡之所以特殊，是因为显卡里有除了 CPU 之外的另一个“处理器”，也就是<strong>GPU</strong>（Graphics Processing Unit，图形处理器），GPU 一样可以做各种“计算”的工作。</p>
<p>鼠标、键盘以及硬盘，这些都是插在主板上的。作为外部 I/O 设备，它们是通过主板上的<strong>南桥</strong>（SouthBridge）芯片组，来控制和 CPU 之间的通信的。“南桥”芯片的名字很直观，一方面，它在主板上的位置，通常在主板的“南面”。另一方面，它的作用就是作为“桥”，来连接鼠标、键盘以及硬盘这些外部设备和 CPU 之间的通信。</p>
<p>有了南桥，自然对应着也有“北桥”。是的，以前的主板上通常也有“北桥”芯片，用来作为“桥”，连接 CPU 和内存、显卡之间的通信。不过，随着时间的变迁，现在的主板上的“北桥”芯片的工作，已经被移到了 CPU 的内部，所以你在主板上，已经看不到北桥芯片了。</p>
<h2 id="11-2-冯·诺依曼体系结构"><a href="#11-2-冯·诺依曼体系结构" class="headerlink" title="11-2-冯·诺依曼体系结构"></a>11.2 冯·诺依曼体系结构</h2>
<p>刚才我们讲了一台计算机的硬件组成，这说的是我们平时用的个人电脑或者服务器。那我们平时最常用的智能手机的组成，也是这样吗？</p>
<p>我们手机里只有 SD 卡（Secure Digital Memory Card）这样类似硬盘功能的存储卡插槽，并没有内存插槽、CPU 插槽这些东西。没错，因为手机尺寸的原因，手机制造商们选择把 CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。这种方式叫<strong>SoC</strong>，也就是 System on a Chip（系统芯片）。</p>
<p>这样看起来，个人电脑和智能手机的硬件组成方式不太一样。可是，我们写智能手机上的 App，和写个人电脑的客户端应用似乎没有什么差别，都是通过“高级语言”这样的编程语言撰写、编译之后，一样是把代码和数据加载到内存里来执行。这是为什么呢？因为，无论是个人电脑、服务器、智能手机，还是 Raspberry Pi 这样的微型卡片机，都遵循着同一个“计算机”的抽象概念。这是怎么样一个“计算机”呢？这其实就是，计算机祖师爷之一冯·诺依曼（John von Neumann）提出的<strong>冯·诺依曼体系结构</strong>（Von Neumann architecture），也叫<strong>存储程序计算机</strong>。</p>
<p>什么是存储程序计算机呢？这里面其实暗含了两个概念，一个是“<strong>可编程</strong>”计算机，一个是“<strong>存储</strong>”计算机。</p>
<p>说到“可编程”，估计你会有点懵，你可以先想想，什么是“不可编程”。计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路版，来完成一个特定的计算程序。一旦需要修改功能，就要重新组装电路。这样的话，计算机就是“不可编程”的，因为程序在计算机硬件层面是“写死”的。最常见的就是老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情。</p>
<p class='item-img' data-src='image-20231119110821403.png'><img src="image-20231119110821403.png" alt="image-20231119110821403"></p>
<p>计算器的本质是一个不可编程的计算机，<a target="_blank" rel="noopener" href="https://www.flickr.com/photos/horiavarlan/4273218725/in/photolist-7vBn3V-3j7qrv-8iUqcs-biaK7a-qdmGPv-3jbGUN-6pFNS-3jbBa1-4MZAxs-292yK5p-2akim1j-26Bw8bE-qgskU-4EeDGe-NhdPhL-28gSRkC-292yLd6-4wVKuz-29iaje9-81BJ2h-27DSFgw-292yQkV-2akis1L-292yWRa-292yTqn-9sATYG-2akirG9-29ian6G-27DSDV5-9sAUCq-8EGHW5-29iaj49-2akigzf-29iarj1-MexNtE-292yUkt-LDNqXB-29jdR8d-4pyKYY-29nivE4-29iavZy-29iamfy-292yUMa-2akig6u-2akifN5-29jdQs5-29jdQhW-2akifUN-29jdRah-29jdQtN">图片来源</a></p>
<p>我们再来看“存储”计算机。这其实是说，程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。有“存储程序计算机”，自然也有不能存储程序的计算机。典型的就是早年的“Plugboard”这样的插线板式的计算机。整个计算机就是一个巨大的插线板，通过在板子上不同的插头或者接口的位置插入线路，来实现不同的功能。这样的计算机自然是“可编程”的，但是编写好的程序不能存储下来供下一次加载使用，不得不每次要用到和当前不同的“程序”的时候，重新插板子，重新“编程”。</p>
<p class='item-img' data-src='image-20231119110829370.png'><img src="image-20231119110829370.png" alt="image-20231119110829370"></p>
<p>著名的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Enigma_machine">Engima Machine</a>就用到了 Plugboard 来进行“编程”，<a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Enigma-plugboard.jpg">图片来源</a></p>
<p>可以看到，无论是“不可编程”还是“不可存储”，都会让使用计算机的效率大大下降。而这个对于效率的追求，也就是“存储程序计算机”的由来。</p>
<p>于是我们的冯祖师爷，基于当时在秘密开发的 EDVAC 写了一篇报告<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC"><em>First Draft of a Report on the EDVAC</em></a>，描述了他心目中的一台计算机应该长什么样。这篇报告在历史上有个很特殊的简称，叫<strong>First Draft</strong>，翻译成中文，其实就是《第一份草案》。这样，现代计算机的发展就从祖师爷写的一份草案开始了。</p>
<p><strong>First Draft</strong>里面说了一台计算机应该有哪些部分组成，我们一起来看看。</p>
<p>首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的<strong>处理器单元</strong>（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。</p>
<p>然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的<strong>控制器单元</strong>（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU。</p>
<p>接着是用来存储数据（Data）和指令（Instruction）的<strong>内存</strong>。以及更大容量的<strong>外部存储</strong>，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。</p>
<p>最后就是各种<strong>输入和输出设备</strong>，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。</p>
<p>任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。</p>
<p>而所有的计算机程序，也都可以抽象为从<strong>输入设备</strong>读取输入信息，通过<strong>运算器</strong>和<strong>控制器</strong>来执行存储在<strong>存储器</strong>里的程序，最终把结果输出到<strong>输出设备</strong>中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。</p>
<p class='item-img' data-src='image-20231119110837770.png'><img src="image-20231119110837770.png" alt="image-20231119110837770"></p>
<p>冯·诺依曼体系结构示意图，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Von_Neumann_architecture#/media/File:Von_Neumann_Architecture.svg">图片来源</a></p>
<p><strong>冯·诺依曼架构（Von Neumann Architecture）</strong> 是冯·诺依曼和其他人提出的电子计算机通用架构。冯·诺依曼架构将通用计算机定义为以下 3 个基本原则：</p>
<ul>
<li><strong>1、采用二进制：</strong> 指令和数据均采用二进制格式；</li>
<li><strong>2、存储程序：</strong> 一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。指令和数据均存储在存储器中，而不是早期的插线板中，计算机按需从存储器中取指令和取数据；</li>
<li><strong>3、计算机由 5 个硬件组成：</strong> 运算器、控制器、存储器、输入设备和输出设备。在最开始的计算机中，五个部件是围绕着运算器运转的，这使得存储器和 I/O 设备之间的数据传送也需要经过运算器。 <strong>而现代计算机中，五个部件是围绕着存储器运转的，这使得存储器和 I/O 设备可以直接完成数据传送，而不需要经过 CPU。</strong></li>
</ul>
<p>在冯·诺依曼架构之前还有一个哈佛架构，现在说的比较少。两者的区别在于冯·诺依曼是将指令和数据存储在同一个存储器的不同位置，存在争用问题；而哈弗架构将指令和数据存储在不同存储器中，规避了争用问题，与 CPU L1 缓存将指令和数据分离的思想类似。</p>
<h2 id="12-2-冯·诺依曼瓶颈"><a href="#12-2-冯·诺依曼瓶颈" class="headerlink" title="12-2-冯·诺依曼瓶颈"></a>12.2  冯·诺依曼瓶颈</h2>
<p>冯·诺依曼瓶颈的概念最早由 John Backus 在 1977 年的图灵奖领奖演讲中提出： <strong>由于 CPU 和存储器之间共享同一个系统总线，并且 CPU 和存储器之间存在巨大的速度差，导致 CPU 需要不断地被迫等待数据读取或写入到存储器，因此遏制了 CPU 的吞吐量</strong></p>
<p>要从根本上解决冯·诺依曼瓶颈，还是只能重新构建一套新的计算机体系，例如生物计算机、量子计算机。不过，目前它们都还处在非常原始的阶段。现代计算机体系只能采用优化策略来减弱冯·诺依曼瓶颈的影响。</p>
<h2 id="12-3-总结"><a href="#12-3-总结" class="headerlink" title="12-3-总结"></a>12.3 总结</h2>
<p><strong>如果说图灵机描述的是计算机的抽象模型，那么冯·诺依曼架构则是对图灵机这个抽象模型的实现架构。</strong> 冯诺依曼架构确立了现代电子计算机的基础和结构，学习计算机组成原理，其实就是学习和拆解冯诺依曼架构。</p>
<p class='item-img' data-src='image-20231119111138054.png'><img src="image-20231119111138054.png" alt="image-20231119111138054"></p>
<h1>0x12 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a20020107020/article/details/130255261">字长与端序</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">字节序探析：大端与小端的比较</a></p>
<p><a target="_blank" rel="noopener" href="http://www.008ct.top/blog/2020/05/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%B4%E7%90%86/">汇编指令入门级整理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/k5210202/p/13365499.html">汇编基础之三 – 汇编指令</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/01%20%20%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%9A%84%E9%87%91%E5%AD%97%E5%A1%94.md"><strong>01 冯·诺依曼体系结构：计算机组成的金字塔</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://mdnice.com/writing/ba4b3af843a84652adef7fae7380da07">一套用了 70 年的计算机架构 —— 冯·诺依曼架构</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/11/21/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%A4%84%E7%BD%AE/">← 下一篇 </a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/11/14/Pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/">Pickle反序列化 上一篇 →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">0x01 什么是汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 汇编语言产生的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%B1%87%E7%BC%96%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 汇编与二进制的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">0x02 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 寄存器作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AD%98%E5%8F%96%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 存取速度比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 寄存器分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E9%80%94"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 常用寄存器用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%AF%84%E5%AD%98%E5%99%A8EAX%E3%80%81AX%E3%80%81AH%E3%80%81AL%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 寄存器EAX、AX、AH、AL的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 段寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">0x03 内存模型：Heap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">0x04 内存模型：Stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">0x05 CPU 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-push-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 push 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-call-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 call 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-mov-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 mov 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-add-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 add 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-pop-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 pop 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-ret-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 ret 指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">0x06 汇编语言指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 数据传送指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 算术运算指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 逻辑运算指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 循环控制指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-JCC%E6%8C%87%E4%BB%A4%E7%BB%84"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 JCC指令组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E5%A0%86%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 堆栈指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="toc-number">6.8.</span> <span class="toc-text">6.8 跳转指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">0x07 linux 和 windows 下汇编的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">0x08 什么是字长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">0x09 大端与小端的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 可读性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E6%A3%80%E6%9F%A5%E5%A5%87%E5%81%B6%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 检查奇偶性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E6%A3%80%E6%9F%A5%E6%AD%A3%E8%B4%9F%E5%8F%B7"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 检查正负号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F"><span class="toc-number">9.5.</span> <span class="toc-text">9.5 比较大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-%E4%B9%98%E6%B3%95"><span class="toc-number">9.6.</span> <span class="toc-text">9.6 乘法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E6%95%B4%E6%95%B0"><span class="toc-number">9.7.</span> <span class="toc-text">9.7 任意精度整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-%E6%9B%B4%E6%94%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.8.</span> <span class="toc-text">9.8 更改类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-%E6%80%BB%E7%BB%93"><span class="toc-number">9.9.</span> <span class="toc-text">9.9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">0x10 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">0x11 冯诺依曼结构体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 计算机的基本硬件组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 冯·诺依曼体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%93%B6%E9%A2%88"><span class="toc-number">11.3.</span> <span class="toc-text">12.2  冯·诺依曼瓶颈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E6%80%BB%E7%BB%93"><span class="toc-number">11.4.</span> <span class="toc-text">12.3 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">0x12 参考文章</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>